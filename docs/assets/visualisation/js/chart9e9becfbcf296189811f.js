(self["webpackChunkdi_website"] = self["webpackChunkdi_website"] || []).push([["vendors-node_modules_plotly_js_lib_core_js"],{

/***/ "./node_modules/plotly.js/build/plotcss.js":
/*!*************************************************!*\
  !*** ./node_modules/plotly.js/build/plotcss.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Lib = __webpack_require__(/*! ../src/lib */ "./node_modules/plotly.js/src/lib/index.js");
var rules = {
    "X,X div": "direction:ltr;font-family:'Open Sans', verdana, arial, sans-serif;margin:0;padding:0;",
    "X input,X button": "font-family:'Open Sans', verdana, arial, sans-serif;",
    "X input:focus,X button:focus": "outline:none;",
    "X a": "text-decoration:none;",
    "X a:hover": "text-decoration:none;",
    "X .crisp": "shape-rendering:crispEdges;",
    "X .user-select-none": "-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none;",
    "X svg": "overflow:hidden;",
    "X svg a": "fill:#447adb;",
    "X svg a:hover": "fill:#3c6dc5;",
    "X .main-svg": "position:absolute;top:0;left:0;pointer-events:none;",
    "X .main-svg .draglayer": "pointer-events:all;",
    "X .cursor-default": "cursor:default;",
    "X .cursor-pointer": "cursor:pointer;",
    "X .cursor-crosshair": "cursor:crosshair;",
    "X .cursor-move": "cursor:move;",
    "X .cursor-col-resize": "cursor:col-resize;",
    "X .cursor-row-resize": "cursor:row-resize;",
    "X .cursor-ns-resize": "cursor:ns-resize;",
    "X .cursor-ew-resize": "cursor:ew-resize;",
    "X .cursor-sw-resize": "cursor:sw-resize;",
    "X .cursor-s-resize": "cursor:s-resize;",
    "X .cursor-se-resize": "cursor:se-resize;",
    "X .cursor-w-resize": "cursor:w-resize;",
    "X .cursor-e-resize": "cursor:e-resize;",
    "X .cursor-nw-resize": "cursor:nw-resize;",
    "X .cursor-n-resize": "cursor:n-resize;",
    "X .cursor-ne-resize": "cursor:ne-resize;",
    "X .cursor-grab": "cursor:-webkit-grab;cursor:grab;",
    "X .modebar": "position:absolute;top:2px;right:2px;",
    "X .ease-bg": "-webkit-transition:background-color 0.3s ease 0s;-moz-transition:background-color 0.3s ease 0s;-ms-transition:background-color 0.3s ease 0s;-o-transition:background-color 0.3s ease 0s;transition:background-color 0.3s ease 0s;",
    "X .modebar--hover>:not(.watermark)": "opacity:0;-webkit-transition:opacity 0.3s ease 0s;-moz-transition:opacity 0.3s ease 0s;-ms-transition:opacity 0.3s ease 0s;-o-transition:opacity 0.3s ease 0s;transition:opacity 0.3s ease 0s;",
    "X:hover .modebar--hover .modebar-group": "opacity:1;",
    "X .modebar-group": "float:left;display:inline-block;box-sizing:border-box;padding-left:8px;position:relative;vertical-align:middle;white-space:nowrap;",
    "X .modebar-btn": "position:relative;font-size:16px;padding:3px 4px;height:22px;cursor:pointer;line-height:normal;box-sizing:border-box;",
    "X .modebar-btn svg": "position:relative;top:2px;",
    "X .modebar.vertical": "display:flex;flex-direction:column;flex-wrap:wrap;align-content:flex-end;max-height:100%;",
    "X .modebar.vertical svg": "top:-1px;",
    "X .modebar.vertical .modebar-group": "display:block;float:none;padding-left:0px;padding-bottom:8px;",
    "X .modebar.vertical .modebar-group .modebar-btn": "display:block;text-align:center;",
    "X [data-title]:before,X [data-title]:after": "position:absolute;-webkit-transform:translate3d(0, 0, 0);-moz-transform:translate3d(0, 0, 0);-ms-transform:translate3d(0, 0, 0);-o-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);display:none;opacity:0;z-index:1001;pointer-events:none;top:110%;right:50%;",
    "X [data-title]:hover:before,X [data-title]:hover:after": "display:block;opacity:1;",
    "X [data-title]:before": "content:'';position:absolute;background:transparent;border:6px solid transparent;z-index:1002;margin-top:-12px;border-bottom-color:#69738a;margin-right:-6px;",
    "X [data-title]:after": "content:attr(data-title);background:#69738a;color:white;padding:8px 10px;font-size:12px;line-height:12px;white-space:nowrap;margin-right:-18px;border-radius:2px;",
    "X .vertical [data-title]:before,X .vertical [data-title]:after": "top:0%;right:200%;",
    "X .vertical [data-title]:before": "border:6px solid transparent;border-left-color:#69738a;margin-top:8px;margin-right:-30px;",
    "X .select-outline": "fill:none;stroke-width:1;shape-rendering:crispEdges;",
    "X .select-outline-1": "stroke:white;",
    "X .select-outline-2": "stroke:black;stroke-dasharray:2px 2px;",
    Y: "font-family:'Open Sans', verdana, arial, sans-serif;position:fixed;top:50px;right:20px;z-index:10000;font-size:10pt;max-width:180px;",
    "Y p": "margin:0;",
    "Y .notifier-note": "min-width:180px;max-width:250px;border:1px solid #fff;z-index:3000;margin:0;background-color:#8c97af;background-color:rgba(140,151,175,0.9);color:#fff;padding:10px;overflow-wrap:break-word;word-wrap:break-word;-ms-hyphens:auto;-webkit-hyphens:auto;hyphens:auto;",
    "Y .notifier-close": "color:#fff;opacity:0.8;float:right;padding:0 5px;background:none;border:none;font-size:20px;font-weight:bold;line-height:20px;",
    "Y .notifier-close:hover": "color:#444;text-decoration:none;cursor:pointer;"
};

for(var selector in rules) {
    var fullSelector = selector.replace(/^,/,' ,')
        .replace(/X/g, '.js-plotly-plot .plotly')
        .replace(/Y/g, '.plotly-notifier');
    Lib.addStyleRule(fullSelector, rules[selector]);
}


/***/ }),

/***/ "./node_modules/plotly.js/lib/core.js":
/*!********************************************!*\
  !*** ./node_modules/plotly.js/lib/core.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/core */ "./node_modules/plotly.js/src/core.js");


/***/ }),

/***/ "./node_modules/plotly.js/node_modules/es6-promise/dist/es6-promise.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/plotly.js/node_modules/es6-promise/dist/es6-promise.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.8+1e68dce6
 */

(function (global, factory) {
	 true ? module.exports = factory() :
	0;
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    var then$$1 = void 0;
    try {
      then$$1 = value.then;
    } catch (error) {
      reject(promise, error);
      return;
    }
    handleMaybeThenable(promise, value, then$$1);
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = true;

  if (hasCallback) {
    try {
      value = callback(detail);
    } catch (e) {
      succeeded = false;
      error = e;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (succeeded === false) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = void 0;
      var error = void 0;
      var didError = false;
      try {
        _then = entry.then;
      } catch (e) {
        didError = true;
        error = e;
      }

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        if (didError) {
          reject(promise, error);
        } else {
          handleMaybeThenable(promise, entry, _then);
        }
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof __webpack_require__.g !== 'undefined') {
    local = __webpack_require__.g;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));



//# sourceMappingURL=es6-promise.map


/***/ }),

/***/ "./node_modules/plotly.js/src/components/annotations/calc_autorange.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/annotations/calc_autorange.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Axes = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js");

var draw = __webpack_require__(/*! ./draw */ "./node_modules/plotly.js/src/components/annotations/draw.js").draw;


module.exports = function calcAutorange(gd) {
    var fullLayout = gd._fullLayout;
    var annotationList = Lib.filterVisible(fullLayout.annotations);

    if(annotationList.length && gd._fullData.length) {
        return Lib.syncOrAsync([draw, annAutorange], gd);
    }
};

function annAutorange(gd) {
    var fullLayout = gd._fullLayout;

    // find the bounding boxes for each of these annotations'
    // relative to their anchor points
    // use the arrow and the text bg rectangle,
    // as the whole anno may include hidden text in its bbox
    Lib.filterVisible(fullLayout.annotations).forEach(function(ann) {
        var xa = Axes.getFromId(gd, ann.xref);
        var ya = Axes.getFromId(gd, ann.yref);

        ann._extremes = {};
        if(xa) calcAxisExpansion(ann, xa);
        if(ya) calcAxisExpansion(ann, ya);
    });
}

function calcAxisExpansion(ann, ax) {
    var axId = ax._id;
    var letter = axId.charAt(0);
    var pos = ann[letter];
    var apos = ann['a' + letter];
    var ref = ann[letter + 'ref'];
    var aref = ann['a' + letter + 'ref'];
    var padplus = ann['_' + letter + 'padplus'];
    var padminus = ann['_' + letter + 'padminus'];
    var shift = {x: 1, y: -1}[letter] * ann[letter + 'shift'];
    var headSize = 3 * ann.arrowsize * ann.arrowwidth || 0;
    var headPlus = headSize + shift;
    var headMinus = headSize - shift;
    var startHeadSize = 3 * ann.startarrowsize * ann.arrowwidth || 0;
    var startHeadPlus = startHeadSize + shift;
    var startHeadMinus = startHeadSize - shift;
    var extremes;

    if(aref === ref) {
        // expand for the arrowhead (padded by arrowhead)
        var extremeArrowHead = Axes.findExtremes(ax, [ax.r2c(pos)], {
            ppadplus: headPlus,
            ppadminus: headMinus
        });
        // again for the textbox (padded by textbox)
        var extremeText = Axes.findExtremes(ax, [ax.r2c(apos)], {
            ppadplus: Math.max(padplus, startHeadPlus),
            ppadminus: Math.max(padminus, startHeadMinus)
        });
        extremes = {
            min: [extremeArrowHead.min[0], extremeText.min[0]],
            max: [extremeArrowHead.max[0], extremeText.max[0]]
        };
    } else {
        startHeadPlus = apos ? startHeadPlus + apos : startHeadPlus;
        startHeadMinus = apos ? startHeadMinus - apos : startHeadMinus;
        extremes = Axes.findExtremes(ax, [ax.r2c(pos)], {
            ppadplus: Math.max(padplus, headPlus, startHeadPlus),
            ppadminus: Math.max(padminus, headMinus, startHeadMinus)
        });
    }

    ann._extremes[axId] = extremes;
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/annotations/click.js":
/*!********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/annotations/click.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Registry = __webpack_require__(/*! ../../registry */ "./node_modules/plotly.js/src/registry.js");
var arrayEditor = __webpack_require__(/*! ../../plot_api/plot_template */ "./node_modules/plotly.js/src/plot_api/plot_template.js").arrayEditor;

module.exports = {
    hasClickToShow: hasClickToShow,
    onClick: onClick
};

/*
 * hasClickToShow: does the given hoverData have ANY annotations which will
 * turn ON if we click here? (used by hover events to set cursor)
 *
 * gd: graphDiv
 * hoverData: a hoverData array, as included with the *plotly_hover* or
 *     *plotly_click* events in the `points` attribute
 *
 * returns: boolean
 */
function hasClickToShow(gd, hoverData) {
    var sets = getToggleSets(gd, hoverData);
    return sets.on.length > 0 || sets.explicitOff.length > 0;
}

/*
 * onClick: perform the toggling (via Plotly.update) implied by clicking
 * at this hoverData
 *
 * gd: graphDiv
 * hoverData: a hoverData array, as included with the *plotly_hover* or
 *     *plotly_click* events in the `points` attribute
 *
 * returns: Promise that the update is complete
 */
function onClick(gd, hoverData) {
    var toggleSets = getToggleSets(gd, hoverData);
    var onSet = toggleSets.on;
    var offSet = toggleSets.off.concat(toggleSets.explicitOff);
    var update = {};
    var annotationsOut = gd._fullLayout.annotations;
    var i, editHelpers;

    if(!(onSet.length || offSet.length)) return;

    for(i = 0; i < onSet.length; i++) {
        editHelpers = arrayEditor(gd.layout, 'annotations', annotationsOut[onSet[i]]);
        editHelpers.modifyItem('visible', true);
        Lib.extendFlat(update, editHelpers.getUpdateObj());
    }

    for(i = 0; i < offSet.length; i++) {
        editHelpers = arrayEditor(gd.layout, 'annotations', annotationsOut[offSet[i]]);
        editHelpers.modifyItem('visible', false);
        Lib.extendFlat(update, editHelpers.getUpdateObj());
    }

    return Registry.call('update', gd, {}, update);
}

/*
 * getToggleSets: find the annotations which will turn on or off at this
 * hoverData
 *
 * gd: graphDiv
 * hoverData: a hoverData array, as included with the *plotly_hover* or
 *     *plotly_click* events in the `points` attribute
 *
 * returns: {
 *   on: Array (indices of annotations to turn on),
 *   off: Array (indices to turn off because you're not hovering on them),
 *   explicitOff: Array (indices to turn off because you *are* hovering on them)
 * }
 */
function getToggleSets(gd, hoverData) {
    var annotations = gd._fullLayout.annotations;
    var onSet = [];
    var offSet = [];
    var explicitOffSet = [];
    var hoverLen = (hoverData || []).length;

    var i, j, anni, showMode, pointj, xa, ya, toggleType;

    for(i = 0; i < annotations.length; i++) {
        anni = annotations[i];
        showMode = anni.clicktoshow;

        if(showMode) {
            for(j = 0; j < hoverLen; j++) {
                pointj = hoverData[j];
                xa = pointj.xaxis;
                ya = pointj.yaxis;

                if(xa._id === anni.xref &&
                    ya._id === anni.yref &&
                    xa.d2r(pointj.x) === clickData2r(anni._xclick, xa) &&
                    ya.d2r(pointj.y) === clickData2r(anni._yclick, ya)
                ) {
                    // match! toggle this annotation
                    // regardless of its clicktoshow mode
                    // but if it's onout mode, off is implicit
                    if(anni.visible) {
                        if(showMode === 'onout') toggleType = offSet;
                        else toggleType = explicitOffSet;
                    } else {
                        toggleType = onSet;
                    }
                    toggleType.push(i);
                    break;
                }
            }

            if(j === hoverLen) {
                // no match - only turn this annotation OFF, and only if
                // showmode is 'onout'
                if(anni.visible && showMode === 'onout') offSet.push(i);
            }
        }
    }

    return {on: onSet, off: offSet, explicitOff: explicitOffSet};
}

// to handle log axes until v2
function clickData2r(d, ax) {
    return ax.type === 'log' ? ax.l2r(d) : ax.d2r(d);
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/annotations/common_defaults.js":
/*!******************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/annotations/common_defaults.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Color = __webpack_require__(/*! ../color */ "./node_modules/plotly.js/src/components/color/index.js");

// defaults common to 'annotations' and 'annotations3d'
module.exports = function handleAnnotationCommonDefaults(annIn, annOut, fullLayout, coerce) {
    coerce('opacity');
    var bgColor = coerce('bgcolor');

    var borderColor = coerce('bordercolor');
    var borderOpacity = Color.opacity(borderColor);

    coerce('borderpad');

    var borderWidth = coerce('borderwidth');
    var showArrow = coerce('showarrow');

    coerce('text', showArrow ? ' ' : fullLayout._dfltTitle.annotation);
    coerce('textangle');
    Lib.coerceFont(coerce, 'font', fullLayout.font);

    coerce('width');
    coerce('align');

    var h = coerce('height');
    if(h) coerce('valign');

    if(showArrow) {
        var arrowside = coerce('arrowside');
        var arrowhead;
        var arrowsize;

        if(arrowside.indexOf('end') !== -1) {
            arrowhead = coerce('arrowhead');
            arrowsize = coerce('arrowsize');
        }

        if(arrowside.indexOf('start') !== -1) {
            coerce('startarrowhead', arrowhead);
            coerce('startarrowsize', arrowsize);
        }
        coerce('arrowcolor', borderOpacity ? annOut.bordercolor : Color.defaultLine);
        coerce('arrowwidth', ((borderOpacity && borderWidth) || 1) * 2);
        coerce('standoff');
        coerce('startstandoff');
    }

    var hoverText = coerce('hovertext');
    var globalHoverLabel = fullLayout.hoverlabel || {};

    if(hoverText) {
        var hoverBG = coerce('hoverlabel.bgcolor', globalHoverLabel.bgcolor ||
            (Color.opacity(bgColor) ? Color.rgb(bgColor) : Color.defaultLine)
        );

        var hoverBorder = coerce('hoverlabel.bordercolor', globalHoverLabel.bordercolor ||
            Color.contrast(hoverBG)
        );

        Lib.coerceFont(coerce, 'hoverlabel.font', {
            family: globalHoverLabel.font.family,
            size: globalHoverLabel.font.size,
            color: globalHoverLabel.font.color || hoverBorder
        });
    }

    coerce('captureevents', !!hoverText);
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/annotations/convert_coords.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/annotations/convert_coords.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var isNumeric = __webpack_require__(/*! fast-isnumeric */ "./node_modules/fast-isnumeric/index.js");
var toLogRange = __webpack_require__(/*! ../../lib/to_log_range */ "./node_modules/plotly.js/src/lib/to_log_range.js");

/*
 * convertCoords: when converting an axis between log and linear
 * you need to alter any annotations on that axis to keep them
 * pointing at the same data point.
 * In v2.0 this will become obsolete
 *
 * gd: the plot div
 * ax: the axis being changed
 * newType: the type it's getting
 * doExtra: function(attr, val) from inside relayout that sets the attribute.
 *     Use this to make the changes as it's aware if any other changes in the
 *     same relayout call should override this conversion.
 */
module.exports = function convertCoords(gd, ax, newType, doExtra) {
    ax = ax || {};

    var toLog = (newType === 'log') && (ax.type === 'linear');
    var fromLog = (newType === 'linear') && (ax.type === 'log');

    if(!(toLog || fromLog)) return;

    var annotations = gd._fullLayout.annotations;
    var axLetter = ax._id.charAt(0);
    var ann;
    var attrPrefix;

    function convert(attr) {
        var currentVal = ann[attr];
        var newVal = null;

        if(toLog) newVal = toLogRange(currentVal, ax.range);
        else newVal = Math.pow(10, currentVal);

        // if conversion failed, delete the value so it gets a default value
        if(!isNumeric(newVal)) newVal = null;

        doExtra(attrPrefix + attr, newVal);
    }

    for(var i = 0; i < annotations.length; i++) {
        ann = annotations[i];
        attrPrefix = 'annotations[' + i + '].';

        if(ann[axLetter + 'ref'] === ax._id) convert(axLetter);
        if(ann['a' + axLetter + 'ref'] === ax._id) convert('a' + axLetter);
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/annotations/defaults.js":
/*!***********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/annotations/defaults.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Axes = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js");
var handleArrayContainerDefaults = __webpack_require__(/*! ../../plots/array_container_defaults */ "./node_modules/plotly.js/src/plots/array_container_defaults.js");

var handleAnnotationCommonDefaults = __webpack_require__(/*! ./common_defaults */ "./node_modules/plotly.js/src/components/annotations/common_defaults.js");
var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/annotations/attributes.js");


module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
    handleArrayContainerDefaults(layoutIn, layoutOut, {
        name: 'annotations',
        handleItemDefaults: handleAnnotationDefaults
    });
};

function handleAnnotationDefaults(annIn, annOut, fullLayout) {
    function coerce(attr, dflt) {
        return Lib.coerce(annIn, annOut, attributes, attr, dflt);
    }

    var visible = coerce('visible');
    var clickToShow = coerce('clicktoshow');

    if(!(visible || clickToShow)) return;

    handleAnnotationCommonDefaults(annIn, annOut, fullLayout, coerce);

    var showArrow = annOut.showarrow;

    // positioning
    var axLetters = ['x', 'y'];
    var arrowPosDflt = [-10, -30];
    var gdMock = {_fullLayout: fullLayout};

    for(var i = 0; i < 2; i++) {
        var axLetter = axLetters[i];

        // xref, yref
        var axRef = Axes.coerceRef(annIn, annOut, gdMock, axLetter, '', 'paper');

        if(axRef !== 'paper') {
            var ax = Axes.getFromId(gdMock, axRef);
            ax._annIndices.push(annOut._index);
        }

        // x, y
        Axes.coercePosition(annOut, gdMock, coerce, axRef, axLetter, 0.5);

        if(showArrow) {
            var arrowPosAttr = 'a' + axLetter;
            // axref, ayref
            var aaxRef = Axes.coerceRef(annIn, annOut, gdMock, arrowPosAttr, 'pixel');

            // for now the arrow can only be on the same axis or specified as pixels
            // TODO: sometime it might be interesting to allow it to be on *any* axis
            // but that would require updates to drawing & autorange code and maybe more
            if(aaxRef !== 'pixel' && aaxRef !== axRef) {
                aaxRef = annOut[arrowPosAttr] = 'pixel';
            }

            // ax, ay
            var aDflt = (aaxRef === 'pixel') ? arrowPosDflt[i] : 0.4;
            Axes.coercePosition(annOut, gdMock, coerce, aaxRef, arrowPosAttr, aDflt);
        }

        // xanchor, yanchor
        coerce(axLetter + 'anchor');

        // xshift, yshift
        coerce(axLetter + 'shift');
    }

    // if you have one coordinate you should have both
    Lib.noneOrAll(annIn, annOut, ['x', 'y']);

    // if you have one part of arrow length you should have both
    if(showArrow) {
        Lib.noneOrAll(annIn, annOut, ['ax', 'ay']);
    }

    if(clickToShow) {
        var xClick = coerce('xclick');
        var yClick = coerce('yclick');

        // put the actual click data to bind to into private attributes
        // so we don't have to do this little bit of logic on every hover event
        annOut._xclick = (xClick === undefined) ?
            annOut.x :
            Axes.cleanPosition(xClick, gdMock, annOut.xref);
        annOut._yclick = (yClick === undefined) ?
            annOut.y :
            Axes.cleanPosition(yClick, gdMock, annOut.yref);
    }
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/annotations/draw.js":
/*!*******************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/annotations/draw.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");

var Registry = __webpack_require__(/*! ../../registry */ "./node_modules/plotly.js/src/registry.js");
var Plots = __webpack_require__(/*! ../../plots/plots */ "./node_modules/plotly.js/src/plots/plots.js");
var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Axes = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js");
var Color = __webpack_require__(/*! ../color */ "./node_modules/plotly.js/src/components/color/index.js");
var Drawing = __webpack_require__(/*! ../drawing */ "./node_modules/plotly.js/src/components/drawing/index.js");
var Fx = __webpack_require__(/*! ../fx */ "./node_modules/plotly.js/src/components/fx/index.js");
var svgTextUtils = __webpack_require__(/*! ../../lib/svg_text_utils */ "./node_modules/plotly.js/src/lib/svg_text_utils.js");
var setCursor = __webpack_require__(/*! ../../lib/setcursor */ "./node_modules/plotly.js/src/lib/setcursor.js");
var dragElement = __webpack_require__(/*! ../dragelement */ "./node_modules/plotly.js/src/components/dragelement/index.js");
var arrayEditor = __webpack_require__(/*! ../../plot_api/plot_template */ "./node_modules/plotly.js/src/plot_api/plot_template.js").arrayEditor;

var drawArrowHead = __webpack_require__(/*! ./draw_arrow_head */ "./node_modules/plotly.js/src/components/annotations/draw_arrow_head.js");

// Annotations are stored in gd.layout.annotations, an array of objects
// index can point to one item in this array,
//  or non-numeric to simply add a new one
//  or -1 to modify all existing
// opt can be the full options object, or one key (to be set to value)
//  or undefined to simply redraw
// if opt is blank, val can be 'add' or a full options object to add a new
//  annotation at that point in the array, or 'remove' to delete this one

module.exports = {
    draw: draw,
    drawOne: drawOne,
    drawRaw: drawRaw
};

/*
 * draw: draw all annotations without any new modifications
 */
function draw(gd) {
    var fullLayout = gd._fullLayout;

    fullLayout._infolayer.selectAll('.annotation').remove();

    for(var i = 0; i < fullLayout.annotations.length; i++) {
        if(fullLayout.annotations[i].visible) {
            drawOne(gd, i);
        }
    }

    return Plots.previousPromises(gd);
}

/*
 * drawOne: draw a single cartesian or paper-ref annotation, potentially with modifications
 *
 * index (int): the annotation to draw
 */
function drawOne(gd, index) {
    var fullLayout = gd._fullLayout;
    var options = fullLayout.annotations[index] || {};
    var xa = Axes.getFromId(gd, options.xref);
    var ya = Axes.getFromId(gd, options.yref);

    if(xa) xa.setScale();
    if(ya) ya.setScale();

    drawRaw(gd, options, index, false, xa, ya);
}

/**
 * drawRaw: draw a single annotation, potentially with modifications
 *
 * @param {DOM element} gd
 * @param {object} options : this annotation's fullLayout options
 * @param {integer} index : index in 'annotations' container of the annotation to draw
 * @param {string} subplotId : id of the annotation's subplot
 *  - use false for 2d (i.e. cartesian or paper-ref) annotations
 * @param {object | undefined} xa : full x-axis object to compute subplot pos-to-px
 * @param {object | undefined} ya : ... y-axis
 */
function drawRaw(gd, options, index, subplotId, xa, ya) {
    var fullLayout = gd._fullLayout;
    var gs = gd._fullLayout._size;
    var edits = gd._context.edits;

    var className, containerStr;

    if(subplotId) {
        className = 'annotation-' + subplotId;
        containerStr = subplotId + '.annotations';
    } else {
        className = 'annotation';
        containerStr = 'annotations';
    }

    var editHelpers = arrayEditor(gd.layout, containerStr, options);
    var modifyBase = editHelpers.modifyBase;
    var modifyItem = editHelpers.modifyItem;
    var getUpdateObj = editHelpers.getUpdateObj;

    // remove the existing annotation if there is one
    fullLayout._infolayer
        .selectAll('.' + className + '[data-index="' + index + '"]')
        .remove();

    var annClipID = 'clip' + fullLayout._uid + '_ann' + index;

    // this annotation is gone - quit now after deleting it
    // TODO: use d3 idioms instead of deleting and redrawing every time
    if(!options._input || options.visible === false) {
        d3.selectAll('#' + annClipID).remove();
        return;
    }

    // calculated pixel positions
    // x & y each will get text, head, and tail as appropriate
    var annPosPx = {x: {}, y: {}};
    var textangle = +options.textangle || 0;

    // create the components
    // made a single group to contain all, so opacity can work right
    // with border/arrow together this could handle a whole bunch of
    // cleanup at this point, but works for now
    var annGroup = fullLayout._infolayer.append('g')
        .classed(className, true)
        .attr('data-index', String(index))
        .style('opacity', options.opacity);

    // another group for text+background so that they can rotate together
    var annTextGroup = annGroup.append('g')
        .classed('annotation-text-g', true);

    var editTextPosition = edits[options.showarrow ? 'annotationTail' : 'annotationPosition'];
    var textEvents = options.captureevents || edits.annotationText || editTextPosition;

    function makeEventData(initialEvent) {
        var eventData = {
            index: index,
            annotation: options._input,
            fullAnnotation: options,
            event: initialEvent
        };
        if(subplotId) {
            eventData.subplotId = subplotId;
        }
        return eventData;
    }

    var annTextGroupInner = annTextGroup.append('g')
        .style('pointer-events', textEvents ? 'all' : null)
        .call(setCursor, 'pointer')
        .on('click', function() {
            gd._dragging = false;
            gd.emit('plotly_clickannotation', makeEventData(d3.event));
        });

    if(options.hovertext) {
        annTextGroupInner
        .on('mouseover', function() {
            var hoverOptions = options.hoverlabel;
            var hoverFont = hoverOptions.font;
            var bBox = this.getBoundingClientRect();
            var bBoxRef = gd.getBoundingClientRect();

            Fx.loneHover({
                x0: bBox.left - bBoxRef.left,
                x1: bBox.right - bBoxRef.left,
                y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,
                text: options.hovertext,
                color: hoverOptions.bgcolor,
                borderColor: hoverOptions.bordercolor,
                fontFamily: hoverFont.family,
                fontSize: hoverFont.size,
                fontColor: hoverFont.color
            }, {
                container: fullLayout._hoverlayer.node(),
                outerContainer: fullLayout._paper.node(),
                gd: gd
            });
        })
        .on('mouseout', function() {
            Fx.loneUnhover(fullLayout._hoverlayer.node());
        });
    }

    var borderwidth = options.borderwidth;
    var borderpad = options.borderpad;
    var borderfull = borderwidth + borderpad;

    var annTextBG = annTextGroupInner.append('rect')
        .attr('class', 'bg')
        .style('stroke-width', borderwidth + 'px')
        .call(Color.stroke, options.bordercolor)
        .call(Color.fill, options.bgcolor);

    var isSizeConstrained = options.width || options.height;

    var annTextClip = fullLayout._topclips
        .selectAll('#' + annClipID)
        .data(isSizeConstrained ? [0] : []);

    annTextClip.enter().append('clipPath')
        .classed('annclip', true)
        .attr('id', annClipID)
      .append('rect');
    annTextClip.exit().remove();

    var font = options.font;

    var text = fullLayout._meta ?
        Lib.templateString(options.text, fullLayout._meta) :
        options.text;

    var annText = annTextGroupInner.append('text')
        .classed('annotation-text', true)
        .text(text);

    function textLayout(s) {
        s.call(Drawing.font, font)
        .attr({
            'text-anchor': {
                left: 'start',
                right: 'end'
            }[options.align] || 'middle'
        });

        svgTextUtils.convertToTspans(s, gd, drawGraphicalElements);
        return s;
    }

    function drawGraphicalElements() {
        // if the text has *only* a link, make the whole box into a link
        var anchor3 = annText.selectAll('a');
        if(anchor3.size() === 1 && anchor3.text() === annText.text()) {
            var wholeLink = annTextGroupInner.insert('a', ':first-child').attr({
                'xlink:xlink:href': anchor3.attr('xlink:href'),
                'xlink:xlink:show': anchor3.attr('xlink:show')
            })
            .style({cursor: 'pointer'});

            wholeLink.node().appendChild(annTextBG.node());
        }

        var mathjaxGroup = annTextGroupInner.select('.annotation-text-math-group');
        var hasMathjax = !mathjaxGroup.empty();
        var anntextBB = Drawing.bBox(
                (hasMathjax ? mathjaxGroup : annText).node());
        var textWidth = anntextBB.width;
        var textHeight = anntextBB.height;
        var annWidth = options.width || textWidth;
        var annHeight = options.height || textHeight;
        var outerWidth = Math.round(annWidth + 2 * borderfull);
        var outerHeight = Math.round(annHeight + 2 * borderfull);

        function shiftFraction(v, anchor) {
            if(anchor === 'auto') {
                if(v < 1 / 3) anchor = 'left';
                else if(v > 2 / 3) anchor = 'right';
                else anchor = 'center';
            }
            return {
                center: 0,
                middle: 0,
                left: 0.5,
                bottom: -0.5,
                right: -0.5,
                top: 0.5
            }[anchor];
        }

        var annotationIsOffscreen = false;
        var letters = ['x', 'y'];

        for(var i = 0; i < letters.length; i++) {
            var axLetter = letters[i];
            var axRef = options[axLetter + 'ref'] || axLetter;
            var tailRef = options['a' + axLetter + 'ref'];
            var ax = {x: xa, y: ya}[axLetter];
            var dimAngle = (textangle + (axLetter === 'x' ? 0 : -90)) * Math.PI / 180;
            // note that these two can be either positive or negative
            var annSizeFromWidth = outerWidth * Math.cos(dimAngle);
            var annSizeFromHeight = outerHeight * Math.sin(dimAngle);
            // but this one is the positive total size
            var annSize = Math.abs(annSizeFromWidth) + Math.abs(annSizeFromHeight);
            var anchor = options[axLetter + 'anchor'];
            var overallShift = options[axLetter + 'shift'] * (axLetter === 'x' ? 1 : -1);
            var posPx = annPosPx[axLetter];
            var basePx;
            var textPadShift;
            var alignPosition;
            var autoAlignFraction;
            var textShift;

            /*
             * calculate the *primary* pixel position
             * which is the arrowhead if there is one,
             * otherwise the text anchor point
             */
            if(ax) {
                // check if annotation is off screen, to bypass DOM manipulations
                var posFraction = ax.r2fraction(options[axLetter]);
                if(posFraction < 0 || posFraction > 1) {
                    if(tailRef === axRef) {
                        posFraction = ax.r2fraction(options['a' + axLetter]);
                        if(posFraction < 0 || posFraction > 1) {
                            annotationIsOffscreen = true;
                        }
                    } else {
                        annotationIsOffscreen = true;
                    }
                }
                basePx = ax._offset + ax.r2p(options[axLetter]);
                autoAlignFraction = 0.5;
            } else {
                if(axLetter === 'x') {
                    alignPosition = options[axLetter];
                    basePx = gs.l + gs.w * alignPosition;
                } else {
                    alignPosition = 1 - options[axLetter];
                    basePx = gs.t + gs.h * alignPosition;
                }
                autoAlignFraction = options.showarrow ? 0.5 : alignPosition;
            }

            // now translate this into pixel positions of head, tail, and text
            // as well as paddings for autorange
            if(options.showarrow) {
                posPx.head = basePx;

                var arrowLength = options['a' + axLetter];

                // with an arrow, the text rotates around the anchor point
                textShift = annSizeFromWidth * shiftFraction(0.5, options.xanchor) -
                    annSizeFromHeight * shiftFraction(0.5, options.yanchor);

                if(tailRef === axRef) {
                    posPx.tail = ax._offset + ax.r2p(arrowLength);
                    // tail is data-referenced: autorange pads the text in px from the tail
                    textPadShift = textShift;
                } else {
                    posPx.tail = basePx + arrowLength;
                    // tail is specified in px from head, so autorange also pads vs head
                    textPadShift = textShift + arrowLength;
                }

                posPx.text = posPx.tail + textShift;

                // constrain pixel/paper referenced so the draggers are at least
                // partially visible
                var maxPx = fullLayout[(axLetter === 'x') ? 'width' : 'height'];
                if(axRef === 'paper') {
                    posPx.head = Lib.constrain(posPx.head, 1, maxPx - 1);
                }
                if(tailRef === 'pixel') {
                    var shiftPlus = -Math.max(posPx.tail - 3, posPx.text);
                    var shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;
                    if(shiftPlus > 0) {
                        posPx.tail += shiftPlus;
                        posPx.text += shiftPlus;
                    } else if(shiftMinus > 0) {
                        posPx.tail -= shiftMinus;
                        posPx.text -= shiftMinus;
                    }
                }

                posPx.tail += overallShift;
                posPx.head += overallShift;
            } else {
                // with no arrow, the text rotates and *then* we put the anchor
                // relative to the new bounding box
                textShift = annSize * shiftFraction(autoAlignFraction, anchor);
                textPadShift = textShift;
                posPx.text = basePx + textShift;
            }

            posPx.text += overallShift;
            textShift += overallShift;
            textPadShift += overallShift;

            // padplus/minus are used by autorange
            options['_' + axLetter + 'padplus'] = (annSize / 2) + textPadShift;
            options['_' + axLetter + 'padminus'] = (annSize / 2) - textPadShift;

            // size/shift are used during dragging
            options['_' + axLetter + 'size'] = annSize;
            options['_' + axLetter + 'shift'] = textShift;
        }

        if(annotationIsOffscreen) {
            annTextGroupInner.remove();
            return;
        }

        var xShift = 0;
        var yShift = 0;

        if(options.align !== 'left') {
            xShift = (annWidth - textWidth) * (options.align === 'center' ? 0.5 : 1);
        }
        if(options.valign !== 'top') {
            yShift = (annHeight - textHeight) * (options.valign === 'middle' ? 0.5 : 1);
        }

        if(hasMathjax) {
            mathjaxGroup.select('svg').attr({
                x: borderfull + xShift - 1,
                y: borderfull + yShift
            })
            .call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);
        } else {
            var texty = borderfull + yShift - anntextBB.top;
            var textx = borderfull + xShift - anntextBB.left;

            annText.call(svgTextUtils.positionText, textx, texty)
                .call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);
        }

        annTextClip.select('rect').call(Drawing.setRect, borderfull, borderfull,
            annWidth, annHeight);

        annTextBG.call(Drawing.setRect, borderwidth / 2, borderwidth / 2,
            outerWidth - borderwidth, outerHeight - borderwidth);

        annTextGroupInner.call(Drawing.setTranslate,
            Math.round(annPosPx.x.text - outerWidth / 2),
            Math.round(annPosPx.y.text - outerHeight / 2));

        /*
         * rotate text and background
         * we already calculated the text center position *as rotated*
         * because we needed that for autoranging anyway, so now whether
         * we have an arrow or not, we rotate about the text center.
         */
        annTextGroup.attr({transform: 'rotate(' + textangle + ',' +
                            annPosPx.x.text + ',' + annPosPx.y.text + ')'});

        /*
         * add the arrow
         * uses options[arrowwidth,arrowcolor,arrowhead] for styling
         * dx and dy are normally zero, but when you are dragging the textbox
         * while the head stays put, dx and dy are the pixel offsets
         */
        var drawArrow = function(dx, dy) {
            annGroup
                .selectAll('.annotation-arrow-g')
                .remove();

            var headX = annPosPx.x.head;
            var headY = annPosPx.y.head;
            var tailX = annPosPx.x.tail + dx;
            var tailY = annPosPx.y.tail + dy;
            var textX = annPosPx.x.text + dx;
            var textY = annPosPx.y.text + dy;

            // find the edge of the text box, where we'll start the arrow:
            // create transform matrix to rotate the text box corners
            var transform = Lib.rotationXYMatrix(textangle, textX, textY);
            var applyTransform = Lib.apply2DTransform(transform);
            var applyTransform2 = Lib.apply2DTransform2(transform);

            // calculate and transform bounding box
            var width = +annTextBG.attr('width');
            var height = +annTextBG.attr('height');
            var xLeft = textX - 0.5 * width;
            var xRight = xLeft + width;
            var yTop = textY - 0.5 * height;
            var yBottom = yTop + height;
            var edges = [
                [xLeft, yTop, xLeft, yBottom],
                [xLeft, yBottom, xRight, yBottom],
                [xRight, yBottom, xRight, yTop],
                [xRight, yTop, xLeft, yTop]
            ].map(applyTransform2);

            // Remove the line if it ends inside the box.  Use ray
            // casting for rotated boxes: see which edges intersect a
            // line from the arrowhead to far away and reduce with xor
            // to get the parity of the number of intersections.
            if(edges.reduce(function(a, x) {
                return a ^
                    !!Lib.segmentsIntersect(headX, headY, headX + 1e6, headY + 1e6,
                            x[0], x[1], x[2], x[3]);
            }, false)) {
                // no line or arrow - so quit drawArrow now
                return;
            }

            edges.forEach(function(x) {
                var p = Lib.segmentsIntersect(tailX, tailY, headX, headY,
                            x[0], x[1], x[2], x[3]);
                if(p) {
                    tailX = p.x;
                    tailY = p.y;
                }
            });

            var strokewidth = options.arrowwidth;
            var arrowColor = options.arrowcolor;
            var arrowSide = options.arrowside;

            var arrowGroup = annGroup.append('g')
                .style({opacity: Color.opacity(arrowColor)})
                .classed('annotation-arrow-g', true);

            var arrow = arrowGroup.append('path')
                .attr('d', 'M' + tailX + ',' + tailY + 'L' + headX + ',' + headY)
                .style('stroke-width', strokewidth + 'px')
                .call(Color.stroke, Color.rgb(arrowColor));

            drawArrowHead(arrow, arrowSide, options);

            // the arrow dragger is a small square right at the head, then a line to the tail,
            // all expanded by a stroke width of 6px plus the arrow line width
            if(edits.annotationPosition && arrow.node().parentNode && !subplotId) {
                var arrowDragHeadX = headX;
                var arrowDragHeadY = headY;
                if(options.standoff) {
                    var arrowLength = Math.sqrt(Math.pow(headX - tailX, 2) + Math.pow(headY - tailY, 2));
                    arrowDragHeadX += options.standoff * (tailX - headX) / arrowLength;
                    arrowDragHeadY += options.standoff * (tailY - headY) / arrowLength;
                }
                var arrowDrag = arrowGroup.append('path')
                    .classed('annotation-arrow', true)
                    .classed('anndrag', true)
                    .classed('cursor-move', true)
                    .attr({
                        d: 'M3,3H-3V-3H3ZM0,0L' + (tailX - arrowDragHeadX) + ',' + (tailY - arrowDragHeadY),
                        transform: 'translate(' + arrowDragHeadX + ',' + arrowDragHeadY + ')'
                    })
                    .style('stroke-width', (strokewidth + 6) + 'px')
                    .call(Color.stroke, 'rgba(0,0,0,0)')
                    .call(Color.fill, 'rgba(0,0,0,0)');

                var annx0, anny0;

                // dragger for the arrow & head: translates the whole thing
                // (head/tail/text) all together
                dragElement.init({
                    element: arrowDrag.node(),
                    gd: gd,
                    prepFn: function() {
                        var pos = Drawing.getTranslate(annTextGroupInner);

                        annx0 = pos.x;
                        anny0 = pos.y;
                        if(xa && xa.autorange) {
                            modifyBase(xa._name + '.autorange', true);
                        }
                        if(ya && ya.autorange) {
                            modifyBase(ya._name + '.autorange', true);
                        }
                    },
                    moveFn: function(dx, dy) {
                        var annxy0 = applyTransform(annx0, anny0);
                        var xcenter = annxy0[0] + dx;
                        var ycenter = annxy0[1] + dy;
                        annTextGroupInner.call(Drawing.setTranslate, xcenter, ycenter);

                        modifyItem('x', xa ?
                            xa.p2r(xa.r2p(options.x) + dx) :
                            (options.x + (dx / gs.w)));
                        modifyItem('y', ya ?
                            ya.p2r(ya.r2p(options.y) + dy) :
                            (options.y - (dy / gs.h)));

                        if(options.axref === options.xref) {
                            modifyItem('ax', xa.p2r(xa.r2p(options.ax) + dx));
                        }

                        if(options.ayref === options.yref) {
                            modifyItem('ay', ya.p2r(ya.r2p(options.ay) + dy));
                        }

                        arrowGroup.attr('transform', 'translate(' + dx + ',' + dy + ')');
                        annTextGroup.attr({
                            transform: 'rotate(' + textangle + ',' +
                                   xcenter + ',' + ycenter + ')'
                        });
                    },
                    doneFn: function() {
                        Registry.call('_guiRelayout', gd, getUpdateObj());
                        var notesBox = document.querySelector('.js-notes-box-panel');
                        if(notesBox) notesBox.redraw(notesBox.selectedObj);
                    }
                });
            }
        };

        if(options.showarrow) drawArrow(0, 0);

        // user dragging the annotation (text, not arrow)
        if(editTextPosition) {
            var baseTextTransform;

            // dragger for the textbox: if there's an arrow, just drag the
            // textbox and tail, leave the head untouched
            dragElement.init({
                element: annTextGroupInner.node(),
                gd: gd,
                prepFn: function() {
                    baseTextTransform = annTextGroup.attr('transform');
                },
                moveFn: function(dx, dy) {
                    var csr = 'pointer';
                    if(options.showarrow) {
                        if(options.axref === options.xref) {
                            modifyItem('ax', xa.p2r(xa.r2p(options.ax) + dx));
                        } else {
                            modifyItem('ax', options.ax + dx);
                        }

                        if(options.ayref === options.yref) {
                            modifyItem('ay', ya.p2r(ya.r2p(options.ay) + dy));
                        } else {
                            modifyItem('ay', options.ay + dy);
                        }

                        drawArrow(dx, dy);
                    } else if(!subplotId) {
                        var xUpdate, yUpdate;
                        if(xa) {
                            xUpdate = xa.p2r(xa.r2p(options.x) + dx);
                        } else {
                            var widthFraction = options._xsize / gs.w;
                            var xLeft = options.x + (options._xshift - options.xshift) / gs.w - widthFraction / 2;

                            xUpdate = dragElement.align(xLeft + dx / gs.w,
                                widthFraction, 0, 1, options.xanchor);
                        }

                        if(ya) {
                            yUpdate = ya.p2r(ya.r2p(options.y) + dy);
                        } else {
                            var heightFraction = options._ysize / gs.h;
                            var yBottom = options.y - (options._yshift + options.yshift) / gs.h - heightFraction / 2;

                            yUpdate = dragElement.align(yBottom - dy / gs.h,
                                heightFraction, 0, 1, options.yanchor);
                        }
                        modifyItem('x', xUpdate);
                        modifyItem('y', yUpdate);
                        if(!xa || !ya) {
                            csr = dragElement.getCursor(
                                xa ? 0.5 : xUpdate,
                                ya ? 0.5 : yUpdate,
                                options.xanchor, options.yanchor
                            );
                        }
                    } else return;

                    annTextGroup.attr({
                        transform: 'translate(' + dx + ',' + dy + ')' + baseTextTransform
                    });

                    setCursor(annTextGroupInner, csr);
                },
                clickFn: function(_, initialEvent) {
                    if(options.captureevents) {
                        gd.emit('plotly_clickannotation', makeEventData(initialEvent));
                    }
                },
                doneFn: function() {
                    setCursor(annTextGroupInner);
                    Registry.call('_guiRelayout', gd, getUpdateObj());
                    var notesBox = document.querySelector('.js-notes-box-panel');
                    if(notesBox) notesBox.redraw(notesBox.selectedObj);
                }
            });
        }
    }

    if(edits.annotationText) {
        annText.call(svgTextUtils.makeEditable, {delegate: annTextGroupInner, gd: gd})
            .call(textLayout)
            .on('edit', function(_text) {
                options.text = _text;

                this.call(textLayout);

                modifyItem('text', _text);

                if(xa && xa.autorange) {
                    modifyBase(xa._name + '.autorange', true);
                }
                if(ya && ya.autorange) {
                    modifyBase(ya._name + '.autorange', true);
                }

                Registry.call('_guiRelayout', gd, getUpdateObj());
            });
    } else annText.call(textLayout);
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/annotations/draw_arrow_head.js":
/*!******************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/annotations/draw_arrow_head.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");

var Color = __webpack_require__(/*! ../color */ "./node_modules/plotly.js/src/components/color/index.js");

var ARROWPATHS = __webpack_require__(/*! ./arrow_paths */ "./node_modules/plotly.js/src/components/annotations/arrow_paths.js");

/**
 * Add arrowhead(s) to a path or line element
 *
 * @param {d3.selection} el3: a d3-selected line or path element
 *
 * @param {string} ends: 'none', 'start', 'end', or 'start+end' for which ends get arrowheads
 *
 * @param {object} options: style information. Must have all the following:
 * @param {number} options.arrowhead: end head style - see ./arrow_paths
 * @param {number} options.startarrowhead: start head style - see ./arrow_paths
 * @param {number} options.arrowsize: relative size of the end head vs line width
 * @param {number} options.startarrowsize: relative size of the start head vs line width
 * @param {number} options.standoff: distance in px to move the end arrow point from its target
 * @param {number} options.startstandoff: distance in px to move the start arrow point from its target
 * @param {number} options.arrowwidth: width of the arrow line
 * @param {string} options.arrowcolor: color of the arrow line, for the head to match
 *     Note that the opacity of this color is ignored, as it's assumed the container
 *     of both the line and head has opacity applied to it so there isn't greater opacity
 *     where they overlap.
 */
module.exports = function drawArrowHead(el3, ends, options) {
    var el = el3.node();
    var headStyle = ARROWPATHS[options.arrowhead || 0];
    var startHeadStyle = ARROWPATHS[options.startarrowhead || 0];
    var scale = (options.arrowwidth || 1) * (options.arrowsize || 1);
    var startScale = (options.arrowwidth || 1) * (options.startarrowsize || 1);
    var doStart = ends.indexOf('start') >= 0;
    var doEnd = ends.indexOf('end') >= 0;
    var backOff = headStyle.backoff * scale + options.standoff;
    var startBackOff = startHeadStyle.backoff * startScale + options.startstandoff;

    var start, end, startRot, endRot;

    if(el.nodeName === 'line') {
        start = {x: +el3.attr('x1'), y: +el3.attr('y1')};
        end = {x: +el3.attr('x2'), y: +el3.attr('y2')};

        var dx = start.x - end.x;
        var dy = start.y - end.y;

        startRot = Math.atan2(dy, dx);
        endRot = startRot + Math.PI;
        if(backOff && startBackOff) {
            if(backOff + startBackOff > Math.sqrt(dx * dx + dy * dy)) {
                hideLine();
                return;
            }
        }

        if(backOff) {
            if(backOff * backOff > dx * dx + dy * dy) {
                hideLine();
                return;
            }
            var backOffX = backOff * Math.cos(startRot);
            var backOffY = backOff * Math.sin(startRot);

            end.x += backOffX;
            end.y += backOffY;
            el3.attr({x2: end.x, y2: end.y});
        }

        if(startBackOff) {
            if(startBackOff * startBackOff > dx * dx + dy * dy) {
                hideLine();
                return;
            }
            var startBackOffX = startBackOff * Math.cos(startRot);
            var startbackOffY = startBackOff * Math.sin(startRot);

            start.x -= startBackOffX;
            start.y -= startbackOffY;
            el3.attr({x1: start.x, y1: start.y});
        }
    } else if(el.nodeName === 'path') {
        var pathlen = el.getTotalLength();
        // using dash to hide the backOff region of the path.
        // if we ever allow dash for the arrow we'll have to
        // do better than this hack... maybe just manually
        // combine the two
        var dashArray = '';

        if(pathlen < backOff + startBackOff) {
            hideLine();
            return;
        }


        var start0 = el.getPointAtLength(0);
        var dstart = el.getPointAtLength(0.1);

        startRot = Math.atan2(start0.y - dstart.y, start0.x - dstart.x);
        start = el.getPointAtLength(Math.min(startBackOff, pathlen));

        dashArray = '0px,' + startBackOff + 'px,';

        var end0 = el.getPointAtLength(pathlen);
        var dend = el.getPointAtLength(pathlen - 0.1);

        endRot = Math.atan2(end0.y - dend.y, end0.x - dend.x);
        end = el.getPointAtLength(Math.max(0, pathlen - backOff));

        var shortening = dashArray ? startBackOff + backOff : backOff;
        dashArray += (pathlen - shortening) + 'px,' + pathlen + 'px';

        el3.style('stroke-dasharray', dashArray);
    }

    function hideLine() { el3.style('stroke-dasharray', '0px,100px'); }

    function drawhead(arrowHeadStyle, p, rot, arrowScale) {
        if(!arrowHeadStyle.path) return;
        if(arrowHeadStyle.noRotate) rot = 0;

        d3.select(el.parentNode).append('path')
            .attr({
                'class': el3.attr('class'),
                d: arrowHeadStyle.path,
                transform:
                    'translate(' + p.x + ',' + p.y + ')' +
                    (rot ? 'rotate(' + (rot * 180 / Math.PI) + ')' : '') +
                    'scale(' + arrowScale + ')'
            })
            .style({
                fill: Color.rgb(options.arrowcolor),
                'stroke-width': 0
            });
    }

    if(doStart) drawhead(startHeadStyle, start, startRot, startScale);
    if(doEnd) drawhead(headStyle, end, endRot, scale);
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/annotations/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/annotations/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var drawModule = __webpack_require__(/*! ./draw */ "./node_modules/plotly.js/src/components/annotations/draw.js");
var clickModule = __webpack_require__(/*! ./click */ "./node_modules/plotly.js/src/components/annotations/click.js");

module.exports = {
    moduleType: 'component',
    name: 'annotations',

    layoutAttributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/annotations/attributes.js"),
    supplyLayoutDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/components/annotations/defaults.js"),
    includeBasePlot: __webpack_require__(/*! ../../plots/cartesian/include_components */ "./node_modules/plotly.js/src/plots/cartesian/include_components.js")('annotations'),

    calcAutorange: __webpack_require__(/*! ./calc_autorange */ "./node_modules/plotly.js/src/components/annotations/calc_autorange.js"),
    draw: drawModule.draw,
    drawOne: drawModule.drawOne,
    drawRaw: drawModule.drawRaw,

    hasClickToShow: clickModule.hasClickToShow,
    onClick: clickModule.onClick,

    convertCoords: __webpack_require__(/*! ./convert_coords */ "./node_modules/plotly.js/src/components/annotations/convert_coords.js")
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/annotations3d/attributes.js":
/*!***************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/annotations3d/attributes.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var annAttrs = __webpack_require__(/*! ../annotations/attributes */ "./node_modules/plotly.js/src/components/annotations/attributes.js");
var overrideAll = __webpack_require__(/*! ../../plot_api/edit_types */ "./node_modules/plotly.js/src/plot_api/edit_types.js").overrideAll;
var templatedArray = __webpack_require__(/*! ../../plot_api/plot_template */ "./node_modules/plotly.js/src/plot_api/plot_template.js").templatedArray;

module.exports = overrideAll(templatedArray('annotation', {
    visible: annAttrs.visible,
    x: {
        valType: 'any',
        role: 'info',
        description: [
            'Sets the annotation\'s x position.'
        ].join(' ')
    },
    y: {
        valType: 'any',
        role: 'info',
        description: [
            'Sets the annotation\'s y position.'
        ].join(' ')
    },
    z: {
        valType: 'any',
        role: 'info',
        description: [
            'Sets the annotation\'s z position.'
        ].join(' ')
    },
    ax: {
        valType: 'number',
        role: 'info',
        description: [
            'Sets the x component of the arrow tail about the arrow head (in pixels).'
        ].join(' ')
    },
    ay: {
        valType: 'number',
        role: 'info',
        description: [
            'Sets the y component of the arrow tail about the arrow head (in pixels).'
        ].join(' ')
    },

    xanchor: annAttrs.xanchor,
    xshift: annAttrs.xshift,
    yanchor: annAttrs.yanchor,
    yshift: annAttrs.yshift,

    text: annAttrs.text,
    textangle: annAttrs.textangle,
    font: annAttrs.font,
    width: annAttrs.width,
    height: annAttrs.height,
    opacity: annAttrs.opacity,
    align: annAttrs.align,
    valign: annAttrs.valign,
    bgcolor: annAttrs.bgcolor,
    bordercolor: annAttrs.bordercolor,
    borderpad: annAttrs.borderpad,
    borderwidth: annAttrs.borderwidth,
    showarrow: annAttrs.showarrow,
    arrowcolor: annAttrs.arrowcolor,
    arrowhead: annAttrs.arrowhead,
    startarrowhead: annAttrs.startarrowhead,
    arrowside: annAttrs.arrowside,
    arrowsize: annAttrs.arrowsize,
    startarrowsize: annAttrs.startarrowsize,
    arrowwidth: annAttrs.arrowwidth,
    standoff: annAttrs.standoff,
    startstandoff: annAttrs.startstandoff,
    hovertext: annAttrs.hovertext,
    hoverlabel: annAttrs.hoverlabel,
    captureevents: annAttrs.captureevents,

    // maybes later?
    // clicktoshow: annAttrs.clicktoshow,
    // xclick: annAttrs.xclick,
    // yclick: annAttrs.yclick,

    // not needed!
    // axref: 'pixel'
    // ayref: 'pixel'
    // xref: 'x'
    // yref: 'y
    // zref: 'z'
}), 'calc', 'from-root');


/***/ }),

/***/ "./node_modules/plotly.js/src/components/annotations3d/convert.js":
/*!************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/annotations3d/convert.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Axes = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js");

module.exports = function convert(scene) {
    var fullSceneLayout = scene.fullSceneLayout;
    var anns = fullSceneLayout.annotations;

    for(var i = 0; i < anns.length; i++) {
        mockAnnAxes(anns[i], scene);
    }

    scene.fullLayout._infolayer
        .selectAll('.annotation-' + scene.id)
        .remove();
};

function mockAnnAxes(ann, scene) {
    var fullSceneLayout = scene.fullSceneLayout;
    var domain = fullSceneLayout.domain;
    var size = scene.fullLayout._size;

    var base = {
        // this gets fill in on render
        pdata: null,

        // to get setConvert to not execute cleanly
        type: 'linear',

        // don't try to update them on `editable: true`
        autorange: false,

        // set infinite range so that annotation draw routine
        // does not try to remove 'outside-range' annotations,
        // this case is handled in the render loop
        range: [-Infinity, Infinity]
    };

    ann._xa = {};
    Lib.extendFlat(ann._xa, base);
    Axes.setConvert(ann._xa);
    ann._xa._offset = size.l + domain.x[0] * size.w;
    ann._xa.l2p = function() {
        return 0.5 * (1 + ann._pdata[0] / ann._pdata[3]) * size.w * (domain.x[1] - domain.x[0]);
    };

    ann._ya = {};
    Lib.extendFlat(ann._ya, base);
    Axes.setConvert(ann._ya);
    ann._ya._offset = size.t + (1 - domain.y[1]) * size.h;
    ann._ya.l2p = function() {
        return 0.5 * (1 - ann._pdata[1] / ann._pdata[3]) * size.h * (domain.y[1] - domain.y[0]);
    };
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/annotations3d/defaults.js":
/*!*************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/annotations3d/defaults.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Axes = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js");
var handleArrayContainerDefaults = __webpack_require__(/*! ../../plots/array_container_defaults */ "./node_modules/plotly.js/src/plots/array_container_defaults.js");
var handleAnnotationCommonDefaults = __webpack_require__(/*! ../annotations/common_defaults */ "./node_modules/plotly.js/src/components/annotations/common_defaults.js");
var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/annotations3d/attributes.js");

module.exports = function handleDefaults(sceneLayoutIn, sceneLayoutOut, opts) {
    handleArrayContainerDefaults(sceneLayoutIn, sceneLayoutOut, {
        name: 'annotations',
        handleItemDefaults: handleAnnotationDefaults,
        fullLayout: opts.fullLayout
    });
};

function handleAnnotationDefaults(annIn, annOut, sceneLayout, opts) {
    function coerce(attr, dflt) {
        return Lib.coerce(annIn, annOut, attributes, attr, dflt);
    }

    function coercePosition(axLetter) {
        var axName = axLetter + 'axis';

        // mock in such way that getFromId grabs correct 3D axis
        var gdMock = { _fullLayout: {} };
        gdMock._fullLayout[axName] = sceneLayout[axName];

        return Axes.coercePosition(annOut, gdMock, coerce, axLetter, axLetter, 0.5);
    }


    var visible = coerce('visible');
    if(!visible) return;

    handleAnnotationCommonDefaults(annIn, annOut, opts.fullLayout, coerce);

    coercePosition('x');
    coercePosition('y');
    coercePosition('z');

    // if you have one coordinate you should all three
    Lib.noneOrAll(annIn, annOut, ['x', 'y', 'z']);

    // hard-set here for completeness
    annOut.xref = 'x';
    annOut.yref = 'y';
    annOut.zref = 'z';

    coerce('xanchor');
    coerce('yanchor');
    coerce('xshift');
    coerce('yshift');

    if(annOut.showarrow) {
        annOut.axref = 'pixel';
        annOut.ayref = 'pixel';

        // TODO maybe default values should be bigger than the 2D case?
        coerce('ax', -10);
        coerce('ay', -30);

        // if you have one part of arrow length you should have both
        Lib.noneOrAll(annIn, annOut, ['ax', 'ay']);
    }
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/annotations3d/draw.js":
/*!*********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/annotations3d/draw.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var drawRaw = __webpack_require__(/*! ../annotations/draw */ "./node_modules/plotly.js/src/components/annotations/draw.js").drawRaw;
var project = __webpack_require__(/*! ../../plots/gl3d/project */ "./node_modules/plotly.js/src/plots/gl3d/project.js");
var axLetters = ['x', 'y', 'z'];

module.exports = function draw(scene) {
    var fullSceneLayout = scene.fullSceneLayout;
    var dataScale = scene.dataScale;
    var anns = fullSceneLayout.annotations;

    for(var i = 0; i < anns.length; i++) {
        var ann = anns[i];
        var annotationIsOffscreen = false;

        for(var j = 0; j < 3; j++) {
            var axLetter = axLetters[j];
            var pos = ann[axLetter];
            var ax = fullSceneLayout[axLetter + 'axis'];
            var posFraction = ax.r2fraction(pos);

            if(posFraction < 0 || posFraction > 1) {
                annotationIsOffscreen = true;
                break;
            }
        }

        if(annotationIsOffscreen) {
            scene.fullLayout._infolayer
                .select('.annotation-' + scene.id + '[data-index="' + i + '"]')
                .remove();
        } else {
            ann._pdata = project(scene.glplot.cameraParams, [
                fullSceneLayout.xaxis.r2l(ann.x) * dataScale[0],
                fullSceneLayout.yaxis.r2l(ann.y) * dataScale[1],
                fullSceneLayout.zaxis.r2l(ann.z) * dataScale[2]
            ]);

            drawRaw(scene.graphDiv, ann, i, scene.id, ann._xa, ann._ya);
        }
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/annotations3d/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/annotations3d/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Registry = __webpack_require__(/*! ../../registry */ "./node_modules/plotly.js/src/registry.js");
var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");

module.exports = {
    moduleType: 'component',
    name: 'annotations3d',

    schema: {
        subplots: {
            scene: {annotations: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/annotations3d/attributes.js")}
        }
    },

    layoutAttributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/annotations3d/attributes.js"),
    handleDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/components/annotations3d/defaults.js"),
    includeBasePlot: includeGL3D,

    convert: __webpack_require__(/*! ./convert */ "./node_modules/plotly.js/src/components/annotations3d/convert.js"),
    draw: __webpack_require__(/*! ./draw */ "./node_modules/plotly.js/src/components/annotations3d/draw.js")
};

function includeGL3D(layoutIn, layoutOut) {
    var GL3D = Registry.subplotsRegistry.gl3d;
    if(!GL3D) return;

    var attrRegex = GL3D.attrRegex;

    var keys = Object.keys(layoutIn);
    for(var i = 0; i < keys.length; i++) {
        var k = keys[i];
        if(attrRegex.test(k) && (layoutIn[k].annotations || []).length) {
            Lib.pushUnique(layoutOut._basePlotModules, GL3D);
            Lib.pushUnique(layoutOut._subplots.gl3d, k);
        }
    }
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/colorbar/constants.js":
/*!*********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/colorbar/constants.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    cn: {
        colorbar: 'colorbar',
        cbbg: 'cbbg',
        cbfill: 'cbfill',
        cbfills: 'cbfills',
        cbline: 'cbline',
        cblines: 'cblines',
        cbaxis: 'cbaxis',
        cbtitleunshift: 'cbtitleunshift',
        cbtitle: 'cbtitle',
        cboutline: 'cboutline',
        crisp: 'crisp',
        jsPlaceholder: 'js-placeholder'
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/colorbar/draw.js":
/*!****************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/colorbar/draw.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");
var tinycolor = __webpack_require__(/*! tinycolor2 */ "./node_modules/tinycolor2/tinycolor.js");

var Plots = __webpack_require__(/*! ../../plots/plots */ "./node_modules/plotly.js/src/plots/plots.js");
var Registry = __webpack_require__(/*! ../../registry */ "./node_modules/plotly.js/src/registry.js");
var Axes = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js");
var dragElement = __webpack_require__(/*! ../dragelement */ "./node_modules/plotly.js/src/components/dragelement/index.js");
var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var extendFlat = __webpack_require__(/*! ../../lib/extend */ "./node_modules/plotly.js/src/lib/extend.js").extendFlat;
var setCursor = __webpack_require__(/*! ../../lib/setcursor */ "./node_modules/plotly.js/src/lib/setcursor.js");
var Drawing = __webpack_require__(/*! ../drawing */ "./node_modules/plotly.js/src/components/drawing/index.js");
var Color = __webpack_require__(/*! ../color */ "./node_modules/plotly.js/src/components/color/index.js");
var Titles = __webpack_require__(/*! ../titles */ "./node_modules/plotly.js/src/components/titles/index.js");
var svgTextUtils = __webpack_require__(/*! ../../lib/svg_text_utils */ "./node_modules/plotly.js/src/lib/svg_text_utils.js");
var flipScale = __webpack_require__(/*! ../colorscale/helpers */ "./node_modules/plotly.js/src/components/colorscale/helpers.js").flipScale;

var handleAxisDefaults = __webpack_require__(/*! ../../plots/cartesian/axis_defaults */ "./node_modules/plotly.js/src/plots/cartesian/axis_defaults.js");
var handleAxisPositionDefaults = __webpack_require__(/*! ../../plots/cartesian/position_defaults */ "./node_modules/plotly.js/src/plots/cartesian/position_defaults.js");
var axisLayoutAttrs = __webpack_require__(/*! ../../plots/cartesian/layout_attributes */ "./node_modules/plotly.js/src/plots/cartesian/layout_attributes.js");

var alignmentConstants = __webpack_require__(/*! ../../constants/alignment */ "./node_modules/plotly.js/src/constants/alignment.js");
var LINE_SPACING = alignmentConstants.LINE_SPACING;
var FROM_TL = alignmentConstants.FROM_TL;
var FROM_BR = alignmentConstants.FROM_BR;

var cn = __webpack_require__(/*! ./constants */ "./node_modules/plotly.js/src/components/colorbar/constants.js").cn;

function draw(gd) {
    var fullLayout = gd._fullLayout;

    var colorBars = fullLayout._infolayer
        .selectAll('g.' + cn.colorbar)
        .data(makeColorBarData(gd), function(opts) { return opts._id; });

    colorBars.enter().append('g')
        .attr('class', function(opts) { return opts._id; })
        .classed(cn.colorbar, true);

    colorBars.each(function(opts) {
        var g = d3.select(this);

        Lib.ensureSingle(g, 'rect', cn.cbbg);
        Lib.ensureSingle(g, 'g', cn.cbfills);
        Lib.ensureSingle(g, 'g', cn.cblines);
        Lib.ensureSingle(g, 'g', cn.cbaxis, function(s) { s.classed(cn.crisp, true); });
        Lib.ensureSingle(g, 'g', cn.cbtitleunshift, function(s) { s.append('g').classed(cn.cbtitle, true); });
        Lib.ensureSingle(g, 'rect', cn.cboutline);

        var done = drawColorBar(g, opts, gd);
        if(done && done.then) (gd._promises || []).push(done);

        if(gd._context.edits.colorbarPosition) {
            makeEditable(g, opts, gd);
        }
    });

    colorBars.exit()
        .each(function(opts) { Plots.autoMargin(gd, opts._id); })
        .remove();

    colorBars.order();
}

function makeColorBarData(gd) {
    var fullLayout = gd._fullLayout;
    var calcdata = gd.calcdata;
    var out = [];

    // single out item
    var opts;
    // colorbar attr parent container
    var cont;
    // trace attr container
    var trace;
    // colorbar options
    var cbOpt;

    function initOpts(opts) {
        return extendFlat(opts, {
            // fillcolor can be a d3 scale, domain is z values, range is colors
            // or leave it out for no fill,
            // or set to a string constant for single-color fill
            _fillcolor: null,
            // line.color has the same options as fillcolor
            _line: {color: null, width: null, dash: null},
            // levels of lines to draw.
            // note that this DOES NOT determine the extent of the bar
            // that's given by the domain of fillcolor
            // (or line.color if no fillcolor domain)
            _levels: {start: null, end: null, size: null},
            // separate fill levels (for example, heatmap coloring of a
            // contour map) if this is omitted, fillcolors will be
            // evaluated halfway between levels
            _filllevels: null,
            // for continuous colorscales: fill with a gradient instead of explicit levels
            // value should be the colorscale [[0, c0], [v1, c1], ..., [1, cEnd]]
            _fillgradient: null,
            // when using a gradient, we need the data range specified separately
            _zrange: null
        });
    }

    function calcOpts() {
        if(typeof cbOpt.calc === 'function') {
            cbOpt.calc(gd, trace, opts);
        } else {
            opts._fillgradient = cont.reversescale ?
                flipScale(cont.colorscale) :
                cont.colorscale;
            opts._zrange = [cont[cbOpt.min], cont[cbOpt.max]];
        }
    }

    for(var i = 0; i < calcdata.length; i++) {
        var cd = calcdata[i];
        trace = cd[0].trace;
        var moduleOpts = trace._module.colorbar;

        if(trace.visible === true && moduleOpts) {
            var allowsMultiplotCbs = Array.isArray(moduleOpts);
            var cbOpts = allowsMultiplotCbs ? moduleOpts : [moduleOpts];

            for(var j = 0; j < cbOpts.length; j++) {
                cbOpt = cbOpts[j];
                var contName = cbOpt.container;
                cont = contName ? trace[contName] : trace;

                if(cont && cont.showscale) {
                    opts = initOpts(cont.colorbar);
                    opts._id = 'cb' + trace.uid + (allowsMultiplotCbs && contName ? '-' + contName : '');
                    opts._traceIndex = trace.index;
                    opts._propPrefix = (contName ? contName + '.' : '') + 'colorbar.';
                    opts._meta = trace._meta;
                    calcOpts();
                    out.push(opts);
                }
            }
        }
    }

    for(var k in fullLayout._colorAxes) {
        cont = fullLayout[k];

        if(cont.showscale) {
            var colorAxOpts = fullLayout._colorAxes[k];

            opts = initOpts(cont.colorbar);
            opts._id = 'cb' + k;
            opts._propPrefix = k + '.colorbar.';
            opts._meta = fullLayout._meta;

            cbOpt = {min: 'cmin', max: 'cmax'};
            if(colorAxOpts[0] !== 'heatmap') {
                trace = colorAxOpts[1];
                cbOpt.calc = trace._module.colorbar.calc;
            }

            calcOpts();
            out.push(opts);
        }
    }

    return out;
}

function drawColorBar(g, opts, gd) {
    var fullLayout = gd._fullLayout;
    var gs = fullLayout._size;

    var fillColor = opts._fillcolor;
    var line = opts._line;
    var title = opts.title;
    var titleSide = title.side;

    var zrange = opts._zrange ||
        d3.extent((typeof fillColor === 'function' ? fillColor : line.color).domain());

    var lineColormap = typeof line.color === 'function' ?
        line.color :
        function() { return line.color; };
    var fillColormap = typeof fillColor === 'function' ?
        fillColor :
        function() { return fillColor; };

    var levelsIn = opts._levels;
    var levelsOut = calcLevels(gd, opts, zrange);
    var fillLevels = levelsOut.fill;
    var lineLevels = levelsOut.line;

    // we calculate pixel sizes based on the specified graph size,
    // not the actual (in case something pushed the margins around)
    // which is a little odd but avoids an odd iterative effect
    // when the colorbar itself is pushing the margins.
    // but then the fractional size is calculated based on the
    // actual graph size, so that the axes will size correctly.
    var thickPx = Math.round(opts.thickness * (opts.thicknessmode === 'fraction' ? gs.w : 1));
    var thickFrac = thickPx / gs.w;
    var lenPx = Math.round(opts.len * (opts.lenmode === 'fraction' ? gs.h : 1));
    var lenFrac = lenPx / gs.h;
    var xpadFrac = opts.xpad / gs.w;
    var yExtraPx = (opts.borderwidth + opts.outlinewidth) / 2;
    var ypadFrac = opts.ypad / gs.h;

    // x positioning: do it initially just for left anchor,
    // then fix at the end (since we don't know the width yet)
    var xLeft = Math.round(opts.x * gs.w + opts.xpad);
    // for dragging... this is getting a little muddled...
    var xLeftFrac = opts.x - thickFrac * ({middle: 0.5, right: 1}[opts.xanchor] || 0);

    // y positioning we can do correctly from the start
    var yBottomFrac = opts.y + lenFrac * (({top: -0.5, bottom: 0.5}[opts.yanchor] || 0) - 0.5);
    var yBottomPx = Math.round(gs.h * (1 - yBottomFrac));
    var yTopPx = yBottomPx - lenPx;

    // stash a few things for makeEditable
    opts._lenFrac = lenFrac;
    opts._thickFrac = thickFrac;
    opts._xLeftFrac = xLeftFrac;
    opts._yBottomFrac = yBottomFrac;

    // stash mocked axis for contour label formatting
    var ax = opts._axis = mockColorBarAxis(gd, opts, zrange);

    // position can't go in through supplyDefaults
    // because that restricts it to [0,1]
    ax.position = opts.x + xpadFrac + thickFrac;

    if(['top', 'bottom'].indexOf(titleSide) !== -1) {
        ax.title.side = titleSide;
        ax.titlex = opts.x + xpadFrac;
        ax.titley = yBottomFrac + (title.side === 'top' ? lenFrac - ypadFrac : ypadFrac);
    }

    if(line.color && opts.tickmode === 'auto') {
        ax.tickmode = 'linear';
        ax.tick0 = levelsIn.start;
        var dtick = levelsIn.size;
        // expand if too many contours, so we don't get too many ticks
        var autoNtick = Lib.constrain((yBottomPx - yTopPx) / 50, 4, 15) + 1;
        var dtFactor = (zrange[1] - zrange[0]) / ((opts.nticks || autoNtick) * dtick);
        if(dtFactor > 1) {
            var dtexp = Math.pow(10, Math.floor(Math.log(dtFactor) / Math.LN10));
            dtick *= dtexp * Lib.roundUp(dtFactor / dtexp, [2, 5, 10]);
            // if the contours are at round multiples, reset tick0
            // so they're still at round multiples. Otherwise,
            // keep the first label on the first contour level
            if((Math.abs(levelsIn.start) / levelsIn.size + 1e-6) % 1 < 2e-6) {
                ax.tick0 = 0;
            }
        }
        ax.dtick = dtick;
    }

    // set domain after init, because we may want to
    // allow it outside [0,1]
    ax.domain = [
        yBottomFrac + ypadFrac,
        yBottomFrac + lenFrac - ypadFrac
    ];

    ax.setScale();

    g.attr('transform', 'translate(' + Math.round(gs.l) + ',' + Math.round(gs.t) + ')');

    var titleCont = g.select('.' + cn.cbtitleunshift)
        .attr('transform', 'translate(-' + Math.round(gs.l) + ',-' + Math.round(gs.t) + ')');

    var axLayer = g.select('.' + cn.cbaxis);
    var titleEl;
    var titleHeight = 0;

    function drawTitle(titleClass, titleOpts) {
        var dfltTitleOpts = {
            propContainer: ax,
            propName: opts._propPrefix + 'title',
            traceIndex: opts._traceIndex,
            _meta: opts._meta,
            placeholder: fullLayout._dfltTitle.colorbar,
            containerGroup: g.select('.' + cn.cbtitle)
        };

        // this class-to-rotate thing with convertToTspans is
        // getting hackier and hackier... delete groups with the
        // wrong class (in case earlier the colorbar was drawn on
        // a different side, I think?)
        var otherClass = titleClass.charAt(0) === 'h' ?
            titleClass.substr(1) :
            'h' + titleClass;
        g.selectAll('.' + otherClass + ',.' + otherClass + '-math-group').remove();

        Titles.draw(gd, titleClass, extendFlat(dfltTitleOpts, titleOpts || {}));
    }

    function drawDummyTitle() {
        if(['top', 'bottom'].indexOf(titleSide) !== -1) {
            // draw the title so we know how much room it needs
            // when we squish the axis. This one only applies to
            // top or bottom titles, not right side.
            var x = gs.l + (opts.x + xpadFrac) * gs.w;
            var fontSize = ax.title.font.size;
            var y;

            if(titleSide === 'top') {
                y = (1 - (yBottomFrac + lenFrac - ypadFrac)) * gs.h +
                    gs.t + 3 + fontSize * 0.75;
            } else {
                y = (1 - (yBottomFrac + ypadFrac)) * gs.h +
                    gs.t - 3 - fontSize * 0.25;
            }
            drawTitle(ax._id + 'title', {
                attributes: {x: x, y: y, 'text-anchor': 'start'}
            });
        }
    }

    function drawCbTitle() {
        if(['top', 'bottom'].indexOf(titleSide) === -1) {
            var fontSize = ax.title.font.size;
            var y = ax._offset + ax._length / 2;
            var x = gs.l + (ax.position || 0) * gs.w + ((ax.side === 'right') ?
                10 + fontSize * ((ax.showticklabels ? 1 : 0.5)) :
                -10 - fontSize * ((ax.showticklabels ? 0.5 : 0)));

            // the 'h' + is a hack to get around the fact that
            // convertToTspans rotates any 'y...' class by 90 degrees.
            // TODO: find a better way to control this.
            drawTitle('h' + ax._id + 'title', {
                avoid: {
                    selection: d3.select(gd).selectAll('g.' + ax._id + 'tick'),
                    side: titleSide,
                    offsetLeft: gs.l,
                    offsetTop: 0,
                    maxShift: fullLayout.width
                },
                attributes: {x: x, y: y, 'text-anchor': 'middle'},
                transform: {rotate: '-90', offset: 0}
            });
        }
    }

    function drawAxis() {
        if(['top', 'bottom'].indexOf(titleSide) !== -1) {
            // squish the axis top to make room for the title
            var titleGroup = g.select('.' + cn.cbtitle);
            var titleText = titleGroup.select('text');
            var titleTrans = [-opts.outlinewidth / 2, opts.outlinewidth / 2];
            var mathJaxNode = titleGroup
                .select('.h' + ax._id + 'title-math-group')
                .node();
            var lineSize = 15.6;
            if(titleText.node()) {
                lineSize = parseInt(titleText.node().style.fontSize, 10) * LINE_SPACING;
            }
            if(mathJaxNode) {
                titleHeight = Drawing.bBox(mathJaxNode).height;
                if(titleHeight > lineSize) {
                    // not entirely sure how mathjax is doing
                    // vertical alignment, but this seems to work.
                    titleTrans[1] -= (titleHeight - lineSize) / 2;
                }
            } else if(titleText.node() && !titleText.classed(cn.jsPlaceholder)) {
                titleHeight = Drawing.bBox(titleText.node()).height;
            }
            if(titleHeight) {
                // buffer btwn colorbar and title
                // TODO: configurable
                titleHeight += 5;

                if(titleSide === 'top') {
                    ax.domain[1] -= titleHeight / gs.h;
                    titleTrans[1] *= -1;
                } else {
                    ax.domain[0] += titleHeight / gs.h;
                    var nlines = svgTextUtils.lineCount(titleText);
                    titleTrans[1] += (1 - nlines) * lineSize;
                }

                titleGroup.attr('transform', 'translate(' + titleTrans + ')');
                ax.setScale();
            }
        }

        g.selectAll('.' + cn.cbfills + ',.' + cn.cblines)
            .attr('transform', 'translate(0,' + Math.round(gs.h * (1 - ax.domain[1])) + ')');

        axLayer.attr('transform', 'translate(0,' + Math.round(-gs.t) + ')');

        var fills = g.select('.' + cn.cbfills)
            .selectAll('rect.' + cn.cbfill)
            .data(fillLevels);
        fills.enter().append('rect')
            .classed(cn.cbfill, true)
            .style('stroke', 'none');
        fills.exit().remove();

        var zBounds = zrange
            .map(ax.c2p)
            .map(Math.round)
            .sort(function(a, b) { return a - b; });

        fills.each(function(d, i) {
            var z = [
                (i === 0) ? zrange[0] : (fillLevels[i] + fillLevels[i - 1]) / 2,
                (i === fillLevels.length - 1) ? zrange[1] : (fillLevels[i] + fillLevels[i + 1]) / 2
            ]
            .map(ax.c2p)
            .map(Math.round);

            // offset the side adjoining the next rectangle so they
            // overlap, to prevent antialiasing gaps
            z[1] = Lib.constrain(z[1] + (z[1] > z[0]) ? 1 : -1, zBounds[0], zBounds[1]);


            // Colorbar cannot currently support opacities so we
            // use an opaque fill even when alpha channels present
            var fillEl = d3.select(this).attr({
                x: xLeft,
                width: Math.max(thickPx, 2),
                y: d3.min(z),
                height: Math.max(d3.max(z) - d3.min(z), 2),
            });

            if(opts._fillgradient) {
                Drawing.gradient(fillEl, gd, opts._id, 'vertical', opts._fillgradient, 'fill');
            } else {
                // tinycolor can't handle exponents and
                // at this scale, removing it makes no difference.
                var colorString = fillColormap(d).replace('e-', '');
                fillEl.attr('fill', tinycolor(colorString).toHexString());
            }
        });

        var lines = g.select('.' + cn.cblines)
            .selectAll('path.' + cn.cbline)
            .data(line.color && line.width ? lineLevels : []);
        lines.enter().append('path')
            .classed(cn.cbline, true);
        lines.exit().remove();
        lines.each(function(d) {
            d3.select(this)
                .attr('d', 'M' + xLeft + ',' +
                    (Math.round(ax.c2p(d)) + (line.width / 2) % 1) + 'h' + thickPx)
                .call(Drawing.lineGroupStyle, line.width, lineColormap(d), line.dash);
        });

        // force full redraw of labels and ticks
        axLayer.selectAll('g.' + ax._id + 'tick,path').remove();

        var shift = xLeft + thickPx +
            (opts.outlinewidth || 0) / 2 - (opts.ticks === 'outside' ? 1 : 0);

        var vals = Axes.calcTicks(ax);
        var transFn = Axes.makeTransFn(ax);
        var tickSign = Axes.getTickSigns(ax)[2];

        Axes.drawTicks(gd, ax, {
            vals: ax.ticks === 'inside' ? Axes.clipEnds(ax, vals) : vals,
            layer: axLayer,
            path: Axes.makeTickPath(ax, shift, tickSign),
            transFn: transFn
        });

        return Axes.drawLabels(gd, ax, {
            vals: vals,
            layer: axLayer,
            transFn: transFn,
            labelFns: Axes.makeLabelFns(ax, shift)
        });
    }

    // wait for the axis & title to finish rendering before
    // continuing positioning
    // TODO: why are we redrawing multiple times now with this?
    // I guess autoMargin doesn't like being post-promise?
    function positionCB() {
        var innerWidth = thickPx + opts.outlinewidth / 2 + Drawing.bBox(axLayer.node()).width;
        titleEl = titleCont.select('text');

        if(titleEl.node() && !titleEl.classed(cn.jsPlaceholder)) {
            var mathJaxNode = titleCont.select('.h' + ax._id + 'title-math-group').node();
            var titleWidth;
            if(mathJaxNode && ['top', 'bottom'].indexOf(titleSide) !== -1) {
                titleWidth = Drawing.bBox(mathJaxNode).width;
            } else {
                // note: the formula below works for all title sides,
                // (except for top/bottom mathjax, above)
                // but the weird gs.l is because the titleunshift
                // transform gets removed by Drawing.bBox
                titleWidth = Drawing.bBox(titleCont.node()).right - xLeft - gs.l;
            }
            innerWidth = Math.max(innerWidth, titleWidth);
        }

        var outerwidth = 2 * opts.xpad + innerWidth + opts.borderwidth + opts.outlinewidth / 2;
        var outerheight = yBottomPx - yTopPx;

        g.select('.' + cn.cbbg).attr({
            x: xLeft - opts.xpad - (opts.borderwidth + opts.outlinewidth) / 2,
            y: yTopPx - yExtraPx,
            width: Math.max(outerwidth, 2),
            height: Math.max(outerheight + 2 * yExtraPx, 2)
        })
        .call(Color.fill, opts.bgcolor)
        .call(Color.stroke, opts.bordercolor)
        .style('stroke-width', opts.borderwidth);

        g.selectAll('.' + cn.cboutline).attr({
            x: xLeft,
            y: yTopPx + opts.ypad + (titleSide === 'top' ? titleHeight : 0),
            width: Math.max(thickPx, 2),
            height: Math.max(outerheight - 2 * opts.ypad - titleHeight, 2)
        })
        .call(Color.stroke, opts.outlinecolor)
        .style({
            fill: 'none',
            'stroke-width': opts.outlinewidth
        });

        // fix positioning for xanchor!='left'
        var xoffset = ({center: 0.5, right: 1}[opts.xanchor] || 0) * outerwidth;
        g.attr('transform', 'translate(' + (gs.l - xoffset) + ',' + gs.t + ')');

        // auto margin adjustment
        var marginOpts = {};
        var tFrac = FROM_TL[opts.yanchor];
        var bFrac = FROM_BR[opts.yanchor];
        if(opts.lenmode === 'pixels') {
            marginOpts.y = opts.y;
            marginOpts.t = outerheight * tFrac;
            marginOpts.b = outerheight * bFrac;
        } else {
            marginOpts.t = marginOpts.b = 0;
            marginOpts.yt = opts.y + opts.len * tFrac;
            marginOpts.yb = opts.y - opts.len * bFrac;
        }

        var lFrac = FROM_TL[opts.xanchor];
        var rFrac = FROM_BR[opts.xanchor];
        if(opts.thicknessmode === 'pixels') {
            marginOpts.x = opts.x;
            marginOpts.l = outerwidth * lFrac;
            marginOpts.r = outerwidth * rFrac;
        } else {
            var extraThickness = outerwidth - thickPx;
            marginOpts.l = extraThickness * lFrac;
            marginOpts.r = extraThickness * rFrac;
            marginOpts.xl = opts.x - opts.thickness * lFrac;
            marginOpts.xr = opts.x + opts.thickness * rFrac;
        }

        Plots.autoMargin(gd, opts._id, marginOpts);
    }

    return Lib.syncOrAsync([
        Plots.previousPromises,
        drawDummyTitle,
        drawAxis,
        drawCbTitle,
        Plots.previousPromises,
        positionCB
    ], gd);
}

function makeEditable(g, opts, gd) {
    var fullLayout = gd._fullLayout;
    var gs = fullLayout._size;
    var t0, xf, yf;

    dragElement.init({
        element: g.node(),
        gd: gd,
        prepFn: function() {
            t0 = g.attr('transform');
            setCursor(g);
        },
        moveFn: function(dx, dy) {
            g.attr('transform', t0 + ' ' + 'translate(' + dx + ',' + dy + ')');

            xf = dragElement.align(opts._xLeftFrac + (dx / gs.w), opts._thickFrac,
                0, 1, opts.xanchor);
            yf = dragElement.align(opts._yBottomFrac - (dy / gs.h), opts._lenFrac,
                0, 1, opts.yanchor);

            var csr = dragElement.getCursor(xf, yf, opts.xanchor, opts.yanchor);
            setCursor(g, csr);
        },
        doneFn: function() {
            setCursor(g);

            if(xf !== undefined && yf !== undefined) {
                var update = {};
                update[opts._propPrefix + 'x'] = xf;
                update[opts._propPrefix + 'y'] = yf;
                if(opts._traceIndex !== undefined) {
                    Registry.call('_guiRestyle', gd, update, opts._traceIndex);
                } else {
                    Registry.call('_guiRelayout', gd, update);
                }
            }
        }
    });
}

function calcLevels(gd, opts, zrange) {
    var levelsIn = opts._levels;
    var lineLevels = [];
    var fillLevels = [];
    var l;
    var i;

    var l0 = levelsIn.end + levelsIn.size / 100;
    var ls = levelsIn.size;
    var zr0 = (1.001 * zrange[0] - 0.001 * zrange[1]);
    var zr1 = (1.001 * zrange[1] - 0.001 * zrange[0]);

    for(i = 0; i < 1e5; i++) {
        l = levelsIn.start + i * ls;
        if(ls > 0 ? (l >= l0) : (l <= l0)) break;
        if(l > zr0 && l < zr1) lineLevels.push(l);
    }

    if(opts._fillgradient) {
        fillLevels = [0];
    } else if(typeof opts._fillcolor === 'function') {
        var fillLevelsIn = opts._filllevels;

        if(fillLevelsIn) {
            l0 = fillLevelsIn.end + fillLevelsIn.size / 100;
            ls = fillLevelsIn.size;
            for(i = 0; i < 1e5; i++) {
                l = fillLevelsIn.start + i * ls;
                if(ls > 0 ? (l >= l0) : (l <= l0)) break;
                if(l > zrange[0] && l < zrange[1]) fillLevels.push(l);
            }
        } else {
            fillLevels = lineLevels.map(function(v) {
                return v - levelsIn.size / 2;
            });
            fillLevels.push(fillLevels[fillLevels.length - 1] + levelsIn.size);
        }
    } else if(opts._fillcolor && typeof opts._fillcolor === 'string') {
        // doesn't matter what this value is, with a single value
        // we'll make a single fill rect covering the whole bar
        fillLevels = [0];
    }

    if(levelsIn.size < 0) {
        lineLevels.reverse();
        fillLevels.reverse();
    }

    return {line: lineLevels, fill: fillLevels};
}

function mockColorBarAxis(gd, opts, zrange) {
    var fullLayout = gd._fullLayout;

    var cbAxisIn = {
        type: 'linear',
        range: zrange,
        tickmode: opts.tickmode,
        nticks: opts.nticks,
        tick0: opts.tick0,
        dtick: opts.dtick,
        tickvals: opts.tickvals,
        ticktext: opts.ticktext,
        ticks: opts.ticks,
        ticklen: opts.ticklen,
        tickwidth: opts.tickwidth,
        tickcolor: opts.tickcolor,
        showticklabels: opts.showticklabels,
        tickfont: opts.tickfont,
        tickangle: opts.tickangle,
        tickformat: opts.tickformat,
        exponentformat: opts.exponentformat,
        separatethousands: opts.separatethousands,
        showexponent: opts.showexponent,
        showtickprefix: opts.showtickprefix,
        tickprefix: opts.tickprefix,
        showticksuffix: opts.showticksuffix,
        ticksuffix: opts.ticksuffix,
        title: opts.title,
        showline: true,
        anchor: 'free',
        side: 'right',
        position: 1
    };

    var cbAxisOut = {
        type: 'linear',
        _id: 'y' + opts._id
    };

    var axisOptions = {
        letter: 'y',
        font: fullLayout.font,
        noHover: true,
        noTickson: true,
        calendar: fullLayout.calendar  // not really necessary (yet?)
    };

    function coerce(attr, dflt) {
        return Lib.coerce(cbAxisIn, cbAxisOut, axisLayoutAttrs, attr, dflt);
    }

    handleAxisDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions, fullLayout);
    handleAxisPositionDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions);

    return cbAxisOut;
}

module.exports = {
    draw: draw
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/colorbar/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/colorbar/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    moduleType: 'component',
    name: 'colorbar',

    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/colorbar/attributes.js"),
    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/components/colorbar/defaults.js"),

    draw: __webpack_require__(/*! ./draw */ "./node_modules/plotly.js/src/components/colorbar/draw.js").draw,
    hasColorbar: __webpack_require__(/*! ./has_colorbar */ "./node_modules/plotly.js/src/components/colorbar/has_colorbar.js")
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/errorbars/attributes.js":
/*!***********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/errorbars/attributes.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




module.exports = {
    visible: {
        valType: 'boolean',
        role: 'info',
        editType: 'calc',
        description: [
            'Determines whether or not this set of error bars is visible.'
        ].join(' ')
    },
    type: {
        valType: 'enumerated',
        values: ['percent', 'constant', 'sqrt', 'data'],
        role: 'info',
        editType: 'calc',
        description: [
            'Determines the rule used to generate the error bars.',

            'If *constant`, the bar lengths are of a constant value.',
            'Set this constant in `value`.',

            'If *percent*, the bar lengths correspond to a percentage of',
            'underlying data. Set this percentage in `value`.',

            'If *sqrt*, the bar lengths correspond to the sqaure of the',
            'underlying data.',

            'If *data*, the bar lengths are set with data set `array`.'
        ].join(' ')
    },
    symmetric: {
        valType: 'boolean',
        role: 'info',
        editType: 'calc',
        description: [
            'Determines whether or not the error bars have the same length',
            'in both direction',
            '(top/bottom for vertical bars, left/right for horizontal bars.'
        ].join(' ')
    },
    array: {
        valType: 'data_array',
        editType: 'calc',
        description: [
            'Sets the data corresponding the length of each error bar.',
            'Values are plotted relative to the underlying data.'
        ].join(' ')
    },
    arrayminus: {
        valType: 'data_array',
        editType: 'calc',
        description: [
            'Sets the data corresponding the length of each error bar in the',
            'bottom (left) direction for vertical (horizontal) bars',
            'Values are plotted relative to the underlying data.'
        ].join(' ')
    },
    value: {
        valType: 'number',
        min: 0,
        dflt: 10,
        role: 'info',
        editType: 'calc',
        description: [
            'Sets the value of either the percentage',
            '(if `type` is set to *percent*) or the constant',
            '(if `type` is set to *constant*) corresponding to the lengths of',
            'the error bars.'
        ].join(' ')
    },
    valueminus: {
        valType: 'number',
        min: 0,
        dflt: 10,
        role: 'info',
        editType: 'calc',
        description: [
            'Sets the value of either the percentage',
            '(if `type` is set to *percent*) or the constant',
            '(if `type` is set to *constant*) corresponding to the lengths of',
            'the error bars in the',
            'bottom (left) direction for vertical (horizontal) bars'
        ].join(' ')
    },
    traceref: {
        valType: 'integer',
        min: 0,
        dflt: 0,
        role: 'info',
        editType: 'style'
    },
    tracerefminus: {
        valType: 'integer',
        min: 0,
        dflt: 0,
        role: 'info',
        editType: 'style'
    },
    copy_ystyle: {
        valType: 'boolean',
        role: 'style',
        editType: 'plot'
    },
    copy_zstyle: {
        valType: 'boolean',
        role: 'style',
        editType: 'style'
    },
    color: {
        valType: 'color',
        role: 'style',
        editType: 'style',
        description: 'Sets the stoke color of the error bars.'
    },
    thickness: {
        valType: 'number',
        min: 0,
        dflt: 2,
        role: 'style',
        editType: 'style',
        description: 'Sets the thickness (in px) of the error bars.'
    },
    width: {
        valType: 'number',
        min: 0,
        role: 'style',
        editType: 'plot',
        description: [
            'Sets the width (in px) of the cross-bar at both ends',
            'of the error bars.'
        ].join(' ')
    },
    editType: 'calc',

    _deprecated: {
        opacity: {
            valType: 'number',
            role: 'style',
            editType: 'style',
            description: [
                'Obsolete.',
                'Use the alpha channel in error bar `color` to set the opacity.'
            ].join(' ')
        }
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/errorbars/calc.js":
/*!*****************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/errorbars/calc.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var isNumeric = __webpack_require__(/*! fast-isnumeric */ "./node_modules/fast-isnumeric/index.js");

var Registry = __webpack_require__(/*! ../../registry */ "./node_modules/plotly.js/src/registry.js");
var Axes = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js");
var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");

var makeComputeError = __webpack_require__(/*! ./compute_error */ "./node_modules/plotly.js/src/components/errorbars/compute_error.js");

module.exports = function calc(gd) {
    var calcdata = gd.calcdata;

    for(var i = 0; i < calcdata.length; i++) {
        var calcTrace = calcdata[i];
        var trace = calcTrace[0].trace;

        if(trace.visible === true && Registry.traceIs(trace, 'errorBarsOK')) {
            var xa = Axes.getFromId(gd, trace.xaxis);
            var ya = Axes.getFromId(gd, trace.yaxis);
            calcOneAxis(calcTrace, trace, xa, 'x');
            calcOneAxis(calcTrace, trace, ya, 'y');
        }
    }
};

function calcOneAxis(calcTrace, trace, axis, coord) {
    var opts = trace['error_' + coord] || {};
    var isVisible = (opts.visible && ['linear', 'log'].indexOf(axis.type) !== -1);
    var vals = [];

    if(!isVisible) return;

    var computeError = makeComputeError(opts);

    for(var i = 0; i < calcTrace.length; i++) {
        var calcPt = calcTrace[i];

        var iIn = calcPt.i;

        // for types that don't include `i` in each calcdata point
        if(iIn === undefined) iIn = i;

        // for stacked area inserted points
        // TODO: errorbars have been tested cursorily with stacked area,
        // but not thoroughly. It's not even really clear what you want to do:
        // Should it just be calculated based on that trace's size data?
        // Should you add errors from below in quadrature?
        // And what about normalization, where in principle the errors shrink
        // again when you get up to the top end?
        // One option would be to forbid errorbars with stacking until we
        // decide how to handle these questions.
        else if(iIn === null) continue;

        var calcCoord = calcPt[coord];

        if(!isNumeric(axis.c2l(calcCoord))) continue;

        var errors = computeError(calcCoord, iIn);
        if(isNumeric(errors[0]) && isNumeric(errors[1])) {
            var shoe = calcPt[coord + 's'] = calcCoord - errors[0];
            var hat = calcPt[coord + 'h'] = calcCoord + errors[1];
            vals.push(shoe, hat);
        }
    }

    var axId = axis._id;
    var baseExtremes = trace._extremes[axId];
    var extremes = Axes.findExtremes(
        axis,
        vals,
        Lib.extendFlat({tozero: baseExtremes.opts.tozero}, {padded: true})
    );
    baseExtremes.min = baseExtremes.min.concat(extremes.min);
    baseExtremes.max = baseExtremes.max.concat(extremes.max);
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/errorbars/compute_error.js":
/*!**************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/errorbars/compute_error.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/





/**
 * Error bar computing function generator
 *
 * N.B. The generated function does not clean the dataPt entries. Non-numeric
 * entries result in undefined error magnitudes.
 *
 * @param {object} opts error bar attributes
 *
 * @return {function} :
 *      @param {numeric} dataPt data point from where to compute the error magnitude
 *      @param {number} index index of dataPt in its corresponding data array
 *      @return {array}
 *        - error[0] : error magnitude in the negative direction
 *        - error[1] : " " " " positive "
 */
module.exports = function makeComputeError(opts) {
    var type = opts.type;
    var symmetric = opts.symmetric;

    if(type === 'data') {
        var array = opts.array || [];

        if(symmetric) {
            return function computeError(dataPt, index) {
                var val = +(array[index]);
                return [val, val];
            };
        } else {
            var arrayminus = opts.arrayminus || [];
            return function computeError(dataPt, index) {
                var val = +array[index];
                var valMinus = +arrayminus[index];
                // in case one is present and the other is missing, fill in 0
                // so we still see the present one. Mostly useful during manual
                // data entry.
                if(!isNaN(val) || !isNaN(valMinus)) {
                    return [valMinus || 0, val || 0];
                }
                return [NaN, NaN];
            };
        }
    } else {
        var computeErrorValue = makeComputeErrorValue(type, opts.value);
        var computeErrorValueMinus = makeComputeErrorValue(type, opts.valueminus);

        if(symmetric || opts.valueminus === undefined) {
            return function computeError(dataPt) {
                var val = computeErrorValue(dataPt);
                return [val, val];
            };
        } else {
            return function computeError(dataPt) {
                return [
                    computeErrorValueMinus(dataPt),
                    computeErrorValue(dataPt)
                ];
            };
        }
    }
};

/**
 * Compute error bar magnitude (for all types except data)
 *
 * @param {string} type error bar type
 * @param {numeric} value error bar value
 *
 * @return {function} :
 *      @param {numeric} dataPt
 */
function makeComputeErrorValue(type, value) {
    if(type === 'percent') {
        return function(dataPt) {
            return Math.abs(dataPt * value / 100);
        };
    }
    if(type === 'constant') {
        return function() {
            return Math.abs(value);
        };
    }
    if(type === 'sqrt') {
        return function(dataPt) {
            return Math.sqrt(Math.abs(dataPt));
        };
    }
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/errorbars/defaults.js":
/*!*********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/errorbars/defaults.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var isNumeric = __webpack_require__(/*! fast-isnumeric */ "./node_modules/fast-isnumeric/index.js");

var Registry = __webpack_require__(/*! ../../registry */ "./node_modules/plotly.js/src/registry.js");
var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Template = __webpack_require__(/*! ../../plot_api/plot_template */ "./node_modules/plotly.js/src/plot_api/plot_template.js");

var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/errorbars/attributes.js");


module.exports = function(traceIn, traceOut, defaultColor, opts) {
    var objName = 'error_' + opts.axis;
    var containerOut = Template.newContainer(traceOut, objName);
    var containerIn = traceIn[objName] || {};

    function coerce(attr, dflt) {
        return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
    }

    var hasErrorBars = (
        containerIn.array !== undefined ||
        containerIn.value !== undefined ||
        containerIn.type === 'sqrt'
    );

    var visible = coerce('visible', hasErrorBars);

    if(visible === false) return;

    var type = coerce('type', 'array' in containerIn ? 'data' : 'percent');
    var symmetric = true;

    if(type !== 'sqrt') {
        symmetric = coerce('symmetric',
            !((type === 'data' ? 'arrayminus' : 'valueminus') in containerIn));
    }

    if(type === 'data') {
        coerce('array');
        coerce('traceref');
        if(!symmetric) {
            coerce('arrayminus');
            coerce('tracerefminus');
        }
    } else if(type === 'percent' || type === 'constant') {
        coerce('value');
        if(!symmetric) coerce('valueminus');
    }

    var copyAttr = 'copy_' + opts.inherit + 'style';
    if(opts.inherit) {
        var inheritObj = traceOut['error_' + opts.inherit];
        if((inheritObj || {}).visible) {
            coerce(copyAttr, !(containerIn.color ||
                               isNumeric(containerIn.thickness) ||
                               isNumeric(containerIn.width)));
        }
    }
    if(!opts.inherit || !containerOut[copyAttr]) {
        coerce('color', defaultColor);
        coerce('thickness');
        coerce('width', Registry.traceIs(traceOut, 'gl3d') ? 0 : 4);
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/errorbars/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/errorbars/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var overrideAll = __webpack_require__(/*! ../../plot_api/edit_types */ "./node_modules/plotly.js/src/plot_api/edit_types.js").overrideAll;

var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/errorbars/attributes.js");

var xyAttrs = {
    error_x: Lib.extendFlat({}, attributes),
    error_y: Lib.extendFlat({}, attributes)
};
delete xyAttrs.error_x.copy_zstyle;
delete xyAttrs.error_y.copy_zstyle;
delete xyAttrs.error_y.copy_ystyle;

var xyzAttrs = {
    error_x: Lib.extendFlat({}, attributes),
    error_y: Lib.extendFlat({}, attributes),
    error_z: Lib.extendFlat({}, attributes)
};
delete xyzAttrs.error_x.copy_ystyle;
delete xyzAttrs.error_y.copy_ystyle;
delete xyzAttrs.error_z.copy_ystyle;
delete xyzAttrs.error_z.copy_zstyle;

module.exports = {
    moduleType: 'component',
    name: 'errorbars',

    schema: {
        traces: {
            scatter: xyAttrs,
            bar: xyAttrs,
            histogram: xyAttrs,
            scatter3d: overrideAll(xyzAttrs, 'calc', 'nested'),
            scattergl: overrideAll(xyAttrs, 'calc', 'nested')
        }
    },

    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/components/errorbars/defaults.js"),

    calc: __webpack_require__(/*! ./calc */ "./node_modules/plotly.js/src/components/errorbars/calc.js"),
    makeComputeError: __webpack_require__(/*! ./compute_error */ "./node_modules/plotly.js/src/components/errorbars/compute_error.js"),

    plot: __webpack_require__(/*! ./plot */ "./node_modules/plotly.js/src/components/errorbars/plot.js"),
    style: __webpack_require__(/*! ./style */ "./node_modules/plotly.js/src/components/errorbars/style.js"),
    hoverInfo: hoverInfo
};

function hoverInfo(calcPoint, trace, hoverPoint) {
    if((trace.error_y || {}).visible) {
        hoverPoint.yerr = calcPoint.yh - calcPoint.y;
        if(!trace.error_y.symmetric) hoverPoint.yerrneg = calcPoint.y - calcPoint.ys;
    }
    if((trace.error_x || {}).visible) {
        hoverPoint.xerr = calcPoint.xh - calcPoint.x;
        if(!trace.error_x.symmetric) hoverPoint.xerrneg = calcPoint.x - calcPoint.xs;
    }
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/errorbars/plot.js":
/*!*****************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/errorbars/plot.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");
var isNumeric = __webpack_require__(/*! fast-isnumeric */ "./node_modules/fast-isnumeric/index.js");

var Drawing = __webpack_require__(/*! ../drawing */ "./node_modules/plotly.js/src/components/drawing/index.js");
var subTypes = __webpack_require__(/*! ../../traces/scatter/subtypes */ "./node_modules/plotly.js/src/traces/scatter/subtypes.js");

module.exports = function plot(gd, traces, plotinfo, transitionOpts) {
    var isNew;

    var xa = plotinfo.xaxis;
    var ya = plotinfo.yaxis;

    var hasAnimation = transitionOpts && transitionOpts.duration > 0;

    traces.each(function(d) {
        var trace = d[0].trace;
        // || {} is in case the trace (specifically scatterternary)
        // doesn't support error bars at all, but does go through
        // the scatter.plot mechanics, which calls ErrorBars.plot
        // internally
        var xObj = trace.error_x || {};
        var yObj = trace.error_y || {};

        var keyFunc;

        if(trace.ids) {
            keyFunc = function(d) {return d.id;};
        }

        var sparse = (
            subTypes.hasMarkers(trace) &&
            trace.marker.maxdisplayed > 0
        );

        if(!yObj.visible && !xObj.visible) d = [];

        var errorbars = d3.select(this).selectAll('g.errorbar')
            .data(d, keyFunc);

        errorbars.exit().remove();

        if(!d.length) return;

        if(!xObj.visible) errorbars.selectAll('path.xerror').remove();
        if(!yObj.visible) errorbars.selectAll('path.yerror').remove();

        errorbars.style('opacity', 1);

        var enter = errorbars.enter().append('g')
            .classed('errorbar', true);

        if(hasAnimation) {
            enter.style('opacity', 0).transition()
                .duration(transitionOpts.duration)
                .style('opacity', 1);
        }

        Drawing.setClipUrl(errorbars, plotinfo.layerClipId, gd);

        errorbars.each(function(d) {
            var errorbar = d3.select(this);
            var coords = errorCoords(d, xa, ya);

            if(sparse && !d.vis) return;

            var path;

            var yerror = errorbar.select('path.yerror');
            if(yObj.visible && isNumeric(coords.x) &&
                    isNumeric(coords.yh) &&
                    isNumeric(coords.ys)) {
                var yw = yObj.width;

                path = 'M' + (coords.x - yw) + ',' +
                    coords.yh + 'h' + (2 * yw) + // hat
                    'm-' + yw + ',0V' + coords.ys; // bar


                if(!coords.noYS) path += 'm-' + yw + ',0h' + (2 * yw); // shoe

                isNew = !yerror.size();

                if(isNew) {
                    yerror = errorbar.append('path')
                        .style('vector-effect', 'non-scaling-stroke')
                        .classed('yerror', true);
                } else if(hasAnimation) {
                    yerror = yerror
                        .transition()
                            .duration(transitionOpts.duration)
                            .ease(transitionOpts.easing);
                }

                yerror.attr('d', path);
            } else yerror.remove();

            var xerror = errorbar.select('path.xerror');
            if(xObj.visible && isNumeric(coords.y) &&
                    isNumeric(coords.xh) &&
                    isNumeric(coords.xs)) {
                var xw = (xObj.copy_ystyle ? yObj : xObj).width;

                path = 'M' + coords.xh + ',' +
                    (coords.y - xw) + 'v' + (2 * xw) + // hat
                    'm0,-' + xw + 'H' + coords.xs; // bar

                if(!coords.noXS) path += 'm0,-' + xw + 'v' + (2 * xw); // shoe

                isNew = !xerror.size();

                if(isNew) {
                    xerror = errorbar.append('path')
                        .style('vector-effect', 'non-scaling-stroke')
                        .classed('xerror', true);
                } else if(hasAnimation) {
                    xerror = xerror
                        .transition()
                            .duration(transitionOpts.duration)
                            .ease(transitionOpts.easing);
                }

                xerror.attr('d', path);
            } else xerror.remove();
        });
    });
};

// compute the coordinates of the error-bar objects
function errorCoords(d, xa, ya) {
    var out = {
        x: xa.c2p(d.x),
        y: ya.c2p(d.y)
    };

    // calculate the error bar size and hat and shoe locations
    if(d.yh !== undefined) {
        out.yh = ya.c2p(d.yh);
        out.ys = ya.c2p(d.ys);

        // if the shoes go off-scale (ie log scale, error bars past zero)
        // clip the bar and hide the shoes
        if(!isNumeric(out.ys)) {
            out.noYS = true;
            out.ys = ya.c2p(d.ys, true);
        }
    }

    if(d.xh !== undefined) {
        out.xh = xa.c2p(d.xh);
        out.xs = xa.c2p(d.xs);

        if(!isNumeric(out.xs)) {
            out.noXS = true;
            out.xs = xa.c2p(d.xs, true);
        }
    }

    return out;
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/errorbars/style.js":
/*!******************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/errorbars/style.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");

var Color = __webpack_require__(/*! ../color */ "./node_modules/plotly.js/src/components/color/index.js");


module.exports = function style(traces) {
    traces.each(function(d) {
        var trace = d[0].trace;
        var yObj = trace.error_y || {};
        var xObj = trace.error_x || {};

        var s = d3.select(this);

        s.selectAll('path.yerror')
            .style('stroke-width', yObj.thickness + 'px')
            .call(Color.stroke, yObj.color);

        if(xObj.copy_ystyle) xObj = yObj;

        s.selectAll('path.xerror')
            .style('stroke-width', xObj.thickness + 'px')
            .call(Color.stroke, xObj.color);
    });
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/images/attributes.js":
/*!********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/images/attributes.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var cartesianConstants = __webpack_require__(/*! ../../plots/cartesian/constants */ "./node_modules/plotly.js/src/plots/cartesian/constants.js");
var templatedArray = __webpack_require__(/*! ../../plot_api/plot_template */ "./node_modules/plotly.js/src/plot_api/plot_template.js").templatedArray;


module.exports = templatedArray('image', {
    visible: {
        valType: 'boolean',
        role: 'info',
        dflt: true,
        editType: 'arraydraw',
        description: [
            'Determines whether or not this image is visible.'
        ].join(' ')
    },

    source: {
        valType: 'string',
        role: 'info',
        editType: 'arraydraw',
        description: [
            'Specifies the URL of the image to be used.',
            'The URL must be accessible from the domain where the',
            'plot code is run, and can be either relative or absolute.'

        ].join(' ')
    },

    layer: {
        valType: 'enumerated',
        values: ['below', 'above'],
        dflt: 'above',
        role: 'info',
        editType: 'arraydraw',
        description: [
            'Specifies whether images are drawn below or above traces.',
            'When `xref` and `yref` are both set to `paper`,',
            'image is drawn below the entire plot area.'
        ].join(' ')
    },

    sizex: {
        valType: 'number',
        role: 'info',
        dflt: 0,
        editType: 'arraydraw',
        description: [
            'Sets the image container size horizontally.',
            'The image will be sized based on the `position` value.',
            'When `xref` is set to `paper`, units are sized relative',
            'to the plot width.'
        ].join(' ')
    },

    sizey: {
        valType: 'number',
        role: 'info',
        dflt: 0,
        editType: 'arraydraw',
        description: [
            'Sets the image container size vertically.',
            'The image will be sized based on the `position` value.',
            'When `yref` is set to `paper`, units are sized relative',
            'to the plot height.'
        ].join(' ')
    },

    sizing: {
        valType: 'enumerated',
        values: ['fill', 'contain', 'stretch'],
        dflt: 'contain',
        role: 'info',
        editType: 'arraydraw',
        description: [
            'Specifies which dimension of the image to constrain.'
        ].join(' ')
    },

    opacity: {
        valType: 'number',
        role: 'info',
        min: 0,
        max: 1,
        dflt: 1,
        editType: 'arraydraw',
        description: 'Sets the opacity of the image.'
    },

    x: {
        valType: 'any',
        role: 'info',
        dflt: 0,
        editType: 'arraydraw',
        description: [
            'Sets the image\'s x position.',
            'When `xref` is set to `paper`, units are sized relative',
            'to the plot height.',
            'See `xref` for more info'
        ].join(' ')
    },

    y: {
        valType: 'any',
        role: 'info',
        dflt: 0,
        editType: 'arraydraw',
        description: [
            'Sets the image\'s y position.',
            'When `yref` is set to `paper`, units are sized relative',
            'to the plot height.',
            'See `yref` for more info'
        ].join(' ')
    },

    xanchor: {
        valType: 'enumerated',
        values: ['left', 'center', 'right'],
        dflt: 'left',
        role: 'info',
        editType: 'arraydraw',
        description: 'Sets the anchor for the x position'
    },

    yanchor: {
        valType: 'enumerated',
        values: ['top', 'middle', 'bottom'],
        dflt: 'top',
        role: 'info',
        editType: 'arraydraw',
        description: 'Sets the anchor for the y position.'
    },

    xref: {
        valType: 'enumerated',
        values: [
            'paper',
            cartesianConstants.idRegex.x.toString()
        ],
        dflt: 'paper',
        role: 'info',
        editType: 'arraydraw',
        description: [
            'Sets the images\'s x coordinate axis.',
            'If set to a x axis id (e.g. *x* or *x2*), the `x` position',
            'refers to an x data coordinate',
            'If set to *paper*, the `x` position refers to the distance from',
            'the left of plot in normalized coordinates',
            'where *0* (*1*) corresponds to the left (right).'
        ].join(' ')
    },

    yref: {
        valType: 'enumerated',
        values: [
            'paper',
            cartesianConstants.idRegex.y.toString()
        ],
        dflt: 'paper',
        role: 'info',
        editType: 'arraydraw',
        description: [
            'Sets the images\'s y coordinate axis.',
            'If set to a y axis id (e.g. *y* or *y2*), the `y` position',
            'refers to a y data coordinate.',
            'If set to *paper*, the `y` position refers to the distance from',
            'the bottom of the plot in normalized coordinates',
            'where *0* (*1*) corresponds to the bottom (top).'
        ].join(' ')
    },
    editType: 'arraydraw'
});


/***/ }),

/***/ "./node_modules/plotly.js/src/components/images/convert_coords.js":
/*!************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/images/convert_coords.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var isNumeric = __webpack_require__(/*! fast-isnumeric */ "./node_modules/fast-isnumeric/index.js");
var toLogRange = __webpack_require__(/*! ../../lib/to_log_range */ "./node_modules/plotly.js/src/lib/to_log_range.js");

/*
 * convertCoords: when converting an axis between log and linear
 * you need to alter any images on that axis to keep them
 * pointing at the same data point.
 * In v2.0 this will become obsolete (or perhaps size will still need conversion?)
 * we convert size by declaring that the maximum extent *in data units* should be
 * the same, assuming the image is anchored by its center (could remove that restriction
 * if we think it's important) even though the actual left and right values will not be
 * quite the same since the scale becomes nonlinear (and central anchor means the pixel
 * center of the image, not the data units center)
 *
 * gd: the plot div
 * ax: the axis being changed
 * newType: the type it's getting
 * doExtra: function(attr, val) from inside relayout that sets the attribute.
 *     Use this to make the changes as it's aware if any other changes in the
 *     same relayout call should override this conversion.
 */
module.exports = function convertCoords(gd, ax, newType, doExtra) {
    ax = ax || {};

    var toLog = (newType === 'log') && (ax.type === 'linear');
    var fromLog = (newType === 'linear') && (ax.type === 'log');

    if(!(toLog || fromLog)) return;

    var images = gd._fullLayout.images;
    var axLetter = ax._id.charAt(0);
    var image;
    var attrPrefix;

    for(var i = 0; i < images.length; i++) {
        image = images[i];
        attrPrefix = 'images[' + i + '].';

        if(image[axLetter + 'ref'] === ax._id) {
            var currentPos = image[axLetter];
            var currentSize = image['size' + axLetter];
            var newPos = null;
            var newSize = null;

            if(toLog) {
                newPos = toLogRange(currentPos, ax.range);

                // this is the inverse of the conversion we do in fromLog below
                // so that the conversion is reversible (notice the fromLog conversion
                // is like sinh, and this one looks like arcsinh)
                var dx = currentSize / Math.pow(10, newPos) / 2;
                newSize = 2 * Math.log(dx + Math.sqrt(1 + dx * dx)) / Math.LN10;
            } else {
                newPos = Math.pow(10, currentPos);
                newSize = newPos * (Math.pow(10, currentSize / 2) - Math.pow(10, -currentSize / 2));
            }

            // if conversion failed, delete the value so it can get a default later on
            if(!isNumeric(newPos)) {
                newPos = null;
                newSize = null;
            } else if(!isNumeric(newSize)) newSize = null;

            doExtra(attrPrefix + axLetter, newPos);
            doExtra(attrPrefix + 'size' + axLetter, newSize);
        }
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/images/defaults.js":
/*!******************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/images/defaults.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Axes = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js");
var handleArrayContainerDefaults = __webpack_require__(/*! ../../plots/array_container_defaults */ "./node_modules/plotly.js/src/plots/array_container_defaults.js");

var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/images/attributes.js");
var name = 'images';

module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
    var opts = {
        name: name,
        handleItemDefaults: imageDefaults
    };

    handleArrayContainerDefaults(layoutIn, layoutOut, opts);
};


function imageDefaults(imageIn, imageOut, fullLayout) {
    function coerce(attr, dflt) {
        return Lib.coerce(imageIn, imageOut, attributes, attr, dflt);
    }

    var source = coerce('source');
    var visible = coerce('visible', !!source);

    if(!visible) return imageOut;

    coerce('layer');
    coerce('xanchor');
    coerce('yanchor');
    coerce('sizex');
    coerce('sizey');
    coerce('sizing');
    coerce('opacity');

    var gdMock = { _fullLayout: fullLayout };
    var axLetters = ['x', 'y'];

    for(var i = 0; i < 2; i++) {
        // 'paper' is the fallback axref
        var axLetter = axLetters[i];
        var axRef = Axes.coerceRef(imageIn, imageOut, gdMock, axLetter, 'paper');

        if(axRef !== 'paper') {
            var ax = Axes.getFromId(gdMock, axRef);
            ax._imgIndices.push(imageOut._index);
        }

        Axes.coercePosition(imageOut, gdMock, coerce, axRef, axLetter, 0);
    }

    return imageOut;
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/images/draw.js":
/*!**************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/images/draw.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");
var Drawing = __webpack_require__(/*! ../drawing */ "./node_modules/plotly.js/src/components/drawing/index.js");
var Axes = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js");
var xmlnsNamespaces = __webpack_require__(/*! ../../constants/xmlns_namespaces */ "./node_modules/plotly.js/src/constants/xmlns_namespaces.js");

module.exports = function draw(gd) {
    var fullLayout = gd._fullLayout;
    var imageDataAbove = [];
    var imageDataSubplot = {};
    var imageDataBelow = [];
    var subplot;
    var i;

    // Sort into top, subplot, and bottom layers
    for(i = 0; i < fullLayout.images.length; i++) {
        var img = fullLayout.images[i];

        if(img.visible) {
            if(img.layer === 'below' && img.xref !== 'paper' && img.yref !== 'paper') {
                subplot = img.xref + img.yref;

                var plotinfo = fullLayout._plots[subplot];

                if(!plotinfo) {
                    // Fall back to _imageLowerLayer in case the requested subplot doesn't exist.
                    // This can happen if you reference the image to an x / y axis combination
                    // that doesn't have any data on it (and layer is below)
                    imageDataBelow.push(img);
                    continue;
                }

                if(plotinfo.mainplot) {
                    subplot = plotinfo.mainplot.id;
                }

                if(!imageDataSubplot[subplot]) {
                    imageDataSubplot[subplot] = [];
                }
                imageDataSubplot[subplot].push(img);
            } else if(img.layer === 'above') {
                imageDataAbove.push(img);
            } else {
                imageDataBelow.push(img);
            }
        }
    }


    var anchors = {
        x: {
            left: { sizing: 'xMin', offset: 0 },
            center: { sizing: 'xMid', offset: -1 / 2 },
            right: { sizing: 'xMax', offset: -1 }
        },
        y: {
            top: { sizing: 'YMin', offset: 0 },
            middle: { sizing: 'YMid', offset: -1 / 2 },
            bottom: { sizing: 'YMax', offset: -1 }
        }
    };


    // Images must be converted to dataURL's for exporting.
    function setImage(d) {
        var thisImage = d3.select(this);

        if(this._imgSrc === d.source) {
            return;
        }

        thisImage.attr('xmlns', xmlnsNamespaces.svg);

        if(d.source && d.source.slice(0, 5) === 'data:') {
            thisImage.attr('xlink:href', d.source);
            this._imgSrc = d.source;
        } else {
            var imagePromise = new Promise(function(resolve) {
                var img = new Image();
                this.img = img;

                // If not set, a `tainted canvas` error is thrown
                img.setAttribute('crossOrigin', 'anonymous');
                img.onerror = errorHandler;
                img.onload = function() {
                    var canvas = document.createElement('canvas');
                    canvas.width = this.width;
                    canvas.height = this.height;

                    var ctx = canvas.getContext('2d');
                    ctx.drawImage(this, 0, 0);

                    var dataURL = canvas.toDataURL('image/png');

                    thisImage.attr('xlink:href', dataURL);

                    // resolve promise in onload handler instead of on 'load' to support IE11
                    // see https://github.com/plotly/plotly.js/issues/1685
                    // for more details
                    resolve();
                };

                thisImage.on('error', errorHandler);

                img.src = d.source;
                this._imgSrc = d.source;

                function errorHandler() {
                    thisImage.remove();
                    resolve();
                }
            }.bind(this));

            gd._promises.push(imagePromise);
        }
    }

    function applyAttributes(d) {
        var thisImage = d3.select(this);

        // Axes if specified
        var xa = Axes.getFromId(gd, d.xref);
        var ya = Axes.getFromId(gd, d.yref);

        var size = fullLayout._size;
        var width = xa ? Math.abs(xa.l2p(d.sizex) - xa.l2p(0)) : d.sizex * size.w;
        var height = ya ? Math.abs(ya.l2p(d.sizey) - ya.l2p(0)) : d.sizey * size.h;

        // Offsets for anchor positioning
        var xOffset = width * anchors.x[d.xanchor].offset;
        var yOffset = height * anchors.y[d.yanchor].offset;

        var sizing = anchors.x[d.xanchor].sizing + anchors.y[d.yanchor].sizing;

        // Final positions
        var xPos = (xa ? xa.r2p(d.x) + xa._offset : d.x * size.w + size.l) + xOffset;
        var yPos = (ya ? ya.r2p(d.y) + ya._offset : size.h - d.y * size.h + size.t) + yOffset;

        // Construct the proper aspectRatio attribute
        switch(d.sizing) {
            case 'fill':
                sizing += ' slice';
                break;

            case 'stretch':
                sizing = 'none';
                break;
        }

        thisImage.attr({
            x: xPos,
            y: yPos,
            width: width,
            height: height,
            preserveAspectRatio: sizing,
            opacity: d.opacity
        });


        // Set proper clipping on images
        var xId = xa ? xa._id : '';
        var yId = ya ? ya._id : '';
        var clipAxes = xId + yId;

        Drawing.setClipUrl(
            thisImage,
            clipAxes ? ('clip' + fullLayout._uid + clipAxes) : null,
            gd
        );
    }

    var imagesBelow = fullLayout._imageLowerLayer.selectAll('image')
        .data(imageDataBelow);
    var imagesAbove = fullLayout._imageUpperLayer.selectAll('image')
        .data(imageDataAbove);

    imagesBelow.enter().append('image');
    imagesAbove.enter().append('image');

    imagesBelow.exit().remove();
    imagesAbove.exit().remove();

    imagesBelow.each(function(d) {
        setImage.bind(this)(d);
        applyAttributes.bind(this)(d);
    });
    imagesAbove.each(function(d) {
        setImage.bind(this)(d);
        applyAttributes.bind(this)(d);
    });

    var allSubplots = Object.keys(fullLayout._plots);
    for(i = 0; i < allSubplots.length; i++) {
        subplot = allSubplots[i];
        var subplotObj = fullLayout._plots[subplot];

        // filter out overlaid plots (which havd their images on the main plot)
        // and gl2d plots (which don't support below images, at least not yet)
        if(!subplotObj.imagelayer) continue;

        var imagesOnSubplot = subplotObj.imagelayer.selectAll('image')
            // even if there are no images on this subplot, we need to run
            // enter and exit in case there were previously
            .data(imageDataSubplot[subplot] || []);

        imagesOnSubplot.enter().append('image');
        imagesOnSubplot.exit().remove();

        imagesOnSubplot.each(function(d) {
            setImage.bind(this)(d);
            applyAttributes.bind(this)(d);
        });
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/images/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/images/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    moduleType: 'component',
    name: 'images',

    layoutAttributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/images/attributes.js"),
    supplyLayoutDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/components/images/defaults.js"),
    includeBasePlot: __webpack_require__(/*! ../../plots/cartesian/include_components */ "./node_modules/plotly.js/src/plots/cartesian/include_components.js")('images'),

    draw: __webpack_require__(/*! ./draw */ "./node_modules/plotly.js/src/components/images/draw.js"),

    convertCoords: __webpack_require__(/*! ./convert_coords */ "./node_modules/plotly.js/src/components/images/convert_coords.js")
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/legend/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/legend/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/





module.exports = {
    moduleType: 'component',
    name: 'legend',

    layoutAttributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/legend/attributes.js"),
    supplyLayoutDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/components/legend/defaults.js"),

    draw: __webpack_require__(/*! ./draw */ "./node_modules/plotly.js/src/components/legend/draw.js"),
    style: __webpack_require__(/*! ./style */ "./node_modules/plotly.js/src/components/legend/style.js")
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/rangeselector/attributes.js":
/*!***************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/rangeselector/attributes.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var fontAttrs = __webpack_require__(/*! ../../plots/font_attributes */ "./node_modules/plotly.js/src/plots/font_attributes.js");
var colorAttrs = __webpack_require__(/*! ../color/attributes */ "./node_modules/plotly.js/src/components/color/attributes.js");
var templatedArray = __webpack_require__(/*! ../../plot_api/plot_template */ "./node_modules/plotly.js/src/plot_api/plot_template.js").templatedArray;

var buttonAttrs = templatedArray('button', {
    visible: {
        valType: 'boolean',
        role: 'info',
        dflt: true,
        editType: 'plot',
        description: 'Determines whether or not this button is visible.'
    },
    step: {
        valType: 'enumerated',
        role: 'info',
        values: ['month', 'year', 'day', 'hour', 'minute', 'second', 'all'],
        dflt: 'month',
        editType: 'plot',
        description: [
            'The unit of measurement that the `count` value will set the range by.'
        ].join(' ')
    },
    stepmode: {
        valType: 'enumerated',
        role: 'info',
        values: ['backward', 'todate'],
        dflt: 'backward',
        editType: 'plot',
        description: [
            'Sets the range update mode.',
            'If *backward*, the range update shifts the start of range',
            'back *count* times *step* milliseconds.',
            'If *todate*, the range update shifts the start of range',
            'back to the first timestamp from *count* times',
            '*step* milliseconds back.',
            'For example, with `step` set to *year* and `count` set to *1*',
            'the range update shifts the start of the range back to',
            'January 01 of the current year.',
            'Month and year *todate* are currently available only',
            'for the built-in (Gregorian) calendar.'
        ].join(' ')
    },
    count: {
        valType: 'number',
        role: 'info',
        min: 0,
        dflt: 1,
        editType: 'plot',
        description: [
            'Sets the number of steps to take to update the range.',
            'Use with `step` to specify the update interval.'
        ].join(' ')
    },
    label: {
        valType: 'string',
        role: 'info',
        editType: 'plot',
        description: 'Sets the text label to appear on the button.'
    },
    editType: 'plot',
    description: [
        'Sets the specifications for each buttons.',
        'By default, a range selector comes with no buttons.'
    ].join(' ')
});

module.exports = {
    visible: {
        valType: 'boolean',
        role: 'info',
        editType: 'plot',
        description: [
            'Determines whether or not this range selector is visible.',
            'Note that range selectors are only available for x axes of',
            '`type` set to or auto-typed to *date*.'
        ].join(' ')
    },

    buttons: buttonAttrs,

    x: {
        valType: 'number',
        min: -2,
        max: 3,
        role: 'style',
        editType: 'plot',
        description: 'Sets the x position (in normalized coordinates) of the range selector.'
    },
    xanchor: {
        valType: 'enumerated',
        values: ['auto', 'left', 'center', 'right'],
        dflt: 'left',
        role: 'info',
        editType: 'plot',
        description: [
            'Sets the range selector\'s horizontal position anchor.',
            'This anchor binds the `x` position to the *left*, *center*',
            'or *right* of the range selector.'
        ].join(' ')
    },
    y: {
        valType: 'number',
        min: -2,
        max: 3,
        role: 'style',
        editType: 'plot',
        description: 'Sets the y position (in normalized coordinates) of the range selector.'
    },
    yanchor: {
        valType: 'enumerated',
        values: ['auto', 'top', 'middle', 'bottom'],
        dflt: 'bottom',
        role: 'info',
        editType: 'plot',
        description: [
            'Sets the range selector\'s vertical position anchor',
            'This anchor binds the `y` position to the *top*, *middle*',
            'or *bottom* of the range selector.'
        ].join(' ')
    },

    font: fontAttrs({
        editType: 'plot',
        description: 'Sets the font of the range selector button text.'
    }),

    bgcolor: {
        valType: 'color',
        dflt: colorAttrs.lightLine,
        role: 'style',
        editType: 'plot',
        description: 'Sets the background color of the range selector buttons.'
    },
    activecolor: {
        valType: 'color',
        role: 'style',
        editType: 'plot',
        description: 'Sets the background color of the active range selector button.'
    },
    bordercolor: {
        valType: 'color',
        dflt: colorAttrs.defaultLine,
        role: 'style',
        editType: 'plot',
        description: 'Sets the color of the border enclosing the range selector.'
    },
    borderwidth: {
        valType: 'number',
        min: 0,
        dflt: 0,
        role: 'style',
        editType: 'plot',
        description: 'Sets the width (in px) of the border enclosing the range selector.'
    },
    editType: 'plot'
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/rangeselector/constants.js":
/*!**************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/rangeselector/constants.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




module.exports = {

    // 'y' position pad above counter axis domain
    yPad: 0.02,

    // minimum button width (regardless of text size)
    minButtonWidth: 30,

    // buttons rect radii
    rx: 3,
    ry: 3,

    // light fraction used to compute the 'activecolor' default
    lightAmount: 25,
    darkAmount: 10
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/rangeselector/defaults.js":
/*!*************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/rangeselector/defaults.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Color = __webpack_require__(/*! ../color */ "./node_modules/plotly.js/src/components/color/index.js");
var Template = __webpack_require__(/*! ../../plot_api/plot_template */ "./node_modules/plotly.js/src/plot_api/plot_template.js");
var handleArrayContainerDefaults = __webpack_require__(/*! ../../plots/array_container_defaults */ "./node_modules/plotly.js/src/plots/array_container_defaults.js");

var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/rangeselector/attributes.js");
var constants = __webpack_require__(/*! ./constants */ "./node_modules/plotly.js/src/components/rangeselector/constants.js");


module.exports = function handleDefaults(containerIn, containerOut, layout, counterAxes, calendar) {
    var selectorIn = containerIn.rangeselector || {};
    var selectorOut = Template.newContainer(containerOut, 'rangeselector');

    function coerce(attr, dflt) {
        return Lib.coerce(selectorIn, selectorOut, attributes, attr, dflt);
    }

    var buttons = handleArrayContainerDefaults(selectorIn, selectorOut, {
        name: 'buttons',
        handleItemDefaults: buttonDefaults,
        calendar: calendar
    });

    var visible = coerce('visible', buttons.length > 0);
    if(visible) {
        var posDflt = getPosDflt(containerOut, layout, counterAxes);
        coerce('x', posDflt[0]);
        coerce('y', posDflt[1]);
        Lib.noneOrAll(containerIn, containerOut, ['x', 'y']);

        coerce('xanchor');
        coerce('yanchor');

        Lib.coerceFont(coerce, 'font', layout.font);

        var bgColor = coerce('bgcolor');
        coerce('activecolor', Color.contrast(bgColor, constants.lightAmount, constants.darkAmount));
        coerce('bordercolor');
        coerce('borderwidth');
    }
};

function buttonDefaults(buttonIn, buttonOut, selectorOut, opts) {
    var calendar = opts.calendar;

    function coerce(attr, dflt) {
        return Lib.coerce(buttonIn, buttonOut, attributes.buttons, attr, dflt);
    }

    var visible = coerce('visible');

    if(visible) {
        var step = coerce('step');
        if(step !== 'all') {
            if(calendar && calendar !== 'gregorian' && (step === 'month' || step === 'year')) {
                buttonOut.stepmode = 'backward';
            } else {
                coerce('stepmode');
            }

            coerce('count');
        }

        coerce('label');
    }
}

function getPosDflt(containerOut, layout, counterAxes) {
    var anchoredList = counterAxes.filter(function(ax) {
        return layout[ax].anchor === containerOut._id;
    });

    var posY = 0;
    for(var i = 0; i < anchoredList.length; i++) {
        var domain = layout[anchoredList[i]].domain;
        if(domain) posY = Math.max(domain[1], posY);
    }

    return [containerOut.domain[0], posY + constants.yPad];
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/rangeselector/draw.js":
/*!*********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/rangeselector/draw.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");

var Registry = __webpack_require__(/*! ../../registry */ "./node_modules/plotly.js/src/registry.js");
var Plots = __webpack_require__(/*! ../../plots/plots */ "./node_modules/plotly.js/src/plots/plots.js");
var Color = __webpack_require__(/*! ../color */ "./node_modules/plotly.js/src/components/color/index.js");
var Drawing = __webpack_require__(/*! ../drawing */ "./node_modules/plotly.js/src/components/drawing/index.js");
var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var svgTextUtils = __webpack_require__(/*! ../../lib/svg_text_utils */ "./node_modules/plotly.js/src/lib/svg_text_utils.js");
var axisIds = __webpack_require__(/*! ../../plots/cartesian/axis_ids */ "./node_modules/plotly.js/src/plots/cartesian/axis_ids.js");

var alignmentConstants = __webpack_require__(/*! ../../constants/alignment */ "./node_modules/plotly.js/src/constants/alignment.js");
var LINE_SPACING = alignmentConstants.LINE_SPACING;
var FROM_TL = alignmentConstants.FROM_TL;
var FROM_BR = alignmentConstants.FROM_BR;

var constants = __webpack_require__(/*! ./constants */ "./node_modules/plotly.js/src/components/rangeselector/constants.js");
var getUpdateObject = __webpack_require__(/*! ./get_update_object */ "./node_modules/plotly.js/src/components/rangeselector/get_update_object.js");

module.exports = function draw(gd) {
    var fullLayout = gd._fullLayout;

    var selectors = fullLayout._infolayer.selectAll('.rangeselector')
        .data(makeSelectorData(gd), selectorKeyFunc);

    selectors.enter().append('g')
        .classed('rangeselector', true);

    selectors.exit().remove();

    selectors.style({
        cursor: 'pointer',
        'pointer-events': 'all'
    });

    selectors.each(function(d) {
        var selector = d3.select(this);
        var axisLayout = d;
        var selectorLayout = axisLayout.rangeselector;

        var buttons = selector.selectAll('g.button')
            .data(Lib.filterVisible(selectorLayout.buttons));

        buttons.enter().append('g')
            .classed('button', true);

        buttons.exit().remove();

        buttons.each(function(d) {
            var button = d3.select(this);
            var update = getUpdateObject(axisLayout, d);

            d._isActive = isActive(axisLayout, d, update);

            button.call(drawButtonRect, selectorLayout, d);
            button.call(drawButtonText, selectorLayout, d, gd);

            button.on('click', function() {
                if(gd._dragged) return;

                Registry.call('_guiRelayout', gd, update);
            });

            button.on('mouseover', function() {
                d._isHovered = true;
                button.call(drawButtonRect, selectorLayout, d);
            });

            button.on('mouseout', function() {
                d._isHovered = false;
                button.call(drawButtonRect, selectorLayout, d);
            });
        });

        reposition(gd, buttons, selectorLayout, axisLayout._name, selector);
    });
};

function makeSelectorData(gd) {
    var axes = axisIds.list(gd, 'x', true);
    var data = [];

    for(var i = 0; i < axes.length; i++) {
        var axis = axes[i];

        if(axis.rangeselector && axis.rangeselector.visible) {
            data.push(axis);
        }
    }

    return data;
}

function selectorKeyFunc(d) {
    return d._id;
}

function isActive(axisLayout, opts, update) {
    if(opts.step === 'all') {
        return axisLayout.autorange === true;
    } else {
        var keys = Object.keys(update);

        return (
            axisLayout.range[0] === update[keys[0]] &&
            axisLayout.range[1] === update[keys[1]]
        );
    }
}

function drawButtonRect(button, selectorLayout, d) {
    var rect = Lib.ensureSingle(button, 'rect', 'selector-rect', function(s) {
        s.attr('shape-rendering', 'crispEdges');
    });

    rect.attr({
        'rx': constants.rx,
        'ry': constants.ry
    });

    rect.call(Color.stroke, selectorLayout.bordercolor)
        .call(Color.fill, getFillColor(selectorLayout, d))
        .style('stroke-width', selectorLayout.borderwidth + 'px');
}

function getFillColor(selectorLayout, d) {
    return (d._isActive || d._isHovered) ?
        selectorLayout.activecolor :
        selectorLayout.bgcolor;
}

function drawButtonText(button, selectorLayout, d, gd) {
    function textLayout(s) {
        svgTextUtils.convertToTspans(s, gd);
    }

    var text = Lib.ensureSingle(button, 'text', 'selector-text', function(s) {
        s.classed('user-select-none', true)
            .attr('text-anchor', 'middle');
    });

    text.call(Drawing.font, selectorLayout.font)
        .text(getLabel(d, gd._fullLayout._meta))
        .call(textLayout);
}

function getLabel(opts, _meta) {
    if(opts.label) {
        return _meta ?
            Lib.templateString(opts.label, _meta) :
            opts.label;
    }

    if(opts.step === 'all') return 'all';

    return opts.count + opts.step.charAt(0);
}

function reposition(gd, buttons, opts, axName, selector) {
    var width = 0;
    var height = 0;

    var borderWidth = opts.borderwidth;

    buttons.each(function() {
        var button = d3.select(this);
        var text = button.select('.selector-text');

        var tHeight = opts.font.size * LINE_SPACING;
        var hEff = Math.max(tHeight * svgTextUtils.lineCount(text), 16) + 3;

        height = Math.max(height, hEff);
    });

    buttons.each(function() {
        var button = d3.select(this);
        var rect = button.select('.selector-rect');
        var text = button.select('.selector-text');

        var tWidth = text.node() && Drawing.bBox(text.node()).width;
        var tHeight = opts.font.size * LINE_SPACING;
        var tLines = svgTextUtils.lineCount(text);

        var wEff = Math.max(tWidth + 10, constants.minButtonWidth);

        // TODO add MathJax support

        // TODO add buttongap attribute

        button.attr('transform', 'translate(' +
            (borderWidth + width) + ',' + borderWidth +
        ')');

        rect.attr({
            x: 0,
            y: 0,
            width: wEff,
            height: height
        });

        svgTextUtils.positionText(text, wEff / 2,
            height / 2 - ((tLines - 1) * tHeight / 2) + 3);

        width += wEff + 5;
    });

    var graphSize = gd._fullLayout._size;
    var lx = graphSize.l + graphSize.w * opts.x;
    var ly = graphSize.t + graphSize.h * (1 - opts.y);

    var xanchor = 'left';
    if(Lib.isRightAnchor(opts)) {
        lx -= width;
        xanchor = 'right';
    }
    if(Lib.isCenterAnchor(opts)) {
        lx -= width / 2;
        xanchor = 'center';
    }

    var yanchor = 'top';
    if(Lib.isBottomAnchor(opts)) {
        ly -= height;
        yanchor = 'bottom';
    }
    if(Lib.isMiddleAnchor(opts)) {
        ly -= height / 2;
        yanchor = 'middle';
    }

    width = Math.ceil(width);
    height = Math.ceil(height);
    lx = Math.round(lx);
    ly = Math.round(ly);

    Plots.autoMargin(gd, axName + '-range-selector', {
        x: opts.x,
        y: opts.y,
        l: width * FROM_TL[xanchor],
        r: width * FROM_BR[xanchor],
        b: height * FROM_BR[yanchor],
        t: height * FROM_TL[yanchor]
    });

    selector.attr('transform', 'translate(' + lx + ',' + ly + ')');
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/rangeselector/get_update_object.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/rangeselector/get_update_object.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");

module.exports = function getUpdateObject(axisLayout, buttonLayout) {
    var axName = axisLayout._name;
    var update = {};

    if(buttonLayout.step === 'all') {
        update[axName + '.autorange'] = true;
    } else {
        var xrange = getXRange(axisLayout, buttonLayout);

        update[axName + '.range[0]'] = xrange[0];
        update[axName + '.range[1]'] = xrange[1];
    }

    return update;
};

function getXRange(axisLayout, buttonLayout) {
    var currentRange = axisLayout.range;
    var base = new Date(axisLayout.r2l(currentRange[1]));
    var step = buttonLayout.step;
    var count = buttonLayout.count;
    var range0;

    switch(buttonLayout.stepmode) {
        case 'backward':
            range0 = axisLayout.l2r(+d3.time[step].utc.offset(base, -count));
            break;

        case 'todate':
            var base2 = d3.time[step].utc.offset(base, -count);

            range0 = axisLayout.l2r(+d3.time[step].utc.ceil(base2));
            break;
    }

    var range1 = currentRange[1];

    return [range0, range1];
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/rangeselector/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/rangeselector/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    moduleType: 'component',
    name: 'rangeselector',

    schema: {
        subplots: {
            xaxis: {rangeselector: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/rangeselector/attributes.js")}
        }
    },

    layoutAttributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/rangeselector/attributes.js"),
    handleDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/components/rangeselector/defaults.js"),

    draw: __webpack_require__(/*! ./draw */ "./node_modules/plotly.js/src/components/rangeselector/draw.js")
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/rangeslider/attributes.js":
/*!*************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/rangeslider/attributes.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var colorAttributes = __webpack_require__(/*! ../color/attributes */ "./node_modules/plotly.js/src/components/color/attributes.js");

module.exports = {
    bgcolor: {
        valType: 'color',
        dflt: colorAttributes.background,
        role: 'style',
        editType: 'plot',
        description: 'Sets the background color of the range slider.'
    },
    bordercolor: {
        valType: 'color',
        dflt: colorAttributes.defaultLine,
        role: 'style',
        editType: 'plot',
        description: 'Sets the border color of the range slider.'
    },
    borderwidth: {
        valType: 'integer',
        dflt: 0,
        min: 0,
        role: 'style',
        editType: 'plot',
        description: 'Sets the border width of the range slider.'
    },
    autorange: {
        valType: 'boolean',
        dflt: true,
        role: 'style',
        editType: 'calc',
        impliedEdits: {'range[0]': undefined, 'range[1]': undefined},
        description: [
            'Determines whether or not the range slider range is',
            'computed in relation to the input data.',
            'If `range` is provided, then `autorange` is set to *false*.'
        ].join(' ')
    },
    range: {
        valType: 'info_array',
        role: 'info',
        items: [
            {valType: 'any', editType: 'calc', impliedEdits: {'^autorange': false}},
            {valType: 'any', editType: 'calc', impliedEdits: {'^autorange': false}}
        ],
        editType: 'calc',
        impliedEdits: {'autorange': false},
        description: [
            'Sets the range of the range slider.',
            'If not set, defaults to the full xaxis range.',
            'If the axis `type` is *log*, then you must take the',
            'log of your desired range.',
            'If the axis `type` is *date*, it should be date strings,',
            'like date data, though Date objects and unix milliseconds',
            'will be accepted and converted to strings.',
            'If the axis `type` is *category*, it should be numbers,',
            'using the scale where each category is assigned a serial',
            'number from zero in the order it appears.'
        ].join(' ')
    },
    thickness: {
        valType: 'number',
        dflt: 0.15,
        min: 0,
        max: 1,
        role: 'style',
        editType: 'plot',
        description: [
            'The height of the range slider as a fraction of the',
            'total plot area height.'
        ].join(' ')
    },
    visible: {
        valType: 'boolean',
        dflt: true,
        role: 'info',
        editType: 'calc',
        description: [
            'Determines whether or not the range slider will be visible.',
            'If visible, perpendicular axes will be set to `fixedrange`'
        ].join(' ')
    },
    editType: 'calc'
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/rangeslider/calc_autorange.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/rangeslider/calc_autorange.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var listAxes = __webpack_require__(/*! ../../plots/cartesian/axis_ids */ "./node_modules/plotly.js/src/plots/cartesian/axis_ids.js").list;
var getAutoRange = __webpack_require__(/*! ../../plots/cartesian/autorange */ "./node_modules/plotly.js/src/plots/cartesian/autorange.js").getAutoRange;
var constants = __webpack_require__(/*! ./constants */ "./node_modules/plotly.js/src/components/rangeslider/constants.js");

module.exports = function calcAutorange(gd) {
    var axes = listAxes(gd, 'x', true);

    // Compute new slider range using axis autorange if necessary.
    //
    // Copy back range to input range slider container to skip
    // this step in subsequent draw calls.

    for(var i = 0; i < axes.length; i++) {
        var ax = axes[i];
        var opts = ax[constants.name];

        if(opts && opts.visible && opts.autorange) {
            opts._input.autorange = true;
            opts._input.range = opts.range = getAutoRange(gd, ax);
        }
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/rangeslider/constants.js":
/*!************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/rangeslider/constants.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {

    // attribute container name
    name: 'rangeslider',

    // class names

    containerClassName: 'rangeslider-container',
    bgClassName: 'rangeslider-bg',
    rangePlotClassName: 'rangeslider-rangeplot',

    maskMinClassName: 'rangeslider-mask-min',
    maskMaxClassName: 'rangeslider-mask-max',
    slideBoxClassName: 'rangeslider-slidebox',

    grabberMinClassName: 'rangeslider-grabber-min',
    grabAreaMinClassName: 'rangeslider-grabarea-min',
    handleMinClassName: 'rangeslider-handle-min',

    grabberMaxClassName: 'rangeslider-grabber-max',
    grabAreaMaxClassName: 'rangeslider-grabarea-max',
    handleMaxClassName: 'rangeslider-handle-max',

    maskMinOppAxisClassName: 'rangeslider-mask-min-opp-axis',
    maskMaxOppAxisClassName: 'rangeslider-mask-max-opp-axis',

    // style constants

    maskColor: 'rgba(0,0,0,0.4)',
    maskOppAxisColor: 'rgba(0,0,0,0.2)',

    slideBoxFill: 'transparent',
    slideBoxCursor: 'ew-resize',

    grabAreaFill: 'transparent',
    grabAreaCursor: 'col-resize',
    grabAreaWidth: 10,

    handleWidth: 4,
    handleRadius: 1,
    handleStrokeWidth: 1,

    extraPad: 15
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/rangeslider/defaults.js":
/*!***********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/rangeslider/defaults.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Template = __webpack_require__(/*! ../../plot_api/plot_template */ "./node_modules/plotly.js/src/plot_api/plot_template.js");
var axisIds = __webpack_require__(/*! ../../plots/cartesian/axis_ids */ "./node_modules/plotly.js/src/plots/cartesian/axis_ids.js");

var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/rangeslider/attributes.js");
var oppAxisAttrs = __webpack_require__(/*! ./oppaxis_attributes */ "./node_modules/plotly.js/src/components/rangeslider/oppaxis_attributes.js");

module.exports = function handleDefaults(layoutIn, layoutOut, axName) {
    var axIn = layoutIn[axName];
    var axOut = layoutOut[axName];

    if(!(axIn.rangeslider || layoutOut._requestRangeslider[axOut._id])) return;

    // not super proud of this (maybe store _ in axis object instead
    if(!Lib.isPlainObject(axIn.rangeslider)) {
        axIn.rangeslider = {};
    }

    var containerIn = axIn.rangeslider;
    var containerOut = Template.newContainer(axOut, 'rangeslider');

    function coerce(attr, dflt) {
        return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
    }

    var rangeContainerIn, rangeContainerOut;
    function coerceRange(attr, dflt) {
        return Lib.coerce(rangeContainerIn, rangeContainerOut, oppAxisAttrs, attr, dflt);
    }

    var visible = coerce('visible');
    if(!visible) return;

    coerce('bgcolor', layoutOut.plot_bgcolor);
    coerce('bordercolor');
    coerce('borderwidth');
    coerce('thickness');

    coerce('autorange', !axOut.isValidRange(containerIn.range));
    coerce('range');

    var subplots = layoutOut._subplots;
    if(subplots) {
        var yIds = subplots.cartesian
            .filter(function(subplotId) {
                return subplotId.substr(0, subplotId.indexOf('y')) === axisIds.name2id(axName);
            })
            .map(function(subplotId) {
                return subplotId.substr(subplotId.indexOf('y'), subplotId.length);
            });
        var yNames = Lib.simpleMap(yIds, axisIds.id2name);
        for(var i = 0; i < yNames.length; i++) {
            var yName = yNames[i];

            rangeContainerIn = containerIn[yName] || {};
            rangeContainerOut = Template.newContainer(containerOut, yName, 'yaxis');

            var yAxOut = layoutOut[yName];

            var rangemodeDflt;
            if(rangeContainerIn.range && yAxOut.isValidRange(rangeContainerIn.range)) {
                rangemodeDflt = 'fixed';
            }

            var rangeMode = coerceRange('rangemode', rangemodeDflt);
            if(rangeMode !== 'match') {
                coerceRange('range', yAxOut.range.slice());
            }
        }
    }

    // to map back range slider (auto) range
    containerOut._input = containerIn;
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/rangeslider/draw.js":
/*!*******************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/rangeslider/draw.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");

var Registry = __webpack_require__(/*! ../../registry */ "./node_modules/plotly.js/src/registry.js");
var Plots = __webpack_require__(/*! ../../plots/plots */ "./node_modules/plotly.js/src/plots/plots.js");

var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Drawing = __webpack_require__(/*! ../drawing */ "./node_modules/plotly.js/src/components/drawing/index.js");
var Color = __webpack_require__(/*! ../color */ "./node_modules/plotly.js/src/components/color/index.js");
var Titles = __webpack_require__(/*! ../titles */ "./node_modules/plotly.js/src/components/titles/index.js");

var Cartesian = __webpack_require__(/*! ../../plots/cartesian */ "./node_modules/plotly.js/src/plots/cartesian/index.js");
var axisIDs = __webpack_require__(/*! ../../plots/cartesian/axis_ids */ "./node_modules/plotly.js/src/plots/cartesian/axis_ids.js");

var dragElement = __webpack_require__(/*! ../dragelement */ "./node_modules/plotly.js/src/components/dragelement/index.js");
var setCursor = __webpack_require__(/*! ../../lib/setcursor */ "./node_modules/plotly.js/src/lib/setcursor.js");

var constants = __webpack_require__(/*! ./constants */ "./node_modules/plotly.js/src/components/rangeslider/constants.js");

module.exports = function(gd) {
    var fullLayout = gd._fullLayout;
    var rangeSliderData = fullLayout._rangeSliderData;
    for(var i = 0; i < rangeSliderData.length; i++) {
        var opts = rangeSliderData[i][constants.name];
        // fullLayout._uid may not exist when we call makeData
        opts._clipId = opts._id + '-' + fullLayout._uid;
    }

    /*
     * <g container />
     *  <rect bg />
     *  < .... range plot />
     *  <rect mask-min />
     *  <rect mask-max />
     *  <rect slidebox />
     *  <g grabber-min />
     *      <rect handle-min />
     *      <rect grabare-min />
     *  <g grabber-max />
     *      <rect handle-max />
     *      <rect grabare-max />
     *
     *  ...
     */

    function keyFunction(axisOpts) {
        return axisOpts._name;
    }

    var rangeSliders = fullLayout._infolayer
        .selectAll('g.' + constants.containerClassName)
        .data(rangeSliderData, keyFunction);

    // remove exiting sliders and their corresponding clip paths
    rangeSliders.exit().each(function(axisOpts) {
        var opts = axisOpts[constants.name];
        fullLayout._topdefs.select('#' + opts._clipId).remove();
    }).remove();

    // return early if no range slider is visible
    if(rangeSliderData.length === 0) return;

    rangeSliders.enter().append('g')
        .classed(constants.containerClassName, true)
        .attr('pointer-events', 'all');

    // for all present range sliders
    rangeSliders.each(function(axisOpts) {
        var rangeSlider = d3.select(this);
        var opts = axisOpts[constants.name];
        var oppAxisOpts = fullLayout[axisIDs.id2name(axisOpts.anchor)];
        var oppAxisRangeOpts = opts[axisIDs.id2name(axisOpts.anchor)];

        // update range
        // Expand slider range to the axis range
        if(opts.range) {
            var rng = Lib.simpleMap(opts.range, axisOpts.r2l);
            var axRng = Lib.simpleMap(axisOpts.range, axisOpts.r2l);
            var newRng;

            if(axRng[0] < axRng[1]) {
                newRng = [
                    Math.min(rng[0], axRng[0]),
                    Math.max(rng[1], axRng[1])
                ];
            } else {
                newRng = [
                    Math.max(rng[0], axRng[0]),
                    Math.min(rng[1], axRng[1])
                ];
            }

            opts.range = opts._input.range = Lib.simpleMap(newRng, axisOpts.l2r);
        }

        axisOpts.cleanRange('rangeslider.range');

        // update range slider dimensions

        var gs = fullLayout._size;
        var domain = axisOpts.domain;

        opts._width = gs.w * (domain[1] - domain[0]);

        var x = Math.round(gs.l + (gs.w * domain[0]));

        var y = Math.round(
            gs.t + gs.h * (1 - axisOpts._counterDomainMin) +
            (axisOpts.side === 'bottom' ? axisOpts._depth : 0) +
            opts._offsetShift + constants.extraPad
        );

        rangeSlider.attr('transform', 'translate(' + x + ',' + y + ')');

        // update data <--> pixel coordinate conversion methods

        opts._rl = Lib.simpleMap(opts.range, axisOpts.r2l);
        var rl0 = opts._rl[0];
        var rl1 = opts._rl[1];
        var drl = rl1 - rl0;

        opts.p2d = function(v) {
            return (v / opts._width) * drl + rl0;
        };

        opts.d2p = function(v) {
            return (v - rl0) / drl * opts._width;
        };

        if(axisOpts.rangebreaks) {
            var rsBreaks = axisOpts.locateBreaks(rl0, rl1);

            if(rsBreaks.length) {
                var j, brk;

                var lBreaks = 0;
                for(j = 0; j < rsBreaks.length; j++) {
                    brk = rsBreaks[j];
                    lBreaks += (brk.max - brk.min);
                }

                // TODO fix for reversed-range axes !!!

                // compute slope and piecewise offsets
                var m2 = opts._width / (rl1 - rl0 - lBreaks);
                var _B = [-m2 * rl0];
                for(j = 0; j < rsBreaks.length; j++) {
                    brk = rsBreaks[j];
                    _B.push(_B[_B.length - 1] - m2 * (brk.max - brk.min));
                }

                opts.d2p = function(v) {
                    var b = _B[0];
                    for(var j = 0; j < rsBreaks.length; j++) {
                        var brk = rsBreaks[j];
                        if(v >= brk.max) b = _B[j + 1];
                        else if(v < brk.min) break;
                    }
                    return b + m2 * v;
                };

                // fill pixel (i.e. 'p') min/max here,
                // to not have to loop through the _rangebreaks twice during `p2d`
                for(j = 0; j < rsBreaks.length; j++) {
                    brk = rsBreaks[j];
                    brk.pmin = opts.d2p(brk.min);
                    brk.pmax = opts.d2p(brk.max);
                }

                opts.p2d = function(v) {
                    var b = _B[0];
                    for(var j = 0; j < rsBreaks.length; j++) {
                        var brk = rsBreaks[j];
                        if(v >= brk.pmax) b = _B[j + 1];
                        else if(v < brk.pmin) break;
                    }
                    return (v - b) / m2;
                };
            }
        }

        if(oppAxisRangeOpts.rangemode !== 'match') {
            var range0OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[0]);
            var range1OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[1]);
            var distOppAxis = range1OppAxis - range0OppAxis;

            opts.d2pOppAxis = function(v) {
                return (v - range0OppAxis) / distOppAxis * opts._height;
            };
        }

        // update inner nodes

        rangeSlider
            .call(drawBg, gd, axisOpts, opts)
            .call(addClipPath, gd, axisOpts, opts)
            .call(drawRangePlot, gd, axisOpts, opts)
            .call(drawMasks, gd, axisOpts, opts, oppAxisRangeOpts)
            .call(drawSlideBox, gd, axisOpts, opts)
            .call(drawGrabbers, gd, axisOpts, opts);

        // setup drag element
        setupDragElement(rangeSlider, gd, axisOpts, opts);

        // update current range
        setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts);

        // title goes next to range slider instead of tick labels, so
        // just take it over and draw it from here
        if(axisOpts.side === 'bottom') {
            Titles.draw(gd, axisOpts._id + 'title', {
                propContainer: axisOpts,
                propName: axisOpts._name + '.title',
                placeholder: fullLayout._dfltTitle.x,
                attributes: {
                    x: axisOpts._offset + axisOpts._length / 2,
                    y: y + opts._height + opts._offsetShift + 10 + 1.5 * axisOpts.title.font.size,
                    'text-anchor': 'middle'
                }
            });
        }
    });
};

function setupDragElement(rangeSlider, gd, axisOpts, opts) {
    var slideBox = rangeSlider.select('rect.' + constants.slideBoxClassName).node();
    var grabAreaMin = rangeSlider.select('rect.' + constants.grabAreaMinClassName).node();
    var grabAreaMax = rangeSlider.select('rect.' + constants.grabAreaMaxClassName).node();

    rangeSlider.on('mousedown', function() {
        var event = d3.event;
        var target = event.target;
        var startX = event.clientX;
        var offsetX = startX - rangeSlider.node().getBoundingClientRect().left;
        var minVal = opts.d2p(axisOpts._rl[0]);
        var maxVal = opts.d2p(axisOpts._rl[1]);

        var dragCover = dragElement.coverSlip();

        dragCover.addEventListener('mousemove', mouseMove);
        dragCover.addEventListener('mouseup', mouseUp);

        function mouseMove(e) {
            var delta = +e.clientX - startX;
            var pixelMin, pixelMax, cursor;

            switch(target) {
                case slideBox:
                    cursor = 'ew-resize';
                    pixelMin = minVal + delta;
                    pixelMax = maxVal + delta;
                    break;

                case grabAreaMin:
                    cursor = 'col-resize';
                    pixelMin = minVal + delta;
                    pixelMax = maxVal;
                    break;

                case grabAreaMax:
                    cursor = 'col-resize';
                    pixelMin = minVal;
                    pixelMax = maxVal + delta;
                    break;

                default:
                    cursor = 'ew-resize';
                    pixelMin = offsetX;
                    pixelMax = offsetX + delta;
                    break;
            }

            if(pixelMax < pixelMin) {
                var tmp = pixelMax;
                pixelMax = pixelMin;
                pixelMin = tmp;
            }

            opts._pixelMin = pixelMin;
            opts._pixelMax = pixelMax;

            setCursor(d3.select(dragCover), cursor);
            setDataRange(rangeSlider, gd, axisOpts, opts);
        }

        function mouseUp() {
            dragCover.removeEventListener('mousemove', mouseMove);
            dragCover.removeEventListener('mouseup', mouseUp);
            Lib.removeElement(dragCover);
        }
    });
}

function setDataRange(rangeSlider, gd, axisOpts, opts) {
    function clamp(v) {
        return axisOpts.l2r(Lib.constrain(v, opts._rl[0], opts._rl[1]));
    }

    var dataMin = clamp(opts.p2d(opts._pixelMin));
    var dataMax = clamp(opts.p2d(opts._pixelMax));

    window.requestAnimationFrame(function() {
        Registry.call('_guiRelayout', gd, axisOpts._name + '.range', [dataMin, dataMax]);
    });
}

function setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts) {
    var hw2 = constants.handleWidth / 2;

    function clamp(v) {
        return Lib.constrain(v, 0, opts._width);
    }

    function clampOppAxis(v) {
        return Lib.constrain(v, 0, opts._height);
    }

    function clampHandle(v) {
        return Lib.constrain(v, -hw2, opts._width + hw2);
    }

    var pixelMin = clamp(opts.d2p(axisOpts._rl[0]));
    var pixelMax = clamp(opts.d2p(axisOpts._rl[1]));

    rangeSlider.select('rect.' + constants.slideBoxClassName)
        .attr('x', pixelMin)
        .attr('width', pixelMax - pixelMin);

    rangeSlider.select('rect.' + constants.maskMinClassName)
        .attr('width', pixelMin);

    rangeSlider.select('rect.' + constants.maskMaxClassName)
        .attr('x', pixelMax)
        .attr('width', opts._width - pixelMax);

    if(oppAxisRangeOpts.rangemode !== 'match') {
        var pixelMinOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[1]));
        var pixelMaxOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[0]));

        rangeSlider.select('rect.' + constants.maskMinOppAxisClassName)
            .attr('x', pixelMin)
            .attr('height', pixelMinOppAxis)
            .attr('width', pixelMax - pixelMin);

        rangeSlider.select('rect.' + constants.maskMaxOppAxisClassName)
            .attr('x', pixelMin)
            .attr('y', pixelMaxOppAxis)
            .attr('height', opts._height - pixelMaxOppAxis)
            .attr('width', pixelMax - pixelMin);

        rangeSlider.select('rect.' + constants.slideBoxClassName)
            .attr('y', pixelMinOppAxis)
            .attr('height', pixelMaxOppAxis - pixelMinOppAxis);
    }

    // add offset for crispier corners
    // https://github.com/plotly/plotly.js/pull/1409
    var offset = 0.5;

    var xMin = Math.round(clampHandle(pixelMin - hw2)) - offset;
    var xMax = Math.round(clampHandle(pixelMax - hw2)) + offset;

    rangeSlider.select('g.' + constants.grabberMinClassName)
        .attr('transform', 'translate(' + xMin + ',' + offset + ')');

    rangeSlider.select('g.' + constants.grabberMaxClassName)
        .attr('transform', 'translate(' + xMax + ',' + offset + ')');
}

function drawBg(rangeSlider, gd, axisOpts, opts) {
    var bg = Lib.ensureSingle(rangeSlider, 'rect', constants.bgClassName, function(s) {
        s.attr({
            x: 0,
            y: 0,
            'shape-rendering': 'crispEdges'
        });
    });

    var borderCorrect = (opts.borderwidth % 2) === 0 ?
        opts.borderwidth :
        opts.borderwidth - 1;

    var offsetShift = -opts._offsetShift;
    var lw = Drawing.crispRound(gd, opts.borderwidth);

    bg.attr({
        width: opts._width + borderCorrect,
        height: opts._height + borderCorrect,
        transform: 'translate(' + offsetShift + ',' + offsetShift + ')',
        fill: opts.bgcolor,
        stroke: opts.bordercolor,
        'stroke-width': lw
    });
}

function addClipPath(rangeSlider, gd, axisOpts, opts) {
    var fullLayout = gd._fullLayout;

    var clipPath = Lib.ensureSingleById(fullLayout._topdefs, 'clipPath', opts._clipId, function(s) {
        s.append('rect').attr({ x: 0, y: 0 });
    });

    clipPath.select('rect').attr({
        width: opts._width,
        height: opts._height
    });
}

function drawRangePlot(rangeSlider, gd, axisOpts, opts) {
    var calcData = gd.calcdata;

    var rangePlots = rangeSlider.selectAll('g.' + constants.rangePlotClassName)
        .data(axisOpts._subplotsWith, Lib.identity);

    rangePlots.enter().append('g')
        .attr('class', function(id) { return constants.rangePlotClassName + ' ' + id; })
        .call(Drawing.setClipUrl, opts._clipId, gd);

    rangePlots.order();

    rangePlots.exit().remove();

    var mainplotinfo;

    rangePlots.each(function(id, i) {
        var plotgroup = d3.select(this);
        var isMainPlot = (i === 0);

        var oppAxisOpts = axisIDs.getFromId(gd, id, 'y');
        var oppAxisName = oppAxisOpts._name;
        var oppAxisRangeOpts = opts[oppAxisName];

        var mockFigure = {
            data: [],
            layout: {
                xaxis: {
                    type: axisOpts.type,
                    domain: [0, 1],
                    range: opts.range.slice(),
                    calendar: axisOpts.calendar
                },
                width: opts._width,
                height: opts._height,
                margin: { t: 0, b: 0, l: 0, r: 0 }
            },
            _context: gd._context
        };

        if(axisOpts.rangebreaks) {
            mockFigure.layout.xaxis.rangebreaks = axisOpts.rangebreaks;
        }

        mockFigure.layout[oppAxisName] = {
            type: oppAxisOpts.type,
            domain: [0, 1],
            range: oppAxisRangeOpts.rangemode !== 'match' ? oppAxisRangeOpts.range.slice() : oppAxisOpts.range.slice(),
            calendar: oppAxisOpts.calendar
        };

        if(oppAxisOpts.rangebreaks) {
            mockFigure.layout[oppAxisName].rangebreaks = oppAxisOpts.rangebreaks;
        }

        Plots.supplyDefaults(mockFigure);

        var xa = mockFigure._fullLayout.xaxis;
        var ya = mockFigure._fullLayout[oppAxisName];

        xa.clearCalc();
        xa.setScale();
        ya.clearCalc();
        ya.setScale();

        var plotinfo = {
            id: id,
            plotgroup: plotgroup,
            xaxis: xa,
            yaxis: ya,
            isRangePlot: true
        };

        if(isMainPlot) mainplotinfo = plotinfo;
        else {
            plotinfo.mainplot = 'xy';
            plotinfo.mainplotinfo = mainplotinfo;
        }

        Cartesian.rangePlot(gd, plotinfo, filterRangePlotCalcData(calcData, id));
    });
}

function filterRangePlotCalcData(calcData, subplotId) {
    var out = [];

    for(var i = 0; i < calcData.length; i++) {
        var calcTrace = calcData[i];
        var trace = calcTrace[0].trace;

        if(trace.xaxis + trace.yaxis === subplotId) {
            out.push(calcTrace);
        }
    }

    return out;
}

function drawMasks(rangeSlider, gd, axisOpts, opts, oppAxisRangeOpts) {
    var maskMin = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMinClassName, function(s) {
        s.attr({
            x: 0,
            y: 0,
            'shape-rendering': 'crispEdges'
        });
    });

    maskMin
        .attr('height', opts._height)
        .call(Color.fill, constants.maskColor);

    var maskMax = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMaxClassName, function(s) {
        s.attr({
            y: 0,
            'shape-rendering': 'crispEdges'
        });
    });

    maskMax
        .attr('height', opts._height)
        .call(Color.fill, constants.maskColor);

    // masks used for oppAxis zoom
    if(oppAxisRangeOpts.rangemode !== 'match') {
        var maskMinOppAxis = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMinOppAxisClassName, function(s) {
            s.attr({
                y: 0,
                'shape-rendering': 'crispEdges'
            });
        });

        maskMinOppAxis
            .attr('width', opts._width)
            .call(Color.fill, constants.maskOppAxisColor);

        var maskMaxOppAxis = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMaxOppAxisClassName, function(s) {
            s.attr({
                y: 0,
                'shape-rendering': 'crispEdges'
            });
        });

        maskMaxOppAxis
            .attr('width', opts._width)
            .style('border-top', constants.maskOppBorder)
            .call(Color.fill, constants.maskOppAxisColor);
    }
}

function drawSlideBox(rangeSlider, gd, axisOpts, opts) {
    if(gd._context.staticPlot) return;

    var slideBox = Lib.ensureSingle(rangeSlider, 'rect', constants.slideBoxClassName, function(s) {
        s.attr({
            y: 0,
            cursor: constants.slideBoxCursor,
            'shape-rendering': 'crispEdges'
        });
    });

    slideBox.attr({
        height: opts._height,
        fill: constants.slideBoxFill
    });
}

function drawGrabbers(rangeSlider, gd, axisOpts, opts) {
    // <g grabber />
    var grabberMin = Lib.ensureSingle(rangeSlider, 'g', constants.grabberMinClassName);
    var grabberMax = Lib.ensureSingle(rangeSlider, 'g', constants.grabberMaxClassName);

    // <g handle />
    var handleFixAttrs = {
        x: 0,
        width: constants.handleWidth,
        rx: constants.handleRadius,
        fill: Color.background,
        stroke: Color.defaultLine,
        'stroke-width': constants.handleStrokeWidth,
        'shape-rendering': 'crispEdges'
    };
    var handleDynamicAttrs = {
        y: Math.round(opts._height / 4),
        height: Math.round(opts._height / 2),
    };
    var handleMin = Lib.ensureSingle(grabberMin, 'rect', constants.handleMinClassName, function(s) {
        s.attr(handleFixAttrs);
    });
    handleMin.attr(handleDynamicAttrs);

    var handleMax = Lib.ensureSingle(grabberMax, 'rect', constants.handleMaxClassName, function(s) {
        s.attr(handleFixAttrs);
    });
    handleMax.attr(handleDynamicAttrs);

    // <g grabarea />
    if(gd._context.staticPlot) return;

    var grabAreaFixAttrs = {
        width: constants.grabAreaWidth,
        x: 0,
        y: 0,
        fill: constants.grabAreaFill,
        cursor: constants.grabAreaCursor
    };

    var grabAreaMin = Lib.ensureSingle(grabberMin, 'rect', constants.grabAreaMinClassName, function(s) {
        s.attr(grabAreaFixAttrs);
    });
    grabAreaMin.attr('height', opts._height);

    var grabAreaMax = Lib.ensureSingle(grabberMax, 'rect', constants.grabAreaMaxClassName, function(s) {
        s.attr(grabAreaFixAttrs);
    });
    grabAreaMax.attr('height', opts._height);
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/rangeslider/helpers.js":
/*!**********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/rangeslider/helpers.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var axisIDs = __webpack_require__(/*! ../../plots/cartesian/axis_ids */ "./node_modules/plotly.js/src/plots/cartesian/axis_ids.js");
var svgTextUtils = __webpack_require__(/*! ../../lib/svg_text_utils */ "./node_modules/plotly.js/src/lib/svg_text_utils.js");
var constants = __webpack_require__(/*! ./constants */ "./node_modules/plotly.js/src/components/rangeslider/constants.js");
var LINE_SPACING = __webpack_require__(/*! ../../constants/alignment */ "./node_modules/plotly.js/src/constants/alignment.js").LINE_SPACING;
var name = constants.name;

function isVisible(ax) {
    var rangeSlider = ax && ax[name];
    return rangeSlider && rangeSlider.visible;
}
exports.isVisible = isVisible;

exports.makeData = function(fullLayout) {
    var axes = axisIDs.list({ _fullLayout: fullLayout }, 'x', true);
    var margin = fullLayout.margin;
    var rangeSliderData = [];

    if(!fullLayout._has('gl2d')) {
        for(var i = 0; i < axes.length; i++) {
            var ax = axes[i];

            if(isVisible(ax)) {
                rangeSliderData.push(ax);

                var opts = ax[name];
                opts._id = name + ax._id;
                opts._height = (fullLayout.height - margin.b - margin.t) * opts.thickness;
                opts._offsetShift = Math.floor(opts.borderwidth / 2);
            }
        }
    }

    fullLayout._rangeSliderData = rangeSliderData;
};

exports.autoMarginOpts = function(gd, ax) {
    var fullLayout = gd._fullLayout;
    var opts = ax[name];
    var axLetter = ax._id.charAt(0);

    var bottomDepth = 0;
    var titleHeight = 0;
    if(ax.side === 'bottom') {
        bottomDepth = ax._depth;
        if(ax.title.text !== fullLayout._dfltTitle[axLetter]) {
            // as in rangeslider/draw.js
            titleHeight = 1.5 * ax.title.font.size + 10 + opts._offsetShift;
            // multi-line extra bump
            var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
            titleHeight += extraLines * ax.title.font.size * LINE_SPACING;
        }
    }

    return {
        x: 0,
        y: ax._counterDomainMin,
        l: 0,
        r: 0,
        t: 0,
        b: opts._height + bottomDepth + Math.max(fullLayout.margin.b, titleHeight),
        pad: constants.extraPad + opts._offsetShift * 2
    };
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/rangeslider/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/rangeslider/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var attrs = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/rangeslider/attributes.js");
var oppAxisAttrs = __webpack_require__(/*! ./oppaxis_attributes */ "./node_modules/plotly.js/src/components/rangeslider/oppaxis_attributes.js");
var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/plotly.js/src/components/rangeslider/helpers.js");

module.exports = {
    moduleType: 'component',
    name: 'rangeslider',

    schema: {
        subplots: {
            xaxis: {
                rangeslider: Lib.extendFlat({}, attrs, {
                    yaxis: oppAxisAttrs
                })
            }
        }
    },

    layoutAttributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/rangeslider/attributes.js"),
    handleDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/components/rangeslider/defaults.js"),
    calcAutorange: __webpack_require__(/*! ./calc_autorange */ "./node_modules/plotly.js/src/components/rangeslider/calc_autorange.js"),
    draw: __webpack_require__(/*! ./draw */ "./node_modules/plotly.js/src/components/rangeslider/draw.js"),
    isVisible: helpers.isVisible,
    makeData: helpers.makeData,
    autoMarginOpts: helpers.autoMarginOpts
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/rangeslider/oppaxis_attributes.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/rangeslider/oppaxis_attributes.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    // not really a 'subplot' attribute container,
    // but this is the flag we use to denote attributes that
    // support yaxis, yaxis2, yaxis3, ... counters
    _isSubplotObj: true,

    rangemode: {
        valType: 'enumerated',
        values: ['auto', 'fixed', 'match'],
        dflt: 'match',
        role: 'style',
        editType: 'calc',
        description: [
            'Determines whether or not the range of this axis in',
            'the rangeslider use the same value than in the main plot',
            'when zooming in/out.',
            'If *auto*, the autorange will be used.',
            'If *fixed*, the `range` is used.',
            'If *match*, the current range of the corresponding y-axis on the main subplot is used.'
        ].join(' ')
    },
    range: {
        valType: 'info_array',
        role: 'style',
        items: [
            {valType: 'any', editType: 'plot'},
            {valType: 'any', editType: 'plot'}
        ],
        editType: 'plot',
        description: [
            'Sets the range of this axis for the rangeslider.'
        ].join(' ')
    },
    editType: 'calc'
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/shapes/attributes.js":
/*!********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/shapes/attributes.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var annAttrs = __webpack_require__(/*! ../annotations/attributes */ "./node_modules/plotly.js/src/components/annotations/attributes.js");
var scatterLineAttrs = __webpack_require__(/*! ../../traces/scatter/attributes */ "./node_modules/plotly.js/src/traces/scatter/attributes.js").line;
var dash = __webpack_require__(/*! ../drawing/attributes */ "./node_modules/plotly.js/src/components/drawing/attributes.js").dash;
var extendFlat = __webpack_require__(/*! ../../lib/extend */ "./node_modules/plotly.js/src/lib/extend.js").extendFlat;
var templatedArray = __webpack_require__(/*! ../../plot_api/plot_template */ "./node_modules/plotly.js/src/plot_api/plot_template.js").templatedArray;

module.exports = templatedArray('shape', {
    visible: {
        valType: 'boolean',
        role: 'info',
        dflt: true,
        editType: 'calc+arraydraw',
        description: [
            'Determines whether or not this shape is visible.'
        ].join(' ')
    },

    type: {
        valType: 'enumerated',
        values: ['circle', 'rect', 'path', 'line'],
        role: 'info',
        editType: 'calc+arraydraw',
        description: [
            'Specifies the shape type to be drawn.',

            'If *line*, a line is drawn from (`x0`,`y0`) to (`x1`,`y1`)',
            'with respect to the axes\' sizing mode.',

            'If *circle*, a circle is drawn from',
            '((`x0`+`x1`)/2, (`y0`+`y1`)/2))',
            'with radius',
            '(|(`x0`+`x1`)/2 - `x0`|, |(`y0`+`y1`)/2 -`y0`)|)',
            'with respect to the axes\' sizing mode.',

            'If *rect*, a rectangle is drawn linking',
            '(`x0`,`y0`), (`x1`,`y0`), (`x1`,`y1`), (`x0`,`y1`), (`x0`,`y0`)',
            'with respect to the axes\' sizing mode.',

            'If *path*, draw a custom SVG path using `path`.',
            'with respect to the axes\' sizing mode.'
        ].join(' ')
    },

    layer: {
        valType: 'enumerated',
        values: ['below', 'above'],
        dflt: 'above',
        role: 'info',
        editType: 'arraydraw',
        description: 'Specifies whether shapes are drawn below or above traces.'
    },

    xref: extendFlat({}, annAttrs.xref, {
        description: [
            'Sets the shape\'s x coordinate axis.',
            'If set to an x axis id (e.g. *x* or *x2*), the `x` position',
            'refers to an x coordinate.',
            'If set to *paper*, the `x` position refers to the distance from',
            'the left side of the plotting area in normalized coordinates',
            'where *0* (*1*) corresponds to the left (right) side.',
            'If the axis `type` is *log*, then you must take the',
            'log of your desired range.',
            'If the axis `type` is *date*, then you must convert',
            'the date to unix time in milliseconds.'
        ].join(' ')
    }),
    xsizemode: {
        valType: 'enumerated',
        values: ['scaled', 'pixel'],
        dflt: 'scaled',
        role: 'info',
        editType: 'calc+arraydraw',
        description: [
            'Sets the shapes\'s sizing mode along the x axis.',
            'If set to *scaled*, `x0`, `x1` and x coordinates within `path` refer to',
            'data values on the x axis or a fraction of the plot area\'s width',
            '(`xref` set to *paper*).',
            'If set to *pixel*, `xanchor` specifies the x position in terms',
            'of data or plot fraction but `x0`, `x1` and x coordinates within `path`',
            'are pixels relative to `xanchor`. This way, the shape can have',
            'a fixed width while maintaining a position relative to data or',
            'plot fraction.'
        ].join(' ')
    },
    xanchor: {
        valType: 'any',
        role: 'info',
        editType: 'calc+arraydraw',
        description: [
            'Only relevant in conjunction with `xsizemode` set to *pixel*.',
            'Specifies the anchor point on the x axis to which `x0`, `x1`',
            'and x coordinates within `path` are relative to.',
            'E.g. useful to attach a pixel sized shape to a certain data value.',
            'No effect when `xsizemode` not set to *pixel*.'
        ].join(' ')
    },
    x0: {
        valType: 'any',
        role: 'info',
        editType: 'calc+arraydraw',
        description: [
            'Sets the shape\'s starting x position.',
            'See `type` and `xsizemode` for more info.'
        ].join(' ')
    },
    x1: {
        valType: 'any',
        role: 'info',
        editType: 'calc+arraydraw',
        description: [
            'Sets the shape\'s end x position.',
            'See `type` and `xsizemode` for more info.'
        ].join(' ')
    },

    yref: extendFlat({}, annAttrs.yref, {
        description: [
            'Sets the annotation\'s y coordinate axis.',
            'If set to an y axis id (e.g. *y* or *y2*), the `y` position',
            'refers to an y coordinate',
            'If set to *paper*, the `y` position refers to the distance from',
            'the bottom of the plotting area in normalized coordinates',
            'where *0* (*1*) corresponds to the bottom (top).'
        ].join(' ')
    }),
    ysizemode: {
        valType: 'enumerated',
        values: ['scaled', 'pixel'],
        dflt: 'scaled',
        role: 'info',
        editType: 'calc+arraydraw',
        description: [
            'Sets the shapes\'s sizing mode along the y axis.',
            'If set to *scaled*, `y0`, `y1` and y coordinates within `path` refer to',
            'data values on the y axis or a fraction of the plot area\'s height',
            '(`yref` set to *paper*).',
            'If set to *pixel*, `yanchor` specifies the y position in terms',
            'of data or plot fraction but `y0`, `y1` and y coordinates within `path`',
            'are pixels relative to `yanchor`. This way, the shape can have',
            'a fixed height while maintaining a position relative to data or',
            'plot fraction.'
        ].join(' ')
    },
    yanchor: {
        valType: 'any',
        role: 'info',
        editType: 'calc+arraydraw',
        description: [
            'Only relevant in conjunction with `ysizemode` set to *pixel*.',
            'Specifies the anchor point on the y axis to which `y0`, `y1`',
            'and y coordinates within `path` are relative to.',
            'E.g. useful to attach a pixel sized shape to a certain data value.',
            'No effect when `ysizemode` not set to *pixel*.'
        ].join(' ')
    },
    y0: {
        valType: 'any',
        role: 'info',
        editType: 'calc+arraydraw',
        description: [
            'Sets the shape\'s starting y position.',
            'See `type` and `ysizemode` for more info.'
        ].join(' ')
    },
    y1: {
        valType: 'any',
        role: 'info',
        editType: 'calc+arraydraw',
        description: [
            'Sets the shape\'s end y position.',
            'See `type` and `ysizemode` for more info.'
        ].join(' ')
    },

    path: {
        valType: 'string',
        role: 'info',
        editType: 'calc+arraydraw',
        description: [
            'For `type` *path* - a valid SVG path with the pixel values',
            'replaced by data values in `xsizemode`/`ysizemode` being *scaled*',
            'and taken unmodified as pixels relative to `xanchor` and `yanchor`',
            'in case of *pixel* size mode.',
            'There are a few restrictions / quirks',
            'only absolute instructions, not relative. So the allowed segments',
            'are: M, L, H, V, Q, C, T, S, and Z',
            'arcs (A) are not allowed because radius rx and ry are relative.',

            'In the future we could consider supporting relative commands,',
            'but we would have to decide on how to handle date and log axes.',
            'Note that even as is, Q and C Bezier paths that are smooth on',
            'linear axes may not be smooth on log, and vice versa.',
            'no chained "polybezier" commands - specify the segment type for',
            'each one.',

            'On category axes, values are numbers scaled to the serial numbers',
            'of categories because using the categories themselves there would',
            'be no way to describe fractional positions',
            'On data axes: because space and T are both normal components of path',
            'strings, we can\'t use either to separate date from time parts.',
            'Therefore we\'ll use underscore for this purpose:',
            '2015-02-21_13:45:56.789'
        ].join(' ')
    },

    opacity: {
        valType: 'number',
        min: 0,
        max: 1,
        dflt: 1,
        role: 'info',
        editType: 'arraydraw',
        description: 'Sets the opacity of the shape.'
    },
    line: {
        color: extendFlat({}, scatterLineAttrs.color, {editType: 'arraydraw'}),
        width: extendFlat({}, scatterLineAttrs.width, {editType: 'calc+arraydraw'}),
        dash: extendFlat({}, dash, {editType: 'arraydraw'}),
        role: 'info',
        editType: 'calc+arraydraw'
    },
    fillcolor: {
        valType: 'color',
        dflt: 'rgba(0,0,0,0)',
        role: 'info',
        editType: 'arraydraw',
        description: [
            'Sets the color filling the shape\'s interior. Only applies to closed shapes.'
        ].join(' ')
    },
    fillrule: {
        valType: 'enumerated',
        values: ['evenodd', 'nonzero'],
        dflt: 'evenodd',
        role: 'info',
        editType: 'arraydraw',
        description: [
            'Determines which regions of complex paths constitute the interior.',
            'For more info please visit https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule'
        ].join(' ')
    },
    editable: {
        valType: 'boolean',
        role: 'info',
        dflt: false,
        editType: 'calc+arraydraw',
        description: [
            'Determines whether the shape could be activated for edit or not.',
            'Has no effect when the older editable shapes mode is enabled via',
            '`config.editable` or `config.edits.shapePosition`.'
        ].join(' ')
    },

    editType: 'arraydraw'
});


/***/ }),

/***/ "./node_modules/plotly.js/src/components/shapes/calc_autorange.js":
/*!************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/shapes/calc_autorange.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Axes = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js");

var constants = __webpack_require__(/*! ./constants */ "./node_modules/plotly.js/src/components/shapes/constants.js");
var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/plotly.js/src/components/shapes/helpers.js");


module.exports = function calcAutorange(gd) {
    var fullLayout = gd._fullLayout;
    var shapeList = Lib.filterVisible(fullLayout.shapes);

    if(!shapeList.length || !gd._fullData.length) return;

    for(var i = 0; i < shapeList.length; i++) {
        var shape = shapeList[i];
        shape._extremes = {};

        var ax, bounds;

        if(shape.xref !== 'paper') {
            var vx0 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x0;
            var vx1 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x1;
            ax = Axes.getFromId(gd, shape.xref);

            bounds = shapeBounds(ax, vx0, vx1, shape.path, constants.paramIsX);
            if(bounds) {
                shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcXPaddingOptions(shape));
            }
        }

        if(shape.yref !== 'paper') {
            var vy0 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y0;
            var vy1 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y1;
            ax = Axes.getFromId(gd, shape.yref);

            bounds = shapeBounds(ax, vy0, vy1, shape.path, constants.paramIsY);
            if(bounds) {
                shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcYPaddingOptions(shape));
            }
        }
    }
};

function calcXPaddingOptions(shape) {
    return calcPaddingOptions(shape.line.width, shape.xsizemode, shape.x0, shape.x1, shape.path, false);
}

function calcYPaddingOptions(shape) {
    return calcPaddingOptions(shape.line.width, shape.ysizemode, shape.y0, shape.y1, shape.path, true);
}

function calcPaddingOptions(lineWidth, sizeMode, v0, v1, path, isYAxis) {
    var ppad = lineWidth / 2;
    var axisDirectionReverted = isYAxis;

    if(sizeMode === 'pixel') {
        var coords = path ?
            helpers.extractPathCoords(path, isYAxis ? constants.paramIsY : constants.paramIsX) :
            [v0, v1];
        var maxValue = Lib.aggNums(Math.max, null, coords);
        var minValue = Lib.aggNums(Math.min, null, coords);
        var beforePad = minValue < 0 ? Math.abs(minValue) + ppad : ppad;
        var afterPad = maxValue > 0 ? maxValue + ppad : ppad;

        return {
            ppad: ppad,
            ppadplus: axisDirectionReverted ? beforePad : afterPad,
            ppadminus: axisDirectionReverted ? afterPad : beforePad
        };
    } else {
        return {ppad: ppad};
    }
}

function shapeBounds(ax, v0, v1, path, paramsToUse) {
    var convertVal = (ax.type === 'category' || ax.type === 'multicategory') ? ax.r2c : ax.d2c;

    if(v0 !== undefined) return [convertVal(v0), convertVal(v1)];
    if(!path) return;

    var min = Infinity;
    var max = -Infinity;
    var segments = path.match(constants.segmentRE);
    var i;
    var segment;
    var drawnParam;
    var params;
    var val;

    if(ax.type === 'date') convertVal = helpers.decodeDate(convertVal);

    for(i = 0; i < segments.length; i++) {
        segment = segments[i];
        drawnParam = paramsToUse[segment.charAt(0)].drawn;
        if(drawnParam === undefined) continue;

        params = segments[i].substr(1).match(constants.paramRE);
        if(!params || params.length < drawnParam) continue;

        val = convertVal(params[drawnParam]);
        if(val < min) min = val;
        if(val > max) max = val;
    }
    if(max >= min) return [min, max];
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/shapes/defaults.js":
/*!******************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/shapes/defaults.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Axes = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js");
var handleArrayContainerDefaults = __webpack_require__(/*! ../../plots/array_container_defaults */ "./node_modules/plotly.js/src/plots/array_container_defaults.js");

var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/shapes/attributes.js");
var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/plotly.js/src/components/shapes/helpers.js");


module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
    handleArrayContainerDefaults(layoutIn, layoutOut, {
        name: 'shapes',
        handleItemDefaults: handleShapeDefaults
    });
};

function handleShapeDefaults(shapeIn, shapeOut, fullLayout) {
    function coerce(attr, dflt) {
        return Lib.coerce(shapeIn, shapeOut, attributes, attr, dflt);
    }

    var visible = coerce('visible');
    if(!visible) return;

    var path = coerce('path');
    var dfltType = path ? 'path' : 'rect';
    var shapeType = coerce('type', dfltType);
    if(shapeOut.type !== 'path') delete shapeOut.path;

    coerce('editable');
    coerce('layer');
    coerce('opacity');
    coerce('fillcolor');
    coerce('fillrule');
    var lineWidth = coerce('line.width');
    if(lineWidth) {
        coerce('line.color');
        coerce('line.dash');
    }

    var xSizeMode = coerce('xsizemode');
    var ySizeMode = coerce('ysizemode');

    // positioning
    var axLetters = ['x', 'y'];
    for(var i = 0; i < 2; i++) {
        var axLetter = axLetters[i];
        var attrAnchor = axLetter + 'anchor';
        var sizeMode = axLetter === 'x' ? xSizeMode : ySizeMode;
        var gdMock = {_fullLayout: fullLayout};
        var ax;
        var pos2r;
        var r2pos;

        // xref, yref
        var axRef = Axes.coerceRef(shapeIn, shapeOut, gdMock, axLetter, '', 'paper');

        if(axRef !== 'paper') {
            ax = Axes.getFromId(gdMock, axRef);
            ax._shapeIndices.push(shapeOut._index);
            r2pos = helpers.rangeToShapePosition(ax);
            pos2r = helpers.shapePositionToRange(ax);
        } else {
            pos2r = r2pos = Lib.identity;
        }

        // Coerce x0, x1, y0, y1
        if(shapeType !== 'path') {
            var dflt0 = 0.25;
            var dflt1 = 0.75;

            // hack until V2.0 when log has regular range behavior - make it look like other
            // ranges to send to coerce, then put it back after
            // this is all to give reasonable default position behavior on log axes, which is
            // a pretty unimportant edge case so we could just ignore this.
            var attr0 = axLetter + '0';
            var attr1 = axLetter + '1';
            var in0 = shapeIn[attr0];
            var in1 = shapeIn[attr1];
            shapeIn[attr0] = pos2r(shapeIn[attr0], true);
            shapeIn[attr1] = pos2r(shapeIn[attr1], true);

            if(sizeMode === 'pixel') {
                coerce(attr0, 0);
                coerce(attr1, 10);
            } else {
                Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attr0, dflt0);
                Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attr1, dflt1);
            }

            // hack part 2
            shapeOut[attr0] = r2pos(shapeOut[attr0]);
            shapeOut[attr1] = r2pos(shapeOut[attr1]);
            shapeIn[attr0] = in0;
            shapeIn[attr1] = in1;
        }

        // Coerce xanchor and yanchor
        if(sizeMode === 'pixel') {
            // Hack for log axis described above
            var inAnchor = shapeIn[attrAnchor];
            shapeIn[attrAnchor] = pos2r(shapeIn[attrAnchor], true);

            Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attrAnchor, 0.25);

            // Hack part 2
            shapeOut[attrAnchor] = r2pos(shapeOut[attrAnchor]);
            shapeIn[attrAnchor] = inAnchor;
        }
    }

    if(shapeType === 'path') {
        coerce('path');
    } else {
        Lib.noneOrAll(shapeIn, shapeOut, ['x0', 'x1', 'y0', 'y1']);
    }
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/shapes/draw_newshape/defaults.js":
/*!********************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/shapes/draw_newshape/defaults.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var Color = __webpack_require__(/*! ../../color */ "./node_modules/plotly.js/src/components/color/index.js");


module.exports = function supplyDrawNewShapeDefaults(layoutIn, layoutOut, coerce) {
    coerce('newshape.drawdirection');
    coerce('newshape.layer');
    coerce('newshape.fillcolor');
    coerce('newshape.fillrule');
    coerce('newshape.opacity');
    var newshapeLineWidth = coerce('newshape.line.width');
    if(newshapeLineWidth) {
        var bgcolor = (layoutIn || {}).plot_bgcolor || '#FFF';
        coerce('newshape.line.color', Color.contrast(bgcolor));
        coerce('newshape.line.dash');
    }

    coerce('activeshape.fillcolor');
    coerce('activeshape.opacity');
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/shapes/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/shapes/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var drawModule = __webpack_require__(/*! ./draw */ "./node_modules/plotly.js/src/components/shapes/draw.js");

module.exports = {
    moduleType: 'component',
    name: 'shapes',

    layoutAttributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/shapes/attributes.js"),
    supplyLayoutDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/components/shapes/defaults.js"),
    supplyDrawNewShapeDefaults: __webpack_require__(/*! ./draw_newshape/defaults */ "./node_modules/plotly.js/src/components/shapes/draw_newshape/defaults.js"),
    includeBasePlot: __webpack_require__(/*! ../../plots/cartesian/include_components */ "./node_modules/plotly.js/src/plots/cartesian/include_components.js")('shapes'),

    calcAutorange: __webpack_require__(/*! ./calc_autorange */ "./node_modules/plotly.js/src/components/shapes/calc_autorange.js"),
    draw: drawModule.draw,
    drawOne: drawModule.drawOne
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/sliders/attributes.js":
/*!*********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/sliders/attributes.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var fontAttrs = __webpack_require__(/*! ../../plots/font_attributes */ "./node_modules/plotly.js/src/plots/font_attributes.js");
var padAttrs = __webpack_require__(/*! ../../plots/pad_attributes */ "./node_modules/plotly.js/src/plots/pad_attributes.js");
var extendDeepAll = __webpack_require__(/*! ../../lib/extend */ "./node_modules/plotly.js/src/lib/extend.js").extendDeepAll;
var overrideAll = __webpack_require__(/*! ../../plot_api/edit_types */ "./node_modules/plotly.js/src/plot_api/edit_types.js").overrideAll;
var animationAttrs = __webpack_require__(/*! ../../plots/animation_attributes */ "./node_modules/plotly.js/src/plots/animation_attributes.js");
var templatedArray = __webpack_require__(/*! ../../plot_api/plot_template */ "./node_modules/plotly.js/src/plot_api/plot_template.js").templatedArray;
var constants = __webpack_require__(/*! ./constants */ "./node_modules/plotly.js/src/components/sliders/constants.js");

var stepsAttrs = templatedArray('step', {
    visible: {
        valType: 'boolean',
        role: 'info',
        dflt: true,
        description: [
            'Determines whether or not this step is included in the slider.'
        ].join(' ')
    },
    method: {
        valType: 'enumerated',
        values: ['restyle', 'relayout', 'animate', 'update', 'skip'],
        dflt: 'restyle',
        role: 'info',
        description: [
            'Sets the Plotly method to be called when the slider value is changed.',
            'If the `skip` method is used, the API slider will function as normal',
            'but will perform no API calls and will not bind automatically to state',
            'updates. This may be used to create a component interface and attach to',
            'slider events manually via JavaScript.'
        ].join(' ')
    },
    args: {
        valType: 'info_array',
        role: 'info',
        freeLength: true,
        items: [
            { valType: 'any' },
            { valType: 'any' },
            { valType: 'any' }
        ],
        description: [
            'Sets the arguments values to be passed to the Plotly',
            'method set in `method` on slide.'
        ].join(' ')
    },
    label: {
        valType: 'string',
        role: 'info',
        description: 'Sets the text label to appear on the slider'
    },
    value: {
        valType: 'string',
        role: 'info',
        description: [
            'Sets the value of the slider step, used to refer to the step programatically.',
            'Defaults to the slider label if not provided.'
        ].join(' ')
    },
    execute: {
        valType: 'boolean',
        role: 'info',
        dflt: true,
        description: [
            'When true, the API method is executed. When false, all other behaviors are the same',
            'and command execution is skipped. This may be useful when hooking into, for example,',
            'the `plotly_sliderchange` method and executing the API command manually without losing',
            'the benefit of the slider automatically binding to the state of the plot through the',
            'specification of `method` and `args`.'
        ].join(' ')
    }
});

module.exports = overrideAll(templatedArray('slider', {
    visible: {
        valType: 'boolean',
        role: 'info',
        dflt: true,
        description: [
            'Determines whether or not the slider is visible.'
        ].join(' ')
    },

    active: {
        valType: 'number',
        role: 'info',
        min: 0,
        dflt: 0,
        description: [
            'Determines which button (by index starting from 0) is',
            'considered active.'
        ].join(' ')
    },

    steps: stepsAttrs,

    lenmode: {
        valType: 'enumerated',
        values: ['fraction', 'pixels'],
        role: 'info',
        dflt: 'fraction',
        description: [
            'Determines whether this slider length',
            'is set in units of plot *fraction* or in *pixels.',
            'Use `len` to set the value.'
        ].join(' ')
    },
    len: {
        valType: 'number',
        min: 0,
        dflt: 1,
        role: 'style',
        description: [
            'Sets the length of the slider',
            'This measure excludes the padding of both ends.',
            'That is, the slider\'s length is this length minus the',
            'padding on both ends.'
        ].join(' ')
    },
    x: {
        valType: 'number',
        min: -2,
        max: 3,
        dflt: 0,
        role: 'style',
        description: 'Sets the x position (in normalized coordinates) of the slider.'
    },
    pad: extendDeepAll(padAttrs({editType: 'arraydraw'}), {
        description: 'Set the padding of the slider component along each side.'
    }, {t: {dflt: 20}}),
    xanchor: {
        valType: 'enumerated',
        values: ['auto', 'left', 'center', 'right'],
        dflt: 'left',
        role: 'info',
        description: [
            'Sets the slider\'s horizontal position anchor.',
            'This anchor binds the `x` position to the *left*, *center*',
            'or *right* of the range selector.'
        ].join(' ')
    },
    y: {
        valType: 'number',
        min: -2,
        max: 3,
        dflt: 0,
        role: 'style',
        description: 'Sets the y position (in normalized coordinates) of the slider.'
    },
    yanchor: {
        valType: 'enumerated',
        values: ['auto', 'top', 'middle', 'bottom'],
        dflt: 'top',
        role: 'info',
        description: [
            'Sets the slider\'s vertical position anchor',
            'This anchor binds the `y` position to the *top*, *middle*',
            'or *bottom* of the range selector.'
        ].join(' ')
    },

    transition: {
        duration: {
            valType: 'number',
            role: 'info',
            min: 0,
            dflt: 150,
            description: 'Sets the duration of the slider transition'
        },
        easing: {
            valType: 'enumerated',
            values: animationAttrs.transition.easing.values,
            role: 'info',
            dflt: 'cubic-in-out',
            description: 'Sets the easing function of the slider transition'
        }
    },

    currentvalue: {
        visible: {
            valType: 'boolean',
            role: 'info',
            dflt: true,
            description: [
                'Shows the currently-selected value above the slider.'
            ].join(' ')
        },

        xanchor: {
            valType: 'enumerated',
            values: ['left', 'center', 'right'],
            dflt: 'left',
            role: 'info',
            description: [
                'The alignment of the value readout relative to the length of the slider.'
            ].join(' ')
        },

        offset: {
            valType: 'number',
            dflt: 10,
            role: 'info',
            description: [
                'The amount of space, in pixels, between the current value label',
                'and the slider.'
            ].join(' ')
        },

        prefix: {
            valType: 'string',
            role: 'info',
            description: 'When currentvalue.visible is true, this sets the prefix of the label.'
        },

        suffix: {
            valType: 'string',
            role: 'info',
            description: 'When currentvalue.visible is true, this sets the suffix of the label.'
        },

        font: fontAttrs({
            description: 'Sets the font of the current value label text.'
        })
    },

    font: fontAttrs({
        description: 'Sets the font of the slider step labels.'
    }),

    activebgcolor: {
        valType: 'color',
        role: 'style',
        dflt: constants.gripBgActiveColor,
        description: [
            'Sets the background color of the slider grip',
            'while dragging.'
        ].join(' ')
    },
    bgcolor: {
        valType: 'color',
        role: 'style',
        dflt: constants.railBgColor,
        description: 'Sets the background color of the slider.'
    },
    bordercolor: {
        valType: 'color',
        dflt: constants.railBorderColor,
        role: 'style',
        description: 'Sets the color of the border enclosing the slider.'
    },
    borderwidth: {
        valType: 'number',
        min: 0,
        dflt: constants.railBorderWidth,
        role: 'style',
        description: 'Sets the width (in px) of the border enclosing the slider.'
    },
    ticklen: {
        valType: 'number',
        min: 0,
        dflt: constants.tickLength,
        role: 'style',
        description: 'Sets the length in pixels of step tick marks'
    },
    tickcolor: {
        valType: 'color',
        dflt: constants.tickColor,
        role: 'style',
        description: 'Sets the color of the border enclosing the slider.'
    },
    tickwidth: {
        valType: 'number',
        min: 0,
        dflt: 1,
        role: 'style',
        description: 'Sets the tick width (in px).'
    },
    minorticklen: {
        valType: 'number',
        min: 0,
        dflt: constants.minorTickLength,
        role: 'style',
        description: 'Sets the length in pixels of minor step tick marks'
    }
}), 'arraydraw', 'from-root');


/***/ }),

/***/ "./node_modules/plotly.js/src/components/sliders/constants.js":
/*!********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/sliders/constants.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/





module.exports = {

    // layout attribute name
    name: 'sliders',

    // class names
    containerClassName: 'slider-container',
    groupClassName: 'slider-group',
    inputAreaClass: 'slider-input-area',
    railRectClass: 'slider-rail-rect',
    railTouchRectClass: 'slider-rail-touch-rect',
    gripRectClass: 'slider-grip-rect',
    tickRectClass: 'slider-tick-rect',
    inputProxyClass: 'slider-input-proxy',
    labelsClass: 'slider-labels',
    labelGroupClass: 'slider-label-group',
    labelClass: 'slider-label',
    currentValueClass: 'slider-current-value',

    railHeight: 5,

    // DOM attribute name in button group keeping track
    // of active update menu
    menuIndexAttrName: 'slider-active-index',

    // id root pass to Plots.autoMargin
    autoMarginIdRoot: 'slider-',

    // min item width / height
    minWidth: 30,
    minHeight: 30,

    // padding around item text
    textPadX: 40,

    // arrow offset off right edge
    arrowOffsetX: 4,

    railRadius: 2,
    railWidth: 5,
    railBorder: 4,
    railBorderWidth: 1,
    railBorderColor: '#bec8d9',
    railBgColor: '#f8fafc',

    // The distance of the rail from the edge of the touchable area
    // Slightly less than the step inset because of the curved edges
    // of the rail
    railInset: 8,

    // The distance from the extremal tick marks to the edge of the
    // touchable area. This is basically the same as the grip radius,
    // but for other styles it wouldn't really need to be.
    stepInset: 10,

    gripRadius: 10,
    gripWidth: 20,
    gripHeight: 20,
    gripBorder: 20,
    gripBorderWidth: 1,
    gripBorderColor: '#bec8d9',
    gripBgColor: '#f6f8fa',
    gripBgActiveColor: '#dbdde0',

    labelPadding: 8,
    labelOffset: 0,

    tickWidth: 1,
    tickColor: '#333',
    tickOffset: 25,
    tickLength: 7,

    minorTickOffset: 25,
    minorTickColor: '#333',
    minorTickLength: 4,

    // Extra space below the current value label:
    currentValuePadding: 8,
    currentValueInset: 0,
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/sliders/defaults.js":
/*!*******************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/sliders/defaults.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var handleArrayContainerDefaults = __webpack_require__(/*! ../../plots/array_container_defaults */ "./node_modules/plotly.js/src/plots/array_container_defaults.js");

var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/sliders/attributes.js");
var constants = __webpack_require__(/*! ./constants */ "./node_modules/plotly.js/src/components/sliders/constants.js");

var name = constants.name;
var stepAttrs = attributes.steps;


module.exports = function slidersDefaults(layoutIn, layoutOut) {
    handleArrayContainerDefaults(layoutIn, layoutOut, {
        name: name,
        handleItemDefaults: sliderDefaults
    });
};

function sliderDefaults(sliderIn, sliderOut, layoutOut) {
    function coerce(attr, dflt) {
        return Lib.coerce(sliderIn, sliderOut, attributes, attr, dflt);
    }

    var steps = handleArrayContainerDefaults(sliderIn, sliderOut, {
        name: 'steps',
        handleItemDefaults: stepDefaults
    });

    var stepCount = 0;
    for(var i = 0; i < steps.length; i++) {
        if(steps[i].visible) stepCount++;
    }

    var visible;
    // If it has fewer than two options, it's not really a slider
    if(stepCount < 2) visible = sliderOut.visible = false;
    else visible = coerce('visible');
    if(!visible) return;

    sliderOut._stepCount = stepCount;
    var visSteps = sliderOut._visibleSteps = Lib.filterVisible(steps);

    var active = coerce('active');
    if(!(steps[active] || {}).visible) sliderOut.active = visSteps[0]._index;

    coerce('x');
    coerce('y');
    Lib.noneOrAll(sliderIn, sliderOut, ['x', 'y']);

    coerce('xanchor');
    coerce('yanchor');

    coerce('len');
    coerce('lenmode');

    coerce('pad.t');
    coerce('pad.r');
    coerce('pad.b');
    coerce('pad.l');

    Lib.coerceFont(coerce, 'font', layoutOut.font);

    var currentValueIsVisible = coerce('currentvalue.visible');

    if(currentValueIsVisible) {
        coerce('currentvalue.xanchor');
        coerce('currentvalue.prefix');
        coerce('currentvalue.suffix');
        coerce('currentvalue.offset');

        Lib.coerceFont(coerce, 'currentvalue.font', sliderOut.font);
    }

    coerce('transition.duration');
    coerce('transition.easing');

    coerce('bgcolor');
    coerce('activebgcolor');
    coerce('bordercolor');
    coerce('borderwidth');
    coerce('ticklen');
    coerce('tickwidth');
    coerce('tickcolor');
    coerce('minorticklen');
}

function stepDefaults(valueIn, valueOut) {
    function coerce(attr, dflt) {
        return Lib.coerce(valueIn, valueOut, stepAttrs, attr, dflt);
    }

    var visible;
    if(valueIn.method !== 'skip' && !Array.isArray(valueIn.args)) {
        visible = valueOut.visible = false;
    } else visible = coerce('visible');

    if(visible) {
        coerce('method');
        coerce('args');
        var label = coerce('label', 'step-' + valueOut._index);
        coerce('value', label);
        coerce('execute');
    }
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/sliders/draw.js":
/*!***************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/sliders/draw.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");

var Plots = __webpack_require__(/*! ../../plots/plots */ "./node_modules/plotly.js/src/plots/plots.js");
var Color = __webpack_require__(/*! ../color */ "./node_modules/plotly.js/src/components/color/index.js");
var Drawing = __webpack_require__(/*! ../drawing */ "./node_modules/plotly.js/src/components/drawing/index.js");
var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var svgTextUtils = __webpack_require__(/*! ../../lib/svg_text_utils */ "./node_modules/plotly.js/src/lib/svg_text_utils.js");
var arrayEditor = __webpack_require__(/*! ../../plot_api/plot_template */ "./node_modules/plotly.js/src/plot_api/plot_template.js").arrayEditor;

var constants = __webpack_require__(/*! ./constants */ "./node_modules/plotly.js/src/components/sliders/constants.js");
var alignmentConstants = __webpack_require__(/*! ../../constants/alignment */ "./node_modules/plotly.js/src/constants/alignment.js");
var LINE_SPACING = alignmentConstants.LINE_SPACING;
var FROM_TL = alignmentConstants.FROM_TL;
var FROM_BR = alignmentConstants.FROM_BR;

module.exports = function draw(gd) {
    var fullLayout = gd._fullLayout;
    var sliderData = makeSliderData(fullLayout, gd);

    // draw a container for *all* sliders:
    var sliders = fullLayout._infolayer
        .selectAll('g.' + constants.containerClassName)
        .data(sliderData.length > 0 ? [0] : []);

    sliders.enter().append('g')
        .classed(constants.containerClassName, true)
        .style('cursor', 'ew-resize');

    function clearSlider(sliderOpts) {
        if(sliderOpts._commandObserver) {
            sliderOpts._commandObserver.remove();
            delete sliderOpts._commandObserver;
        }

        // Most components don't need to explicitly remove autoMargin, because
        // marginPushers does this - but slider updates don't go through
        // a full replot so we need to explicitly remove it.
        Plots.autoMargin(gd, autoMarginId(sliderOpts));
    }

    sliders.exit().each(function() {
        d3.select(this).selectAll('g.' + constants.groupClassName)
            .each(clearSlider);
    })
    .remove();

    // Return early if no menus visible:
    if(sliderData.length === 0) return;

    var sliderGroups = sliders.selectAll('g.' + constants.groupClassName)
        .data(sliderData, keyFunction);

    sliderGroups.enter().append('g')
        .classed(constants.groupClassName, true);

    sliderGroups.exit()
        .each(clearSlider)
        .remove();

    // Find the dimensions of the sliders:
    for(var i = 0; i < sliderData.length; i++) {
        var sliderOpts = sliderData[i];
        findDimensions(gd, sliderOpts);
    }

    sliderGroups.each(function(sliderOpts) {
        var gSlider = d3.select(this);

        computeLabelSteps(sliderOpts);

        Plots.manageCommandObserver(gd, sliderOpts, sliderOpts._visibleSteps, function(data) {
            // NB: Same as below. This is *not* always the same as sliderOpts since
            // if a new set of steps comes in, the reference in this callback would
            // be invalid. We need to refetch it from the slider group, which is
            // the join data that creates this slider. So if this slider still exists,
            // the group should be valid, *to the best of my knowledge.* If not,
            // we'd have to look it up by d3 data join index/key.
            var opts = gSlider.data()[0];

            if(opts.active === data.index) return;
            if(opts._dragging) return;

            setActive(gd, gSlider, opts, data.index, false, true);
        });

        drawSlider(gd, d3.select(this), sliderOpts);
    });
};

function autoMarginId(sliderOpts) {
    return constants.autoMarginIdRoot + sliderOpts._index;
}

// This really only just filters by visibility:
function makeSliderData(fullLayout, gd) {
    var contOpts = fullLayout[constants.name];
    var sliderData = [];

    for(var i = 0; i < contOpts.length; i++) {
        var item = contOpts[i];
        if(!item.visible) continue;
        item._gd = gd;
        sliderData.push(item);
    }

    return sliderData;
}

// This is set in the defaults step:
function keyFunction(opts) {
    return opts._index;
}

// Compute the dimensions (mutates sliderOpts):
function findDimensions(gd, sliderOpts) {
    var sliderLabels = Drawing.tester.selectAll('g.' + constants.labelGroupClass)
        .data(sliderOpts._visibleSteps);

    sliderLabels.enter().append('g')
        .classed(constants.labelGroupClass, true);

    // loop over fake buttons to find width / height
    var maxLabelWidth = 0;
    var labelHeight = 0;
    sliderLabels.each(function(stepOpts) {
        var labelGroup = d3.select(this);

        var text = drawLabel(labelGroup, {step: stepOpts}, sliderOpts);

        var textNode = text.node();
        if(textNode) {
            var bBox = Drawing.bBox(textNode);
            labelHeight = Math.max(labelHeight, bBox.height);
            maxLabelWidth = Math.max(maxLabelWidth, bBox.width);
        }
    });

    sliderLabels.remove();

    var dims = sliderOpts._dims = {};

    dims.inputAreaWidth = Math.max(
        constants.railWidth,
        constants.gripHeight
    );

    // calculate some overall dimensions - some of these are needed for
    // calculating the currentValue dimensions
    var graphSize = gd._fullLayout._size;
    dims.lx = graphSize.l + graphSize.w * sliderOpts.x;
    dims.ly = graphSize.t + graphSize.h * (1 - sliderOpts.y);

    if(sliderOpts.lenmode === 'fraction') {
        // fraction:
        dims.outerLength = Math.round(graphSize.w * sliderOpts.len);
    } else {
        // pixels:
        dims.outerLength = sliderOpts.len;
    }

    // The length of the rail, *excluding* padding on either end:
    dims.inputAreaStart = 0;
    dims.inputAreaLength = Math.round(dims.outerLength - sliderOpts.pad.l - sliderOpts.pad.r);

    var textableInputLength = dims.inputAreaLength - 2 * constants.stepInset;
    var availableSpacePerLabel = textableInputLength / (sliderOpts._stepCount - 1);
    var computedSpacePerLabel = maxLabelWidth + constants.labelPadding;
    dims.labelStride = Math.max(1, Math.ceil(computedSpacePerLabel / availableSpacePerLabel));
    dims.labelHeight = labelHeight;

    // loop over all possible values for currentValue to find the
    // area we need for it
    dims.currentValueMaxWidth = 0;
    dims.currentValueHeight = 0;
    dims.currentValueTotalHeight = 0;
    dims.currentValueMaxLines = 1;

    if(sliderOpts.currentvalue.visible) {
        // Get the dimensions of the current value label:
        var dummyGroup = Drawing.tester.append('g');

        sliderLabels.each(function(stepOpts) {
            var curValPrefix = drawCurrentValue(dummyGroup, sliderOpts, stepOpts.label);
            var curValSize = (curValPrefix.node() && Drawing.bBox(curValPrefix.node())) || {width: 0, height: 0};
            var lines = svgTextUtils.lineCount(curValPrefix);
            dims.currentValueMaxWidth = Math.max(dims.currentValueMaxWidth, Math.ceil(curValSize.width));
            dims.currentValueHeight = Math.max(dims.currentValueHeight, Math.ceil(curValSize.height));
            dims.currentValueMaxLines = Math.max(dims.currentValueMaxLines, lines);
        });

        dims.currentValueTotalHeight = dims.currentValueHeight + sliderOpts.currentvalue.offset;

        dummyGroup.remove();
    }

    dims.height = dims.currentValueTotalHeight + constants.tickOffset + sliderOpts.ticklen + constants.labelOffset + dims.labelHeight + sliderOpts.pad.t + sliderOpts.pad.b;

    var xanchor = 'left';
    if(Lib.isRightAnchor(sliderOpts)) {
        dims.lx -= dims.outerLength;
        xanchor = 'right';
    }
    if(Lib.isCenterAnchor(sliderOpts)) {
        dims.lx -= dims.outerLength / 2;
        xanchor = 'center';
    }

    var yanchor = 'top';
    if(Lib.isBottomAnchor(sliderOpts)) {
        dims.ly -= dims.height;
        yanchor = 'bottom';
    }
    if(Lib.isMiddleAnchor(sliderOpts)) {
        dims.ly -= dims.height / 2;
        yanchor = 'middle';
    }

    dims.outerLength = Math.ceil(dims.outerLength);
    dims.height = Math.ceil(dims.height);
    dims.lx = Math.round(dims.lx);
    dims.ly = Math.round(dims.ly);

    var marginOpts = {
        y: sliderOpts.y,
        b: dims.height * FROM_BR[yanchor],
        t: dims.height * FROM_TL[yanchor]
    };

    if(sliderOpts.lenmode === 'fraction') {
        marginOpts.l = 0;
        marginOpts.xl = sliderOpts.x - sliderOpts.len * FROM_TL[xanchor];
        marginOpts.r = 0;
        marginOpts.xr = sliderOpts.x + sliderOpts.len * FROM_BR[xanchor];
    } else {
        marginOpts.x = sliderOpts.x;
        marginOpts.l = dims.outerLength * FROM_TL[xanchor];
        marginOpts.r = dims.outerLength * FROM_BR[xanchor];
    }

    Plots.autoMargin(gd, autoMarginId(sliderOpts), marginOpts);
}

function drawSlider(gd, sliderGroup, sliderOpts) {
    // This is related to the other long notes in this file regarding what happens
    // when slider steps disappear. This particular fix handles what happens when
    // the *current* slider step is removed. The drawing functions will error out
    // when they fail to find it, so the fix for now is that it will just draw the
    // slider in the first position but will not execute the command.
    if(!((sliderOpts.steps[sliderOpts.active] || {}).visible)) {
        sliderOpts.active = sliderOpts._visibleSteps[0]._index;
    }

    // These are carefully ordered for proper z-ordering:
    sliderGroup
        .call(drawCurrentValue, sliderOpts)
        .call(drawRail, sliderOpts)
        .call(drawLabelGroup, sliderOpts)
        .call(drawTicks, sliderOpts)
        .call(drawTouchRect, gd, sliderOpts)
        .call(drawGrip, gd, sliderOpts);

    var dims = sliderOpts._dims;

    // Position the rectangle:
    Drawing.setTranslate(sliderGroup, dims.lx + sliderOpts.pad.l, dims.ly + sliderOpts.pad.t);

    sliderGroup.call(setGripPosition, sliderOpts, false);
    sliderGroup.call(drawCurrentValue, sliderOpts);
}

function drawCurrentValue(sliderGroup, sliderOpts, valueOverride) {
    if(!sliderOpts.currentvalue.visible) return;

    var dims = sliderOpts._dims;
    var x0, textAnchor;

    switch(sliderOpts.currentvalue.xanchor) {
        case 'right':
            // This is anchored left and adjusted by the width of the longest label
            // so that the prefix doesn't move. The goal of this is to emphasize
            // what's actually changing and make the update less distracting.
            x0 = dims.inputAreaLength - constants.currentValueInset - dims.currentValueMaxWidth;
            textAnchor = 'left';
            break;
        case 'center':
            x0 = dims.inputAreaLength * 0.5;
            textAnchor = 'middle';
            break;
        default:
            x0 = constants.currentValueInset;
            textAnchor = 'left';
    }

    var text = Lib.ensureSingle(sliderGroup, 'text', constants.labelClass, function(s) {
        s.classed('user-select-none', true)
            .attr({
                'text-anchor': textAnchor,
                'data-notex': 1
            });
    });

    var str = sliderOpts.currentvalue.prefix ? sliderOpts.currentvalue.prefix : '';

    if(typeof valueOverride === 'string') {
        str += valueOverride;
    } else {
        var curVal = sliderOpts.steps[sliderOpts.active].label;
        var _meta = sliderOpts._gd._fullLayout._meta;
        if(_meta) curVal = Lib.templateString(curVal, _meta);
        str += curVal;
    }

    if(sliderOpts.currentvalue.suffix) {
        str += sliderOpts.currentvalue.suffix;
    }

    text.call(Drawing.font, sliderOpts.currentvalue.font)
        .text(str)
        .call(svgTextUtils.convertToTspans, sliderOpts._gd);

    var lines = svgTextUtils.lineCount(text);

    var y0 = (dims.currentValueMaxLines + 1 - lines) *
        sliderOpts.currentvalue.font.size * LINE_SPACING;

    svgTextUtils.positionText(text, x0, y0);

    return text;
}

function drawGrip(sliderGroup, gd, sliderOpts) {
    var grip = Lib.ensureSingle(sliderGroup, 'rect', constants.gripRectClass, function(s) {
        s.call(attachGripEvents, gd, sliderGroup, sliderOpts)
            .style('pointer-events', 'all');
    });

    grip.attr({
        width: constants.gripWidth,
        height: constants.gripHeight,
        rx: constants.gripRadius,
        ry: constants.gripRadius,
    })
    .call(Color.stroke, sliderOpts.bordercolor)
    .call(Color.fill, sliderOpts.bgcolor)
    .style('stroke-width', sliderOpts.borderwidth + 'px');
}

function drawLabel(item, data, sliderOpts) {
    var text = Lib.ensureSingle(item, 'text', constants.labelClass, function(s) {
        s.classed('user-select-none', true)
            .attr({
                'text-anchor': 'middle',
                'data-notex': 1
            });
    });

    var tx = data.step.label;
    var _meta = sliderOpts._gd._fullLayout._meta;
    if(_meta) tx = Lib.templateString(tx, _meta);

    text.call(Drawing.font, sliderOpts.font)
        .text(tx)
        .call(svgTextUtils.convertToTspans, sliderOpts._gd);

    return text;
}

function drawLabelGroup(sliderGroup, sliderOpts) {
    var labels = Lib.ensureSingle(sliderGroup, 'g', constants.labelsClass);
    var dims = sliderOpts._dims;

    var labelItems = labels.selectAll('g.' + constants.labelGroupClass)
        .data(dims.labelSteps);

    labelItems.enter().append('g')
        .classed(constants.labelGroupClass, true);

    labelItems.exit().remove();

    labelItems.each(function(d) {
        var item = d3.select(this);

        item.call(drawLabel, d, sliderOpts);

        Drawing.setTranslate(item,
            normalizedValueToPosition(sliderOpts, d.fraction),
            constants.tickOffset +
                sliderOpts.ticklen +
                // position is the baseline of the top line of text only, even
                // if the label spans multiple lines
                sliderOpts.font.size * LINE_SPACING +
                constants.labelOffset +
                dims.currentValueTotalHeight
        );
    });
}

function handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, doTransition) {
    var quantizedPosition = Math.round(normalizedPosition * (sliderOpts._stepCount - 1));
    var quantizedIndex = sliderOpts._visibleSteps[quantizedPosition]._index;

    if(quantizedIndex !== sliderOpts.active) {
        setActive(gd, sliderGroup, sliderOpts, quantizedIndex, true, doTransition);
    }
}

function setActive(gd, sliderGroup, sliderOpts, index, doCallback, doTransition) {
    var previousActive = sliderOpts.active;
    sliderOpts.active = index;

    // due to templating, it's possible this slider doesn't even exist yet
    arrayEditor(gd.layout, constants.name, sliderOpts)
        .applyUpdate('active', index);

    var step = sliderOpts.steps[sliderOpts.active];

    sliderGroup.call(setGripPosition, sliderOpts, doTransition);
    sliderGroup.call(drawCurrentValue, sliderOpts);

    gd.emit('plotly_sliderchange', {
        slider: sliderOpts,
        step: sliderOpts.steps[sliderOpts.active],
        interaction: doCallback,
        previousActive: previousActive
    });

    if(step && step.method && doCallback) {
        if(sliderGroup._nextMethod) {
            // If we've already queued up an update, just overwrite it with the most recent:
            sliderGroup._nextMethod.step = step;
            sliderGroup._nextMethod.doCallback = doCallback;
            sliderGroup._nextMethod.doTransition = doTransition;
        } else {
            sliderGroup._nextMethod = {step: step, doCallback: doCallback, doTransition: doTransition};
            sliderGroup._nextMethodRaf = window.requestAnimationFrame(function() {
                var _step = sliderGroup._nextMethod.step;
                if(!_step.method) return;

                if(_step.execute) {
                    Plots.executeAPICommand(gd, _step.method, _step.args);
                }

                sliderGroup._nextMethod = null;
                sliderGroup._nextMethodRaf = null;
            });
        }
    }
}

function attachGripEvents(item, gd, sliderGroup) {
    var node = sliderGroup.node();
    var $gd = d3.select(gd);

    // NB: This is *not* the same as sliderOpts itself! These callbacks
    // are in a closure so this array won't actually be correct if the
    // steps have changed since this was initialized. The sliderGroup,
    // however, has not changed since that *is* the slider, so it must
    // be present to receive mouse events.
    function getSliderOpts() {
        return sliderGroup.data()[0];
    }

    item.on('mousedown', function() {
        var sliderOpts = getSliderOpts();
        gd.emit('plotly_sliderstart', {slider: sliderOpts});

        var grip = sliderGroup.select('.' + constants.gripRectClass);

        d3.event.stopPropagation();
        d3.event.preventDefault();
        grip.call(Color.fill, sliderOpts.activebgcolor);

        var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);
        handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, true);
        sliderOpts._dragging = true;

        $gd.on('mousemove', function() {
            var sliderOpts = getSliderOpts();
            var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);
            handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, false);
        });

        $gd.on('mouseup', function() {
            var sliderOpts = getSliderOpts();
            sliderOpts._dragging = false;
            grip.call(Color.fill, sliderOpts.bgcolor);
            $gd.on('mouseup', null);
            $gd.on('mousemove', null);

            gd.emit('plotly_sliderend', {
                slider: sliderOpts,
                step: sliderOpts.steps[sliderOpts.active]
            });
        });
    });
}

function drawTicks(sliderGroup, sliderOpts) {
    var tick = sliderGroup.selectAll('rect.' + constants.tickRectClass)
        .data(sliderOpts._visibleSteps);
    var dims = sliderOpts._dims;

    tick.enter().append('rect')
        .classed(constants.tickRectClass, true);

    tick.exit().remove();

    tick.attr({
        width: sliderOpts.tickwidth + 'px',
        'shape-rendering': 'crispEdges'
    });

    tick.each(function(d, i) {
        var isMajor = i % dims.labelStride === 0;
        var item = d3.select(this);

        item
            .attr({height: isMajor ? sliderOpts.ticklen : sliderOpts.minorticklen})
            .call(Color.fill, isMajor ? sliderOpts.tickcolor : sliderOpts.tickcolor);

        Drawing.setTranslate(item,
            normalizedValueToPosition(sliderOpts, i / (sliderOpts._stepCount - 1)) - 0.5 * sliderOpts.tickwidth,
            (isMajor ? constants.tickOffset : constants.minorTickOffset) + dims.currentValueTotalHeight
        );
    });
}

function computeLabelSteps(sliderOpts) {
    var dims = sliderOpts._dims;
    dims.labelSteps = [];
    var nsteps = sliderOpts._stepCount;

    for(var i = 0; i < nsteps; i += dims.labelStride) {
        dims.labelSteps.push({
            fraction: i / (nsteps - 1),
            step: sliderOpts._visibleSteps[i]
        });
    }
}

function setGripPosition(sliderGroup, sliderOpts, doTransition) {
    var grip = sliderGroup.select('rect.' + constants.gripRectClass);

    var quantizedIndex = 0;
    for(var i = 0; i < sliderOpts._stepCount; i++) {
        if(sliderOpts._visibleSteps[i]._index === sliderOpts.active) {
            quantizedIndex = i;
            break;
        }
    }

    var x = normalizedValueToPosition(sliderOpts, quantizedIndex / (sliderOpts._stepCount - 1));

    // If this is true, then *this component* is already invoking its own command
    // and has triggered its own animation.
    if(sliderOpts._invokingCommand) return;

    var el = grip;
    if(doTransition && sliderOpts.transition.duration > 0) {
        el = el.transition()
            .duration(sliderOpts.transition.duration)
            .ease(sliderOpts.transition.easing);
    }

    // Drawing.setTranslate doesn't work here becasue of the transition duck-typing.
    // It's also not necessary because there are no other transitions to preserve.
    el.attr('transform', 'translate(' + (x - constants.gripWidth * 0.5) + ',' + (sliderOpts._dims.currentValueTotalHeight) + ')');
}

// Convert a number from [0-1] to a pixel position relative to the slider group container:
function normalizedValueToPosition(sliderOpts, normalizedPosition) {
    var dims = sliderOpts._dims;
    return dims.inputAreaStart + constants.stepInset +
        (dims.inputAreaLength - 2 * constants.stepInset) * Math.min(1, Math.max(0, normalizedPosition));
}

// Convert a position relative to the slider group to a nubmer in [0, 1]
function positionToNormalizedValue(sliderOpts, position) {
    var dims = sliderOpts._dims;
    return Math.min(1, Math.max(0, (position - constants.stepInset - dims.inputAreaStart) / (dims.inputAreaLength - 2 * constants.stepInset - 2 * dims.inputAreaStart)));
}

function drawTouchRect(sliderGroup, gd, sliderOpts) {
    var dims = sliderOpts._dims;
    var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railTouchRectClass, function(s) {
        s.call(attachGripEvents, gd, sliderGroup, sliderOpts)
            .style('pointer-events', 'all');
    });

    rect.attr({
        width: dims.inputAreaLength,
        height: Math.max(dims.inputAreaWidth, constants.tickOffset + sliderOpts.ticklen + dims.labelHeight)
    })
        .call(Color.fill, sliderOpts.bgcolor)
        .attr('opacity', 0);

    Drawing.setTranslate(rect, 0, dims.currentValueTotalHeight);
}

function drawRail(sliderGroup, sliderOpts) {
    var dims = sliderOpts._dims;
    var computedLength = dims.inputAreaLength - constants.railInset * 2;
    var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railRectClass);

    rect.attr({
        width: computedLength,
        height: constants.railWidth,
        rx: constants.railRadius,
        ry: constants.railRadius,
        'shape-rendering': 'crispEdges'
    })
    .call(Color.stroke, sliderOpts.bordercolor)
    .call(Color.fill, sliderOpts.bgcolor)
    .style('stroke-width', sliderOpts.borderwidth + 'px');

    Drawing.setTranslate(rect,
        constants.railInset,
        (dims.inputAreaWidth - constants.railWidth) * 0.5 + dims.currentValueTotalHeight
    );
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/sliders/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/sliders/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var constants = __webpack_require__(/*! ./constants */ "./node_modules/plotly.js/src/components/sliders/constants.js");

module.exports = {
    moduleType: 'component',
    name: constants.name,

    layoutAttributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/sliders/attributes.js"),
    supplyLayoutDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/components/sliders/defaults.js"),

    draw: __webpack_require__(/*! ./draw */ "./node_modules/plotly.js/src/components/sliders/draw.js")
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/updatemenus/attributes.js":
/*!*************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/updatemenus/attributes.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var fontAttrs = __webpack_require__(/*! ../../plots/font_attributes */ "./node_modules/plotly.js/src/plots/font_attributes.js");
var colorAttrs = __webpack_require__(/*! ../color/attributes */ "./node_modules/plotly.js/src/components/color/attributes.js");
var extendFlat = __webpack_require__(/*! ../../lib/extend */ "./node_modules/plotly.js/src/lib/extend.js").extendFlat;
var overrideAll = __webpack_require__(/*! ../../plot_api/edit_types */ "./node_modules/plotly.js/src/plot_api/edit_types.js").overrideAll;
var padAttrs = __webpack_require__(/*! ../../plots/pad_attributes */ "./node_modules/plotly.js/src/plots/pad_attributes.js");
var templatedArray = __webpack_require__(/*! ../../plot_api/plot_template */ "./node_modules/plotly.js/src/plot_api/plot_template.js").templatedArray;

var buttonsAttrs = templatedArray('button', {
    visible: {
        valType: 'boolean',
        role: 'info',
        description: 'Determines whether or not this button is visible.'
    },
    method: {
        valType: 'enumerated',
        values: ['restyle', 'relayout', 'animate', 'update', 'skip'],
        dflt: 'restyle',
        role: 'info',
        description: [
            'Sets the Plotly method to be called on click.',
            'If the `skip` method is used, the API updatemenu will function as normal',
            'but will perform no API calls and will not bind automatically to state',
            'updates. This may be used to create a component interface and attach to',
            'updatemenu events manually via JavaScript.'
        ].join(' ')
    },
    args: {
        valType: 'info_array',
        role: 'info',
        freeLength: true,
        items: [
            {valType: 'any'},
            {valType: 'any'},
            {valType: 'any'}
        ],
        description: [
            'Sets the arguments values to be passed to the Plotly',
            'method set in `method` on click.'
        ].join(' ')
    },
    args2: {
        valType: 'info_array',
        role: 'info',
        freeLength: true,
        items: [
            {valType: 'any'},
            {valType: 'any'},
            {valType: 'any'}
        ],
        description: [
            'Sets a 2nd set of `args`,',
            'these arguments values are passed to the Plotly',
            'method set in `method` when clicking this button while in the active state.',
            'Use this to create toggle buttons.'
        ].join(' ')
    },
    label: {
        valType: 'string',
        role: 'info',
        dflt: '',
        description: 'Sets the text label to appear on the button.'
    },
    execute: {
        valType: 'boolean',
        role: 'info',
        dflt: true,
        description: [
            'When true, the API method is executed. When false, all other behaviors are the same',
            'and command execution is skipped. This may be useful when hooking into, for example,',
            'the `plotly_buttonclicked` method and executing the API command manually without losing',
            'the benefit of the updatemenu automatically binding to the state of the plot through the',
            'specification of `method` and `args`.'
        ].join(' ')
    }
});

module.exports = overrideAll(templatedArray('updatemenu', {
    _arrayAttrRegexps: [/^updatemenus\[(0|[1-9][0-9]+)\]\.buttons/],

    visible: {
        valType: 'boolean',
        role: 'info',
        description: [
            'Determines whether or not the update menu is visible.'
        ].join(' ')
    },

    type: {
        valType: 'enumerated',
        values: ['dropdown', 'buttons'],
        dflt: 'dropdown',
        role: 'info',
        description: [
            'Determines whether the buttons are accessible via a dropdown menu',
            'or whether the buttons are stacked horizontally or vertically'
        ].join(' ')
    },

    direction: {
        valType: 'enumerated',
        values: ['left', 'right', 'up', 'down'],
        dflt: 'down',
        role: 'info',
        description: [
            'Determines the direction in which the buttons are laid out, whether',
            'in a dropdown menu or a row/column of buttons. For `left` and `up`,',
            'the buttons will still appear in left-to-right or top-to-bottom order',
            'respectively.'
        ].join(' ')
    },

    active: {
        valType: 'integer',
        role: 'info',
        min: -1,
        dflt: 0,
        description: [
            'Determines which button (by index starting from 0) is',
            'considered active.'
        ].join(' ')
    },

    showactive: {
        valType: 'boolean',
        role: 'info',
        dflt: true,
        description: 'Highlights active dropdown item or active button if true.'
    },

    buttons: buttonsAttrs,

    x: {
        valType: 'number',
        min: -2,
        max: 3,
        dflt: -0.05,
        role: 'style',
        description: 'Sets the x position (in normalized coordinates) of the update menu.'
    },
    xanchor: {
        valType: 'enumerated',
        values: ['auto', 'left', 'center', 'right'],
        dflt: 'right',
        role: 'info',
        description: [
            'Sets the update menu\'s horizontal position anchor.',
            'This anchor binds the `x` position to the *left*, *center*',
            'or *right* of the range selector.'
        ].join(' ')
    },
    y: {
        valType: 'number',
        min: -2,
        max: 3,
        dflt: 1,
        role: 'style',
        description: 'Sets the y position (in normalized coordinates) of the update menu.'
    },
    yanchor: {
        valType: 'enumerated',
        values: ['auto', 'top', 'middle', 'bottom'],
        dflt: 'top',
        role: 'info',
        description: [
            'Sets the update menu\'s vertical position anchor',
            'This anchor binds the `y` position to the *top*, *middle*',
            'or *bottom* of the range selector.'
        ].join(' ')
    },

    pad: extendFlat(padAttrs({editType: 'arraydraw'}), {
        description: 'Sets the padding around the buttons or dropdown menu.'
    }),

    font: fontAttrs({
        description: 'Sets the font of the update menu button text.'
    }),

    bgcolor: {
        valType: 'color',
        role: 'style',
        description: 'Sets the background color of the update menu buttons.'
    },
    bordercolor: {
        valType: 'color',
        dflt: colorAttrs.borderLine,
        role: 'style',
        description: 'Sets the color of the border enclosing the update menu.'
    },
    borderwidth: {
        valType: 'number',
        min: 0,
        dflt: 1,
        role: 'style',
        editType: 'arraydraw',
        description: 'Sets the width (in px) of the border enclosing the update menu.'
    }
}), 'arraydraw', 'from-root');


/***/ }),

/***/ "./node_modules/plotly.js/src/components/updatemenus/constants.js":
/*!************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/updatemenus/constants.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/





module.exports = {

    // layout attribute name
    name: 'updatemenus',

    // class names
    containerClassName: 'updatemenu-container',
    headerGroupClassName: 'updatemenu-header-group',
    headerClassName: 'updatemenu-header',
    headerArrowClassName: 'updatemenu-header-arrow',
    dropdownButtonGroupClassName: 'updatemenu-dropdown-button-group',
    dropdownButtonClassName: 'updatemenu-dropdown-button',
    buttonClassName: 'updatemenu-button',
    itemRectClassName: 'updatemenu-item-rect',
    itemTextClassName: 'updatemenu-item-text',

    // DOM attribute name in button group keeping track
    // of active update menu
    menuIndexAttrName: 'updatemenu-active-index',

    // id root pass to Plots.autoMargin
    autoMarginIdRoot: 'updatemenu-',

    // options when 'active: -1'
    blankHeaderOpts: { label: '  ' },

    // min item width / height
    minWidth: 30,
    minHeight: 30,

    // padding around item text
    textPadX: 24,
    arrowPadX: 16,

    // item rect radii
    rx: 2,
    ry: 2,

    // item  text x offset off left edge
    textOffsetX: 12,

    // item  text y offset (w.r.t. middle)
    textOffsetY: 3,

    // arrow offset off right edge
    arrowOffsetX: 4,

    // gap between header and buttons
    gapButtonHeader: 5,

    // gap between between buttons
    gapButton: 2,

    // color given to active buttons
    activeColor: '#F4FAFF',

    // color given to hovered buttons
    hoverColor: '#F4FAFF',

    // symbol for menu open arrow
    arrowSymbol: {
        left: '◄',
        right: '►',
        up: '▲',
        down: '▼'
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/updatemenus/defaults.js":
/*!***********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/updatemenus/defaults.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var handleArrayContainerDefaults = __webpack_require__(/*! ../../plots/array_container_defaults */ "./node_modules/plotly.js/src/plots/array_container_defaults.js");

var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/updatemenus/attributes.js");
var constants = __webpack_require__(/*! ./constants */ "./node_modules/plotly.js/src/components/updatemenus/constants.js");

var name = constants.name;
var buttonAttrs = attributes.buttons;


module.exports = function updateMenusDefaults(layoutIn, layoutOut) {
    var opts = {
        name: name,
        handleItemDefaults: menuDefaults
    };

    handleArrayContainerDefaults(layoutIn, layoutOut, opts);
};

function menuDefaults(menuIn, menuOut, layoutOut) {
    function coerce(attr, dflt) {
        return Lib.coerce(menuIn, menuOut, attributes, attr, dflt);
    }

    var buttons = handleArrayContainerDefaults(menuIn, menuOut, {
        name: 'buttons',
        handleItemDefaults: buttonDefaults
    });

    var visible = coerce('visible', buttons.length > 0);
    if(!visible) return;

    coerce('active');
    coerce('direction');
    coerce('type');
    coerce('showactive');

    coerce('x');
    coerce('y');
    Lib.noneOrAll(menuIn, menuOut, ['x', 'y']);

    coerce('xanchor');
    coerce('yanchor');

    coerce('pad.t');
    coerce('pad.r');
    coerce('pad.b');
    coerce('pad.l');

    Lib.coerceFont(coerce, 'font', layoutOut.font);

    coerce('bgcolor', layoutOut.paper_bgcolor);
    coerce('bordercolor');
    coerce('borderwidth');
}

function buttonDefaults(buttonIn, buttonOut) {
    function coerce(attr, dflt) {
        return Lib.coerce(buttonIn, buttonOut, buttonAttrs, attr, dflt);
    }

    var visible = coerce('visible',
        (buttonIn.method === 'skip' || Array.isArray(buttonIn.args)));
    if(visible) {
        coerce('method');
        coerce('args');
        coerce('args2');
        coerce('label');
        coerce('execute');
    }
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/updatemenus/draw.js":
/*!*******************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/updatemenus/draw.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");

var Plots = __webpack_require__(/*! ../../plots/plots */ "./node_modules/plotly.js/src/plots/plots.js");
var Color = __webpack_require__(/*! ../color */ "./node_modules/plotly.js/src/components/color/index.js");
var Drawing = __webpack_require__(/*! ../drawing */ "./node_modules/plotly.js/src/components/drawing/index.js");
var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var svgTextUtils = __webpack_require__(/*! ../../lib/svg_text_utils */ "./node_modules/plotly.js/src/lib/svg_text_utils.js");
var arrayEditor = __webpack_require__(/*! ../../plot_api/plot_template */ "./node_modules/plotly.js/src/plot_api/plot_template.js").arrayEditor;

var LINE_SPACING = __webpack_require__(/*! ../../constants/alignment */ "./node_modules/plotly.js/src/constants/alignment.js").LINE_SPACING;

var constants = __webpack_require__(/*! ./constants */ "./node_modules/plotly.js/src/components/updatemenus/constants.js");
var ScrollBox = __webpack_require__(/*! ./scrollbox */ "./node_modules/plotly.js/src/components/updatemenus/scrollbox.js");

module.exports = function draw(gd) {
    var fullLayout = gd._fullLayout;
    var menuData = Lib.filterVisible(fullLayout[constants.name]);

    /* Update menu data is bound to the header-group.
     * The items in the header group are always present.
     *
     * Upon clicking on a header its corresponding button
     * data is bound to the button-group.
     *
     * We draw all headers in one group before all buttons
     * so that the buttons *always* appear above the headers.
     *
     * Note that only one set of buttons are visible at once.
     *
     * <g container />
     *
     *     <g header-group />
     *         <g item header />
     *         <text item header-arrow />
     *     <g header-group />
     *         <g item header />
     *         <text item header-arrow />
     *     ...
     *
     *     <g button-group />
     *         <g item button />
     *         <g item button />
     *         ...
     */

    function clearAutoMargin(menuOpts) {
        Plots.autoMargin(gd, autoMarginId(menuOpts));
    }

    // draw update menu container
    var menus = fullLayout._menulayer
        .selectAll('g.' + constants.containerClassName)
        .data(menuData.length > 0 ? [0] : []);

    menus.enter().append('g')
        .classed(constants.containerClassName, true)
        .style('cursor', 'pointer');

    menus.exit().each(function() {
        // Most components don't need to explicitly remove autoMargin, because
        // marginPushers does this - but updatemenu updates don't go through
        // a full replot so we need to explicitly remove it.
        // This is for removing *all* updatemenus, removing individuals is
        // handled below, in headerGroups.exit
        d3.select(this).selectAll('g.' + constants.headerGroupClassName)
            .each(clearAutoMargin);
    }).remove();

    // return early if no update menus are visible
    if(menuData.length === 0) return;

    // join header group
    var headerGroups = menus.selectAll('g.' + constants.headerGroupClassName)
        .data(menuData, keyFunction);

    headerGroups.enter().append('g')
        .classed(constants.headerGroupClassName, true);

    // draw dropdown button container
    var gButton = Lib.ensureSingle(menus, 'g', constants.dropdownButtonGroupClassName, function(s) {
        s.style('pointer-events', 'all');
    });

    // find dimensions before plotting anything (this mutates menuOpts)
    for(var i = 0; i < menuData.length; i++) {
        var menuOpts = menuData[i];
        findDimensions(gd, menuOpts);
    }

    // setup scrollbox
    var scrollBoxId = 'updatemenus' + fullLayout._uid;
    var scrollBox = new ScrollBox(gd, gButton, scrollBoxId);

    // remove exiting header, remove dropped buttons and reset margins
    if(headerGroups.enter().size()) {
        // make sure gButton is on top of all headers
        gButton.node().parentNode.appendChild(gButton.node());
        gButton.call(removeAllButtons);
    }

    headerGroups.exit().each(function(menuOpts) {
        gButton.call(removeAllButtons);
        clearAutoMargin(menuOpts);
    }).remove();

    // draw headers!
    headerGroups.each(function(menuOpts) {
        var gHeader = d3.select(this);

        var _gButton = menuOpts.type === 'dropdown' ? gButton : null;

        Plots.manageCommandObserver(gd, menuOpts, menuOpts.buttons, function(data) {
            setActive(gd, menuOpts, menuOpts.buttons[data.index], gHeader, _gButton, scrollBox, data.index, true);
        });

        if(menuOpts.type === 'dropdown') {
            drawHeader(gd, gHeader, gButton, scrollBox, menuOpts);

            // if this menu is active, update the dropdown container
            if(isActive(gButton, menuOpts)) {
                drawButtons(gd, gHeader, gButton, scrollBox, menuOpts);
            }
        } else {
            drawButtons(gd, gHeader, null, null, menuOpts);
        }
    });
};

// Note that '_index' is set at the default step,
// it corresponds to the menu index in the user layout update menu container.
// Because a menu can be set invisible,
// this is a more 'consistent' field than the index in the menuData.
function keyFunction(menuOpts) {
    return menuOpts._index;
}

function isFolded(gButton) {
    return +gButton.attr(constants.menuIndexAttrName) === -1;
}

function isActive(gButton, menuOpts) {
    return +gButton.attr(constants.menuIndexAttrName) === menuOpts._index;
}

function setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, buttonIndex, isSilentUpdate) {
    // update 'active' attribute in menuOpts
    menuOpts.active = buttonIndex;

    // due to templating, it's possible this slider doesn't even exist yet
    arrayEditor(gd.layout, constants.name, menuOpts)
        .applyUpdate('active', buttonIndex);

    if(menuOpts.type === 'buttons') {
        drawButtons(gd, gHeader, null, null, menuOpts);
    } else if(menuOpts.type === 'dropdown') {
        // fold up buttons and redraw header
        gButton.attr(constants.menuIndexAttrName, '-1');

        drawHeader(gd, gHeader, gButton, scrollBox, menuOpts);

        if(!isSilentUpdate) {
            drawButtons(gd, gHeader, gButton, scrollBox, menuOpts);
        }
    }
}

function drawHeader(gd, gHeader, gButton, scrollBox, menuOpts) {
    var header = Lib.ensureSingle(gHeader, 'g', constants.headerClassName, function(s) {
        s.style('pointer-events', 'all');
    });

    var dims = menuOpts._dims;
    var active = menuOpts.active;
    var headerOpts = menuOpts.buttons[active] || constants.blankHeaderOpts;
    var posOpts = { y: menuOpts.pad.t, yPad: 0, x: menuOpts.pad.l, xPad: 0, index: 0 };
    var positionOverrides = {
        width: dims.headerWidth,
        height: dims.headerHeight
    };

    header
        .call(drawItem, menuOpts, headerOpts, gd)
        .call(setItemPosition, menuOpts, posOpts, positionOverrides);

    // draw drop arrow at the right edge
    var arrow = Lib.ensureSingle(gHeader, 'text', constants.headerArrowClassName, function(s) {
        s.classed('user-select-none', true)
            .attr('text-anchor', 'end')
            .call(Drawing.font, menuOpts.font)
            .text(constants.arrowSymbol[menuOpts.direction]);
    });

    arrow.attr({
        x: dims.headerWidth - constants.arrowOffsetX + menuOpts.pad.l,
        y: dims.headerHeight / 2 + constants.textOffsetY + menuOpts.pad.t
    });

    header.on('click', function() {
        gButton.call(removeAllButtons,
            String(isActive(gButton, menuOpts) ? -1 : menuOpts._index)
        );

        drawButtons(gd, gHeader, gButton, scrollBox, menuOpts);
    });

    header.on('mouseover', function() {
        header.call(styleOnMouseOver);
    });

    header.on('mouseout', function() {
        header.call(styleOnMouseOut, menuOpts);
    });

    // translate header group
    Drawing.setTranslate(gHeader, dims.lx, dims.ly);
}

function drawButtons(gd, gHeader, gButton, scrollBox, menuOpts) {
    // If this is a set of buttons, set pointer events = all since we play
    // some minor games with which container is which in order to simplify
    // the drawing of *either* buttons or menus
    if(!gButton) {
        gButton = gHeader;
        gButton.attr('pointer-events', 'all');
    }

    var buttonData = (!isFolded(gButton) || menuOpts.type === 'buttons') ?
        menuOpts.buttons :
        [];

    var klass = menuOpts.type === 'dropdown' ? constants.dropdownButtonClassName : constants.buttonClassName;

    var buttons = gButton.selectAll('g.' + klass)
        .data(Lib.filterVisible(buttonData));

    var enter = buttons.enter().append('g')
        .classed(klass, true);

    var exit = buttons.exit();

    if(menuOpts.type === 'dropdown') {
        enter.attr('opacity', '0')
            .transition()
            .attr('opacity', '1');

        exit.transition()
            .attr('opacity', '0')
            .remove();
    } else {
        exit.remove();
    }

    var x0 = 0;
    var y0 = 0;
    var dims = menuOpts._dims;

    var isVertical = ['up', 'down'].indexOf(menuOpts.direction) !== -1;

    if(menuOpts.type === 'dropdown') {
        if(isVertical) {
            y0 = dims.headerHeight + constants.gapButtonHeader;
        } else {
            x0 = dims.headerWidth + constants.gapButtonHeader;
        }
    }

    if(menuOpts.type === 'dropdown' && menuOpts.direction === 'up') {
        y0 = -constants.gapButtonHeader + constants.gapButton - dims.openHeight;
    }

    if(menuOpts.type === 'dropdown' && menuOpts.direction === 'left') {
        x0 = -constants.gapButtonHeader + constants.gapButton - dims.openWidth;
    }

    var posOpts = {
        x: dims.lx + x0 + menuOpts.pad.l,
        y: dims.ly + y0 + menuOpts.pad.t,
        yPad: constants.gapButton,
        xPad: constants.gapButton,
        index: 0,
    };

    var scrollBoxPosition = {
        l: posOpts.x + menuOpts.borderwidth,
        t: posOpts.y + menuOpts.borderwidth
    };

    buttons.each(function(buttonOpts, buttonIndex) {
        var button = d3.select(this);

        button
            .call(drawItem, menuOpts, buttonOpts, gd)
            .call(setItemPosition, menuOpts, posOpts);

        button.on('click', function() {
            // skip `dragend` events
            if(d3.event.defaultPrevented) return;

            if(buttonOpts.execute) {
                if(buttonOpts.args2 && menuOpts.active === buttonIndex) {
                    setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, -1);
                    Plots.executeAPICommand(gd, buttonOpts.method, buttonOpts.args2);
                } else {
                    setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, buttonIndex);
                    Plots.executeAPICommand(gd, buttonOpts.method, buttonOpts.args);
                }
            }

            gd.emit('plotly_buttonclicked', {menu: menuOpts, button: buttonOpts, active: menuOpts.active});
        });

        button.on('mouseover', function() {
            button.call(styleOnMouseOver);
        });

        button.on('mouseout', function() {
            button.call(styleOnMouseOut, menuOpts);
            buttons.call(styleButtons, menuOpts);
        });
    });

    buttons.call(styleButtons, menuOpts);

    if(isVertical) {
        scrollBoxPosition.w = Math.max(dims.openWidth, dims.headerWidth);
        scrollBoxPosition.h = posOpts.y - scrollBoxPosition.t;
    } else {
        scrollBoxPosition.w = posOpts.x - scrollBoxPosition.l;
        scrollBoxPosition.h = Math.max(dims.openHeight, dims.headerHeight);
    }

    scrollBoxPosition.direction = menuOpts.direction;

    if(scrollBox) {
        if(buttons.size()) {
            drawScrollBox(gd, gHeader, gButton, scrollBox, menuOpts, scrollBoxPosition);
        } else {
            hideScrollBox(scrollBox);
        }
    }
}

function drawScrollBox(gd, gHeader, gButton, scrollBox, menuOpts, position) {
    // enable the scrollbox
    var direction = menuOpts.direction;
    var isVertical = (direction === 'up' || direction === 'down');
    var dims = menuOpts._dims;

    var active = menuOpts.active;
    var translateX, translateY;
    var i;
    if(isVertical) {
        translateY = 0;
        for(i = 0; i < active; i++) {
            translateY += dims.heights[i] + constants.gapButton;
        }
    } else {
        translateX = 0;
        for(i = 0; i < active; i++) {
            translateX += dims.widths[i] + constants.gapButton;
        }
    }

    scrollBox.enable(position, translateX, translateY);

    if(scrollBox.hbar) {
        scrollBox.hbar
            .attr('opacity', '0')
            .transition()
            .attr('opacity', '1');
    }

    if(scrollBox.vbar) {
        scrollBox.vbar
            .attr('opacity', '0')
            .transition()
            .attr('opacity', '1');
    }
}

function hideScrollBox(scrollBox) {
    var hasHBar = !!scrollBox.hbar;
    var hasVBar = !!scrollBox.vbar;

    if(hasHBar) {
        scrollBox.hbar
            .transition()
            .attr('opacity', '0')
            .each('end', function() {
                hasHBar = false;
                if(!hasVBar) scrollBox.disable();
            });
    }

    if(hasVBar) {
        scrollBox.vbar
            .transition()
            .attr('opacity', '0')
            .each('end', function() {
                hasVBar = false;
                if(!hasHBar) scrollBox.disable();
            });
    }
}

function drawItem(item, menuOpts, itemOpts, gd) {
    item.call(drawItemRect, menuOpts)
        .call(drawItemText, menuOpts, itemOpts, gd);
}

function drawItemRect(item, menuOpts) {
    var rect = Lib.ensureSingle(item, 'rect', constants.itemRectClassName, function(s) {
        s.attr({
            rx: constants.rx,
            ry: constants.ry,
            'shape-rendering': 'crispEdges'
        });
    });

    rect.call(Color.stroke, menuOpts.bordercolor)
        .call(Color.fill, menuOpts.bgcolor)
        .style('stroke-width', menuOpts.borderwidth + 'px');
}

function drawItemText(item, menuOpts, itemOpts, gd) {
    var text = Lib.ensureSingle(item, 'text', constants.itemTextClassName, function(s) {
        s.classed('user-select-none', true)
            .attr({
                'text-anchor': 'start',
                'data-notex': 1
            });
    });

    var tx = itemOpts.label;
    var _meta = gd._fullLayout._meta;
    if(_meta) tx = Lib.templateString(tx, _meta);

    text.call(Drawing.font, menuOpts.font)
        .text(tx)
        .call(svgTextUtils.convertToTspans, gd);
}

function styleButtons(buttons, menuOpts) {
    var active = menuOpts.active;

    buttons.each(function(buttonOpts, i) {
        var button = d3.select(this);

        if(i === active && menuOpts.showactive) {
            button.select('rect.' + constants.itemRectClassName)
                .call(Color.fill, constants.activeColor);
        }
    });
}

function styleOnMouseOver(item) {
    item.select('rect.' + constants.itemRectClassName)
        .call(Color.fill, constants.hoverColor);
}

function styleOnMouseOut(item, menuOpts) {
    item.select('rect.' + constants.itemRectClassName)
        .call(Color.fill, menuOpts.bgcolor);
}

// find item dimensions (this mutates menuOpts)
function findDimensions(gd, menuOpts) {
    var dims = menuOpts._dims = {
        width1: 0,
        height1: 0,
        heights: [],
        widths: [],
        totalWidth: 0,
        totalHeight: 0,
        openWidth: 0,
        openHeight: 0,
        lx: 0,
        ly: 0
    };

    var fakeButtons = Drawing.tester.selectAll('g.' + constants.dropdownButtonClassName)
        .data(Lib.filterVisible(menuOpts.buttons));

    fakeButtons.enter().append('g')
        .classed(constants.dropdownButtonClassName, true);

    var isVertical = ['up', 'down'].indexOf(menuOpts.direction) !== -1;

    // loop over fake buttons to find width / height
    fakeButtons.each(function(buttonOpts, i) {
        var button = d3.select(this);

        button.call(drawItem, menuOpts, buttonOpts, gd);

        var text = button.select('.' + constants.itemTextClassName);

        // width is given by max width of all buttons
        var tWidth = text.node() && Drawing.bBox(text.node()).width;
        var wEff = Math.max(tWidth + constants.textPadX, constants.minWidth);

        // height is determined by item text
        var tHeight = menuOpts.font.size * LINE_SPACING;
        var tLines = svgTextUtils.lineCount(text);
        var hEff = Math.max(tHeight * tLines, constants.minHeight) + constants.textOffsetY;

        hEff = Math.ceil(hEff);
        wEff = Math.ceil(wEff);

        // Store per-item sizes since a row of horizontal buttons, for example,
        // don't all need to be the same width:
        dims.widths[i] = wEff;
        dims.heights[i] = hEff;

        // Height and width of individual element:
        dims.height1 = Math.max(dims.height1, hEff);
        dims.width1 = Math.max(dims.width1, wEff);

        if(isVertical) {
            dims.totalWidth = Math.max(dims.totalWidth, wEff);
            dims.openWidth = dims.totalWidth;
            dims.totalHeight += hEff + constants.gapButton;
            dims.openHeight += hEff + constants.gapButton;
        } else {
            dims.totalWidth += wEff + constants.gapButton;
            dims.openWidth += wEff + constants.gapButton;
            dims.totalHeight = Math.max(dims.totalHeight, hEff);
            dims.openHeight = dims.totalHeight;
        }
    });

    if(isVertical) {
        dims.totalHeight -= constants.gapButton;
    } else {
        dims.totalWidth -= constants.gapButton;
    }


    dims.headerWidth = dims.width1 + constants.arrowPadX;
    dims.headerHeight = dims.height1;

    if(menuOpts.type === 'dropdown') {
        if(isVertical) {
            dims.width1 += constants.arrowPadX;
            dims.totalHeight = dims.height1;
        } else {
            dims.totalWidth = dims.width1;
        }
        dims.totalWidth += constants.arrowPadX;
    }

    fakeButtons.remove();

    var paddedWidth = dims.totalWidth + menuOpts.pad.l + menuOpts.pad.r;
    var paddedHeight = dims.totalHeight + menuOpts.pad.t + menuOpts.pad.b;

    var graphSize = gd._fullLayout._size;
    dims.lx = graphSize.l + graphSize.w * menuOpts.x;
    dims.ly = graphSize.t + graphSize.h * (1 - menuOpts.y);

    var xanchor = 'left';
    if(Lib.isRightAnchor(menuOpts)) {
        dims.lx -= paddedWidth;
        xanchor = 'right';
    }
    if(Lib.isCenterAnchor(menuOpts)) {
        dims.lx -= paddedWidth / 2;
        xanchor = 'center';
    }

    var yanchor = 'top';
    if(Lib.isBottomAnchor(menuOpts)) {
        dims.ly -= paddedHeight;
        yanchor = 'bottom';
    }
    if(Lib.isMiddleAnchor(menuOpts)) {
        dims.ly -= paddedHeight / 2;
        yanchor = 'middle';
    }

    dims.totalWidth = Math.ceil(dims.totalWidth);
    dims.totalHeight = Math.ceil(dims.totalHeight);
    dims.lx = Math.round(dims.lx);
    dims.ly = Math.round(dims.ly);

    Plots.autoMargin(gd, autoMarginId(menuOpts), {
        x: menuOpts.x,
        y: menuOpts.y,
        l: paddedWidth * ({right: 1, center: 0.5}[xanchor] || 0),
        r: paddedWidth * ({left: 1, center: 0.5}[xanchor] || 0),
        b: paddedHeight * ({top: 1, middle: 0.5}[yanchor] || 0),
        t: paddedHeight * ({bottom: 1, middle: 0.5}[yanchor] || 0)
    });
}

function autoMarginId(menuOpts) {
    return constants.autoMarginIdRoot + menuOpts._index;
}

// set item positions (mutates posOpts)
function setItemPosition(item, menuOpts, posOpts, overrideOpts) {
    overrideOpts = overrideOpts || {};
    var rect = item.select('.' + constants.itemRectClassName);
    var text = item.select('.' + constants.itemTextClassName);
    var borderWidth = menuOpts.borderwidth;
    var index = posOpts.index;
    var dims = menuOpts._dims;

    Drawing.setTranslate(item, borderWidth + posOpts.x, borderWidth + posOpts.y);

    var isVertical = ['up', 'down'].indexOf(menuOpts.direction) !== -1;
    var finalHeight = overrideOpts.height || (isVertical ? dims.heights[index] : dims.height1);

    rect.attr({
        x: 0,
        y: 0,
        width: overrideOpts.width || (isVertical ? dims.width1 : dims.widths[index]),
        height: finalHeight
    });

    var tHeight = menuOpts.font.size * LINE_SPACING;
    var tLines = svgTextUtils.lineCount(text);
    var spanOffset = ((tLines - 1) * tHeight / 2);

    svgTextUtils.positionText(text, constants.textOffsetX,
        finalHeight / 2 - spanOffset + constants.textOffsetY);

    if(isVertical) {
        posOpts.y += dims.heights[index] + posOpts.yPad;
    } else {
        posOpts.x += dims.widths[index] + posOpts.xPad;
    }

    posOpts.index++;
}

function removeAllButtons(gButton, newMenuIndexAttr) {
    gButton
        .attr(constants.menuIndexAttrName, newMenuIndexAttr || '-1')
        .selectAll('g.' + constants.dropdownButtonClassName).remove();
}


/***/ }),

/***/ "./node_modules/plotly.js/src/components/updatemenus/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/updatemenus/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var constants = __webpack_require__(/*! ./constants */ "./node_modules/plotly.js/src/components/updatemenus/constants.js");

module.exports = {
    moduleType: 'component',
    name: constants.name,

    layoutAttributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/components/updatemenus/attributes.js"),
    supplyLayoutDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/components/updatemenus/defaults.js"),

    draw: __webpack_require__(/*! ./draw */ "./node_modules/plotly.js/src/components/updatemenus/draw.js")
};


/***/ }),

/***/ "./node_modules/plotly.js/src/components/updatemenus/scrollbox.js":
/*!************************************************************************!*\
  !*** ./node_modules/plotly.js/src/components/updatemenus/scrollbox.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = ScrollBox;

var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");

var Color = __webpack_require__(/*! ../color */ "./node_modules/plotly.js/src/components/color/index.js");
var Drawing = __webpack_require__(/*! ../drawing */ "./node_modules/plotly.js/src/components/drawing/index.js");

var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");

/**
 * Helper class to setup a scroll box
 *
 * @class
 * @param           gd          Plotly's graph div
 * @param           container   Container to be scroll-boxed (as a D3 selection)
 * @param {string}  id          Id for the clip path to implement the scroll box
 */
function ScrollBox(gd, container, id) {
    this.gd = gd;
    this.container = container;
    this.id = id;

    // See ScrollBox.prototype.enable for further definition
    this.position = null;  // scrollbox position
    this.translateX = null;  // scrollbox horizontal translation
    this.translateY = null;  // scrollbox vertical translation
    this.hbar = null;  // horizontal scrollbar D3 selection
    this.vbar = null;  // vertical scrollbar D3 selection

    // <rect> element to capture pointer events
    this.bg = this.container.selectAll('rect.scrollbox-bg').data([0]);

    this.bg.exit()
        .on('.drag', null)
        .on('wheel', null)
        .remove();

    this.bg.enter().append('rect')
        .classed('scrollbox-bg', true)
        .style('pointer-events', 'all')
        .attr({
            opacity: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0
        });
}

// scroll bar dimensions
ScrollBox.barWidth = 2;
ScrollBox.barLength = 20;
ScrollBox.barRadius = 2;
ScrollBox.barPad = 1;
ScrollBox.barColor = '#808BA4';

/**
 * If needed, setup a clip path and scrollbars
 *
 * @method
 * @param {Object}  position
 * @param {number}  position.l  Left side position (in pixels)
 * @param {number}  position.t  Top side (in pixels)
 * @param {number}  position.w  Width (in pixels)
 * @param {number}  position.h  Height (in pixels)
 * @param {string}  [position.direction='down']
 *                  Either 'down', 'left', 'right' or 'up'
 * @param {number}  [translateX=0]  Horizontal offset (in pixels)
 * @param {number}  [translateY=0]  Vertical offset (in pixels)
 */
ScrollBox.prototype.enable = function enable(position, translateX, translateY) {
    var fullLayout = this.gd._fullLayout;
    var fullWidth = fullLayout.width;
    var fullHeight = fullLayout.height;

    // compute position of scrollbox
    this.position = position;

    var l = this.position.l;
    var w = this.position.w;
    var t = this.position.t;
    var h = this.position.h;
    var direction = this.position.direction;
    var isDown = (direction === 'down');
    var isLeft = (direction === 'left');
    var isRight = (direction === 'right');
    var isUp = (direction === 'up');
    var boxW = w;
    var boxH = h;
    var boxL, boxR;
    var boxT, boxB;

    if(!isDown && !isLeft && !isRight && !isUp) {
        this.position.direction = 'down';
        isDown = true;
    }

    var isVertical = isDown || isUp;
    if(isVertical) {
        boxL = l;
        boxR = boxL + boxW;

        if(isDown) {
            // anchor to top side
            boxT = t;
            boxB = Math.min(boxT + boxH, fullHeight);
            boxH = boxB - boxT;
        } else {
            // anchor to bottom side
            boxB = t + boxH;
            boxT = Math.max(boxB - boxH, 0);
            boxH = boxB - boxT;
        }
    } else {
        boxT = t;
        boxB = boxT + boxH;

        if(isLeft) {
            // anchor to right side
            boxR = l + boxW;
            boxL = Math.max(boxR - boxW, 0);
            boxW = boxR - boxL;
        } else {
            // anchor to left side
            boxL = l;
            boxR = Math.min(boxL + boxW, fullWidth);
            boxW = boxR - boxL;
        }
    }

    this._box = {
        l: boxL,
        t: boxT,
        w: boxW,
        h: boxH
    };

    // compute position of horizontal scroll bar
    var needsHorizontalScrollBar = (w > boxW);
    var hbarW = ScrollBox.barLength + 2 * ScrollBox.barPad;
    var hbarH = ScrollBox.barWidth + 2 * ScrollBox.barPad;
    // draw horizontal scrollbar on the bottom side
    var hbarL = l;
    var hbarT = t + h;

    if(hbarT + hbarH > fullHeight) hbarT = fullHeight - hbarH;

    var hbar = this.container.selectAll('rect.scrollbar-horizontal').data(
            (needsHorizontalScrollBar) ? [0] : []);

    hbar.exit()
        .on('.drag', null)
        .remove();

    hbar.enter().append('rect')
        .classed('scrollbar-horizontal', true)
        .call(Color.fill, ScrollBox.barColor);

    if(needsHorizontalScrollBar) {
        this.hbar = hbar.attr({
            'rx': ScrollBox.barRadius,
            'ry': ScrollBox.barRadius,
            'x': hbarL,
            'y': hbarT,
            'width': hbarW,
            'height': hbarH
        });

        // hbar center moves between hbarXMin and hbarXMin + hbarTranslateMax
        this._hbarXMin = hbarL + hbarW / 2;
        this._hbarTranslateMax = boxW - hbarW;
    } else {
        delete this.hbar;
        delete this._hbarXMin;
        delete this._hbarTranslateMax;
    }

    // compute position of vertical scroll bar
    var needsVerticalScrollBar = (h > boxH);
    var vbarW = ScrollBox.barWidth + 2 * ScrollBox.barPad;
    var vbarH = ScrollBox.barLength + 2 * ScrollBox.barPad;
    // draw vertical scrollbar on the right side
    var vbarL = l + w;
    var vbarT = t;

    if(vbarL + vbarW > fullWidth) vbarL = fullWidth - vbarW;

    var vbar = this.container.selectAll('rect.scrollbar-vertical').data(
            (needsVerticalScrollBar) ? [0] : []);

    vbar.exit()
        .on('.drag', null)
        .remove();

    vbar.enter().append('rect')
        .classed('scrollbar-vertical', true)
        .call(Color.fill, ScrollBox.barColor);

    if(needsVerticalScrollBar) {
        this.vbar = vbar.attr({
            'rx': ScrollBox.barRadius,
            'ry': ScrollBox.barRadius,
            'x': vbarL,
            'y': vbarT,
            'width': vbarW,
            'height': vbarH
        });

        // vbar center moves between vbarYMin and vbarYMin + vbarTranslateMax
        this._vbarYMin = vbarT + vbarH / 2;
        this._vbarTranslateMax = boxH - vbarH;
    } else {
        delete this.vbar;
        delete this._vbarYMin;
        delete this._vbarTranslateMax;
    }

    // setup a clip path (if scroll bars are needed)
    var clipId = this.id;
    var clipL = boxL - 0.5;
    var clipR = (needsVerticalScrollBar) ? boxR + vbarW + 0.5 : boxR + 0.5;
    var clipT = boxT - 0.5;
    var clipB = (needsHorizontalScrollBar) ? boxB + hbarH + 0.5 : boxB + 0.5;

    var clipPath = fullLayout._topdefs.selectAll('#' + clipId)
        .data((needsHorizontalScrollBar || needsVerticalScrollBar) ? [0] : []);

    clipPath.exit().remove();

    clipPath.enter()
        .append('clipPath').attr('id', clipId)
        .append('rect');

    if(needsHorizontalScrollBar || needsVerticalScrollBar) {
        this._clipRect = clipPath.select('rect').attr({
            x: Math.floor(clipL),
            y: Math.floor(clipT),
            width: Math.ceil(clipR) - Math.floor(clipL),
            height: Math.ceil(clipB) - Math.floor(clipT)
        });

        this.container.call(Drawing.setClipUrl, clipId, this.gd);

        this.bg.attr({
            x: l,
            y: t,
            width: w,
            height: h
        });
    } else {
        this.bg.attr({
            width: 0,
            height: 0
        });
        this.container
            .on('wheel', null)
            .on('.drag', null)
            .call(Drawing.setClipUrl, null);
        delete this._clipRect;
    }

    // set up drag listeners (if scroll bars are needed)
    if(needsHorizontalScrollBar || needsVerticalScrollBar) {
        var onBoxDrag = d3.behavior.drag()
            .on('dragstart', function() {
                d3.event.sourceEvent.preventDefault();
            })
            .on('drag', this._onBoxDrag.bind(this));

        this.container
            .on('wheel', null)
            .on('wheel', this._onBoxWheel.bind(this))
            .on('.drag', null)
            .call(onBoxDrag);

        var onBarDrag = d3.behavior.drag()
            .on('dragstart', function() {
                d3.event.sourceEvent.preventDefault();
                d3.event.sourceEvent.stopPropagation();
            })
            .on('drag', this._onBarDrag.bind(this));

        if(needsHorizontalScrollBar) {
            this.hbar
                .on('.drag', null)
                .call(onBarDrag);
        }

        if(needsVerticalScrollBar) {
            this.vbar
                .on('.drag', null)
                .call(onBarDrag);
        }
    }

    // set scrollbox translation
    this.setTranslate(translateX, translateY);
};

/**
 * If present, remove clip-path and scrollbars
 *
 * @method
 */
ScrollBox.prototype.disable = function disable() {
    if(this.hbar || this.vbar) {
        this.bg.attr({
            width: 0,
            height: 0
        });
        this.container
            .on('wheel', null)
            .on('.drag', null)
            .call(Drawing.setClipUrl, null);
        delete this._clipRect;
    }

    if(this.hbar) {
        this.hbar.on('.drag', null);
        this.hbar.remove();
        delete this.hbar;
        delete this._hbarXMin;
        delete this._hbarTranslateMax;
    }

    if(this.vbar) {
        this.vbar.on('.drag', null);
        this.vbar.remove();
        delete this.vbar;
        delete this._vbarYMin;
        delete this._vbarTranslateMax;
    }
};

/**
 * Handles scroll box drag events
 *
 * @method
 */
ScrollBox.prototype._onBoxDrag = function _onBoxDrag() {
    var translateX = this.translateX;
    var translateY = this.translateY;

    if(this.hbar) {
        translateX -= d3.event.dx;
    }

    if(this.vbar) {
        translateY -= d3.event.dy;
    }

    this.setTranslate(translateX, translateY);
};

/**
 * Handles scroll box wheel events
 *
 * @method
 */
ScrollBox.prototype._onBoxWheel = function _onBoxWheel() {
    var translateX = this.translateX;
    var translateY = this.translateY;

    if(this.hbar) {
        translateX += d3.event.deltaY;
    }

    if(this.vbar) {
        translateY += d3.event.deltaY;
    }

    this.setTranslate(translateX, translateY);
};

/**
 * Handles scroll bar drag events
 *
 * @method
 */
ScrollBox.prototype._onBarDrag = function _onBarDrag() {
    var translateX = this.translateX;
    var translateY = this.translateY;

    if(this.hbar) {
        var xMin = translateX + this._hbarXMin;
        var xMax = xMin + this._hbarTranslateMax;
        var x = Lib.constrain(d3.event.x, xMin, xMax);
        var xf = (x - xMin) / (xMax - xMin);

        var translateXMax = this.position.w - this._box.w;

        translateX = xf * translateXMax;
    }

    if(this.vbar) {
        var yMin = translateY + this._vbarYMin;
        var yMax = yMin + this._vbarTranslateMax;
        var y = Lib.constrain(d3.event.y, yMin, yMax);
        var yf = (y - yMin) / (yMax - yMin);

        var translateYMax = this.position.h - this._box.h;

        translateY = yf * translateYMax;
    }

    this.setTranslate(translateX, translateY);
};

/**
 * Set clip path and scroll bar translate transform
 *
 * @method
 * @param {number}  [translateX=0]  Horizontal offset (in pixels)
 * @param {number}  [translateY=0]  Vertical offset (in pixels)
 */
ScrollBox.prototype.setTranslate = function setTranslate(translateX, translateY) {
    // store translateX and translateY (needed by mouse event handlers)
    var translateXMax = this.position.w - this._box.w;
    var translateYMax = this.position.h - this._box.h;

    translateX = Lib.constrain(translateX || 0, 0, translateXMax);
    translateY = Lib.constrain(translateY || 0, 0, translateYMax);

    this.translateX = translateX;
    this.translateY = translateY;

    this.container.call(Drawing.setTranslate,
        this._box.l - this.position.l - translateX,
        this._box.t - this.position.t - translateY);

    if(this._clipRect) {
        this._clipRect.attr({
            x: Math.floor(this.position.l + translateX - 0.5),
            y: Math.floor(this.position.t + translateY - 0.5)
        });
    }

    if(this.hbar) {
        var xf = translateX / translateXMax;

        this.hbar.call(Drawing.setTranslate,
            translateX + xf * this._hbarTranslateMax,
            translateY);
    }

    if(this.vbar) {
        var yf = translateY / translateYMax;

        this.vbar.call(Drawing.setTranslate,
            translateX,
            translateY + yf * this._vbarTranslateMax);
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/core.js":
/*!********************************************!*\
  !*** ./node_modules/plotly.js/src/core.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



exports.version = __webpack_require__(/*! ./version */ "./node_modules/plotly.js/src/version.js").version;

// inject promise polyfill
__webpack_require__(/*! es6-promise */ "./node_modules/plotly.js/node_modules/es6-promise/dist/es6-promise.js").polyfill();

// inject plot css
__webpack_require__(/*! ../build/plotcss */ "./node_modules/plotly.js/build/plotcss.js");

// inject default MathJax config
__webpack_require__(/*! ./fonts/mathjax_config */ "./node_modules/plotly.js/src/fonts/mathjax_config.js")();

// include registry module and expose register method
var Registry = __webpack_require__(/*! ./registry */ "./node_modules/plotly.js/src/registry.js");
var register = exports.register = Registry.register;

// expose plot api methods
var plotApi = __webpack_require__(/*! ./plot_api */ "./node_modules/plotly.js/src/plot_api/index.js");
var methodNames = Object.keys(plotApi);
for(var i = 0; i < methodNames.length; i++) {
    var name = methodNames[i];
    // _ -> private API methods, but still registered for internal use
    if(name.charAt(0) !== '_') exports[name] = plotApi[name];
    register({
        moduleType: 'apiMethod',
        name: name,
        fn: plotApi[name]
    });
}

// scatter is the only trace included by default
register(__webpack_require__(/*! ./traces/scatter */ "./node_modules/plotly.js/src/traces/scatter/index.js"));

// register all registrable components modules
register([
    __webpack_require__(/*! ./components/legend */ "./node_modules/plotly.js/src/components/legend/index.js"),
    __webpack_require__(/*! ./components/fx */ "./node_modules/plotly.js/src/components/fx/index.js"), // fx needs to come after legend
    __webpack_require__(/*! ./components/annotations */ "./node_modules/plotly.js/src/components/annotations/index.js"),
    __webpack_require__(/*! ./components/annotations3d */ "./node_modules/plotly.js/src/components/annotations3d/index.js"),
    __webpack_require__(/*! ./components/shapes */ "./node_modules/plotly.js/src/components/shapes/index.js"),
    __webpack_require__(/*! ./components/images */ "./node_modules/plotly.js/src/components/images/index.js"),
    __webpack_require__(/*! ./components/updatemenus */ "./node_modules/plotly.js/src/components/updatemenus/index.js"),
    __webpack_require__(/*! ./components/sliders */ "./node_modules/plotly.js/src/components/sliders/index.js"),
    __webpack_require__(/*! ./components/rangeslider */ "./node_modules/plotly.js/src/components/rangeslider/index.js"),
    __webpack_require__(/*! ./components/rangeselector */ "./node_modules/plotly.js/src/components/rangeselector/index.js"),
    __webpack_require__(/*! ./components/grid */ "./node_modules/plotly.js/src/components/grid/index.js"),
    __webpack_require__(/*! ./components/errorbars */ "./node_modules/plotly.js/src/components/errorbars/index.js"),
    __webpack_require__(/*! ./components/colorscale */ "./node_modules/plotly.js/src/components/colorscale/index.js"),
    __webpack_require__(/*! ./components/colorbar */ "./node_modules/plotly.js/src/components/colorbar/index.js")
]);

// locales en and en-US are required for default behavior
register([
    __webpack_require__(/*! ./locale-en */ "./node_modules/plotly.js/src/locale-en.js"),
    __webpack_require__(/*! ./locale-en-us */ "./node_modules/plotly.js/src/locale-en-us.js")
]);

// locales that are present in the window should be loaded
if(window.PlotlyLocales && Array.isArray(window.PlotlyLocales)) {
    register(window.PlotlyLocales);
    delete window.PlotlyLocales;
}

// plot icons
exports.Icons = __webpack_require__(/*! ./fonts/ploticon */ "./node_modules/plotly.js/src/fonts/ploticon.js");

// unofficial 'beta' plot methods, use at your own risk
exports.Plots = __webpack_require__(/*! ./plots/plots */ "./node_modules/plotly.js/src/plots/plots.js");
exports.Fx = __webpack_require__(/*! ./components/fx */ "./node_modules/plotly.js/src/components/fx/index.js");
exports.Snapshot = __webpack_require__(/*! ./snapshot */ "./node_modules/plotly.js/src/snapshot/index.js");
exports.PlotSchema = __webpack_require__(/*! ./plot_api/plot_schema */ "./node_modules/plotly.js/src/plot_api/plot_schema.js");
exports.Queue = __webpack_require__(/*! ./lib/queue */ "./node_modules/plotly.js/src/lib/queue.js");

// export d3 used in the bundle
exports.d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");


/***/ }),

/***/ "./node_modules/plotly.js/src/fonts/mathjax_config.js":
/*!************************************************************!*\
  !*** ./node_modules/plotly.js/src/fonts/mathjax_config.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



/* global MathJax:false */

module.exports = function() {
    if(typeof MathJax !== 'undefined') {
        var globalConfig = (window.PlotlyConfig || {}).MathJaxConfig !== 'local';

        if(globalConfig) {
            MathJax.Hub.Config({
                messageStyle: 'none',
                skipStartupTypeset: true,
                displayAlign: 'left',
                tex2jax: {
                    inlineMath: [['$', '$'], ['\\(', '\\)']]
                }
            });
            MathJax.Hub.Configured();
        }
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/locale-en-us.js":
/*!****************************************************!*\
  !*** ./node_modules/plotly.js/src/locale-en-us.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    moduleType: 'locale',
    name: 'en-US',
    dictionary: {
        'Click to enter Colorscale title': 'Click to enter Colorscale title'
    },
    format: {
        date: '%m/%d/%Y'
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/locale-en.js":
/*!*************************************************!*\
  !*** ./node_modules/plotly.js/src/locale-en.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    moduleType: 'locale',
    name: 'en',
    dictionary: {
        'Click to enter Colorscale title': 'Click to enter Colourscale title'
    },
    format: {
        days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
        shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        months: [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ],
        shortMonths: [
            'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
            'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
        ],
        periods: ['AM', 'PM'],
        dateTime: '%a %b %e %X %Y',
        date: '%d/%m/%Y',
        time: '%H:%M:%S',
        decimal: '.',
        thousands: ',',
        grouping: [3],
        currency: ['$', ''],
        year: '%Y',
        month: '%b %Y',
        dayMonth: '%b %-d',
        dayMonthYear: '%b %-d, %Y'
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/plot_api/index.js":
/*!******************************************************!*\
  !*** ./node_modules/plotly.js/src/plot_api/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var main = __webpack_require__(/*! ./plot_api */ "./node_modules/plotly.js/src/plot_api/plot_api.js");

exports.plot = main.plot;
exports.newPlot = main.newPlot;
exports.restyle = main.restyle;
exports.relayout = main.relayout;
exports.redraw = main.redraw;
exports.update = main.update;
exports._guiRestyle = main._guiRestyle;
exports._guiRelayout = main._guiRelayout;
exports._guiUpdate = main._guiUpdate;
exports._storeDirectGUIEdit = main._storeDirectGUIEdit;
exports.react = main.react;
exports.extendTraces = main.extendTraces;
exports.prependTraces = main.prependTraces;
exports.addTraces = main.addTraces;
exports.deleteTraces = main.deleteTraces;
exports.moveTraces = main.moveTraces;
exports.purge = main.purge;
exports.addFrames = main.addFrames;
exports.deleteFrames = main.deleteFrames;
exports.animate = main.animate;
exports.setPlotConfig = main.setPlotConfig;

exports.toImage = __webpack_require__(/*! ./to_image */ "./node_modules/plotly.js/src/plot_api/to_image.js");
exports.validate = __webpack_require__(/*! ./validate */ "./node_modules/plotly.js/src/plot_api/validate.js");
exports.downloadImage = __webpack_require__(/*! ../snapshot/download */ "./node_modules/plotly.js/src/snapshot/download.js");

var templateApi = __webpack_require__(/*! ./template_api */ "./node_modules/plotly.js/src/plot_api/template_api.js");
exports.makeTemplate = templateApi.makeTemplate;
exports.validateTemplate = templateApi.validateTemplate;


/***/ }),

/***/ "./node_modules/plotly.js/src/plot_api/template_api.js":
/*!*************************************************************!*\
  !*** ./node_modules/plotly.js/src/plot_api/template_api.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var Lib = __webpack_require__(/*! ../lib */ "./node_modules/plotly.js/src/lib/index.js");
var isPlainObject = Lib.isPlainObject;
var PlotSchema = __webpack_require__(/*! ./plot_schema */ "./node_modules/plotly.js/src/plot_api/plot_schema.js");
var Plots = __webpack_require__(/*! ../plots/plots */ "./node_modules/plotly.js/src/plots/plots.js");
var plotAttributes = __webpack_require__(/*! ../plots/attributes */ "./node_modules/plotly.js/src/plots/attributes.js");
var Template = __webpack_require__(/*! ./plot_template */ "./node_modules/plotly.js/src/plot_api/plot_template.js");
var dfltConfig = __webpack_require__(/*! ./plot_config */ "./node_modules/plotly.js/src/plot_api/plot_config.js").dfltConfig;

/**
 * Plotly.makeTemplate: create a template off an existing figure to reuse
 * style attributes on other figures.
 *
 * Note: separated from the rest of templates because otherwise we get circular
 * references due to PlotSchema.
 *
 * @param {object|DOM element|string} figure: The figure to base the template on
 *     should contain a trace array `figure.data`
 *     and a layout object `figure.layout`
 * @returns {object} template: the extracted template - can then be used as
 *     `layout.template` in another figure.
 */
exports.makeTemplate = function(figure) {
    figure = Lib.isPlainObject(figure) ? figure : Lib.getGraphDiv(figure);
    figure = Lib.extendDeep({_context: dfltConfig}, {data: figure.data, layout: figure.layout});
    Plots.supplyDefaults(figure);
    var data = figure.data || [];
    var layout = figure.layout || {};
    // copy over a few items to help follow the schema
    layout._basePlotModules = figure._fullLayout._basePlotModules;
    layout._modules = figure._fullLayout._modules;

    var template = {
        data: {},
        layout: {}
    };

    /*
     * Note: we do NOT validate template values, we just take what's in the
     * user inputs data and layout, not the validated values in fullData and
     * fullLayout. Even if we were to validate here, there's no guarantee that
     * these values would still be valid when applied to a new figure, which
     * may contain different trace modes, different axes, etc. So it's
     * important that when applying a template we still validate the template
     * values, rather than just using them as defaults.
     */

    data.forEach(function(trace) {
        // TODO: What if no style info is extracted for this trace. We may
        // not want an empty object as the null value.
        // TODO: allow transforms to contribute to templates?
        // as it stands they are ignored, which may be for the best...

        var traceTemplate = {};
        walkStyleKeys(trace, traceTemplate, getTraceInfo.bind(null, trace));

        var traceType = Lib.coerce(trace, {}, plotAttributes, 'type');
        var typeTemplates = template.data[traceType];
        if(!typeTemplates) typeTemplates = template.data[traceType] = [];
        typeTemplates.push(traceTemplate);
    });

    walkStyleKeys(layout, template.layout, getLayoutInfo.bind(null, layout));

    /*
     * Compose the new template with an existing one to the same effect
     *
     * NOTE: there's a possibility of slightly different behavior: if the plot
     * has an invalid value and the old template has a valid value for the same
     * attribute, the plot will use the old template value but this routine
     * will pull the invalid value (resulting in the original default).
     * In the general case it's not possible to solve this with a single value,
     * since valid options can be context-dependent. It could be solved with
     * a *list* of values, but that would be huge complexity for little gain.
     */
    delete template.layout.template;
    var oldTemplate = layout.template;
    if(isPlainObject(oldTemplate)) {
        var oldLayoutTemplate = oldTemplate.layout;

        var i, traceType, oldTypeTemplates, oldTypeLen, typeTemplates, typeLen;

        if(isPlainObject(oldLayoutTemplate)) {
            mergeTemplates(oldLayoutTemplate, template.layout);
        }
        var oldDataTemplate = oldTemplate.data;
        if(isPlainObject(oldDataTemplate)) {
            for(traceType in template.data) {
                oldTypeTemplates = oldDataTemplate[traceType];
                if(Array.isArray(oldTypeTemplates)) {
                    typeTemplates = template.data[traceType];
                    typeLen = typeTemplates.length;
                    oldTypeLen = oldTypeTemplates.length;
                    for(i = 0; i < typeLen; i++) {
                        mergeTemplates(oldTypeTemplates[i % oldTypeLen], typeTemplates[i]);
                    }
                    for(i = typeLen; i < oldTypeLen; i++) {
                        typeTemplates.push(Lib.extendDeep({}, oldTypeTemplates[i]));
                    }
                }
            }
            for(traceType in oldDataTemplate) {
                if(!(traceType in template.data)) {
                    template.data[traceType] = Lib.extendDeep([], oldDataTemplate[traceType]);
                }
            }
        }
    }

    return template;
};

function mergeTemplates(oldTemplate, newTemplate) {
    // we don't care about speed here, just make sure we have a totally
    // distinct object from the previous template
    oldTemplate = Lib.extendDeep({}, oldTemplate);

    // sort keys so we always get annotationdefaults before annotations etc
    // so arrayTemplater will work right
    var oldKeys = Object.keys(oldTemplate).sort();
    var i, j;

    function mergeOne(oldVal, newVal, key) {
        if(isPlainObject(newVal) && isPlainObject(oldVal)) {
            mergeTemplates(oldVal, newVal);
        } else if(Array.isArray(newVal) && Array.isArray(oldVal)) {
            // Note: omitted `inclusionAttr` from arrayTemplater here,
            // it's irrelevant as we only want the resulting `_template`.
            var templater = Template.arrayTemplater({_template: oldTemplate}, key);
            for(j = 0; j < newVal.length; j++) {
                var item = newVal[j];
                var oldItem = templater.newItem(item)._template;
                if(oldItem) mergeTemplates(oldItem, item);
            }
            var defaultItems = templater.defaultItems();
            for(j = 0; j < defaultItems.length; j++) newVal.push(defaultItems[j]._template);

            // templateitemname only applies to receiving plots
            for(j = 0; j < newVal.length; j++) delete newVal[j].templateitemname;
        }
    }

    for(i = 0; i < oldKeys.length; i++) {
        var key = oldKeys[i];
        var oldVal = oldTemplate[key];
        if(key in newTemplate) {
            mergeOne(oldVal, newTemplate[key], key);
        } else newTemplate[key] = oldVal;

        // if this is a base key from the old template (eg xaxis), look for
        // extended keys (eg xaxis2) in the new template to merge into
        if(getBaseKey(key) === key) {
            for(var key2 in newTemplate) {
                var baseKey2 = getBaseKey(key2);
                if(key2 !== baseKey2 && baseKey2 === key && !(key2 in oldTemplate)) {
                    mergeOne(oldVal, newTemplate[key2], key);
                }
            }
        }
    }
}

function getBaseKey(key) {
    return key.replace(/[0-9]+$/, '');
}

function walkStyleKeys(parent, templateOut, getAttributeInfo, path, basePath) {
    var pathAttr = basePath && getAttributeInfo(basePath);
    for(var key in parent) {
        var child = parent[key];
        var nextPath = getNextPath(parent, key, path);
        var nextBasePath = getNextPath(parent, key, basePath);
        var attr = getAttributeInfo(nextBasePath);
        if(!attr) {
            var baseKey = getBaseKey(key);
            if(baseKey !== key) {
                nextBasePath = getNextPath(parent, baseKey, basePath);
                attr = getAttributeInfo(nextBasePath);
            }
        }

        // we'll get an attr if path starts with a valid part, then has an
        // invalid ending. Make sure we got all the way to the end.
        if(pathAttr && (pathAttr === attr)) continue;

        if(!attr || attr._noTemplating ||
            attr.valType === 'data_array' ||
            (attr.arrayOk && Array.isArray(child))
        ) {
            continue;
        }

        if(!attr.valType && isPlainObject(child)) {
            walkStyleKeys(child, templateOut, getAttributeInfo, nextPath, nextBasePath);
        } else if(attr._isLinkedToArray && Array.isArray(child)) {
            var dfltDone = false;
            var namedIndex = 0;
            var usedNames = {};
            for(var i = 0; i < child.length; i++) {
                var item = child[i];
                if(isPlainObject(item)) {
                    var name = item.name;
                    if(name) {
                        if(!usedNames[name]) {
                            // named array items: allow all attributes except data arrays
                            walkStyleKeys(item, templateOut, getAttributeInfo,
                                getNextPath(child, namedIndex, nextPath),
                                getNextPath(child, namedIndex, nextBasePath));
                            namedIndex++;
                            usedNames[name] = 1;
                        }
                    } else if(!dfltDone) {
                        var dfltKey = Template.arrayDefaultKey(key);
                        var dfltPath = getNextPath(parent, dfltKey, path);

                        // getAttributeInfo will fail if we try to use dfltKey directly.
                        // Instead put this item into the next array element, then
                        // pull it out and move it to dfltKey.
                        var pathInArray = getNextPath(child, namedIndex, nextPath);
                        walkStyleKeys(item, templateOut, getAttributeInfo, pathInArray,
                            getNextPath(child, namedIndex, nextBasePath));
                        var itemPropInArray = Lib.nestedProperty(templateOut, pathInArray);
                        var dfltProp = Lib.nestedProperty(templateOut, dfltPath);
                        dfltProp.set(itemPropInArray.get());
                        itemPropInArray.set(null);

                        dfltDone = true;
                    }
                }
            }
        } else {
            var templateProp = Lib.nestedProperty(templateOut, nextPath);
            templateProp.set(child);
        }
    }
}

function getLayoutInfo(layout, path) {
    return PlotSchema.getLayoutValObject(
        layout, Lib.nestedProperty({}, path).parts
    );
}

function getTraceInfo(trace, path) {
    return PlotSchema.getTraceValObject(
        trace, Lib.nestedProperty({}, path).parts
    );
}

function getNextPath(parent, key, path) {
    var nextPath;
    if(!path) nextPath = key;
    else if(Array.isArray(parent)) nextPath = path + '[' + key + ']';
    else nextPath = path + '.' + key;

    return nextPath;
}

/**
 * validateTemplate: Test for consistency between the given figure and
 * a template, either already included in the figure or given separately.
 * Note that not every issue we identify here is necessarily a problem,
 * it depends on what you're using the template for.
 *
 * @param {object|DOM element} figure: the plot, with {data, layout} members,
 *     to test the template against
 * @param {Optional(object)} template: the template, with its own {data, layout},
 *     to test. If omitted, we will look for a template already attached as the
 *     plot's `layout.template` attribute.
 *
 * @returns {array} array of error objects each containing:
 *  - {string} code
 *      error code ('missing', 'unused', 'reused', 'noLayout', 'noData')
 *  - {string} msg
 *      a full readable description of the issue.
 */
exports.validateTemplate = function(figureIn, template) {
    var figure = Lib.extendDeep({}, {
        _context: dfltConfig,
        data: figureIn.data,
        layout: figureIn.layout
    });
    var layout = figure.layout || {};
    if(!isPlainObject(template)) template = layout.template || {};
    var layoutTemplate = template.layout;
    var dataTemplate = template.data;
    var errorList = [];

    figure.layout = layout;
    figure.layout.template = template;
    Plots.supplyDefaults(figure);

    var fullLayout = figure._fullLayout;
    var fullData = figure._fullData;

    var layoutPaths = {};
    function crawlLayoutForContainers(obj, paths) {
        for(var key in obj) {
            if(key.charAt(0) !== '_' && isPlainObject(obj[key])) {
                var baseKey = getBaseKey(key);
                var nextPaths = [];
                var i;
                for(i = 0; i < paths.length; i++) {
                    nextPaths.push(getNextPath(obj, key, paths[i]));
                    if(baseKey !== key) nextPaths.push(getNextPath(obj, baseKey, paths[i]));
                }
                for(i = 0; i < nextPaths.length; i++) {
                    layoutPaths[nextPaths[i]] = 1;
                }
                crawlLayoutForContainers(obj[key], nextPaths);
            }
        }
    }

    function crawlLayoutTemplateForContainers(obj, path) {
        for(var key in obj) {
            if(key.indexOf('defaults') === -1 && isPlainObject(obj[key])) {
                var nextPath = getNextPath(obj, key, path);
                if(layoutPaths[nextPath]) {
                    crawlLayoutTemplateForContainers(obj[key], nextPath);
                } else {
                    errorList.push({code: 'unused', path: nextPath});
                }
            }
        }
    }

    if(!isPlainObject(layoutTemplate)) {
        errorList.push({code: 'layout'});
    } else {
        crawlLayoutForContainers(fullLayout, ['layout']);
        crawlLayoutTemplateForContainers(layoutTemplate, 'layout');
    }

    if(!isPlainObject(dataTemplate)) {
        errorList.push({code: 'data'});
    } else {
        var typeCount = {};
        var traceType;
        for(var i = 0; i < fullData.length; i++) {
            var fullTrace = fullData[i];
            traceType = fullTrace.type;
            typeCount[traceType] = (typeCount[traceType] || 0) + 1;
            if(!fullTrace._fullInput._template) {
                // this takes care of the case of traceType in the data but not
                // the template
                errorList.push({
                    code: 'missing',
                    index: fullTrace._fullInput.index,
                    traceType: traceType
                });
            }
        }
        for(traceType in dataTemplate) {
            var templateCount = dataTemplate[traceType].length;
            var dataCount = typeCount[traceType] || 0;
            if(templateCount > dataCount) {
                errorList.push({
                    code: 'unused',
                    traceType: traceType,
                    templateCount: templateCount,
                    dataCount: dataCount
                });
            } else if(dataCount > templateCount) {
                errorList.push({
                    code: 'reused',
                    traceType: traceType,
                    templateCount: templateCount,
                    dataCount: dataCount
                });
            }
        }
    }

    // _template: false is when someone tried to modify an array item
    // but there was no template with matching name
    function crawlForMissingTemplates(obj, path) {
        for(var key in obj) {
            if(key.charAt(0) === '_') continue;
            var val = obj[key];
            var nextPath = getNextPath(obj, key, path);
            if(isPlainObject(val)) {
                if(Array.isArray(obj) && val._template === false && val.templateitemname) {
                    errorList.push({
                        code: 'missing',
                        path: nextPath,
                        templateitemname: val.templateitemname
                    });
                }
                crawlForMissingTemplates(val, nextPath);
            } else if(Array.isArray(val) && hasPlainObject(val)) {
                crawlForMissingTemplates(val, nextPath);
            }
        }
    }
    crawlForMissingTemplates({data: fullData, layout: fullLayout}, '');

    if(errorList.length) return errorList.map(format);
};

function hasPlainObject(arr) {
    for(var i = 0; i < arr.length; i++) {
        if(isPlainObject(arr[i])) return true;
    }
}

function format(opts) {
    var msg;
    switch(opts.code) {
        case 'data':
            msg = 'The template has no key data.';
            break;
        case 'layout':
            msg = 'The template has no key layout.';
            break;
        case 'missing':
            if(opts.path) {
                msg = 'There are no templates for item ' + opts.path +
                    ' with name ' + opts.templateitemname;
            } else {
                msg = 'There are no templates for trace ' + opts.index +
                    ', of type ' + opts.traceType + '.';
            }
            break;
        case 'unused':
            if(opts.path) {
                msg = 'The template item at ' + opts.path +
                    ' was not used in constructing the plot.';
            } else if(opts.dataCount) {
                msg = 'Some of the templates of type ' + opts.traceType +
                    ' were not used. The template has ' + opts.templateCount +
                    ' traces, the data only has ' + opts.dataCount +
                    ' of this type.';
            } else {
                msg = 'The template has ' + opts.templateCount +
                    ' traces of type ' + opts.traceType +
                    ' but there are none in the data.';
            }
            break;
        case 'reused':
            msg = 'Some of the templates of type ' + opts.traceType +
                ' were used more than once. The template has ' +
                opts.templateCount + ' traces, the data has ' +
                opts.dataCount + ' of this type.';
            break;
    }
    opts.msg = msg;

    return opts;
}


/***/ }),

/***/ "./node_modules/plotly.js/src/plot_api/to_image.js":
/*!*********************************************************!*\
  !*** ./node_modules/plotly.js/src/plot_api/to_image.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var isNumeric = __webpack_require__(/*! fast-isnumeric */ "./node_modules/fast-isnumeric/index.js");

var plotApi = __webpack_require__(/*! ./plot_api */ "./node_modules/plotly.js/src/plot_api/plot_api.js");
var plots = __webpack_require__(/*! ../plots/plots */ "./node_modules/plotly.js/src/plots/plots.js");
var Lib = __webpack_require__(/*! ../lib */ "./node_modules/plotly.js/src/lib/index.js");

var helpers = __webpack_require__(/*! ../snapshot/helpers */ "./node_modules/plotly.js/src/snapshot/helpers.js");
var toSVG = __webpack_require__(/*! ../snapshot/tosvg */ "./node_modules/plotly.js/src/snapshot/tosvg.js");
var svgToImg = __webpack_require__(/*! ../snapshot/svgtoimg */ "./node_modules/plotly.js/src/snapshot/svgtoimg.js");
var version = __webpack_require__(/*! ../version */ "./node_modules/plotly.js/src/version.js").version;

var attrs = {
    format: {
        valType: 'enumerated',
        values: ['png', 'jpeg', 'webp', 'svg', 'full-json'],
        dflt: 'png',
        description: 'Sets the format of exported image.'
    },
    width: {
        valType: 'number',
        min: 1,
        description: [
            'Sets the exported image width.',
            'Defaults to the value found in `layout.width`',
            'If set to *null*, the exported image width will match the current graph width.'
        ].join(' ')
    },
    height: {
        valType: 'number',
        min: 1,
        description: [
            'Sets the exported image height.',
            'Defaults to the value found in `layout.height`',
            'If set to *null*, the exported image height will match the current graph height.'
        ].join(' ')
    },
    scale: {
        valType: 'number',
        min: 0,
        dflt: 1,
        description: [
            'Sets a scaling for the generated image.',
            'If set, all features of a graphs (e.g. text, line width)',
            'are scaled, unlike simply setting',
            'a bigger *width* and *height*.'
        ].join(' ')
    },
    setBackground: {
        valType: 'any',
        dflt: false,
        description: [
            'Sets the image background mode.',
            'By default, the image background is determined by `layout.paper_bgcolor`,',
            'the *transparent* mode.',
            'One might consider setting `setBackground` to *opaque*',
            'when exporting a *jpeg* image as JPEGs do not support opacity.'
        ].join(' ')
    },
    imageDataOnly: {
        valType: 'boolean',
        dflt: false,
        description: [
            'Determines whether or not the return value is prefixed by',
            'the image format\'s corresponding \'data:image;\' spec.'
        ].join(' ')
    }
};

/** Plotly.toImage
 *
 * @param {object | string | HTML div} gd
 *   can either be a data/layout/config object
 *   or an existing graph <div>
 *   or an id to an existing graph <div>
 * @param {object} opts (see above)
 * @return {promise}
 */
function toImage(gd, opts) {
    opts = opts || {};

    var data;
    var layout;
    var config;
    var fullLayout;

    if(Lib.isPlainObject(gd)) {
        data = gd.data || [];
        layout = gd.layout || {};
        config = gd.config || {};
        fullLayout = {};
    } else {
        gd = Lib.getGraphDiv(gd);
        data = Lib.extendDeep([], gd.data);
        layout = Lib.extendDeep({}, gd.layout);
        config = gd._context;
        fullLayout = gd._fullLayout || {};
    }

    function isImpliedOrValid(attr) {
        return !(attr in opts) || Lib.validate(opts[attr], attrs[attr]);
    }

    if((!isImpliedOrValid('width') && opts.width !== null) ||
        (!isImpliedOrValid('height') && opts.height !== null)) {
        throw new Error('Height and width should be pixel values.');
    }

    if(!isImpliedOrValid('format')) {
        throw new Error('Image format is not jpeg, png, svg or webp.');
    }

    var fullOpts = {};

    function coerce(attr, dflt) {
        return Lib.coerce(opts, fullOpts, attrs, attr, dflt);
    }

    var format = coerce('format');
    var width = coerce('width');
    var height = coerce('height');
    var scale = coerce('scale');
    var setBackground = coerce('setBackground');
    var imageDataOnly = coerce('imageDataOnly');

    // put the cloned div somewhere off screen before attaching to DOM
    var clonedGd = document.createElement('div');
    clonedGd.style.position = 'absolute';
    clonedGd.style.left = '-5000px';
    document.body.appendChild(clonedGd);

    // extend layout with image options
    var layoutImage = Lib.extendFlat({}, layout);
    if(width) {
        layoutImage.width = width;
    } else if(opts.width === null && isNumeric(fullLayout.width)) {
        layoutImage.width = fullLayout.width;
    }
    if(height) {
        layoutImage.height = height;
    } else if(opts.height === null && isNumeric(fullLayout.height)) {
        layoutImage.height = fullLayout.height;
    }

    // extend config for static plot
    var configImage = Lib.extendFlat({}, config, {
        _exportedPlot: true,
        staticPlot: true,
        setBackground: setBackground
    });

    var redrawFunc = helpers.getRedrawFunc(clonedGd);

    function wait() {
        return new Promise(function(resolve) {
            setTimeout(resolve, helpers.getDelay(clonedGd._fullLayout));
        });
    }

    function convert() {
        return new Promise(function(resolve, reject) {
            var svg = toSVG(clonedGd, format, scale);
            var width = clonedGd._fullLayout.width;
            var height = clonedGd._fullLayout.height;

            function cleanup() {
                plotApi.purge(clonedGd);
                document.body.removeChild(clonedGd);
            }

            if(format === 'full-json') {
                var json = plots.graphJson(clonedGd, false, 'keepdata', 'object', true, true);
                json.version = version;
                json = JSON.stringify(json);
                cleanup();
                if(imageDataOnly) {
                    return resolve(json);
                } else {
                    return resolve(helpers.encodeJSON(json));
                }
            }

            cleanup();

            if(format === 'svg') {
                if(imageDataOnly) {
                    return resolve(svg);
                } else {
                    return resolve(helpers.encodeSVG(svg));
                }
            }

            var canvas = document.createElement('canvas');
            canvas.id = Lib.randstr();

            svgToImg({
                format: format,
                width: width,
                height: height,
                scale: scale,
                canvas: canvas,
                svg: svg,
                // ask svgToImg to return a Promise
                //  rather than EventEmitter
                //  leave EventEmitter for backward
                //  compatibility
                promise: true
            })
            .then(resolve)
            .catch(reject);
        });
    }

    function urlToImageData(url) {
        if(imageDataOnly) {
            return url.replace(helpers.IMAGE_URL_PREFIX, '');
        } else {
            return url;
        }
    }

    return new Promise(function(resolve, reject) {
        plotApi.plot(clonedGd, data, layoutImage, configImage)
            .then(redrawFunc)
            .then(wait)
            .then(convert)
            .then(function(url) { resolve(urlToImageData(url)); })
            .catch(function(err) { reject(err); });
    });
}

module.exports = toImage;


/***/ }),

/***/ "./node_modules/plotly.js/src/plot_api/validate.js":
/*!*********************************************************!*\
  !*** ./node_modules/plotly.js/src/plot_api/validate.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Plots = __webpack_require__(/*! ../plots/plots */ "./node_modules/plotly.js/src/plots/plots.js");
var PlotSchema = __webpack_require__(/*! ./plot_schema */ "./node_modules/plotly.js/src/plot_api/plot_schema.js");
var dfltConfig = __webpack_require__(/*! ./plot_config */ "./node_modules/plotly.js/src/plot_api/plot_config.js").dfltConfig;

var isPlainObject = Lib.isPlainObject;
var isArray = Array.isArray;
var isArrayOrTypedArray = Lib.isArrayOrTypedArray;

/**
 * Validate a data array and layout object.
 *
 * @param {array} data
 * @param {object} layout
 *
 * @return {array} array of error objects each containing:
 *  - {string} code
 *      error code ('object', 'array', 'schema', 'unused', 'invisible' or 'value')
 *  - {string} container
 *      container where the error occurs ('data' or 'layout')
 *  - {number} trace
 *      trace index of the 'data' container where the error occurs
 *  - {array} path
 *      nested path to the key that causes the error
 *  - {string} astr
 *      attribute string variant of 'path' compatible with Plotly.restyle and
 *      Plotly.relayout.
 *  - {string} msg
 *      error message (shown in console in logger config argument is enable)
 */
module.exports = function validate(data, layout) {
    if(data === undefined) data = [];
    if(layout === undefined) layout = {};

    var schema = PlotSchema.get();
    var errorList = [];
    var gd = {_context: Lib.extendFlat({}, dfltConfig)};

    var dataIn, layoutIn;

    if(isArray(data)) {
        gd.data = Lib.extendDeep([], data);
        dataIn = data;
    } else {
        gd.data = [];
        dataIn = [];
        errorList.push(format('array', 'data'));
    }

    if(isPlainObject(layout)) {
        gd.layout = Lib.extendDeep({}, layout);
        layoutIn = layout;
    } else {
        gd.layout = {};
        layoutIn = {};
        if(arguments.length > 1) {
            errorList.push(format('object', 'layout'));
        }
    }

    // N.B. dataIn and layoutIn are in general not the same as
    // gd.data and gd.layout after supplyDefaults as some attributes
    // in gd.data and gd.layout (still) get mutated during this step.

    Plots.supplyDefaults(gd);

    var dataOut = gd._fullData;
    var len = dataIn.length;

    for(var i = 0; i < len; i++) {
        var traceIn = dataIn[i];
        var base = ['data', i];

        if(!isPlainObject(traceIn)) {
            errorList.push(format('object', base));
            continue;
        }

        var traceOut = dataOut[i];
        var traceType = traceOut.type;
        var traceSchema = schema.traces[traceType].attributes;

        // PlotSchema does something fancy with trace 'type', reset it here
        // to make the trace schema compatible with Lib.validate.
        traceSchema.type = {
            valType: 'enumerated',
            values: [traceType]
        };

        if(traceOut.visible === false && traceIn.visible !== false) {
            errorList.push(format('invisible', base));
        }

        crawl(traceIn, traceOut, traceSchema, errorList, base);

        var transformsIn = traceIn.transforms;
        var transformsOut = traceOut.transforms;

        if(transformsIn) {
            if(!isArray(transformsIn)) {
                errorList.push(format('array', base, ['transforms']));
            }

            base.push('transforms');

            for(var j = 0; j < transformsIn.length; j++) {
                var path = ['transforms', j];
                var transformType = transformsIn[j].type;

                if(!isPlainObject(transformsIn[j])) {
                    errorList.push(format('object', base, path));
                    continue;
                }

                var transformSchema = schema.transforms[transformType] ?
                    schema.transforms[transformType].attributes :
                    {};

                // add 'type' to transform schema to validate the transform type
                transformSchema.type = {
                    valType: 'enumerated',
                    values: Object.keys(schema.transforms)
                };

                crawl(transformsIn[j], transformsOut[j], transformSchema, errorList, base, path);
            }
        }
    }

    var layoutOut = gd._fullLayout;
    var layoutSchema = fillLayoutSchema(schema, dataOut);

    crawl(layoutIn, layoutOut, layoutSchema, errorList, 'layout');

    // return undefined if no validation errors were found
    return (errorList.length === 0) ? void(0) : errorList;
};

function crawl(objIn, objOut, schema, list, base, path) {
    path = path || [];

    var keys = Object.keys(objIn);

    for(var i = 0; i < keys.length; i++) {
        var k = keys[i];

        // transforms are handled separately
        if(k === 'transforms') continue;

        var p = path.slice();
        p.push(k);

        var valIn = objIn[k];
        var valOut = objOut[k];

        var nestedSchema = getNestedSchema(schema, k);
        var nestedValType = (nestedSchema || {}).valType;
        var isInfoArray = nestedValType === 'info_array';
        var isColorscale = nestedValType === 'colorscale';
        var items = (nestedSchema || {}).items;

        if(!isInSchema(schema, k)) {
            list.push(format('schema', base, p));
        } else if(isPlainObject(valIn) && isPlainObject(valOut) && nestedValType !== 'any') {
            crawl(valIn, valOut, nestedSchema, list, base, p);
        } else if(isInfoArray && isArray(valIn)) {
            if(valIn.length > valOut.length) {
                list.push(format('unused', base, p.concat(valOut.length)));
            }
            var len = valOut.length;
            var arrayItems = Array.isArray(items);
            if(arrayItems) len = Math.min(len, items.length);
            var m, n, item, valInPart, valOutPart;
            if(nestedSchema.dimensions === 2) {
                for(n = 0; n < len; n++) {
                    if(isArray(valIn[n])) {
                        if(valIn[n].length > valOut[n].length) {
                            list.push(format('unused', base, p.concat(n, valOut[n].length)));
                        }
                        var len2 = valOut[n].length;
                        for(m = 0; m < (arrayItems ? Math.min(len2, items[n].length) : len2); m++) {
                            item = arrayItems ? items[n][m] : items;
                            valInPart = valIn[n][m];
                            valOutPart = valOut[n][m];
                            if(!Lib.validate(valInPart, item)) {
                                list.push(format('value', base, p.concat(n, m), valInPart));
                            } else if(valOutPart !== valInPart && valOutPart !== +valInPart) {
                                list.push(format('dynamic', base, p.concat(n, m), valInPart, valOutPart));
                            }
                        }
                    } else {
                        list.push(format('array', base, p.concat(n), valIn[n]));
                    }
                }
            } else {
                for(n = 0; n < len; n++) {
                    item = arrayItems ? items[n] : items;
                    valInPart = valIn[n];
                    valOutPart = valOut[n];
                    if(!Lib.validate(valInPart, item)) {
                        list.push(format('value', base, p.concat(n), valInPart));
                    } else if(valOutPart !== valInPart && valOutPart !== +valInPart) {
                        list.push(format('dynamic', base, p.concat(n), valInPart, valOutPart));
                    }
                }
            }
        } else if(nestedSchema.items && !isInfoArray && isArray(valIn)) {
            var _nestedSchema = items[Object.keys(items)[0]];
            var indexList = [];

            var j, _p;

            // loop over valOut items while keeping track of their
            // corresponding input container index (given by _index)
            for(j = 0; j < valOut.length; j++) {
                var _index = valOut[j]._index || j;

                _p = p.slice();
                _p.push(_index);

                if(isPlainObject(valIn[_index]) && isPlainObject(valOut[j])) {
                    indexList.push(_index);
                    var valInj = valIn[_index];
                    var valOutj = valOut[j];
                    if(isPlainObject(valInj) && valInj.visible !== false && valOutj.visible === false) {
                        list.push(format('invisible', base, _p));
                    } else crawl(valInj, valOutj, _nestedSchema, list, base, _p);
                }
            }

            // loop over valIn to determine where it went wrong for some items
            for(j = 0; j < valIn.length; j++) {
                _p = p.slice();
                _p.push(j);

                if(!isPlainObject(valIn[j])) {
                    list.push(format('object', base, _p, valIn[j]));
                } else if(indexList.indexOf(j) === -1) {
                    list.push(format('unused', base, _p));
                }
            }
        } else if(!isPlainObject(valIn) && isPlainObject(valOut)) {
            list.push(format('object', base, p, valIn));
        } else if(!isArrayOrTypedArray(valIn) && isArrayOrTypedArray(valOut) && !isInfoArray && !isColorscale) {
            list.push(format('array', base, p, valIn));
        } else if(!(k in objOut)) {
            list.push(format('unused', base, p, valIn));
        } else if(!Lib.validate(valIn, nestedSchema)) {
            list.push(format('value', base, p, valIn));
        } else if(nestedSchema.valType === 'enumerated' &&
            ((nestedSchema.coerceNumber && valIn !== +valOut) || valIn !== valOut)
        ) {
            list.push(format('dynamic', base, p, valIn, valOut));
        }
    }

    return list;
}

// the 'full' layout schema depends on the traces types presents
function fillLayoutSchema(schema, dataOut) {
    var layoutSchema = schema.layout.layoutAttributes;

    for(var i = 0; i < dataOut.length; i++) {
        var traceOut = dataOut[i];
        var traceSchema = schema.traces[traceOut.type];
        var traceLayoutAttr = traceSchema.layoutAttributes;

        if(traceLayoutAttr) {
            if(traceOut.subplot) {
                Lib.extendFlat(layoutSchema[traceSchema.attributes.subplot.dflt], traceLayoutAttr);
            } else {
                Lib.extendFlat(layoutSchema, traceLayoutAttr);
            }
        }
    }

    return layoutSchema;
}

// validation error codes
var code2msgFunc = {
    object: function(base, astr) {
        var prefix;

        if(base === 'layout' && astr === '') prefix = 'The layout argument';
        else if(base[0] === 'data' && astr === '') {
            prefix = 'Trace ' + base[1] + ' in the data argument';
        } else prefix = inBase(base) + 'key ' + astr;

        return prefix + ' must be linked to an object container';
    },
    array: function(base, astr) {
        var prefix;

        if(base === 'data') prefix = 'The data argument';
        else prefix = inBase(base) + 'key ' + astr;

        return prefix + ' must be linked to an array container';
    },
    schema: function(base, astr) {
        return inBase(base) + 'key ' + astr + ' is not part of the schema';
    },
    unused: function(base, astr, valIn) {
        var target = isPlainObject(valIn) ? 'container' : 'key';

        return inBase(base) + target + ' ' + astr + ' did not get coerced';
    },
    dynamic: function(base, astr, valIn, valOut) {
        return [
            inBase(base) + 'key',
            astr,
            '(set to \'' + valIn + '\')',
            'got reset to',
            '\'' + valOut + '\'',
            'during defaults.'
        ].join(' ');
    },
    invisible: function(base, astr) {
        return (
            astr ? (inBase(base) + 'item ' + astr) : ('Trace ' + base[1])
        ) + ' got defaulted to be not visible';
    },
    value: function(base, astr, valIn) {
        return [
            inBase(base) + 'key ' + astr,
            'is set to an invalid value (' + valIn + ')'
        ].join(' ');
    }
};

function inBase(base) {
    if(isArray(base)) return 'In data trace ' + base[1] + ', ';

    return 'In ' + base + ', ';
}

function format(code, base, path, valIn, valOut) {
    path = path || '';

    var container, trace;

    // container is either 'data' or 'layout
    // trace is the trace index if 'data', null otherwise

    if(isArray(base)) {
        container = base[0];
        trace = base[1];
    } else {
        container = base;
        trace = null;
    }

    var astr = convertPathToAttributeString(path);
    var msg = code2msgFunc[code](base, astr, valIn, valOut);

    // log to console if logger config option is enabled
    Lib.log(msg);

    return {
        code: code,
        container: container,
        trace: trace,
        path: path,
        astr: astr,
        msg: msg
    };
}

function isInSchema(schema, key) {
    var parts = splitKey(key);
    var keyMinusId = parts.keyMinusId;
    var id = parts.id;

    if((keyMinusId in schema) && schema[keyMinusId]._isSubplotObj && id) {
        return true;
    }

    return (key in schema);
}

function getNestedSchema(schema, key) {
    if(key in schema) return schema[key];

    var parts = splitKey(key);

    return schema[parts.keyMinusId];
}

var idRegex = Lib.counterRegex('([a-z]+)');

function splitKey(key) {
    var idMatch = key.match(idRegex);

    return {
        keyMinusId: idMatch && idMatch[1],
        id: idMatch && idMatch[2]
    };
}

function convertPathToAttributeString(path) {
    if(!isArray(path)) return String(path);

    var astr = '';

    for(var i = 0; i < path.length; i++) {
        var p = path[i];

        if(typeof p === 'number') {
            astr = astr.substr(0, astr.length - 1) + '[' + p + ']';
        } else {
            astr += p;
        }

        if(i < path.length - 1) astr += '.';
    }

    return astr;
}


/***/ }),

/***/ "./node_modules/plotly.js/src/plots/cartesian/include_components.js":
/*!**************************************************************************!*\
  !*** ./node_modules/plotly.js/src/plots/cartesian/include_components.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var Registry = __webpack_require__(/*! ../../registry */ "./node_modules/plotly.js/src/registry.js");
var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");

/**
 * Factory function for checking component arrays for subplot references.
 *
 * @param {string} containerArrayName: the top-level array in gd.layout to check
 *   If an item in this container is found that references a cartesian x and/or y axis,
 *   ensure cartesian is marked as a base plot module and record the axes (and subplot
 *   if both refs are axes) in gd._fullLayout
 *
 * @return {function}: with args layoutIn (gd.layout) and layoutOut (gd._fullLayout)
 * as expected of a component includeBasePlot method
 */
module.exports = function makeIncludeComponents(containerArrayName) {
    return function includeComponents(layoutIn, layoutOut) {
        var array = layoutIn[containerArrayName];
        if(!Array.isArray(array)) return;

        var Cartesian = Registry.subplotsRegistry.cartesian;
        var idRegex = Cartesian.idRegex;
        var subplots = layoutOut._subplots;
        var xaList = subplots.xaxis;
        var yaList = subplots.yaxis;
        var cartesianList = subplots.cartesian;
        var hasCartesianOrGL2D = layoutOut._has('cartesian') || layoutOut._has('gl2d');

        for(var i = 0; i < array.length; i++) {
            var itemi = array[i];
            if(!Lib.isPlainObject(itemi)) continue;

            var xref = itemi.xref;
            var yref = itemi.yref;

            var hasXref = idRegex.x.test(xref);
            var hasYref = idRegex.y.test(yref);
            if(hasXref || hasYref) {
                if(!hasCartesianOrGL2D) Lib.pushUnique(layoutOut._basePlotModules, Cartesian);

                var newAxis = false;
                if(hasXref && xaList.indexOf(xref) === -1) {
                    xaList.push(xref);
                    newAxis = true;
                }
                if(hasYref && yaList.indexOf(yref) === -1) {
                    yaList.push(yref);
                    newAxis = true;
                }

                /*
                 * Notice the logic here: only add a subplot for a component if
                 * it's referencing both x and y axes AND it's creating a new axis
                 * so for example if your plot already has xy and x2y2, an annotation
                 * on x2y or xy2 will not create a new subplot.
                 */
                if(newAxis && hasXref && hasYref) {
                    cartesianList.push(xref + yref);
                }
            }
        }
    };
};


/***/ }),

/***/ "./node_modules/plotly.js/src/plots/gl3d/project.js":
/*!**********************************************************!*\
  !*** ./node_modules/plotly.js/src/plots/gl3d/project.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




function xformMatrix(m, v) {
    var out = [0, 0, 0, 0];
    var i, j;

    for(i = 0; i < 4; ++i) {
        for(j = 0; j < 4; ++j) {
            out[j] += m[4 * i + j] * v[i];
        }
    }

    return out;
}

function project(camera, v) {
    var p = xformMatrix(camera.projection,
        xformMatrix(camera.view,
        xformMatrix(camera.model, [v[0], v[1], v[2], 1])));
    return p;
}

module.exports = project;


/***/ }),

/***/ "./node_modules/plotly.js/src/snapshot/cloneplot.js":
/*!**********************************************************!*\
  !*** ./node_modules/plotly.js/src/snapshot/cloneplot.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Registry = __webpack_require__(/*! ../registry */ "./node_modules/plotly.js/src/registry.js");
var Lib = __webpack_require__(/*! ../lib */ "./node_modules/plotly.js/src/lib/index.js");

var extendFlat = Lib.extendFlat;
var extendDeep = Lib.extendDeep;

// Put default plotTile layouts here
function cloneLayoutOverride(tileClass) {
    var override;

    switch(tileClass) {
        case 'themes__thumb':
            override = {
                autosize: true,
                width: 150,
                height: 150,
                title: {text: ''},
                showlegend: false,
                margin: {l: 5, r: 5, t: 5, b: 5, pad: 0},
                annotations: []
            };
            break;

        case 'thumbnail':
            override = {
                title: {text: ''},
                hidesources: true,
                showlegend: false,
                borderwidth: 0,
                bordercolor: '',
                margin: {l: 1, r: 1, t: 1, b: 1, pad: 0},
                annotations: []
            };
            break;

        default:
            override = {};
    }


    return override;
}

function keyIsAxis(keyName) {
    var types = ['xaxis', 'yaxis', 'zaxis'];
    return (types.indexOf(keyName.slice(0, 5)) > -1);
}


module.exports = function clonePlot(graphObj, options) {
    // Polar plot compatibility
    if(graphObj.framework && graphObj.framework.isPolar) {
        graphObj = graphObj.framework.getConfig();
    }

    var i;
    var oldData = graphObj.data;
    var oldLayout = graphObj.layout;
    var newData = extendDeep([], oldData);
    var newLayout = extendDeep({}, oldLayout, cloneLayoutOverride(options.tileClass));
    var context = graphObj._context || {};

    if(options.width) newLayout.width = options.width;
    if(options.height) newLayout.height = options.height;

    if(options.tileClass === 'thumbnail' || options.tileClass === 'themes__thumb') {
        // kill annotations
        newLayout.annotations = [];
        var keys = Object.keys(newLayout);

        for(i = 0; i < keys.length; i++) {
            if(keyIsAxis(keys[i])) {
                newLayout[keys[i]].title = {text: ''};
            }
        }

        // kill colorbar and pie labels
        for(i = 0; i < newData.length; i++) {
            var trace = newData[i];
            trace.showscale = false;
            if(trace.marker) trace.marker.showscale = false;
            if(Registry.traceIs(trace, 'pie-like')) trace.textposition = 'none';
        }
    }

    if(Array.isArray(options.annotations)) {
        for(i = 0; i < options.annotations.length; i++) {
            newLayout.annotations.push(options.annotations[i]);
        }
    }

    // TODO: does this scene modification really belong here?
    // If we still need it, can it move into the gl3d module?
    var sceneIds = Object.keys(newLayout).filter(function(key) {
        return key.match(/^scene\d*$/);
    });
    if(sceneIds.length) {
        var axesImageOverride = {};
        if(options.tileClass === 'thumbnail') {
            axesImageOverride = {
                title: {text: ''},
                showaxeslabels: false,
                showticklabels: false,
                linetickenable: false
            };
        }
        for(i = 0; i < sceneIds.length; i++) {
            var scene = newLayout[sceneIds[i]];

            if(!scene.xaxis) {
                scene.xaxis = {};
            }

            if(!scene.yaxis) {
                scene.yaxis = {};
            }

            if(!scene.zaxis) {
                scene.zaxis = {};
            }

            extendFlat(scene.xaxis, axesImageOverride);
            extendFlat(scene.yaxis, axesImageOverride);
            extendFlat(scene.zaxis, axesImageOverride);

            // TODO what does this do?
            scene._scene = null;
        }
    }

    var gd = document.createElement('div');
    if(options.tileClass) gd.className = options.tileClass;

    var plotTile = {
        gd: gd,
        td: gd, // for external (image server) compatibility
        layout: newLayout,
        data: newData,
        config: {
            staticPlot: (options.staticPlot === undefined) ?
                true :
                options.staticPlot,
            plotGlPixelRatio: (options.plotGlPixelRatio === undefined) ?
                2 :
                options.plotGlPixelRatio,
            displaylogo: options.displaylogo || false,
            showLink: options.showLink || false,
            showTips: options.showTips || false,
            mapboxAccessToken: context.mapboxAccessToken
        }
    };

    if(options.setBackground !== 'transparent') {
        plotTile.config.setBackground = options.setBackground || 'opaque';
    }

    // attaching the default Layout the gd, so you can grab it later
    plotTile.gd.defaultLayout = cloneLayoutOverride(options.tileClass);

    return plotTile;
};


/***/ }),

/***/ "./node_modules/plotly.js/src/snapshot/download.js":
/*!*********************************************************!*\
  !*** ./node_modules/plotly.js/src/snapshot/download.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../lib */ "./node_modules/plotly.js/src/lib/index.js");

var toImage = __webpack_require__(/*! ../plot_api/to_image */ "./node_modules/plotly.js/src/plot_api/to_image.js");

var fileSaver = __webpack_require__(/*! ./filesaver */ "./node_modules/plotly.js/src/snapshot/filesaver.js");
var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/plotly.js/src/snapshot/helpers.js");

/**
 * Plotly.downloadImage
 *
 * @param {object | string | HTML div} gd
 *   can either be a data/layout/config object
 *   or an existing graph <div>
 *   or an id to an existing graph <div>
 * @param {object} opts (see Plotly.toImage in ../plot_api/to_image)
 * @return {promise}
 */
function downloadImage(gd, opts) {
    var _gd;
    if(!Lib.isPlainObject(gd)) _gd = Lib.getGraphDiv(gd);

    opts = opts || {};
    opts.format = opts.format || 'png';
    opts.imageDataOnly = true;

    return new Promise(function(resolve, reject) {
        if(_gd && _gd._snapshotInProgress) {
            reject(new Error('Snapshotting already in progress.'));
        }

        // see comments within svgtoimg for additional
        //   discussion of problems with IE
        //   can now draw to canvas, but CORS tainted canvas
        //   does not allow toDataURL
        //   svg format will work though
        if(Lib.isIE() && opts.format !== 'svg') {
            reject(new Error(helpers.MSG_IE_BAD_FORMAT));
        }

        if(_gd) _gd._snapshotInProgress = true;
        var promise = toImage(gd, opts);

        var filename = opts.filename || gd.fn || 'newplot';
        filename += '.' + opts.format.replace('-', '.');

        promise.then(function(result) {
            if(_gd) _gd._snapshotInProgress = false;
            return fileSaver(result, filename, opts.format);
        }).then(function(name) {
            resolve(name);
        }).catch(function(err) {
            if(_gd) _gd._snapshotInProgress = false;
            reject(err);
        });
    });
}

module.exports = downloadImage;


/***/ }),

/***/ "./node_modules/plotly.js/src/snapshot/filesaver.js":
/*!**********************************************************!*\
  !*** ./node_modules/plotly.js/src/snapshot/filesaver.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../lib */ "./node_modules/plotly.js/src/lib/index.js");
var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/plotly.js/src/snapshot/helpers.js");

/*
* substantial portions of this code from FileSaver.js
* https://github.com/eligrey/FileSaver.js
* License: https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
* FileSaver.js
* A saveAs() FileSaver implementation.
* 1.1.20160328
*
* By Eli Grey, http://eligrey.com
* License: MIT
*   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
*/
function fileSaver(url, name, format) {
    var saveLink = document.createElement('a');
    var canUseSaveLink = 'download' in saveLink;

    var promise = new Promise(function(resolve, reject) {
        var blob;
        var objectUrl;

        if(Lib.isIE9orBelow()) {
            reject(new Error('IE < 10 unsupported'));
        }

        // Safari doesn't allow downloading of blob urls
        if(Lib.isSafari()) {
            var prefix = format === 'svg' ? ',' : ';base64,';
            helpers.octetStream(prefix + encodeURIComponent(url));
            return resolve(name);
        }

        // IE 10+ (native saveAs)
        if(Lib.isIE()) {
            // At this point we are only dealing with a decoded SVG as
            // a data URL (since IE only supports SVG)
            blob = helpers.createBlob(url, 'svg');
            window.navigator.msSaveBlob(blob, name);
            blob = null;
            return resolve(name);
        }

        if(canUseSaveLink) {
            blob = helpers.createBlob(url, format);
            objectUrl = helpers.createObjectURL(blob);

            saveLink.href = objectUrl;
            saveLink.download = name;
            document.body.appendChild(saveLink);
            saveLink.click();

            document.body.removeChild(saveLink);
            helpers.revokeObjectURL(objectUrl);
            blob = null;

            return resolve(name);
        }

        reject(new Error('download error'));
    });

    return promise;
}


module.exports = fileSaver;


/***/ }),

/***/ "./node_modules/plotly.js/src/snapshot/helpers.js":
/*!********************************************************!*\
  !*** ./node_modules/plotly.js/src/snapshot/helpers.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Registry = __webpack_require__(/*! ../registry */ "./node_modules/plotly.js/src/registry.js");

exports.getDelay = function(fullLayout) {
    if(!fullLayout._has) return 0;

    return (
        fullLayout._has('gl3d') ||
        fullLayout._has('gl2d') ||
        fullLayout._has('mapbox')
    ) ? 500 : 0;
};

exports.getRedrawFunc = function(gd) {
    return function() {
        var fullLayout = gd._fullLayout || {};
        var hasPolar = fullLayout._has && fullLayout._has('polar');
        var hasLegacyPolar = !hasPolar && gd.data && gd.data[0] && gd.data[0].r;

        if(!hasLegacyPolar) {
            Registry.getComponentMethod('colorbar', 'draw')(gd);
        }
    };
};

exports.encodeSVG = function(svg) {
    return 'data:image/svg+xml,' + encodeURIComponent(svg);
};

exports.encodeJSON = function(json) {
    return 'data:application/json,' + encodeURIComponent(json);
};

var DOM_URL = window.URL || window.webkitURL;

exports.createObjectURL = function(blob) {
    return DOM_URL.createObjectURL(blob);
};

exports.revokeObjectURL = function(url) {
    return DOM_URL.revokeObjectURL(url);
};

exports.createBlob = function(url, format) {
    if(format === 'svg') {
        return new window.Blob([url], {type: 'image/svg+xml;charset=utf-8'});
    } else if(format === 'full-json') {
        return new window.Blob([url], {type: 'application/json;charset=utf-8'});
    } else {
        var binary = fixBinary(window.atob(url));
        return new window.Blob([binary], {type: 'image/' + format});
    }
};

exports.octetStream = function(s) {
    document.location.href = 'data:application/octet-stream' + s;
};

// Taken from https://bl.ocks.org/nolanlawson/0eac306e4dac2114c752
function fixBinary(b) {
    var len = b.length;
    var buf = new ArrayBuffer(len);
    var arr = new Uint8Array(buf);
    for(var i = 0; i < len; i++) {
        arr[i] = b.charCodeAt(i);
    }
    return buf;
}

exports.IMAGE_URL_PREFIX = /^data:image\/\w+;base64,/;

exports.MSG_IE_BAD_FORMAT = 'Sorry IE does not support downloading from canvas. Try {format:\'svg\'} instead.';


/***/ }),

/***/ "./node_modules/plotly.js/src/snapshot/index.js":
/*!******************************************************!*\
  !*** ./node_modules/plotly.js/src/snapshot/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/plotly.js/src/snapshot/helpers.js");

var Snapshot = {
    getDelay: helpers.getDelay,
    getRedrawFunc: helpers.getRedrawFunc,
    clone: __webpack_require__(/*! ./cloneplot */ "./node_modules/plotly.js/src/snapshot/cloneplot.js"),
    toSVG: __webpack_require__(/*! ./tosvg */ "./node_modules/plotly.js/src/snapshot/tosvg.js"),
    svgToImg: __webpack_require__(/*! ./svgtoimg */ "./node_modules/plotly.js/src/snapshot/svgtoimg.js"),
    toImage: __webpack_require__(/*! ./toimage */ "./node_modules/plotly.js/src/snapshot/toimage.js"),
    downloadImage: __webpack_require__(/*! ./download */ "./node_modules/plotly.js/src/snapshot/download.js")
};

module.exports = Snapshot;


/***/ }),

/***/ "./node_modules/plotly.js/src/snapshot/svgtoimg.js":
/*!*********************************************************!*\
  !*** ./node_modules/plotly.js/src/snapshot/svgtoimg.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../lib */ "./node_modules/plotly.js/src/lib/index.js");
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/plotly.js/src/snapshot/helpers.js");

function svgToImg(opts) {
    var ev = opts.emitter || new EventEmitter();

    var promise = new Promise(function(resolve, reject) {
        var Image = window.Image;
        var svg = opts.svg;
        var format = opts.format || 'png';

        // IE only support svg
        if(Lib.isIE() && format !== 'svg') {
            var ieSvgError = new Error(helpers.MSG_IE_BAD_FORMAT);
            reject(ieSvgError);
            // eventually remove the ev
            //  in favor of promises
            if(!opts.promise) {
                return ev.emit('error', ieSvgError);
            } else {
                return promise;
            }
        }

        var canvas = opts.canvas;
        var scale = opts.scale || 1;
        var w0 = opts.width || 300;
        var h0 = opts.height || 150;
        var w1 = scale * w0;
        var h1 = scale * h0;

        var ctx = canvas.getContext('2d');
        var img = new Image();
        var svgBlob, url;

        if(format === 'svg' || Lib.isIE9orBelow() || Lib.isSafari()) {
            url = helpers.encodeSVG(svg);
        } else {
            svgBlob = helpers.createBlob(svg, 'svg');
            url = helpers.createObjectURL(svgBlob);
        }

        canvas.width = w1;
        canvas.height = h1;

        img.onload = function() {
            var imgData;

            svgBlob = null;
            helpers.revokeObjectURL(url);

            // don't need to draw to canvas if svg
            //  save some time and also avoid failure on IE
            if(format !== 'svg') {
                ctx.drawImage(img, 0, 0, w1, h1);
            }

            switch(format) {
                case 'jpeg':
                    imgData = canvas.toDataURL('image/jpeg');
                    break;
                case 'png':
                    imgData = canvas.toDataURL('image/png');
                    break;
                case 'webp':
                    imgData = canvas.toDataURL('image/webp');
                    break;
                case 'svg':
                    imgData = url;
                    break;
                default:
                    var errorMsg = 'Image format is not jpeg, png, svg or webp.';
                    reject(new Error(errorMsg));
                    // eventually remove the ev
                    //  in favor of promises
                    if(!opts.promise) {
                        return ev.emit('error', errorMsg);
                    }
            }
            resolve(imgData);
            // eventually remove the ev
            //  in favor of promises
            if(!opts.promise) {
                ev.emit('success', imgData);
            }
        };

        img.onerror = function(err) {
            svgBlob = null;
            helpers.revokeObjectURL(url);

            reject(err);
            // eventually remove the ev
            //  in favor of promises
            if(!opts.promise) {
                return ev.emit('error', err);
            }
        };

        img.src = url;
    });

    // temporary for backward compatibility
    //  move to only Promise in 2.0.0
    //  and eliminate the EventEmitter
    if(opts.promise) {
        return promise;
    }

    return ev;
}

module.exports = svgToImg;


/***/ }),

/***/ "./node_modules/plotly.js/src/snapshot/toimage.js":
/*!********************************************************!*\
  !*** ./node_modules/plotly.js/src/snapshot/toimage.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

var Registry = __webpack_require__(/*! ../registry */ "./node_modules/plotly.js/src/registry.js");
var Lib = __webpack_require__(/*! ../lib */ "./node_modules/plotly.js/src/lib/index.js");

var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/plotly.js/src/snapshot/helpers.js");
var clonePlot = __webpack_require__(/*! ./cloneplot */ "./node_modules/plotly.js/src/snapshot/cloneplot.js");
var toSVG = __webpack_require__(/*! ./tosvg */ "./node_modules/plotly.js/src/snapshot/tosvg.js");
var svgToImg = __webpack_require__(/*! ./svgtoimg */ "./node_modules/plotly.js/src/snapshot/svgtoimg.js");

/**
 * @param {object} gd figure Object
 * @param {object} opts option object
 * @param opts.format 'jpeg' | 'png' | 'webp' | 'svg'
 */
function toImage(gd, opts) {
    // first clone the GD so we can operate in a clean environment
    var ev = new EventEmitter();

    var clone = clonePlot(gd, {format: 'png'});
    var clonedGd = clone.gd;

    // put the cloned div somewhere off screen before attaching to DOM
    clonedGd.style.position = 'absolute';
    clonedGd.style.left = '-5000px';
    document.body.appendChild(clonedGd);

    function wait() {
        var delay = helpers.getDelay(clonedGd._fullLayout);

        setTimeout(function() {
            var svg = toSVG(clonedGd);

            var canvas = document.createElement('canvas');
            canvas.id = Lib.randstr();

            ev = svgToImg({
                format: opts.format,
                width: clonedGd._fullLayout.width,
                height: clonedGd._fullLayout.height,
                canvas: canvas,
                emitter: ev,
                svg: svg
            });

            ev.clean = function() {
                if(clonedGd) document.body.removeChild(clonedGd);
            };
        }, delay);
    }

    var redrawFunc = helpers.getRedrawFunc(clonedGd);

    Registry.call('plot', clonedGd, clone.data, clone.layout, clone.config)
        .then(redrawFunc)
        .then(wait)
        .catch(function(err) {
            ev.emit('error', err);
        });


    return ev;
}

module.exports = toImage;


/***/ }),

/***/ "./node_modules/plotly.js/src/snapshot/tosvg.js":
/*!******************************************************!*\
  !*** ./node_modules/plotly.js/src/snapshot/tosvg.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");

var Lib = __webpack_require__(/*! ../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Drawing = __webpack_require__(/*! ../components/drawing */ "./node_modules/plotly.js/src/components/drawing/index.js");
var Color = __webpack_require__(/*! ../components/color */ "./node_modules/plotly.js/src/components/color/index.js");

var xmlnsNamespaces = __webpack_require__(/*! ../constants/xmlns_namespaces */ "./node_modules/plotly.js/src/constants/xmlns_namespaces.js");
var DOUBLEQUOTE_REGEX = /"/g;
var DUMMY_SUB = 'TOBESTRIPPED';
var DUMMY_REGEX = new RegExp('("' + DUMMY_SUB + ')|(' + DUMMY_SUB + '")', 'g');

function htmlEntityDecode(s) {
    var hiddenDiv = d3.select('body').append('div').style({display: 'none'}).html('');
    var replaced = s.replace(/(&[^;]*;)/gi, function(d) {
        if(d === '&lt;') { return '&#60;'; } // special handling for brackets
        if(d === '&rt;') { return '&#62;'; }
        if(d.indexOf('<') !== -1 || d.indexOf('>') !== -1) { return ''; }
        return hiddenDiv.html(d).text(); // everything else, let the browser decode it to unicode
    });
    hiddenDiv.remove();
    return replaced;
}

function xmlEntityEncode(str) {
    return str.replace(/&(?!\w+;|\#[0-9]+;| \#x[0-9A-F]+;)/g, '&amp;');
}

module.exports = function toSVG(gd, format, scale) {
    var fullLayout = gd._fullLayout;
    var svg = fullLayout._paper;
    var toppaper = fullLayout._toppaper;
    var width = fullLayout.width;
    var height = fullLayout.height;
    var i;

    // make background color a rect in the svg, then revert after scraping
    // all other alterations have been dealt with by properly preparing the svg
    // in the first place... like setting cursors with css classes so we don't
    // have to remove them, and providing the right namespaces in the svg to
    // begin with
    svg.insert('rect', ':first-child')
        .call(Drawing.setRect, 0, 0, width, height)
        .call(Color.fill, fullLayout.paper_bgcolor);

    // subplot-specific to-SVG methods
    // which notably add the contents of the gl-container
    // into the main svg node
    var basePlotModules = fullLayout._basePlotModules || [];
    for(i = 0; i < basePlotModules.length; i++) {
        var _module = basePlotModules[i];

        if(_module.toSVG) _module.toSVG(gd);
    }

    // add top items above them assumes everything in toppaper is either
    // a group or a defs, and if it's empty (like hoverlayer) we can ignore it.
    if(toppaper) {
        var nodes = toppaper.node().childNodes;

        // make copy of nodes as childNodes prop gets mutated in loop below
        var topGroups = Array.prototype.slice.call(nodes);

        for(i = 0; i < topGroups.length; i++) {
            var topGroup = topGroups[i];

            if(topGroup.childNodes.length) svg.node().appendChild(topGroup);
        }
    }

    // remove draglayer for Adobe Illustrator compatibility
    if(fullLayout._draggers) {
        fullLayout._draggers.remove();
    }

    // in case the svg element had an explicit background color, remove this
    // we want the rect to get the color so it's the right size; svg bg will
    // fill whatever container it's displayed in regardless of plot size.
    svg.node().style.background = '';

    svg.selectAll('text')
        .attr({'data-unformatted': null, 'data-math': null})
        .each(function() {
            var txt = d3.select(this);

            // hidden text is pre-formatting mathjax, the browser ignores it
            // but in a static plot it's useless and it can confuse batik
            // we've tried to standardize on display:none but make sure we still
            // catch visibility:hidden if it ever arises
            if(this.style.visibility === 'hidden' || this.style.display === 'none') {
                txt.remove();
                return;
            } else {
                // clear other visibility/display values to default
                // to not potentially confuse non-browser SVG implementations
                txt.style({visibility: null, display: null});
            }

            // Font family styles break things because of quotation marks,
            // so we must remove them *after* the SVG DOM has been serialized
            // to a string (browsers convert singles back)
            var ff = this.style.fontFamily;
            if(ff && ff.indexOf('"') !== -1) {
                txt.style('font-family', ff.replace(DOUBLEQUOTE_REGEX, DUMMY_SUB));
            }
        });


    if(fullLayout._gradientUrlQueryParts) {
        var queryParts = [];
        for(var k in fullLayout._gradientUrlQueryParts) queryParts.push(k);

        if(queryParts.length) {
            svg.selectAll(queryParts.join(',')).each(function() {
                var pt = d3.select(this);

                // similar to font family styles above,
                // we must remove " after the SVG DOM has been serialized
                var fill = this.style.fill;
                if(fill && fill.indexOf('url(') !== -1) {
                    pt.style('fill', fill.replace(DOUBLEQUOTE_REGEX, DUMMY_SUB));
                }

                var stroke = this.style.stroke;
                if(stroke && stroke.indexOf('url(') !== -1) {
                    pt.style('stroke', stroke.replace(DOUBLEQUOTE_REGEX, DUMMY_SUB));
                }
            });
        }
    }

    if(format === 'pdf' || format === 'eps') {
        // these formats make the extra line MathJax adds around symbols look super thick in some cases
        // it looks better if this is removed entirely.
        svg.selectAll('#MathJax_SVG_glyphs path')
            .attr('stroke-width', 0);
    }

    // fix for IE namespacing quirk?
    // http://stackoverflow.com/questions/19610089/unwanted-namespaces-on-svg-markup-when-using-xmlserializer-in-javascript-with-ie
    svg.node().setAttributeNS(xmlnsNamespaces.xmlns, 'xmlns', xmlnsNamespaces.svg);
    svg.node().setAttributeNS(xmlnsNamespaces.xmlns, 'xmlns:xlink', xmlnsNamespaces.xlink);

    if(format === 'svg' && scale) {
        svg.attr('width', scale * width);
        svg.attr('height', scale * height);
        svg.attr('viewBox', '0 0 ' + width + ' ' + height);
    }

    var s = new window.XMLSerializer().serializeToString(svg.node());
    s = htmlEntityDecode(s);
    s = xmlEntityEncode(s);

    // Fix quotations around font strings and gradient URLs
    s = s.replace(DUMMY_REGEX, '\'');

    // IE is very strict, so we will need to clean
    //  svg with the following regex
    //  yes this is messy, but do not know a better way
    // Even with this IE will not work due to tainted canvas
    //  see https://github.com/kangax/fabric.js/issues/1957
    //      http://stackoverflow.com/questions/18112047/canvas-todataurl-working-in-all-browsers-except-ie10
    // Leave here just in case the CORS/tainted IE issue gets resolved
    if(Lib.isIE()) {
        // replace double quote with single quote
        s = s.replace(/"/gi, '\'');
        // url in svg are single quoted
        //   since we changed double to single
        //   we'll need to change these to double-quoted
        s = s.replace(/(\('#)([^']*)('\))/gi, '(\"#$2\")');
        // font names with spaces will be escaped single-quoted
        //   we'll need to change these to double-quoted
        s = s.replace(/(\\')/gi, '\"');
    }

    return s;
};


/***/ }),

/***/ "./node_modules/plotly.js/src/version.js":
/*!***********************************************!*\
  !*** ./node_modules/plotly.js/src/version.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



// package version injected by `npm run preprocess`
exports.version = '1.54.5';


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9idWlsZC9wbG90Y3NzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL2xpYi9jb3JlLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL2Fubm90YXRpb25zL2NhbGNfYXV0b3JhbmdlLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL2Fubm90YXRpb25zL2NsaWNrLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL2Fubm90YXRpb25zL2NvbW1vbl9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9hbm5vdGF0aW9ucy9jb252ZXJ0X2Nvb3Jkcy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9hbm5vdGF0aW9ucy9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9hbm5vdGF0aW9ucy9kcmF3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL2Fubm90YXRpb25zL2RyYXdfYXJyb3dfaGVhZC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9hbm5vdGF0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9hbm5vdGF0aW9uczNkL2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvYW5ub3RhdGlvbnMzZC9jb252ZXJ0LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL2Fubm90YXRpb25zM2QvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvYW5ub3RhdGlvbnMzZC9kcmF3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL2Fubm90YXRpb25zM2QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvY29sb3JiYXIvY29uc3RhbnRzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL2NvbG9yYmFyL2RyYXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvY29sb3JiYXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvZXJyb3JiYXJzL2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvZXJyb3JiYXJzL2NhbGMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvZXJyb3JiYXJzL2NvbXB1dGVfZXJyb3IuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvZXJyb3JiYXJzL2RlZmF1bHRzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL2Vycm9yYmFycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9lcnJvcmJhcnMvcGxvdC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9lcnJvcmJhcnMvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvaW1hZ2VzL2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvaW1hZ2VzL2NvbnZlcnRfY29vcmRzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL2ltYWdlcy9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9pbWFnZXMvZHJhdy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9pbWFnZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvbGVnZW5kL2luZGV4LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL3Jhbmdlc2VsZWN0b3IvYXR0cmlidXRlcy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9yYW5nZXNlbGVjdG9yL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9yYW5nZXNlbGVjdG9yL2RlZmF1bHRzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL3Jhbmdlc2VsZWN0b3IvZHJhdy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9yYW5nZXNlbGVjdG9yL2dldF91cGRhdGVfb2JqZWN0LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL3Jhbmdlc2VsZWN0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvcmFuZ2VzbGlkZXIvYXR0cmlidXRlcy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9yYW5nZXNsaWRlci9jYWxjX2F1dG9yYW5nZS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9yYW5nZXNsaWRlci9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvcmFuZ2VzbGlkZXIvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvcmFuZ2VzbGlkZXIvZHJhdy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9yYW5nZXNsaWRlci9oZWxwZXJzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL3Jhbmdlc2xpZGVyL2luZGV4LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL3Jhbmdlc2xpZGVyL29wcGF4aXNfYXR0cmlidXRlcy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9zaGFwZXMvYXR0cmlidXRlcy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9zaGFwZXMvY2FsY19hdXRvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvc2hhcGVzL2RlZmF1bHRzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL3NoYXBlcy9kcmF3X25ld3NoYXBlL2RlZmF1bHRzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL3NoYXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9zbGlkZXJzL2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvc2xpZGVycy9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvc2xpZGVycy9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy9zbGlkZXJzL2RyYXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2NvbXBvbmVudHMvc2xpZGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy91cGRhdGVtZW51cy9hdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL3VwZGF0ZW1lbnVzL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy91cGRhdGVtZW51cy9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29tcG9uZW50cy91cGRhdGVtZW51cy9kcmF3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL3VwZGF0ZW1lbnVzL2luZGV4LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9jb21wb25lbnRzL3VwZGF0ZW1lbnVzL3Njcm9sbGJveC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvY29yZS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvZm9udHMvbWF0aGpheF9jb25maWcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL2xvY2FsZS1lbi11cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvbG9jYWxlLWVuLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9wbG90X2FwaS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvcGxvdF9hcGkvdGVtcGxhdGVfYXBpLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9wbG90X2FwaS90b19pbWFnZS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvcGxvdF9hcGkvdmFsaWRhdGUuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3Bsb3RzL2NhcnRlc2lhbi9pbmNsdWRlX2NvbXBvbmVudHMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3Bsb3RzL2dsM2QvcHJvamVjdC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvc25hcHNob3QvY2xvbmVwbG90LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9zbmFwc2hvdC9kb3dubG9hZC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvc25hcHNob3QvZmlsZXNhdmVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9zbmFwc2hvdC9oZWxwZXJzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy9zbmFwc2hvdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvc25hcHNob3Qvc3ZndG9pbWcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3NuYXBzaG90L3RvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3NuYXBzaG90L3Rvc3ZnLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy92ZXJzaW9uLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFhOztBQUViLFVBQVUsbUJBQU8sQ0FBQyw2REFBWTtBQUM5QjtBQUNBLDhCQUE4QixvREFBb0QsU0FBUyxVQUFVO0FBQ3JHLDZFQUE2RTtBQUM3RSxrREFBa0Q7QUFDbEQsaUNBQWlDO0FBQ2pDLHVDQUF1QztBQUN2Qyw0Q0FBNEM7QUFDNUMscURBQXFELHNCQUFzQixxQkFBcUIsb0JBQW9CLGlCQUFpQjtBQUNySSw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLG1DQUFtQztBQUNuQyxzQ0FBc0MsTUFBTSxPQUFPLG9CQUFvQjtBQUN2RSxrREFBa0Q7QUFDbEQseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyw2Q0FBNkM7QUFDN0MsbUNBQW1DO0FBQ25DLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsMkNBQTJDO0FBQzNDLDZDQUE2QztBQUM3QywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDZDQUE2QztBQUM3QywyQ0FBMkM7QUFDM0MsNkNBQTZDO0FBQzdDLDJDQUEyQyxZ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Q0FBQyx5Q0FBeUMsVUFBYztBQUN4RDtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiw2Q0FBNkM7QUFDaEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCLFVBQVUsT0FBTztBQUNqQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CLFVBQVUsU0FBUztBQUNuQjtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQSxXQUFXO0FBQ1g7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFlBQVksU0FBUztBQUNyQixhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxxQkFBTTtBQUNuQixZQUFZLHFCQUFNO0FBQ2xCLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7Ozs7QUFJRDs7Ozs7Ozs7Ozs7O0FDcnBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR2E7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLDREQUFXO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyx3RkFBNEI7O0FBRS9DLFdBQVcscUdBQXNCOzs7QUFHakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLDREQUFXO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyxnRUFBZ0I7QUFDdkMsa0JBQWtCLDZIQUFtRDs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLDREQUFXO0FBQzdCLFlBQVksbUJBQU8sQ0FBQyx3RUFBVTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hDLGlCQUFpQixtQkFBTyxDQUFDLGdGQUF3Qjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHYTs7QUFFYixVQUFVLG1CQUFPLENBQUMsNERBQVc7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLHdGQUE0QjtBQUMvQyxtQ0FBbUMsbUJBQU8sQ0FBQyw0R0FBc0M7O0FBRWpGLHFDQUFxQyxtQkFBTyxDQUFDLGlHQUFtQjtBQUNoRSxpQkFBaUIsbUJBQU8sQ0FBQyx1RkFBYzs7O0FBR3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQixrQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsU0FBUyxtQkFBTyxDQUFDLG1DQUFJOztBQUVyQixlQUFlLG1CQUFPLENBQUMsZ0VBQWdCO0FBQ3ZDLFlBQVksbUJBQU8sQ0FBQyxzRUFBbUI7QUFDdkMsVUFBVSxtQkFBTyxDQUFDLDREQUFXO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyx3RkFBNEI7QUFDL0MsWUFBWSxtQkFBTyxDQUFDLHdFQUFVO0FBQzlCLGNBQWMsbUJBQU8sQ0FBQyw0RUFBWTtBQUNsQyxTQUFTLG1CQUFPLENBQUMsa0VBQU87QUFDeEIsbUJBQW1CLG1CQUFPLENBQUMsb0ZBQTBCO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLDBFQUFxQjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyxvRkFBZ0I7QUFDMUMsa0JBQWtCLDZIQUFtRDs7QUFFckUsb0JBQW9CLG1CQUFPLENBQUMsaUdBQW1COztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsbUNBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG9CQUFvQixrQkFBa0I7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwwRUFBMEU7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsbUNBQW1DO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxvQ0FBb0M7QUFDckY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7Ozs7Ozs7Ozs7OztBQ3pyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdhOztBQUViLFNBQVMsbUJBQU8sQ0FBQyxtQ0FBSTs7QUFFckIsWUFBWSxtQkFBTyxDQUFDLHdFQUFVOztBQUU5QixpQkFBaUIsbUJBQU8sQ0FBQyx5RkFBZTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlOztBQUVmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5Qiw0Q0FBNEM7O0FBRXJFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR2E7O0FBRWIsaUJBQWlCLG1CQUFPLENBQUMsMkVBQVE7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsNkVBQVM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQU8sQ0FBQyx1RkFBYztBQUM1QywwQkFBMEIsbUJBQU8sQ0FBQyxtRkFBWTtBQUM5QyxxQkFBcUIsbUJBQU8sQ0FBQyxvSEFBMEM7O0FBRXZFLG1CQUFtQixtQkFBTyxDQUFDLCtGQUFrQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBa0I7QUFDN0M7Ozs7Ozs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR2E7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLG9HQUEyQjtBQUNsRCxrQkFBa0IsdUhBQWdEO0FBQ2xFLHFCQUFxQixnSUFBc0Q7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUMvRkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLDREQUFXO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyx3RkFBNEI7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixVQUFVLG1CQUFPLENBQUMsNERBQVc7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLHdGQUE0QjtBQUMvQyxtQ0FBbUMsbUJBQU8sQ0FBQyw0R0FBc0M7QUFDakYscUNBQXFDLG1CQUFPLENBQUMsOEdBQWdDO0FBQzdFLGlCQUFpQixtQkFBTyxDQUFDLHlGQUFjOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGNBQWMscUhBQXNDO0FBQ3BELGNBQWMsbUJBQU8sQ0FBQyxvRkFBMEI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBOztBQUVBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxnRUFBZ0I7QUFDdkMsVUFBVSxtQkFBTyxDQUFDLDREQUFXOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixhQUFhLG1CQUFPLENBQUMseUZBQWM7QUFDdkQ7QUFDQSxLQUFLOztBQUVMLHNCQUFzQixtQkFBTyxDQUFDLHlGQUFjO0FBQzVDLG9CQUFvQixtQkFBTyxDQUFDLHFGQUFZO0FBQ3hDOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxtRkFBVztBQUNoQyxVQUFVLG1CQUFPLENBQUMsNkVBQVE7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsU0FBUyxtQkFBTyxDQUFDLG1DQUFJO0FBQ3JCLGdCQUFnQixtQkFBTyxDQUFDLDBEQUFZOztBQUVwQyxZQUFZLG1CQUFPLENBQUMsc0VBQW1CO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxnRUFBZ0I7QUFDdkMsV0FBVyxtQkFBTyxDQUFDLHdGQUE0QjtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyxvRkFBZ0I7QUFDMUMsVUFBVSxtQkFBTyxDQUFDLDREQUFXO0FBQzdCLGlCQUFpQixvR0FBc0M7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQXFCO0FBQzdDLGNBQWMsbUJBQU8sQ0FBQyw0RUFBWTtBQUNsQyxZQUFZLG1CQUFPLENBQUMsd0VBQVU7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLDBFQUFXO0FBQ2hDLG1CQUFtQixtQkFBTyxDQUFDLG9GQUEwQjtBQUNyRCxnQkFBZ0IsMkhBQTBDOztBQUUxRCx5QkFBeUIsbUJBQU8sQ0FBQywwR0FBcUM7QUFDdEUsaUNBQWlDLG1CQUFPLENBQUMsa0hBQXlDO0FBQ2xGLHNCQUFzQixtQkFBTyxDQUFDLGtIQUF5Qzs7QUFFdkUseUJBQXlCLG1CQUFPLENBQUMsc0ZBQTJCO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDBHQUF5Qjs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQixFQUFFOztBQUV2RTtBQUNBLHVDQUF1QyxpQkFBaUIsRUFBRTtBQUMxRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwyQkFBMkIsRUFBRTtBQUN0RixpRUFBaUUseUNBQXlDLEVBQUU7QUFDNUc7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOEJBQThCLGdDQUFnQyxFQUFFO0FBQ2hFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUNBQW1DO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQkFBc0I7O0FBRWpFO0FBQ0EsNENBQTRDLHVCQUF1QjtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkVBQTZFO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDZCQUE2QixvQ0FBb0M7QUFDakUsNEJBQTRCO0FBQzVCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjLEVBQUU7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbnRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsb0ZBQWM7QUFDdEMsb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQVk7O0FBRXhDLFVBQVUsa0dBQXNCO0FBQ2hDLGlCQUFpQixtQkFBTyxDQUFDLHdGQUFnQjtBQUN6Qzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOzs7QUFHYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsOERBQWdCOztBQUV4QyxlQUFlLG1CQUFPLENBQUMsZ0VBQWdCO0FBQ3ZDLFdBQVcsbUJBQU8sQ0FBQyx3RkFBNEI7QUFDL0MsVUFBVSxtQkFBTyxDQUFDLDREQUFXOztBQUU3Qix1QkFBdUIsbUJBQU8sQ0FBQywyRkFBaUI7O0FBRWhEO0FBQ0E7O0FBRUEsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUNBQWlDLEdBQUcsYUFBYTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHYTs7O0FBR2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVksU0FBUztBQUNyQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQyw4REFBZ0I7O0FBRXhDLGVBQWUsbUJBQU8sQ0FBQyxnRUFBZ0I7QUFDdkMsVUFBVSxtQkFBTyxDQUFDLDREQUFXO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyw0RkFBOEI7O0FBRXJELGlCQUFpQixtQkFBTyxDQUFDLHFGQUFjOzs7QUFHdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixVQUFVLG1CQUFPLENBQUMsNERBQVc7QUFDN0Isa0JBQWtCLHVIQUFnRDs7QUFFbEUsaUJBQWlCLG1CQUFPLENBQUMscUZBQWM7O0FBRXZDO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLG9CQUFvQixtQkFBTyxDQUFDLGlGQUFZOztBQUV4QyxVQUFVLG1CQUFPLENBQUMseUVBQVE7QUFDMUIsc0JBQXNCLG1CQUFPLENBQUMsMkZBQWlCOztBQUUvQyxVQUFVLG1CQUFPLENBQUMseUVBQVE7QUFDMUIsV0FBVyxtQkFBTyxDQUFDLDJFQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdhOztBQUViLFNBQVMsbUJBQU8sQ0FBQyxtQ0FBSTtBQUNyQixnQkFBZ0IsbUJBQU8sQ0FBQyw4REFBZ0I7O0FBRXhDLGNBQWMsbUJBQU8sQ0FBQyw0RUFBWTtBQUNsQyxlQUFlLG1CQUFPLENBQUMsOEZBQStCOztBQUV0RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDs7O0FBR2xELHNFQUFzRTs7QUFFdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRCxzRUFBc0U7O0FBRXRFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHYTs7QUFFYixTQUFTLG1CQUFPLENBQUMsbUNBQUk7O0FBRXJCLFlBQVksbUJBQU8sQ0FBQyx3RUFBVTs7O0FBRzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLHlCQUF5QixtQkFBTyxDQUFDLGtHQUFpQztBQUNsRSxxQkFBcUIsZ0lBQXNEOzs7QUFHM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QixtQkFBTyxDQUFDLHdGQUFxQjtBQUM5QyxxQkFBcUIsZ0lBQXNEOztBQUUzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7Ozs7Ozs7Ozs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QyxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsZ0RBQWdELEVBQUU7QUFDdkY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtB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Q0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEJBQTRCLDJCQUEyQixzQkFBc0I7QUFDN0UsNEJBQTRCLDJCQUEyQiwyQkFBMkI7QUFDbEYsMkJBQTJCLFNBQVMsc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLHNCQUFzQjtBQUN2RDtBQUNBLEtBQUssR0FBRyxJQUFJLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxlQUFlOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUI7O0FBRTFEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFD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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQSxlQUFlIiwiZmlsZSI6ImNoYXJ0OWU5YmVjZmJjZjI5NjE4OTgxMWYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBMaWIgPSByZXF1aXJlKCcuLi9zcmMvbGliJyk7XG52YXIgcnVsZXMgPSB7XG4gICAgXCJYLFggZGl2XCI6IFwiZGlyZWN0aW9uOmx0cjtmb250LWZhbWlseTonT3BlbiBTYW5zJywgdmVyZGFuYSwgYXJpYWwsIHNhbnMtc2VyaWY7bWFyZ2luOjA7cGFkZGluZzowO1wiLFxuICAgIFwiWCBpbnB1dCxYIGJ1dHRvblwiOiBcImZvbnQtZmFtaWx5OidPcGVuIFNhbnMnLCB2ZXJkYW5hLCBhcmlhbCwgc2Fucy1zZXJpZjtcIixcbiAgICBcIlggaW5wdXQ6Zm9jdXMsWCBidXR0b246Zm9jdXNcIjogXCJvdXRsaW5lOm5vbmU7XCIsXG4gICAgXCJYIGFcIjogXCJ0ZXh0LWRlY29yYXRpb246bm9uZTtcIixcbiAgICBcIlggYTpob3ZlclwiOiBcInRleHQtZGVjb3JhdGlvbjpub25lO1wiLFxuICAgIFwiWCAuY3Jpc3BcIjogXCJzaGFwZS1yZW5kZXJpbmc6Y3Jpc3BFZGdlcztcIixcbiAgICBcIlggLnVzZXItc2VsZWN0LW5vbmVcIjogXCItd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lOy1vLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtcIixcbiAgICBcIlggc3ZnXCI6IFwib3ZlcmZsb3c6aGlkZGVuO1wiLFxuICAgIFwiWCBzdmcgYVwiOiBcImZpbGw6IzQ0N2FkYjtcIixcbiAgICBcIlggc3ZnIGE6aG92ZXJcIjogXCJmaWxsOiMzYzZkYzU7XCIsXG4gICAgXCJYIC5tYWluLXN2Z1wiOiBcInBvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtwb2ludGVyLWV2ZW50czpub25lO1wiLFxuICAgIFwiWCAubWFpbi1zdmcgLmRyYWdsYXllclwiOiBcInBvaW50ZXItZXZlbnRzOmFsbDtcIixcbiAgICBcIlggLmN1cnNvci1kZWZhdWx0XCI6IFwiY3Vyc29yOmRlZmF1bHQ7XCIsXG4gICAgXCJYIC5jdXJzb3ItcG9pbnRlclwiOiBcImN1cnNvcjpwb2ludGVyO1wiLFxuICAgIFwiWCAuY3Vyc29yLWNyb3NzaGFpclwiOiBcImN1cnNvcjpjcm9zc2hhaXI7XCIsXG4gICAgXCJYIC5jdXJzb3ItbW92ZVwiOiBcImN1cnNvcjptb3ZlO1wiLFxuICAgIFwiWCAuY3Vyc29yLWNvbC1yZXNpemVcIjogXCJjdXJzb3I6Y29sLXJlc2l6ZTtcIixcbiAgICBcIlggLmN1cnNvci1yb3ctcmVzaXplXCI6IFwiY3Vyc29yOnJvdy1yZXNpemU7XCIsXG4gICAgXCJYIC5jdXJzb3ItbnMtcmVzaXplXCI6IFwiY3Vyc29yOm5zLXJlc2l6ZTtcIixcbiAgICBcIlggLmN1cnNvci1ldy1yZXNpemVcIjogXCJjdXJzb3I6ZXctcmVzaXplO1wiLFxuICAgIFwiWCAuY3Vyc29yLXN3LXJlc2l6ZVwiOiBcImN1cnNvcjpzdy1yZXNpemU7XCIsXG4gICAgXCJYIC5jdXJzb3Itcy1yZXNpemVcIjogXCJjdXJzb3I6cy1yZXNpemU7XCIsXG4gICAgXCJYIC5jdXJzb3Itc2UtcmVzaXplXCI6IFwiY3Vyc29yOnNlLXJlc2l6ZTtcIixcbiAgICBcIlggLmN1cnNvci13LXJlc2l6ZVwiOiBcImN1cnNvcjp3LXJlc2l6ZTtcIixcbiAgICBcIlggLmN1cnNvci1lLXJlc2l6ZVwiOiBcImN1cnNvcjplLXJlc2l6ZTtcIixcbiAgICBcIlggLmN1cnNvci1udy1yZXNpemVcIjogXCJjdXJzb3I6bnctcmVzaXplO1wiLFxuICAgIFwiWCAuY3Vyc29yLW4tcmVzaXplXCI6IFwiY3Vyc29yOm4tcmVzaXplO1wiLFxuICAgIFwiWCAuY3Vyc29yLW5lLXJlc2l6ZVwiOiBcImN1cnNvcjpuZS1yZXNpemU7XCIsXG4gICAgXCJYIC5jdXJzb3ItZ3JhYlwiOiBcImN1cnNvcjotd2Via2l0LWdyYWI7Y3Vyc29yOmdyYWI7XCIsXG4gICAgXCJYIC5tb2RlYmFyXCI6IFwicG9zaXRpb246YWJzb2x1dGU7dG9wOjJweDtyaWdodDoycHg7XCIsXG4gICAgXCJYIC5lYXNlLWJnXCI6IFwiLXdlYmtpdC10cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgMC4zcyBlYXNlIDBzOy1tb3otdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIDAuM3MgZWFzZSAwczstbXMtdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIDAuM3MgZWFzZSAwczstby10cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgMC4zcyBlYXNlIDBzO3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAwLjNzIGVhc2UgMHM7XCIsXG4gICAgXCJYIC5tb2RlYmFyLS1ob3Zlcj46bm90KC53YXRlcm1hcmspXCI6IFwib3BhY2l0eTowOy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IDAuM3MgZWFzZSAwczstbW96LXRyYW5zaXRpb246b3BhY2l0eSAwLjNzIGVhc2UgMHM7LW1zLXRyYW5zaXRpb246b3BhY2l0eSAwLjNzIGVhc2UgMHM7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IDAuM3MgZWFzZSAwczt0cmFuc2l0aW9uOm9wYWNpdHkgMC4zcyBlYXNlIDBzO1wiLFxuICAgIFwiWDpob3ZlciAubW9kZWJhci0taG92ZXIgLm1vZGViYXItZ3JvdXBcIjogXCJvcGFjaXR5OjE7XCIsXG4gICAgXCJYIC5tb2RlYmFyLWdyb3VwXCI6IFwiZmxvYXQ6bGVmdDtkaXNwbGF5OmlubGluZS1ibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7cGFkZGluZy1sZWZ0OjhweDtwb3NpdGlvbjpyZWxhdGl2ZTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7d2hpdGUtc3BhY2U6bm93cmFwO1wiLFxuICAgIFwiWCAubW9kZWJhci1idG5cIjogXCJwb3NpdGlvbjpyZWxhdGl2ZTtmb250LXNpemU6MTZweDtwYWRkaW5nOjNweCA0cHg7aGVpZ2h0OjIycHg7Y3Vyc29yOnBvaW50ZXI7bGluZS1oZWlnaHQ6bm9ybWFsO2JveC1zaXppbmc6Ym9yZGVyLWJveDtcIixcbiAgICBcIlggLm1vZGViYXItYnRuIHN2Z1wiOiBcInBvc2l0aW9uOnJlbGF0aXZlO3RvcDoycHg7XCIsXG4gICAgXCJYIC5tb2RlYmFyLnZlcnRpY2FsXCI6IFwiZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LXdyYXA6d3JhcDthbGlnbi1jb250ZW50OmZsZXgtZW5kO21heC1oZWlnaHQ6MTAwJTtcIixcbiAgICBcIlggLm1vZGViYXIudmVydGljYWwgc3ZnXCI6IFwidG9wOi0xcHg7XCIsXG4gICAgXCJYIC5tb2RlYmFyLnZlcnRpY2FsIC5tb2RlYmFyLWdyb3VwXCI6IFwiZGlzcGxheTpibG9jaztmbG9hdDpub25lO3BhZGRpbmctbGVmdDowcHg7cGFkZGluZy1ib3R0b206OHB4O1wiLFxuICAgIFwiWCAubW9kZWJhci52ZXJ0aWNhbCAubW9kZWJhci1ncm91cCAubW9kZWJhci1idG5cIjogXCJkaXNwbGF5OmJsb2NrO3RleHQtYWxpZ246Y2VudGVyO1wiLFxuICAgIFwiWCBbZGF0YS10aXRsZV06YmVmb3JlLFggW2RhdGEtdGl0bGVdOmFmdGVyXCI6IFwicG9zaXRpb246YWJzb2x1dGU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwgMCwgMCk7LW1vei10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwgMCwgMCk7LW1zLXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLCAwLCAwKTstby10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwgMCwgMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsIDAsIDApO2Rpc3BsYXk6bm9uZTtvcGFjaXR5OjA7ei1pbmRleDoxMDAxO3BvaW50ZXItZXZlbnRzOm5vbmU7dG9wOjExMCU7cmlnaHQ6NTAlO1wiLFxuICAgIFwiWCBbZGF0YS10aXRsZV06aG92ZXI6YmVmb3JlLFggW2RhdGEtdGl0bGVdOmhvdmVyOmFmdGVyXCI6IFwiZGlzcGxheTpibG9jaztvcGFjaXR5OjE7XCIsXG4gICAgXCJYIFtkYXRhLXRpdGxlXTpiZWZvcmVcIjogXCJjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7Ym9yZGVyOjZweCBzb2xpZCB0cmFuc3BhcmVudDt6LWluZGV4OjEwMDI7bWFyZ2luLXRvcDotMTJweDtib3JkZXItYm90dG9tLWNvbG9yOiM2OTczOGE7bWFyZ2luLXJpZ2h0Oi02cHg7XCIsXG4gICAgXCJYIFtkYXRhLXRpdGxlXTphZnRlclwiOiBcImNvbnRlbnQ6YXR0cihkYXRhLXRpdGxlKTtiYWNrZ3JvdW5kOiM2OTczOGE7Y29sb3I6d2hpdGU7cGFkZGluZzo4cHggMTBweDtmb250LXNpemU6MTJweDtsaW5lLWhlaWdodDoxMnB4O3doaXRlLXNwYWNlOm5vd3JhcDttYXJnaW4tcmlnaHQ6LTE4cHg7Ym9yZGVyLXJhZGl1czoycHg7XCIsXG4gICAgXCJYIC52ZXJ0aWNhbCBbZGF0YS10aXRsZV06YmVmb3JlLFggLnZlcnRpY2FsIFtkYXRhLXRpdGxlXTphZnRlclwiOiBcInRvcDowJTtyaWdodDoyMDAlO1wiLFxuICAgIFwiWCAudmVydGljYWwgW2RhdGEtdGl0bGVdOmJlZm9yZVwiOiBcImJvcmRlcjo2cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQtY29sb3I6IzY5NzM4YTttYXJnaW4tdG9wOjhweDttYXJnaW4tcmlnaHQ6LTMwcHg7XCIsXG4gICAgXCJYIC5zZWxlY3Qtb3V0bGluZVwiOiBcImZpbGw6bm9uZTtzdHJva2Utd2lkdGg6MTtzaGFwZS1yZW5kZXJpbmc6Y3Jpc3BFZGdlcztcIixcbiAgICBcIlggLnNlbGVjdC1vdXRsaW5lLTFcIjogXCJzdHJva2U6d2hpdGU7XCIsXG4gICAgXCJYIC5zZWxlY3Qtb3V0bGluZS0yXCI6IFwic3Ryb2tlOmJsYWNrO3N0cm9rZS1kYXNoYXJyYXk6MnB4IDJweDtcIixcbiAgICBZOiBcImZvbnQtZmFtaWx5OidPcGVuIFNhbnMnLCB2ZXJkYW5hLCBhcmlhbCwgc2Fucy1zZXJpZjtwb3NpdGlvbjpmaXhlZDt0b3A6NTBweDtyaWdodDoyMHB4O3otaW5kZXg6MTAwMDA7Zm9udC1zaXplOjEwcHQ7bWF4LXdpZHRoOjE4MHB4O1wiLFxuICAgIFwiWSBwXCI6IFwibWFyZ2luOjA7XCIsXG4gICAgXCJZIC5ub3RpZmllci1ub3RlXCI6IFwibWluLXdpZHRoOjE4MHB4O21heC13aWR0aDoyNTBweDtib3JkZXI6MXB4IHNvbGlkICNmZmY7ei1pbmRleDozMDAwO21hcmdpbjowO2JhY2tncm91bmQtY29sb3I6IzhjOTdhZjtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMTQwLDE1MSwxNzUsMC45KTtjb2xvcjojZmZmO3BhZGRpbmc6MTBweDtvdmVyZmxvdy13cmFwOmJyZWFrLXdvcmQ7d29yZC13cmFwOmJyZWFrLXdvcmQ7LW1zLWh5cGhlbnM6YXV0bzstd2Via2l0LWh5cGhlbnM6YXV0bztoeXBoZW5zOmF1dG87XCIsXG4gICAgXCJZIC5ub3RpZmllci1jbG9zZVwiOiBcImNvbG9yOiNmZmY7b3BhY2l0eTowLjg7ZmxvYXQ6cmlnaHQ7cGFkZGluZzowIDVweDtiYWNrZ3JvdW5kOm5vbmU7Ym9yZGVyOm5vbmU7Zm9udC1zaXplOjIwcHg7Zm9udC13ZWlnaHQ6Ym9sZDtsaW5lLWhlaWdodDoyMHB4O1wiLFxuICAgIFwiWSAubm90aWZpZXItY2xvc2U6aG92ZXJcIjogXCJjb2xvcjojNDQ0O3RleHQtZGVjb3JhdGlvbjpub25lO2N1cnNvcjpwb2ludGVyO1wiXG59O1xuXG5mb3IodmFyIHNlbGVjdG9yIGluIHJ1bGVzKSB7XG4gICAgdmFyIGZ1bGxTZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoL14sLywnICwnKVxuICAgICAgICAucmVwbGFjZSgvWC9nLCAnLmpzLXBsb3RseS1wbG90IC5wbG90bHknKVxuICAgICAgICAucmVwbGFjZSgvWS9nLCAnLnBsb3RseS1ub3RpZmllcicpO1xuICAgIExpYi5hZGRTdHlsZVJ1bGUoZnVsbFNlbGVjdG9yLCBydWxlc1tzZWxlY3Rvcl0pO1xufVxuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL3NyYy9jb3JlJyk7XG4iLCIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIHY0LjIuOCsxZTY4ZGNlNlxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5FUzZQcm9taXNlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgeDtcbiAgcmV0dXJuIHggIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cblxudmFyIF9pc0FycmF5ID0gdm9pZCAwO1xuaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG59XG5cbnZhciBpc0FycmF5ID0gX2lzQXJyYXk7XG5cbnZhciBsZW4gPSAwO1xudmFyIHZlcnR4TmV4dCA9IHZvaWQgMDtcbnZhciBjdXN0b21TY2hlZHVsZXJGbiA9IHZvaWQgMDtcblxudmFyIGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgcXVldWVbbGVuXSA9IGNhbGxiYWNrO1xuICBxdWV1ZVtsZW4gKyAxXSA9IGFyZztcbiAgbGVuICs9IDI7XG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgaWYgKGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICBjdXN0b21TY2hlZHVsZXJGbihmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gIGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbn1cblxuZnVuY3Rpb24gc2V0QXNhcChhc2FwRm4pIHtcbiAgYXNhcCA9IGFzYXBGbjtcbn1cblxudmFyIGJyb3dzZXJXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbnZhciBicm93c2VyR2xvYmFsID0gYnJvd3NlcldpbmRvdyB8fCB7fTtcbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIGlmICh0eXBlb2YgdmVydHhOZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2ZXJ0eE5leHQoZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIG5vZGUuZGF0YSA9IGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyO1xuICB9O1xufVxuXG4vLyB3ZWIgd29ya2VyXG5mdW5jdGlvbiB1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0VGltZW91dCgpIHtcbiAgLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gZXM2LXByb21pc2Ugd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgZ2xvYmFsU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFNldFRpbWVvdXQoZmx1c2gsIDEpO1xuICB9O1xufVxuXG52YXIgcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgIHZhciBhcmcgPSBxdWV1ZVtpICsgMV07XG5cbiAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgcXVldWVbaSArIDFdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFZlcnR4KCkge1xuICB0cnkge1xuICAgIHZhciB2ZXJ0eCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkucmVxdWlyZSgndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdm9pZCAwO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG5cbiAgaWYgKF9zdGF0ZSkge1xuICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjayhfc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlc29sdmVkIHdpdGggdGhlXG4gIHBhc3NlZCBgdmFsdWVgLiBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlJDEob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQRU5ESU5HID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiB0cnlUaGVuKHRoZW4kJDEsIHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcbiAgdHJ5IHtcbiAgICB0aGVuJCQxLmNhbGwodmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgYXNhcChmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSB0cnlUaGVuKHRoZW4kJDEsIHRoZW5hYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGVuYWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0sICdTZXR0bGU6ICcgKyAocHJvbWlzZS5fbGFiZWwgfHwgJyB1bmtub3duIHByb21pc2UnKSk7XG5cbiAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgfVxuICB9LCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUpIHtcbiAgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGlmIChtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yID09PSBwcm9taXNlLmNvbnN0cnVjdG9yICYmIHRoZW4kJDEgPT09IHRoZW4gJiYgbWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3Rvci5yZXNvbHZlID09PSByZXNvbHZlJDEpIHtcbiAgICBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhlbiQkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQxKSkge1xuICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBzZWxmRnVsZmlsbG1lbnQoKSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgdGhlbiQkMSA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgdGhlbiQkMSA9IHZhbHVlLnRoZW47XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUsIHRoZW4kJDEpO1xuICB9IGVsc2Uge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgfVxuXG4gIHB1Ymxpc2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gIHByb21pc2UuX3N0YXRlID0gRlVMRklMTEVEO1xuXG4gIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHByb21pc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb21pc2UuX3N0YXRlID0gUkVKRUNURUQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblxuICBhc2FwKHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIF9zdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gIHZhciBsZW5ndGggPSBfc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG5cbiAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICBfc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gPSBvblJlamVjdGlvbjtcblxuICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2hpbGQgPSB2b2lkIDAsXG4gICAgICBjYWxsYmFjayA9IHZvaWQgMCxcbiAgICAgIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICB2YWx1ZSA9IHZvaWQgMCxcbiAgICAgIGVycm9yID0gdm9pZCAwLFxuICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcblxuICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgZXJyb3IgPSBlO1xuICAgIH1cblxuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBkZXRhaWw7XG4gIH1cblxuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAvLyBub29wXG4gIH0gZWxzZSBpZiAoaGFzQ2FsbGJhY2sgJiYgc3VjY2VlZGVkKSB7XG4gICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc3VjY2VlZGVkID09PSBmYWxzZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlKTtcbiAgfVxufVxuXG52YXIgaWQgPSAwO1xuZnVuY3Rpb24gbmV4dElkKCkge1xuICByZXR1cm4gaWQrKztcbn1cblxuZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuICBwcm9taXNlW1BST01JU0VfSURdID0gaWQrKztcbiAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbn1cblxudmFyIEVudW1lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICAgIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgICBtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgdGhpcy5fZW51bWVyYXRlKGlucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgICB9XG4gIH1cblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gX2VudW1lcmF0ZShpbnB1dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiBfZWFjaEVudHJ5KGVudHJ5LCBpKSB7XG4gICAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICAgIHZhciByZXNvbHZlJCQxID0gYy5yZXNvbHZlO1xuXG5cbiAgICBpZiAocmVzb2x2ZSQkMSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgICB2YXIgX3RoZW4gPSB2b2lkIDA7XG4gICAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIF90aGVuID0gZW50cnkudGhlbjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBlcnJvciA9IGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhlbiA9PT0gdGhlbiAmJiBlbnRyeS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAgICAgdGhpcy5fc2V0dGxlZEF0KGVudHJ5Ll9zdGF0ZSwgaSwgZW50cnkuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLl9yZW1haW5pbmctLTtcbiAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IFByb21pc2UkMSkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBjKG5vb3ApO1xuICAgICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIF90aGVuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQobmV3IGMoZnVuY3Rpb24gKHJlc29sdmUkJDEpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSQkMShlbnRyeSk7XG4gICAgICAgIH0pLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHJlc29sdmUkJDEoZW50cnkpLCBpKTtcbiAgICB9XG4gIH07XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uIF9zZXR0bGVkQXQoc3RhdGUsIGksIHZhbHVlKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cblxuICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICAgICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICB9XG4gIH07XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uIF93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSkge1xuICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICAgIHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KFJFSkVDVEVELCBpLCByZWFzb24pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBFbnVtZXJhdG9yO1xufSgpO1xuXG4vKipcbiAgYFByb21pc2UuYWxsYCBhY2NlcHRzIGFuIGFycmF5IG9mIHByb21pc2VzLCBhbmQgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoXG4gIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGFycmF5IG9mIGZ1bGZpbGxtZW50IHZhbHVlcyBmb3IgdGhlIHBhc3NlZCBwcm9taXNlcywgb3JcbiAgcmVqZWN0ZWQgd2l0aCB0aGUgcmVhc29uIG9mIHRoZSBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBiZSByZWplY3RlZC4gSXQgY2FzdHMgYWxsXG4gIGVsZW1lbnRzIG9mIHRoZSBwYXNzZWQgaXRlcmFibGUgdG8gcHJvbWlzZXMgYXMgaXQgcnVucyB0aGlzIGFsZ29yaXRobS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVzb2x2ZSgyKTtcbiAgbGV0IHByb21pc2UzID0gcmVzb2x2ZSgzKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIFRoZSBhcnJheSBoZXJlIHdvdWxkIGJlIFsgMSwgMiwgMyBdO1xuICB9KTtcbiAgYGBgXG5cbiAgSWYgYW55IG9mIHRoZSBgcHJvbWlzZXNgIGdpdmVuIHRvIGBhbGxgIGFyZSByZWplY3RlZCwgdGhlIGZpcnN0IHByb21pc2VcbiAgdGhhdCBpcyByZWplY3RlZCB3aWxsIGJlIGdpdmVuIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSByZXR1cm5lZCBwcm9taXNlcydzXG4gIHJlamVjdGlvbiBoYW5kbGVyLiBGb3IgZXhhbXBsZTpcblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVqZWN0KG5ldyBFcnJvcihcIjJcIikpO1xuICBsZXQgcHJvbWlzZTMgPSByZWplY3QobmV3IEVycm9yKFwiM1wiKSk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVucyBiZWNhdXNlIHRoZXJlIGFyZSByZWplY3RlZCBwcm9taXNlcyFcbiAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAvLyBlcnJvci5tZXNzYWdlID09PSBcIjJcIlxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCBhbGxcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBlbnRyaWVzIGFycmF5IG9mIHByb21pc2VzXG4gIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGxhYmVsaW5nIHRoZSBwcm9taXNlLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBhbGwgYHByb21pc2VzYCBoYXZlIGJlZW5cbiAgZnVsZmlsbGVkLCBvciByZWplY3RlZCBpZiBhbnkgb2YgdGhlbSBiZWNvbWUgcmVqZWN0ZWQuXG4gIEBzdGF0aWNcbiovXG5mdW5jdGlvbiBhbGwoZW50cmllcykge1xuICByZXR1cm4gbmV3IEVudW1lcmF0b3IodGhpcywgZW50cmllcykucHJvbWlzZTtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJhY2VgIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaCBpcyBzZXR0bGVkIGluIHRoZSBzYW1lIHdheSBhcyB0aGVcbiAgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gc2V0dGxlLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAyJyk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gcmVzdWx0ID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIGl0IHdhcyByZXNvbHZlZCBiZWZvcmUgcHJvbWlzZTFcbiAgICAvLyB3YXMgcmVzb2x2ZWQuXG4gIH0pO1xuICBgYGBcblxuICBgUHJvbWlzZS5yYWNlYCBpcyBkZXRlcm1pbmlzdGljIGluIHRoYXQgb25seSB0aGUgc3RhdGUgb2YgdGhlIGZpcnN0XG4gIHNldHRsZWQgcHJvbWlzZSBtYXR0ZXJzLiBGb3IgZXhhbXBsZSwgZXZlbiBpZiBvdGhlciBwcm9taXNlcyBnaXZlbiB0byB0aGVcbiAgYHByb21pc2VzYCBhcnJheSBhcmd1bWVudCBhcmUgcmVzb2x2ZWQsIGJ1dCB0aGUgZmlyc3Qgc2V0dGxlZCBwcm9taXNlIGhhc1xuICBiZWNvbWUgcmVqZWN0ZWQgYmVmb3JlIHRoZSBvdGhlciBwcm9taXNlcyBiZWNhbWUgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWRcbiAgcHJvbWlzZSB3aWxsIGJlY29tZSByZWplY3RlZDpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdwcm9taXNlIDInKSk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnNcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBwcm9taXNlIDIgYmVjYW1lIHJlamVjdGVkIGJlZm9yZVxuICAgIC8vIHByb21pc2UgMSBiZWNhbWUgZnVsZmlsbGVkXG4gIH0pO1xuICBgYGBcblxuICBBbiBleGFtcGxlIHJlYWwtd29ybGQgdXNlIGNhc2UgaXMgaW1wbGVtZW50aW5nIHRpbWVvdXRzOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgUHJvbWlzZS5yYWNlKFthamF4KCdmb28uanNvbicpLCB0aW1lb3V0KDUwMDApXSlcbiAgYGBgXG5cbiAgQG1ldGhvZCByYWNlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgdG8gb2JzZXJ2ZVxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB3aGljaCBzZXR0bGVzIGluIHRoZSBzYW1lIHdheSBhcyB0aGUgZmlyc3QgcGFzc2VkXG4gIHByb21pc2UgdG8gc2V0dGxlLlxuKi9cbmZ1bmN0aW9uIHJhY2UoZW50cmllcykge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmICghaXNBcnJheShlbnRyaWVzKSkge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAgYFByb21pc2UucmVqZWN0YCByZXR1cm5zIGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBwYXNzZWQgYHJlYXNvbmAuXG4gIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlamVjdFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSByZWFzb24gdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGguXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuIGByZWFzb25gLlxuKi9cbmZ1bmN0aW9uIHJlamVjdCQxKHJlYXNvbikge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBuZWVkc1Jlc29sdmVyKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG59XG5cbmZ1bmN0aW9uIG5lZWRzTmV3KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xufVxuXG4vKipcbiAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgVGVybWlub2xvZ3lcbiAgLS0tLS0tLS0tLS1cblxuICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICBCYXNpYyBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tXG5cbiAgYGBganNcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBvbiBzdWNjZXNzXG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAvLyBvbiBmYWlsdXJlXG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgQWR2YW5jZWQgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLS0tLVxuXG4gIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgYGBganNcbiAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gIGBgYGpzXG4gIFByb21pc2UuYWxsKFtcbiAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0pO1xuICBgYGBcblxuICBAY2xhc3MgUHJvbWlzZVxuICBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlclxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEBjb25zdHJ1Y3RvclxuKi9cblxudmFyIFByb21pc2UkMSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUHJvbWlzZShyZXNvbHZlcikge1xuICAgIHRoaXNbUFJPTUlTRV9JRF0gPSBuZXh0SWQoKTtcbiAgICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXG4gICAgaWYgKG5vb3AgIT09IHJlc29sdmVyKSB7XG4gICAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbmVlZHNSZXNvbHZlcigpO1xuICAgICAgdGhpcyBpbnN0YW5jZW9mIFByb21pc2UgPyBpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcikgOiBuZWVkc05ldygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICBUaGUgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCxcbiAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgcmVhc29uIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgIC8vIHVzZXIgaXMgYXZhaWxhYmxlXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgfSk7XG4gIGBgYFxuICAgQ2hhaW5pbmdcbiAgLS0tLS0tLS1cbiAgIFRoZSByZXR1cm4gdmFsdWUgb2YgYHRoZW5gIGlzIGl0c2VsZiBhIHByb21pc2UuICBUaGlzIHNlY29uZCwgJ2Rvd25zdHJlYW0nXG4gIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgb3IgcmVqZWN0aW9uIGhhbmRsZXIsIG9yIHJlamVjdGVkIGlmIHRoZSBoYW5kbGVyIHRocm93cyBhbiBleGNlcHRpb24uXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gdXNlci5uYW1lO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuICdkZWZhdWx0IG5hbWUnO1xuICB9KS50aGVuKGZ1bmN0aW9uICh1c2VyTmFtZSkge1xuICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAvLyB3aWxsIGJlIGAnZGVmYXVsdCBuYW1lJ2BcbiAgfSk7XG4gICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICB9KTtcbiAgYGBgXG4gIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdGhyb3cgbmV3IFBlZGFnb2dpY2FsRXhjZXB0aW9uKCdVcHN0cmVhbSBlcnJvcicpO1xuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBUaGUgYFBlZGdhZ29jaWFsRXhjZXB0aW9uYCBpcyBwcm9wYWdhdGVkIGFsbCB0aGUgd2F5IGRvd24gdG8gaGVyZVxuICB9KTtcbiAgYGBgXG4gICBBc3NpbWlsYXRpb25cbiAgLS0tLS0tLS0tLS0tXG4gICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBoYW5kbGVyLiBUaGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgdGhlbiBiZSBwZW5kaW5nXG4gIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgIC8vIFRoZSB1c2VyJ3MgY29tbWVudHMgYXJlIG5vdyBhdmFpbGFibGVcbiAgfSk7XG4gIGBgYFxuICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICB9KTtcbiAgYGBgXG4gICBTaW1wbGUgRXhhbXBsZVxuICAtLS0tLS0tLS0tLS0tLVxuICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICAgYGBgamF2YXNjcmlwdFxuICBsZXQgcmVzdWx0O1xuICAgdHJ5IHtcbiAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgLy8gc3VjY2Vzc1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAgIC8vIGZhaWx1cmVcbiAgfVxuICBgYGBcbiAgIEVycmJhY2sgRXhhbXBsZVxuICAgYGBganNcbiAgZmluZFJlc3VsdChmdW5jdGlvbihyZXN1bHQsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG4gICBQcm9taXNlIEV4YW1wbGU7XG4gICBgYGBqYXZhc2NyaXB0XG4gIGZpbmRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gc3VjY2Vzc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIGZhaWx1cmVcbiAgfSk7XG4gIGBgYFxuICAgQWR2YW5jZWQgRXhhbXBsZVxuICAtLS0tLS0tLS0tLS0tLVxuICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICAgYGBgamF2YXNjcmlwdFxuICBsZXQgYXV0aG9yLCBib29rcztcbiAgIHRyeSB7XG4gICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgLy8gc3VjY2Vzc1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAgIC8vIGZhaWx1cmVcbiAgfVxuICBgYGBcbiAgIEVycmJhY2sgRXhhbXBsZVxuICAgYGBganNcbiAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcbiAgIH1cbiAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG4gICB9XG4gICBmaW5kQXV0aG9yKGZ1bmN0aW9uKGF1dGhvciwgZXJyKXtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBmYWlsdXJlKGVycik7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbmRCb29va3NCeUF1dGhvcihhdXRob3IsIGZ1bmN0aW9uKGJvb2tzLCBlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgICAgICAgZmFpbHVyZShyZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgIH1cbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9XG4gIH0pO1xuICBgYGBcbiAgIFByb21pc2UgRXhhbXBsZTtcbiAgIGBgYGphdmFzY3JpcHRcbiAgZmluZEF1dGhvcigpLlxuICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgIHRoZW4oZnVuY3Rpb24oYm9va3Mpe1xuICAgICAgLy8gZm91bmQgYm9va3NcbiAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9KTtcbiAgYGBgXG4gICBAbWV0aG9kIHRoZW5cbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZFxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cbiAgLyoqXG4gIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgYXMgdGhlIGNhdGNoIGJsb2NrIG9mIGEgdHJ5L2NhdGNoIHN0YXRlbWVudC5cbiAgYGBganNcbiAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcbiAgfVxuICAvLyBzeW5jaHJvbm91c1xuICB0cnkge1xuICBmaW5kQXV0aG9yKCk7XG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH1cbiAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfSk7XG4gIGBgYFxuICBAbWV0aG9kIGNhdGNoXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0aW9uXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuXG4gIFByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAgYGZpbmFsbHlgIHdpbGwgYmUgaW52b2tlZCByZWdhcmRsZXNzIG9mIHRoZSBwcm9taXNlJ3MgZmF0ZSBqdXN0IGFzIG5hdGl2ZVxuICAgIHRyeS9jYXRjaC9maW5hbGx5IGJlaGF2ZXNcbiAgXG4gICAgU3luY2hyb25vdXMgZXhhbXBsZTpcbiAgXG4gICAgYGBganNcbiAgICBmaW5kQXV0aG9yKCkge1xuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEF1dGhvcigpO1xuICAgIH1cbiAgXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmaW5kQXV0aG9yKCk7IC8vIHN1Y2NlZWQgb3IgZmFpbFxuICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gYWx3YXlzIHJ1bnNcbiAgICAgIC8vIGRvZXNuJ3QgYWZmZWN0IHRoZSByZXR1cm4gdmFsdWVcbiAgICB9XG4gICAgYGBgXG4gIFxuICAgIEFzeW5jaHJvbm91cyBleGFtcGxlOlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgcmV0dXJuIGZpbmRPdGhlckF1dGhlcigpO1xuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKXtcbiAgICAgIC8vIGF1dGhvciB3YXMgZWl0aGVyIGZvdW5kLCBvciBub3RcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQG1ldGhvZCBmaW5hbGx5XG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuZmluYWxseSA9IGZ1bmN0aW9uIF9maW5hbGx5KGNhbGxiYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHByb21pc2UuY29uc3RydWN0b3I7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGNhbGxiYWNrLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgcmV0dXJuIFByb21pc2U7XG59KCk7XG5cblByb21pc2UkMS5wcm90b3R5cGUudGhlbiA9IHRoZW47XG5Qcm9taXNlJDEuYWxsID0gYWxsO1xuUHJvbWlzZSQxLnJhY2UgPSByYWNlO1xuUHJvbWlzZSQxLnJlc29sdmUgPSByZXNvbHZlJDE7XG5Qcm9taXNlJDEucmVqZWN0ID0gcmVqZWN0JDE7XG5Qcm9taXNlJDEuX3NldFNjaGVkdWxlciA9IHNldFNjaGVkdWxlcjtcblByb21pc2UkMS5fc2V0QXNhcCA9IHNldEFzYXA7XG5Qcm9taXNlJDEuX2FzYXAgPSBhc2FwO1xuXG4vKmdsb2JhbCBzZWxmKi9cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICB2YXIgbG9jYWwgPSB2b2lkIDA7XG5cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBzZWxmO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgaWYgKFApIHtcbiAgICB2YXIgcHJvbWlzZVRvU3RyaW5nID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzaWxlbnRseSBpZ25vcmVkXG4gICAgfVxuXG4gICAgaWYgKHByb21pc2VUb1N0cmluZyA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBsb2NhbC5Qcm9taXNlID0gUHJvbWlzZSQxO1xufVxuXG4vLyBTdHJhbmdlIGNvbXBhdC4uXG5Qcm9taXNlJDEucG9seWZpbGwgPSBwb2x5ZmlsbDtcblByb21pc2UkMS5Qcm9taXNlID0gUHJvbWlzZSQxO1xuXG5yZXR1cm4gUHJvbWlzZSQxO1xuXG59KSkpO1xuXG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXM2LXByb21pc2UubWFwXG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xudmFyIEF4ZXMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9jYXJ0ZXNpYW4vYXhlcycpO1xuXG52YXIgZHJhdyA9IHJlcXVpcmUoJy4vZHJhdycpLmRyYXc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxjQXV0b3JhbmdlKGdkKSB7XG4gICAgdmFyIGZ1bGxMYXlvdXQgPSBnZC5fZnVsbExheW91dDtcbiAgICB2YXIgYW5ub3RhdGlvbkxpc3QgPSBMaWIuZmlsdGVyVmlzaWJsZShmdWxsTGF5b3V0LmFubm90YXRpb25zKTtcblxuICAgIGlmKGFubm90YXRpb25MaXN0Lmxlbmd0aCAmJiBnZC5fZnVsbERhdGEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBMaWIuc3luY09yQXN5bmMoW2RyYXcsIGFubkF1dG9yYW5nZV0sIGdkKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBhbm5BdXRvcmFuZ2UoZ2QpIHtcbiAgICB2YXIgZnVsbExheW91dCA9IGdkLl9mdWxsTGF5b3V0O1xuXG4gICAgLy8gZmluZCB0aGUgYm91bmRpbmcgYm94ZXMgZm9yIGVhY2ggb2YgdGhlc2UgYW5ub3RhdGlvbnMnXG4gICAgLy8gcmVsYXRpdmUgdG8gdGhlaXIgYW5jaG9yIHBvaW50c1xuICAgIC8vIHVzZSB0aGUgYXJyb3cgYW5kIHRoZSB0ZXh0IGJnIHJlY3RhbmdsZSxcbiAgICAvLyBhcyB0aGUgd2hvbGUgYW5ubyBtYXkgaW5jbHVkZSBoaWRkZW4gdGV4dCBpbiBpdHMgYmJveFxuICAgIExpYi5maWx0ZXJWaXNpYmxlKGZ1bGxMYXlvdXQuYW5ub3RhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24oYW5uKSB7XG4gICAgICAgIHZhciB4YSA9IEF4ZXMuZ2V0RnJvbUlkKGdkLCBhbm4ueHJlZik7XG4gICAgICAgIHZhciB5YSA9IEF4ZXMuZ2V0RnJvbUlkKGdkLCBhbm4ueXJlZik7XG5cbiAgICAgICAgYW5uLl9leHRyZW1lcyA9IHt9O1xuICAgICAgICBpZih4YSkgY2FsY0F4aXNFeHBhbnNpb24oYW5uLCB4YSk7XG4gICAgICAgIGlmKHlhKSBjYWxjQXhpc0V4cGFuc2lvbihhbm4sIHlhKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY2FsY0F4aXNFeHBhbnNpb24oYW5uLCBheCkge1xuICAgIHZhciBheElkID0gYXguX2lkO1xuICAgIHZhciBsZXR0ZXIgPSBheElkLmNoYXJBdCgwKTtcbiAgICB2YXIgcG9zID0gYW5uW2xldHRlcl07XG4gICAgdmFyIGFwb3MgPSBhbm5bJ2EnICsgbGV0dGVyXTtcbiAgICB2YXIgcmVmID0gYW5uW2xldHRlciArICdyZWYnXTtcbiAgICB2YXIgYXJlZiA9IGFublsnYScgKyBsZXR0ZXIgKyAncmVmJ107XG4gICAgdmFyIHBhZHBsdXMgPSBhbm5bJ18nICsgbGV0dGVyICsgJ3BhZHBsdXMnXTtcbiAgICB2YXIgcGFkbWludXMgPSBhbm5bJ18nICsgbGV0dGVyICsgJ3BhZG1pbnVzJ107XG4gICAgdmFyIHNoaWZ0ID0ge3g6IDEsIHk6IC0xfVtsZXR0ZXJdICogYW5uW2xldHRlciArICdzaGlmdCddO1xuICAgIHZhciBoZWFkU2l6ZSA9IDMgKiBhbm4uYXJyb3dzaXplICogYW5uLmFycm93d2lkdGggfHwgMDtcbiAgICB2YXIgaGVhZFBsdXMgPSBoZWFkU2l6ZSArIHNoaWZ0O1xuICAgIHZhciBoZWFkTWludXMgPSBoZWFkU2l6ZSAtIHNoaWZ0O1xuICAgIHZhciBzdGFydEhlYWRTaXplID0gMyAqIGFubi5zdGFydGFycm93c2l6ZSAqIGFubi5hcnJvd3dpZHRoIHx8IDA7XG4gICAgdmFyIHN0YXJ0SGVhZFBsdXMgPSBzdGFydEhlYWRTaXplICsgc2hpZnQ7XG4gICAgdmFyIHN0YXJ0SGVhZE1pbnVzID0gc3RhcnRIZWFkU2l6ZSAtIHNoaWZ0O1xuICAgIHZhciBleHRyZW1lcztcblxuICAgIGlmKGFyZWYgPT09IHJlZikge1xuICAgICAgICAvLyBleHBhbmQgZm9yIHRoZSBhcnJvd2hlYWQgKHBhZGRlZCBieSBhcnJvd2hlYWQpXG4gICAgICAgIHZhciBleHRyZW1lQXJyb3dIZWFkID0gQXhlcy5maW5kRXh0cmVtZXMoYXgsIFtheC5yMmMocG9zKV0sIHtcbiAgICAgICAgICAgIHBwYWRwbHVzOiBoZWFkUGx1cyxcbiAgICAgICAgICAgIHBwYWRtaW51czogaGVhZE1pbnVzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhZ2FpbiBmb3IgdGhlIHRleHRib3ggKHBhZGRlZCBieSB0ZXh0Ym94KVxuICAgICAgICB2YXIgZXh0cmVtZVRleHQgPSBBeGVzLmZpbmRFeHRyZW1lcyhheCwgW2F4LnIyYyhhcG9zKV0sIHtcbiAgICAgICAgICAgIHBwYWRwbHVzOiBNYXRoLm1heChwYWRwbHVzLCBzdGFydEhlYWRQbHVzKSxcbiAgICAgICAgICAgIHBwYWRtaW51czogTWF0aC5tYXgocGFkbWludXMsIHN0YXJ0SGVhZE1pbnVzKVxuICAgICAgICB9KTtcbiAgICAgICAgZXh0cmVtZXMgPSB7XG4gICAgICAgICAgICBtaW46IFtleHRyZW1lQXJyb3dIZWFkLm1pblswXSwgZXh0cmVtZVRleHQubWluWzBdXSxcbiAgICAgICAgICAgIG1heDogW2V4dHJlbWVBcnJvd0hlYWQubWF4WzBdLCBleHRyZW1lVGV4dC5tYXhbMF1dXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRIZWFkUGx1cyA9IGFwb3MgPyBzdGFydEhlYWRQbHVzICsgYXBvcyA6IHN0YXJ0SGVhZFBsdXM7XG4gICAgICAgIHN0YXJ0SGVhZE1pbnVzID0gYXBvcyA/IHN0YXJ0SGVhZE1pbnVzIC0gYXBvcyA6IHN0YXJ0SGVhZE1pbnVzO1xuICAgICAgICBleHRyZW1lcyA9IEF4ZXMuZmluZEV4dHJlbWVzKGF4LCBbYXgucjJjKHBvcyldLCB7XG4gICAgICAgICAgICBwcGFkcGx1czogTWF0aC5tYXgocGFkcGx1cywgaGVhZFBsdXMsIHN0YXJ0SGVhZFBsdXMpLFxuICAgICAgICAgICAgcHBhZG1pbnVzOiBNYXRoLm1heChwYWRtaW51cywgaGVhZE1pbnVzLCBzdGFydEhlYWRNaW51cylcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYW5uLl9leHRyZW1lc1theElkXSA9IGV4dHJlbWVzO1xufVxuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGliID0gcmVxdWlyZSgnLi4vLi4vbGliJyk7XG52YXIgUmVnaXN0cnkgPSByZXF1aXJlKCcuLi8uLi9yZWdpc3RyeScpO1xudmFyIGFycmF5RWRpdG9yID0gcmVxdWlyZSgnLi4vLi4vcGxvdF9hcGkvcGxvdF90ZW1wbGF0ZScpLmFycmF5RWRpdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBoYXNDbGlja1RvU2hvdzogaGFzQ2xpY2tUb1Nob3csXG4gICAgb25DbGljazogb25DbGlja1xufTtcblxuLypcbiAqIGhhc0NsaWNrVG9TaG93OiBkb2VzIHRoZSBnaXZlbiBob3ZlckRhdGEgaGF2ZSBBTlkgYW5ub3RhdGlvbnMgd2hpY2ggd2lsbFxuICogdHVybiBPTiBpZiB3ZSBjbGljayBoZXJlPyAodXNlZCBieSBob3ZlciBldmVudHMgdG8gc2V0IGN1cnNvcilcbiAqXG4gKiBnZDogZ3JhcGhEaXZcbiAqIGhvdmVyRGF0YTogYSBob3ZlckRhdGEgYXJyYXksIGFzIGluY2x1ZGVkIHdpdGggdGhlICpwbG90bHlfaG92ZXIqIG9yXG4gKiAgICAgKnBsb3RseV9jbGljayogZXZlbnRzIGluIHRoZSBgcG9pbnRzYCBhdHRyaWJ1dGVcbiAqXG4gKiByZXR1cm5zOiBib29sZWFuXG4gKi9cbmZ1bmN0aW9uIGhhc0NsaWNrVG9TaG93KGdkLCBob3ZlckRhdGEpIHtcbiAgICB2YXIgc2V0cyA9IGdldFRvZ2dsZVNldHMoZ2QsIGhvdmVyRGF0YSk7XG4gICAgcmV0dXJuIHNldHMub24ubGVuZ3RoID4gMCB8fCBzZXRzLmV4cGxpY2l0T2ZmLmxlbmd0aCA+IDA7XG59XG5cbi8qXG4gKiBvbkNsaWNrOiBwZXJmb3JtIHRoZSB0b2dnbGluZyAodmlhIFBsb3RseS51cGRhdGUpIGltcGxpZWQgYnkgY2xpY2tpbmdcbiAqIGF0IHRoaXMgaG92ZXJEYXRhXG4gKlxuICogZ2Q6IGdyYXBoRGl2XG4gKiBob3ZlckRhdGE6IGEgaG92ZXJEYXRhIGFycmF5LCBhcyBpbmNsdWRlZCB3aXRoIHRoZSAqcGxvdGx5X2hvdmVyKiBvclxuICogICAgICpwbG90bHlfY2xpY2sqIGV2ZW50cyBpbiB0aGUgYHBvaW50c2AgYXR0cmlidXRlXG4gKlxuICogcmV0dXJuczogUHJvbWlzZSB0aGF0IHRoZSB1cGRhdGUgaXMgY29tcGxldGVcbiAqL1xuZnVuY3Rpb24gb25DbGljayhnZCwgaG92ZXJEYXRhKSB7XG4gICAgdmFyIHRvZ2dsZVNldHMgPSBnZXRUb2dnbGVTZXRzKGdkLCBob3ZlckRhdGEpO1xuICAgIHZhciBvblNldCA9IHRvZ2dsZVNldHMub247XG4gICAgdmFyIG9mZlNldCA9IHRvZ2dsZVNldHMub2ZmLmNvbmNhdCh0b2dnbGVTZXRzLmV4cGxpY2l0T2ZmKTtcbiAgICB2YXIgdXBkYXRlID0ge307XG4gICAgdmFyIGFubm90YXRpb25zT3V0ID0gZ2QuX2Z1bGxMYXlvdXQuYW5ub3RhdGlvbnM7XG4gICAgdmFyIGksIGVkaXRIZWxwZXJzO1xuXG4gICAgaWYoIShvblNldC5sZW5ndGggfHwgb2ZmU2V0Lmxlbmd0aCkpIHJldHVybjtcblxuICAgIGZvcihpID0gMDsgaSA8IG9uU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVkaXRIZWxwZXJzID0gYXJyYXlFZGl0b3IoZ2QubGF5b3V0LCAnYW5ub3RhdGlvbnMnLCBhbm5vdGF0aW9uc091dFtvblNldFtpXV0pO1xuICAgICAgICBlZGl0SGVscGVycy5tb2RpZnlJdGVtKCd2aXNpYmxlJywgdHJ1ZSk7XG4gICAgICAgIExpYi5leHRlbmRGbGF0KHVwZGF0ZSwgZWRpdEhlbHBlcnMuZ2V0VXBkYXRlT2JqKCkpO1xuICAgIH1cblxuICAgIGZvcihpID0gMDsgaSA8IG9mZlNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBlZGl0SGVscGVycyA9IGFycmF5RWRpdG9yKGdkLmxheW91dCwgJ2Fubm90YXRpb25zJywgYW5ub3RhdGlvbnNPdXRbb2ZmU2V0W2ldXSk7XG4gICAgICAgIGVkaXRIZWxwZXJzLm1vZGlmeUl0ZW0oJ3Zpc2libGUnLCBmYWxzZSk7XG4gICAgICAgIExpYi5leHRlbmRGbGF0KHVwZGF0ZSwgZWRpdEhlbHBlcnMuZ2V0VXBkYXRlT2JqKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWdpc3RyeS5jYWxsKCd1cGRhdGUnLCBnZCwge30sIHVwZGF0ZSk7XG59XG5cbi8qXG4gKiBnZXRUb2dnbGVTZXRzOiBmaW5kIHRoZSBhbm5vdGF0aW9ucyB3aGljaCB3aWxsIHR1cm4gb24gb3Igb2ZmIGF0IHRoaXNcbiAqIGhvdmVyRGF0YVxuICpcbiAqIGdkOiBncmFwaERpdlxuICogaG92ZXJEYXRhOiBhIGhvdmVyRGF0YSBhcnJheSwgYXMgaW5jbHVkZWQgd2l0aCB0aGUgKnBsb3RseV9ob3Zlciogb3JcbiAqICAgICAqcGxvdGx5X2NsaWNrKiBldmVudHMgaW4gdGhlIGBwb2ludHNgIGF0dHJpYnV0ZVxuICpcbiAqIHJldHVybnM6IHtcbiAqICAgb246IEFycmF5IChpbmRpY2VzIG9mIGFubm90YXRpb25zIHRvIHR1cm4gb24pLFxuICogICBvZmY6IEFycmF5IChpbmRpY2VzIHRvIHR1cm4gb2ZmIGJlY2F1c2UgeW91J3JlIG5vdCBob3ZlcmluZyBvbiB0aGVtKSxcbiAqICAgZXhwbGljaXRPZmY6IEFycmF5IChpbmRpY2VzIHRvIHR1cm4gb2ZmIGJlY2F1c2UgeW91ICphcmUqIGhvdmVyaW5nIG9uIHRoZW0pXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGdldFRvZ2dsZVNldHMoZ2QsIGhvdmVyRGF0YSkge1xuICAgIHZhciBhbm5vdGF0aW9ucyA9IGdkLl9mdWxsTGF5b3V0LmFubm90YXRpb25zO1xuICAgIHZhciBvblNldCA9IFtdO1xuICAgIHZhciBvZmZTZXQgPSBbXTtcbiAgICB2YXIgZXhwbGljaXRPZmZTZXQgPSBbXTtcbiAgICB2YXIgaG92ZXJMZW4gPSAoaG92ZXJEYXRhIHx8IFtdKS5sZW5ndGg7XG5cbiAgICB2YXIgaSwgaiwgYW5uaSwgc2hvd01vZGUsIHBvaW50aiwgeGEsIHlhLCB0b2dnbGVUeXBlO1xuXG4gICAgZm9yKGkgPSAwOyBpIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYW5uaSA9IGFubm90YXRpb25zW2ldO1xuICAgICAgICBzaG93TW9kZSA9IGFubmkuY2xpY2t0b3Nob3c7XG5cbiAgICAgICAgaWYoc2hvd01vZGUpIHtcbiAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IGhvdmVyTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwb2ludGogPSBob3ZlckRhdGFbal07XG4gICAgICAgICAgICAgICAgeGEgPSBwb2ludGoueGF4aXM7XG4gICAgICAgICAgICAgICAgeWEgPSBwb2ludGoueWF4aXM7XG5cbiAgICAgICAgICAgICAgICBpZih4YS5faWQgPT09IGFubmkueHJlZiAmJlxuICAgICAgICAgICAgICAgICAgICB5YS5faWQgPT09IGFubmkueXJlZiAmJlxuICAgICAgICAgICAgICAgICAgICB4YS5kMnIocG9pbnRqLngpID09PSBjbGlja0RhdGEycihhbm5pLl94Y2xpY2ssIHhhKSAmJlxuICAgICAgICAgICAgICAgICAgICB5YS5kMnIocG9pbnRqLnkpID09PSBjbGlja0RhdGEycihhbm5pLl95Y2xpY2ssIHlhKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaCEgdG9nZ2xlIHRoaXMgYW5ub3RhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIGl0cyBjbGlja3Rvc2hvdyBtb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpZiBpdCdzIG9ub3V0IG1vZGUsIG9mZiBpcyBpbXBsaWNpdFxuICAgICAgICAgICAgICAgICAgICBpZihhbm5pLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNob3dNb2RlID09PSAnb25vdXQnKSB0b2dnbGVUeXBlID0gb2ZmU2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB0b2dnbGVUeXBlID0gZXhwbGljaXRPZmZTZXQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVUeXBlID0gb25TZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlVHlwZS5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGogPT09IGhvdmVyTGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbWF0Y2ggLSBvbmx5IHR1cm4gdGhpcyBhbm5vdGF0aW9uIE9GRiwgYW5kIG9ubHkgaWZcbiAgICAgICAgICAgICAgICAvLyBzaG93bW9kZSBpcyAnb25vdXQnXG4gICAgICAgICAgICAgICAgaWYoYW5uaS52aXNpYmxlICYmIHNob3dNb2RlID09PSAnb25vdXQnKSBvZmZTZXQucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7b246IG9uU2V0LCBvZmY6IG9mZlNldCwgZXhwbGljaXRPZmY6IGV4cGxpY2l0T2ZmU2V0fTtcbn1cblxuLy8gdG8gaGFuZGxlIGxvZyBheGVzIHVudGlsIHYyXG5mdW5jdGlvbiBjbGlja0RhdGEycihkLCBheCkge1xuICAgIHJldHVybiBheC50eXBlID09PSAnbG9nJyA/IGF4LmwycihkKSA6IGF4LmQycihkKTtcbn1cbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xudmFyIENvbG9yID0gcmVxdWlyZSgnLi4vY29sb3InKTtcblxuLy8gZGVmYXVsdHMgY29tbW9uIHRvICdhbm5vdGF0aW9ucycgYW5kICdhbm5vdGF0aW9uczNkJ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYW5kbGVBbm5vdGF0aW9uQ29tbW9uRGVmYXVsdHMoYW5uSW4sIGFubk91dCwgZnVsbExheW91dCwgY29lcmNlKSB7XG4gICAgY29lcmNlKCdvcGFjaXR5Jyk7XG4gICAgdmFyIGJnQ29sb3IgPSBjb2VyY2UoJ2JnY29sb3InKTtcblxuICAgIHZhciBib3JkZXJDb2xvciA9IGNvZXJjZSgnYm9yZGVyY29sb3InKTtcbiAgICB2YXIgYm9yZGVyT3BhY2l0eSA9IENvbG9yLm9wYWNpdHkoYm9yZGVyQ29sb3IpO1xuXG4gICAgY29lcmNlKCdib3JkZXJwYWQnKTtcblxuICAgIHZhciBib3JkZXJXaWR0aCA9IGNvZXJjZSgnYm9yZGVyd2lkdGgnKTtcbiAgICB2YXIgc2hvd0Fycm93ID0gY29lcmNlKCdzaG93YXJyb3cnKTtcblxuICAgIGNvZXJjZSgndGV4dCcsIHNob3dBcnJvdyA/ICcgJyA6IGZ1bGxMYXlvdXQuX2RmbHRUaXRsZS5hbm5vdGF0aW9uKTtcbiAgICBjb2VyY2UoJ3RleHRhbmdsZScpO1xuICAgIExpYi5jb2VyY2VGb250KGNvZXJjZSwgJ2ZvbnQnLCBmdWxsTGF5b3V0LmZvbnQpO1xuXG4gICAgY29lcmNlKCd3aWR0aCcpO1xuICAgIGNvZXJjZSgnYWxpZ24nKTtcblxuICAgIHZhciBoID0gY29lcmNlKCdoZWlnaHQnKTtcbiAgICBpZihoKSBjb2VyY2UoJ3ZhbGlnbicpO1xuXG4gICAgaWYoc2hvd0Fycm93KSB7XG4gICAgICAgIHZhciBhcnJvd3NpZGUgPSBjb2VyY2UoJ2Fycm93c2lkZScpO1xuICAgICAgICB2YXIgYXJyb3doZWFkO1xuICAgICAgICB2YXIgYXJyb3dzaXplO1xuXG4gICAgICAgIGlmKGFycm93c2lkZS5pbmRleE9mKCdlbmQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFycm93aGVhZCA9IGNvZXJjZSgnYXJyb3doZWFkJyk7XG4gICAgICAgICAgICBhcnJvd3NpemUgPSBjb2VyY2UoJ2Fycm93c2l6ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYXJyb3dzaWRlLmluZGV4T2YoJ3N0YXJ0JykgIT09IC0xKSB7XG4gICAgICAgICAgICBjb2VyY2UoJ3N0YXJ0YXJyb3doZWFkJywgYXJyb3doZWFkKTtcbiAgICAgICAgICAgIGNvZXJjZSgnc3RhcnRhcnJvd3NpemUnLCBhcnJvd3NpemUpO1xuICAgICAgICB9XG4gICAgICAgIGNvZXJjZSgnYXJyb3djb2xvcicsIGJvcmRlck9wYWNpdHkgPyBhbm5PdXQuYm9yZGVyY29sb3IgOiBDb2xvci5kZWZhdWx0TGluZSk7XG4gICAgICAgIGNvZXJjZSgnYXJyb3d3aWR0aCcsICgoYm9yZGVyT3BhY2l0eSAmJiBib3JkZXJXaWR0aCkgfHwgMSkgKiAyKTtcbiAgICAgICAgY29lcmNlKCdzdGFuZG9mZicpO1xuICAgICAgICBjb2VyY2UoJ3N0YXJ0c3RhbmRvZmYnKTtcbiAgICB9XG5cbiAgICB2YXIgaG92ZXJUZXh0ID0gY29lcmNlKCdob3ZlcnRleHQnKTtcbiAgICB2YXIgZ2xvYmFsSG92ZXJMYWJlbCA9IGZ1bGxMYXlvdXQuaG92ZXJsYWJlbCB8fCB7fTtcblxuICAgIGlmKGhvdmVyVGV4dCkge1xuICAgICAgICB2YXIgaG92ZXJCRyA9IGNvZXJjZSgnaG92ZXJsYWJlbC5iZ2NvbG9yJywgZ2xvYmFsSG92ZXJMYWJlbC5iZ2NvbG9yIHx8XG4gICAgICAgICAgICAoQ29sb3Iub3BhY2l0eShiZ0NvbG9yKSA/IENvbG9yLnJnYihiZ0NvbG9yKSA6IENvbG9yLmRlZmF1bHRMaW5lKVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBob3ZlckJvcmRlciA9IGNvZXJjZSgnaG92ZXJsYWJlbC5ib3JkZXJjb2xvcicsIGdsb2JhbEhvdmVyTGFiZWwuYm9yZGVyY29sb3IgfHxcbiAgICAgICAgICAgIENvbG9yLmNvbnRyYXN0KGhvdmVyQkcpXG4gICAgICAgICk7XG5cbiAgICAgICAgTGliLmNvZXJjZUZvbnQoY29lcmNlLCAnaG92ZXJsYWJlbC5mb250Jywge1xuICAgICAgICAgICAgZmFtaWx5OiBnbG9iYWxIb3ZlckxhYmVsLmZvbnQuZmFtaWx5LFxuICAgICAgICAgICAgc2l6ZTogZ2xvYmFsSG92ZXJMYWJlbC5mb250LnNpemUsXG4gICAgICAgICAgICBjb2xvcjogZ2xvYmFsSG92ZXJMYWJlbC5mb250LmNvbG9yIHx8IGhvdmVyQm9yZGVyXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvZXJjZSgnY2FwdHVyZWV2ZW50cycsICEhaG92ZXJUZXh0KTtcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzTnVtZXJpYyA9IHJlcXVpcmUoJ2Zhc3QtaXNudW1lcmljJyk7XG52YXIgdG9Mb2dSYW5nZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi90b19sb2dfcmFuZ2UnKTtcblxuLypcbiAqIGNvbnZlcnRDb29yZHM6IHdoZW4gY29udmVydGluZyBhbiBheGlzIGJldHdlZW4gbG9nIGFuZCBsaW5lYXJcbiAqIHlvdSBuZWVkIHRvIGFsdGVyIGFueSBhbm5vdGF0aW9ucyBvbiB0aGF0IGF4aXMgdG8ga2VlcCB0aGVtXG4gKiBwb2ludGluZyBhdCB0aGUgc2FtZSBkYXRhIHBvaW50LlxuICogSW4gdjIuMCB0aGlzIHdpbGwgYmVjb21lIG9ic29sZXRlXG4gKlxuICogZ2Q6IHRoZSBwbG90IGRpdlxuICogYXg6IHRoZSBheGlzIGJlaW5nIGNoYW5nZWRcbiAqIG5ld1R5cGU6IHRoZSB0eXBlIGl0J3MgZ2V0dGluZ1xuICogZG9FeHRyYTogZnVuY3Rpb24oYXR0ciwgdmFsKSBmcm9tIGluc2lkZSByZWxheW91dCB0aGF0IHNldHMgdGhlIGF0dHJpYnV0ZS5cbiAqICAgICBVc2UgdGhpcyB0byBtYWtlIHRoZSBjaGFuZ2VzIGFzIGl0J3MgYXdhcmUgaWYgYW55IG90aGVyIGNoYW5nZXMgaW4gdGhlXG4gKiAgICAgc2FtZSByZWxheW91dCBjYWxsIHNob3VsZCBvdmVycmlkZSB0aGlzIGNvbnZlcnNpb24uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29udmVydENvb3JkcyhnZCwgYXgsIG5ld1R5cGUsIGRvRXh0cmEpIHtcbiAgICBheCA9IGF4IHx8IHt9O1xuXG4gICAgdmFyIHRvTG9nID0gKG5ld1R5cGUgPT09ICdsb2cnKSAmJiAoYXgudHlwZSA9PT0gJ2xpbmVhcicpO1xuICAgIHZhciBmcm9tTG9nID0gKG5ld1R5cGUgPT09ICdsaW5lYXInKSAmJiAoYXgudHlwZSA9PT0gJ2xvZycpO1xuXG4gICAgaWYoISh0b0xvZyB8fCBmcm9tTG9nKSkgcmV0dXJuO1xuXG4gICAgdmFyIGFubm90YXRpb25zID0gZ2QuX2Z1bGxMYXlvdXQuYW5ub3RhdGlvbnM7XG4gICAgdmFyIGF4TGV0dGVyID0gYXguX2lkLmNoYXJBdCgwKTtcbiAgICB2YXIgYW5uO1xuICAgIHZhciBhdHRyUHJlZml4O1xuXG4gICAgZnVuY3Rpb24gY29udmVydChhdHRyKSB7XG4gICAgICAgIHZhciBjdXJyZW50VmFsID0gYW5uW2F0dHJdO1xuICAgICAgICB2YXIgbmV3VmFsID0gbnVsbDtcblxuICAgICAgICBpZih0b0xvZykgbmV3VmFsID0gdG9Mb2dSYW5nZShjdXJyZW50VmFsLCBheC5yYW5nZSk7XG4gICAgICAgIGVsc2UgbmV3VmFsID0gTWF0aC5wb3coMTAsIGN1cnJlbnRWYWwpO1xuXG4gICAgICAgIC8vIGlmIGNvbnZlcnNpb24gZmFpbGVkLCBkZWxldGUgdGhlIHZhbHVlIHNvIGl0IGdldHMgYSBkZWZhdWx0IHZhbHVlXG4gICAgICAgIGlmKCFpc051bWVyaWMobmV3VmFsKSkgbmV3VmFsID0gbnVsbDtcblxuICAgICAgICBkb0V4dHJhKGF0dHJQcmVmaXggKyBhdHRyLCBuZXdWYWwpO1xuICAgIH1cblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhbm5vdGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhbm4gPSBhbm5vdGF0aW9uc1tpXTtcbiAgICAgICAgYXR0clByZWZpeCA9ICdhbm5vdGF0aW9uc1snICsgaSArICddLic7XG5cbiAgICAgICAgaWYoYW5uW2F4TGV0dGVyICsgJ3JlZiddID09PSBheC5faWQpIGNvbnZlcnQoYXhMZXR0ZXIpO1xuICAgICAgICBpZihhbm5bJ2EnICsgYXhMZXR0ZXIgKyAncmVmJ10gPT09IGF4Ll9pZCkgY29udmVydCgnYScgKyBheExldHRlcik7XG4gICAgfVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGliID0gcmVxdWlyZSgnLi4vLi4vbGliJyk7XG52YXIgQXhlcyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2NhcnRlc2lhbi9heGVzJyk7XG52YXIgaGFuZGxlQXJyYXlDb250YWluZXJEZWZhdWx0cyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2FycmF5X2NvbnRhaW5lcl9kZWZhdWx0cycpO1xuXG52YXIgaGFuZGxlQW5ub3RhdGlvbkNvbW1vbkRlZmF1bHRzID0gcmVxdWlyZSgnLi9jb21tb25fZGVmYXVsdHMnKTtcbnZhciBhdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdXBwbHlMYXlvdXREZWZhdWx0cyhsYXlvdXRJbiwgbGF5b3V0T3V0KSB7XG4gICAgaGFuZGxlQXJyYXlDb250YWluZXJEZWZhdWx0cyhsYXlvdXRJbiwgbGF5b3V0T3V0LCB7XG4gICAgICAgIG5hbWU6ICdhbm5vdGF0aW9ucycsXG4gICAgICAgIGhhbmRsZUl0ZW1EZWZhdWx0czogaGFuZGxlQW5ub3RhdGlvbkRlZmF1bHRzXG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBoYW5kbGVBbm5vdGF0aW9uRGVmYXVsdHMoYW5uSW4sIGFubk91dCwgZnVsbExheW91dCkge1xuICAgIGZ1bmN0aW9uIGNvZXJjZShhdHRyLCBkZmx0KSB7XG4gICAgICAgIHJldHVybiBMaWIuY29lcmNlKGFubkluLCBhbm5PdXQsIGF0dHJpYnV0ZXMsIGF0dHIsIGRmbHQpO1xuICAgIH1cblxuICAgIHZhciB2aXNpYmxlID0gY29lcmNlKCd2aXNpYmxlJyk7XG4gICAgdmFyIGNsaWNrVG9TaG93ID0gY29lcmNlKCdjbGlja3Rvc2hvdycpO1xuXG4gICAgaWYoISh2aXNpYmxlIHx8IGNsaWNrVG9TaG93KSkgcmV0dXJuO1xuXG4gICAgaGFuZGxlQW5ub3RhdGlvbkNvbW1vbkRlZmF1bHRzKGFubkluLCBhbm5PdXQsIGZ1bGxMYXlvdXQsIGNvZXJjZSk7XG5cbiAgICB2YXIgc2hvd0Fycm93ID0gYW5uT3V0LnNob3dhcnJvdztcblxuICAgIC8vIHBvc2l0aW9uaW5nXG4gICAgdmFyIGF4TGV0dGVycyA9IFsneCcsICd5J107XG4gICAgdmFyIGFycm93UG9zRGZsdCA9IFstMTAsIC0zMF07XG4gICAgdmFyIGdkTW9jayA9IHtfZnVsbExheW91dDogZnVsbExheW91dH07XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgIHZhciBheExldHRlciA9IGF4TGV0dGVyc1tpXTtcblxuICAgICAgICAvLyB4cmVmLCB5cmVmXG4gICAgICAgIHZhciBheFJlZiA9IEF4ZXMuY29lcmNlUmVmKGFubkluLCBhbm5PdXQsIGdkTW9jaywgYXhMZXR0ZXIsICcnLCAncGFwZXInKTtcblxuICAgICAgICBpZihheFJlZiAhPT0gJ3BhcGVyJykge1xuICAgICAgICAgICAgdmFyIGF4ID0gQXhlcy5nZXRGcm9tSWQoZ2RNb2NrLCBheFJlZik7XG4gICAgICAgICAgICBheC5fYW5uSW5kaWNlcy5wdXNoKGFubk91dC5faW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8geCwgeVxuICAgICAgICBBeGVzLmNvZXJjZVBvc2l0aW9uKGFubk91dCwgZ2RNb2NrLCBjb2VyY2UsIGF4UmVmLCBheExldHRlciwgMC41KTtcblxuICAgICAgICBpZihzaG93QXJyb3cpIHtcbiAgICAgICAgICAgIHZhciBhcnJvd1Bvc0F0dHIgPSAnYScgKyBheExldHRlcjtcbiAgICAgICAgICAgIC8vIGF4cmVmLCBheXJlZlxuICAgICAgICAgICAgdmFyIGFheFJlZiA9IEF4ZXMuY29lcmNlUmVmKGFubkluLCBhbm5PdXQsIGdkTW9jaywgYXJyb3dQb3NBdHRyLCAncGl4ZWwnKTtcblxuICAgICAgICAgICAgLy8gZm9yIG5vdyB0aGUgYXJyb3cgY2FuIG9ubHkgYmUgb24gdGhlIHNhbWUgYXhpcyBvciBzcGVjaWZpZWQgYXMgcGl4ZWxzXG4gICAgICAgICAgICAvLyBUT0RPOiBzb21ldGltZSBpdCBtaWdodCBiZSBpbnRlcmVzdGluZyB0byBhbGxvdyBpdCB0byBiZSBvbiAqYW55KiBheGlzXG4gICAgICAgICAgICAvLyBidXQgdGhhdCB3b3VsZCByZXF1aXJlIHVwZGF0ZXMgdG8gZHJhd2luZyAmIGF1dG9yYW5nZSBjb2RlIGFuZCBtYXliZSBtb3JlXG4gICAgICAgICAgICBpZihhYXhSZWYgIT09ICdwaXhlbCcgJiYgYWF4UmVmICE9PSBheFJlZikge1xuICAgICAgICAgICAgICAgIGFheFJlZiA9IGFubk91dFthcnJvd1Bvc0F0dHJdID0gJ3BpeGVsJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYXgsIGF5XG4gICAgICAgICAgICB2YXIgYURmbHQgPSAoYWF4UmVmID09PSAncGl4ZWwnKSA/IGFycm93UG9zRGZsdFtpXSA6IDAuNDtcbiAgICAgICAgICAgIEF4ZXMuY29lcmNlUG9zaXRpb24oYW5uT3V0LCBnZE1vY2ssIGNvZXJjZSwgYWF4UmVmLCBhcnJvd1Bvc0F0dHIsIGFEZmx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHhhbmNob3IsIHlhbmNob3JcbiAgICAgICAgY29lcmNlKGF4TGV0dGVyICsgJ2FuY2hvcicpO1xuXG4gICAgICAgIC8vIHhzaGlmdCwgeXNoaWZ0XG4gICAgICAgIGNvZXJjZShheExldHRlciArICdzaGlmdCcpO1xuICAgIH1cblxuICAgIC8vIGlmIHlvdSBoYXZlIG9uZSBjb29yZGluYXRlIHlvdSBzaG91bGQgaGF2ZSBib3RoXG4gICAgTGliLm5vbmVPckFsbChhbm5JbiwgYW5uT3V0LCBbJ3gnLCAneSddKTtcblxuICAgIC8vIGlmIHlvdSBoYXZlIG9uZSBwYXJ0IG9mIGFycm93IGxlbmd0aCB5b3Ugc2hvdWxkIGhhdmUgYm90aFxuICAgIGlmKHNob3dBcnJvdykge1xuICAgICAgICBMaWIubm9uZU9yQWxsKGFubkluLCBhbm5PdXQsIFsnYXgnLCAnYXknXSk7XG4gICAgfVxuXG4gICAgaWYoY2xpY2tUb1Nob3cpIHtcbiAgICAgICAgdmFyIHhDbGljayA9IGNvZXJjZSgneGNsaWNrJyk7XG4gICAgICAgIHZhciB5Q2xpY2sgPSBjb2VyY2UoJ3ljbGljaycpO1xuXG4gICAgICAgIC8vIHB1dCB0aGUgYWN0dWFsIGNsaWNrIGRhdGEgdG8gYmluZCB0byBpbnRvIHByaXZhdGUgYXR0cmlidXRlc1xuICAgICAgICAvLyBzbyB3ZSBkb24ndCBoYXZlIHRvIGRvIHRoaXMgbGl0dGxlIGJpdCBvZiBsb2dpYyBvbiBldmVyeSBob3ZlciBldmVudFxuICAgICAgICBhbm5PdXQuX3hjbGljayA9ICh4Q2xpY2sgPT09IHVuZGVmaW5lZCkgP1xuICAgICAgICAgICAgYW5uT3V0LnggOlxuICAgICAgICAgICAgQXhlcy5jbGVhblBvc2l0aW9uKHhDbGljaywgZ2RNb2NrLCBhbm5PdXQueHJlZik7XG4gICAgICAgIGFubk91dC5feWNsaWNrID0gKHlDbGljayA9PT0gdW5kZWZpbmVkKSA/XG4gICAgICAgICAgICBhbm5PdXQueSA6XG4gICAgICAgICAgICBBeGVzLmNsZWFuUG9zaXRpb24oeUNsaWNrLCBnZE1vY2ssIGFubk91dC55cmVmKTtcbiAgICB9XG59XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkMyA9IHJlcXVpcmUoJ2QzJyk7XG5cbnZhciBSZWdpc3RyeSA9IHJlcXVpcmUoJy4uLy4uL3JlZ2lzdHJ5Jyk7XG52YXIgUGxvdHMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9wbG90cycpO1xudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xudmFyIEF4ZXMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9jYXJ0ZXNpYW4vYXhlcycpO1xudmFyIENvbG9yID0gcmVxdWlyZSgnLi4vY29sb3InKTtcbnZhciBEcmF3aW5nID0gcmVxdWlyZSgnLi4vZHJhd2luZycpO1xudmFyIEZ4ID0gcmVxdWlyZSgnLi4vZngnKTtcbnZhciBzdmdUZXh0VXRpbHMgPSByZXF1aXJlKCcuLi8uLi9saWIvc3ZnX3RleHRfdXRpbHMnKTtcbnZhciBzZXRDdXJzb3IgPSByZXF1aXJlKCcuLi8uLi9saWIvc2V0Y3Vyc29yJyk7XG52YXIgZHJhZ0VsZW1lbnQgPSByZXF1aXJlKCcuLi9kcmFnZWxlbWVudCcpO1xudmFyIGFycmF5RWRpdG9yID0gcmVxdWlyZSgnLi4vLi4vcGxvdF9hcGkvcGxvdF90ZW1wbGF0ZScpLmFycmF5RWRpdG9yO1xuXG52YXIgZHJhd0Fycm93SGVhZCA9IHJlcXVpcmUoJy4vZHJhd19hcnJvd19oZWFkJyk7XG5cbi8vIEFubm90YXRpb25zIGFyZSBzdG9yZWQgaW4gZ2QubGF5b3V0LmFubm90YXRpb25zLCBhbiBhcnJheSBvZiBvYmplY3RzXG4vLyBpbmRleCBjYW4gcG9pbnQgdG8gb25lIGl0ZW0gaW4gdGhpcyBhcnJheSxcbi8vICBvciBub24tbnVtZXJpYyB0byBzaW1wbHkgYWRkIGEgbmV3IG9uZVxuLy8gIG9yIC0xIHRvIG1vZGlmeSBhbGwgZXhpc3Rpbmdcbi8vIG9wdCBjYW4gYmUgdGhlIGZ1bGwgb3B0aW9ucyBvYmplY3QsIG9yIG9uZSBrZXkgKHRvIGJlIHNldCB0byB2YWx1ZSlcbi8vICBvciB1bmRlZmluZWQgdG8gc2ltcGx5IHJlZHJhd1xuLy8gaWYgb3B0IGlzIGJsYW5rLCB2YWwgY2FuIGJlICdhZGQnIG9yIGEgZnVsbCBvcHRpb25zIG9iamVjdCB0byBhZGQgYSBuZXdcbi8vICBhbm5vdGF0aW9uIGF0IHRoYXQgcG9pbnQgaW4gdGhlIGFycmF5LCBvciAncmVtb3ZlJyB0byBkZWxldGUgdGhpcyBvbmVcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZHJhdzogZHJhdyxcbiAgICBkcmF3T25lOiBkcmF3T25lLFxuICAgIGRyYXdSYXc6IGRyYXdSYXdcbn07XG5cbi8qXG4gKiBkcmF3OiBkcmF3IGFsbCBhbm5vdGF0aW9ucyB3aXRob3V0IGFueSBuZXcgbW9kaWZpY2F0aW9uc1xuICovXG5mdW5jdGlvbiBkcmF3KGdkKSB7XG4gICAgdmFyIGZ1bGxMYXlvdXQgPSBnZC5fZnVsbExheW91dDtcblxuICAgIGZ1bGxMYXlvdXQuX2luZm9sYXllci5zZWxlY3RBbGwoJy5hbm5vdGF0aW9uJykucmVtb3ZlKCk7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZnVsbExheW91dC5hbm5vdGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZihmdWxsTGF5b3V0LmFubm90YXRpb25zW2ldLnZpc2libGUpIHtcbiAgICAgICAgICAgIGRyYXdPbmUoZ2QsIGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFBsb3RzLnByZXZpb3VzUHJvbWlzZXMoZ2QpO1xufVxuXG4vKlxuICogZHJhd09uZTogZHJhdyBhIHNpbmdsZSBjYXJ0ZXNpYW4gb3IgcGFwZXItcmVmIGFubm90YXRpb24sIHBvdGVudGlhbGx5IHdpdGggbW9kaWZpY2F0aW9uc1xuICpcbiAqIGluZGV4IChpbnQpOiB0aGUgYW5ub3RhdGlvbiB0byBkcmF3XG4gKi9cbmZ1bmN0aW9uIGRyYXdPbmUoZ2QsIGluZGV4KSB7XG4gICAgdmFyIGZ1bGxMYXlvdXQgPSBnZC5fZnVsbExheW91dDtcbiAgICB2YXIgb3B0aW9ucyA9IGZ1bGxMYXlvdXQuYW5ub3RhdGlvbnNbaW5kZXhdIHx8IHt9O1xuICAgIHZhciB4YSA9IEF4ZXMuZ2V0RnJvbUlkKGdkLCBvcHRpb25zLnhyZWYpO1xuICAgIHZhciB5YSA9IEF4ZXMuZ2V0RnJvbUlkKGdkLCBvcHRpb25zLnlyZWYpO1xuXG4gICAgaWYoeGEpIHhhLnNldFNjYWxlKCk7XG4gICAgaWYoeWEpIHlhLnNldFNjYWxlKCk7XG5cbiAgICBkcmF3UmF3KGdkLCBvcHRpb25zLCBpbmRleCwgZmFsc2UsIHhhLCB5YSk7XG59XG5cbi8qKlxuICogZHJhd1JhdzogZHJhdyBhIHNpbmdsZSBhbm5vdGF0aW9uLCBwb3RlbnRpYWxseSB3aXRoIG1vZGlmaWNhdGlvbnNcbiAqXG4gKiBAcGFyYW0ge0RPTSBlbGVtZW50fSBnZFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgOiB0aGlzIGFubm90YXRpb24ncyBmdWxsTGF5b3V0IG9wdGlvbnNcbiAqIEBwYXJhbSB7aW50ZWdlcn0gaW5kZXggOiBpbmRleCBpbiAnYW5ub3RhdGlvbnMnIGNvbnRhaW5lciBvZiB0aGUgYW5ub3RhdGlvbiB0byBkcmF3XG4gKiBAcGFyYW0ge3N0cmluZ30gc3VicGxvdElkIDogaWQgb2YgdGhlIGFubm90YXRpb24ncyBzdWJwbG90XG4gKiAgLSB1c2UgZmFsc2UgZm9yIDJkIChpLmUuIGNhcnRlc2lhbiBvciBwYXBlci1yZWYpIGFubm90YXRpb25zXG4gKiBAcGFyYW0ge29iamVjdCB8IHVuZGVmaW5lZH0geGEgOiBmdWxsIHgtYXhpcyBvYmplY3QgdG8gY29tcHV0ZSBzdWJwbG90IHBvcy10by1weFxuICogQHBhcmFtIHtvYmplY3QgfCB1bmRlZmluZWR9IHlhIDogLi4uIHktYXhpc1xuICovXG5mdW5jdGlvbiBkcmF3UmF3KGdkLCBvcHRpb25zLCBpbmRleCwgc3VicGxvdElkLCB4YSwgeWEpIHtcbiAgICB2YXIgZnVsbExheW91dCA9IGdkLl9mdWxsTGF5b3V0O1xuICAgIHZhciBncyA9IGdkLl9mdWxsTGF5b3V0Ll9zaXplO1xuICAgIHZhciBlZGl0cyA9IGdkLl9jb250ZXh0LmVkaXRzO1xuXG4gICAgdmFyIGNsYXNzTmFtZSwgY29udGFpbmVyU3RyO1xuXG4gICAgaWYoc3VicGxvdElkKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9ICdhbm5vdGF0aW9uLScgKyBzdWJwbG90SWQ7XG4gICAgICAgIGNvbnRhaW5lclN0ciA9IHN1YnBsb3RJZCArICcuYW5ub3RhdGlvbnMnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNsYXNzTmFtZSA9ICdhbm5vdGF0aW9uJztcbiAgICAgICAgY29udGFpbmVyU3RyID0gJ2Fubm90YXRpb25zJztcbiAgICB9XG5cbiAgICB2YXIgZWRpdEhlbHBlcnMgPSBhcnJheUVkaXRvcihnZC5sYXlvdXQsIGNvbnRhaW5lclN0ciwgb3B0aW9ucyk7XG4gICAgdmFyIG1vZGlmeUJhc2UgPSBlZGl0SGVscGVycy5tb2RpZnlCYXNlO1xuICAgIHZhciBtb2RpZnlJdGVtID0gZWRpdEhlbHBlcnMubW9kaWZ5SXRlbTtcbiAgICB2YXIgZ2V0VXBkYXRlT2JqID0gZWRpdEhlbHBlcnMuZ2V0VXBkYXRlT2JqO1xuXG4gICAgLy8gcmVtb3ZlIHRoZSBleGlzdGluZyBhbm5vdGF0aW9uIGlmIHRoZXJlIGlzIG9uZVxuICAgIGZ1bGxMYXlvdXQuX2luZm9sYXllclxuICAgICAgICAuc2VsZWN0QWxsKCcuJyArIGNsYXNzTmFtZSArICdbZGF0YS1pbmRleD1cIicgKyBpbmRleCArICdcIl0nKVxuICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICB2YXIgYW5uQ2xpcElEID0gJ2NsaXAnICsgZnVsbExheW91dC5fdWlkICsgJ19hbm4nICsgaW5kZXg7XG5cbiAgICAvLyB0aGlzIGFubm90YXRpb24gaXMgZ29uZSAtIHF1aXQgbm93IGFmdGVyIGRlbGV0aW5nIGl0XG4gICAgLy8gVE9ETzogdXNlIGQzIGlkaW9tcyBpbnN0ZWFkIG9mIGRlbGV0aW5nIGFuZCByZWRyYXdpbmcgZXZlcnkgdGltZVxuICAgIGlmKCFvcHRpb25zLl9pbnB1dCB8fCBvcHRpb25zLnZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgIGQzLnNlbGVjdEFsbCgnIycgKyBhbm5DbGlwSUQpLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlZCBwaXhlbCBwb3NpdGlvbnNcbiAgICAvLyB4ICYgeSBlYWNoIHdpbGwgZ2V0IHRleHQsIGhlYWQsIGFuZCB0YWlsIGFzIGFwcHJvcHJpYXRlXG4gICAgdmFyIGFublBvc1B4ID0ge3g6IHt9LCB5OiB7fX07XG4gICAgdmFyIHRleHRhbmdsZSA9ICtvcHRpb25zLnRleHRhbmdsZSB8fCAwO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBjb21wb25lbnRzXG4gICAgLy8gbWFkZSBhIHNpbmdsZSBncm91cCB0byBjb250YWluIGFsbCwgc28gb3BhY2l0eSBjYW4gd29yayByaWdodFxuICAgIC8vIHdpdGggYm9yZGVyL2Fycm93IHRvZ2V0aGVyIHRoaXMgY291bGQgaGFuZGxlIGEgd2hvbGUgYnVuY2ggb2ZcbiAgICAvLyBjbGVhbnVwIGF0IHRoaXMgcG9pbnQsIGJ1dCB3b3JrcyBmb3Igbm93XG4gICAgdmFyIGFubkdyb3VwID0gZnVsbExheW91dC5faW5mb2xheWVyLmFwcGVuZCgnZycpXG4gICAgICAgIC5jbGFzc2VkKGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgICAgLmF0dHIoJ2RhdGEtaW5kZXgnLCBTdHJpbmcoaW5kZXgpKVxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBvcHRpb25zLm9wYWNpdHkpO1xuXG4gICAgLy8gYW5vdGhlciBncm91cCBmb3IgdGV4dCtiYWNrZ3JvdW5kIHNvIHRoYXQgdGhleSBjYW4gcm90YXRlIHRvZ2V0aGVyXG4gICAgdmFyIGFublRleHRHcm91cCA9IGFubkdyb3VwLmFwcGVuZCgnZycpXG4gICAgICAgIC5jbGFzc2VkKCdhbm5vdGF0aW9uLXRleHQtZycsIHRydWUpO1xuXG4gICAgdmFyIGVkaXRUZXh0UG9zaXRpb24gPSBlZGl0c1tvcHRpb25zLnNob3dhcnJvdyA/ICdhbm5vdGF0aW9uVGFpbCcgOiAnYW5ub3RhdGlvblBvc2l0aW9uJ107XG4gICAgdmFyIHRleHRFdmVudHMgPSBvcHRpb25zLmNhcHR1cmVldmVudHMgfHwgZWRpdHMuYW5ub3RhdGlvblRleHQgfHwgZWRpdFRleHRQb3NpdGlvbjtcblxuICAgIGZ1bmN0aW9uIG1ha2VFdmVudERhdGEoaW5pdGlhbEV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudERhdGEgPSB7XG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICBhbm5vdGF0aW9uOiBvcHRpb25zLl9pbnB1dCxcbiAgICAgICAgICAgIGZ1bGxBbm5vdGF0aW9uOiBvcHRpb25zLFxuICAgICAgICAgICAgZXZlbnQ6IGluaXRpYWxFdmVudFxuICAgICAgICB9O1xuICAgICAgICBpZihzdWJwbG90SWQpIHtcbiAgICAgICAgICAgIGV2ZW50RGF0YS5zdWJwbG90SWQgPSBzdWJwbG90SWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50RGF0YTtcbiAgICB9XG5cbiAgICB2YXIgYW5uVGV4dEdyb3VwSW5uZXIgPSBhbm5UZXh0R3JvdXAuYXBwZW5kKCdnJylcbiAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsIHRleHRFdmVudHMgPyAnYWxsJyA6IG51bGwpXG4gICAgICAgIC5jYWxsKHNldEN1cnNvciwgJ3BvaW50ZXInKVxuICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBnZC5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGdkLmVtaXQoJ3Bsb3RseV9jbGlja2Fubm90YXRpb24nLCBtYWtlRXZlbnREYXRhKGQzLmV2ZW50KSk7XG4gICAgICAgIH0pO1xuXG4gICAgaWYob3B0aW9ucy5ob3ZlcnRleHQpIHtcbiAgICAgICAgYW5uVGV4dEdyb3VwSW5uZXJcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBob3Zlck9wdGlvbnMgPSBvcHRpb25zLmhvdmVybGFiZWw7XG4gICAgICAgICAgICB2YXIgaG92ZXJGb250ID0gaG92ZXJPcHRpb25zLmZvbnQ7XG4gICAgICAgICAgICB2YXIgYkJveCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgYkJveFJlZiA9IGdkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICBGeC5sb25lSG92ZXIoe1xuICAgICAgICAgICAgICAgIHgwOiBiQm94LmxlZnQgLSBiQm94UmVmLmxlZnQsXG4gICAgICAgICAgICAgICAgeDE6IGJCb3gucmlnaHQgLSBiQm94UmVmLmxlZnQsXG4gICAgICAgICAgICAgICAgeTogKGJCb3gudG9wICsgYkJveC5ib3R0b20pIC8gMiAtIGJCb3hSZWYudG9wLFxuICAgICAgICAgICAgICAgIHRleHQ6IG9wdGlvbnMuaG92ZXJ0ZXh0LFxuICAgICAgICAgICAgICAgIGNvbG9yOiBob3Zlck9wdGlvbnMuYmdjb2xvcixcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogaG92ZXJPcHRpb25zLmJvcmRlcmNvbG9yLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IGhvdmVyRm9udC5mYW1pbHksXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IGhvdmVyRm9udC5zaXplLFxuICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogaG92ZXJGb250LmNvbG9yXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiBmdWxsTGF5b3V0Ll9ob3ZlcmxheWVyLm5vZGUoKSxcbiAgICAgICAgICAgICAgICBvdXRlckNvbnRhaW5lcjogZnVsbExheW91dC5fcGFwZXIubm9kZSgpLFxuICAgICAgICAgICAgICAgIGdkOiBnZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEZ4LmxvbmVVbmhvdmVyKGZ1bGxMYXlvdXQuX2hvdmVybGF5ZXIubm9kZSgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGJvcmRlcndpZHRoID0gb3B0aW9ucy5ib3JkZXJ3aWR0aDtcbiAgICB2YXIgYm9yZGVycGFkID0gb3B0aW9ucy5ib3JkZXJwYWQ7XG4gICAgdmFyIGJvcmRlcmZ1bGwgPSBib3JkZXJ3aWR0aCArIGJvcmRlcnBhZDtcblxuICAgIHZhciBhbm5UZXh0QkcgPSBhbm5UZXh0R3JvdXBJbm5lci5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYmcnKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIGJvcmRlcndpZHRoICsgJ3B4JylcbiAgICAgICAgLmNhbGwoQ29sb3Iuc3Ryb2tlLCBvcHRpb25zLmJvcmRlcmNvbG9yKVxuICAgICAgICAuY2FsbChDb2xvci5maWxsLCBvcHRpb25zLmJnY29sb3IpO1xuXG4gICAgdmFyIGlzU2l6ZUNvbnN0cmFpbmVkID0gb3B0aW9ucy53aWR0aCB8fCBvcHRpb25zLmhlaWdodDtcblxuICAgIHZhciBhbm5UZXh0Q2xpcCA9IGZ1bGxMYXlvdXQuX3RvcGNsaXBzXG4gICAgICAgIC5zZWxlY3RBbGwoJyMnICsgYW5uQ2xpcElEKVxuICAgICAgICAuZGF0YShpc1NpemVDb25zdHJhaW5lZCA/IFswXSA6IFtdKTtcblxuICAgIGFublRleHRDbGlwLmVudGVyKCkuYXBwZW5kKCdjbGlwUGF0aCcpXG4gICAgICAgIC5jbGFzc2VkKCdhbm5jbGlwJywgdHJ1ZSlcbiAgICAgICAgLmF0dHIoJ2lkJywgYW5uQ2xpcElEKVxuICAgICAgLmFwcGVuZCgncmVjdCcpO1xuICAgIGFublRleHRDbGlwLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgIHZhciBmb250ID0gb3B0aW9ucy5mb250O1xuXG4gICAgdmFyIHRleHQgPSBmdWxsTGF5b3V0Ll9tZXRhID9cbiAgICAgICAgTGliLnRlbXBsYXRlU3RyaW5nKG9wdGlvbnMudGV4dCwgZnVsbExheW91dC5fbWV0YSkgOlxuICAgICAgICBvcHRpb25zLnRleHQ7XG5cbiAgICB2YXIgYW5uVGV4dCA9IGFublRleHRHcm91cElubmVyLmFwcGVuZCgndGV4dCcpXG4gICAgICAgIC5jbGFzc2VkKCdhbm5vdGF0aW9uLXRleHQnLCB0cnVlKVxuICAgICAgICAudGV4dCh0ZXh0KTtcblxuICAgIGZ1bmN0aW9uIHRleHRMYXlvdXQocykge1xuICAgICAgICBzLmNhbGwoRHJhd2luZy5mb250LCBmb250KVxuICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAndGV4dC1hbmNob3InOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICByaWdodDogJ2VuZCdcbiAgICAgICAgICAgIH1bb3B0aW9ucy5hbGlnbl0gfHwgJ21pZGRsZSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3ZnVGV4dFV0aWxzLmNvbnZlcnRUb1RzcGFucyhzLCBnZCwgZHJhd0dyYXBoaWNhbEVsZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd0dyYXBoaWNhbEVsZW1lbnRzKCkge1xuICAgICAgICAvLyBpZiB0aGUgdGV4dCBoYXMgKm9ubHkqIGEgbGluaywgbWFrZSB0aGUgd2hvbGUgYm94IGludG8gYSBsaW5rXG4gICAgICAgIHZhciBhbmNob3IzID0gYW5uVGV4dC5zZWxlY3RBbGwoJ2EnKTtcbiAgICAgICAgaWYoYW5jaG9yMy5zaXplKCkgPT09IDEgJiYgYW5jaG9yMy50ZXh0KCkgPT09IGFublRleHQudGV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgd2hvbGVMaW5rID0gYW5uVGV4dEdyb3VwSW5uZXIuaW5zZXJ0KCdhJywgJzpmaXJzdC1jaGlsZCcpLmF0dHIoe1xuICAgICAgICAgICAgICAgICd4bGluazp4bGluazpocmVmJzogYW5jaG9yMy5hdHRyKCd4bGluazpocmVmJyksXG4gICAgICAgICAgICAgICAgJ3hsaW5rOnhsaW5rOnNob3cnOiBhbmNob3IzLmF0dHIoJ3hsaW5rOnNob3cnKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZSh7Y3Vyc29yOiAncG9pbnRlcid9KTtcblxuICAgICAgICAgICAgd2hvbGVMaW5rLm5vZGUoKS5hcHBlbmRDaGlsZChhbm5UZXh0Qkcubm9kZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXRoamF4R3JvdXAgPSBhbm5UZXh0R3JvdXBJbm5lci5zZWxlY3QoJy5hbm5vdGF0aW9uLXRleHQtbWF0aC1ncm91cCcpO1xuICAgICAgICB2YXIgaGFzTWF0aGpheCA9ICFtYXRoamF4R3JvdXAuZW1wdHkoKTtcbiAgICAgICAgdmFyIGFubnRleHRCQiA9IERyYXdpbmcuYkJveChcbiAgICAgICAgICAgICAgICAoaGFzTWF0aGpheCA/IG1hdGhqYXhHcm91cCA6IGFublRleHQpLm5vZGUoKSk7XG4gICAgICAgIHZhciB0ZXh0V2lkdGggPSBhbm50ZXh0QkIud2lkdGg7XG4gICAgICAgIHZhciB0ZXh0SGVpZ2h0ID0gYW5udGV4dEJCLmhlaWdodDtcbiAgICAgICAgdmFyIGFubldpZHRoID0gb3B0aW9ucy53aWR0aCB8fCB0ZXh0V2lkdGg7XG4gICAgICAgIHZhciBhbm5IZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCB0ZXh0SGVpZ2h0O1xuICAgICAgICB2YXIgb3V0ZXJXaWR0aCA9IE1hdGgucm91bmQoYW5uV2lkdGggKyAyICogYm9yZGVyZnVsbCk7XG4gICAgICAgIHZhciBvdXRlckhlaWdodCA9IE1hdGgucm91bmQoYW5uSGVpZ2h0ICsgMiAqIGJvcmRlcmZ1bGwpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNoaWZ0RnJhY3Rpb24odiwgYW5jaG9yKSB7XG4gICAgICAgICAgICBpZihhbmNob3IgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgIGlmKHYgPCAxIC8gMykgYW5jaG9yID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYodiA+IDIgLyAzKSBhbmNob3IgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGVsc2UgYW5jaG9yID0gJ2NlbnRlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNlbnRlcjogMCxcbiAgICAgICAgICAgICAgICBtaWRkbGU6IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogMC41LFxuICAgICAgICAgICAgICAgIGJvdHRvbTogLTAuNSxcbiAgICAgICAgICAgICAgICByaWdodDogLTAuNSxcbiAgICAgICAgICAgICAgICB0b3A6IDAuNVxuICAgICAgICAgICAgfVthbmNob3JdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFubm90YXRpb25Jc09mZnNjcmVlbiA9IGZhbHNlO1xuICAgICAgICB2YXIgbGV0dGVycyA9IFsneCcsICd5J107XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxldHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBheExldHRlciA9IGxldHRlcnNbaV07XG4gICAgICAgICAgICB2YXIgYXhSZWYgPSBvcHRpb25zW2F4TGV0dGVyICsgJ3JlZiddIHx8IGF4TGV0dGVyO1xuICAgICAgICAgICAgdmFyIHRhaWxSZWYgPSBvcHRpb25zWydhJyArIGF4TGV0dGVyICsgJ3JlZiddO1xuICAgICAgICAgICAgdmFyIGF4ID0ge3g6IHhhLCB5OiB5YX1bYXhMZXR0ZXJdO1xuICAgICAgICAgICAgdmFyIGRpbUFuZ2xlID0gKHRleHRhbmdsZSArIChheExldHRlciA9PT0gJ3gnID8gMCA6IC05MCkpICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGVzZSB0d28gY2FuIGJlIGVpdGhlciBwb3NpdGl2ZSBvciBuZWdhdGl2ZVxuICAgICAgICAgICAgdmFyIGFublNpemVGcm9tV2lkdGggPSBvdXRlcldpZHRoICogTWF0aC5jb3MoZGltQW5nbGUpO1xuICAgICAgICAgICAgdmFyIGFublNpemVGcm9tSGVpZ2h0ID0gb3V0ZXJIZWlnaHQgKiBNYXRoLnNpbihkaW1BbmdsZSk7XG4gICAgICAgICAgICAvLyBidXQgdGhpcyBvbmUgaXMgdGhlIHBvc2l0aXZlIHRvdGFsIHNpemVcbiAgICAgICAgICAgIHZhciBhbm5TaXplID0gTWF0aC5hYnMoYW5uU2l6ZUZyb21XaWR0aCkgKyBNYXRoLmFicyhhbm5TaXplRnJvbUhlaWdodCk7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gb3B0aW9uc1theExldHRlciArICdhbmNob3InXTtcbiAgICAgICAgICAgIHZhciBvdmVyYWxsU2hpZnQgPSBvcHRpb25zW2F4TGV0dGVyICsgJ3NoaWZ0J10gKiAoYXhMZXR0ZXIgPT09ICd4JyA/IDEgOiAtMSk7XG4gICAgICAgICAgICB2YXIgcG9zUHggPSBhbm5Qb3NQeFtheExldHRlcl07XG4gICAgICAgICAgICB2YXIgYmFzZVB4O1xuICAgICAgICAgICAgdmFyIHRleHRQYWRTaGlmdDtcbiAgICAgICAgICAgIHZhciBhbGlnblBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGF1dG9BbGlnbkZyYWN0aW9uO1xuICAgICAgICAgICAgdmFyIHRleHRTaGlmdDtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGNhbGN1bGF0ZSB0aGUgKnByaW1hcnkqIHBpeGVsIHBvc2l0aW9uXG4gICAgICAgICAgICAgKiB3aGljaCBpcyB0aGUgYXJyb3doZWFkIGlmIHRoZXJlIGlzIG9uZSxcbiAgICAgICAgICAgICAqIG90aGVyd2lzZSB0aGUgdGV4dCBhbmNob3IgcG9pbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYoYXgpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBhbm5vdGF0aW9uIGlzIG9mZiBzY3JlZW4sIHRvIGJ5cGFzcyBET00gbWFuaXB1bGF0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBwb3NGcmFjdGlvbiA9IGF4LnIyZnJhY3Rpb24ob3B0aW9uc1theExldHRlcl0pO1xuICAgICAgICAgICAgICAgIGlmKHBvc0ZyYWN0aW9uIDwgMCB8fCBwb3NGcmFjdGlvbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYodGFpbFJlZiA9PT0gYXhSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc0ZyYWN0aW9uID0gYXgucjJmcmFjdGlvbihvcHRpb25zWydhJyArIGF4TGV0dGVyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwb3NGcmFjdGlvbiA8IDAgfHwgcG9zRnJhY3Rpb24gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbklzT2Zmc2NyZWVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25Jc09mZnNjcmVlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmFzZVB4ID0gYXguX29mZnNldCArIGF4LnIycChvcHRpb25zW2F4TGV0dGVyXSk7XG4gICAgICAgICAgICAgICAgYXV0b0FsaWduRnJhY3Rpb24gPSAwLjU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKGF4TGV0dGVyID09PSAneCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25Qb3NpdGlvbiA9IG9wdGlvbnNbYXhMZXR0ZXJdO1xuICAgICAgICAgICAgICAgICAgICBiYXNlUHggPSBncy5sICsgZ3MudyAqIGFsaWduUG9zaXRpb247XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25Qb3NpdGlvbiA9IDEgLSBvcHRpb25zW2F4TGV0dGVyXTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZVB4ID0gZ3MudCArIGdzLmggKiBhbGlnblBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdXRvQWxpZ25GcmFjdGlvbiA9IG9wdGlvbnMuc2hvd2Fycm93ID8gMC41IDogYWxpZ25Qb3NpdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm93IHRyYW5zbGF0ZSB0aGlzIGludG8gcGl4ZWwgcG9zaXRpb25zIG9mIGhlYWQsIHRhaWwsIGFuZCB0ZXh0XG4gICAgICAgICAgICAvLyBhcyB3ZWxsIGFzIHBhZGRpbmdzIGZvciBhdXRvcmFuZ2VcbiAgICAgICAgICAgIGlmKG9wdGlvbnMuc2hvd2Fycm93KSB7XG4gICAgICAgICAgICAgICAgcG9zUHguaGVhZCA9IGJhc2VQeDtcblxuICAgICAgICAgICAgICAgIHZhciBhcnJvd0xlbmd0aCA9IG9wdGlvbnNbJ2EnICsgYXhMZXR0ZXJdO1xuXG4gICAgICAgICAgICAgICAgLy8gd2l0aCBhbiBhcnJvdywgdGhlIHRleHQgcm90YXRlcyBhcm91bmQgdGhlIGFuY2hvciBwb2ludFxuICAgICAgICAgICAgICAgIHRleHRTaGlmdCA9IGFublNpemVGcm9tV2lkdGggKiBzaGlmdEZyYWN0aW9uKDAuNSwgb3B0aW9ucy54YW5jaG9yKSAtXG4gICAgICAgICAgICAgICAgICAgIGFublNpemVGcm9tSGVpZ2h0ICogc2hpZnRGcmFjdGlvbigwLjUsIG9wdGlvbnMueWFuY2hvcik7XG5cbiAgICAgICAgICAgICAgICBpZih0YWlsUmVmID09PSBheFJlZikge1xuICAgICAgICAgICAgICAgICAgICBwb3NQeC50YWlsID0gYXguX29mZnNldCArIGF4LnIycChhcnJvd0xlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRhaWwgaXMgZGF0YS1yZWZlcmVuY2VkOiBhdXRvcmFuZ2UgcGFkcyB0aGUgdGV4dCBpbiBweCBmcm9tIHRoZSB0YWlsXG4gICAgICAgICAgICAgICAgICAgIHRleHRQYWRTaGlmdCA9IHRleHRTaGlmdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb3NQeC50YWlsID0gYmFzZVB4ICsgYXJyb3dMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRhaWwgaXMgc3BlY2lmaWVkIGluIHB4IGZyb20gaGVhZCwgc28gYXV0b3JhbmdlIGFsc28gcGFkcyB2cyBoZWFkXG4gICAgICAgICAgICAgICAgICAgIHRleHRQYWRTaGlmdCA9IHRleHRTaGlmdCArIGFycm93TGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvc1B4LnRleHQgPSBwb3NQeC50YWlsICsgdGV4dFNoaWZ0O1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc3RyYWluIHBpeGVsL3BhcGVyIHJlZmVyZW5jZWQgc28gdGhlIGRyYWdnZXJzIGFyZSBhdCBsZWFzdFxuICAgICAgICAgICAgICAgIC8vIHBhcnRpYWxseSB2aXNpYmxlXG4gICAgICAgICAgICAgICAgdmFyIG1heFB4ID0gZnVsbExheW91dFsoYXhMZXR0ZXIgPT09ICd4JykgPyAnd2lkdGgnIDogJ2hlaWdodCddO1xuICAgICAgICAgICAgICAgIGlmKGF4UmVmID09PSAncGFwZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc1B4LmhlYWQgPSBMaWIuY29uc3RyYWluKHBvc1B4LmhlYWQsIDEsIG1heFB4IC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHRhaWxSZWYgPT09ICdwaXhlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNoaWZ0UGx1cyA9IC1NYXRoLm1heChwb3NQeC50YWlsIC0gMywgcG9zUHgudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaGlmdE1pbnVzID0gTWF0aC5taW4ocG9zUHgudGFpbCArIDMsIHBvc1B4LnRleHQpIC0gbWF4UHg7XG4gICAgICAgICAgICAgICAgICAgIGlmKHNoaWZ0UGx1cyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc1B4LnRhaWwgKz0gc2hpZnRQbHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zUHgudGV4dCArPSBzaGlmdFBsdXM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihzaGlmdE1pbnVzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zUHgudGFpbCAtPSBzaGlmdE1pbnVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zUHgudGV4dCAtPSBzaGlmdE1pbnVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcG9zUHgudGFpbCArPSBvdmVyYWxsU2hpZnQ7XG4gICAgICAgICAgICAgICAgcG9zUHguaGVhZCArPSBvdmVyYWxsU2hpZnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdpdGggbm8gYXJyb3csIHRoZSB0ZXh0IHJvdGF0ZXMgYW5kICp0aGVuKiB3ZSBwdXQgdGhlIGFuY2hvclxuICAgICAgICAgICAgICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBuZXcgYm91bmRpbmcgYm94XG4gICAgICAgICAgICAgICAgdGV4dFNoaWZ0ID0gYW5uU2l6ZSAqIHNoaWZ0RnJhY3Rpb24oYXV0b0FsaWduRnJhY3Rpb24sIGFuY2hvcik7XG4gICAgICAgICAgICAgICAgdGV4dFBhZFNoaWZ0ID0gdGV4dFNoaWZ0O1xuICAgICAgICAgICAgICAgIHBvc1B4LnRleHQgPSBiYXNlUHggKyB0ZXh0U2hpZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvc1B4LnRleHQgKz0gb3ZlcmFsbFNoaWZ0O1xuICAgICAgICAgICAgdGV4dFNoaWZ0ICs9IG92ZXJhbGxTaGlmdDtcbiAgICAgICAgICAgIHRleHRQYWRTaGlmdCArPSBvdmVyYWxsU2hpZnQ7XG5cbiAgICAgICAgICAgIC8vIHBhZHBsdXMvbWludXMgYXJlIHVzZWQgYnkgYXV0b3JhbmdlXG4gICAgICAgICAgICBvcHRpb25zWydfJyArIGF4TGV0dGVyICsgJ3BhZHBsdXMnXSA9IChhbm5TaXplIC8gMikgKyB0ZXh0UGFkU2hpZnQ7XG4gICAgICAgICAgICBvcHRpb25zWydfJyArIGF4TGV0dGVyICsgJ3BhZG1pbnVzJ10gPSAoYW5uU2l6ZSAvIDIpIC0gdGV4dFBhZFNoaWZ0O1xuXG4gICAgICAgICAgICAvLyBzaXplL3NoaWZ0IGFyZSB1c2VkIGR1cmluZyBkcmFnZ2luZ1xuICAgICAgICAgICAgb3B0aW9uc1snXycgKyBheExldHRlciArICdzaXplJ10gPSBhbm5TaXplO1xuICAgICAgICAgICAgb3B0aW9uc1snXycgKyBheExldHRlciArICdzaGlmdCddID0gdGV4dFNoaWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYW5ub3RhdGlvbklzT2Zmc2NyZWVuKSB7XG4gICAgICAgICAgICBhbm5UZXh0R3JvdXBJbm5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4U2hpZnQgPSAwO1xuICAgICAgICB2YXIgeVNoaWZ0ID0gMDtcblxuICAgICAgICBpZihvcHRpb25zLmFsaWduICE9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIHhTaGlmdCA9IChhbm5XaWR0aCAtIHRleHRXaWR0aCkgKiAob3B0aW9ucy5hbGlnbiA9PT0gJ2NlbnRlcicgPyAwLjUgOiAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZihvcHRpb25zLnZhbGlnbiAhPT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHlTaGlmdCA9IChhbm5IZWlnaHQgLSB0ZXh0SGVpZ2h0KSAqIChvcHRpb25zLnZhbGlnbiA9PT0gJ21pZGRsZScgPyAwLjUgOiAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGhhc01hdGhqYXgpIHtcbiAgICAgICAgICAgIG1hdGhqYXhHcm91cC5zZWxlY3QoJ3N2ZycpLmF0dHIoe1xuICAgICAgICAgICAgICAgIHg6IGJvcmRlcmZ1bGwgKyB4U2hpZnQgLSAxLFxuICAgICAgICAgICAgICAgIHk6IGJvcmRlcmZ1bGwgKyB5U2hpZnRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2FsbChEcmF3aW5nLnNldENsaXBVcmwsIGlzU2l6ZUNvbnN0cmFpbmVkID8gYW5uQ2xpcElEIDogbnVsbCwgZ2QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRleHR5ID0gYm9yZGVyZnVsbCArIHlTaGlmdCAtIGFubnRleHRCQi50b3A7XG4gICAgICAgICAgICB2YXIgdGV4dHggPSBib3JkZXJmdWxsICsgeFNoaWZ0IC0gYW5udGV4dEJCLmxlZnQ7XG5cbiAgICAgICAgICAgIGFublRleHQuY2FsbChzdmdUZXh0VXRpbHMucG9zaXRpb25UZXh0LCB0ZXh0eCwgdGV4dHkpXG4gICAgICAgICAgICAgICAgLmNhbGwoRHJhd2luZy5zZXRDbGlwVXJsLCBpc1NpemVDb25zdHJhaW5lZCA/IGFubkNsaXBJRCA6IG51bGwsIGdkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFublRleHRDbGlwLnNlbGVjdCgncmVjdCcpLmNhbGwoRHJhd2luZy5zZXRSZWN0LCBib3JkZXJmdWxsLCBib3JkZXJmdWxsLFxuICAgICAgICAgICAgYW5uV2lkdGgsIGFubkhlaWdodCk7XG5cbiAgICAgICAgYW5uVGV4dEJHLmNhbGwoRHJhd2luZy5zZXRSZWN0LCBib3JkZXJ3aWR0aCAvIDIsIGJvcmRlcndpZHRoIC8gMixcbiAgICAgICAgICAgIG91dGVyV2lkdGggLSBib3JkZXJ3aWR0aCwgb3V0ZXJIZWlnaHQgLSBib3JkZXJ3aWR0aCk7XG5cbiAgICAgICAgYW5uVGV4dEdyb3VwSW5uZXIuY2FsbChEcmF3aW5nLnNldFRyYW5zbGF0ZSxcbiAgICAgICAgICAgIE1hdGgucm91bmQoYW5uUG9zUHgueC50ZXh0IC0gb3V0ZXJXaWR0aCAvIDIpLFxuICAgICAgICAgICAgTWF0aC5yb3VuZChhbm5Qb3NQeC55LnRleHQgLSBvdXRlckhlaWdodCAvIDIpKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiByb3RhdGUgdGV4dCBhbmQgYmFja2dyb3VuZFxuICAgICAgICAgKiB3ZSBhbHJlYWR5IGNhbGN1bGF0ZWQgdGhlIHRleHQgY2VudGVyIHBvc2l0aW9uICphcyByb3RhdGVkKlxuICAgICAgICAgKiBiZWNhdXNlIHdlIG5lZWRlZCB0aGF0IGZvciBhdXRvcmFuZ2luZyBhbnl3YXksIHNvIG5vdyB3aGV0aGVyXG4gICAgICAgICAqIHdlIGhhdmUgYW4gYXJyb3cgb3Igbm90LCB3ZSByb3RhdGUgYWJvdXQgdGhlIHRleHQgY2VudGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgYW5uVGV4dEdyb3VwLmF0dHIoe3RyYW5zZm9ybTogJ3JvdGF0ZSgnICsgdGV4dGFuZ2xlICsgJywnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5Qb3NQeC54LnRleHQgKyAnLCcgKyBhbm5Qb3NQeC55LnRleHQgKyAnKSd9KTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBhZGQgdGhlIGFycm93XG4gICAgICAgICAqIHVzZXMgb3B0aW9uc1thcnJvd3dpZHRoLGFycm93Y29sb3IsYXJyb3doZWFkXSBmb3Igc3R5bGluZ1xuICAgICAgICAgKiBkeCBhbmQgZHkgYXJlIG5vcm1hbGx5IHplcm8sIGJ1dCB3aGVuIHlvdSBhcmUgZHJhZ2dpbmcgdGhlIHRleHRib3hcbiAgICAgICAgICogd2hpbGUgdGhlIGhlYWQgc3RheXMgcHV0LCBkeCBhbmQgZHkgYXJlIHRoZSBwaXhlbCBvZmZzZXRzXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZHJhd0Fycm93ID0gZnVuY3Rpb24oZHgsIGR5KSB7XG4gICAgICAgICAgICBhbm5Hcm91cFxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJy5hbm5vdGF0aW9uLWFycm93LWcnKVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAgICAgdmFyIGhlYWRYID0gYW5uUG9zUHgueC5oZWFkO1xuICAgICAgICAgICAgdmFyIGhlYWRZID0gYW5uUG9zUHgueS5oZWFkO1xuICAgICAgICAgICAgdmFyIHRhaWxYID0gYW5uUG9zUHgueC50YWlsICsgZHg7XG4gICAgICAgICAgICB2YXIgdGFpbFkgPSBhbm5Qb3NQeC55LnRhaWwgKyBkeTtcbiAgICAgICAgICAgIHZhciB0ZXh0WCA9IGFublBvc1B4LngudGV4dCArIGR4O1xuICAgICAgICAgICAgdmFyIHRleHRZID0gYW5uUG9zUHgueS50ZXh0ICsgZHk7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIGVkZ2Ugb2YgdGhlIHRleHQgYm94LCB3aGVyZSB3ZSdsbCBzdGFydCB0aGUgYXJyb3c6XG4gICAgICAgICAgICAvLyBjcmVhdGUgdHJhbnNmb3JtIG1hdHJpeCB0byByb3RhdGUgdGhlIHRleHQgYm94IGNvcm5lcnNcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBMaWIucm90YXRpb25YWU1hdHJpeCh0ZXh0YW5nbGUsIHRleHRYLCB0ZXh0WSk7XG4gICAgICAgICAgICB2YXIgYXBwbHlUcmFuc2Zvcm0gPSBMaWIuYXBwbHkyRFRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgdmFyIGFwcGx5VHJhbnNmb3JtMiA9IExpYi5hcHBseTJEVHJhbnNmb3JtMih0cmFuc2Zvcm0pO1xuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgYW5kIHRyYW5zZm9ybSBib3VuZGluZyBib3hcbiAgICAgICAgICAgIHZhciB3aWR0aCA9ICthbm5UZXh0QkcuYXR0cignd2lkdGgnKTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSArYW5uVGV4dEJHLmF0dHIoJ2hlaWdodCcpO1xuICAgICAgICAgICAgdmFyIHhMZWZ0ID0gdGV4dFggLSAwLjUgKiB3aWR0aDtcbiAgICAgICAgICAgIHZhciB4UmlnaHQgPSB4TGVmdCArIHdpZHRoO1xuICAgICAgICAgICAgdmFyIHlUb3AgPSB0ZXh0WSAtIDAuNSAqIGhlaWdodDtcbiAgICAgICAgICAgIHZhciB5Qm90dG9tID0geVRvcCArIGhlaWdodDtcbiAgICAgICAgICAgIHZhciBlZGdlcyA9IFtcbiAgICAgICAgICAgICAgICBbeExlZnQsIHlUb3AsIHhMZWZ0LCB5Qm90dG9tXSxcbiAgICAgICAgICAgICAgICBbeExlZnQsIHlCb3R0b20sIHhSaWdodCwgeUJvdHRvbV0sXG4gICAgICAgICAgICAgICAgW3hSaWdodCwgeUJvdHRvbSwgeFJpZ2h0LCB5VG9wXSxcbiAgICAgICAgICAgICAgICBbeFJpZ2h0LCB5VG9wLCB4TGVmdCwgeVRvcF1cbiAgICAgICAgICAgIF0ubWFwKGFwcGx5VHJhbnNmb3JtMik7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGluZSBpZiBpdCBlbmRzIGluc2lkZSB0aGUgYm94LiAgVXNlIHJheVxuICAgICAgICAgICAgLy8gY2FzdGluZyBmb3Igcm90YXRlZCBib3hlczogc2VlIHdoaWNoIGVkZ2VzIGludGVyc2VjdCBhXG4gICAgICAgICAgICAvLyBsaW5lIGZyb20gdGhlIGFycm93aGVhZCB0byBmYXIgYXdheSBhbmQgcmVkdWNlIHdpdGggeG9yXG4gICAgICAgICAgICAvLyB0byBnZXQgdGhlIHBhcml0eSBvZiB0aGUgbnVtYmVyIG9mIGludGVyc2VjdGlvbnMuXG4gICAgICAgICAgICBpZihlZGdlcy5yZWR1Y2UoZnVuY3Rpb24oYSwgeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhIF5cbiAgICAgICAgICAgICAgICAgICAgISFMaWIuc2VnbWVudHNJbnRlcnNlY3QoaGVhZFgsIGhlYWRZLCBoZWFkWCArIDFlNiwgaGVhZFkgKyAxZTYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeFswXSwgeFsxXSwgeFsyXSwgeFszXSk7XG4gICAgICAgICAgICB9LCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBubyBsaW5lIG9yIGFycm93IC0gc28gcXVpdCBkcmF3QXJyb3cgbm93XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IExpYi5zZWdtZW50c0ludGVyc2VjdCh0YWlsWCwgdGFpbFksIGhlYWRYLCBoZWFkWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4WzBdLCB4WzFdLCB4WzJdLCB4WzNdKTtcbiAgICAgICAgICAgICAgICBpZihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhaWxYID0gcC54O1xuICAgICAgICAgICAgICAgICAgICB0YWlsWSA9IHAueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHN0cm9rZXdpZHRoID0gb3B0aW9ucy5hcnJvd3dpZHRoO1xuICAgICAgICAgICAgdmFyIGFycm93Q29sb3IgPSBvcHRpb25zLmFycm93Y29sb3I7XG4gICAgICAgICAgICB2YXIgYXJyb3dTaWRlID0gb3B0aW9ucy5hcnJvd3NpZGU7XG5cbiAgICAgICAgICAgIHZhciBhcnJvd0dyb3VwID0gYW5uR3JvdXAuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoe29wYWNpdHk6IENvbG9yLm9wYWNpdHkoYXJyb3dDb2xvcil9KVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdhbm5vdGF0aW9uLWFycm93LWcnLCB0cnVlKTtcblxuICAgICAgICAgICAgdmFyIGFycm93ID0gYXJyb3dHcm91cC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgJ00nICsgdGFpbFggKyAnLCcgKyB0YWlsWSArICdMJyArIGhlYWRYICsgJywnICsgaGVhZFkpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBzdHJva2V3aWR0aCArICdweCcpXG4gICAgICAgICAgICAgICAgLmNhbGwoQ29sb3Iuc3Ryb2tlLCBDb2xvci5yZ2IoYXJyb3dDb2xvcikpO1xuXG4gICAgICAgICAgICBkcmF3QXJyb3dIZWFkKGFycm93LCBhcnJvd1NpZGUsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyB0aGUgYXJyb3cgZHJhZ2dlciBpcyBhIHNtYWxsIHNxdWFyZSByaWdodCBhdCB0aGUgaGVhZCwgdGhlbiBhIGxpbmUgdG8gdGhlIHRhaWwsXG4gICAgICAgICAgICAvLyBhbGwgZXhwYW5kZWQgYnkgYSBzdHJva2Ugd2lkdGggb2YgNnB4IHBsdXMgdGhlIGFycm93IGxpbmUgd2lkdGhcbiAgICAgICAgICAgIGlmKGVkaXRzLmFubm90YXRpb25Qb3NpdGlvbiAmJiBhcnJvdy5ub2RlKCkucGFyZW50Tm9kZSAmJiAhc3VicGxvdElkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFycm93RHJhZ0hlYWRYID0gaGVhZFg7XG4gICAgICAgICAgICAgICAgdmFyIGFycm93RHJhZ0hlYWRZID0gaGVhZFk7XG4gICAgICAgICAgICAgICAgaWYob3B0aW9ucy5zdGFuZG9mZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyb3dMZW5ndGggPSBNYXRoLnNxcnQoTWF0aC5wb3coaGVhZFggLSB0YWlsWCwgMikgKyBNYXRoLnBvdyhoZWFkWSAtIHRhaWxZLCAyKSk7XG4gICAgICAgICAgICAgICAgICAgIGFycm93RHJhZ0hlYWRYICs9IG9wdGlvbnMuc3RhbmRvZmYgKiAodGFpbFggLSBoZWFkWCkgLyBhcnJvd0xlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYXJyb3dEcmFnSGVhZFkgKz0gb3B0aW9ucy5zdGFuZG9mZiAqICh0YWlsWSAtIGhlYWRZKSAvIGFycm93TGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYXJyb3dEcmFnID0gYXJyb3dHcm91cC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnYW5ub3RhdGlvbi1hcnJvdycsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdhbm5kcmFnJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2N1cnNvci1tb3ZlJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZDogJ00zLDNILTNWLTNIM1pNMCwwTCcgKyAodGFpbFggLSBhcnJvd0RyYWdIZWFkWCkgKyAnLCcgKyAodGFpbFkgLSBhcnJvd0RyYWdIZWFkWSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIGFycm93RHJhZ0hlYWRYICsgJywnICsgYXJyb3dEcmFnSGVhZFkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCAoc3Ryb2tld2lkdGggKyA2KSArICdweCcpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKENvbG9yLnN0cm9rZSwgJ3JnYmEoMCwwLDAsMCknKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChDb2xvci5maWxsLCAncmdiYSgwLDAsMCwwKScpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFubngwLCBhbm55MDtcblxuICAgICAgICAgICAgICAgIC8vIGRyYWdnZXIgZm9yIHRoZSBhcnJvdyAmIGhlYWQ6IHRyYW5zbGF0ZXMgdGhlIHdob2xlIHRoaW5nXG4gICAgICAgICAgICAgICAgLy8gKGhlYWQvdGFpbC90ZXh0KSBhbGwgdG9nZXRoZXJcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudC5pbml0KHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogYXJyb3dEcmFnLm5vZGUoKSxcbiAgICAgICAgICAgICAgICAgICAgZ2Q6IGdkLFxuICAgICAgICAgICAgICAgICAgICBwcmVwRm46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IERyYXdpbmcuZ2V0VHJhbnNsYXRlKGFublRleHRHcm91cElubmVyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ueDAgPSBwb3MueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFubnkwID0gcG9zLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih4YSAmJiB4YS5hdXRvcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZnlCYXNlKHhhLl9uYW1lICsgJy5hdXRvcmFuZ2UnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHlhICYmIHlhLmF1dG9yYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmeUJhc2UoeWEuX25hbWUgKyAnLmF1dG9yYW5nZScsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtb3ZlRm46IGZ1bmN0aW9uKGR4LCBkeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFubnh5MCA9IGFwcGx5VHJhbnNmb3JtKGFubngwLCBhbm55MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeGNlbnRlciA9IGFubnh5MFswXSArIGR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHljZW50ZXIgPSBhbm54eTBbMV0gKyBkeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFublRleHRHcm91cElubmVyLmNhbGwoRHJhd2luZy5zZXRUcmFuc2xhdGUsIHhjZW50ZXIsIHljZW50ZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZnlJdGVtKCd4JywgeGEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhhLnAycih4YS5yMnAob3B0aW9ucy54KSArIGR4KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbnMueCArIChkeCAvIGdzLncpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZnlJdGVtKCd5JywgeWEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlhLnAycih5YS5yMnAob3B0aW9ucy55KSArIGR5KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbnMueSAtIChkeSAvIGdzLmgpKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9wdGlvbnMuYXhyZWYgPT09IG9wdGlvbnMueHJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmeUl0ZW0oJ2F4JywgeGEucDJyKHhhLnIycChvcHRpb25zLmF4KSArIGR4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9wdGlvbnMuYXlyZWYgPT09IG9wdGlvbnMueXJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmeUl0ZW0oJ2F5JywgeWEucDJyKHlhLnIycChvcHRpb25zLmF5KSArIGR5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFycm93R3JvdXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgZHggKyAnLCcgKyBkeSArICcpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5UZXh0R3JvdXAuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAncm90YXRlKCcgKyB0ZXh0YW5nbGUgKyAnLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4Y2VudGVyICsgJywnICsgeWNlbnRlciArICcpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRvbmVGbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWdpc3RyeS5jYWxsKCdfZ3VpUmVsYXlvdXQnLCBnZCwgZ2V0VXBkYXRlT2JqKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdGVzQm94ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmpzLW5vdGVzLWJveC1wYW5lbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobm90ZXNCb3gpIG5vdGVzQm94LnJlZHJhdyhub3Rlc0JveC5zZWxlY3RlZE9iaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZihvcHRpb25zLnNob3dhcnJvdykgZHJhd0Fycm93KDAsIDApO1xuXG4gICAgICAgIC8vIHVzZXIgZHJhZ2dpbmcgdGhlIGFubm90YXRpb24gKHRleHQsIG5vdCBhcnJvdylcbiAgICAgICAgaWYoZWRpdFRleHRQb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIGJhc2VUZXh0VHJhbnNmb3JtO1xuXG4gICAgICAgICAgICAvLyBkcmFnZ2VyIGZvciB0aGUgdGV4dGJveDogaWYgdGhlcmUncyBhbiBhcnJvdywganVzdCBkcmFnIHRoZVxuICAgICAgICAgICAgLy8gdGV4dGJveCBhbmQgdGFpbCwgbGVhdmUgdGhlIGhlYWQgdW50b3VjaGVkXG4gICAgICAgICAgICBkcmFnRWxlbWVudC5pbml0KHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBhbm5UZXh0R3JvdXBJbm5lci5ub2RlKCksXG4gICAgICAgICAgICAgICAgZ2Q6IGdkLFxuICAgICAgICAgICAgICAgIHByZXBGbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VUZXh0VHJhbnNmb3JtID0gYW5uVGV4dEdyb3VwLmF0dHIoJ3RyYW5zZm9ybScpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW92ZUZuOiBmdW5jdGlvbihkeCwgZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICAgICAgaWYob3B0aW9ucy5zaG93YXJyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9wdGlvbnMuYXhyZWYgPT09IG9wdGlvbnMueHJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmeUl0ZW0oJ2F4JywgeGEucDJyKHhhLnIycChvcHRpb25zLmF4KSArIGR4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmeUl0ZW0oJ2F4Jywgb3B0aW9ucy5heCArIGR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYob3B0aW9ucy5heXJlZiA9PT0gb3B0aW9ucy55cmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZ5SXRlbSgnYXknLCB5YS5wMnIoeWEucjJwKG9wdGlvbnMuYXkpICsgZHkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZ5SXRlbSgnYXknLCBvcHRpb25zLmF5ICsgZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3QXJyb3coZHgsIGR5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKCFzdWJwbG90SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4VXBkYXRlLCB5VXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoeGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4VXBkYXRlID0geGEucDJyKHhhLnIycChvcHRpb25zLngpICsgZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGhGcmFjdGlvbiA9IG9wdGlvbnMuX3hzaXplIC8gZ3MudztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeExlZnQgPSBvcHRpb25zLnggKyAob3B0aW9ucy5feHNoaWZ0IC0gb3B0aW9ucy54c2hpZnQpIC8gZ3MudyAtIHdpZHRoRnJhY3Rpb24gLyAyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeFVwZGF0ZSA9IGRyYWdFbGVtZW50LmFsaWduKHhMZWZ0ICsgZHggLyBncy53LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aEZyYWN0aW9uLCAwLCAxLCBvcHRpb25zLnhhbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih5YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlVcGRhdGUgPSB5YS5wMnIoeWEucjJwKG9wdGlvbnMueSkgKyBkeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHRGcmFjdGlvbiA9IG9wdGlvbnMuX3lzaXplIC8gZ3MuaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeUJvdHRvbSA9IG9wdGlvbnMueSAtIChvcHRpb25zLl95c2hpZnQgKyBvcHRpb25zLnlzaGlmdCkgLyBncy5oIC0gaGVpZ2h0RnJhY3Rpb24gLyAyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeVVwZGF0ZSA9IGRyYWdFbGVtZW50LmFsaWduKHlCb3R0b20gLSBkeSAvIGdzLmgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodEZyYWN0aW9uLCAwLCAxLCBvcHRpb25zLnlhbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZ5SXRlbSgneCcsIHhVcGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZ5SXRlbSgneScsIHlVcGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXhhIHx8ICF5YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzciA9IGRyYWdFbGVtZW50LmdldEN1cnNvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGEgPyAwLjUgOiB4VXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5YSA/IDAuNSA6IHlVcGRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMueGFuY2hvciwgb3B0aW9ucy55YW5jaG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBhbm5UZXh0R3JvdXAuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIGR4ICsgJywnICsgZHkgKyAnKScgKyBiYXNlVGV4dFRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJzb3IoYW5uVGV4dEdyb3VwSW5uZXIsIGNzcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGlja0ZuOiBmdW5jdGlvbihfLCBpbml0aWFsRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYob3B0aW9ucy5jYXB0dXJlZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZC5lbWl0KCdwbG90bHlfY2xpY2thbm5vdGF0aW9uJywgbWFrZUV2ZW50RGF0YShpbml0aWFsRXZlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZG9uZUZuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3Vyc29yKGFublRleHRHcm91cElubmVyKTtcbiAgICAgICAgICAgICAgICAgICAgUmVnaXN0cnkuY2FsbCgnX2d1aVJlbGF5b3V0JywgZ2QsIGdldFVwZGF0ZU9iaigpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdGVzQm94ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmpzLW5vdGVzLWJveC1wYW5lbCcpO1xuICAgICAgICAgICAgICAgICAgICBpZihub3Rlc0JveCkgbm90ZXNCb3gucmVkcmF3KG5vdGVzQm94LnNlbGVjdGVkT2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGVkaXRzLmFubm90YXRpb25UZXh0KSB7XG4gICAgICAgIGFublRleHQuY2FsbChzdmdUZXh0VXRpbHMubWFrZUVkaXRhYmxlLCB7ZGVsZWdhdGU6IGFublRleHRHcm91cElubmVyLCBnZDogZ2R9KVxuICAgICAgICAgICAgLmNhbGwodGV4dExheW91dClcbiAgICAgICAgICAgIC5vbignZWRpdCcsIGZ1bmN0aW9uKF90ZXh0KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50ZXh0ID0gX3RleHQ7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNhbGwodGV4dExheW91dCk7XG5cbiAgICAgICAgICAgICAgICBtb2RpZnlJdGVtKCd0ZXh0JywgX3RleHQpO1xuXG4gICAgICAgICAgICAgICAgaWYoeGEgJiYgeGEuYXV0b3JhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmeUJhc2UoeGEuX25hbWUgKyAnLmF1dG9yYW5nZScsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZih5YSAmJiB5YS5hdXRvcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZ5QmFzZSh5YS5fbmFtZSArICcuYXV0b3JhbmdlJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgUmVnaXN0cnkuY2FsbCgnX2d1aVJlbGF5b3V0JywgZ2QsIGdldFVwZGF0ZU9iaigpKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSBhbm5UZXh0LmNhbGwodGV4dExheW91dCk7XG59XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGQzID0gcmVxdWlyZSgnZDMnKTtcblxudmFyIENvbG9yID0gcmVxdWlyZSgnLi4vY29sb3InKTtcblxudmFyIEFSUk9XUEFUSFMgPSByZXF1aXJlKCcuL2Fycm93X3BhdGhzJyk7XG5cbi8qKlxuICogQWRkIGFycm93aGVhZChzKSB0byBhIHBhdGggb3IgbGluZSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IGVsMzogYSBkMy1zZWxlY3RlZCBsaW5lIG9yIHBhdGggZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRzOiAnbm9uZScsICdzdGFydCcsICdlbmQnLCBvciAnc3RhcnQrZW5kJyBmb3Igd2hpY2ggZW5kcyBnZXQgYXJyb3doZWFkc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zOiBzdHlsZSBpbmZvcm1hdGlvbi4gTXVzdCBoYXZlIGFsbCB0aGUgZm9sbG93aW5nOlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuYXJyb3doZWFkOiBlbmQgaGVhZCBzdHlsZSAtIHNlZSAuL2Fycm93X3BhdGhzXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zdGFydGFycm93aGVhZDogc3RhcnQgaGVhZCBzdHlsZSAtIHNlZSAuL2Fycm93X3BhdGhzXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5hcnJvd3NpemU6IHJlbGF0aXZlIHNpemUgb2YgdGhlIGVuZCBoZWFkIHZzIGxpbmUgd2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnN0YXJ0YXJyb3dzaXplOiByZWxhdGl2ZSBzaXplIG9mIHRoZSBzdGFydCBoZWFkIHZzIGxpbmUgd2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnN0YW5kb2ZmOiBkaXN0YW5jZSBpbiBweCB0byBtb3ZlIHRoZSBlbmQgYXJyb3cgcG9pbnQgZnJvbSBpdHMgdGFyZ2V0XG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zdGFydHN0YW5kb2ZmOiBkaXN0YW5jZSBpbiBweCB0byBtb3ZlIHRoZSBzdGFydCBhcnJvdyBwb2ludCBmcm9tIGl0cyB0YXJnZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmFycm93d2lkdGg6IHdpZHRoIG9mIHRoZSBhcnJvdyBsaW5lXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5hcnJvd2NvbG9yOiBjb2xvciBvZiB0aGUgYXJyb3cgbGluZSwgZm9yIHRoZSBoZWFkIHRvIG1hdGNoXG4gKiAgICAgTm90ZSB0aGF0IHRoZSBvcGFjaXR5IG9mIHRoaXMgY29sb3IgaXMgaWdub3JlZCwgYXMgaXQncyBhc3N1bWVkIHRoZSBjb250YWluZXJcbiAqICAgICBvZiBib3RoIHRoZSBsaW5lIGFuZCBoZWFkIGhhcyBvcGFjaXR5IGFwcGxpZWQgdG8gaXQgc28gdGhlcmUgaXNuJ3QgZ3JlYXRlciBvcGFjaXR5XG4gKiAgICAgd2hlcmUgdGhleSBvdmVybGFwLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRyYXdBcnJvd0hlYWQoZWwzLCBlbmRzLCBvcHRpb25zKSB7XG4gICAgdmFyIGVsID0gZWwzLm5vZGUoKTtcbiAgICB2YXIgaGVhZFN0eWxlID0gQVJST1dQQVRIU1tvcHRpb25zLmFycm93aGVhZCB8fCAwXTtcbiAgICB2YXIgc3RhcnRIZWFkU3R5bGUgPSBBUlJPV1BBVEhTW29wdGlvbnMuc3RhcnRhcnJvd2hlYWQgfHwgMF07XG4gICAgdmFyIHNjYWxlID0gKG9wdGlvbnMuYXJyb3d3aWR0aCB8fCAxKSAqIChvcHRpb25zLmFycm93c2l6ZSB8fCAxKTtcbiAgICB2YXIgc3RhcnRTY2FsZSA9IChvcHRpb25zLmFycm93d2lkdGggfHwgMSkgKiAob3B0aW9ucy5zdGFydGFycm93c2l6ZSB8fCAxKTtcbiAgICB2YXIgZG9TdGFydCA9IGVuZHMuaW5kZXhPZignc3RhcnQnKSA+PSAwO1xuICAgIHZhciBkb0VuZCA9IGVuZHMuaW5kZXhPZignZW5kJykgPj0gMDtcbiAgICB2YXIgYmFja09mZiA9IGhlYWRTdHlsZS5iYWNrb2ZmICogc2NhbGUgKyBvcHRpb25zLnN0YW5kb2ZmO1xuICAgIHZhciBzdGFydEJhY2tPZmYgPSBzdGFydEhlYWRTdHlsZS5iYWNrb2ZmICogc3RhcnRTY2FsZSArIG9wdGlvbnMuc3RhcnRzdGFuZG9mZjtcblxuICAgIHZhciBzdGFydCwgZW5kLCBzdGFydFJvdCwgZW5kUm90O1xuXG4gICAgaWYoZWwubm9kZU5hbWUgPT09ICdsaW5lJykge1xuICAgICAgICBzdGFydCA9IHt4OiArZWwzLmF0dHIoJ3gxJyksIHk6ICtlbDMuYXR0cigneTEnKX07XG4gICAgICAgIGVuZCA9IHt4OiArZWwzLmF0dHIoJ3gyJyksIHk6ICtlbDMuYXR0cigneTInKX07XG5cbiAgICAgICAgdmFyIGR4ID0gc3RhcnQueCAtIGVuZC54O1xuICAgICAgICB2YXIgZHkgPSBzdGFydC55IC0gZW5kLnk7XG5cbiAgICAgICAgc3RhcnRSb3QgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgICAgIGVuZFJvdCA9IHN0YXJ0Um90ICsgTWF0aC5QSTtcbiAgICAgICAgaWYoYmFja09mZiAmJiBzdGFydEJhY2tPZmYpIHtcbiAgICAgICAgICAgIGlmKGJhY2tPZmYgKyBzdGFydEJhY2tPZmYgPiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpKSB7XG4gICAgICAgICAgICAgICAgaGlkZUxpbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihiYWNrT2ZmKSB7XG4gICAgICAgICAgICBpZihiYWNrT2ZmICogYmFja09mZiA+IGR4ICogZHggKyBkeSAqIGR5KSB7XG4gICAgICAgICAgICAgICAgaGlkZUxpbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmFja09mZlggPSBiYWNrT2ZmICogTWF0aC5jb3Moc3RhcnRSb3QpO1xuICAgICAgICAgICAgdmFyIGJhY2tPZmZZID0gYmFja09mZiAqIE1hdGguc2luKHN0YXJ0Um90KTtcblxuICAgICAgICAgICAgZW5kLnggKz0gYmFja09mZlg7XG4gICAgICAgICAgICBlbmQueSArPSBiYWNrT2ZmWTtcbiAgICAgICAgICAgIGVsMy5hdHRyKHt4MjogZW5kLngsIHkyOiBlbmQueX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoc3RhcnRCYWNrT2ZmKSB7XG4gICAgICAgICAgICBpZihzdGFydEJhY2tPZmYgKiBzdGFydEJhY2tPZmYgPiBkeCAqIGR4ICsgZHkgKiBkeSkge1xuICAgICAgICAgICAgICAgIGhpZGVMaW5lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXJ0QmFja09mZlggPSBzdGFydEJhY2tPZmYgKiBNYXRoLmNvcyhzdGFydFJvdCk7XG4gICAgICAgICAgICB2YXIgc3RhcnRiYWNrT2ZmWSA9IHN0YXJ0QmFja09mZiAqIE1hdGguc2luKHN0YXJ0Um90KTtcblxuICAgICAgICAgICAgc3RhcnQueCAtPSBzdGFydEJhY2tPZmZYO1xuICAgICAgICAgICAgc3RhcnQueSAtPSBzdGFydGJhY2tPZmZZO1xuICAgICAgICAgICAgZWwzLmF0dHIoe3gxOiBzdGFydC54LCB5MTogc3RhcnQueX0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKGVsLm5vZGVOYW1lID09PSAncGF0aCcpIHtcbiAgICAgICAgdmFyIHBhdGhsZW4gPSBlbC5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICAvLyB1c2luZyBkYXNoIHRvIGhpZGUgdGhlIGJhY2tPZmYgcmVnaW9uIG9mIHRoZSBwYXRoLlxuICAgICAgICAvLyBpZiB3ZSBldmVyIGFsbG93IGRhc2ggZm9yIHRoZSBhcnJvdyB3ZSdsbCBoYXZlIHRvXG4gICAgICAgIC8vIGRvIGJldHRlciB0aGFuIHRoaXMgaGFjay4uLiBtYXliZSBqdXN0IG1hbnVhbGx5XG4gICAgICAgIC8vIGNvbWJpbmUgdGhlIHR3b1xuICAgICAgICB2YXIgZGFzaEFycmF5ID0gJyc7XG5cbiAgICAgICAgaWYocGF0aGxlbiA8IGJhY2tPZmYgKyBzdGFydEJhY2tPZmYpIHtcbiAgICAgICAgICAgIGhpZGVMaW5lKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuXG4gICAgICAgIHZhciBzdGFydDAgPSBlbC5nZXRQb2ludEF0TGVuZ3RoKDApO1xuICAgICAgICB2YXIgZHN0YXJ0ID0gZWwuZ2V0UG9pbnRBdExlbmd0aCgwLjEpO1xuXG4gICAgICAgIHN0YXJ0Um90ID0gTWF0aC5hdGFuMihzdGFydDAueSAtIGRzdGFydC55LCBzdGFydDAueCAtIGRzdGFydC54KTtcbiAgICAgICAgc3RhcnQgPSBlbC5nZXRQb2ludEF0TGVuZ3RoKE1hdGgubWluKHN0YXJ0QmFja09mZiwgcGF0aGxlbikpO1xuXG4gICAgICAgIGRhc2hBcnJheSA9ICcwcHgsJyArIHN0YXJ0QmFja09mZiArICdweCwnO1xuXG4gICAgICAgIHZhciBlbmQwID0gZWwuZ2V0UG9pbnRBdExlbmd0aChwYXRobGVuKTtcbiAgICAgICAgdmFyIGRlbmQgPSBlbC5nZXRQb2ludEF0TGVuZ3RoKHBhdGhsZW4gLSAwLjEpO1xuXG4gICAgICAgIGVuZFJvdCA9IE1hdGguYXRhbjIoZW5kMC55IC0gZGVuZC55LCBlbmQwLnggLSBkZW5kLngpO1xuICAgICAgICBlbmQgPSBlbC5nZXRQb2ludEF0TGVuZ3RoKE1hdGgubWF4KDAsIHBhdGhsZW4gLSBiYWNrT2ZmKSk7XG5cbiAgICAgICAgdmFyIHNob3J0ZW5pbmcgPSBkYXNoQXJyYXkgPyBzdGFydEJhY2tPZmYgKyBiYWNrT2ZmIDogYmFja09mZjtcbiAgICAgICAgZGFzaEFycmF5ICs9IChwYXRobGVuIC0gc2hvcnRlbmluZykgKyAncHgsJyArIHBhdGhsZW4gKyAncHgnO1xuXG4gICAgICAgIGVsMy5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScsIGRhc2hBcnJheSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGlkZUxpbmUoKSB7IGVsMy5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScsICcwcHgsMTAwcHgnKTsgfVxuXG4gICAgZnVuY3Rpb24gZHJhd2hlYWQoYXJyb3dIZWFkU3R5bGUsIHAsIHJvdCwgYXJyb3dTY2FsZSkge1xuICAgICAgICBpZighYXJyb3dIZWFkU3R5bGUucGF0aCkgcmV0dXJuO1xuICAgICAgICBpZihhcnJvd0hlYWRTdHlsZS5ub1JvdGF0ZSkgcm90ID0gMDtcblxuICAgICAgICBkMy5zZWxlY3QoZWwucGFyZW50Tm9kZSkuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiBlbDMuYXR0cignY2xhc3MnKSxcbiAgICAgICAgICAgICAgICBkOiBhcnJvd0hlYWRTdHlsZS5wYXRoLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTpcbiAgICAgICAgICAgICAgICAgICAgJ3RyYW5zbGF0ZSgnICsgcC54ICsgJywnICsgcC55ICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgKHJvdCA/ICdyb3RhdGUoJyArIChyb3QgKiAxODAgLyBNYXRoLlBJKSArICcpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICdzY2FsZSgnICsgYXJyb3dTY2FsZSArICcpJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZSh7XG4gICAgICAgICAgICAgICAgZmlsbDogQ29sb3IucmdiKG9wdGlvbnMuYXJyb3djb2xvciksXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDBcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmKGRvU3RhcnQpIGRyYXdoZWFkKHN0YXJ0SGVhZFN0eWxlLCBzdGFydCwgc3RhcnRSb3QsIHN0YXJ0U2NhbGUpO1xuICAgIGlmKGRvRW5kKSBkcmF3aGVhZChoZWFkU3R5bGUsIGVuZCwgZW5kUm90LCBzY2FsZSk7XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkcmF3TW9kdWxlID0gcmVxdWlyZSgnLi9kcmF3Jyk7XG52YXIgY2xpY2tNb2R1bGUgPSByZXF1aXJlKCcuL2NsaWNrJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1vZHVsZVR5cGU6ICdjb21wb25lbnQnLFxuICAgIG5hbWU6ICdhbm5vdGF0aW9ucycsXG5cbiAgICBsYXlvdXRBdHRyaWJ1dGVzOiByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKSxcbiAgICBzdXBwbHlMYXlvdXREZWZhdWx0czogcmVxdWlyZSgnLi9kZWZhdWx0cycpLFxuICAgIGluY2x1ZGVCYXNlUGxvdDogcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuL2luY2x1ZGVfY29tcG9uZW50cycpKCdhbm5vdGF0aW9ucycpLFxuXG4gICAgY2FsY0F1dG9yYW5nZTogcmVxdWlyZSgnLi9jYWxjX2F1dG9yYW5nZScpLFxuICAgIGRyYXc6IGRyYXdNb2R1bGUuZHJhdyxcbiAgICBkcmF3T25lOiBkcmF3TW9kdWxlLmRyYXdPbmUsXG4gICAgZHJhd1JhdzogZHJhd01vZHVsZS5kcmF3UmF3LFxuXG4gICAgaGFzQ2xpY2tUb1Nob3c6IGNsaWNrTW9kdWxlLmhhc0NsaWNrVG9TaG93LFxuICAgIG9uQ2xpY2s6IGNsaWNrTW9kdWxlLm9uQ2xpY2ssXG5cbiAgICBjb252ZXJ0Q29vcmRzOiByZXF1aXJlKCcuL2NvbnZlcnRfY29vcmRzJylcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFubkF0dHJzID0gcmVxdWlyZSgnLi4vYW5ub3RhdGlvbnMvYXR0cmlidXRlcycpO1xudmFyIG92ZXJyaWRlQWxsID0gcmVxdWlyZSgnLi4vLi4vcGxvdF9hcGkvZWRpdF90eXBlcycpLm92ZXJyaWRlQWxsO1xudmFyIHRlbXBsYXRlZEFycmF5ID0gcmVxdWlyZSgnLi4vLi4vcGxvdF9hcGkvcGxvdF90ZW1wbGF0ZScpLnRlbXBsYXRlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJyaWRlQWxsKHRlbXBsYXRlZEFycmF5KCdhbm5vdGF0aW9uJywge1xuICAgIHZpc2libGU6IGFubkF0dHJzLnZpc2libGUsXG4gICAgeDoge1xuICAgICAgICB2YWxUeXBlOiAnYW55JyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1NldHMgdGhlIGFubm90YXRpb25cXCdzIHggcG9zaXRpb24uJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgeToge1xuICAgICAgICB2YWxUeXBlOiAnYW55JyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1NldHMgdGhlIGFubm90YXRpb25cXCdzIHkgcG9zaXRpb24uJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgejoge1xuICAgICAgICB2YWxUeXBlOiAnYW55JyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1NldHMgdGhlIGFubm90YXRpb25cXCdzIHogcG9zaXRpb24uJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgYXg6IHtcbiAgICAgICAgdmFsVHlwZTogJ251bWJlcicsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSB4IGNvbXBvbmVudCBvZiB0aGUgYXJyb3cgdGFpbCBhYm91dCB0aGUgYXJyb3cgaGVhZCAoaW4gcGl4ZWxzKS4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICBheToge1xuICAgICAgICB2YWxUeXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1NldHMgdGhlIHkgY29tcG9uZW50IG9mIHRoZSBhcnJvdyB0YWlsIGFib3V0IHRoZSBhcnJvdyBoZWFkIChpbiBwaXhlbHMpLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuXG4gICAgeGFuY2hvcjogYW5uQXR0cnMueGFuY2hvcixcbiAgICB4c2hpZnQ6IGFubkF0dHJzLnhzaGlmdCxcbiAgICB5YW5jaG9yOiBhbm5BdHRycy55YW5jaG9yLFxuICAgIHlzaGlmdDogYW5uQXR0cnMueXNoaWZ0LFxuXG4gICAgdGV4dDogYW5uQXR0cnMudGV4dCxcbiAgICB0ZXh0YW5nbGU6IGFubkF0dHJzLnRleHRhbmdsZSxcbiAgICBmb250OiBhbm5BdHRycy5mb250LFxuICAgIHdpZHRoOiBhbm5BdHRycy53aWR0aCxcbiAgICBoZWlnaHQ6IGFubkF0dHJzLmhlaWdodCxcbiAgICBvcGFjaXR5OiBhbm5BdHRycy5vcGFjaXR5LFxuICAgIGFsaWduOiBhbm5BdHRycy5hbGlnbixcbiAgICB2YWxpZ246IGFubkF0dHJzLnZhbGlnbixcbiAgICBiZ2NvbG9yOiBhbm5BdHRycy5iZ2NvbG9yLFxuICAgIGJvcmRlcmNvbG9yOiBhbm5BdHRycy5ib3JkZXJjb2xvcixcbiAgICBib3JkZXJwYWQ6IGFubkF0dHJzLmJvcmRlcnBhZCxcbiAgICBib3JkZXJ3aWR0aDogYW5uQXR0cnMuYm9yZGVyd2lkdGgsXG4gICAgc2hvd2Fycm93OiBhbm5BdHRycy5zaG93YXJyb3csXG4gICAgYXJyb3djb2xvcjogYW5uQXR0cnMuYXJyb3djb2xvcixcbiAgICBhcnJvd2hlYWQ6IGFubkF0dHJzLmFycm93aGVhZCxcbiAgICBzdGFydGFycm93aGVhZDogYW5uQXR0cnMuc3RhcnRhcnJvd2hlYWQsXG4gICAgYXJyb3dzaWRlOiBhbm5BdHRycy5hcnJvd3NpZGUsXG4gICAgYXJyb3dzaXplOiBhbm5BdHRycy5hcnJvd3NpemUsXG4gICAgc3RhcnRhcnJvd3NpemU6IGFubkF0dHJzLnN0YXJ0YXJyb3dzaXplLFxuICAgIGFycm93d2lkdGg6IGFubkF0dHJzLmFycm93d2lkdGgsXG4gICAgc3RhbmRvZmY6IGFubkF0dHJzLnN0YW5kb2ZmLFxuICAgIHN0YXJ0c3RhbmRvZmY6IGFubkF0dHJzLnN0YXJ0c3RhbmRvZmYsXG4gICAgaG92ZXJ0ZXh0OiBhbm5BdHRycy5ob3ZlcnRleHQsXG4gICAgaG92ZXJsYWJlbDogYW5uQXR0cnMuaG92ZXJsYWJlbCxcbiAgICBjYXB0dXJlZXZlbnRzOiBhbm5BdHRycy5jYXB0dXJlZXZlbnRzLFxuXG4gICAgLy8gbWF5YmVzIGxhdGVyP1xuICAgIC8vIGNsaWNrdG9zaG93OiBhbm5BdHRycy5jbGlja3Rvc2hvdyxcbiAgICAvLyB4Y2xpY2s6IGFubkF0dHJzLnhjbGljayxcbiAgICAvLyB5Y2xpY2s6IGFubkF0dHJzLnljbGljayxcblxuICAgIC8vIG5vdCBuZWVkZWQhXG4gICAgLy8gYXhyZWY6ICdwaXhlbCdcbiAgICAvLyBheXJlZjogJ3BpeGVsJ1xuICAgIC8vIHhyZWY6ICd4J1xuICAgIC8vIHlyZWY6ICd5XG4gICAgLy8genJlZjogJ3onXG59KSwgJ2NhbGMnLCAnZnJvbS1yb290Jyk7XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaWIgPSByZXF1aXJlKCcuLi8uLi9saWInKTtcbnZhciBBeGVzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuL2F4ZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb252ZXJ0KHNjZW5lKSB7XG4gICAgdmFyIGZ1bGxTY2VuZUxheW91dCA9IHNjZW5lLmZ1bGxTY2VuZUxheW91dDtcbiAgICB2YXIgYW5ucyA9IGZ1bGxTY2VuZUxheW91dC5hbm5vdGF0aW9ucztcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhbm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1vY2tBbm5BeGVzKGFubnNbaV0sIHNjZW5lKTtcbiAgICB9XG5cbiAgICBzY2VuZS5mdWxsTGF5b3V0Ll9pbmZvbGF5ZXJcbiAgICAgICAgLnNlbGVjdEFsbCgnLmFubm90YXRpb24tJyArIHNjZW5lLmlkKVxuICAgICAgICAucmVtb3ZlKCk7XG59O1xuXG5mdW5jdGlvbiBtb2NrQW5uQXhlcyhhbm4sIHNjZW5lKSB7XG4gICAgdmFyIGZ1bGxTY2VuZUxheW91dCA9IHNjZW5lLmZ1bGxTY2VuZUxheW91dDtcbiAgICB2YXIgZG9tYWluID0gZnVsbFNjZW5lTGF5b3V0LmRvbWFpbjtcbiAgICB2YXIgc2l6ZSA9IHNjZW5lLmZ1bGxMYXlvdXQuX3NpemU7XG5cbiAgICB2YXIgYmFzZSA9IHtcbiAgICAgICAgLy8gdGhpcyBnZXRzIGZpbGwgaW4gb24gcmVuZGVyXG4gICAgICAgIHBkYXRhOiBudWxsLFxuXG4gICAgICAgIC8vIHRvIGdldCBzZXRDb252ZXJ0IHRvIG5vdCBleGVjdXRlIGNsZWFubHlcbiAgICAgICAgdHlwZTogJ2xpbmVhcicsXG5cbiAgICAgICAgLy8gZG9uJ3QgdHJ5IHRvIHVwZGF0ZSB0aGVtIG9uIGBlZGl0YWJsZTogdHJ1ZWBcbiAgICAgICAgYXV0b3JhbmdlOiBmYWxzZSxcblxuICAgICAgICAvLyBzZXQgaW5maW5pdGUgcmFuZ2Ugc28gdGhhdCBhbm5vdGF0aW9uIGRyYXcgcm91dGluZVxuICAgICAgICAvLyBkb2VzIG5vdCB0cnkgdG8gcmVtb3ZlICdvdXRzaWRlLXJhbmdlJyBhbm5vdGF0aW9ucyxcbiAgICAgICAgLy8gdGhpcyBjYXNlIGlzIGhhbmRsZWQgaW4gdGhlIHJlbmRlciBsb29wXG4gICAgICAgIHJhbmdlOiBbLUluZmluaXR5LCBJbmZpbml0eV1cbiAgICB9O1xuXG4gICAgYW5uLl94YSA9IHt9O1xuICAgIExpYi5leHRlbmRGbGF0KGFubi5feGEsIGJhc2UpO1xuICAgIEF4ZXMuc2V0Q29udmVydChhbm4uX3hhKTtcbiAgICBhbm4uX3hhLl9vZmZzZXQgPSBzaXplLmwgKyBkb21haW4ueFswXSAqIHNpemUudztcbiAgICBhbm4uX3hhLmwycCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMC41ICogKDEgKyBhbm4uX3BkYXRhWzBdIC8gYW5uLl9wZGF0YVszXSkgKiBzaXplLncgKiAoZG9tYWluLnhbMV0gLSBkb21haW4ueFswXSk7XG4gICAgfTtcblxuICAgIGFubi5feWEgPSB7fTtcbiAgICBMaWIuZXh0ZW5kRmxhdChhbm4uX3lhLCBiYXNlKTtcbiAgICBBeGVzLnNldENvbnZlcnQoYW5uLl95YSk7XG4gICAgYW5uLl95YS5fb2Zmc2V0ID0gc2l6ZS50ICsgKDEgLSBkb21haW4ueVsxXSkgKiBzaXplLmg7XG4gICAgYW5uLl95YS5sMnAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqICgxIC0gYW5uLl9wZGF0YVsxXSAvIGFubi5fcGRhdGFbM10pICogc2l6ZS5oICogKGRvbWFpbi55WzFdIC0gZG9tYWluLnlbMF0pO1xuICAgIH07XG59XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaWIgPSByZXF1aXJlKCcuLi8uLi9saWInKTtcbnZhciBBeGVzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuL2F4ZXMnKTtcbnZhciBoYW5kbGVBcnJheUNvbnRhaW5lckRlZmF1bHRzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvYXJyYXlfY29udGFpbmVyX2RlZmF1bHRzJyk7XG52YXIgaGFuZGxlQW5ub3RhdGlvbkNvbW1vbkRlZmF1bHRzID0gcmVxdWlyZSgnLi4vYW5ub3RhdGlvbnMvY29tbW9uX2RlZmF1bHRzJyk7XG52YXIgYXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhbmRsZURlZmF1bHRzKHNjZW5lTGF5b3V0SW4sIHNjZW5lTGF5b3V0T3V0LCBvcHRzKSB7XG4gICAgaGFuZGxlQXJyYXlDb250YWluZXJEZWZhdWx0cyhzY2VuZUxheW91dEluLCBzY2VuZUxheW91dE91dCwge1xuICAgICAgICBuYW1lOiAnYW5ub3RhdGlvbnMnLFxuICAgICAgICBoYW5kbGVJdGVtRGVmYXVsdHM6IGhhbmRsZUFubm90YXRpb25EZWZhdWx0cyxcbiAgICAgICAgZnVsbExheW91dDogb3B0cy5mdWxsTGF5b3V0XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBoYW5kbGVBbm5vdGF0aW9uRGVmYXVsdHMoYW5uSW4sIGFubk91dCwgc2NlbmVMYXlvdXQsIG9wdHMpIHtcbiAgICBmdW5jdGlvbiBjb2VyY2UoYXR0ciwgZGZsdCkge1xuICAgICAgICByZXR1cm4gTGliLmNvZXJjZShhbm5JbiwgYW5uT3V0LCBhdHRyaWJ1dGVzLCBhdHRyLCBkZmx0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2VyY2VQb3NpdGlvbihheExldHRlcikge1xuICAgICAgICB2YXIgYXhOYW1lID0gYXhMZXR0ZXIgKyAnYXhpcyc7XG5cbiAgICAgICAgLy8gbW9jayBpbiBzdWNoIHdheSB0aGF0IGdldEZyb21JZCBncmFicyBjb3JyZWN0IDNEIGF4aXNcbiAgICAgICAgdmFyIGdkTW9jayA9IHsgX2Z1bGxMYXlvdXQ6IHt9IH07XG4gICAgICAgIGdkTW9jay5fZnVsbExheW91dFtheE5hbWVdID0gc2NlbmVMYXlvdXRbYXhOYW1lXTtcblxuICAgICAgICByZXR1cm4gQXhlcy5jb2VyY2VQb3NpdGlvbihhbm5PdXQsIGdkTW9jaywgY29lcmNlLCBheExldHRlciwgYXhMZXR0ZXIsIDAuNSk7XG4gICAgfVxuXG5cbiAgICB2YXIgdmlzaWJsZSA9IGNvZXJjZSgndmlzaWJsZScpO1xuICAgIGlmKCF2aXNpYmxlKSByZXR1cm47XG5cbiAgICBoYW5kbGVBbm5vdGF0aW9uQ29tbW9uRGVmYXVsdHMoYW5uSW4sIGFubk91dCwgb3B0cy5mdWxsTGF5b3V0LCBjb2VyY2UpO1xuXG4gICAgY29lcmNlUG9zaXRpb24oJ3gnKTtcbiAgICBjb2VyY2VQb3NpdGlvbigneScpO1xuICAgIGNvZXJjZVBvc2l0aW9uKCd6Jyk7XG5cbiAgICAvLyBpZiB5b3UgaGF2ZSBvbmUgY29vcmRpbmF0ZSB5b3Ugc2hvdWxkIGFsbCB0aHJlZVxuICAgIExpYi5ub25lT3JBbGwoYW5uSW4sIGFubk91dCwgWyd4JywgJ3knLCAneiddKTtcblxuICAgIC8vIGhhcmQtc2V0IGhlcmUgZm9yIGNvbXBsZXRlbmVzc1xuICAgIGFubk91dC54cmVmID0gJ3gnO1xuICAgIGFubk91dC55cmVmID0gJ3knO1xuICAgIGFubk91dC56cmVmID0gJ3onO1xuXG4gICAgY29lcmNlKCd4YW5jaG9yJyk7XG4gICAgY29lcmNlKCd5YW5jaG9yJyk7XG4gICAgY29lcmNlKCd4c2hpZnQnKTtcbiAgICBjb2VyY2UoJ3lzaGlmdCcpO1xuXG4gICAgaWYoYW5uT3V0LnNob3dhcnJvdykge1xuICAgICAgICBhbm5PdXQuYXhyZWYgPSAncGl4ZWwnO1xuICAgICAgICBhbm5PdXQuYXlyZWYgPSAncGl4ZWwnO1xuXG4gICAgICAgIC8vIFRPRE8gbWF5YmUgZGVmYXVsdCB2YWx1ZXMgc2hvdWxkIGJlIGJpZ2dlciB0aGFuIHRoZSAyRCBjYXNlP1xuICAgICAgICBjb2VyY2UoJ2F4JywgLTEwKTtcbiAgICAgICAgY29lcmNlKCdheScsIC0zMCk7XG5cbiAgICAgICAgLy8gaWYgeW91IGhhdmUgb25lIHBhcnQgb2YgYXJyb3cgbGVuZ3RoIHlvdSBzaG91bGQgaGF2ZSBib3RoXG4gICAgICAgIExpYi5ub25lT3JBbGwoYW5uSW4sIGFubk91dCwgWydheCcsICdheSddKTtcbiAgICB9XG59XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkcmF3UmF3ID0gcmVxdWlyZSgnLi4vYW5ub3RhdGlvbnMvZHJhdycpLmRyYXdSYXc7XG52YXIgcHJvamVjdCA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2dsM2QvcHJvamVjdCcpO1xudmFyIGF4TGV0dGVycyA9IFsneCcsICd5JywgJ3onXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkcmF3KHNjZW5lKSB7XG4gICAgdmFyIGZ1bGxTY2VuZUxheW91dCA9IHNjZW5lLmZ1bGxTY2VuZUxheW91dDtcbiAgICB2YXIgZGF0YVNjYWxlID0gc2NlbmUuZGF0YVNjYWxlO1xuICAgIHZhciBhbm5zID0gZnVsbFNjZW5lTGF5b3V0LmFubm90YXRpb25zO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGFubnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFubiA9IGFubnNbaV07XG4gICAgICAgIHZhciBhbm5vdGF0aW9uSXNPZmZzY3JlZW4gPSBmYWxzZTtcblxuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgICAgICB2YXIgYXhMZXR0ZXIgPSBheExldHRlcnNbal07XG4gICAgICAgICAgICB2YXIgcG9zID0gYW5uW2F4TGV0dGVyXTtcbiAgICAgICAgICAgIHZhciBheCA9IGZ1bGxTY2VuZUxheW91dFtheExldHRlciArICdheGlzJ107XG4gICAgICAgICAgICB2YXIgcG9zRnJhY3Rpb24gPSBheC5yMmZyYWN0aW9uKHBvcyk7XG5cbiAgICAgICAgICAgIGlmKHBvc0ZyYWN0aW9uIDwgMCB8fCBwb3NGcmFjdGlvbiA+IDEpIHtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uSXNPZmZzY3JlZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoYW5ub3RhdGlvbklzT2Zmc2NyZWVuKSB7XG4gICAgICAgICAgICBzY2VuZS5mdWxsTGF5b3V0Ll9pbmZvbGF5ZXJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcuYW5ub3RhdGlvbi0nICsgc2NlbmUuaWQgKyAnW2RhdGEtaW5kZXg9XCInICsgaSArICdcIl0nKVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFubi5fcGRhdGEgPSBwcm9qZWN0KHNjZW5lLmdscGxvdC5jYW1lcmFQYXJhbXMsIFtcbiAgICAgICAgICAgICAgICBmdWxsU2NlbmVMYXlvdXQueGF4aXMucjJsKGFubi54KSAqIGRhdGFTY2FsZVswXSxcbiAgICAgICAgICAgICAgICBmdWxsU2NlbmVMYXlvdXQueWF4aXMucjJsKGFubi55KSAqIGRhdGFTY2FsZVsxXSxcbiAgICAgICAgICAgICAgICBmdWxsU2NlbmVMYXlvdXQuemF4aXMucjJsKGFubi56KSAqIGRhdGFTY2FsZVsyXVxuICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgIGRyYXdSYXcoc2NlbmUuZ3JhcGhEaXYsIGFubiwgaSwgc2NlbmUuaWQsIGFubi5feGEsIGFubi5feWEpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi4vLi4vcmVnaXN0cnknKTtcbnZhciBMaWIgPSByZXF1aXJlKCcuLi8uLi9saWInKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbW9kdWxlVHlwZTogJ2NvbXBvbmVudCcsXG4gICAgbmFtZTogJ2Fubm90YXRpb25zM2QnLFxuXG4gICAgc2NoZW1hOiB7XG4gICAgICAgIHN1YnBsb3RzOiB7XG4gICAgICAgICAgICBzY2VuZToge2Fubm90YXRpb25zOiByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKX1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBsYXlvdXRBdHRyaWJ1dGVzOiByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKSxcbiAgICBoYW5kbGVEZWZhdWx0czogcmVxdWlyZSgnLi9kZWZhdWx0cycpLFxuICAgIGluY2x1ZGVCYXNlUGxvdDogaW5jbHVkZUdMM0QsXG5cbiAgICBjb252ZXJ0OiByZXF1aXJlKCcuL2NvbnZlcnQnKSxcbiAgICBkcmF3OiByZXF1aXJlKCcuL2RyYXcnKVxufTtcblxuZnVuY3Rpb24gaW5jbHVkZUdMM0QobGF5b3V0SW4sIGxheW91dE91dCkge1xuICAgIHZhciBHTDNEID0gUmVnaXN0cnkuc3VicGxvdHNSZWdpc3RyeS5nbDNkO1xuICAgIGlmKCFHTDNEKSByZXR1cm47XG5cbiAgICB2YXIgYXR0clJlZ2V4ID0gR0wzRC5hdHRyUmVnZXg7XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGxheW91dEluKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbaV07XG4gICAgICAgIGlmKGF0dHJSZWdleC50ZXN0KGspICYmIChsYXlvdXRJbltrXS5hbm5vdGF0aW9ucyB8fCBbXSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBMaWIucHVzaFVuaXF1ZShsYXlvdXRPdXQuX2Jhc2VQbG90TW9kdWxlcywgR0wzRCk7XG4gICAgICAgICAgICBMaWIucHVzaFVuaXF1ZShsYXlvdXRPdXQuX3N1YnBsb3RzLmdsM2QsIGspO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjbjoge1xuICAgICAgICBjb2xvcmJhcjogJ2NvbG9yYmFyJyxcbiAgICAgICAgY2JiZzogJ2NiYmcnLFxuICAgICAgICBjYmZpbGw6ICdjYmZpbGwnLFxuICAgICAgICBjYmZpbGxzOiAnY2JmaWxscycsXG4gICAgICAgIGNibGluZTogJ2NibGluZScsXG4gICAgICAgIGNibGluZXM6ICdjYmxpbmVzJyxcbiAgICAgICAgY2JheGlzOiAnY2JheGlzJyxcbiAgICAgICAgY2J0aXRsZXVuc2hpZnQ6ICdjYnRpdGxldW5zaGlmdCcsXG4gICAgICAgIGNidGl0bGU6ICdjYnRpdGxlJyxcbiAgICAgICAgY2JvdXRsaW5lOiAnY2JvdXRsaW5lJyxcbiAgICAgICAgY3Jpc3A6ICdjcmlzcCcsXG4gICAgICAgIGpzUGxhY2Vob2xkZXI6ICdqcy1wbGFjZWhvbGRlcidcbiAgICB9XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZDMgPSByZXF1aXJlKCdkMycpO1xudmFyIHRpbnljb2xvciA9IHJlcXVpcmUoJ3Rpbnljb2xvcjInKTtcblxudmFyIFBsb3RzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvcGxvdHMnKTtcbnZhciBSZWdpc3RyeSA9IHJlcXVpcmUoJy4uLy4uL3JlZ2lzdHJ5Jyk7XG52YXIgQXhlcyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2NhcnRlc2lhbi9heGVzJyk7XG52YXIgZHJhZ0VsZW1lbnQgPSByZXF1aXJlKCcuLi9kcmFnZWxlbWVudCcpO1xudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xudmFyIGV4dGVuZEZsYXQgPSByZXF1aXJlKCcuLi8uLi9saWIvZXh0ZW5kJykuZXh0ZW5kRmxhdDtcbnZhciBzZXRDdXJzb3IgPSByZXF1aXJlKCcuLi8uLi9saWIvc2V0Y3Vyc29yJyk7XG52YXIgRHJhd2luZyA9IHJlcXVpcmUoJy4uL2RyYXdpbmcnKTtcbnZhciBDb2xvciA9IHJlcXVpcmUoJy4uL2NvbG9yJyk7XG52YXIgVGl0bGVzID0gcmVxdWlyZSgnLi4vdGl0bGVzJyk7XG52YXIgc3ZnVGV4dFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vbGliL3N2Z190ZXh0X3V0aWxzJyk7XG52YXIgZmxpcFNjYWxlID0gcmVxdWlyZSgnLi4vY29sb3JzY2FsZS9oZWxwZXJzJykuZmxpcFNjYWxlO1xuXG52YXIgaGFuZGxlQXhpc0RlZmF1bHRzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuL2F4aXNfZGVmYXVsdHMnKTtcbnZhciBoYW5kbGVBeGlzUG9zaXRpb25EZWZhdWx0cyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2NhcnRlc2lhbi9wb3NpdGlvbl9kZWZhdWx0cycpO1xudmFyIGF4aXNMYXlvdXRBdHRycyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2NhcnRlc2lhbi9sYXlvdXRfYXR0cmlidXRlcycpO1xuXG52YXIgYWxpZ25tZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi4vLi4vY29uc3RhbnRzL2FsaWdubWVudCcpO1xudmFyIExJTkVfU1BBQ0lORyA9IGFsaWdubWVudENvbnN0YW50cy5MSU5FX1NQQUNJTkc7XG52YXIgRlJPTV9UTCA9IGFsaWdubWVudENvbnN0YW50cy5GUk9NX1RMO1xudmFyIEZST01fQlIgPSBhbGlnbm1lbnRDb25zdGFudHMuRlJPTV9CUjtcblxudmFyIGNuID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKS5jbjtcblxuZnVuY3Rpb24gZHJhdyhnZCkge1xuICAgIHZhciBmdWxsTGF5b3V0ID0gZ2QuX2Z1bGxMYXlvdXQ7XG5cbiAgICB2YXIgY29sb3JCYXJzID0gZnVsbExheW91dC5faW5mb2xheWVyXG4gICAgICAgIC5zZWxlY3RBbGwoJ2cuJyArIGNuLmNvbG9yYmFyKVxuICAgICAgICAuZGF0YShtYWtlQ29sb3JCYXJEYXRhKGdkKSwgZnVuY3Rpb24ob3B0cykgeyByZXR1cm4gb3B0cy5faWQ7IH0pO1xuXG4gICAgY29sb3JCYXJzLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24ob3B0cykgeyByZXR1cm4gb3B0cy5faWQ7IH0pXG4gICAgICAgIC5jbGFzc2VkKGNuLmNvbG9yYmFyLCB0cnVlKTtcblxuICAgIGNvbG9yQmFycy5lYWNoKGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAgICAgdmFyIGcgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgTGliLmVuc3VyZVNpbmdsZShnLCAncmVjdCcsIGNuLmNiYmcpO1xuICAgICAgICBMaWIuZW5zdXJlU2luZ2xlKGcsICdnJywgY24uY2JmaWxscyk7XG4gICAgICAgIExpYi5lbnN1cmVTaW5nbGUoZywgJ2cnLCBjbi5jYmxpbmVzKTtcbiAgICAgICAgTGliLmVuc3VyZVNpbmdsZShnLCAnZycsIGNuLmNiYXhpcywgZnVuY3Rpb24ocykgeyBzLmNsYXNzZWQoY24uY3Jpc3AsIHRydWUpOyB9KTtcbiAgICAgICAgTGliLmVuc3VyZVNpbmdsZShnLCAnZycsIGNuLmNidGl0bGV1bnNoaWZ0LCBmdW5jdGlvbihzKSB7IHMuYXBwZW5kKCdnJykuY2xhc3NlZChjbi5jYnRpdGxlLCB0cnVlKTsgfSk7XG4gICAgICAgIExpYi5lbnN1cmVTaW5nbGUoZywgJ3JlY3QnLCBjbi5jYm91dGxpbmUpO1xuXG4gICAgICAgIHZhciBkb25lID0gZHJhd0NvbG9yQmFyKGcsIG9wdHMsIGdkKTtcbiAgICAgICAgaWYoZG9uZSAmJiBkb25lLnRoZW4pIChnZC5fcHJvbWlzZXMgfHwgW10pLnB1c2goZG9uZSk7XG5cbiAgICAgICAgaWYoZ2QuX2NvbnRleHQuZWRpdHMuY29sb3JiYXJQb3NpdGlvbikge1xuICAgICAgICAgICAgbWFrZUVkaXRhYmxlKGcsIG9wdHMsIGdkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29sb3JCYXJzLmV4aXQoKVxuICAgICAgICAuZWFjaChmdW5jdGlvbihvcHRzKSB7IFBsb3RzLmF1dG9NYXJnaW4oZ2QsIG9wdHMuX2lkKTsgfSlcbiAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgY29sb3JCYXJzLm9yZGVyKCk7XG59XG5cbmZ1bmN0aW9uIG1ha2VDb2xvckJhckRhdGEoZ2QpIHtcbiAgICB2YXIgZnVsbExheW91dCA9IGdkLl9mdWxsTGF5b3V0O1xuICAgIHZhciBjYWxjZGF0YSA9IGdkLmNhbGNkYXRhO1xuICAgIHZhciBvdXQgPSBbXTtcblxuICAgIC8vIHNpbmdsZSBvdXQgaXRlbVxuICAgIHZhciBvcHRzO1xuICAgIC8vIGNvbG9yYmFyIGF0dHIgcGFyZW50IGNvbnRhaW5lclxuICAgIHZhciBjb250O1xuICAgIC8vIHRyYWNlIGF0dHIgY29udGFpbmVyXG4gICAgdmFyIHRyYWNlO1xuICAgIC8vIGNvbG9yYmFyIG9wdGlvbnNcbiAgICB2YXIgY2JPcHQ7XG5cbiAgICBmdW5jdGlvbiBpbml0T3B0cyhvcHRzKSB7XG4gICAgICAgIHJldHVybiBleHRlbmRGbGF0KG9wdHMsIHtcbiAgICAgICAgICAgIC8vIGZpbGxjb2xvciBjYW4gYmUgYSBkMyBzY2FsZSwgZG9tYWluIGlzIHogdmFsdWVzLCByYW5nZSBpcyBjb2xvcnNcbiAgICAgICAgICAgIC8vIG9yIGxlYXZlIGl0IG91dCBmb3Igbm8gZmlsbCxcbiAgICAgICAgICAgIC8vIG9yIHNldCB0byBhIHN0cmluZyBjb25zdGFudCBmb3Igc2luZ2xlLWNvbG9yIGZpbGxcbiAgICAgICAgICAgIF9maWxsY29sb3I6IG51bGwsXG4gICAgICAgICAgICAvLyBsaW5lLmNvbG9yIGhhcyB0aGUgc2FtZSBvcHRpb25zIGFzIGZpbGxjb2xvclxuICAgICAgICAgICAgX2xpbmU6IHtjb2xvcjogbnVsbCwgd2lkdGg6IG51bGwsIGRhc2g6IG51bGx9LFxuICAgICAgICAgICAgLy8gbGV2ZWxzIG9mIGxpbmVzIHRvIGRyYXcuXG4gICAgICAgICAgICAvLyBub3RlIHRoYXQgdGhpcyBET0VTIE5PVCBkZXRlcm1pbmUgdGhlIGV4dGVudCBvZiB0aGUgYmFyXG4gICAgICAgICAgICAvLyB0aGF0J3MgZ2l2ZW4gYnkgdGhlIGRvbWFpbiBvZiBmaWxsY29sb3JcbiAgICAgICAgICAgIC8vIChvciBsaW5lLmNvbG9yIGlmIG5vIGZpbGxjb2xvciBkb21haW4pXG4gICAgICAgICAgICBfbGV2ZWxzOiB7c3RhcnQ6IG51bGwsIGVuZDogbnVsbCwgc2l6ZTogbnVsbH0sXG4gICAgICAgICAgICAvLyBzZXBhcmF0ZSBmaWxsIGxldmVscyAoZm9yIGV4YW1wbGUsIGhlYXRtYXAgY29sb3Jpbmcgb2YgYVxuICAgICAgICAgICAgLy8gY29udG91ciBtYXApIGlmIHRoaXMgaXMgb21pdHRlZCwgZmlsbGNvbG9ycyB3aWxsIGJlXG4gICAgICAgICAgICAvLyBldmFsdWF0ZWQgaGFsZndheSBiZXR3ZWVuIGxldmVsc1xuICAgICAgICAgICAgX2ZpbGxsZXZlbHM6IG51bGwsXG4gICAgICAgICAgICAvLyBmb3IgY29udGludW91cyBjb2xvcnNjYWxlczogZmlsbCB3aXRoIGEgZ3JhZGllbnQgaW5zdGVhZCBvZiBleHBsaWNpdCBsZXZlbHNcbiAgICAgICAgICAgIC8vIHZhbHVlIHNob3VsZCBiZSB0aGUgY29sb3JzY2FsZSBbWzAsIGMwXSwgW3YxLCBjMV0sIC4uLiwgWzEsIGNFbmRdXVxuICAgICAgICAgICAgX2ZpbGxncmFkaWVudDogbnVsbCxcbiAgICAgICAgICAgIC8vIHdoZW4gdXNpbmcgYSBncmFkaWVudCwgd2UgbmVlZCB0aGUgZGF0YSByYW5nZSBzcGVjaWZpZWQgc2VwYXJhdGVseVxuICAgICAgICAgICAgX3pyYW5nZTogbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjT3B0cygpIHtcbiAgICAgICAgaWYodHlwZW9mIGNiT3B0LmNhbGMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiT3B0LmNhbGMoZ2QsIHRyYWNlLCBvcHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMuX2ZpbGxncmFkaWVudCA9IGNvbnQucmV2ZXJzZXNjYWxlID9cbiAgICAgICAgICAgICAgICBmbGlwU2NhbGUoY29udC5jb2xvcnNjYWxlKSA6XG4gICAgICAgICAgICAgICAgY29udC5jb2xvcnNjYWxlO1xuICAgICAgICAgICAgb3B0cy5fenJhbmdlID0gW2NvbnRbY2JPcHQubWluXSwgY29udFtjYk9wdC5tYXhdXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjYWxjZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2QgPSBjYWxjZGF0YVtpXTtcbiAgICAgICAgdHJhY2UgPSBjZFswXS50cmFjZTtcbiAgICAgICAgdmFyIG1vZHVsZU9wdHMgPSB0cmFjZS5fbW9kdWxlLmNvbG9yYmFyO1xuXG4gICAgICAgIGlmKHRyYWNlLnZpc2libGUgPT09IHRydWUgJiYgbW9kdWxlT3B0cykge1xuICAgICAgICAgICAgdmFyIGFsbG93c011bHRpcGxvdENicyA9IEFycmF5LmlzQXJyYXkobW9kdWxlT3B0cyk7XG4gICAgICAgICAgICB2YXIgY2JPcHRzID0gYWxsb3dzTXVsdGlwbG90Q2JzID8gbW9kdWxlT3B0cyA6IFttb2R1bGVPcHRzXTtcblxuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGNiT3B0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNiT3B0ID0gY2JPcHRzW2pdO1xuICAgICAgICAgICAgICAgIHZhciBjb250TmFtZSA9IGNiT3B0LmNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICBjb250ID0gY29udE5hbWUgPyB0cmFjZVtjb250TmFtZV0gOiB0cmFjZTtcblxuICAgICAgICAgICAgICAgIGlmKGNvbnQgJiYgY29udC5zaG93c2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cyA9IGluaXRPcHRzKGNvbnQuY29sb3JiYXIpO1xuICAgICAgICAgICAgICAgICAgICBvcHRzLl9pZCA9ICdjYicgKyB0cmFjZS51aWQgKyAoYWxsb3dzTXVsdGlwbG90Q2JzICYmIGNvbnROYW1lID8gJy0nICsgY29udE5hbWUgOiAnJyk7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuX3RyYWNlSW5kZXggPSB0cmFjZS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5fcHJvcFByZWZpeCA9IChjb250TmFtZSA/IGNvbnROYW1lICsgJy4nIDogJycpICsgJ2NvbG9yYmFyLic7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuX21ldGEgPSB0cmFjZS5fbWV0YTtcbiAgICAgICAgICAgICAgICAgICAgY2FsY09wdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2gob3B0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yKHZhciBrIGluIGZ1bGxMYXlvdXQuX2NvbG9yQXhlcykge1xuICAgICAgICBjb250ID0gZnVsbExheW91dFtrXTtcblxuICAgICAgICBpZihjb250LnNob3dzY2FsZSkge1xuICAgICAgICAgICAgdmFyIGNvbG9yQXhPcHRzID0gZnVsbExheW91dC5fY29sb3JBeGVzW2tdO1xuXG4gICAgICAgICAgICBvcHRzID0gaW5pdE9wdHMoY29udC5jb2xvcmJhcik7XG4gICAgICAgICAgICBvcHRzLl9pZCA9ICdjYicgKyBrO1xuICAgICAgICAgICAgb3B0cy5fcHJvcFByZWZpeCA9IGsgKyAnLmNvbG9yYmFyLic7XG4gICAgICAgICAgICBvcHRzLl9tZXRhID0gZnVsbExheW91dC5fbWV0YTtcblxuICAgICAgICAgICAgY2JPcHQgPSB7bWluOiAnY21pbicsIG1heDogJ2NtYXgnfTtcbiAgICAgICAgICAgIGlmKGNvbG9yQXhPcHRzWzBdICE9PSAnaGVhdG1hcCcpIHtcbiAgICAgICAgICAgICAgICB0cmFjZSA9IGNvbG9yQXhPcHRzWzFdO1xuICAgICAgICAgICAgICAgIGNiT3B0LmNhbGMgPSB0cmFjZS5fbW9kdWxlLmNvbG9yYmFyLmNhbGM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbGNPcHRzKCk7XG4gICAgICAgICAgICBvdXQucHVzaChvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGRyYXdDb2xvckJhcihnLCBvcHRzLCBnZCkge1xuICAgIHZhciBmdWxsTGF5b3V0ID0gZ2QuX2Z1bGxMYXlvdXQ7XG4gICAgdmFyIGdzID0gZnVsbExheW91dC5fc2l6ZTtcblxuICAgIHZhciBmaWxsQ29sb3IgPSBvcHRzLl9maWxsY29sb3I7XG4gICAgdmFyIGxpbmUgPSBvcHRzLl9saW5lO1xuICAgIHZhciB0aXRsZSA9IG9wdHMudGl0bGU7XG4gICAgdmFyIHRpdGxlU2lkZSA9IHRpdGxlLnNpZGU7XG5cbiAgICB2YXIgenJhbmdlID0gb3B0cy5fenJhbmdlIHx8XG4gICAgICAgIGQzLmV4dGVudCgodHlwZW9mIGZpbGxDb2xvciA9PT0gJ2Z1bmN0aW9uJyA/IGZpbGxDb2xvciA6IGxpbmUuY29sb3IpLmRvbWFpbigpKTtcblxuICAgIHZhciBsaW5lQ29sb3JtYXAgPSB0eXBlb2YgbGluZS5jb2xvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIGxpbmUuY29sb3IgOlxuICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIGxpbmUuY29sb3I7IH07XG4gICAgdmFyIGZpbGxDb2xvcm1hcCA9IHR5cGVvZiBmaWxsQ29sb3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBmaWxsQ29sb3IgOlxuICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIGZpbGxDb2xvcjsgfTtcblxuICAgIHZhciBsZXZlbHNJbiA9IG9wdHMuX2xldmVscztcbiAgICB2YXIgbGV2ZWxzT3V0ID0gY2FsY0xldmVscyhnZCwgb3B0cywgenJhbmdlKTtcbiAgICB2YXIgZmlsbExldmVscyA9IGxldmVsc091dC5maWxsO1xuICAgIHZhciBsaW5lTGV2ZWxzID0gbGV2ZWxzT3V0LmxpbmU7XG5cbiAgICAvLyB3ZSBjYWxjdWxhdGUgcGl4ZWwgc2l6ZXMgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBncmFwaCBzaXplLFxuICAgIC8vIG5vdCB0aGUgYWN0dWFsIChpbiBjYXNlIHNvbWV0aGluZyBwdXNoZWQgdGhlIG1hcmdpbnMgYXJvdW5kKVxuICAgIC8vIHdoaWNoIGlzIGEgbGl0dGxlIG9kZCBidXQgYXZvaWRzIGFuIG9kZCBpdGVyYXRpdmUgZWZmZWN0XG4gICAgLy8gd2hlbiB0aGUgY29sb3JiYXIgaXRzZWxmIGlzIHB1c2hpbmcgdGhlIG1hcmdpbnMuXG4gICAgLy8gYnV0IHRoZW4gdGhlIGZyYWN0aW9uYWwgc2l6ZSBpcyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZVxuICAgIC8vIGFjdHVhbCBncmFwaCBzaXplLCBzbyB0aGF0IHRoZSBheGVzIHdpbGwgc2l6ZSBjb3JyZWN0bHkuXG4gICAgdmFyIHRoaWNrUHggPSBNYXRoLnJvdW5kKG9wdHMudGhpY2tuZXNzICogKG9wdHMudGhpY2tuZXNzbW9kZSA9PT0gJ2ZyYWN0aW9uJyA/IGdzLncgOiAxKSk7XG4gICAgdmFyIHRoaWNrRnJhYyA9IHRoaWNrUHggLyBncy53O1xuICAgIHZhciBsZW5QeCA9IE1hdGgucm91bmQob3B0cy5sZW4gKiAob3B0cy5sZW5tb2RlID09PSAnZnJhY3Rpb24nID8gZ3MuaCA6IDEpKTtcbiAgICB2YXIgbGVuRnJhYyA9IGxlblB4IC8gZ3MuaDtcbiAgICB2YXIgeHBhZEZyYWMgPSBvcHRzLnhwYWQgLyBncy53O1xuICAgIHZhciB5RXh0cmFQeCA9IChvcHRzLmJvcmRlcndpZHRoICsgb3B0cy5vdXRsaW5ld2lkdGgpIC8gMjtcbiAgICB2YXIgeXBhZEZyYWMgPSBvcHRzLnlwYWQgLyBncy5oO1xuXG4gICAgLy8geCBwb3NpdGlvbmluZzogZG8gaXQgaW5pdGlhbGx5IGp1c3QgZm9yIGxlZnQgYW5jaG9yLFxuICAgIC8vIHRoZW4gZml4IGF0IHRoZSBlbmQgKHNpbmNlIHdlIGRvbid0IGtub3cgdGhlIHdpZHRoIHlldClcbiAgICB2YXIgeExlZnQgPSBNYXRoLnJvdW5kKG9wdHMueCAqIGdzLncgKyBvcHRzLnhwYWQpO1xuICAgIC8vIGZvciBkcmFnZ2luZy4uLiB0aGlzIGlzIGdldHRpbmcgYSBsaXR0bGUgbXVkZGxlZC4uLlxuICAgIHZhciB4TGVmdEZyYWMgPSBvcHRzLnggLSB0aGlja0ZyYWMgKiAoe21pZGRsZTogMC41LCByaWdodDogMX1bb3B0cy54YW5jaG9yXSB8fCAwKTtcblxuICAgIC8vIHkgcG9zaXRpb25pbmcgd2UgY2FuIGRvIGNvcnJlY3RseSBmcm9tIHRoZSBzdGFydFxuICAgIHZhciB5Qm90dG9tRnJhYyA9IG9wdHMueSArIGxlbkZyYWMgKiAoKHt0b3A6IC0wLjUsIGJvdHRvbTogMC41fVtvcHRzLnlhbmNob3JdIHx8IDApIC0gMC41KTtcbiAgICB2YXIgeUJvdHRvbVB4ID0gTWF0aC5yb3VuZChncy5oICogKDEgLSB5Qm90dG9tRnJhYykpO1xuICAgIHZhciB5VG9wUHggPSB5Qm90dG9tUHggLSBsZW5QeDtcblxuICAgIC8vIHN0YXNoIGEgZmV3IHRoaW5ncyBmb3IgbWFrZUVkaXRhYmxlXG4gICAgb3B0cy5fbGVuRnJhYyA9IGxlbkZyYWM7XG4gICAgb3B0cy5fdGhpY2tGcmFjID0gdGhpY2tGcmFjO1xuICAgIG9wdHMuX3hMZWZ0RnJhYyA9IHhMZWZ0RnJhYztcbiAgICBvcHRzLl95Qm90dG9tRnJhYyA9IHlCb3R0b21GcmFjO1xuXG4gICAgLy8gc3Rhc2ggbW9ja2VkIGF4aXMgZm9yIGNvbnRvdXIgbGFiZWwgZm9ybWF0dGluZ1xuICAgIHZhciBheCA9IG9wdHMuX2F4aXMgPSBtb2NrQ29sb3JCYXJBeGlzKGdkLCBvcHRzLCB6cmFuZ2UpO1xuXG4gICAgLy8gcG9zaXRpb24gY2FuJ3QgZ28gaW4gdGhyb3VnaCBzdXBwbHlEZWZhdWx0c1xuICAgIC8vIGJlY2F1c2UgdGhhdCByZXN0cmljdHMgaXQgdG8gWzAsMV1cbiAgICBheC5wb3NpdGlvbiA9IG9wdHMueCArIHhwYWRGcmFjICsgdGhpY2tGcmFjO1xuXG4gICAgaWYoWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZih0aXRsZVNpZGUpICE9PSAtMSkge1xuICAgICAgICBheC50aXRsZS5zaWRlID0gdGl0bGVTaWRlO1xuICAgICAgICBheC50aXRsZXggPSBvcHRzLnggKyB4cGFkRnJhYztcbiAgICAgICAgYXgudGl0bGV5ID0geUJvdHRvbUZyYWMgKyAodGl0bGUuc2lkZSA9PT0gJ3RvcCcgPyBsZW5GcmFjIC0geXBhZEZyYWMgOiB5cGFkRnJhYyk7XG4gICAgfVxuXG4gICAgaWYobGluZS5jb2xvciAmJiBvcHRzLnRpY2ttb2RlID09PSAnYXV0bycpIHtcbiAgICAgICAgYXgudGlja21vZGUgPSAnbGluZWFyJztcbiAgICAgICAgYXgudGljazAgPSBsZXZlbHNJbi5zdGFydDtcbiAgICAgICAgdmFyIGR0aWNrID0gbGV2ZWxzSW4uc2l6ZTtcbiAgICAgICAgLy8gZXhwYW5kIGlmIHRvbyBtYW55IGNvbnRvdXJzLCBzbyB3ZSBkb24ndCBnZXQgdG9vIG1hbnkgdGlja3NcbiAgICAgICAgdmFyIGF1dG9OdGljayA9IExpYi5jb25zdHJhaW4oKHlCb3R0b21QeCAtIHlUb3BQeCkgLyA1MCwgNCwgMTUpICsgMTtcbiAgICAgICAgdmFyIGR0RmFjdG9yID0gKHpyYW5nZVsxXSAtIHpyYW5nZVswXSkgLyAoKG9wdHMubnRpY2tzIHx8IGF1dG9OdGljaykgKiBkdGljayk7XG4gICAgICAgIGlmKGR0RmFjdG9yID4gMSkge1xuICAgICAgICAgICAgdmFyIGR0ZXhwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coZHRGYWN0b3IpIC8gTWF0aC5MTjEwKSk7XG4gICAgICAgICAgICBkdGljayAqPSBkdGV4cCAqIExpYi5yb3VuZFVwKGR0RmFjdG9yIC8gZHRleHAsIFsyLCA1LCAxMF0pO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbnRvdXJzIGFyZSBhdCByb3VuZCBtdWx0aXBsZXMsIHJlc2V0IHRpY2swXG4gICAgICAgICAgICAvLyBzbyB0aGV5J3JlIHN0aWxsIGF0IHJvdW5kIG11bHRpcGxlcy4gT3RoZXJ3aXNlLFxuICAgICAgICAgICAgLy8ga2VlcCB0aGUgZmlyc3QgbGFiZWwgb24gdGhlIGZpcnN0IGNvbnRvdXIgbGV2ZWxcbiAgICAgICAgICAgIGlmKChNYXRoLmFicyhsZXZlbHNJbi5zdGFydCkgLyBsZXZlbHNJbi5zaXplICsgMWUtNikgJSAxIDwgMmUtNikge1xuICAgICAgICAgICAgICAgIGF4LnRpY2swID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBheC5kdGljayA9IGR0aWNrO1xuICAgIH1cblxuICAgIC8vIHNldCBkb21haW4gYWZ0ZXIgaW5pdCwgYmVjYXVzZSB3ZSBtYXkgd2FudCB0b1xuICAgIC8vIGFsbG93IGl0IG91dHNpZGUgWzAsMV1cbiAgICBheC5kb21haW4gPSBbXG4gICAgICAgIHlCb3R0b21GcmFjICsgeXBhZEZyYWMsXG4gICAgICAgIHlCb3R0b21GcmFjICsgbGVuRnJhYyAtIHlwYWRGcmFjXG4gICAgXTtcblxuICAgIGF4LnNldFNjYWxlKCk7XG5cbiAgICBnLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIE1hdGgucm91bmQoZ3MubCkgKyAnLCcgKyBNYXRoLnJvdW5kKGdzLnQpICsgJyknKTtcblxuICAgIHZhciB0aXRsZUNvbnQgPSBnLnNlbGVjdCgnLicgKyBjbi5jYnRpdGxldW5zaGlmdClcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoLScgKyBNYXRoLnJvdW5kKGdzLmwpICsgJywtJyArIE1hdGgucm91bmQoZ3MudCkgKyAnKScpO1xuXG4gICAgdmFyIGF4TGF5ZXIgPSBnLnNlbGVjdCgnLicgKyBjbi5jYmF4aXMpO1xuICAgIHZhciB0aXRsZUVsO1xuICAgIHZhciB0aXRsZUhlaWdodCA9IDA7XG5cbiAgICBmdW5jdGlvbiBkcmF3VGl0bGUodGl0bGVDbGFzcywgdGl0bGVPcHRzKSB7XG4gICAgICAgIHZhciBkZmx0VGl0bGVPcHRzID0ge1xuICAgICAgICAgICAgcHJvcENvbnRhaW5lcjogYXgsXG4gICAgICAgICAgICBwcm9wTmFtZTogb3B0cy5fcHJvcFByZWZpeCArICd0aXRsZScsXG4gICAgICAgICAgICB0cmFjZUluZGV4OiBvcHRzLl90cmFjZUluZGV4LFxuICAgICAgICAgICAgX21ldGE6IG9wdHMuX21ldGEsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogZnVsbExheW91dC5fZGZsdFRpdGxlLmNvbG9yYmFyLFxuICAgICAgICAgICAgY29udGFpbmVyR3JvdXA6IGcuc2VsZWN0KCcuJyArIGNuLmNidGl0bGUpXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdGhpcyBjbGFzcy10by1yb3RhdGUgdGhpbmcgd2l0aCBjb252ZXJ0VG9Uc3BhbnMgaXNcbiAgICAgICAgLy8gZ2V0dGluZyBoYWNraWVyIGFuZCBoYWNraWVyLi4uIGRlbGV0ZSBncm91cHMgd2l0aCB0aGVcbiAgICAgICAgLy8gd3JvbmcgY2xhc3MgKGluIGNhc2UgZWFybGllciB0aGUgY29sb3JiYXIgd2FzIGRyYXduIG9uXG4gICAgICAgIC8vIGEgZGlmZmVyZW50IHNpZGUsIEkgdGhpbms/KVxuICAgICAgICB2YXIgb3RoZXJDbGFzcyA9IHRpdGxlQ2xhc3MuY2hhckF0KDApID09PSAnaCcgP1xuICAgICAgICAgICAgdGl0bGVDbGFzcy5zdWJzdHIoMSkgOlxuICAgICAgICAgICAgJ2gnICsgdGl0bGVDbGFzcztcbiAgICAgICAgZy5zZWxlY3RBbGwoJy4nICsgb3RoZXJDbGFzcyArICcsLicgKyBvdGhlckNsYXNzICsgJy1tYXRoLWdyb3VwJykucmVtb3ZlKCk7XG5cbiAgICAgICAgVGl0bGVzLmRyYXcoZ2QsIHRpdGxlQ2xhc3MsIGV4dGVuZEZsYXQoZGZsdFRpdGxlT3B0cywgdGl0bGVPcHRzIHx8IHt9KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd0R1bW15VGl0bGUoKSB7XG4gICAgICAgIGlmKFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YodGl0bGVTaWRlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGRyYXcgdGhlIHRpdGxlIHNvIHdlIGtub3cgaG93IG11Y2ggcm9vbSBpdCBuZWVkc1xuICAgICAgICAgICAgLy8gd2hlbiB3ZSBzcXVpc2ggdGhlIGF4aXMuIFRoaXMgb25lIG9ubHkgYXBwbGllcyB0b1xuICAgICAgICAgICAgLy8gdG9wIG9yIGJvdHRvbSB0aXRsZXMsIG5vdCByaWdodCBzaWRlLlxuICAgICAgICAgICAgdmFyIHggPSBncy5sICsgKG9wdHMueCArIHhwYWRGcmFjKSAqIGdzLnc7XG4gICAgICAgICAgICB2YXIgZm9udFNpemUgPSBheC50aXRsZS5mb250LnNpemU7XG4gICAgICAgICAgICB2YXIgeTtcblxuICAgICAgICAgICAgaWYodGl0bGVTaWRlID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgIHkgPSAoMSAtICh5Qm90dG9tRnJhYyArIGxlbkZyYWMgLSB5cGFkRnJhYykpICogZ3MuaCArXG4gICAgICAgICAgICAgICAgICAgIGdzLnQgKyAzICsgZm9udFNpemUgKiAwLjc1O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ID0gKDEgLSAoeUJvdHRvbUZyYWMgKyB5cGFkRnJhYykpICogZ3MuaCArXG4gICAgICAgICAgICAgICAgICAgIGdzLnQgLSAzIC0gZm9udFNpemUgKiAwLjI1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHJhd1RpdGxlKGF4Ll9pZCArICd0aXRsZScsIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7eDogeCwgeTogeSwgJ3RleHQtYW5jaG9yJzogJ3N0YXJ0J31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd0NiVGl0bGUoKSB7XG4gICAgICAgIGlmKFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YodGl0bGVTaWRlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBmb250U2l6ZSA9IGF4LnRpdGxlLmZvbnQuc2l6ZTtcbiAgICAgICAgICAgIHZhciB5ID0gYXguX29mZnNldCArIGF4Ll9sZW5ndGggLyAyO1xuICAgICAgICAgICAgdmFyIHggPSBncy5sICsgKGF4LnBvc2l0aW9uIHx8IDApICogZ3MudyArICgoYXguc2lkZSA9PT0gJ3JpZ2h0JykgP1xuICAgICAgICAgICAgICAgIDEwICsgZm9udFNpemUgKiAoKGF4LnNob3d0aWNrbGFiZWxzID8gMSA6IDAuNSkpIDpcbiAgICAgICAgICAgICAgICAtMTAgLSBmb250U2l6ZSAqICgoYXguc2hvd3RpY2tsYWJlbHMgPyAwLjUgOiAwKSkpO1xuXG4gICAgICAgICAgICAvLyB0aGUgJ2gnICsgaXMgYSBoYWNrIHRvIGdldCBhcm91bmQgdGhlIGZhY3QgdGhhdFxuICAgICAgICAgICAgLy8gY29udmVydFRvVHNwYW5zIHJvdGF0ZXMgYW55ICd5Li4uJyBjbGFzcyBieSA5MCBkZWdyZWVzLlxuICAgICAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciB3YXkgdG8gY29udHJvbCB0aGlzLlxuICAgICAgICAgICAgZHJhd1RpdGxlKCdoJyArIGF4Ll9pZCArICd0aXRsZScsIHtcbiAgICAgICAgICAgICAgICBhdm9pZDoge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGQzLnNlbGVjdChnZCkuc2VsZWN0QWxsKCdnLicgKyBheC5faWQgKyAndGljaycpLFxuICAgICAgICAgICAgICAgICAgICBzaWRlOiB0aXRsZVNpZGUsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQ6IGdzLmwsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgbWF4U2hpZnQ6IGZ1bGxMYXlvdXQud2lkdGhcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHt4OiB4LCB5OiB5LCAndGV4dC1hbmNob3InOiAnbWlkZGxlJ30sXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB7cm90YXRlOiAnLTkwJywgb2Zmc2V0OiAwfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3QXhpcygpIHtcbiAgICAgICAgaWYoWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZih0aXRsZVNpZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gc3F1aXNoIHRoZSBheGlzIHRvcCB0byBtYWtlIHJvb20gZm9yIHRoZSB0aXRsZVxuICAgICAgICAgICAgdmFyIHRpdGxlR3JvdXAgPSBnLnNlbGVjdCgnLicgKyBjbi5jYnRpdGxlKTtcbiAgICAgICAgICAgIHZhciB0aXRsZVRleHQgPSB0aXRsZUdyb3VwLnNlbGVjdCgndGV4dCcpO1xuICAgICAgICAgICAgdmFyIHRpdGxlVHJhbnMgPSBbLW9wdHMub3V0bGluZXdpZHRoIC8gMiwgb3B0cy5vdXRsaW5ld2lkdGggLyAyXTtcbiAgICAgICAgICAgIHZhciBtYXRoSmF4Tm9kZSA9IHRpdGxlR3JvdXBcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcuaCcgKyBheC5faWQgKyAndGl0bGUtbWF0aC1ncm91cCcpXG4gICAgICAgICAgICAgICAgLm5vZGUoKTtcbiAgICAgICAgICAgIHZhciBsaW5lU2l6ZSA9IDE1LjY7XG4gICAgICAgICAgICBpZih0aXRsZVRleHQubm9kZSgpKSB7XG4gICAgICAgICAgICAgICAgbGluZVNpemUgPSBwYXJzZUludCh0aXRsZVRleHQubm9kZSgpLnN0eWxlLmZvbnRTaXplLCAxMCkgKiBMSU5FX1NQQUNJTkc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihtYXRoSmF4Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRpdGxlSGVpZ2h0ID0gRHJhd2luZy5iQm94KG1hdGhKYXhOb2RlKS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYodGl0bGVIZWlnaHQgPiBsaW5lU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3QgZW50aXJlbHkgc3VyZSBob3cgbWF0aGpheCBpcyBkb2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyB2ZXJ0aWNhbCBhbGlnbm1lbnQsIGJ1dCB0aGlzIHNlZW1zIHRvIHdvcmsuXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlVHJhbnNbMV0gLT0gKHRpdGxlSGVpZ2h0IC0gbGluZVNpemUpIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYodGl0bGVUZXh0Lm5vZGUoKSAmJiAhdGl0bGVUZXh0LmNsYXNzZWQoY24uanNQbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgICAgICB0aXRsZUhlaWdodCA9IERyYXdpbmcuYkJveCh0aXRsZVRleHQubm9kZSgpKS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aXRsZUhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciBidHduIGNvbG9yYmFyIGFuZCB0aXRsZVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGNvbmZpZ3VyYWJsZVxuICAgICAgICAgICAgICAgIHRpdGxlSGVpZ2h0ICs9IDU7XG5cbiAgICAgICAgICAgICAgICBpZih0aXRsZVNpZGUgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4LmRvbWFpblsxXSAtPSB0aXRsZUhlaWdodCAvIGdzLmg7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlVHJhbnNbMV0gKj0gLTE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXguZG9tYWluWzBdICs9IHRpdGxlSGVpZ2h0IC8gZ3MuaDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5saW5lcyA9IHN2Z1RleHRVdGlscy5saW5lQ291bnQodGl0bGVUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGVUcmFuc1sxXSArPSAoMSAtIG5saW5lcykgKiBsaW5lU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aXRsZUdyb3VwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHRpdGxlVHJhbnMgKyAnKScpO1xuICAgICAgICAgICAgICAgIGF4LnNldFNjYWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnLnNlbGVjdEFsbCgnLicgKyBjbi5jYmZpbGxzICsgJywuJyArIGNuLmNibGluZXMpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyBNYXRoLnJvdW5kKGdzLmggKiAoMSAtIGF4LmRvbWFpblsxXSkpICsgJyknKTtcblxuICAgICAgICBheExheWVyLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgTWF0aC5yb3VuZCgtZ3MudCkgKyAnKScpO1xuXG4gICAgICAgIHZhciBmaWxscyA9IGcuc2VsZWN0KCcuJyArIGNuLmNiZmlsbHMpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdyZWN0LicgKyBjbi5jYmZpbGwpXG4gICAgICAgICAgICAuZGF0YShmaWxsTGV2ZWxzKTtcbiAgICAgICAgZmlsbHMuZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgLmNsYXNzZWQoY24uY2JmaWxsLCB0cnVlKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnbm9uZScpO1xuICAgICAgICBmaWxscy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgdmFyIHpCb3VuZHMgPSB6cmFuZ2VcbiAgICAgICAgICAgIC5tYXAoYXguYzJwKVxuICAgICAgICAgICAgLm1hcChNYXRoLnJvdW5kKVxuICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xuXG4gICAgICAgIGZpbGxzLmVhY2goZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgdmFyIHogPSBbXG4gICAgICAgICAgICAgICAgKGkgPT09IDApID8genJhbmdlWzBdIDogKGZpbGxMZXZlbHNbaV0gKyBmaWxsTGV2ZWxzW2kgLSAxXSkgLyAyLFxuICAgICAgICAgICAgICAgIChpID09PSBmaWxsTGV2ZWxzLmxlbmd0aCAtIDEpID8genJhbmdlWzFdIDogKGZpbGxMZXZlbHNbaV0gKyBmaWxsTGV2ZWxzW2kgKyAxXSkgLyAyXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICAubWFwKGF4LmMycClcbiAgICAgICAgICAgIC5tYXAoTWF0aC5yb3VuZCk7XG5cbiAgICAgICAgICAgIC8vIG9mZnNldCB0aGUgc2lkZSBhZGpvaW5pbmcgdGhlIG5leHQgcmVjdGFuZ2xlIHNvIHRoZXlcbiAgICAgICAgICAgIC8vIG92ZXJsYXAsIHRvIHByZXZlbnQgYW50aWFsaWFzaW5nIGdhcHNcbiAgICAgICAgICAgIHpbMV0gPSBMaWIuY29uc3RyYWluKHpbMV0gKyAoelsxXSA+IHpbMF0pID8gMSA6IC0xLCB6Qm91bmRzWzBdLCB6Qm91bmRzWzFdKTtcblxuXG4gICAgICAgICAgICAvLyBDb2xvcmJhciBjYW5ub3QgY3VycmVudGx5IHN1cHBvcnQgb3BhY2l0aWVzIHNvIHdlXG4gICAgICAgICAgICAvLyB1c2UgYW4gb3BhcXVlIGZpbGwgZXZlbiB3aGVuIGFscGhhIGNoYW5uZWxzIHByZXNlbnRcbiAgICAgICAgICAgIHZhciBmaWxsRWwgPSBkMy5zZWxlY3QodGhpcykuYXR0cih7XG4gICAgICAgICAgICAgICAgeDogeExlZnQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IE1hdGgubWF4KHRoaWNrUHgsIDIpLFxuICAgICAgICAgICAgICAgIHk6IGQzLm1pbih6KSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KGQzLm1heCh6KSAtIGQzLm1pbih6KSwgMiksXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYob3B0cy5fZmlsbGdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgRHJhd2luZy5ncmFkaWVudChmaWxsRWwsIGdkLCBvcHRzLl9pZCwgJ3ZlcnRpY2FsJywgb3B0cy5fZmlsbGdyYWRpZW50LCAnZmlsbCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aW55Y29sb3IgY2FuJ3QgaGFuZGxlIGV4cG9uZW50cyBhbmRcbiAgICAgICAgICAgICAgICAvLyBhdCB0aGlzIHNjYWxlLCByZW1vdmluZyBpdCBtYWtlcyBubyBkaWZmZXJlbmNlLlxuICAgICAgICAgICAgICAgIHZhciBjb2xvclN0cmluZyA9IGZpbGxDb2xvcm1hcChkKS5yZXBsYWNlKCdlLScsICcnKTtcbiAgICAgICAgICAgICAgICBmaWxsRWwuYXR0cignZmlsbCcsIHRpbnljb2xvcihjb2xvclN0cmluZykudG9IZXhTdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBsaW5lcyA9IGcuc2VsZWN0KCcuJyArIGNuLmNibGluZXMpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoLicgKyBjbi5jYmxpbmUpXG4gICAgICAgICAgICAuZGF0YShsaW5lLmNvbG9yICYmIGxpbmUud2lkdGggPyBsaW5lTGV2ZWxzIDogW10pO1xuICAgICAgICBsaW5lcy5lbnRlcigpLmFwcGVuZCgncGF0aCcpXG4gICAgICAgICAgICAuY2xhc3NlZChjbi5jYmxpbmUsIHRydWUpO1xuICAgICAgICBsaW5lcy5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgIGxpbmVzLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCAnTScgKyB4TGVmdCArICcsJyArXG4gICAgICAgICAgICAgICAgICAgIChNYXRoLnJvdW5kKGF4LmMycChkKSkgKyAobGluZS53aWR0aCAvIDIpICUgMSkgKyAnaCcgKyB0aGlja1B4KVxuICAgICAgICAgICAgICAgIC5jYWxsKERyYXdpbmcubGluZUdyb3VwU3R5bGUsIGxpbmUud2lkdGgsIGxpbmVDb2xvcm1hcChkKSwgbGluZS5kYXNoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZm9yY2UgZnVsbCByZWRyYXcgb2YgbGFiZWxzIGFuZCB0aWNrc1xuICAgICAgICBheExheWVyLnNlbGVjdEFsbCgnZy4nICsgYXguX2lkICsgJ3RpY2sscGF0aCcpLnJlbW92ZSgpO1xuXG4gICAgICAgIHZhciBzaGlmdCA9IHhMZWZ0ICsgdGhpY2tQeCArXG4gICAgICAgICAgICAob3B0cy5vdXRsaW5ld2lkdGggfHwgMCkgLyAyIC0gKG9wdHMudGlja3MgPT09ICdvdXRzaWRlJyA/IDEgOiAwKTtcblxuICAgICAgICB2YXIgdmFscyA9IEF4ZXMuY2FsY1RpY2tzKGF4KTtcbiAgICAgICAgdmFyIHRyYW5zRm4gPSBBeGVzLm1ha2VUcmFuc0ZuKGF4KTtcbiAgICAgICAgdmFyIHRpY2tTaWduID0gQXhlcy5nZXRUaWNrU2lnbnMoYXgpWzJdO1xuXG4gICAgICAgIEF4ZXMuZHJhd1RpY2tzKGdkLCBheCwge1xuICAgICAgICAgICAgdmFsczogYXgudGlja3MgPT09ICdpbnNpZGUnID8gQXhlcy5jbGlwRW5kcyhheCwgdmFscykgOiB2YWxzLFxuICAgICAgICAgICAgbGF5ZXI6IGF4TGF5ZXIsXG4gICAgICAgICAgICBwYXRoOiBBeGVzLm1ha2VUaWNrUGF0aChheCwgc2hpZnQsIHRpY2tTaWduKSxcbiAgICAgICAgICAgIHRyYW5zRm46IHRyYW5zRm5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIEF4ZXMuZHJhd0xhYmVscyhnZCwgYXgsIHtcbiAgICAgICAgICAgIHZhbHM6IHZhbHMsXG4gICAgICAgICAgICBsYXllcjogYXhMYXllcixcbiAgICAgICAgICAgIHRyYW5zRm46IHRyYW5zRm4sXG4gICAgICAgICAgICBsYWJlbEZuczogQXhlcy5tYWtlTGFiZWxGbnMoYXgsIHNoaWZ0KVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB3YWl0IGZvciB0aGUgYXhpcyAmIHRpdGxlIHRvIGZpbmlzaCByZW5kZXJpbmcgYmVmb3JlXG4gICAgLy8gY29udGludWluZyBwb3NpdGlvbmluZ1xuICAgIC8vIFRPRE86IHdoeSBhcmUgd2UgcmVkcmF3aW5nIG11bHRpcGxlIHRpbWVzIG5vdyB3aXRoIHRoaXM/XG4gICAgLy8gSSBndWVzcyBhdXRvTWFyZ2luIGRvZXNuJ3QgbGlrZSBiZWluZyBwb3N0LXByb21pc2U/XG4gICAgZnVuY3Rpb24gcG9zaXRpb25DQigpIHtcbiAgICAgICAgdmFyIGlubmVyV2lkdGggPSB0aGlja1B4ICsgb3B0cy5vdXRsaW5ld2lkdGggLyAyICsgRHJhd2luZy5iQm94KGF4TGF5ZXIubm9kZSgpKS53aWR0aDtcbiAgICAgICAgdGl0bGVFbCA9IHRpdGxlQ29udC5zZWxlY3QoJ3RleHQnKTtcblxuICAgICAgICBpZih0aXRsZUVsLm5vZGUoKSAmJiAhdGl0bGVFbC5jbGFzc2VkKGNuLmpzUGxhY2Vob2xkZXIpKSB7XG4gICAgICAgICAgICB2YXIgbWF0aEpheE5vZGUgPSB0aXRsZUNvbnQuc2VsZWN0KCcuaCcgKyBheC5faWQgKyAndGl0bGUtbWF0aC1ncm91cCcpLm5vZGUoKTtcbiAgICAgICAgICAgIHZhciB0aXRsZVdpZHRoO1xuICAgICAgICAgICAgaWYobWF0aEpheE5vZGUgJiYgWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZih0aXRsZVNpZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRpdGxlV2lkdGggPSBEcmF3aW5nLmJCb3gobWF0aEpheE5vZGUpLndpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub3RlOiB0aGUgZm9ybXVsYSBiZWxvdyB3b3JrcyBmb3IgYWxsIHRpdGxlIHNpZGVzLFxuICAgICAgICAgICAgICAgIC8vIChleGNlcHQgZm9yIHRvcC9ib3R0b20gbWF0aGpheCwgYWJvdmUpXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoZSB3ZWlyZCBncy5sIGlzIGJlY2F1c2UgdGhlIHRpdGxldW5zaGlmdFxuICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBnZXRzIHJlbW92ZWQgYnkgRHJhd2luZy5iQm94XG4gICAgICAgICAgICAgICAgdGl0bGVXaWR0aCA9IERyYXdpbmcuYkJveCh0aXRsZUNvbnQubm9kZSgpKS5yaWdodCAtIHhMZWZ0IC0gZ3MubDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlubmVyV2lkdGggPSBNYXRoLm1heChpbm5lcldpZHRoLCB0aXRsZVdpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRlcndpZHRoID0gMiAqIG9wdHMueHBhZCArIGlubmVyV2lkdGggKyBvcHRzLmJvcmRlcndpZHRoICsgb3B0cy5vdXRsaW5ld2lkdGggLyAyO1xuICAgICAgICB2YXIgb3V0ZXJoZWlnaHQgPSB5Qm90dG9tUHggLSB5VG9wUHg7XG5cbiAgICAgICAgZy5zZWxlY3QoJy4nICsgY24uY2JiZykuYXR0cih7XG4gICAgICAgICAgICB4OiB4TGVmdCAtIG9wdHMueHBhZCAtIChvcHRzLmJvcmRlcndpZHRoICsgb3B0cy5vdXRsaW5ld2lkdGgpIC8gMixcbiAgICAgICAgICAgIHk6IHlUb3BQeCAtIHlFeHRyYVB4LFxuICAgICAgICAgICAgd2lkdGg6IE1hdGgubWF4KG91dGVyd2lkdGgsIDIpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChvdXRlcmhlaWdodCArIDIgKiB5RXh0cmFQeCwgMilcbiAgICAgICAgfSlcbiAgICAgICAgLmNhbGwoQ29sb3IuZmlsbCwgb3B0cy5iZ2NvbG9yKVxuICAgICAgICAuY2FsbChDb2xvci5zdHJva2UsIG9wdHMuYm9yZGVyY29sb3IpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgb3B0cy5ib3JkZXJ3aWR0aCk7XG5cbiAgICAgICAgZy5zZWxlY3RBbGwoJy4nICsgY24uY2JvdXRsaW5lKS5hdHRyKHtcbiAgICAgICAgICAgIHg6IHhMZWZ0LFxuICAgICAgICAgICAgeTogeVRvcFB4ICsgb3B0cy55cGFkICsgKHRpdGxlU2lkZSA9PT0gJ3RvcCcgPyB0aXRsZUhlaWdodCA6IDApLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGgubWF4KHRoaWNrUHgsIDIpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChvdXRlcmhlaWdodCAtIDIgKiBvcHRzLnlwYWQgLSB0aXRsZUhlaWdodCwgMilcbiAgICAgICAgfSlcbiAgICAgICAgLmNhbGwoQ29sb3Iuc3Ryb2tlLCBvcHRzLm91dGxpbmVjb2xvcilcbiAgICAgICAgLnN0eWxlKHtcbiAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBvcHRzLm91dGxpbmV3aWR0aFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmaXggcG9zaXRpb25pbmcgZm9yIHhhbmNob3IhPSdsZWZ0J1xuICAgICAgICB2YXIgeG9mZnNldCA9ICh7Y2VudGVyOiAwLjUsIHJpZ2h0OiAxfVtvcHRzLnhhbmNob3JdIHx8IDApICogb3V0ZXJ3aWR0aDtcbiAgICAgICAgZy5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoZ3MubCAtIHhvZmZzZXQpICsgJywnICsgZ3MudCArICcpJyk7XG5cbiAgICAgICAgLy8gYXV0byBtYXJnaW4gYWRqdXN0bWVudFxuICAgICAgICB2YXIgbWFyZ2luT3B0cyA9IHt9O1xuICAgICAgICB2YXIgdEZyYWMgPSBGUk9NX1RMW29wdHMueWFuY2hvcl07XG4gICAgICAgIHZhciBiRnJhYyA9IEZST01fQlJbb3B0cy55YW5jaG9yXTtcbiAgICAgICAgaWYob3B0cy5sZW5tb2RlID09PSAncGl4ZWxzJykge1xuICAgICAgICAgICAgbWFyZ2luT3B0cy55ID0gb3B0cy55O1xuICAgICAgICAgICAgbWFyZ2luT3B0cy50ID0gb3V0ZXJoZWlnaHQgKiB0RnJhYztcbiAgICAgICAgICAgIG1hcmdpbk9wdHMuYiA9IG91dGVyaGVpZ2h0ICogYkZyYWM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXJnaW5PcHRzLnQgPSBtYXJnaW5PcHRzLmIgPSAwO1xuICAgICAgICAgICAgbWFyZ2luT3B0cy55dCA9IG9wdHMueSArIG9wdHMubGVuICogdEZyYWM7XG4gICAgICAgICAgICBtYXJnaW5PcHRzLnliID0gb3B0cy55IC0gb3B0cy5sZW4gKiBiRnJhYztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsRnJhYyA9IEZST01fVExbb3B0cy54YW5jaG9yXTtcbiAgICAgICAgdmFyIHJGcmFjID0gRlJPTV9CUltvcHRzLnhhbmNob3JdO1xuICAgICAgICBpZihvcHRzLnRoaWNrbmVzc21vZGUgPT09ICdwaXhlbHMnKSB7XG4gICAgICAgICAgICBtYXJnaW5PcHRzLnggPSBvcHRzLng7XG4gICAgICAgICAgICBtYXJnaW5PcHRzLmwgPSBvdXRlcndpZHRoICogbEZyYWM7XG4gICAgICAgICAgICBtYXJnaW5PcHRzLnIgPSBvdXRlcndpZHRoICogckZyYWM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXh0cmFUaGlja25lc3MgPSBvdXRlcndpZHRoIC0gdGhpY2tQeDtcbiAgICAgICAgICAgIG1hcmdpbk9wdHMubCA9IGV4dHJhVGhpY2tuZXNzICogbEZyYWM7XG4gICAgICAgICAgICBtYXJnaW5PcHRzLnIgPSBleHRyYVRoaWNrbmVzcyAqIHJGcmFjO1xuICAgICAgICAgICAgbWFyZ2luT3B0cy54bCA9IG9wdHMueCAtIG9wdHMudGhpY2tuZXNzICogbEZyYWM7XG4gICAgICAgICAgICBtYXJnaW5PcHRzLnhyID0gb3B0cy54ICsgb3B0cy50aGlja25lc3MgKiByRnJhYztcbiAgICAgICAgfVxuXG4gICAgICAgIFBsb3RzLmF1dG9NYXJnaW4oZ2QsIG9wdHMuX2lkLCBtYXJnaW5PcHRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTGliLnN5bmNPckFzeW5jKFtcbiAgICAgICAgUGxvdHMucHJldmlvdXNQcm9taXNlcyxcbiAgICAgICAgZHJhd0R1bW15VGl0bGUsXG4gICAgICAgIGRyYXdBeGlzLFxuICAgICAgICBkcmF3Q2JUaXRsZSxcbiAgICAgICAgUGxvdHMucHJldmlvdXNQcm9taXNlcyxcbiAgICAgICAgcG9zaXRpb25DQlxuICAgIF0sIGdkKTtcbn1cblxuZnVuY3Rpb24gbWFrZUVkaXRhYmxlKGcsIG9wdHMsIGdkKSB7XG4gICAgdmFyIGZ1bGxMYXlvdXQgPSBnZC5fZnVsbExheW91dDtcbiAgICB2YXIgZ3MgPSBmdWxsTGF5b3V0Ll9zaXplO1xuICAgIHZhciB0MCwgeGYsIHlmO1xuXG4gICAgZHJhZ0VsZW1lbnQuaW5pdCh7XG4gICAgICAgIGVsZW1lbnQ6IGcubm9kZSgpLFxuICAgICAgICBnZDogZ2QsXG4gICAgICAgIHByZXBGbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0MCA9IGcuYXR0cigndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICBzZXRDdXJzb3IoZyk7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmVGbjogZnVuY3Rpb24oZHgsIGR5KSB7XG4gICAgICAgICAgICBnLmF0dHIoJ3RyYW5zZm9ybScsIHQwICsgJyAnICsgJ3RyYW5zbGF0ZSgnICsgZHggKyAnLCcgKyBkeSArICcpJyk7XG5cbiAgICAgICAgICAgIHhmID0gZHJhZ0VsZW1lbnQuYWxpZ24ob3B0cy5feExlZnRGcmFjICsgKGR4IC8gZ3MudyksIG9wdHMuX3RoaWNrRnJhYyxcbiAgICAgICAgICAgICAgICAwLCAxLCBvcHRzLnhhbmNob3IpO1xuICAgICAgICAgICAgeWYgPSBkcmFnRWxlbWVudC5hbGlnbihvcHRzLl95Qm90dG9tRnJhYyAtIChkeSAvIGdzLmgpLCBvcHRzLl9sZW5GcmFjLFxuICAgICAgICAgICAgICAgIDAsIDEsIG9wdHMueWFuY2hvcik7XG5cbiAgICAgICAgICAgIHZhciBjc3IgPSBkcmFnRWxlbWVudC5nZXRDdXJzb3IoeGYsIHlmLCBvcHRzLnhhbmNob3IsIG9wdHMueWFuY2hvcik7XG4gICAgICAgICAgICBzZXRDdXJzb3IoZywgY3NyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZG9uZUZuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNldEN1cnNvcihnKTtcblxuICAgICAgICAgICAgaWYoeGYgIT09IHVuZGVmaW5lZCAmJiB5ZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIHVwZGF0ZVtvcHRzLl9wcm9wUHJlZml4ICsgJ3gnXSA9IHhmO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVtvcHRzLl9wcm9wUHJlZml4ICsgJ3knXSA9IHlmO1xuICAgICAgICAgICAgICAgIGlmKG9wdHMuX3RyYWNlSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBSZWdpc3RyeS5jYWxsKCdfZ3VpUmVzdHlsZScsIGdkLCB1cGRhdGUsIG9wdHMuX3RyYWNlSW5kZXgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFJlZ2lzdHJ5LmNhbGwoJ19ndWlSZWxheW91dCcsIGdkLCB1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjYWxjTGV2ZWxzKGdkLCBvcHRzLCB6cmFuZ2UpIHtcbiAgICB2YXIgbGV2ZWxzSW4gPSBvcHRzLl9sZXZlbHM7XG4gICAgdmFyIGxpbmVMZXZlbHMgPSBbXTtcbiAgICB2YXIgZmlsbExldmVscyA9IFtdO1xuICAgIHZhciBsO1xuICAgIHZhciBpO1xuXG4gICAgdmFyIGwwID0gbGV2ZWxzSW4uZW5kICsgbGV2ZWxzSW4uc2l6ZSAvIDEwMDtcbiAgICB2YXIgbHMgPSBsZXZlbHNJbi5zaXplO1xuICAgIHZhciB6cjAgPSAoMS4wMDEgKiB6cmFuZ2VbMF0gLSAwLjAwMSAqIHpyYW5nZVsxXSk7XG4gICAgdmFyIHpyMSA9ICgxLjAwMSAqIHpyYW5nZVsxXSAtIDAuMDAxICogenJhbmdlWzBdKTtcblxuICAgIGZvcihpID0gMDsgaSA8IDFlNTsgaSsrKSB7XG4gICAgICAgIGwgPSBsZXZlbHNJbi5zdGFydCArIGkgKiBscztcbiAgICAgICAgaWYobHMgPiAwID8gKGwgPj0gbDApIDogKGwgPD0gbDApKSBicmVhaztcbiAgICAgICAgaWYobCA+IHpyMCAmJiBsIDwgenIxKSBsaW5lTGV2ZWxzLnB1c2gobCk7XG4gICAgfVxuXG4gICAgaWYob3B0cy5fZmlsbGdyYWRpZW50KSB7XG4gICAgICAgIGZpbGxMZXZlbHMgPSBbMF07XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBvcHRzLl9maWxsY29sb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGZpbGxMZXZlbHNJbiA9IG9wdHMuX2ZpbGxsZXZlbHM7XG5cbiAgICAgICAgaWYoZmlsbExldmVsc0luKSB7XG4gICAgICAgICAgICBsMCA9IGZpbGxMZXZlbHNJbi5lbmQgKyBmaWxsTGV2ZWxzSW4uc2l6ZSAvIDEwMDtcbiAgICAgICAgICAgIGxzID0gZmlsbExldmVsc0luLnNpemU7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCAxZTU7IGkrKykge1xuICAgICAgICAgICAgICAgIGwgPSBmaWxsTGV2ZWxzSW4uc3RhcnQgKyBpICogbHM7XG4gICAgICAgICAgICAgICAgaWYobHMgPiAwID8gKGwgPj0gbDApIDogKGwgPD0gbDApKSBicmVhaztcbiAgICAgICAgICAgICAgICBpZihsID4genJhbmdlWzBdICYmIGwgPCB6cmFuZ2VbMV0pIGZpbGxMZXZlbHMucHVzaChsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbGxMZXZlbHMgPSBsaW5lTGV2ZWxzLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYgLSBsZXZlbHNJbi5zaXplIC8gMjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmlsbExldmVscy5wdXNoKGZpbGxMZXZlbHNbZmlsbExldmVscy5sZW5ndGggLSAxXSArIGxldmVsc0luLnNpemUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKG9wdHMuX2ZpbGxjb2xvciAmJiB0eXBlb2Ygb3B0cy5fZmlsbGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBkb2Vzbid0IG1hdHRlciB3aGF0IHRoaXMgdmFsdWUgaXMsIHdpdGggYSBzaW5nbGUgdmFsdWVcbiAgICAgICAgLy8gd2UnbGwgbWFrZSBhIHNpbmdsZSBmaWxsIHJlY3QgY292ZXJpbmcgdGhlIHdob2xlIGJhclxuICAgICAgICBmaWxsTGV2ZWxzID0gWzBdO1xuICAgIH1cblxuICAgIGlmKGxldmVsc0luLnNpemUgPCAwKSB7XG4gICAgICAgIGxpbmVMZXZlbHMucmV2ZXJzZSgpO1xuICAgICAgICBmaWxsTGV2ZWxzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge2xpbmU6IGxpbmVMZXZlbHMsIGZpbGw6IGZpbGxMZXZlbHN9O1xufVxuXG5mdW5jdGlvbiBtb2NrQ29sb3JCYXJBeGlzKGdkLCBvcHRzLCB6cmFuZ2UpIHtcbiAgICB2YXIgZnVsbExheW91dCA9IGdkLl9mdWxsTGF5b3V0O1xuXG4gICAgdmFyIGNiQXhpc0luID0ge1xuICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgICAgcmFuZ2U6IHpyYW5nZSxcbiAgICAgICAgdGlja21vZGU6IG9wdHMudGlja21vZGUsXG4gICAgICAgIG50aWNrczogb3B0cy5udGlja3MsXG4gICAgICAgIHRpY2swOiBvcHRzLnRpY2swLFxuICAgICAgICBkdGljazogb3B0cy5kdGljayxcbiAgICAgICAgdGlja3ZhbHM6IG9wdHMudGlja3ZhbHMsXG4gICAgICAgIHRpY2t0ZXh0OiBvcHRzLnRpY2t0ZXh0LFxuICAgICAgICB0aWNrczogb3B0cy50aWNrcyxcbiAgICAgICAgdGlja2xlbjogb3B0cy50aWNrbGVuLFxuICAgICAgICB0aWNrd2lkdGg6IG9wdHMudGlja3dpZHRoLFxuICAgICAgICB0aWNrY29sb3I6IG9wdHMudGlja2NvbG9yLFxuICAgICAgICBzaG93dGlja2xhYmVsczogb3B0cy5zaG93dGlja2xhYmVscyxcbiAgICAgICAgdGlja2ZvbnQ6IG9wdHMudGlja2ZvbnQsXG4gICAgICAgIHRpY2thbmdsZTogb3B0cy50aWNrYW5nbGUsXG4gICAgICAgIHRpY2tmb3JtYXQ6IG9wdHMudGlja2Zvcm1hdCxcbiAgICAgICAgZXhwb25lbnRmb3JtYXQ6IG9wdHMuZXhwb25lbnRmb3JtYXQsXG4gICAgICAgIHNlcGFyYXRldGhvdXNhbmRzOiBvcHRzLnNlcGFyYXRldGhvdXNhbmRzLFxuICAgICAgICBzaG93ZXhwb25lbnQ6IG9wdHMuc2hvd2V4cG9uZW50LFxuICAgICAgICBzaG93dGlja3ByZWZpeDogb3B0cy5zaG93dGlja3ByZWZpeCxcbiAgICAgICAgdGlja3ByZWZpeDogb3B0cy50aWNrcHJlZml4LFxuICAgICAgICBzaG93dGlja3N1ZmZpeDogb3B0cy5zaG93dGlja3N1ZmZpeCxcbiAgICAgICAgdGlja3N1ZmZpeDogb3B0cy50aWNrc3VmZml4LFxuICAgICAgICB0aXRsZTogb3B0cy50aXRsZSxcbiAgICAgICAgc2hvd2xpbmU6IHRydWUsXG4gICAgICAgIGFuY2hvcjogJ2ZyZWUnLFxuICAgICAgICBzaWRlOiAncmlnaHQnLFxuICAgICAgICBwb3NpdGlvbjogMVxuICAgIH07XG5cbiAgICB2YXIgY2JBeGlzT3V0ID0ge1xuICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgICAgX2lkOiAneScgKyBvcHRzLl9pZFxuICAgIH07XG5cbiAgICB2YXIgYXhpc09wdGlvbnMgPSB7XG4gICAgICAgIGxldHRlcjogJ3knLFxuICAgICAgICBmb250OiBmdWxsTGF5b3V0LmZvbnQsXG4gICAgICAgIG5vSG92ZXI6IHRydWUsXG4gICAgICAgIG5vVGlja3NvbjogdHJ1ZSxcbiAgICAgICAgY2FsZW5kYXI6IGZ1bGxMYXlvdXQuY2FsZW5kYXIgIC8vIG5vdCByZWFsbHkgbmVjZXNzYXJ5ICh5ZXQ/KVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjb2VyY2UoYXR0ciwgZGZsdCkge1xuICAgICAgICByZXR1cm4gTGliLmNvZXJjZShjYkF4aXNJbiwgY2JBeGlzT3V0LCBheGlzTGF5b3V0QXR0cnMsIGF0dHIsIGRmbHQpO1xuICAgIH1cblxuICAgIGhhbmRsZUF4aXNEZWZhdWx0cyhjYkF4aXNJbiwgY2JBeGlzT3V0LCBjb2VyY2UsIGF4aXNPcHRpb25zLCBmdWxsTGF5b3V0KTtcbiAgICBoYW5kbGVBeGlzUG9zaXRpb25EZWZhdWx0cyhjYkF4aXNJbiwgY2JBeGlzT3V0LCBjb2VyY2UsIGF4aXNPcHRpb25zKTtcblxuICAgIHJldHVybiBjYkF4aXNPdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGRyYXc6IGRyYXdcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1vZHVsZVR5cGU6ICdjb21wb25lbnQnLFxuICAgIG5hbWU6ICdjb2xvcmJhcicsXG5cbiAgICBhdHRyaWJ1dGVzOiByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKSxcbiAgICBzdXBwbHlEZWZhdWx0czogcmVxdWlyZSgnLi9kZWZhdWx0cycpLFxuXG4gICAgZHJhdzogcmVxdWlyZSgnLi9kcmF3JykuZHJhdyxcbiAgICBoYXNDb2xvcmJhcjogcmVxdWlyZSgnLi9oYXNfY29sb3JiYXInKVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB2aXNpYmxlOiB7XG4gICAgICAgIHZhbFR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBlZGl0VHlwZTogJ2NhbGMnLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ0RldGVybWluZXMgd2hldGhlciBvciBub3QgdGhpcyBzZXQgb2YgZXJyb3IgYmFycyBpcyB2aXNpYmxlLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuICAgIHR5cGU6IHtcbiAgICAgICAgdmFsVHlwZTogJ2VudW1lcmF0ZWQnLFxuICAgICAgICB2YWx1ZXM6IFsncGVyY2VudCcsICdjb25zdGFudCcsICdzcXJ0JywgJ2RhdGEnXSxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBlZGl0VHlwZTogJ2NhbGMnLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ0RldGVybWluZXMgdGhlIHJ1bGUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgYmFycy4nLFxuXG4gICAgICAgICAgICAnSWYgKmNvbnN0YW50YCwgdGhlIGJhciBsZW5ndGhzIGFyZSBvZiBhIGNvbnN0YW50IHZhbHVlLicsXG4gICAgICAgICAgICAnU2V0IHRoaXMgY29uc3RhbnQgaW4gYHZhbHVlYC4nLFxuXG4gICAgICAgICAgICAnSWYgKnBlcmNlbnQqLCB0aGUgYmFyIGxlbmd0aHMgY29ycmVzcG9uZCB0byBhIHBlcmNlbnRhZ2Ugb2YnLFxuICAgICAgICAgICAgJ3VuZGVybHlpbmcgZGF0YS4gU2V0IHRoaXMgcGVyY2VudGFnZSBpbiBgdmFsdWVgLicsXG5cbiAgICAgICAgICAgICdJZiAqc3FydCosIHRoZSBiYXIgbGVuZ3RocyBjb3JyZXNwb25kIHRvIHRoZSBzcWF1cmUgb2YgdGhlJyxcbiAgICAgICAgICAgICd1bmRlcmx5aW5nIGRhdGEuJyxcblxuICAgICAgICAgICAgJ0lmICpkYXRhKiwgdGhlIGJhciBsZW5ndGhzIGFyZSBzZXQgd2l0aCBkYXRhIHNldCBgYXJyYXlgLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuICAgIHN5bW1ldHJpYzoge1xuICAgICAgICB2YWxUeXBlOiAnYm9vbGVhbicsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgZWRpdFR5cGU6ICdjYWxjJyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBlcnJvciBiYXJzIGhhdmUgdGhlIHNhbWUgbGVuZ3RoJyxcbiAgICAgICAgICAgICdpbiBib3RoIGRpcmVjdGlvbicsXG4gICAgICAgICAgICAnKHRvcC9ib3R0b20gZm9yIHZlcnRpY2FsIGJhcnMsIGxlZnQvcmlnaHQgZm9yIGhvcml6b250YWwgYmFycy4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICBhcnJheToge1xuICAgICAgICB2YWxUeXBlOiAnZGF0YV9hcnJheScsXG4gICAgICAgIGVkaXRUeXBlOiAnY2FsYycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU2V0cyB0aGUgZGF0YSBjb3JyZXNwb25kaW5nIHRoZSBsZW5ndGggb2YgZWFjaCBlcnJvciBiYXIuJyxcbiAgICAgICAgICAgICdWYWx1ZXMgYXJlIHBsb3R0ZWQgcmVsYXRpdmUgdG8gdGhlIHVuZGVybHlpbmcgZGF0YS4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICBhcnJheW1pbnVzOiB7XG4gICAgICAgIHZhbFR5cGU6ICdkYXRhX2FycmF5JyxcbiAgICAgICAgZWRpdFR5cGU6ICdjYWxjJyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSBkYXRhIGNvcnJlc3BvbmRpbmcgdGhlIGxlbmd0aCBvZiBlYWNoIGVycm9yIGJhciBpbiB0aGUnLFxuICAgICAgICAgICAgJ2JvdHRvbSAobGVmdCkgZGlyZWN0aW9uIGZvciB2ZXJ0aWNhbCAoaG9yaXpvbnRhbCkgYmFycycsXG4gICAgICAgICAgICAnVmFsdWVzIGFyZSBwbG90dGVkIHJlbGF0aXZlIHRvIHRoZSB1bmRlcmx5aW5nIGRhdGEuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgdmFsdWU6IHtcbiAgICAgICAgdmFsVHlwZTogJ251bWJlcicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgZGZsdDogMTAsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgZWRpdFR5cGU6ICdjYWxjJyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSB2YWx1ZSBvZiBlaXRoZXIgdGhlIHBlcmNlbnRhZ2UnLFxuICAgICAgICAgICAgJyhpZiBgdHlwZWAgaXMgc2V0IHRvICpwZXJjZW50Kikgb3IgdGhlIGNvbnN0YW50JyxcbiAgICAgICAgICAgICcoaWYgYHR5cGVgIGlzIHNldCB0byAqY29uc3RhbnQqKSBjb3JyZXNwb25kaW5nIHRvIHRoZSBsZW5ndGhzIG9mJyxcbiAgICAgICAgICAgICd0aGUgZXJyb3IgYmFycy4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICB2YWx1ZW1pbnVzOiB7XG4gICAgICAgIHZhbFR5cGU6ICdudW1iZXInLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIGRmbHQ6IDEwLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGVkaXRUeXBlOiAnY2FsYycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU2V0cyB0aGUgdmFsdWUgb2YgZWl0aGVyIHRoZSBwZXJjZW50YWdlJyxcbiAgICAgICAgICAgICcoaWYgYHR5cGVgIGlzIHNldCB0byAqcGVyY2VudCopIG9yIHRoZSBjb25zdGFudCcsXG4gICAgICAgICAgICAnKGlmIGB0eXBlYCBpcyBzZXQgdG8gKmNvbnN0YW50KikgY29ycmVzcG9uZGluZyB0byB0aGUgbGVuZ3RocyBvZicsXG4gICAgICAgICAgICAndGhlIGVycm9yIGJhcnMgaW4gdGhlJyxcbiAgICAgICAgICAgICdib3R0b20gKGxlZnQpIGRpcmVjdGlvbiBmb3IgdmVydGljYWwgKGhvcml6b250YWwpIGJhcnMnXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICB0cmFjZXJlZjoge1xuICAgICAgICB2YWxUeXBlOiAnaW50ZWdlcicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgZGZsdDogMCxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBlZGl0VHlwZTogJ3N0eWxlJ1xuICAgIH0sXG4gICAgdHJhY2VyZWZtaW51czoge1xuICAgICAgICB2YWxUeXBlOiAnaW50ZWdlcicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgZGZsdDogMCxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBlZGl0VHlwZTogJ3N0eWxlJ1xuICAgIH0sXG4gICAgY29weV95c3R5bGU6IHtcbiAgICAgICAgdmFsVHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICByb2xlOiAnc3R5bGUnLFxuICAgICAgICBlZGl0VHlwZTogJ3Bsb3QnXG4gICAgfSxcbiAgICBjb3B5X3pzdHlsZToge1xuICAgICAgICB2YWxUeXBlOiAnYm9vbGVhbicsXG4gICAgICAgIHJvbGU6ICdzdHlsZScsXG4gICAgICAgIGVkaXRUeXBlOiAnc3R5bGUnXG4gICAgfSxcbiAgICBjb2xvcjoge1xuICAgICAgICB2YWxUeXBlOiAnY29sb3InLFxuICAgICAgICByb2xlOiAnc3R5bGUnLFxuICAgICAgICBlZGl0VHlwZTogJ3N0eWxlJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdTZXRzIHRoZSBzdG9rZSBjb2xvciBvZiB0aGUgZXJyb3IgYmFycy4nXG4gICAgfSxcbiAgICB0aGlja25lc3M6IHtcbiAgICAgICAgdmFsVHlwZTogJ251bWJlcicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgZGZsdDogMixcbiAgICAgICAgcm9sZTogJ3N0eWxlJyxcbiAgICAgICAgZWRpdFR5cGU6ICdzdHlsZScsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU2V0cyB0aGUgdGhpY2tuZXNzIChpbiBweCkgb2YgdGhlIGVycm9yIGJhcnMuJ1xuICAgIH0sXG4gICAgd2lkdGg6IHtcbiAgICAgICAgdmFsVHlwZTogJ251bWJlcicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgcm9sZTogJ3N0eWxlJyxcbiAgICAgICAgZWRpdFR5cGU6ICdwbG90JyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSB3aWR0aCAoaW4gcHgpIG9mIHRoZSBjcm9zcy1iYXIgYXQgYm90aCBlbmRzJyxcbiAgICAgICAgICAgICdvZiB0aGUgZXJyb3IgYmFycy4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICBlZGl0VHlwZTogJ2NhbGMnLFxuXG4gICAgX2RlcHJlY2F0ZWQ6IHtcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgICAgdmFsVHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICByb2xlOiAnc3R5bGUnLFxuICAgICAgICAgICAgZWRpdFR5cGU6ICdzdHlsZScsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgICAgICdPYnNvbGV0ZS4nLFxuICAgICAgICAgICAgICAgICdVc2UgdGhlIGFscGhhIGNoYW5uZWwgaW4gZXJyb3IgYmFyIGBjb2xvcmAgdG8gc2V0IHRoZSBvcGFjaXR5LidcbiAgICAgICAgICAgIF0uam9pbignICcpXG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNOdW1lcmljID0gcmVxdWlyZSgnZmFzdC1pc251bWVyaWMnKTtcblxudmFyIFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi4vLi4vcmVnaXN0cnknKTtcbnZhciBBeGVzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuL2F4ZXMnKTtcbnZhciBMaWIgPSByZXF1aXJlKCcuLi8uLi9saWInKTtcblxudmFyIG1ha2VDb21wdXRlRXJyb3IgPSByZXF1aXJlKCcuL2NvbXB1dGVfZXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxjKGdkKSB7XG4gICAgdmFyIGNhbGNkYXRhID0gZ2QuY2FsY2RhdGE7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2FsY2RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNhbGNUcmFjZSA9IGNhbGNkYXRhW2ldO1xuICAgICAgICB2YXIgdHJhY2UgPSBjYWxjVHJhY2VbMF0udHJhY2U7XG5cbiAgICAgICAgaWYodHJhY2UudmlzaWJsZSA9PT0gdHJ1ZSAmJiBSZWdpc3RyeS50cmFjZUlzKHRyYWNlLCAnZXJyb3JCYXJzT0snKSkge1xuICAgICAgICAgICAgdmFyIHhhID0gQXhlcy5nZXRGcm9tSWQoZ2QsIHRyYWNlLnhheGlzKTtcbiAgICAgICAgICAgIHZhciB5YSA9IEF4ZXMuZ2V0RnJvbUlkKGdkLCB0cmFjZS55YXhpcyk7XG4gICAgICAgICAgICBjYWxjT25lQXhpcyhjYWxjVHJhY2UsIHRyYWNlLCB4YSwgJ3gnKTtcbiAgICAgICAgICAgIGNhbGNPbmVBeGlzKGNhbGNUcmFjZSwgdHJhY2UsIHlhLCAneScpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gY2FsY09uZUF4aXMoY2FsY1RyYWNlLCB0cmFjZSwgYXhpcywgY29vcmQpIHtcbiAgICB2YXIgb3B0cyA9IHRyYWNlWydlcnJvcl8nICsgY29vcmRdIHx8IHt9O1xuICAgIHZhciBpc1Zpc2libGUgPSAob3B0cy52aXNpYmxlICYmIFsnbGluZWFyJywgJ2xvZyddLmluZGV4T2YoYXhpcy50eXBlKSAhPT0gLTEpO1xuICAgIHZhciB2YWxzID0gW107XG5cbiAgICBpZighaXNWaXNpYmxlKSByZXR1cm47XG5cbiAgICB2YXIgY29tcHV0ZUVycm9yID0gbWFrZUNvbXB1dGVFcnJvcihvcHRzKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjYWxjVHJhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNhbGNQdCA9IGNhbGNUcmFjZVtpXTtcblxuICAgICAgICB2YXIgaUluID0gY2FsY1B0Lmk7XG5cbiAgICAgICAgLy8gZm9yIHR5cGVzIHRoYXQgZG9uJ3QgaW5jbHVkZSBgaWAgaW4gZWFjaCBjYWxjZGF0YSBwb2ludFxuICAgICAgICBpZihpSW4gPT09IHVuZGVmaW5lZCkgaUluID0gaTtcblxuICAgICAgICAvLyBmb3Igc3RhY2tlZCBhcmVhIGluc2VydGVkIHBvaW50c1xuICAgICAgICAvLyBUT0RPOiBlcnJvcmJhcnMgaGF2ZSBiZWVuIHRlc3RlZCBjdXJzb3JpbHkgd2l0aCBzdGFja2VkIGFyZWEsXG4gICAgICAgIC8vIGJ1dCBub3QgdGhvcm91Z2hseS4gSXQncyBub3QgZXZlbiByZWFsbHkgY2xlYXIgd2hhdCB5b3Ugd2FudCB0byBkbzpcbiAgICAgICAgLy8gU2hvdWxkIGl0IGp1c3QgYmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGF0IHRyYWNlJ3Mgc2l6ZSBkYXRhP1xuICAgICAgICAvLyBTaG91bGQgeW91IGFkZCBlcnJvcnMgZnJvbSBiZWxvdyBpbiBxdWFkcmF0dXJlP1xuICAgICAgICAvLyBBbmQgd2hhdCBhYm91dCBub3JtYWxpemF0aW9uLCB3aGVyZSBpbiBwcmluY2lwbGUgdGhlIGVycm9ycyBzaHJpbmtcbiAgICAgICAgLy8gYWdhaW4gd2hlbiB5b3UgZ2V0IHVwIHRvIHRoZSB0b3AgZW5kP1xuICAgICAgICAvLyBPbmUgb3B0aW9uIHdvdWxkIGJlIHRvIGZvcmJpZCBlcnJvcmJhcnMgd2l0aCBzdGFja2luZyB1bnRpbCB3ZVxuICAgICAgICAvLyBkZWNpZGUgaG93IHRvIGhhbmRsZSB0aGVzZSBxdWVzdGlvbnMuXG4gICAgICAgIGVsc2UgaWYoaUluID09PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgY2FsY0Nvb3JkID0gY2FsY1B0W2Nvb3JkXTtcblxuICAgICAgICBpZighaXNOdW1lcmljKGF4aXMuYzJsKGNhbGNDb29yZCkpKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgZXJyb3JzID0gY29tcHV0ZUVycm9yKGNhbGNDb29yZCwgaUluKTtcbiAgICAgICAgaWYoaXNOdW1lcmljKGVycm9yc1swXSkgJiYgaXNOdW1lcmljKGVycm9yc1sxXSkpIHtcbiAgICAgICAgICAgIHZhciBzaG9lID0gY2FsY1B0W2Nvb3JkICsgJ3MnXSA9IGNhbGNDb29yZCAtIGVycm9yc1swXTtcbiAgICAgICAgICAgIHZhciBoYXQgPSBjYWxjUHRbY29vcmQgKyAnaCddID0gY2FsY0Nvb3JkICsgZXJyb3JzWzFdO1xuICAgICAgICAgICAgdmFscy5wdXNoKHNob2UsIGhhdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXhJZCA9IGF4aXMuX2lkO1xuICAgIHZhciBiYXNlRXh0cmVtZXMgPSB0cmFjZS5fZXh0cmVtZXNbYXhJZF07XG4gICAgdmFyIGV4dHJlbWVzID0gQXhlcy5maW5kRXh0cmVtZXMoXG4gICAgICAgIGF4aXMsXG4gICAgICAgIHZhbHMsXG4gICAgICAgIExpYi5leHRlbmRGbGF0KHt0b3plcm86IGJhc2VFeHRyZW1lcy5vcHRzLnRvemVyb30sIHtwYWRkZWQ6IHRydWV9KVxuICAgICk7XG4gICAgYmFzZUV4dHJlbWVzLm1pbiA9IGJhc2VFeHRyZW1lcy5taW4uY29uY2F0KGV4dHJlbWVzLm1pbik7XG4gICAgYmFzZUV4dHJlbWVzLm1heCA9IGJhc2VFeHRyZW1lcy5tYXguY29uY2F0KGV4dHJlbWVzLm1heCk7XG59XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vKipcbiAqIEVycm9yIGJhciBjb21wdXRpbmcgZnVuY3Rpb24gZ2VuZXJhdG9yXG4gKlxuICogTi5CLiBUaGUgZ2VuZXJhdGVkIGZ1bmN0aW9uIGRvZXMgbm90IGNsZWFuIHRoZSBkYXRhUHQgZW50cmllcy4gTm9uLW51bWVyaWNcbiAqIGVudHJpZXMgcmVzdWx0IGluIHVuZGVmaW5lZCBlcnJvciBtYWduaXR1ZGVzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIGVycm9yIGJhciBhdHRyaWJ1dGVzXG4gKlxuICogQHJldHVybiB7ZnVuY3Rpb259IDpcbiAqICAgICAgQHBhcmFtIHtudW1lcmljfSBkYXRhUHQgZGF0YSBwb2ludCBmcm9tIHdoZXJlIHRvIGNvbXB1dGUgdGhlIGVycm9yIG1hZ25pdHVkZVxuICogICAgICBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXggb2YgZGF0YVB0IGluIGl0cyBjb3JyZXNwb25kaW5nIGRhdGEgYXJyYXlcbiAqICAgICAgQHJldHVybiB7YXJyYXl9XG4gKiAgICAgICAgLSBlcnJvclswXSA6IGVycm9yIG1hZ25pdHVkZSBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uXG4gKiAgICAgICAgLSBlcnJvclsxXSA6IFwiIFwiIFwiIFwiIHBvc2l0aXZlIFwiXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWFrZUNvbXB1dGVFcnJvcihvcHRzKSB7XG4gICAgdmFyIHR5cGUgPSBvcHRzLnR5cGU7XG4gICAgdmFyIHN5bW1ldHJpYyA9IG9wdHMuc3ltbWV0cmljO1xuXG4gICAgaWYodHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgIHZhciBhcnJheSA9IG9wdHMuYXJyYXkgfHwgW107XG5cbiAgICAgICAgaWYoc3ltbWV0cmljKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZUVycm9yKGRhdGFQdCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gKyhhcnJheVtpbmRleF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdmFsLCB2YWxdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcnJheW1pbnVzID0gb3B0cy5hcnJheW1pbnVzIHx8IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVFcnJvcihkYXRhUHQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9ICthcnJheVtpbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIHZhbE1pbnVzID0gK2FycmF5bWludXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vIGluIGNhc2Ugb25lIGlzIHByZXNlbnQgYW5kIHRoZSBvdGhlciBpcyBtaXNzaW5nLCBmaWxsIGluIDBcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBzdGlsbCBzZWUgdGhlIHByZXNlbnQgb25lLiBNb3N0bHkgdXNlZnVsIGR1cmluZyBtYW51YWxcbiAgICAgICAgICAgICAgICAvLyBkYXRhIGVudHJ5LlxuICAgICAgICAgICAgICAgIGlmKCFpc05hTih2YWwpIHx8ICFpc05hTih2YWxNaW51cykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt2YWxNaW51cyB8fCAwLCB2YWwgfHwgMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbTmFOLCBOYU5dO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb21wdXRlRXJyb3JWYWx1ZSA9IG1ha2VDb21wdXRlRXJyb3JWYWx1ZSh0eXBlLCBvcHRzLnZhbHVlKTtcbiAgICAgICAgdmFyIGNvbXB1dGVFcnJvclZhbHVlTWludXMgPSBtYWtlQ29tcHV0ZUVycm9yVmFsdWUodHlwZSwgb3B0cy52YWx1ZW1pbnVzKTtcblxuICAgICAgICBpZihzeW1tZXRyaWMgfHwgb3B0cy52YWx1ZW1pbnVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlRXJyb3IoZGF0YVB0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGNvbXB1dGVFcnJvclZhbHVlKGRhdGFQdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt2YWwsIHZhbF07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVFcnJvcihkYXRhUHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBjb21wdXRlRXJyb3JWYWx1ZU1pbnVzKGRhdGFQdCksXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVFcnJvclZhbHVlKGRhdGFQdClcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZSBlcnJvciBiYXIgbWFnbml0dWRlIChmb3IgYWxsIHR5cGVzIGV4Y2VwdCBkYXRhKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGVycm9yIGJhciB0eXBlXG4gKiBAcGFyYW0ge251bWVyaWN9IHZhbHVlIGVycm9yIGJhciB2YWx1ZVxuICpcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSA6XG4gKiAgICAgIEBwYXJhbSB7bnVtZXJpY30gZGF0YVB0XG4gKi9cbmZ1bmN0aW9uIG1ha2VDb21wdXRlRXJyb3JWYWx1ZSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmKHR5cGUgPT09ICdwZXJjZW50Jykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YVB0KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoZGF0YVB0ICogdmFsdWUgLyAxMDApO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZih0eXBlID09PSAnY29uc3RhbnQnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmKHR5cGUgPT09ICdzcXJ0Jykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YVB0KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGguYWJzKGRhdGFQdCkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzTnVtZXJpYyA9IHJlcXVpcmUoJ2Zhc3QtaXNudW1lcmljJyk7XG5cbnZhciBSZWdpc3RyeSA9IHJlcXVpcmUoJy4uLy4uL3JlZ2lzdHJ5Jyk7XG52YXIgTGliID0gcmVxdWlyZSgnLi4vLi4vbGliJyk7XG52YXIgVGVtcGxhdGUgPSByZXF1aXJlKCcuLi8uLi9wbG90X2FwaS9wbG90X3RlbXBsYXRlJyk7XG5cbnZhciBhdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0cmFjZUluLCB0cmFjZU91dCwgZGVmYXVsdENvbG9yLCBvcHRzKSB7XG4gICAgdmFyIG9iak5hbWUgPSAnZXJyb3JfJyArIG9wdHMuYXhpcztcbiAgICB2YXIgY29udGFpbmVyT3V0ID0gVGVtcGxhdGUubmV3Q29udGFpbmVyKHRyYWNlT3V0LCBvYmpOYW1lKTtcbiAgICB2YXIgY29udGFpbmVySW4gPSB0cmFjZUluW29iak5hbWVdIHx8IHt9O1xuXG4gICAgZnVuY3Rpb24gY29lcmNlKGF0dHIsIGRmbHQpIHtcbiAgICAgICAgcmV0dXJuIExpYi5jb2VyY2UoY29udGFpbmVySW4sIGNvbnRhaW5lck91dCwgYXR0cmlidXRlcywgYXR0ciwgZGZsdCk7XG4gICAgfVxuXG4gICAgdmFyIGhhc0Vycm9yQmFycyA9IChcbiAgICAgICAgY29udGFpbmVySW4uYXJyYXkgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBjb250YWluZXJJbi52YWx1ZSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGNvbnRhaW5lckluLnR5cGUgPT09ICdzcXJ0J1xuICAgICk7XG5cbiAgICB2YXIgdmlzaWJsZSA9IGNvZXJjZSgndmlzaWJsZScsIGhhc0Vycm9yQmFycyk7XG5cbiAgICBpZih2aXNpYmxlID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgdmFyIHR5cGUgPSBjb2VyY2UoJ3R5cGUnLCAnYXJyYXknIGluIGNvbnRhaW5lckluID8gJ2RhdGEnIDogJ3BlcmNlbnQnKTtcbiAgICB2YXIgc3ltbWV0cmljID0gdHJ1ZTtcblxuICAgIGlmKHR5cGUgIT09ICdzcXJ0Jykge1xuICAgICAgICBzeW1tZXRyaWMgPSBjb2VyY2UoJ3N5bW1ldHJpYycsXG4gICAgICAgICAgICAhKCh0eXBlID09PSAnZGF0YScgPyAnYXJyYXltaW51cycgOiAndmFsdWVtaW51cycpIGluIGNvbnRhaW5lckluKSk7XG4gICAgfVxuXG4gICAgaWYodHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgIGNvZXJjZSgnYXJyYXknKTtcbiAgICAgICAgY29lcmNlKCd0cmFjZXJlZicpO1xuICAgICAgICBpZighc3ltbWV0cmljKSB7XG4gICAgICAgICAgICBjb2VyY2UoJ2FycmF5bWludXMnKTtcbiAgICAgICAgICAgIGNvZXJjZSgndHJhY2VyZWZtaW51cycpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKHR5cGUgPT09ICdwZXJjZW50JyB8fCB0eXBlID09PSAnY29uc3RhbnQnKSB7XG4gICAgICAgIGNvZXJjZSgndmFsdWUnKTtcbiAgICAgICAgaWYoIXN5bW1ldHJpYykgY29lcmNlKCd2YWx1ZW1pbnVzJyk7XG4gICAgfVxuXG4gICAgdmFyIGNvcHlBdHRyID0gJ2NvcHlfJyArIG9wdHMuaW5oZXJpdCArICdzdHlsZSc7XG4gICAgaWYob3B0cy5pbmhlcml0KSB7XG4gICAgICAgIHZhciBpbmhlcml0T2JqID0gdHJhY2VPdXRbJ2Vycm9yXycgKyBvcHRzLmluaGVyaXRdO1xuICAgICAgICBpZigoaW5oZXJpdE9iaiB8fCB7fSkudmlzaWJsZSkge1xuICAgICAgICAgICAgY29lcmNlKGNvcHlBdHRyLCAhKGNvbnRhaW5lckluLmNvbG9yIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOdW1lcmljKGNvbnRhaW5lckluLnRoaWNrbmVzcykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc051bWVyaWMoY29udGFpbmVySW4ud2lkdGgpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYoIW9wdHMuaW5oZXJpdCB8fCAhY29udGFpbmVyT3V0W2NvcHlBdHRyXSkge1xuICAgICAgICBjb2VyY2UoJ2NvbG9yJywgZGVmYXVsdENvbG9yKTtcbiAgICAgICAgY29lcmNlKCd0aGlja25lc3MnKTtcbiAgICAgICAgY29lcmNlKCd3aWR0aCcsIFJlZ2lzdHJ5LnRyYWNlSXModHJhY2VPdXQsICdnbDNkJykgPyAwIDogNCk7XG4gICAgfVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xudmFyIG92ZXJyaWRlQWxsID0gcmVxdWlyZSgnLi4vLi4vcGxvdF9hcGkvZWRpdF90eXBlcycpLm92ZXJyaWRlQWxsO1xuXG52YXIgYXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpO1xuXG52YXIgeHlBdHRycyA9IHtcbiAgICBlcnJvcl94OiBMaWIuZXh0ZW5kRmxhdCh7fSwgYXR0cmlidXRlcyksXG4gICAgZXJyb3JfeTogTGliLmV4dGVuZEZsYXQoe30sIGF0dHJpYnV0ZXMpXG59O1xuZGVsZXRlIHh5QXR0cnMuZXJyb3JfeC5jb3B5X3pzdHlsZTtcbmRlbGV0ZSB4eUF0dHJzLmVycm9yX3kuY29weV96c3R5bGU7XG5kZWxldGUgeHlBdHRycy5lcnJvcl95LmNvcHlfeXN0eWxlO1xuXG52YXIgeHl6QXR0cnMgPSB7XG4gICAgZXJyb3JfeDogTGliLmV4dGVuZEZsYXQoe30sIGF0dHJpYnV0ZXMpLFxuICAgIGVycm9yX3k6IExpYi5leHRlbmRGbGF0KHt9LCBhdHRyaWJ1dGVzKSxcbiAgICBlcnJvcl96OiBMaWIuZXh0ZW5kRmxhdCh7fSwgYXR0cmlidXRlcylcbn07XG5kZWxldGUgeHl6QXR0cnMuZXJyb3JfeC5jb3B5X3lzdHlsZTtcbmRlbGV0ZSB4eXpBdHRycy5lcnJvcl95LmNvcHlfeXN0eWxlO1xuZGVsZXRlIHh5ekF0dHJzLmVycm9yX3ouY29weV95c3R5bGU7XG5kZWxldGUgeHl6QXR0cnMuZXJyb3Jfei5jb3B5X3pzdHlsZTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbW9kdWxlVHlwZTogJ2NvbXBvbmVudCcsXG4gICAgbmFtZTogJ2Vycm9yYmFycycsXG5cbiAgICBzY2hlbWE6IHtcbiAgICAgICAgdHJhY2VzOiB7XG4gICAgICAgICAgICBzY2F0dGVyOiB4eUF0dHJzLFxuICAgICAgICAgICAgYmFyOiB4eUF0dHJzLFxuICAgICAgICAgICAgaGlzdG9ncmFtOiB4eUF0dHJzLFxuICAgICAgICAgICAgc2NhdHRlcjNkOiBvdmVycmlkZUFsbCh4eXpBdHRycywgJ2NhbGMnLCAnbmVzdGVkJyksXG4gICAgICAgICAgICBzY2F0dGVyZ2w6IG92ZXJyaWRlQWxsKHh5QXR0cnMsICdjYWxjJywgJ25lc3RlZCcpXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc3VwcGx5RGVmYXVsdHM6IHJlcXVpcmUoJy4vZGVmYXVsdHMnKSxcblxuICAgIGNhbGM6IHJlcXVpcmUoJy4vY2FsYycpLFxuICAgIG1ha2VDb21wdXRlRXJyb3I6IHJlcXVpcmUoJy4vY29tcHV0ZV9lcnJvcicpLFxuXG4gICAgcGxvdDogcmVxdWlyZSgnLi9wbG90JyksXG4gICAgc3R5bGU6IHJlcXVpcmUoJy4vc3R5bGUnKSxcbiAgICBob3ZlckluZm86IGhvdmVySW5mb1xufTtcblxuZnVuY3Rpb24gaG92ZXJJbmZvKGNhbGNQb2ludCwgdHJhY2UsIGhvdmVyUG9pbnQpIHtcbiAgICBpZigodHJhY2UuZXJyb3JfeSB8fCB7fSkudmlzaWJsZSkge1xuICAgICAgICBob3ZlclBvaW50LnllcnIgPSBjYWxjUG9pbnQueWggLSBjYWxjUG9pbnQueTtcbiAgICAgICAgaWYoIXRyYWNlLmVycm9yX3kuc3ltbWV0cmljKSBob3ZlclBvaW50LnllcnJuZWcgPSBjYWxjUG9pbnQueSAtIGNhbGNQb2ludC55cztcbiAgICB9XG4gICAgaWYoKHRyYWNlLmVycm9yX3ggfHwge30pLnZpc2libGUpIHtcbiAgICAgICAgaG92ZXJQb2ludC54ZXJyID0gY2FsY1BvaW50LnhoIC0gY2FsY1BvaW50Lng7XG4gICAgICAgIGlmKCF0cmFjZS5lcnJvcl94LnN5bW1ldHJpYykgaG92ZXJQb2ludC54ZXJybmVnID0gY2FsY1BvaW50LnggLSBjYWxjUG9pbnQueHM7XG4gICAgfVxufVxuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkMyA9IHJlcXVpcmUoJ2QzJyk7XG52YXIgaXNOdW1lcmljID0gcmVxdWlyZSgnZmFzdC1pc251bWVyaWMnKTtcblxudmFyIERyYXdpbmcgPSByZXF1aXJlKCcuLi9kcmF3aW5nJyk7XG52YXIgc3ViVHlwZXMgPSByZXF1aXJlKCcuLi8uLi90cmFjZXMvc2NhdHRlci9zdWJ0eXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBsb3QoZ2QsIHRyYWNlcywgcGxvdGluZm8sIHRyYW5zaXRpb25PcHRzKSB7XG4gICAgdmFyIGlzTmV3O1xuXG4gICAgdmFyIHhhID0gcGxvdGluZm8ueGF4aXM7XG4gICAgdmFyIHlhID0gcGxvdGluZm8ueWF4aXM7XG5cbiAgICB2YXIgaGFzQW5pbWF0aW9uID0gdHJhbnNpdGlvbk9wdHMgJiYgdHJhbnNpdGlvbk9wdHMuZHVyYXRpb24gPiAwO1xuXG4gICAgdHJhY2VzLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICB2YXIgdHJhY2UgPSBkWzBdLnRyYWNlO1xuICAgICAgICAvLyB8fCB7fSBpcyBpbiBjYXNlIHRoZSB0cmFjZSAoc3BlY2lmaWNhbGx5IHNjYXR0ZXJ0ZXJuYXJ5KVxuICAgICAgICAvLyBkb2Vzbid0IHN1cHBvcnQgZXJyb3IgYmFycyBhdCBhbGwsIGJ1dCBkb2VzIGdvIHRocm91Z2hcbiAgICAgICAgLy8gdGhlIHNjYXR0ZXIucGxvdCBtZWNoYW5pY3MsIHdoaWNoIGNhbGxzIEVycm9yQmFycy5wbG90XG4gICAgICAgIC8vIGludGVybmFsbHlcbiAgICAgICAgdmFyIHhPYmogPSB0cmFjZS5lcnJvcl94IHx8IHt9O1xuICAgICAgICB2YXIgeU9iaiA9IHRyYWNlLmVycm9yX3kgfHwge307XG5cbiAgICAgICAgdmFyIGtleUZ1bmM7XG5cbiAgICAgICAgaWYodHJhY2UuaWRzKSB7XG4gICAgICAgICAgICBrZXlGdW5jID0gZnVuY3Rpb24oZCkge3JldHVybiBkLmlkO307XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3BhcnNlID0gKFxuICAgICAgICAgICAgc3ViVHlwZXMuaGFzTWFya2Vycyh0cmFjZSkgJiZcbiAgICAgICAgICAgIHRyYWNlLm1hcmtlci5tYXhkaXNwbGF5ZWQgPiAwXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYoIXlPYmoudmlzaWJsZSAmJiAheE9iai52aXNpYmxlKSBkID0gW107XG5cbiAgICAgICAgdmFyIGVycm9yYmFycyA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoJ2cuZXJyb3JiYXInKVxuICAgICAgICAgICAgLmRhdGEoZCwga2V5RnVuYyk7XG5cbiAgICAgICAgZXJyb3JiYXJzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICBpZighZC5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICBpZigheE9iai52aXNpYmxlKSBlcnJvcmJhcnMuc2VsZWN0QWxsKCdwYXRoLnhlcnJvcicpLnJlbW92ZSgpO1xuICAgICAgICBpZigheU9iai52aXNpYmxlKSBlcnJvcmJhcnMuc2VsZWN0QWxsKCdwYXRoLnllcnJvcicpLnJlbW92ZSgpO1xuXG4gICAgICAgIGVycm9yYmFycy5zdHlsZSgnb3BhY2l0eScsIDEpO1xuXG4gICAgICAgIHZhciBlbnRlciA9IGVycm9yYmFycy5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuY2xhc3NlZCgnZXJyb3JiYXInLCB0cnVlKTtcblxuICAgICAgICBpZihoYXNBbmltYXRpb24pIHtcbiAgICAgICAgICAgIGVudGVyLnN0eWxlKCdvcGFjaXR5JywgMCkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKHRyYW5zaXRpb25PcHRzLmR1cmF0aW9uKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgRHJhd2luZy5zZXRDbGlwVXJsKGVycm9yYmFycywgcGxvdGluZm8ubGF5ZXJDbGlwSWQsIGdkKTtcblxuICAgICAgICBlcnJvcmJhcnMuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JiYXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgY29vcmRzID0gZXJyb3JDb29yZHMoZCwgeGEsIHlhKTtcblxuICAgICAgICAgICAgaWYoc3BhcnNlICYmICFkLnZpcykgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgcGF0aDtcblxuICAgICAgICAgICAgdmFyIHllcnJvciA9IGVycm9yYmFyLnNlbGVjdCgncGF0aC55ZXJyb3InKTtcbiAgICAgICAgICAgIGlmKHlPYmoudmlzaWJsZSAmJiBpc051bWVyaWMoY29vcmRzLngpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzTnVtZXJpYyhjb29yZHMueWgpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzTnVtZXJpYyhjb29yZHMueXMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHl3ID0geU9iai53aWR0aDtcblxuICAgICAgICAgICAgICAgIHBhdGggPSAnTScgKyAoY29vcmRzLnggLSB5dykgKyAnLCcgK1xuICAgICAgICAgICAgICAgICAgICBjb29yZHMueWggKyAnaCcgKyAoMiAqIHl3KSArIC8vIGhhdFxuICAgICAgICAgICAgICAgICAgICAnbS0nICsgeXcgKyAnLDBWJyArIGNvb3Jkcy55czsgLy8gYmFyXG5cblxuICAgICAgICAgICAgICAgIGlmKCFjb29yZHMubm9ZUykgcGF0aCArPSAnbS0nICsgeXcgKyAnLDBoJyArICgyICogeXcpOyAvLyBzaG9lXG5cbiAgICAgICAgICAgICAgICBpc05ldyA9ICF5ZXJyb3Iuc2l6ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYoaXNOZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgeWVycm9yID0gZXJyb3JiYXIuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndmVjdG9yLWVmZmVjdCcsICdub24tc2NhbGluZy1zdHJva2UnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ3llcnJvcicsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihoYXNBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgeWVycm9yID0geWVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKHRyYW5zaXRpb25PcHRzLmR1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lYXNlKHRyYW5zaXRpb25PcHRzLmVhc2luZyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeWVycm9yLmF0dHIoJ2QnLCBwYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB5ZXJyb3IucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHZhciB4ZXJyb3IgPSBlcnJvcmJhci5zZWxlY3QoJ3BhdGgueGVycm9yJyk7XG4gICAgICAgICAgICBpZih4T2JqLnZpc2libGUgJiYgaXNOdW1lcmljKGNvb3Jkcy55KSAmJlxuICAgICAgICAgICAgICAgICAgICBpc051bWVyaWMoY29vcmRzLnhoKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc051bWVyaWMoY29vcmRzLnhzKSkge1xuICAgICAgICAgICAgICAgIHZhciB4dyA9ICh4T2JqLmNvcHlfeXN0eWxlID8geU9iaiA6IHhPYmopLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgcGF0aCA9ICdNJyArIGNvb3Jkcy54aCArICcsJyArXG4gICAgICAgICAgICAgICAgICAgIChjb29yZHMueSAtIHh3KSArICd2JyArICgyICogeHcpICsgLy8gaGF0XG4gICAgICAgICAgICAgICAgICAgICdtMCwtJyArIHh3ICsgJ0gnICsgY29vcmRzLnhzOyAvLyBiYXJcblxuICAgICAgICAgICAgICAgIGlmKCFjb29yZHMubm9YUykgcGF0aCArPSAnbTAsLScgKyB4dyArICd2JyArICgyICogeHcpOyAvLyBzaG9lXG5cbiAgICAgICAgICAgICAgICBpc05ldyA9ICF4ZXJyb3Iuc2l6ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYoaXNOZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgeGVycm9yID0gZXJyb3JiYXIuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndmVjdG9yLWVmZmVjdCcsICdub24tc2NhbGluZy1zdHJva2UnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ3hlcnJvcicsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihoYXNBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgeGVycm9yID0geGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKHRyYW5zaXRpb25PcHRzLmR1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lYXNlKHRyYW5zaXRpb25PcHRzLmVhc2luZyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeGVycm9yLmF0dHIoJ2QnLCBwYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB4ZXJyb3IucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLy8gY29tcHV0ZSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGVycm9yLWJhciBvYmplY3RzXG5mdW5jdGlvbiBlcnJvckNvb3JkcyhkLCB4YSwgeWEpIHtcbiAgICB2YXIgb3V0ID0ge1xuICAgICAgICB4OiB4YS5jMnAoZC54KSxcbiAgICAgICAgeTogeWEuYzJwKGQueSlcbiAgICB9O1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBlcnJvciBiYXIgc2l6ZSBhbmQgaGF0IGFuZCBzaG9lIGxvY2F0aW9uc1xuICAgIGlmKGQueWggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXQueWggPSB5YS5jMnAoZC55aCk7XG4gICAgICAgIG91dC55cyA9IHlhLmMycChkLnlzKTtcblxuICAgICAgICAvLyBpZiB0aGUgc2hvZXMgZ28gb2ZmLXNjYWxlIChpZSBsb2cgc2NhbGUsIGVycm9yIGJhcnMgcGFzdCB6ZXJvKVxuICAgICAgICAvLyBjbGlwIHRoZSBiYXIgYW5kIGhpZGUgdGhlIHNob2VzXG4gICAgICAgIGlmKCFpc051bWVyaWMob3V0LnlzKSkge1xuICAgICAgICAgICAgb3V0Lm5vWVMgPSB0cnVlO1xuICAgICAgICAgICAgb3V0LnlzID0geWEuYzJwKGQueXMsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoZC54aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dC54aCA9IHhhLmMycChkLnhoKTtcbiAgICAgICAgb3V0LnhzID0geGEuYzJwKGQueHMpO1xuXG4gICAgICAgIGlmKCFpc051bWVyaWMob3V0LnhzKSkge1xuICAgICAgICAgICAgb3V0Lm5vWFMgPSB0cnVlO1xuICAgICAgICAgICAgb3V0LnhzID0geGEuYzJwKGQueHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn1cbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZDMgPSByZXF1aXJlKCdkMycpO1xuXG52YXIgQ29sb3IgPSByZXF1aXJlKCcuLi9jb2xvcicpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3R5bGUodHJhY2VzKSB7XG4gICAgdHJhY2VzLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICB2YXIgdHJhY2UgPSBkWzBdLnRyYWNlO1xuICAgICAgICB2YXIgeU9iaiA9IHRyYWNlLmVycm9yX3kgfHwge307XG4gICAgICAgIHZhciB4T2JqID0gdHJhY2UuZXJyb3JfeCB8fCB7fTtcblxuICAgICAgICB2YXIgcyA9IGQzLnNlbGVjdCh0aGlzKTtcblxuICAgICAgICBzLnNlbGVjdEFsbCgncGF0aC55ZXJyb3InKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB5T2JqLnRoaWNrbmVzcyArICdweCcpXG4gICAgICAgICAgICAuY2FsbChDb2xvci5zdHJva2UsIHlPYmouY29sb3IpO1xuXG4gICAgICAgIGlmKHhPYmouY29weV95c3R5bGUpIHhPYmogPSB5T2JqO1xuXG4gICAgICAgIHMuc2VsZWN0QWxsKCdwYXRoLnhlcnJvcicpXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHhPYmoudGhpY2tuZXNzICsgJ3B4JylcbiAgICAgICAgICAgIC5jYWxsKENvbG9yLnN0cm9rZSwgeE9iai5jb2xvcik7XG4gICAgfSk7XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FydGVzaWFuQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuL2NvbnN0YW50cycpO1xudmFyIHRlbXBsYXRlZEFycmF5ID0gcmVxdWlyZSgnLi4vLi4vcGxvdF9hcGkvcGxvdF90ZW1wbGF0ZScpLnRlbXBsYXRlZEFycmF5O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGVkQXJyYXkoJ2ltYWdlJywge1xuICAgIHZpc2libGU6IHtcbiAgICAgICAgdmFsVHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGRmbHQ6IHRydWUsXG4gICAgICAgIGVkaXRUeXBlOiAnYXJyYXlkcmF3JyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaW1hZ2UgaXMgdmlzaWJsZS4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcblxuICAgIHNvdXJjZToge1xuICAgICAgICB2YWxUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBlZGl0VHlwZTogJ2FycmF5ZHJhdycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU3BlY2lmaWVzIHRoZSBVUkwgb2YgdGhlIGltYWdlIHRvIGJlIHVzZWQuJyxcbiAgICAgICAgICAgICdUaGUgVVJMIG11c3QgYmUgYWNjZXNzaWJsZSBmcm9tIHRoZSBkb21haW4gd2hlcmUgdGhlJyxcbiAgICAgICAgICAgICdwbG90IGNvZGUgaXMgcnVuLCBhbmQgY2FuIGJlIGVpdGhlciByZWxhdGl2ZSBvciBhYnNvbHV0ZS4nXG5cbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuXG4gICAgbGF5ZXI6IHtcbiAgICAgICAgdmFsVHlwZTogJ2VudW1lcmF0ZWQnLFxuICAgICAgICB2YWx1ZXM6IFsnYmVsb3cnLCAnYWJvdmUnXSxcbiAgICAgICAgZGZsdDogJ2Fib3ZlJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBlZGl0VHlwZTogJ2FycmF5ZHJhdycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU3BlY2lmaWVzIHdoZXRoZXIgaW1hZ2VzIGFyZSBkcmF3biBiZWxvdyBvciBhYm92ZSB0cmFjZXMuJyxcbiAgICAgICAgICAgICdXaGVuIGB4cmVmYCBhbmQgYHlyZWZgIGFyZSBib3RoIHNldCB0byBgcGFwZXJgLCcsXG4gICAgICAgICAgICAnaW1hZ2UgaXMgZHJhd24gYmVsb3cgdGhlIGVudGlyZSBwbG90IGFyZWEuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG5cbiAgICBzaXpleDoge1xuICAgICAgICB2YWxUeXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZmx0OiAwLFxuICAgICAgICBlZGl0VHlwZTogJ2FycmF5ZHJhdycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU2V0cyB0aGUgaW1hZ2UgY29udGFpbmVyIHNpemUgaG9yaXpvbnRhbGx5LicsXG4gICAgICAgICAgICAnVGhlIGltYWdlIHdpbGwgYmUgc2l6ZWQgYmFzZWQgb24gdGhlIGBwb3NpdGlvbmAgdmFsdWUuJyxcbiAgICAgICAgICAgICdXaGVuIGB4cmVmYCBpcyBzZXQgdG8gYHBhcGVyYCwgdW5pdHMgYXJlIHNpemVkIHJlbGF0aXZlJyxcbiAgICAgICAgICAgICd0byB0aGUgcGxvdCB3aWR0aC4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcblxuICAgIHNpemV5OiB7XG4gICAgICAgIHZhbFR5cGU6ICdudW1iZXInLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGRmbHQ6IDAsXG4gICAgICAgIGVkaXRUeXBlOiAnYXJyYXlkcmF3JyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSBpbWFnZSBjb250YWluZXIgc2l6ZSB2ZXJ0aWNhbGx5LicsXG4gICAgICAgICAgICAnVGhlIGltYWdlIHdpbGwgYmUgc2l6ZWQgYmFzZWQgb24gdGhlIGBwb3NpdGlvbmAgdmFsdWUuJyxcbiAgICAgICAgICAgICdXaGVuIGB5cmVmYCBpcyBzZXQgdG8gYHBhcGVyYCwgdW5pdHMgYXJlIHNpemVkIHJlbGF0aXZlJyxcbiAgICAgICAgICAgICd0byB0aGUgcGxvdCBoZWlnaHQuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG5cbiAgICBzaXppbmc6IHtcbiAgICAgICAgdmFsVHlwZTogJ2VudW1lcmF0ZWQnLFxuICAgICAgICB2YWx1ZXM6IFsnZmlsbCcsICdjb250YWluJywgJ3N0cmV0Y2gnXSxcbiAgICAgICAgZGZsdDogJ2NvbnRhaW4nLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGVkaXRUeXBlOiAnYXJyYXlkcmF3JyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTcGVjaWZpZXMgd2hpY2ggZGltZW5zaW9uIG9mIHRoZSBpbWFnZSB0byBjb25zdHJhaW4uJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG5cbiAgICBvcGFjaXR5OiB7XG4gICAgICAgIHZhbFR5cGU6ICdudW1iZXInLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAxLFxuICAgICAgICBkZmx0OiAxLFxuICAgICAgICBlZGl0VHlwZTogJ2FycmF5ZHJhdycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2UuJ1xuICAgIH0sXG5cbiAgICB4OiB7XG4gICAgICAgIHZhbFR5cGU6ICdhbnknLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGRmbHQ6IDAsXG4gICAgICAgIGVkaXRUeXBlOiAnYXJyYXlkcmF3JyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSBpbWFnZVxcJ3MgeCBwb3NpdGlvbi4nLFxuICAgICAgICAgICAgJ1doZW4gYHhyZWZgIGlzIHNldCB0byBgcGFwZXJgLCB1bml0cyBhcmUgc2l6ZWQgcmVsYXRpdmUnLFxuICAgICAgICAgICAgJ3RvIHRoZSBwbG90IGhlaWdodC4nLFxuICAgICAgICAgICAgJ1NlZSBgeHJlZmAgZm9yIG1vcmUgaW5mbydcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuXG4gICAgeToge1xuICAgICAgICB2YWxUeXBlOiAnYW55JyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZmx0OiAwLFxuICAgICAgICBlZGl0VHlwZTogJ2FycmF5ZHJhdycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU2V0cyB0aGUgaW1hZ2VcXCdzIHkgcG9zaXRpb24uJyxcbiAgICAgICAgICAgICdXaGVuIGB5cmVmYCBpcyBzZXQgdG8gYHBhcGVyYCwgdW5pdHMgYXJlIHNpemVkIHJlbGF0aXZlJyxcbiAgICAgICAgICAgICd0byB0aGUgcGxvdCBoZWlnaHQuJyxcbiAgICAgICAgICAgICdTZWUgYHlyZWZgIGZvciBtb3JlIGluZm8nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcblxuICAgIHhhbmNob3I6IHtcbiAgICAgICAgdmFsVHlwZTogJ2VudW1lcmF0ZWQnLFxuICAgICAgICB2YWx1ZXM6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXSxcbiAgICAgICAgZGZsdDogJ2xlZnQnLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGVkaXRUeXBlOiAnYXJyYXlkcmF3JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdTZXRzIHRoZSBhbmNob3IgZm9yIHRoZSB4IHBvc2l0aW9uJ1xuICAgIH0sXG5cbiAgICB5YW5jaG9yOiB7XG4gICAgICAgIHZhbFR5cGU6ICdlbnVtZXJhdGVkJyxcbiAgICAgICAgdmFsdWVzOiBbJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJ10sXG4gICAgICAgIGRmbHQ6ICd0b3AnLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGVkaXRUeXBlOiAnYXJyYXlkcmF3JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdTZXRzIHRoZSBhbmNob3IgZm9yIHRoZSB5IHBvc2l0aW9uLidcbiAgICB9LFxuXG4gICAgeHJlZjoge1xuICAgICAgICB2YWxUeXBlOiAnZW51bWVyYXRlZCcsXG4gICAgICAgIHZhbHVlczogW1xuICAgICAgICAgICAgJ3BhcGVyJyxcbiAgICAgICAgICAgIGNhcnRlc2lhbkNvbnN0YW50cy5pZFJlZ2V4LngudG9TdHJpbmcoKVxuICAgICAgICBdLFxuICAgICAgICBkZmx0OiAncGFwZXInLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGVkaXRUeXBlOiAnYXJyYXlkcmF3JyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSBpbWFnZXNcXCdzIHggY29vcmRpbmF0ZSBheGlzLicsXG4gICAgICAgICAgICAnSWYgc2V0IHRvIGEgeCBheGlzIGlkIChlLmcuICp4KiBvciAqeDIqKSwgdGhlIGB4YCBwb3NpdGlvbicsXG4gICAgICAgICAgICAncmVmZXJzIHRvIGFuIHggZGF0YSBjb29yZGluYXRlJyxcbiAgICAgICAgICAgICdJZiBzZXQgdG8gKnBhcGVyKiwgdGhlIGB4YCBwb3NpdGlvbiByZWZlcnMgdG8gdGhlIGRpc3RhbmNlIGZyb20nLFxuICAgICAgICAgICAgJ3RoZSBsZWZ0IG9mIHBsb3QgaW4gbm9ybWFsaXplZCBjb29yZGluYXRlcycsXG4gICAgICAgICAgICAnd2hlcmUgKjAqICgqMSopIGNvcnJlc3BvbmRzIHRvIHRoZSBsZWZ0IChyaWdodCkuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG5cbiAgICB5cmVmOiB7XG4gICAgICAgIHZhbFR5cGU6ICdlbnVtZXJhdGVkJyxcbiAgICAgICAgdmFsdWVzOiBbXG4gICAgICAgICAgICAncGFwZXInLFxuICAgICAgICAgICAgY2FydGVzaWFuQ29uc3RhbnRzLmlkUmVnZXgueS50b1N0cmluZygpXG4gICAgICAgIF0sXG4gICAgICAgIGRmbHQ6ICdwYXBlcicsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgZWRpdFR5cGU6ICdhcnJheWRyYXcnLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1NldHMgdGhlIGltYWdlc1xcJ3MgeSBjb29yZGluYXRlIGF4aXMuJyxcbiAgICAgICAgICAgICdJZiBzZXQgdG8gYSB5IGF4aXMgaWQgKGUuZy4gKnkqIG9yICp5MiopLCB0aGUgYHlgIHBvc2l0aW9uJyxcbiAgICAgICAgICAgICdyZWZlcnMgdG8gYSB5IGRhdGEgY29vcmRpbmF0ZS4nLFxuICAgICAgICAgICAgJ0lmIHNldCB0byAqcGFwZXIqLCB0aGUgYHlgIHBvc2l0aW9uIHJlZmVycyB0byB0aGUgZGlzdGFuY2UgZnJvbScsXG4gICAgICAgICAgICAndGhlIGJvdHRvbSBvZiB0aGUgcGxvdCBpbiBub3JtYWxpemVkIGNvb3JkaW5hdGVzJyxcbiAgICAgICAgICAgICd3aGVyZSAqMCogKCoxKikgY29ycmVzcG9uZHMgdG8gdGhlIGJvdHRvbSAodG9wKS4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICBlZGl0VHlwZTogJ2FycmF5ZHJhdydcbn0pO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc051bWVyaWMgPSByZXF1aXJlKCdmYXN0LWlzbnVtZXJpYycpO1xudmFyIHRvTG9nUmFuZ2UgPSByZXF1aXJlKCcuLi8uLi9saWIvdG9fbG9nX3JhbmdlJyk7XG5cbi8qXG4gKiBjb252ZXJ0Q29vcmRzOiB3aGVuIGNvbnZlcnRpbmcgYW4gYXhpcyBiZXR3ZWVuIGxvZyBhbmQgbGluZWFyXG4gKiB5b3UgbmVlZCB0byBhbHRlciBhbnkgaW1hZ2VzIG9uIHRoYXQgYXhpcyB0byBrZWVwIHRoZW1cbiAqIHBvaW50aW5nIGF0IHRoZSBzYW1lIGRhdGEgcG9pbnQuXG4gKiBJbiB2Mi4wIHRoaXMgd2lsbCBiZWNvbWUgb2Jzb2xldGUgKG9yIHBlcmhhcHMgc2l6ZSB3aWxsIHN0aWxsIG5lZWQgY29udmVyc2lvbj8pXG4gKiB3ZSBjb252ZXJ0IHNpemUgYnkgZGVjbGFyaW5nIHRoYXQgdGhlIG1heGltdW0gZXh0ZW50ICppbiBkYXRhIHVuaXRzKiBzaG91bGQgYmVcbiAqIHRoZSBzYW1lLCBhc3N1bWluZyB0aGUgaW1hZ2UgaXMgYW5jaG9yZWQgYnkgaXRzIGNlbnRlciAoY291bGQgcmVtb3ZlIHRoYXQgcmVzdHJpY3Rpb25cbiAqIGlmIHdlIHRoaW5rIGl0J3MgaW1wb3J0YW50KSBldmVuIHRob3VnaCB0aGUgYWN0dWFsIGxlZnQgYW5kIHJpZ2h0IHZhbHVlcyB3aWxsIG5vdCBiZVxuICogcXVpdGUgdGhlIHNhbWUgc2luY2UgdGhlIHNjYWxlIGJlY29tZXMgbm9ubGluZWFyIChhbmQgY2VudHJhbCBhbmNob3IgbWVhbnMgdGhlIHBpeGVsXG4gKiBjZW50ZXIgb2YgdGhlIGltYWdlLCBub3QgdGhlIGRhdGEgdW5pdHMgY2VudGVyKVxuICpcbiAqIGdkOiB0aGUgcGxvdCBkaXZcbiAqIGF4OiB0aGUgYXhpcyBiZWluZyBjaGFuZ2VkXG4gKiBuZXdUeXBlOiB0aGUgdHlwZSBpdCdzIGdldHRpbmdcbiAqIGRvRXh0cmE6IGZ1bmN0aW9uKGF0dHIsIHZhbCkgZnJvbSBpbnNpZGUgcmVsYXlvdXQgdGhhdCBzZXRzIHRoZSBhdHRyaWJ1dGUuXG4gKiAgICAgVXNlIHRoaXMgdG8gbWFrZSB0aGUgY2hhbmdlcyBhcyBpdCdzIGF3YXJlIGlmIGFueSBvdGhlciBjaGFuZ2VzIGluIHRoZVxuICogICAgIHNhbWUgcmVsYXlvdXQgY2FsbCBzaG91bGQgb3ZlcnJpZGUgdGhpcyBjb252ZXJzaW9uLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbnZlcnRDb29yZHMoZ2QsIGF4LCBuZXdUeXBlLCBkb0V4dHJhKSB7XG4gICAgYXggPSBheCB8fCB7fTtcblxuICAgIHZhciB0b0xvZyA9IChuZXdUeXBlID09PSAnbG9nJykgJiYgKGF4LnR5cGUgPT09ICdsaW5lYXInKTtcbiAgICB2YXIgZnJvbUxvZyA9IChuZXdUeXBlID09PSAnbGluZWFyJykgJiYgKGF4LnR5cGUgPT09ICdsb2cnKTtcblxuICAgIGlmKCEodG9Mb2cgfHwgZnJvbUxvZykpIHJldHVybjtcblxuICAgIHZhciBpbWFnZXMgPSBnZC5fZnVsbExheW91dC5pbWFnZXM7XG4gICAgdmFyIGF4TGV0dGVyID0gYXguX2lkLmNoYXJBdCgwKTtcbiAgICB2YXIgaW1hZ2U7XG4gICAgdmFyIGF0dHJQcmVmaXg7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGltYWdlID0gaW1hZ2VzW2ldO1xuICAgICAgICBhdHRyUHJlZml4ID0gJ2ltYWdlc1snICsgaSArICddLic7XG5cbiAgICAgICAgaWYoaW1hZ2VbYXhMZXR0ZXIgKyAncmVmJ10gPT09IGF4Ll9pZCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQb3MgPSBpbWFnZVtheExldHRlcl07XG4gICAgICAgICAgICB2YXIgY3VycmVudFNpemUgPSBpbWFnZVsnc2l6ZScgKyBheExldHRlcl07XG4gICAgICAgICAgICB2YXIgbmV3UG9zID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBuZXdTaXplID0gbnVsbDtcblxuICAgICAgICAgICAgaWYodG9Mb2cpIHtcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSB0b0xvZ1JhbmdlKGN1cnJlbnRQb3MsIGF4LnJhbmdlKTtcblxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbnZlcnNpb24gd2UgZG8gaW4gZnJvbUxvZyBiZWxvd1xuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGNvbnZlcnNpb24gaXMgcmV2ZXJzaWJsZSAobm90aWNlIHRoZSBmcm9tTG9nIGNvbnZlcnNpb25cbiAgICAgICAgICAgICAgICAvLyBpcyBsaWtlIHNpbmgsIGFuZCB0aGlzIG9uZSBsb29rcyBsaWtlIGFyY3NpbmgpXG4gICAgICAgICAgICAgICAgdmFyIGR4ID0gY3VycmVudFNpemUgLyBNYXRoLnBvdygxMCwgbmV3UG9zKSAvIDI7XG4gICAgICAgICAgICAgICAgbmV3U2l6ZSA9IDIgKiBNYXRoLmxvZyhkeCArIE1hdGguc3FydCgxICsgZHggKiBkeCkpIC8gTWF0aC5MTjEwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSBNYXRoLnBvdygxMCwgY3VycmVudFBvcyk7XG4gICAgICAgICAgICAgICAgbmV3U2l6ZSA9IG5ld1BvcyAqIChNYXRoLnBvdygxMCwgY3VycmVudFNpemUgLyAyKSAtIE1hdGgucG93KDEwLCAtY3VycmVudFNpemUgLyAyKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGNvbnZlcnNpb24gZmFpbGVkLCBkZWxldGUgdGhlIHZhbHVlIHNvIGl0IGNhbiBnZXQgYSBkZWZhdWx0IGxhdGVyIG9uXG4gICAgICAgICAgICBpZighaXNOdW1lcmljKG5ld1BvcykpIHtcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIG5ld1NpemUgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCFpc051bWVyaWMobmV3U2l6ZSkpIG5ld1NpemUgPSBudWxsO1xuXG4gICAgICAgICAgICBkb0V4dHJhKGF0dHJQcmVmaXggKyBheExldHRlciwgbmV3UG9zKTtcbiAgICAgICAgICAgIGRvRXh0cmEoYXR0clByZWZpeCArICdzaXplJyArIGF4TGV0dGVyLCBuZXdTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaWIgPSByZXF1aXJlKCcuLi8uLi9saWInKTtcbnZhciBBeGVzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuL2F4ZXMnKTtcbnZhciBoYW5kbGVBcnJheUNvbnRhaW5lckRlZmF1bHRzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvYXJyYXlfY29udGFpbmVyX2RlZmF1bHRzJyk7XG5cbnZhciBhdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyk7XG52YXIgbmFtZSA9ICdpbWFnZXMnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN1cHBseUxheW91dERlZmF1bHRzKGxheW91dEluLCBsYXlvdXRPdXQpIHtcbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgaGFuZGxlSXRlbURlZmF1bHRzOiBpbWFnZURlZmF1bHRzXG4gICAgfTtcblxuICAgIGhhbmRsZUFycmF5Q29udGFpbmVyRGVmYXVsdHMobGF5b3V0SW4sIGxheW91dE91dCwgb3B0cyk7XG59O1xuXG5cbmZ1bmN0aW9uIGltYWdlRGVmYXVsdHMoaW1hZ2VJbiwgaW1hZ2VPdXQsIGZ1bGxMYXlvdXQpIHtcbiAgICBmdW5jdGlvbiBjb2VyY2UoYXR0ciwgZGZsdCkge1xuICAgICAgICByZXR1cm4gTGliLmNvZXJjZShpbWFnZUluLCBpbWFnZU91dCwgYXR0cmlidXRlcywgYXR0ciwgZGZsdCk7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZSA9IGNvZXJjZSgnc291cmNlJyk7XG4gICAgdmFyIHZpc2libGUgPSBjb2VyY2UoJ3Zpc2libGUnLCAhIXNvdXJjZSk7XG5cbiAgICBpZighdmlzaWJsZSkgcmV0dXJuIGltYWdlT3V0O1xuXG4gICAgY29lcmNlKCdsYXllcicpO1xuICAgIGNvZXJjZSgneGFuY2hvcicpO1xuICAgIGNvZXJjZSgneWFuY2hvcicpO1xuICAgIGNvZXJjZSgnc2l6ZXgnKTtcbiAgICBjb2VyY2UoJ3NpemV5Jyk7XG4gICAgY29lcmNlKCdzaXppbmcnKTtcbiAgICBjb2VyY2UoJ29wYWNpdHknKTtcblxuICAgIHZhciBnZE1vY2sgPSB7IF9mdWxsTGF5b3V0OiBmdWxsTGF5b3V0IH07XG4gICAgdmFyIGF4TGV0dGVycyA9IFsneCcsICd5J107XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgIC8vICdwYXBlcicgaXMgdGhlIGZhbGxiYWNrIGF4cmVmXG4gICAgICAgIHZhciBheExldHRlciA9IGF4TGV0dGVyc1tpXTtcbiAgICAgICAgdmFyIGF4UmVmID0gQXhlcy5jb2VyY2VSZWYoaW1hZ2VJbiwgaW1hZ2VPdXQsIGdkTW9jaywgYXhMZXR0ZXIsICdwYXBlcicpO1xuXG4gICAgICAgIGlmKGF4UmVmICE9PSAncGFwZXInKSB7XG4gICAgICAgICAgICB2YXIgYXggPSBBeGVzLmdldEZyb21JZChnZE1vY2ssIGF4UmVmKTtcbiAgICAgICAgICAgIGF4Ll9pbWdJbmRpY2VzLnB1c2goaW1hZ2VPdXQuX2luZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIEF4ZXMuY29lcmNlUG9zaXRpb24oaW1hZ2VPdXQsIGdkTW9jaywgY29lcmNlLCBheFJlZiwgYXhMZXR0ZXIsIDApO1xuICAgIH1cblxuICAgIHJldHVybiBpbWFnZU91dDtcbn1cbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGQzID0gcmVxdWlyZSgnZDMnKTtcbnZhciBEcmF3aW5nID0gcmVxdWlyZSgnLi4vZHJhd2luZycpO1xudmFyIEF4ZXMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9jYXJ0ZXNpYW4vYXhlcycpO1xudmFyIHhtbG5zTmFtZXNwYWNlcyA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0YW50cy94bWxuc19uYW1lc3BhY2VzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZHJhdyhnZCkge1xuICAgIHZhciBmdWxsTGF5b3V0ID0gZ2QuX2Z1bGxMYXlvdXQ7XG4gICAgdmFyIGltYWdlRGF0YUFib3ZlID0gW107XG4gICAgdmFyIGltYWdlRGF0YVN1YnBsb3QgPSB7fTtcbiAgICB2YXIgaW1hZ2VEYXRhQmVsb3cgPSBbXTtcbiAgICB2YXIgc3VicGxvdDtcbiAgICB2YXIgaTtcblxuICAgIC8vIFNvcnQgaW50byB0b3AsIHN1YnBsb3QsIGFuZCBib3R0b20gbGF5ZXJzXG4gICAgZm9yKGkgPSAwOyBpIDwgZnVsbExheW91dC5pbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGltZyA9IGZ1bGxMYXlvdXQuaW1hZ2VzW2ldO1xuXG4gICAgICAgIGlmKGltZy52aXNpYmxlKSB7XG4gICAgICAgICAgICBpZihpbWcubGF5ZXIgPT09ICdiZWxvdycgJiYgaW1nLnhyZWYgIT09ICdwYXBlcicgJiYgaW1nLnlyZWYgIT09ICdwYXBlcicpIHtcbiAgICAgICAgICAgICAgICBzdWJwbG90ID0gaW1nLnhyZWYgKyBpbWcueXJlZjtcblxuICAgICAgICAgICAgICAgIHZhciBwbG90aW5mbyA9IGZ1bGxMYXlvdXQuX3Bsb3RzW3N1YnBsb3RdO1xuXG4gICAgICAgICAgICAgICAgaWYoIXBsb3RpbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBfaW1hZ2VMb3dlckxheWVyIGluIGNhc2UgdGhlIHJlcXVlc3RlZCBzdWJwbG90IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcmVmZXJlbmNlIHRoZSBpbWFnZSB0byBhbiB4IC8geSBheGlzIGNvbWJpbmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgZG9lc24ndCBoYXZlIGFueSBkYXRhIG9uIGl0IChhbmQgbGF5ZXIgaXMgYmVsb3cpXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YUJlbG93LnB1c2goaW1nKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYocGxvdGluZm8ubWFpbnBsb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VicGxvdCA9IHBsb3RpbmZvLm1haW5wbG90LmlkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKCFpbWFnZURhdGFTdWJwbG90W3N1YnBsb3RdKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YVN1YnBsb3Rbc3VicGxvdF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhU3VicGxvdFtzdWJwbG90XS5wdXNoKGltZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoaW1nLmxheWVyID09PSAnYWJvdmUnKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhQWJvdmUucHVzaChpbWcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbWFnZURhdGFCZWxvdy5wdXNoKGltZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHZhciBhbmNob3JzID0ge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgICBsZWZ0OiB7IHNpemluZzogJ3hNaW4nLCBvZmZzZXQ6IDAgfSxcbiAgICAgICAgICAgIGNlbnRlcjogeyBzaXppbmc6ICd4TWlkJywgb2Zmc2V0OiAtMSAvIDIgfSxcbiAgICAgICAgICAgIHJpZ2h0OiB7IHNpemluZzogJ3hNYXgnLCBvZmZzZXQ6IC0xIH1cbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgICAgdG9wOiB7IHNpemluZzogJ1lNaW4nLCBvZmZzZXQ6IDAgfSxcbiAgICAgICAgICAgIG1pZGRsZTogeyBzaXppbmc6ICdZTWlkJywgb2Zmc2V0OiAtMSAvIDIgfSxcbiAgICAgICAgICAgIGJvdHRvbTogeyBzaXppbmc6ICdZTWF4Jywgb2Zmc2V0OiAtMSB9XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvLyBJbWFnZXMgbXVzdCBiZSBjb252ZXJ0ZWQgdG8gZGF0YVVSTCdzIGZvciBleHBvcnRpbmcuXG4gICAgZnVuY3Rpb24gc2V0SW1hZ2UoZCkge1xuICAgICAgICB2YXIgdGhpc0ltYWdlID0gZDMuc2VsZWN0KHRoaXMpO1xuXG4gICAgICAgIGlmKHRoaXMuX2ltZ1NyYyA9PT0gZC5zb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNJbWFnZS5hdHRyKCd4bWxucycsIHhtbG5zTmFtZXNwYWNlcy5zdmcpO1xuXG4gICAgICAgIGlmKGQuc291cmNlICYmIGQuc291cmNlLnNsaWNlKDAsIDUpID09PSAnZGF0YTonKSB7XG4gICAgICAgICAgICB0aGlzSW1hZ2UuYXR0cigneGxpbms6aHJlZicsIGQuc291cmNlKTtcbiAgICAgICAgICAgIHRoaXMuX2ltZ1NyYyA9IGQuc291cmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGltYWdlUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbWcgPSBpbWc7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBub3Qgc2V0LCBhIGB0YWludGVkIGNhbnZhc2AgZXJyb3IgaXMgdGhyb3duXG4gICAgICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnY3Jvc3NPcmlnaW4nLCAnYW5vbnltb3VzJyk7XG4gICAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcywgMCwgMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzSW1hZ2UuYXR0cigneGxpbms6aHJlZicsIGRhdGFVUkwpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgcHJvbWlzZSBpbiBvbmxvYWQgaGFuZGxlciBpbnN0ZWFkIG9mIG9uICdsb2FkJyB0byBzdXBwb3J0IElFMTFcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wbG90bHkvcGxvdGx5LmpzL2lzc3Vlcy8xNjg1XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHNcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzSW1hZ2Uub24oJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcblxuICAgICAgICAgICAgICAgIGltZy5zcmMgPSBkLnNvdXJjZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWdTcmMgPSBkLnNvdXJjZTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVycm9ySGFuZGxlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0ltYWdlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgZ2QuX3Byb21pc2VzLnB1c2goaW1hZ2VQcm9taXNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlcyhkKSB7XG4gICAgICAgIHZhciB0aGlzSW1hZ2UgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgLy8gQXhlcyBpZiBzcGVjaWZpZWRcbiAgICAgICAgdmFyIHhhID0gQXhlcy5nZXRGcm9tSWQoZ2QsIGQueHJlZik7XG4gICAgICAgIHZhciB5YSA9IEF4ZXMuZ2V0RnJvbUlkKGdkLCBkLnlyZWYpO1xuXG4gICAgICAgIHZhciBzaXplID0gZnVsbExheW91dC5fc2l6ZTtcbiAgICAgICAgdmFyIHdpZHRoID0geGEgPyBNYXRoLmFicyh4YS5sMnAoZC5zaXpleCkgLSB4YS5sMnAoMCkpIDogZC5zaXpleCAqIHNpemUudztcbiAgICAgICAgdmFyIGhlaWdodCA9IHlhID8gTWF0aC5hYnMoeWEubDJwKGQuc2l6ZXkpIC0geWEubDJwKDApKSA6IGQuc2l6ZXkgKiBzaXplLmg7XG5cbiAgICAgICAgLy8gT2Zmc2V0cyBmb3IgYW5jaG9yIHBvc2l0aW9uaW5nXG4gICAgICAgIHZhciB4T2Zmc2V0ID0gd2lkdGggKiBhbmNob3JzLnhbZC54YW5jaG9yXS5vZmZzZXQ7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gaGVpZ2h0ICogYW5jaG9ycy55W2QueWFuY2hvcl0ub2Zmc2V0O1xuXG4gICAgICAgIHZhciBzaXppbmcgPSBhbmNob3JzLnhbZC54YW5jaG9yXS5zaXppbmcgKyBhbmNob3JzLnlbZC55YW5jaG9yXS5zaXppbmc7XG5cbiAgICAgICAgLy8gRmluYWwgcG9zaXRpb25zXG4gICAgICAgIHZhciB4UG9zID0gKHhhID8geGEucjJwKGQueCkgKyB4YS5fb2Zmc2V0IDogZC54ICogc2l6ZS53ICsgc2l6ZS5sKSArIHhPZmZzZXQ7XG4gICAgICAgIHZhciB5UG9zID0gKHlhID8geWEucjJwKGQueSkgKyB5YS5fb2Zmc2V0IDogc2l6ZS5oIC0gZC55ICogc2l6ZS5oICsgc2l6ZS50KSArIHlPZmZzZXQ7XG5cbiAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBwcm9wZXIgYXNwZWN0UmF0aW8gYXR0cmlidXRlXG4gICAgICAgIHN3aXRjaChkLnNpemluZykge1xuICAgICAgICAgICAgY2FzZSAnZmlsbCc6XG4gICAgICAgICAgICAgICAgc2l6aW5nICs9ICcgc2xpY2UnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzdHJldGNoJzpcbiAgICAgICAgICAgICAgICBzaXppbmcgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzSW1hZ2UuYXR0cih7XG4gICAgICAgICAgICB4OiB4UG9zLFxuICAgICAgICAgICAgeTogeVBvcyxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogc2l6aW5nLFxuICAgICAgICAgICAgb3BhY2l0eTogZC5vcGFjaXR5XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgLy8gU2V0IHByb3BlciBjbGlwcGluZyBvbiBpbWFnZXNcbiAgICAgICAgdmFyIHhJZCA9IHhhID8geGEuX2lkIDogJyc7XG4gICAgICAgIHZhciB5SWQgPSB5YSA/IHlhLl9pZCA6ICcnO1xuICAgICAgICB2YXIgY2xpcEF4ZXMgPSB4SWQgKyB5SWQ7XG5cbiAgICAgICAgRHJhd2luZy5zZXRDbGlwVXJsKFxuICAgICAgICAgICAgdGhpc0ltYWdlLFxuICAgICAgICAgICAgY2xpcEF4ZXMgPyAoJ2NsaXAnICsgZnVsbExheW91dC5fdWlkICsgY2xpcEF4ZXMpIDogbnVsbCxcbiAgICAgICAgICAgIGdkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGltYWdlc0JlbG93ID0gZnVsbExheW91dC5faW1hZ2VMb3dlckxheWVyLnNlbGVjdEFsbCgnaW1hZ2UnKVxuICAgICAgICAuZGF0YShpbWFnZURhdGFCZWxvdyk7XG4gICAgdmFyIGltYWdlc0Fib3ZlID0gZnVsbExheW91dC5faW1hZ2VVcHBlckxheWVyLnNlbGVjdEFsbCgnaW1hZ2UnKVxuICAgICAgICAuZGF0YShpbWFnZURhdGFBYm92ZSk7XG5cbiAgICBpbWFnZXNCZWxvdy5lbnRlcigpLmFwcGVuZCgnaW1hZ2UnKTtcbiAgICBpbWFnZXNBYm92ZS5lbnRlcigpLmFwcGVuZCgnaW1hZ2UnKTtcblxuICAgIGltYWdlc0JlbG93LmV4aXQoKS5yZW1vdmUoKTtcbiAgICBpbWFnZXNBYm92ZS5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICBpbWFnZXNCZWxvdy5lYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgc2V0SW1hZ2UuYmluZCh0aGlzKShkKTtcbiAgICAgICAgYXBwbHlBdHRyaWJ1dGVzLmJpbmQodGhpcykoZCk7XG4gICAgfSk7XG4gICAgaW1hZ2VzQWJvdmUuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgIHNldEltYWdlLmJpbmQodGhpcykoZCk7XG4gICAgICAgIGFwcGx5QXR0cmlidXRlcy5iaW5kKHRoaXMpKGQpO1xuICAgIH0pO1xuXG4gICAgdmFyIGFsbFN1YnBsb3RzID0gT2JqZWN0LmtleXMoZnVsbExheW91dC5fcGxvdHMpO1xuICAgIGZvcihpID0gMDsgaSA8IGFsbFN1YnBsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1YnBsb3QgPSBhbGxTdWJwbG90c1tpXTtcbiAgICAgICAgdmFyIHN1YnBsb3RPYmogPSBmdWxsTGF5b3V0Ll9wbG90c1tzdWJwbG90XTtcblxuICAgICAgICAvLyBmaWx0ZXIgb3V0IG92ZXJsYWlkIHBsb3RzICh3aGljaCBoYXZkIHRoZWlyIGltYWdlcyBvbiB0aGUgbWFpbiBwbG90KVxuICAgICAgICAvLyBhbmQgZ2wyZCBwbG90cyAod2hpY2ggZG9uJ3Qgc3VwcG9ydCBiZWxvdyBpbWFnZXMsIGF0IGxlYXN0IG5vdCB5ZXQpXG4gICAgICAgIGlmKCFzdWJwbG90T2JqLmltYWdlbGF5ZXIpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBpbWFnZXNPblN1YnBsb3QgPSBzdWJwbG90T2JqLmltYWdlbGF5ZXIuc2VsZWN0QWxsKCdpbWFnZScpXG4gICAgICAgICAgICAvLyBldmVuIGlmIHRoZXJlIGFyZSBubyBpbWFnZXMgb24gdGhpcyBzdWJwbG90LCB3ZSBuZWVkIHRvIHJ1blxuICAgICAgICAgICAgLy8gZW50ZXIgYW5kIGV4aXQgaW4gY2FzZSB0aGVyZSB3ZXJlIHByZXZpb3VzbHlcbiAgICAgICAgICAgIC5kYXRhKGltYWdlRGF0YVN1YnBsb3Rbc3VicGxvdF0gfHwgW10pO1xuXG4gICAgICAgIGltYWdlc09uU3VicGxvdC5lbnRlcigpLmFwcGVuZCgnaW1hZ2UnKTtcbiAgICAgICAgaW1hZ2VzT25TdWJwbG90LmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICBpbWFnZXNPblN1YnBsb3QuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBzZXRJbWFnZS5iaW5kKHRoaXMpKGQpO1xuICAgICAgICAgICAgYXBwbHlBdHRyaWJ1dGVzLmJpbmQodGhpcykoZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1vZHVsZVR5cGU6ICdjb21wb25lbnQnLFxuICAgIG5hbWU6ICdpbWFnZXMnLFxuXG4gICAgbGF5b3V0QXR0cmlidXRlczogcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyksXG4gICAgc3VwcGx5TGF5b3V0RGVmYXVsdHM6IHJlcXVpcmUoJy4vZGVmYXVsdHMnKSxcbiAgICBpbmNsdWRlQmFzZVBsb3Q6IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2NhcnRlc2lhbi9pbmNsdWRlX2NvbXBvbmVudHMnKSgnaW1hZ2VzJyksXG5cbiAgICBkcmF3OiByZXF1aXJlKCcuL2RyYXcnKSxcblxuICAgIGNvbnZlcnRDb29yZHM6IHJlcXVpcmUoJy4vY29udmVydF9jb29yZHMnKVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1vZHVsZVR5cGU6ICdjb21wb25lbnQnLFxuICAgIG5hbWU6ICdsZWdlbmQnLFxuXG4gICAgbGF5b3V0QXR0cmlidXRlczogcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyksXG4gICAgc3VwcGx5TGF5b3V0RGVmYXVsdHM6IHJlcXVpcmUoJy4vZGVmYXVsdHMnKSxcblxuICAgIGRyYXc6IHJlcXVpcmUoJy4vZHJhdycpLFxuICAgIHN0eWxlOiByZXF1aXJlKCcuL3N0eWxlJylcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBmb250QXR0cnMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9mb250X2F0dHJpYnV0ZXMnKTtcbnZhciBjb2xvckF0dHJzID0gcmVxdWlyZSgnLi4vY29sb3IvYXR0cmlidXRlcycpO1xudmFyIHRlbXBsYXRlZEFycmF5ID0gcmVxdWlyZSgnLi4vLi4vcGxvdF9hcGkvcGxvdF90ZW1wbGF0ZScpLnRlbXBsYXRlZEFycmF5O1xuXG52YXIgYnV0dG9uQXR0cnMgPSB0ZW1wbGF0ZWRBcnJheSgnYnV0dG9uJywge1xuICAgIHZpc2libGU6IHtcbiAgICAgICAgdmFsVHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGRmbHQ6IHRydWUsXG4gICAgICAgIGVkaXRUeXBlOiAncGxvdCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGJ1dHRvbiBpcyB2aXNpYmxlLidcbiAgICB9LFxuICAgIHN0ZXA6IHtcbiAgICAgICAgdmFsVHlwZTogJ2VudW1lcmF0ZWQnLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIHZhbHVlczogWydtb250aCcsICd5ZWFyJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnYWxsJ10sXG4gICAgICAgIGRmbHQ6ICdtb250aCcsXG4gICAgICAgIGVkaXRUeXBlOiAncGxvdCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnVGhlIHVuaXQgb2YgbWVhc3VyZW1lbnQgdGhhdCB0aGUgYGNvdW50YCB2YWx1ZSB3aWxsIHNldCB0aGUgcmFuZ2UgYnkuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgc3RlcG1vZGU6IHtcbiAgICAgICAgdmFsVHlwZTogJ2VudW1lcmF0ZWQnLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIHZhbHVlczogWydiYWNrd2FyZCcsICd0b2RhdGUnXSxcbiAgICAgICAgZGZsdDogJ2JhY2t3YXJkJyxcbiAgICAgICAgZWRpdFR5cGU6ICdwbG90JyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSByYW5nZSB1cGRhdGUgbW9kZS4nLFxuICAgICAgICAgICAgJ0lmICpiYWNrd2FyZCosIHRoZSByYW5nZSB1cGRhdGUgc2hpZnRzIHRoZSBzdGFydCBvZiByYW5nZScsXG4gICAgICAgICAgICAnYmFjayAqY291bnQqIHRpbWVzICpzdGVwKiBtaWxsaXNlY29uZHMuJyxcbiAgICAgICAgICAgICdJZiAqdG9kYXRlKiwgdGhlIHJhbmdlIHVwZGF0ZSBzaGlmdHMgdGhlIHN0YXJ0IG9mIHJhbmdlJyxcbiAgICAgICAgICAgICdiYWNrIHRvIHRoZSBmaXJzdCB0aW1lc3RhbXAgZnJvbSAqY291bnQqIHRpbWVzJyxcbiAgICAgICAgICAgICcqc3RlcCogbWlsbGlzZWNvbmRzIGJhY2suJyxcbiAgICAgICAgICAgICdGb3IgZXhhbXBsZSwgd2l0aCBgc3RlcGAgc2V0IHRvICp5ZWFyKiBhbmQgYGNvdW50YCBzZXQgdG8gKjEqJyxcbiAgICAgICAgICAgICd0aGUgcmFuZ2UgdXBkYXRlIHNoaWZ0cyB0aGUgc3RhcnQgb2YgdGhlIHJhbmdlIGJhY2sgdG8nLFxuICAgICAgICAgICAgJ0phbnVhcnkgMDEgb2YgdGhlIGN1cnJlbnQgeWVhci4nLFxuICAgICAgICAgICAgJ01vbnRoIGFuZCB5ZWFyICp0b2RhdGUqIGFyZSBjdXJyZW50bHkgYXZhaWxhYmxlIG9ubHknLFxuICAgICAgICAgICAgJ2ZvciB0aGUgYnVpbHQtaW4gKEdyZWdvcmlhbikgY2FsZW5kYXIuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgY291bnQ6IHtcbiAgICAgICAgdmFsVHlwZTogJ251bWJlcicsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBkZmx0OiAxLFxuICAgICAgICBlZGl0VHlwZTogJ3Bsb3QnLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1NldHMgdGhlIG51bWJlciBvZiBzdGVwcyB0byB0YWtlIHRvIHVwZGF0ZSB0aGUgcmFuZ2UuJyxcbiAgICAgICAgICAgICdVc2Ugd2l0aCBgc3RlcGAgdG8gc3BlY2lmeSB0aGUgdXBkYXRlIGludGVydmFsLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICAgIHZhbFR5cGU6ICdzdHJpbmcnLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGVkaXRUeXBlOiAncGxvdCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU2V0cyB0aGUgdGV4dCBsYWJlbCB0byBhcHBlYXIgb24gdGhlIGJ1dHRvbi4nXG4gICAgfSxcbiAgICBlZGl0VHlwZTogJ3Bsb3QnLFxuICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICdTZXRzIHRoZSBzcGVjaWZpY2F0aW9ucyBmb3IgZWFjaCBidXR0b25zLicsXG4gICAgICAgICdCeSBkZWZhdWx0LCBhIHJhbmdlIHNlbGVjdG9yIGNvbWVzIHdpdGggbm8gYnV0dG9ucy4nXG4gICAgXS5qb2luKCcgJylcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB2aXNpYmxlOiB7XG4gICAgICAgIHZhbFR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBlZGl0VHlwZTogJ3Bsb3QnLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ0RldGVybWluZXMgd2hldGhlciBvciBub3QgdGhpcyByYW5nZSBzZWxlY3RvciBpcyB2aXNpYmxlLicsXG4gICAgICAgICAgICAnTm90ZSB0aGF0IHJhbmdlIHNlbGVjdG9ycyBhcmUgb25seSBhdmFpbGFibGUgZm9yIHggYXhlcyBvZicsXG4gICAgICAgICAgICAnYHR5cGVgIHNldCB0byBvciBhdXRvLXR5cGVkIHRvICpkYXRlKi4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcblxuICAgIGJ1dHRvbnM6IGJ1dHRvbkF0dHJzLFxuXG4gICAgeDoge1xuICAgICAgICB2YWxUeXBlOiAnbnVtYmVyJyxcbiAgICAgICAgbWluOiAtMixcbiAgICAgICAgbWF4OiAzLFxuICAgICAgICByb2xlOiAnc3R5bGUnLFxuICAgICAgICBlZGl0VHlwZTogJ3Bsb3QnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIHggcG9zaXRpb24gKGluIG5vcm1hbGl6ZWQgY29vcmRpbmF0ZXMpIG9mIHRoZSByYW5nZSBzZWxlY3Rvci4nXG4gICAgfSxcbiAgICB4YW5jaG9yOiB7XG4gICAgICAgIHZhbFR5cGU6ICdlbnVtZXJhdGVkJyxcbiAgICAgICAgdmFsdWVzOiBbJ2F1dG8nLCAnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXSxcbiAgICAgICAgZGZsdDogJ2xlZnQnLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGVkaXRUeXBlOiAncGxvdCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU2V0cyB0aGUgcmFuZ2Ugc2VsZWN0b3JcXCdzIGhvcml6b250YWwgcG9zaXRpb24gYW5jaG9yLicsXG4gICAgICAgICAgICAnVGhpcyBhbmNob3IgYmluZHMgdGhlIGB4YCBwb3NpdGlvbiB0byB0aGUgKmxlZnQqLCAqY2VudGVyKicsXG4gICAgICAgICAgICAnb3IgKnJpZ2h0KiBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgeToge1xuICAgICAgICB2YWxUeXBlOiAnbnVtYmVyJyxcbiAgICAgICAgbWluOiAtMixcbiAgICAgICAgbWF4OiAzLFxuICAgICAgICByb2xlOiAnc3R5bGUnLFxuICAgICAgICBlZGl0VHlwZTogJ3Bsb3QnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIHkgcG9zaXRpb24gKGluIG5vcm1hbGl6ZWQgY29vcmRpbmF0ZXMpIG9mIHRoZSByYW5nZSBzZWxlY3Rvci4nXG4gICAgfSxcbiAgICB5YW5jaG9yOiB7XG4gICAgICAgIHZhbFR5cGU6ICdlbnVtZXJhdGVkJyxcbiAgICAgICAgdmFsdWVzOiBbJ2F1dG8nLCAndG9wJywgJ21pZGRsZScsICdib3R0b20nXSxcbiAgICAgICAgZGZsdDogJ2JvdHRvbScsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgZWRpdFR5cGU6ICdwbG90JyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSByYW5nZSBzZWxlY3RvclxcJ3MgdmVydGljYWwgcG9zaXRpb24gYW5jaG9yJyxcbiAgICAgICAgICAgICdUaGlzIGFuY2hvciBiaW5kcyB0aGUgYHlgIHBvc2l0aW9uIHRvIHRoZSAqdG9wKiwgKm1pZGRsZSonLFxuICAgICAgICAgICAgJ29yICpib3R0b20qIG9mIHRoZSByYW5nZSBzZWxlY3Rvci4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcblxuICAgIGZvbnQ6IGZvbnRBdHRycyh7XG4gICAgICAgIGVkaXRUeXBlOiAncGxvdCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU2V0cyB0aGUgZm9udCBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IgYnV0dG9uIHRleHQuJ1xuICAgIH0pLFxuXG4gICAgYmdjb2xvcjoge1xuICAgICAgICB2YWxUeXBlOiAnY29sb3InLFxuICAgICAgICBkZmx0OiBjb2xvckF0dHJzLmxpZ2h0TGluZSxcbiAgICAgICAgcm9sZTogJ3N0eWxlJyxcbiAgICAgICAgZWRpdFR5cGU6ICdwbG90JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdTZXRzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSByYW5nZSBzZWxlY3RvciBidXR0b25zLidcbiAgICB9LFxuICAgIGFjdGl2ZWNvbG9yOiB7XG4gICAgICAgIHZhbFR5cGU6ICdjb2xvcicsXG4gICAgICAgIHJvbGU6ICdzdHlsZScsXG4gICAgICAgIGVkaXRUeXBlOiAncGxvdCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU2V0cyB0aGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgYWN0aXZlIHJhbmdlIHNlbGVjdG9yIGJ1dHRvbi4nXG4gICAgfSxcbiAgICBib3JkZXJjb2xvcjoge1xuICAgICAgICB2YWxUeXBlOiAnY29sb3InLFxuICAgICAgICBkZmx0OiBjb2xvckF0dHJzLmRlZmF1bHRMaW5lLFxuICAgICAgICByb2xlOiAnc3R5bGUnLFxuICAgICAgICBlZGl0VHlwZTogJ3Bsb3QnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIGNvbG9yIG9mIHRoZSBib3JkZXIgZW5jbG9zaW5nIHRoZSByYW5nZSBzZWxlY3Rvci4nXG4gICAgfSxcbiAgICBib3JkZXJ3aWR0aDoge1xuICAgICAgICB2YWxUeXBlOiAnbnVtYmVyJyxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBkZmx0OiAwLFxuICAgICAgICByb2xlOiAnc3R5bGUnLFxuICAgICAgICBlZGl0VHlwZTogJ3Bsb3QnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIHdpZHRoIChpbiBweCkgb2YgdGhlIGJvcmRlciBlbmNsb3NpbmcgdGhlIHJhbmdlIHNlbGVjdG9yLidcbiAgICB9LFxuICAgIGVkaXRUeXBlOiAncGxvdCdcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAvLyAneScgcG9zaXRpb24gcGFkIGFib3ZlIGNvdW50ZXIgYXhpcyBkb21haW5cbiAgICB5UGFkOiAwLjAyLFxuXG4gICAgLy8gbWluaW11bSBidXR0b24gd2lkdGggKHJlZ2FyZGxlc3Mgb2YgdGV4dCBzaXplKVxuICAgIG1pbkJ1dHRvbldpZHRoOiAzMCxcblxuICAgIC8vIGJ1dHRvbnMgcmVjdCByYWRpaVxuICAgIHJ4OiAzLFxuICAgIHJ5OiAzLFxuXG4gICAgLy8gbGlnaHQgZnJhY3Rpb24gdXNlZCB0byBjb21wdXRlIHRoZSAnYWN0aXZlY29sb3InIGRlZmF1bHRcbiAgICBsaWdodEFtb3VudDogMjUsXG4gICAgZGFya0Ftb3VudDogMTBcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaWIgPSByZXF1aXJlKCcuLi8uLi9saWInKTtcbnZhciBDb2xvciA9IHJlcXVpcmUoJy4uL2NvbG9yJyk7XG52YXIgVGVtcGxhdGUgPSByZXF1aXJlKCcuLi8uLi9wbG90X2FwaS9wbG90X3RlbXBsYXRlJyk7XG52YXIgaGFuZGxlQXJyYXlDb250YWluZXJEZWZhdWx0cyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2FycmF5X2NvbnRhaW5lcl9kZWZhdWx0cycpO1xuXG52YXIgYXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYW5kbGVEZWZhdWx0cyhjb250YWluZXJJbiwgY29udGFpbmVyT3V0LCBsYXlvdXQsIGNvdW50ZXJBeGVzLCBjYWxlbmRhcikge1xuICAgIHZhciBzZWxlY3RvckluID0gY29udGFpbmVySW4ucmFuZ2VzZWxlY3RvciB8fCB7fTtcbiAgICB2YXIgc2VsZWN0b3JPdXQgPSBUZW1wbGF0ZS5uZXdDb250YWluZXIoY29udGFpbmVyT3V0LCAncmFuZ2VzZWxlY3RvcicpO1xuXG4gICAgZnVuY3Rpb24gY29lcmNlKGF0dHIsIGRmbHQpIHtcbiAgICAgICAgcmV0dXJuIExpYi5jb2VyY2Uoc2VsZWN0b3JJbiwgc2VsZWN0b3JPdXQsIGF0dHJpYnV0ZXMsIGF0dHIsIGRmbHQpO1xuICAgIH1cblxuICAgIHZhciBidXR0b25zID0gaGFuZGxlQXJyYXlDb250YWluZXJEZWZhdWx0cyhzZWxlY3RvckluLCBzZWxlY3Rvck91dCwge1xuICAgICAgICBuYW1lOiAnYnV0dG9ucycsXG4gICAgICAgIGhhbmRsZUl0ZW1EZWZhdWx0czogYnV0dG9uRGVmYXVsdHMsXG4gICAgICAgIGNhbGVuZGFyOiBjYWxlbmRhclxuICAgIH0pO1xuXG4gICAgdmFyIHZpc2libGUgPSBjb2VyY2UoJ3Zpc2libGUnLCBidXR0b25zLmxlbmd0aCA+IDApO1xuICAgIGlmKHZpc2libGUpIHtcbiAgICAgICAgdmFyIHBvc0RmbHQgPSBnZXRQb3NEZmx0KGNvbnRhaW5lck91dCwgbGF5b3V0LCBjb3VudGVyQXhlcyk7XG4gICAgICAgIGNvZXJjZSgneCcsIHBvc0RmbHRbMF0pO1xuICAgICAgICBjb2VyY2UoJ3knLCBwb3NEZmx0WzFdKTtcbiAgICAgICAgTGliLm5vbmVPckFsbChjb250YWluZXJJbiwgY29udGFpbmVyT3V0LCBbJ3gnLCAneSddKTtcblxuICAgICAgICBjb2VyY2UoJ3hhbmNob3InKTtcbiAgICAgICAgY29lcmNlKCd5YW5jaG9yJyk7XG5cbiAgICAgICAgTGliLmNvZXJjZUZvbnQoY29lcmNlLCAnZm9udCcsIGxheW91dC5mb250KTtcblxuICAgICAgICB2YXIgYmdDb2xvciA9IGNvZXJjZSgnYmdjb2xvcicpO1xuICAgICAgICBjb2VyY2UoJ2FjdGl2ZWNvbG9yJywgQ29sb3IuY29udHJhc3QoYmdDb2xvciwgY29uc3RhbnRzLmxpZ2h0QW1vdW50LCBjb25zdGFudHMuZGFya0Ftb3VudCkpO1xuICAgICAgICBjb2VyY2UoJ2JvcmRlcmNvbG9yJyk7XG4gICAgICAgIGNvZXJjZSgnYm9yZGVyd2lkdGgnKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBidXR0b25EZWZhdWx0cyhidXR0b25JbiwgYnV0dG9uT3V0LCBzZWxlY3Rvck91dCwgb3B0cykge1xuICAgIHZhciBjYWxlbmRhciA9IG9wdHMuY2FsZW5kYXI7XG5cbiAgICBmdW5jdGlvbiBjb2VyY2UoYXR0ciwgZGZsdCkge1xuICAgICAgICByZXR1cm4gTGliLmNvZXJjZShidXR0b25JbiwgYnV0dG9uT3V0LCBhdHRyaWJ1dGVzLmJ1dHRvbnMsIGF0dHIsIGRmbHQpO1xuICAgIH1cblxuICAgIHZhciB2aXNpYmxlID0gY29lcmNlKCd2aXNpYmxlJyk7XG5cbiAgICBpZih2aXNpYmxlKSB7XG4gICAgICAgIHZhciBzdGVwID0gY29lcmNlKCdzdGVwJyk7XG4gICAgICAgIGlmKHN0ZXAgIT09ICdhbGwnKSB7XG4gICAgICAgICAgICBpZihjYWxlbmRhciAmJiBjYWxlbmRhciAhPT0gJ2dyZWdvcmlhbicgJiYgKHN0ZXAgPT09ICdtb250aCcgfHwgc3RlcCA9PT0gJ3llYXInKSkge1xuICAgICAgICAgICAgICAgIGJ1dHRvbk91dC5zdGVwbW9kZSA9ICdiYWNrd2FyZCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZXJjZSgnc3RlcG1vZGUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29lcmNlKCdjb3VudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29lcmNlKCdsYWJlbCcpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9zRGZsdChjb250YWluZXJPdXQsIGxheW91dCwgY291bnRlckF4ZXMpIHtcbiAgICB2YXIgYW5jaG9yZWRMaXN0ID0gY291bnRlckF4ZXMuZmlsdGVyKGZ1bmN0aW9uKGF4KSB7XG4gICAgICAgIHJldHVybiBsYXlvdXRbYXhdLmFuY2hvciA9PT0gY29udGFpbmVyT3V0Ll9pZDtcbiAgICB9KTtcblxuICAgIHZhciBwb3NZID0gMDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYW5jaG9yZWRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkb21haW4gPSBsYXlvdXRbYW5jaG9yZWRMaXN0W2ldXS5kb21haW47XG4gICAgICAgIGlmKGRvbWFpbikgcG9zWSA9IE1hdGgubWF4KGRvbWFpblsxXSwgcG9zWSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtjb250YWluZXJPdXQuZG9tYWluWzBdLCBwb3NZICsgY29uc3RhbnRzLnlQYWRdO1xufVxuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZDMgPSByZXF1aXJlKCdkMycpO1xuXG52YXIgUmVnaXN0cnkgPSByZXF1aXJlKCcuLi8uLi9yZWdpc3RyeScpO1xudmFyIFBsb3RzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvcGxvdHMnKTtcbnZhciBDb2xvciA9IHJlcXVpcmUoJy4uL2NvbG9yJyk7XG52YXIgRHJhd2luZyA9IHJlcXVpcmUoJy4uL2RyYXdpbmcnKTtcbnZhciBMaWIgPSByZXF1aXJlKCcuLi8uLi9saWInKTtcbnZhciBzdmdUZXh0VXRpbHMgPSByZXF1aXJlKCcuLi8uLi9saWIvc3ZnX3RleHRfdXRpbHMnKTtcbnZhciBheGlzSWRzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuL2F4aXNfaWRzJyk7XG5cbnZhciBhbGlnbm1lbnRDb25zdGFudHMgPSByZXF1aXJlKCcuLi8uLi9jb25zdGFudHMvYWxpZ25tZW50Jyk7XG52YXIgTElORV9TUEFDSU5HID0gYWxpZ25tZW50Q29uc3RhbnRzLkxJTkVfU1BBQ0lORztcbnZhciBGUk9NX1RMID0gYWxpZ25tZW50Q29uc3RhbnRzLkZST01fVEw7XG52YXIgRlJPTV9CUiA9IGFsaWdubWVudENvbnN0YW50cy5GUk9NX0JSO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBnZXRVcGRhdGVPYmplY3QgPSByZXF1aXJlKCcuL2dldF91cGRhdGVfb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZHJhdyhnZCkge1xuICAgIHZhciBmdWxsTGF5b3V0ID0gZ2QuX2Z1bGxMYXlvdXQ7XG5cbiAgICB2YXIgc2VsZWN0b3JzID0gZnVsbExheW91dC5faW5mb2xheWVyLnNlbGVjdEFsbCgnLnJhbmdlc2VsZWN0b3InKVxuICAgICAgICAuZGF0YShtYWtlU2VsZWN0b3JEYXRhKGdkKSwgc2VsZWN0b3JLZXlGdW5jKTtcblxuICAgIHNlbGVjdG9ycy5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgIC5jbGFzc2VkKCdyYW5nZXNlbGVjdG9yJywgdHJ1ZSk7XG5cbiAgICBzZWxlY3RvcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgc2VsZWN0b3JzLnN0eWxlKHtcbiAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICdhbGwnXG4gICAgfSk7XG5cbiAgICBzZWxlY3RvcnMuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGF4aXNMYXlvdXQgPSBkO1xuICAgICAgICB2YXIgc2VsZWN0b3JMYXlvdXQgPSBheGlzTGF5b3V0LnJhbmdlc2VsZWN0b3I7XG5cbiAgICAgICAgdmFyIGJ1dHRvbnMgPSBzZWxlY3Rvci5zZWxlY3RBbGwoJ2cuYnV0dG9uJylcbiAgICAgICAgICAgIC5kYXRhKExpYi5maWx0ZXJWaXNpYmxlKHNlbGVjdG9yTGF5b3V0LmJ1dHRvbnMpKTtcblxuICAgICAgICBidXR0b25zLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdidXR0b24nLCB0cnVlKTtcblxuICAgICAgICBidXR0b25zLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICBidXR0b25zLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSBnZXRVcGRhdGVPYmplY3QoYXhpc0xheW91dCwgZCk7XG5cbiAgICAgICAgICAgIGQuX2lzQWN0aXZlID0gaXNBY3RpdmUoYXhpc0xheW91dCwgZCwgdXBkYXRlKTtcblxuICAgICAgICAgICAgYnV0dG9uLmNhbGwoZHJhd0J1dHRvblJlY3QsIHNlbGVjdG9yTGF5b3V0LCBkKTtcbiAgICAgICAgICAgIGJ1dHRvbi5jYWxsKGRyYXdCdXR0b25UZXh0LCBzZWxlY3RvckxheW91dCwgZCwgZ2QpO1xuXG4gICAgICAgICAgICBidXR0b24ub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYoZ2QuX2RyYWdnZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIFJlZ2lzdHJ5LmNhbGwoJ19ndWlSZWxheW91dCcsIGdkLCB1cGRhdGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJ1dHRvbi5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZC5faXNIb3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBidXR0b24uY2FsbChkcmF3QnV0dG9uUmVjdCwgc2VsZWN0b3JMYXlvdXQsIGQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJ1dHRvbi5vbignbW91c2VvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkLl9pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBidXR0b24uY2FsbChkcmF3QnV0dG9uUmVjdCwgc2VsZWN0b3JMYXlvdXQsIGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcG9zaXRpb24oZ2QsIGJ1dHRvbnMsIHNlbGVjdG9yTGF5b3V0LCBheGlzTGF5b3V0Ll9uYW1lLCBzZWxlY3Rvcik7XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBtYWtlU2VsZWN0b3JEYXRhKGdkKSB7XG4gICAgdmFyIGF4ZXMgPSBheGlzSWRzLmxpc3QoZ2QsICd4JywgdHJ1ZSk7XG4gICAgdmFyIGRhdGEgPSBbXTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBheGlzID0gYXhlc1tpXTtcblxuICAgICAgICBpZihheGlzLnJhbmdlc2VsZWN0b3IgJiYgYXhpcy5yYW5nZXNlbGVjdG9yLnZpc2libGUpIHtcbiAgICAgICAgICAgIGRhdGEucHVzaChheGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RvcktleUZ1bmMoZCkge1xuICAgIHJldHVybiBkLl9pZDtcbn1cblxuZnVuY3Rpb24gaXNBY3RpdmUoYXhpc0xheW91dCwgb3B0cywgdXBkYXRlKSB7XG4gICAgaWYob3B0cy5zdGVwID09PSAnYWxsJykge1xuICAgICAgICByZXR1cm4gYXhpc0xheW91dC5hdXRvcmFuZ2UgPT09IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBheGlzTGF5b3V0LnJhbmdlWzBdID09PSB1cGRhdGVba2V5c1swXV0gJiZcbiAgICAgICAgICAgIGF4aXNMYXlvdXQucmFuZ2VbMV0gPT09IHVwZGF0ZVtrZXlzWzFdXVxuICAgICAgICApO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhd0J1dHRvblJlY3QoYnV0dG9uLCBzZWxlY3RvckxheW91dCwgZCkge1xuICAgIHZhciByZWN0ID0gTGliLmVuc3VyZVNpbmdsZShidXR0b24sICdyZWN0JywgJ3NlbGVjdG9yLXJlY3QnLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHMuYXR0cignc2hhcGUtcmVuZGVyaW5nJywgJ2NyaXNwRWRnZXMnKTtcbiAgICB9KTtcblxuICAgIHJlY3QuYXR0cih7XG4gICAgICAgICdyeCc6IGNvbnN0YW50cy5yeCxcbiAgICAgICAgJ3J5JzogY29uc3RhbnRzLnJ5XG4gICAgfSk7XG5cbiAgICByZWN0LmNhbGwoQ29sb3Iuc3Ryb2tlLCBzZWxlY3RvckxheW91dC5ib3JkZXJjb2xvcilcbiAgICAgICAgLmNhbGwoQ29sb3IuZmlsbCwgZ2V0RmlsbENvbG9yKHNlbGVjdG9yTGF5b3V0LCBkKSlcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBzZWxlY3RvckxheW91dC5ib3JkZXJ3aWR0aCArICdweCcpO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxsQ29sb3Ioc2VsZWN0b3JMYXlvdXQsIGQpIHtcbiAgICByZXR1cm4gKGQuX2lzQWN0aXZlIHx8IGQuX2lzSG92ZXJlZCkgP1xuICAgICAgICBzZWxlY3RvckxheW91dC5hY3RpdmVjb2xvciA6XG4gICAgICAgIHNlbGVjdG9yTGF5b3V0LmJnY29sb3I7XG59XG5cbmZ1bmN0aW9uIGRyYXdCdXR0b25UZXh0KGJ1dHRvbiwgc2VsZWN0b3JMYXlvdXQsIGQsIGdkKSB7XG4gICAgZnVuY3Rpb24gdGV4dExheW91dChzKSB7XG4gICAgICAgIHN2Z1RleHRVdGlscy5jb252ZXJ0VG9Uc3BhbnMocywgZ2QpO1xuICAgIH1cblxuICAgIHZhciB0ZXh0ID0gTGliLmVuc3VyZVNpbmdsZShidXR0b24sICd0ZXh0JywgJ3NlbGVjdG9yLXRleHQnLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHMuY2xhc3NlZCgndXNlci1zZWxlY3Qtbm9uZScsIHRydWUpXG4gICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG4gICAgfSk7XG5cbiAgICB0ZXh0LmNhbGwoRHJhd2luZy5mb250LCBzZWxlY3RvckxheW91dC5mb250KVxuICAgICAgICAudGV4dChnZXRMYWJlbChkLCBnZC5fZnVsbExheW91dC5fbWV0YSkpXG4gICAgICAgIC5jYWxsKHRleHRMYXlvdXQpO1xufVxuXG5mdW5jdGlvbiBnZXRMYWJlbChvcHRzLCBfbWV0YSkge1xuICAgIGlmKG9wdHMubGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIF9tZXRhID9cbiAgICAgICAgICAgIExpYi50ZW1wbGF0ZVN0cmluZyhvcHRzLmxhYmVsLCBfbWV0YSkgOlxuICAgICAgICAgICAgb3B0cy5sYWJlbDtcbiAgICB9XG5cbiAgICBpZihvcHRzLnN0ZXAgPT09ICdhbGwnKSByZXR1cm4gJ2FsbCc7XG5cbiAgICByZXR1cm4gb3B0cy5jb3VudCArIG9wdHMuc3RlcC5jaGFyQXQoMCk7XG59XG5cbmZ1bmN0aW9uIHJlcG9zaXRpb24oZ2QsIGJ1dHRvbnMsIG9wdHMsIGF4TmFtZSwgc2VsZWN0b3IpIHtcbiAgICB2YXIgd2lkdGggPSAwO1xuICAgIHZhciBoZWlnaHQgPSAwO1xuXG4gICAgdmFyIGJvcmRlcldpZHRoID0gb3B0cy5ib3JkZXJ3aWR0aDtcblxuICAgIGJ1dHRvbnMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHRleHQgPSBidXR0b24uc2VsZWN0KCcuc2VsZWN0b3ItdGV4dCcpO1xuXG4gICAgICAgIHZhciB0SGVpZ2h0ID0gb3B0cy5mb250LnNpemUgKiBMSU5FX1NQQUNJTkc7XG4gICAgICAgIHZhciBoRWZmID0gTWF0aC5tYXgodEhlaWdodCAqIHN2Z1RleHRVdGlscy5saW5lQ291bnQodGV4dCksIDE2KSArIDM7XG5cbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBoRWZmKTtcbiAgICB9KTtcblxuICAgIGJ1dHRvbnMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHJlY3QgPSBidXR0b24uc2VsZWN0KCcuc2VsZWN0b3ItcmVjdCcpO1xuICAgICAgICB2YXIgdGV4dCA9IGJ1dHRvbi5zZWxlY3QoJy5zZWxlY3Rvci10ZXh0Jyk7XG5cbiAgICAgICAgdmFyIHRXaWR0aCA9IHRleHQubm9kZSgpICYmIERyYXdpbmcuYkJveCh0ZXh0Lm5vZGUoKSkud2lkdGg7XG4gICAgICAgIHZhciB0SGVpZ2h0ID0gb3B0cy5mb250LnNpemUgKiBMSU5FX1NQQUNJTkc7XG4gICAgICAgIHZhciB0TGluZXMgPSBzdmdUZXh0VXRpbHMubGluZUNvdW50KHRleHQpO1xuXG4gICAgICAgIHZhciB3RWZmID0gTWF0aC5tYXgodFdpZHRoICsgMTAsIGNvbnN0YW50cy5taW5CdXR0b25XaWR0aCk7XG5cbiAgICAgICAgLy8gVE9ETyBhZGQgTWF0aEpheCBzdXBwb3J0XG5cbiAgICAgICAgLy8gVE9ETyBhZGQgYnV0dG9uZ2FwIGF0dHJpYnV0ZVxuXG4gICAgICAgIGJ1dHRvbi5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgK1xuICAgICAgICAgICAgKGJvcmRlcldpZHRoICsgd2lkdGgpICsgJywnICsgYm9yZGVyV2lkdGggK1xuICAgICAgICAnKScpO1xuXG4gICAgICAgIHJlY3QuYXR0cih7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiB3RWZmLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3ZnVGV4dFV0aWxzLnBvc2l0aW9uVGV4dCh0ZXh0LCB3RWZmIC8gMixcbiAgICAgICAgICAgIGhlaWdodCAvIDIgLSAoKHRMaW5lcyAtIDEpICogdEhlaWdodCAvIDIpICsgMyk7XG5cbiAgICAgICAgd2lkdGggKz0gd0VmZiArIDU7XG4gICAgfSk7XG5cbiAgICB2YXIgZ3JhcGhTaXplID0gZ2QuX2Z1bGxMYXlvdXQuX3NpemU7XG4gICAgdmFyIGx4ID0gZ3JhcGhTaXplLmwgKyBncmFwaFNpemUudyAqIG9wdHMueDtcbiAgICB2YXIgbHkgPSBncmFwaFNpemUudCArIGdyYXBoU2l6ZS5oICogKDEgLSBvcHRzLnkpO1xuXG4gICAgdmFyIHhhbmNob3IgPSAnbGVmdCc7XG4gICAgaWYoTGliLmlzUmlnaHRBbmNob3Iob3B0cykpIHtcbiAgICAgICAgbHggLT0gd2lkdGg7XG4gICAgICAgIHhhbmNob3IgPSAncmlnaHQnO1xuICAgIH1cbiAgICBpZihMaWIuaXNDZW50ZXJBbmNob3Iob3B0cykpIHtcbiAgICAgICAgbHggLT0gd2lkdGggLyAyO1xuICAgICAgICB4YW5jaG9yID0gJ2NlbnRlcic7XG4gICAgfVxuXG4gICAgdmFyIHlhbmNob3IgPSAndG9wJztcbiAgICBpZihMaWIuaXNCb3R0b21BbmNob3Iob3B0cykpIHtcbiAgICAgICAgbHkgLT0gaGVpZ2h0O1xuICAgICAgICB5YW5jaG9yID0gJ2JvdHRvbSc7XG4gICAgfVxuICAgIGlmKExpYi5pc01pZGRsZUFuY2hvcihvcHRzKSkge1xuICAgICAgICBseSAtPSBoZWlnaHQgLyAyO1xuICAgICAgICB5YW5jaG9yID0gJ21pZGRsZSc7XG4gICAgfVxuXG4gICAgd2lkdGggPSBNYXRoLmNlaWwod2lkdGgpO1xuICAgIGhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQpO1xuICAgIGx4ID0gTWF0aC5yb3VuZChseCk7XG4gICAgbHkgPSBNYXRoLnJvdW5kKGx5KTtcblxuICAgIFBsb3RzLmF1dG9NYXJnaW4oZ2QsIGF4TmFtZSArICctcmFuZ2Utc2VsZWN0b3InLCB7XG4gICAgICAgIHg6IG9wdHMueCxcbiAgICAgICAgeTogb3B0cy55LFxuICAgICAgICBsOiB3aWR0aCAqIEZST01fVExbeGFuY2hvcl0sXG4gICAgICAgIHI6IHdpZHRoICogRlJPTV9CUlt4YW5jaG9yXSxcbiAgICAgICAgYjogaGVpZ2h0ICogRlJPTV9CUlt5YW5jaG9yXSxcbiAgICAgICAgdDogaGVpZ2h0ICogRlJPTV9UTFt5YW5jaG9yXVxuICAgIH0pO1xuXG4gICAgc2VsZWN0b3IuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbHggKyAnLCcgKyBseSArICcpJyk7XG59XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGQzID0gcmVxdWlyZSgnZDMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRVcGRhdGVPYmplY3QoYXhpc0xheW91dCwgYnV0dG9uTGF5b3V0KSB7XG4gICAgdmFyIGF4TmFtZSA9IGF4aXNMYXlvdXQuX25hbWU7XG4gICAgdmFyIHVwZGF0ZSA9IHt9O1xuXG4gICAgaWYoYnV0dG9uTGF5b3V0LnN0ZXAgPT09ICdhbGwnKSB7XG4gICAgICAgIHVwZGF0ZVtheE5hbWUgKyAnLmF1dG9yYW5nZSddID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeHJhbmdlID0gZ2V0WFJhbmdlKGF4aXNMYXlvdXQsIGJ1dHRvbkxheW91dCk7XG5cbiAgICAgICAgdXBkYXRlW2F4TmFtZSArICcucmFuZ2VbMF0nXSA9IHhyYW5nZVswXTtcbiAgICAgICAgdXBkYXRlW2F4TmFtZSArICcucmFuZ2VbMV0nXSA9IHhyYW5nZVsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlO1xufTtcblxuZnVuY3Rpb24gZ2V0WFJhbmdlKGF4aXNMYXlvdXQsIGJ1dHRvbkxheW91dCkge1xuICAgIHZhciBjdXJyZW50UmFuZ2UgPSBheGlzTGF5b3V0LnJhbmdlO1xuICAgIHZhciBiYXNlID0gbmV3IERhdGUoYXhpc0xheW91dC5yMmwoY3VycmVudFJhbmdlWzFdKSk7XG4gICAgdmFyIHN0ZXAgPSBidXR0b25MYXlvdXQuc3RlcDtcbiAgICB2YXIgY291bnQgPSBidXR0b25MYXlvdXQuY291bnQ7XG4gICAgdmFyIHJhbmdlMDtcblxuICAgIHN3aXRjaChidXR0b25MYXlvdXQuc3RlcG1vZGUpIHtcbiAgICAgICAgY2FzZSAnYmFja3dhcmQnOlxuICAgICAgICAgICAgcmFuZ2UwID0gYXhpc0xheW91dC5sMnIoK2QzLnRpbWVbc3RlcF0udXRjLm9mZnNldChiYXNlLCAtY291bnQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvZGF0ZSc6XG4gICAgICAgICAgICB2YXIgYmFzZTIgPSBkMy50aW1lW3N0ZXBdLnV0Yy5vZmZzZXQoYmFzZSwgLWNvdW50KTtcblxuICAgICAgICAgICAgcmFuZ2UwID0gYXhpc0xheW91dC5sMnIoK2QzLnRpbWVbc3RlcF0udXRjLmNlaWwoYmFzZTIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciByYW5nZTEgPSBjdXJyZW50UmFuZ2VbMV07XG5cbiAgICByZXR1cm4gW3JhbmdlMCwgcmFuZ2UxXTtcbn1cbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbW9kdWxlVHlwZTogJ2NvbXBvbmVudCcsXG4gICAgbmFtZTogJ3Jhbmdlc2VsZWN0b3InLFxuXG4gICAgc2NoZW1hOiB7XG4gICAgICAgIHN1YnBsb3RzOiB7XG4gICAgICAgICAgICB4YXhpczoge3Jhbmdlc2VsZWN0b3I6IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGxheW91dEF0dHJpYnV0ZXM6IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpLFxuICAgIGhhbmRsZURlZmF1bHRzOiByZXF1aXJlKCcuL2RlZmF1bHRzJyksXG5cbiAgICBkcmF3OiByZXF1aXJlKCcuL2RyYXcnKVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNvbG9yQXR0cmlidXRlcyA9IHJlcXVpcmUoJy4uL2NvbG9yL2F0dHJpYnV0ZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYmdjb2xvcjoge1xuICAgICAgICB2YWxUeXBlOiAnY29sb3InLFxuICAgICAgICBkZmx0OiBjb2xvckF0dHJpYnV0ZXMuYmFja2dyb3VuZCxcbiAgICAgICAgcm9sZTogJ3N0eWxlJyxcbiAgICAgICAgZWRpdFR5cGU6ICdwbG90JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdTZXRzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSByYW5nZSBzbGlkZXIuJ1xuICAgIH0sXG4gICAgYm9yZGVyY29sb3I6IHtcbiAgICAgICAgdmFsVHlwZTogJ2NvbG9yJyxcbiAgICAgICAgZGZsdDogY29sb3JBdHRyaWJ1dGVzLmRlZmF1bHRMaW5lLFxuICAgICAgICByb2xlOiAnc3R5bGUnLFxuICAgICAgICBlZGl0VHlwZTogJ3Bsb3QnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIGJvcmRlciBjb2xvciBvZiB0aGUgcmFuZ2Ugc2xpZGVyLidcbiAgICB9LFxuICAgIGJvcmRlcndpZHRoOiB7XG4gICAgICAgIHZhbFR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgZGZsdDogMCxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICByb2xlOiAnc3R5bGUnLFxuICAgICAgICBlZGl0VHlwZTogJ3Bsb3QnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIGJvcmRlciB3aWR0aCBvZiB0aGUgcmFuZ2Ugc2xpZGVyLidcbiAgICB9LFxuICAgIGF1dG9yYW5nZToge1xuICAgICAgICB2YWxUeXBlOiAnYm9vbGVhbicsXG4gICAgICAgIGRmbHQ6IHRydWUsXG4gICAgICAgIHJvbGU6ICdzdHlsZScsXG4gICAgICAgIGVkaXRUeXBlOiAnY2FsYycsXG4gICAgICAgIGltcGxpZWRFZGl0czogeydyYW5nZVswXSc6IHVuZGVmaW5lZCwgJ3JhbmdlWzFdJzogdW5kZWZpbmVkfSxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSByYW5nZSBzbGlkZXIgcmFuZ2UgaXMnLFxuICAgICAgICAgICAgJ2NvbXB1dGVkIGluIHJlbGF0aW9uIHRvIHRoZSBpbnB1dCBkYXRhLicsXG4gICAgICAgICAgICAnSWYgYHJhbmdlYCBpcyBwcm92aWRlZCwgdGhlbiBgYXV0b3JhbmdlYCBpcyBzZXQgdG8gKmZhbHNlKi4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICByYW5nZToge1xuICAgICAgICB2YWxUeXBlOiAnaW5mb19hcnJheScsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgIHt2YWxUeXBlOiAnYW55JywgZWRpdFR5cGU6ICdjYWxjJywgaW1wbGllZEVkaXRzOiB7J15hdXRvcmFuZ2UnOiBmYWxzZX19LFxuICAgICAgICAgICAge3ZhbFR5cGU6ICdhbnknLCBlZGl0VHlwZTogJ2NhbGMnLCBpbXBsaWVkRWRpdHM6IHsnXmF1dG9yYW5nZSc6IGZhbHNlfX1cbiAgICAgICAgXSxcbiAgICAgICAgZWRpdFR5cGU6ICdjYWxjJyxcbiAgICAgICAgaW1wbGllZEVkaXRzOiB7J2F1dG9yYW5nZSc6IGZhbHNlfSxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSByYW5nZSBvZiB0aGUgcmFuZ2Ugc2xpZGVyLicsXG4gICAgICAgICAgICAnSWYgbm90IHNldCwgZGVmYXVsdHMgdG8gdGhlIGZ1bGwgeGF4aXMgcmFuZ2UuJyxcbiAgICAgICAgICAgICdJZiB0aGUgYXhpcyBgdHlwZWAgaXMgKmxvZyosIHRoZW4geW91IG11c3QgdGFrZSB0aGUnLFxuICAgICAgICAgICAgJ2xvZyBvZiB5b3VyIGRlc2lyZWQgcmFuZ2UuJyxcbiAgICAgICAgICAgICdJZiB0aGUgYXhpcyBgdHlwZWAgaXMgKmRhdGUqLCBpdCBzaG91bGQgYmUgZGF0ZSBzdHJpbmdzLCcsXG4gICAgICAgICAgICAnbGlrZSBkYXRlIGRhdGEsIHRob3VnaCBEYXRlIG9iamVjdHMgYW5kIHVuaXggbWlsbGlzZWNvbmRzJyxcbiAgICAgICAgICAgICd3aWxsIGJlIGFjY2VwdGVkIGFuZCBjb252ZXJ0ZWQgdG8gc3RyaW5ncy4nLFxuICAgICAgICAgICAgJ0lmIHRoZSBheGlzIGB0eXBlYCBpcyAqY2F0ZWdvcnkqLCBpdCBzaG91bGQgYmUgbnVtYmVycywnLFxuICAgICAgICAgICAgJ3VzaW5nIHRoZSBzY2FsZSB3aGVyZSBlYWNoIGNhdGVnb3J5IGlzIGFzc2lnbmVkIGEgc2VyaWFsJyxcbiAgICAgICAgICAgICdudW1iZXIgZnJvbSB6ZXJvIGluIHRoZSBvcmRlciBpdCBhcHBlYXJzLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuICAgIHRoaWNrbmVzczoge1xuICAgICAgICB2YWxUeXBlOiAnbnVtYmVyJyxcbiAgICAgICAgZGZsdDogMC4xNSxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIHJvbGU6ICdzdHlsZScsXG4gICAgICAgIGVkaXRUeXBlOiAncGxvdCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnVGhlIGhlaWdodCBvZiB0aGUgcmFuZ2Ugc2xpZGVyIGFzIGEgZnJhY3Rpb24gb2YgdGhlJyxcbiAgICAgICAgICAgICd0b3RhbCBwbG90IGFyZWEgaGVpZ2h0LidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuICAgIHZpc2libGU6IHtcbiAgICAgICAgdmFsVHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICBkZmx0OiB0cnVlLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGVkaXRUeXBlOiAnY2FsYycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgcmFuZ2Ugc2xpZGVyIHdpbGwgYmUgdmlzaWJsZS4nLFxuICAgICAgICAgICAgJ0lmIHZpc2libGUsIHBlcnBlbmRpY3VsYXIgYXhlcyB3aWxsIGJlIHNldCB0byBgZml4ZWRyYW5nZWAnXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICBlZGl0VHlwZTogJ2NhbGMnXG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGlzdEF4ZXMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9jYXJ0ZXNpYW4vYXhpc19pZHMnKS5saXN0O1xudmFyIGdldEF1dG9SYW5nZSA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2NhcnRlc2lhbi9hdXRvcmFuZ2UnKS5nZXRBdXRvUmFuZ2U7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxjQXV0b3JhbmdlKGdkKSB7XG4gICAgdmFyIGF4ZXMgPSBsaXN0QXhlcyhnZCwgJ3gnLCB0cnVlKTtcblxuICAgIC8vIENvbXB1dGUgbmV3IHNsaWRlciByYW5nZSB1c2luZyBheGlzIGF1dG9yYW5nZSBpZiBuZWNlc3NhcnkuXG4gICAgLy9cbiAgICAvLyBDb3B5IGJhY2sgcmFuZ2UgdG8gaW5wdXQgcmFuZ2Ugc2xpZGVyIGNvbnRhaW5lciB0byBza2lwXG4gICAgLy8gdGhpcyBzdGVwIGluIHN1YnNlcXVlbnQgZHJhdyBjYWxscy5cblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBheCA9IGF4ZXNbaV07XG4gICAgICAgIHZhciBvcHRzID0gYXhbY29uc3RhbnRzLm5hbWVdO1xuXG4gICAgICAgIGlmKG9wdHMgJiYgb3B0cy52aXNpYmxlICYmIG9wdHMuYXV0b3JhbmdlKSB7XG4gICAgICAgICAgICBvcHRzLl9pbnB1dC5hdXRvcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgb3B0cy5faW5wdXQucmFuZ2UgPSBvcHRzLnJhbmdlID0gZ2V0QXV0b1JhbmdlKGdkLCBheCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIC8vIGF0dHJpYnV0ZSBjb250YWluZXIgbmFtZVxuICAgIG5hbWU6ICdyYW5nZXNsaWRlcicsXG5cbiAgICAvLyBjbGFzcyBuYW1lc1xuXG4gICAgY29udGFpbmVyQ2xhc3NOYW1lOiAncmFuZ2VzbGlkZXItY29udGFpbmVyJyxcbiAgICBiZ0NsYXNzTmFtZTogJ3Jhbmdlc2xpZGVyLWJnJyxcbiAgICByYW5nZVBsb3RDbGFzc05hbWU6ICdyYW5nZXNsaWRlci1yYW5nZXBsb3QnLFxuXG4gICAgbWFza01pbkNsYXNzTmFtZTogJ3Jhbmdlc2xpZGVyLW1hc2stbWluJyxcbiAgICBtYXNrTWF4Q2xhc3NOYW1lOiAncmFuZ2VzbGlkZXItbWFzay1tYXgnLFxuICAgIHNsaWRlQm94Q2xhc3NOYW1lOiAncmFuZ2VzbGlkZXItc2xpZGVib3gnLFxuXG4gICAgZ3JhYmJlck1pbkNsYXNzTmFtZTogJ3Jhbmdlc2xpZGVyLWdyYWJiZXItbWluJyxcbiAgICBncmFiQXJlYU1pbkNsYXNzTmFtZTogJ3Jhbmdlc2xpZGVyLWdyYWJhcmVhLW1pbicsXG4gICAgaGFuZGxlTWluQ2xhc3NOYW1lOiAncmFuZ2VzbGlkZXItaGFuZGxlLW1pbicsXG5cbiAgICBncmFiYmVyTWF4Q2xhc3NOYW1lOiAncmFuZ2VzbGlkZXItZ3JhYmJlci1tYXgnLFxuICAgIGdyYWJBcmVhTWF4Q2xhc3NOYW1lOiAncmFuZ2VzbGlkZXItZ3JhYmFyZWEtbWF4JyxcbiAgICBoYW5kbGVNYXhDbGFzc05hbWU6ICdyYW5nZXNsaWRlci1oYW5kbGUtbWF4JyxcblxuICAgIG1hc2tNaW5PcHBBeGlzQ2xhc3NOYW1lOiAncmFuZ2VzbGlkZXItbWFzay1taW4tb3BwLWF4aXMnLFxuICAgIG1hc2tNYXhPcHBBeGlzQ2xhc3NOYW1lOiAncmFuZ2VzbGlkZXItbWFzay1tYXgtb3BwLWF4aXMnLFxuXG4gICAgLy8gc3R5bGUgY29uc3RhbnRzXG5cbiAgICBtYXNrQ29sb3I6ICdyZ2JhKDAsMCwwLDAuNCknLFxuICAgIG1hc2tPcHBBeGlzQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMiknLFxuXG4gICAgc2xpZGVCb3hGaWxsOiAndHJhbnNwYXJlbnQnLFxuICAgIHNsaWRlQm94Q3Vyc29yOiAnZXctcmVzaXplJyxcblxuICAgIGdyYWJBcmVhRmlsbDogJ3RyYW5zcGFyZW50JyxcbiAgICBncmFiQXJlYUN1cnNvcjogJ2NvbC1yZXNpemUnLFxuICAgIGdyYWJBcmVhV2lkdGg6IDEwLFxuXG4gICAgaGFuZGxlV2lkdGg6IDQsXG4gICAgaGFuZGxlUmFkaXVzOiAxLFxuICAgIGhhbmRsZVN0cm9rZVdpZHRoOiAxLFxuXG4gICAgZXh0cmFQYWQ6IDE1XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGliID0gcmVxdWlyZSgnLi4vLi4vbGliJyk7XG52YXIgVGVtcGxhdGUgPSByZXF1aXJlKCcuLi8uLi9wbG90X2FwaS9wbG90X3RlbXBsYXRlJyk7XG52YXIgYXhpc0lkcyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2NhcnRlc2lhbi9heGlzX2lkcycpO1xuXG52YXIgYXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpO1xudmFyIG9wcEF4aXNBdHRycyA9IHJlcXVpcmUoJy4vb3BwYXhpc19hdHRyaWJ1dGVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFuZGxlRGVmYXVsdHMobGF5b3V0SW4sIGxheW91dE91dCwgYXhOYW1lKSB7XG4gICAgdmFyIGF4SW4gPSBsYXlvdXRJbltheE5hbWVdO1xuICAgIHZhciBheE91dCA9IGxheW91dE91dFtheE5hbWVdO1xuXG4gICAgaWYoIShheEluLnJhbmdlc2xpZGVyIHx8IGxheW91dE91dC5fcmVxdWVzdFJhbmdlc2xpZGVyW2F4T3V0Ll9pZF0pKSByZXR1cm47XG5cbiAgICAvLyBub3Qgc3VwZXIgcHJvdWQgb2YgdGhpcyAobWF5YmUgc3RvcmUgXyBpbiBheGlzIG9iamVjdCBpbnN0ZWFkXG4gICAgaWYoIUxpYi5pc1BsYWluT2JqZWN0KGF4SW4ucmFuZ2VzbGlkZXIpKSB7XG4gICAgICAgIGF4SW4ucmFuZ2VzbGlkZXIgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVySW4gPSBheEluLnJhbmdlc2xpZGVyO1xuICAgIHZhciBjb250YWluZXJPdXQgPSBUZW1wbGF0ZS5uZXdDb250YWluZXIoYXhPdXQsICdyYW5nZXNsaWRlcicpO1xuXG4gICAgZnVuY3Rpb24gY29lcmNlKGF0dHIsIGRmbHQpIHtcbiAgICAgICAgcmV0dXJuIExpYi5jb2VyY2UoY29udGFpbmVySW4sIGNvbnRhaW5lck91dCwgYXR0cmlidXRlcywgYXR0ciwgZGZsdCk7XG4gICAgfVxuXG4gICAgdmFyIHJhbmdlQ29udGFpbmVySW4sIHJhbmdlQ29udGFpbmVyT3V0O1xuICAgIGZ1bmN0aW9uIGNvZXJjZVJhbmdlKGF0dHIsIGRmbHQpIHtcbiAgICAgICAgcmV0dXJuIExpYi5jb2VyY2UocmFuZ2VDb250YWluZXJJbiwgcmFuZ2VDb250YWluZXJPdXQsIG9wcEF4aXNBdHRycywgYXR0ciwgZGZsdCk7XG4gICAgfVxuXG4gICAgdmFyIHZpc2libGUgPSBjb2VyY2UoJ3Zpc2libGUnKTtcbiAgICBpZighdmlzaWJsZSkgcmV0dXJuO1xuXG4gICAgY29lcmNlKCdiZ2NvbG9yJywgbGF5b3V0T3V0LnBsb3RfYmdjb2xvcik7XG4gICAgY29lcmNlKCdib3JkZXJjb2xvcicpO1xuICAgIGNvZXJjZSgnYm9yZGVyd2lkdGgnKTtcbiAgICBjb2VyY2UoJ3RoaWNrbmVzcycpO1xuXG4gICAgY29lcmNlKCdhdXRvcmFuZ2UnLCAhYXhPdXQuaXNWYWxpZFJhbmdlKGNvbnRhaW5lckluLnJhbmdlKSk7XG4gICAgY29lcmNlKCdyYW5nZScpO1xuXG4gICAgdmFyIHN1YnBsb3RzID0gbGF5b3V0T3V0Ll9zdWJwbG90cztcbiAgICBpZihzdWJwbG90cykge1xuICAgICAgICB2YXIgeUlkcyA9IHN1YnBsb3RzLmNhcnRlc2lhblxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzdWJwbG90SWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VicGxvdElkLnN1YnN0cigwLCBzdWJwbG90SWQuaW5kZXhPZigneScpKSA9PT0gYXhpc0lkcy5uYW1lMmlkKGF4TmFtZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihzdWJwbG90SWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VicGxvdElkLnN1YnN0cihzdWJwbG90SWQuaW5kZXhPZigneScpLCBzdWJwbG90SWQubGVuZ3RoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgeU5hbWVzID0gTGliLnNpbXBsZU1hcCh5SWRzLCBheGlzSWRzLmlkMm5hbWUpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgeU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgeU5hbWUgPSB5TmFtZXNbaV07XG5cbiAgICAgICAgICAgIHJhbmdlQ29udGFpbmVySW4gPSBjb250YWluZXJJblt5TmFtZV0gfHwge307XG4gICAgICAgICAgICByYW5nZUNvbnRhaW5lck91dCA9IFRlbXBsYXRlLm5ld0NvbnRhaW5lcihjb250YWluZXJPdXQsIHlOYW1lLCAneWF4aXMnKTtcblxuICAgICAgICAgICAgdmFyIHlBeE91dCA9IGxheW91dE91dFt5TmFtZV07XG5cbiAgICAgICAgICAgIHZhciByYW5nZW1vZGVEZmx0O1xuICAgICAgICAgICAgaWYocmFuZ2VDb250YWluZXJJbi5yYW5nZSAmJiB5QXhPdXQuaXNWYWxpZFJhbmdlKHJhbmdlQ29udGFpbmVySW4ucmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Vtb2RlRGZsdCA9ICdmaXhlZCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByYW5nZU1vZGUgPSBjb2VyY2VSYW5nZSgncmFuZ2Vtb2RlJywgcmFuZ2Vtb2RlRGZsdCk7XG4gICAgICAgICAgICBpZihyYW5nZU1vZGUgIT09ICdtYXRjaCcpIHtcbiAgICAgICAgICAgICAgICBjb2VyY2VSYW5nZSgncmFuZ2UnLCB5QXhPdXQucmFuZ2Uuc2xpY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0byBtYXAgYmFjayByYW5nZSBzbGlkZXIgKGF1dG8pIHJhbmdlXG4gICAgY29udGFpbmVyT3V0Ll9pbnB1dCA9IGNvbnRhaW5lckluO1xufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGQzID0gcmVxdWlyZSgnZDMnKTtcblxudmFyIFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi4vLi4vcmVnaXN0cnknKTtcbnZhciBQbG90cyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL3Bsb3RzJyk7XG5cbnZhciBMaWIgPSByZXF1aXJlKCcuLi8uLi9saWInKTtcbnZhciBEcmF3aW5nID0gcmVxdWlyZSgnLi4vZHJhd2luZycpO1xudmFyIENvbG9yID0gcmVxdWlyZSgnLi4vY29sb3InKTtcbnZhciBUaXRsZXMgPSByZXF1aXJlKCcuLi90aXRsZXMnKTtcblxudmFyIENhcnRlc2lhbiA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2NhcnRlc2lhbicpO1xudmFyIGF4aXNJRHMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9jYXJ0ZXNpYW4vYXhpc19pZHMnKTtcblxudmFyIGRyYWdFbGVtZW50ID0gcmVxdWlyZSgnLi4vZHJhZ2VsZW1lbnQnKTtcbnZhciBzZXRDdXJzb3IgPSByZXF1aXJlKCcuLi8uLi9saWIvc2V0Y3Vyc29yJyk7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGdkKSB7XG4gICAgdmFyIGZ1bGxMYXlvdXQgPSBnZC5fZnVsbExheW91dDtcbiAgICB2YXIgcmFuZ2VTbGlkZXJEYXRhID0gZnVsbExheW91dC5fcmFuZ2VTbGlkZXJEYXRhO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCByYW5nZVNsaWRlckRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9wdHMgPSByYW5nZVNsaWRlckRhdGFbaV1bY29uc3RhbnRzLm5hbWVdO1xuICAgICAgICAvLyBmdWxsTGF5b3V0Ll91aWQgbWF5IG5vdCBleGlzdCB3aGVuIHdlIGNhbGwgbWFrZURhdGFcbiAgICAgICAgb3B0cy5fY2xpcElkID0gb3B0cy5faWQgKyAnLScgKyBmdWxsTGF5b3V0Ll91aWQ7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiA8ZyBjb250YWluZXIgLz5cbiAgICAgKiAgPHJlY3QgYmcgLz5cbiAgICAgKiAgPCAuLi4uIHJhbmdlIHBsb3QgLz5cbiAgICAgKiAgPHJlY3QgbWFzay1taW4gLz5cbiAgICAgKiAgPHJlY3QgbWFzay1tYXggLz5cbiAgICAgKiAgPHJlY3Qgc2xpZGVib3ggLz5cbiAgICAgKiAgPGcgZ3JhYmJlci1taW4gLz5cbiAgICAgKiAgICAgIDxyZWN0IGhhbmRsZS1taW4gLz5cbiAgICAgKiAgICAgIDxyZWN0IGdyYWJhcmUtbWluIC8+XG4gICAgICogIDxnIGdyYWJiZXItbWF4IC8+XG4gICAgICogICAgICA8cmVjdCBoYW5kbGUtbWF4IC8+XG4gICAgICogICAgICA8cmVjdCBncmFiYXJlLW1heCAvPlxuICAgICAqXG4gICAgICogIC4uLlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24ga2V5RnVuY3Rpb24oYXhpc09wdHMpIHtcbiAgICAgICAgcmV0dXJuIGF4aXNPcHRzLl9uYW1lO1xuICAgIH1cblxuICAgIHZhciByYW5nZVNsaWRlcnMgPSBmdWxsTGF5b3V0Ll9pbmZvbGF5ZXJcbiAgICAgICAgLnNlbGVjdEFsbCgnZy4nICsgY29uc3RhbnRzLmNvbnRhaW5lckNsYXNzTmFtZSlcbiAgICAgICAgLmRhdGEocmFuZ2VTbGlkZXJEYXRhLCBrZXlGdW5jdGlvbik7XG5cbiAgICAvLyByZW1vdmUgZXhpdGluZyBzbGlkZXJzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIGNsaXAgcGF0aHNcbiAgICByYW5nZVNsaWRlcnMuZXhpdCgpLmVhY2goZnVuY3Rpb24oYXhpc09wdHMpIHtcbiAgICAgICAgdmFyIG9wdHMgPSBheGlzT3B0c1tjb25zdGFudHMubmFtZV07XG4gICAgICAgIGZ1bGxMYXlvdXQuX3RvcGRlZnMuc2VsZWN0KCcjJyArIG9wdHMuX2NsaXBJZCkucmVtb3ZlKCk7XG4gICAgfSkucmVtb3ZlKCk7XG5cbiAgICAvLyByZXR1cm4gZWFybHkgaWYgbm8gcmFuZ2Ugc2xpZGVyIGlzIHZpc2libGVcbiAgICBpZihyYW5nZVNsaWRlckRhdGEubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICByYW5nZVNsaWRlcnMuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAuY2xhc3NlZChjb25zdGFudHMuY29udGFpbmVyQ2xhc3NOYW1lLCB0cnVlKVxuICAgICAgICAuYXR0cigncG9pbnRlci1ldmVudHMnLCAnYWxsJyk7XG5cbiAgICAvLyBmb3IgYWxsIHByZXNlbnQgcmFuZ2Ugc2xpZGVyc1xuICAgIHJhbmdlU2xpZGVycy5lYWNoKGZ1bmN0aW9uKGF4aXNPcHRzKSB7XG4gICAgICAgIHZhciByYW5nZVNsaWRlciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgdmFyIG9wdHMgPSBheGlzT3B0c1tjb25zdGFudHMubmFtZV07XG4gICAgICAgIHZhciBvcHBBeGlzT3B0cyA9IGZ1bGxMYXlvdXRbYXhpc0lEcy5pZDJuYW1lKGF4aXNPcHRzLmFuY2hvcildO1xuICAgICAgICB2YXIgb3BwQXhpc1JhbmdlT3B0cyA9IG9wdHNbYXhpc0lEcy5pZDJuYW1lKGF4aXNPcHRzLmFuY2hvcildO1xuXG4gICAgICAgIC8vIHVwZGF0ZSByYW5nZVxuICAgICAgICAvLyBFeHBhbmQgc2xpZGVyIHJhbmdlIHRvIHRoZSBheGlzIHJhbmdlXG4gICAgICAgIGlmKG9wdHMucmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBybmcgPSBMaWIuc2ltcGxlTWFwKG9wdHMucmFuZ2UsIGF4aXNPcHRzLnIybCk7XG4gICAgICAgICAgICB2YXIgYXhSbmcgPSBMaWIuc2ltcGxlTWFwKGF4aXNPcHRzLnJhbmdlLCBheGlzT3B0cy5yMmwpO1xuICAgICAgICAgICAgdmFyIG5ld1JuZztcblxuICAgICAgICAgICAgaWYoYXhSbmdbMF0gPCBheFJuZ1sxXSkge1xuICAgICAgICAgICAgICAgIG5ld1JuZyA9IFtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4ocm5nWzBdLCBheFJuZ1swXSksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHJuZ1sxXSwgYXhSbmdbMV0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3Um5nID0gW1xuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChybmdbMF0sIGF4Um5nWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4ocm5nWzFdLCBheFJuZ1sxXSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHRzLnJhbmdlID0gb3B0cy5faW5wdXQucmFuZ2UgPSBMaWIuc2ltcGxlTWFwKG5ld1JuZywgYXhpc09wdHMubDJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNPcHRzLmNsZWFuUmFuZ2UoJ3Jhbmdlc2xpZGVyLnJhbmdlJyk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHJhbmdlIHNsaWRlciBkaW1lbnNpb25zXG5cbiAgICAgICAgdmFyIGdzID0gZnVsbExheW91dC5fc2l6ZTtcbiAgICAgICAgdmFyIGRvbWFpbiA9IGF4aXNPcHRzLmRvbWFpbjtcblxuICAgICAgICBvcHRzLl93aWR0aCA9IGdzLncgKiAoZG9tYWluWzFdIC0gZG9tYWluWzBdKTtcblxuICAgICAgICB2YXIgeCA9IE1hdGgucm91bmQoZ3MubCArIChncy53ICogZG9tYWluWzBdKSk7XG5cbiAgICAgICAgdmFyIHkgPSBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgZ3MudCArIGdzLmggKiAoMSAtIGF4aXNPcHRzLl9jb3VudGVyRG9tYWluTWluKSArXG4gICAgICAgICAgICAoYXhpc09wdHMuc2lkZSA9PT0gJ2JvdHRvbScgPyBheGlzT3B0cy5fZGVwdGggOiAwKSArXG4gICAgICAgICAgICBvcHRzLl9vZmZzZXRTaGlmdCArIGNvbnN0YW50cy5leHRyYVBhZFxuICAgICAgICApO1xuXG4gICAgICAgIHJhbmdlU2xpZGVyLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHggKyAnLCcgKyB5ICsgJyknKTtcblxuICAgICAgICAvLyB1cGRhdGUgZGF0YSA8LS0+IHBpeGVsIGNvb3JkaW5hdGUgY29udmVyc2lvbiBtZXRob2RzXG5cbiAgICAgICAgb3B0cy5fcmwgPSBMaWIuc2ltcGxlTWFwKG9wdHMucmFuZ2UsIGF4aXNPcHRzLnIybCk7XG4gICAgICAgIHZhciBybDAgPSBvcHRzLl9ybFswXTtcbiAgICAgICAgdmFyIHJsMSA9IG9wdHMuX3JsWzFdO1xuICAgICAgICB2YXIgZHJsID0gcmwxIC0gcmwwO1xuXG4gICAgICAgIG9wdHMucDJkID0gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuICh2IC8gb3B0cy5fd2lkdGgpICogZHJsICsgcmwwO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9wdHMuZDJwID0gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuICh2IC0gcmwwKSAvIGRybCAqIG9wdHMuX3dpZHRoO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKGF4aXNPcHRzLnJhbmdlYnJlYWtzKSB7XG4gICAgICAgICAgICB2YXIgcnNCcmVha3MgPSBheGlzT3B0cy5sb2NhdGVCcmVha3MocmwwLCBybDEpO1xuXG4gICAgICAgICAgICBpZihyc0JyZWFrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiwgYnJrO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxCcmVha3MgPSAwO1xuICAgICAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IHJzQnJlYWtzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyayA9IHJzQnJlYWtzW2pdO1xuICAgICAgICAgICAgICAgICAgICBsQnJlYWtzICs9IChicmsubWF4IC0gYnJrLm1pbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBmaXggZm9yIHJldmVyc2VkLXJhbmdlIGF4ZXMgISEhXG5cbiAgICAgICAgICAgICAgICAvLyBjb21wdXRlIHNsb3BlIGFuZCBwaWVjZXdpc2Ugb2Zmc2V0c1xuICAgICAgICAgICAgICAgIHZhciBtMiA9IG9wdHMuX3dpZHRoIC8gKHJsMSAtIHJsMCAtIGxCcmVha3MpO1xuICAgICAgICAgICAgICAgIHZhciBfQiA9IFstbTIgKiBybDBdO1xuICAgICAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IHJzQnJlYWtzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyayA9IHJzQnJlYWtzW2pdO1xuICAgICAgICAgICAgICAgICAgICBfQi5wdXNoKF9CW19CLmxlbmd0aCAtIDFdIC0gbTIgKiAoYnJrLm1heCAtIGJyay5taW4pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvcHRzLmQycCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBfQlswXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHJzQnJlYWtzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnJrID0gcnNCcmVha3Nbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2ID49IGJyay5tYXgpIGIgPSBfQltqICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHYgPCBicmsubWluKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYiArIG0yICogdjtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gZmlsbCBwaXhlbCAoaS5lLiAncCcpIG1pbi9tYXggaGVyZSxcbiAgICAgICAgICAgICAgICAvLyB0byBub3QgaGF2ZSB0byBsb29wIHRocm91Z2ggdGhlIF9yYW5nZWJyZWFrcyB0d2ljZSBkdXJpbmcgYHAyZGBcbiAgICAgICAgICAgICAgICBmb3IoaiA9IDA7IGogPCByc0JyZWFrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBicmsgPSByc0JyZWFrc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgYnJrLnBtaW4gPSBvcHRzLmQycChicmsubWluKTtcbiAgICAgICAgICAgICAgICAgICAgYnJrLnBtYXggPSBvcHRzLmQycChicmsubWF4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvcHRzLnAyZCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBfQlswXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHJzQnJlYWtzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnJrID0gcnNCcmVha3Nbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2ID49IGJyay5wbWF4KSBiID0gX0JbaiArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZih2IDwgYnJrLnBtaW4pIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodiAtIGIpIC8gbTI7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG9wcEF4aXNSYW5nZU9wdHMucmFuZ2Vtb2RlICE9PSAnbWF0Y2gnKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UwT3BwQXhpcyA9IG9wcEF4aXNPcHRzLnIybChvcHBBeGlzUmFuZ2VPcHRzLnJhbmdlWzBdKTtcbiAgICAgICAgICAgIHZhciByYW5nZTFPcHBBeGlzID0gb3BwQXhpc09wdHMucjJsKG9wcEF4aXNSYW5nZU9wdHMucmFuZ2VbMV0pO1xuICAgICAgICAgICAgdmFyIGRpc3RPcHBBeGlzID0gcmFuZ2UxT3BwQXhpcyAtIHJhbmdlME9wcEF4aXM7XG5cbiAgICAgICAgICAgIG9wdHMuZDJwT3BwQXhpcyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHYgLSByYW5nZTBPcHBBeGlzKSAvIGRpc3RPcHBBeGlzICogb3B0cy5faGVpZ2h0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBpbm5lciBub2Rlc1xuXG4gICAgICAgIHJhbmdlU2xpZGVyXG4gICAgICAgICAgICAuY2FsbChkcmF3QmcsIGdkLCBheGlzT3B0cywgb3B0cylcbiAgICAgICAgICAgIC5jYWxsKGFkZENsaXBQYXRoLCBnZCwgYXhpc09wdHMsIG9wdHMpXG4gICAgICAgICAgICAuY2FsbChkcmF3UmFuZ2VQbG90LCBnZCwgYXhpc09wdHMsIG9wdHMpXG4gICAgICAgICAgICAuY2FsbChkcmF3TWFza3MsIGdkLCBheGlzT3B0cywgb3B0cywgb3BwQXhpc1JhbmdlT3B0cylcbiAgICAgICAgICAgIC5jYWxsKGRyYXdTbGlkZUJveCwgZ2QsIGF4aXNPcHRzLCBvcHRzKVxuICAgICAgICAgICAgLmNhbGwoZHJhd0dyYWJiZXJzLCBnZCwgYXhpc09wdHMsIG9wdHMpO1xuXG4gICAgICAgIC8vIHNldHVwIGRyYWcgZWxlbWVudFxuICAgICAgICBzZXR1cERyYWdFbGVtZW50KHJhbmdlU2xpZGVyLCBnZCwgYXhpc09wdHMsIG9wdHMpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBjdXJyZW50IHJhbmdlXG4gICAgICAgIHNldFBpeGVsUmFuZ2UocmFuZ2VTbGlkZXIsIGdkLCBheGlzT3B0cywgb3B0cywgb3BwQXhpc09wdHMsIG9wcEF4aXNSYW5nZU9wdHMpO1xuXG4gICAgICAgIC8vIHRpdGxlIGdvZXMgbmV4dCB0byByYW5nZSBzbGlkZXIgaW5zdGVhZCBvZiB0aWNrIGxhYmVscywgc29cbiAgICAgICAgLy8ganVzdCB0YWtlIGl0IG92ZXIgYW5kIGRyYXcgaXQgZnJvbSBoZXJlXG4gICAgICAgIGlmKGF4aXNPcHRzLnNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICBUaXRsZXMuZHJhdyhnZCwgYXhpc09wdHMuX2lkICsgJ3RpdGxlJywge1xuICAgICAgICAgICAgICAgIHByb3BDb250YWluZXI6IGF4aXNPcHRzLFxuICAgICAgICAgICAgICAgIHByb3BOYW1lOiBheGlzT3B0cy5fbmFtZSArICcudGl0bGUnLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBmdWxsTGF5b3V0Ll9kZmx0VGl0bGUueCxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGF4aXNPcHRzLl9vZmZzZXQgKyBheGlzT3B0cy5fbGVuZ3RoIC8gMixcbiAgICAgICAgICAgICAgICAgICAgeTogeSArIG9wdHMuX2hlaWdodCArIG9wdHMuX29mZnNldFNoaWZ0ICsgMTAgKyAxLjUgKiBheGlzT3B0cy50aXRsZS5mb250LnNpemUsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIHNldHVwRHJhZ0VsZW1lbnQocmFuZ2VTbGlkZXIsIGdkLCBheGlzT3B0cywgb3B0cykge1xuICAgIHZhciBzbGlkZUJveCA9IHJhbmdlU2xpZGVyLnNlbGVjdCgncmVjdC4nICsgY29uc3RhbnRzLnNsaWRlQm94Q2xhc3NOYW1lKS5ub2RlKCk7XG4gICAgdmFyIGdyYWJBcmVhTWluID0gcmFuZ2VTbGlkZXIuc2VsZWN0KCdyZWN0LicgKyBjb25zdGFudHMuZ3JhYkFyZWFNaW5DbGFzc05hbWUpLm5vZGUoKTtcbiAgICB2YXIgZ3JhYkFyZWFNYXggPSByYW5nZVNsaWRlci5zZWxlY3QoJ3JlY3QuJyArIGNvbnN0YW50cy5ncmFiQXJlYU1heENsYXNzTmFtZSkubm9kZSgpO1xuXG4gICAgcmFuZ2VTbGlkZXIub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBkMy5ldmVudDtcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgdmFyIHN0YXJ0WCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIHZhciBvZmZzZXRYID0gc3RhcnRYIC0gcmFuZ2VTbGlkZXIubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgIHZhciBtaW5WYWwgPSBvcHRzLmQycChheGlzT3B0cy5fcmxbMF0pO1xuICAgICAgICB2YXIgbWF4VmFsID0gb3B0cy5kMnAoYXhpc09wdHMuX3JsWzFdKTtcblxuICAgICAgICB2YXIgZHJhZ0NvdmVyID0gZHJhZ0VsZW1lbnQuY292ZXJTbGlwKCk7XG5cbiAgICAgICAgZHJhZ0NvdmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlTW92ZSk7XG4gICAgICAgIGRyYWdDb3Zlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VVcCk7XG5cbiAgICAgICAgZnVuY3Rpb24gbW91c2VNb3ZlKGUpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9ICtlLmNsaWVudFggLSBzdGFydFg7XG4gICAgICAgICAgICB2YXIgcGl4ZWxNaW4sIHBpeGVsTWF4LCBjdXJzb3I7XG5cbiAgICAgICAgICAgIHN3aXRjaCh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHNsaWRlQm94OlxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSAnZXctcmVzaXplJztcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxNaW4gPSBtaW5WYWwgKyBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxNYXggPSBtYXhWYWwgKyBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIGdyYWJBcmVhTWluOlxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSAnY29sLXJlc2l6ZSc7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsTWluID0gbWluVmFsICsgZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsTWF4ID0gbWF4VmFsO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgZ3JhYkFyZWFNYXg6XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9ICdjb2wtcmVzaXplJztcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxNaW4gPSBtaW5WYWw7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsTWF4ID0gbWF4VmFsICsgZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gJ2V3LXJlc2l6ZSc7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsTWluID0gb2Zmc2V0WDtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxNYXggPSBvZmZzZXRYICsgZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihwaXhlbE1heCA8IHBpeGVsTWluKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IHBpeGVsTWF4O1xuICAgICAgICAgICAgICAgIHBpeGVsTWF4ID0gcGl4ZWxNaW47XG4gICAgICAgICAgICAgICAgcGl4ZWxNaW4gPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdHMuX3BpeGVsTWluID0gcGl4ZWxNaW47XG4gICAgICAgICAgICBvcHRzLl9waXhlbE1heCA9IHBpeGVsTWF4O1xuXG4gICAgICAgICAgICBzZXRDdXJzb3IoZDMuc2VsZWN0KGRyYWdDb3ZlciksIGN1cnNvcik7XG4gICAgICAgICAgICBzZXREYXRhUmFuZ2UocmFuZ2VTbGlkZXIsIGdkLCBheGlzT3B0cywgb3B0cyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtb3VzZVVwKCkge1xuICAgICAgICAgICAgZHJhZ0NvdmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlTW92ZSk7XG4gICAgICAgICAgICBkcmFnQ292ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlVXApO1xuICAgICAgICAgICAgTGliLnJlbW92ZUVsZW1lbnQoZHJhZ0NvdmVyKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBzZXREYXRhUmFuZ2UocmFuZ2VTbGlkZXIsIGdkLCBheGlzT3B0cywgb3B0cykge1xuICAgIGZ1bmN0aW9uIGNsYW1wKHYpIHtcbiAgICAgICAgcmV0dXJuIGF4aXNPcHRzLmwycihMaWIuY29uc3RyYWluKHYsIG9wdHMuX3JsWzBdLCBvcHRzLl9ybFsxXSkpO1xuICAgIH1cblxuICAgIHZhciBkYXRhTWluID0gY2xhbXAob3B0cy5wMmQob3B0cy5fcGl4ZWxNaW4pKTtcbiAgICB2YXIgZGF0YU1heCA9IGNsYW1wKG9wdHMucDJkKG9wdHMuX3BpeGVsTWF4KSk7XG5cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBSZWdpc3RyeS5jYWxsKCdfZ3VpUmVsYXlvdXQnLCBnZCwgYXhpc09wdHMuX25hbWUgKyAnLnJhbmdlJywgW2RhdGFNaW4sIGRhdGFNYXhdKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0UGl4ZWxSYW5nZShyYW5nZVNsaWRlciwgZ2QsIGF4aXNPcHRzLCBvcHRzLCBvcHBBeGlzT3B0cywgb3BwQXhpc1JhbmdlT3B0cykge1xuICAgIHZhciBodzIgPSBjb25zdGFudHMuaGFuZGxlV2lkdGggLyAyO1xuXG4gICAgZnVuY3Rpb24gY2xhbXAodikge1xuICAgICAgICByZXR1cm4gTGliLmNvbnN0cmFpbih2LCAwLCBvcHRzLl93aWR0aCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xhbXBPcHBBeGlzKHYpIHtcbiAgICAgICAgcmV0dXJuIExpYi5jb25zdHJhaW4odiwgMCwgb3B0cy5faGVpZ2h0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcEhhbmRsZSh2KSB7XG4gICAgICAgIHJldHVybiBMaWIuY29uc3RyYWluKHYsIC1odzIsIG9wdHMuX3dpZHRoICsgaHcyKTtcbiAgICB9XG5cbiAgICB2YXIgcGl4ZWxNaW4gPSBjbGFtcChvcHRzLmQycChheGlzT3B0cy5fcmxbMF0pKTtcbiAgICB2YXIgcGl4ZWxNYXggPSBjbGFtcChvcHRzLmQycChheGlzT3B0cy5fcmxbMV0pKTtcblxuICAgIHJhbmdlU2xpZGVyLnNlbGVjdCgncmVjdC4nICsgY29uc3RhbnRzLnNsaWRlQm94Q2xhc3NOYW1lKVxuICAgICAgICAuYXR0cigneCcsIHBpeGVsTWluKVxuICAgICAgICAuYXR0cignd2lkdGgnLCBwaXhlbE1heCAtIHBpeGVsTWluKTtcblxuICAgIHJhbmdlU2xpZGVyLnNlbGVjdCgncmVjdC4nICsgY29uc3RhbnRzLm1hc2tNaW5DbGFzc05hbWUpXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIHBpeGVsTWluKTtcblxuICAgIHJhbmdlU2xpZGVyLnNlbGVjdCgncmVjdC4nICsgY29uc3RhbnRzLm1hc2tNYXhDbGFzc05hbWUpXG4gICAgICAgIC5hdHRyKCd4JywgcGl4ZWxNYXgpXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIG9wdHMuX3dpZHRoIC0gcGl4ZWxNYXgpO1xuXG4gICAgaWYob3BwQXhpc1JhbmdlT3B0cy5yYW5nZW1vZGUgIT09ICdtYXRjaCcpIHtcbiAgICAgICAgdmFyIHBpeGVsTWluT3BwQXhpcyA9IG9wdHMuX2hlaWdodCAtIGNsYW1wT3BwQXhpcyhvcHRzLmQycE9wcEF4aXMob3BwQXhpc09wdHMuX3JsWzFdKSk7XG4gICAgICAgIHZhciBwaXhlbE1heE9wcEF4aXMgPSBvcHRzLl9oZWlnaHQgLSBjbGFtcE9wcEF4aXMob3B0cy5kMnBPcHBBeGlzKG9wcEF4aXNPcHRzLl9ybFswXSkpO1xuXG4gICAgICAgIHJhbmdlU2xpZGVyLnNlbGVjdCgncmVjdC4nICsgY29uc3RhbnRzLm1hc2tNaW5PcHBBeGlzQ2xhc3NOYW1lKVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBwaXhlbE1pbilcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBwaXhlbE1pbk9wcEF4aXMpXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBwaXhlbE1heCAtIHBpeGVsTWluKTtcblxuICAgICAgICByYW5nZVNsaWRlci5zZWxlY3QoJ3JlY3QuJyArIGNvbnN0YW50cy5tYXNrTWF4T3BwQXhpc0NsYXNzTmFtZSlcbiAgICAgICAgICAgIC5hdHRyKCd4JywgcGl4ZWxNaW4pXG4gICAgICAgICAgICAuYXR0cigneScsIHBpeGVsTWF4T3BwQXhpcylcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvcHRzLl9oZWlnaHQgLSBwaXhlbE1heE9wcEF4aXMpXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBwaXhlbE1heCAtIHBpeGVsTWluKTtcblxuICAgICAgICByYW5nZVNsaWRlci5zZWxlY3QoJ3JlY3QuJyArIGNvbnN0YW50cy5zbGlkZUJveENsYXNzTmFtZSlcbiAgICAgICAgICAgIC5hdHRyKCd5JywgcGl4ZWxNaW5PcHBBeGlzKVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHBpeGVsTWF4T3BwQXhpcyAtIHBpeGVsTWluT3BwQXhpcyk7XG4gICAgfVxuXG4gICAgLy8gYWRkIG9mZnNldCBmb3IgY3Jpc3BpZXIgY29ybmVyc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbG90bHkvcGxvdGx5LmpzL3B1bGwvMTQwOVxuICAgIHZhciBvZmZzZXQgPSAwLjU7XG5cbiAgICB2YXIgeE1pbiA9IE1hdGgucm91bmQoY2xhbXBIYW5kbGUocGl4ZWxNaW4gLSBodzIpKSAtIG9mZnNldDtcbiAgICB2YXIgeE1heCA9IE1hdGgucm91bmQoY2xhbXBIYW5kbGUocGl4ZWxNYXggLSBodzIpKSArIG9mZnNldDtcblxuICAgIHJhbmdlU2xpZGVyLnNlbGVjdCgnZy4nICsgY29uc3RhbnRzLmdyYWJiZXJNaW5DbGFzc05hbWUpXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4TWluICsgJywnICsgb2Zmc2V0ICsgJyknKTtcblxuICAgIHJhbmdlU2xpZGVyLnNlbGVjdCgnZy4nICsgY29uc3RhbnRzLmdyYWJiZXJNYXhDbGFzc05hbWUpXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4TWF4ICsgJywnICsgb2Zmc2V0ICsgJyknKTtcbn1cblxuZnVuY3Rpb24gZHJhd0JnKHJhbmdlU2xpZGVyLCBnZCwgYXhpc09wdHMsIG9wdHMpIHtcbiAgICB2YXIgYmcgPSBMaWIuZW5zdXJlU2luZ2xlKHJhbmdlU2xpZGVyLCAncmVjdCcsIGNvbnN0YW50cy5iZ0NsYXNzTmFtZSwgZnVuY3Rpb24ocykge1xuICAgICAgICBzLmF0dHIoe1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAnc2hhcGUtcmVuZGVyaW5nJzogJ2NyaXNwRWRnZXMnXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGJvcmRlckNvcnJlY3QgPSAob3B0cy5ib3JkZXJ3aWR0aCAlIDIpID09PSAwID9cbiAgICAgICAgb3B0cy5ib3JkZXJ3aWR0aCA6XG4gICAgICAgIG9wdHMuYm9yZGVyd2lkdGggLSAxO1xuXG4gICAgdmFyIG9mZnNldFNoaWZ0ID0gLW9wdHMuX29mZnNldFNoaWZ0O1xuICAgIHZhciBsdyA9IERyYXdpbmcuY3Jpc3BSb3VuZChnZCwgb3B0cy5ib3JkZXJ3aWR0aCk7XG5cbiAgICBiZy5hdHRyKHtcbiAgICAgICAgd2lkdGg6IG9wdHMuX3dpZHRoICsgYm9yZGVyQ29ycmVjdCxcbiAgICAgICAgaGVpZ2h0OiBvcHRzLl9oZWlnaHQgKyBib3JkZXJDb3JyZWN0LFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIG9mZnNldFNoaWZ0ICsgJywnICsgb2Zmc2V0U2hpZnQgKyAnKScsXG4gICAgICAgIGZpbGw6IG9wdHMuYmdjb2xvcixcbiAgICAgICAgc3Ryb2tlOiBvcHRzLmJvcmRlcmNvbG9yLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogbHdcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkQ2xpcFBhdGgocmFuZ2VTbGlkZXIsIGdkLCBheGlzT3B0cywgb3B0cykge1xuICAgIHZhciBmdWxsTGF5b3V0ID0gZ2QuX2Z1bGxMYXlvdXQ7XG5cbiAgICB2YXIgY2xpcFBhdGggPSBMaWIuZW5zdXJlU2luZ2xlQnlJZChmdWxsTGF5b3V0Ll90b3BkZWZzLCAnY2xpcFBhdGgnLCBvcHRzLl9jbGlwSWQsIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcy5hcHBlbmQoJ3JlY3QnKS5hdHRyKHsgeDogMCwgeTogMCB9KTtcbiAgICB9KTtcblxuICAgIGNsaXBQYXRoLnNlbGVjdCgncmVjdCcpLmF0dHIoe1xuICAgICAgICB3aWR0aDogb3B0cy5fd2lkdGgsXG4gICAgICAgIGhlaWdodDogb3B0cy5faGVpZ2h0XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGRyYXdSYW5nZVBsb3QocmFuZ2VTbGlkZXIsIGdkLCBheGlzT3B0cywgb3B0cykge1xuICAgIHZhciBjYWxjRGF0YSA9IGdkLmNhbGNkYXRhO1xuXG4gICAgdmFyIHJhbmdlUGxvdHMgPSByYW5nZVNsaWRlci5zZWxlY3RBbGwoJ2cuJyArIGNvbnN0YW50cy5yYW5nZVBsb3RDbGFzc05hbWUpXG4gICAgICAgIC5kYXRhKGF4aXNPcHRzLl9zdWJwbG90c1dpdGgsIExpYi5pZGVudGl0eSk7XG5cbiAgICByYW5nZVBsb3RzLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oaWQpIHsgcmV0dXJuIGNvbnN0YW50cy5yYW5nZVBsb3RDbGFzc05hbWUgKyAnICcgKyBpZDsgfSlcbiAgICAgICAgLmNhbGwoRHJhd2luZy5zZXRDbGlwVXJsLCBvcHRzLl9jbGlwSWQsIGdkKTtcblxuICAgIHJhbmdlUGxvdHMub3JkZXIoKTtcblxuICAgIHJhbmdlUGxvdHMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgdmFyIG1haW5wbG90aW5mbztcblxuICAgIHJhbmdlUGxvdHMuZWFjaChmdW5jdGlvbihpZCwgaSkge1xuICAgICAgICB2YXIgcGxvdGdyb3VwID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICB2YXIgaXNNYWluUGxvdCA9IChpID09PSAwKTtcblxuICAgICAgICB2YXIgb3BwQXhpc09wdHMgPSBheGlzSURzLmdldEZyb21JZChnZCwgaWQsICd5Jyk7XG4gICAgICAgIHZhciBvcHBBeGlzTmFtZSA9IG9wcEF4aXNPcHRzLl9uYW1lO1xuICAgICAgICB2YXIgb3BwQXhpc1JhbmdlT3B0cyA9IG9wdHNbb3BwQXhpc05hbWVdO1xuXG4gICAgICAgIHZhciBtb2NrRmlndXJlID0ge1xuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBheGlzT3B0cy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBkb21haW46IFswLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IG9wdHMucmFuZ2Uuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXI6IGF4aXNPcHRzLmNhbGVuZGFyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3aWR0aDogb3B0cy5fd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBvcHRzLl9oZWlnaHQsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiB7IHQ6IDAsIGI6IDAsIGw6IDAsIHI6IDAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jb250ZXh0OiBnZC5fY29udGV4dFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKGF4aXNPcHRzLnJhbmdlYnJlYWtzKSB7XG4gICAgICAgICAgICBtb2NrRmlndXJlLmxheW91dC54YXhpcy5yYW5nZWJyZWFrcyA9IGF4aXNPcHRzLnJhbmdlYnJlYWtzO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9ja0ZpZ3VyZS5sYXlvdXRbb3BwQXhpc05hbWVdID0ge1xuICAgICAgICAgICAgdHlwZTogb3BwQXhpc09wdHMudHlwZSxcbiAgICAgICAgICAgIGRvbWFpbjogWzAsIDFdLFxuICAgICAgICAgICAgcmFuZ2U6IG9wcEF4aXNSYW5nZU9wdHMucmFuZ2Vtb2RlICE9PSAnbWF0Y2gnID8gb3BwQXhpc1JhbmdlT3B0cy5yYW5nZS5zbGljZSgpIDogb3BwQXhpc09wdHMucmFuZ2Uuc2xpY2UoKSxcbiAgICAgICAgICAgIGNhbGVuZGFyOiBvcHBBeGlzT3B0cy5jYWxlbmRhclxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKG9wcEF4aXNPcHRzLnJhbmdlYnJlYWtzKSB7XG4gICAgICAgICAgICBtb2NrRmlndXJlLmxheW91dFtvcHBBeGlzTmFtZV0ucmFuZ2VicmVha3MgPSBvcHBBeGlzT3B0cy5yYW5nZWJyZWFrcztcbiAgICAgICAgfVxuXG4gICAgICAgIFBsb3RzLnN1cHBseURlZmF1bHRzKG1vY2tGaWd1cmUpO1xuXG4gICAgICAgIHZhciB4YSA9IG1vY2tGaWd1cmUuX2Z1bGxMYXlvdXQueGF4aXM7XG4gICAgICAgIHZhciB5YSA9IG1vY2tGaWd1cmUuX2Z1bGxMYXlvdXRbb3BwQXhpc05hbWVdO1xuXG4gICAgICAgIHhhLmNsZWFyQ2FsYygpO1xuICAgICAgICB4YS5zZXRTY2FsZSgpO1xuICAgICAgICB5YS5jbGVhckNhbGMoKTtcbiAgICAgICAgeWEuc2V0U2NhbGUoKTtcblxuICAgICAgICB2YXIgcGxvdGluZm8gPSB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBwbG90Z3JvdXA6IHBsb3Rncm91cCxcbiAgICAgICAgICAgIHhheGlzOiB4YSxcbiAgICAgICAgICAgIHlheGlzOiB5YSxcbiAgICAgICAgICAgIGlzUmFuZ2VQbG90OiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoaXNNYWluUGxvdCkgbWFpbnBsb3RpbmZvID0gcGxvdGluZm87XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGxvdGluZm8ubWFpbnBsb3QgPSAneHknO1xuICAgICAgICAgICAgcGxvdGluZm8ubWFpbnBsb3RpbmZvID0gbWFpbnBsb3RpbmZvO1xuICAgICAgICB9XG5cbiAgICAgICAgQ2FydGVzaWFuLnJhbmdlUGxvdChnZCwgcGxvdGluZm8sIGZpbHRlclJhbmdlUGxvdENhbGNEYXRhKGNhbGNEYXRhLCBpZCkpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJSYW5nZVBsb3RDYWxjRGF0YShjYWxjRGF0YSwgc3VicGxvdElkKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNhbGNEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjYWxjVHJhY2UgPSBjYWxjRGF0YVtpXTtcbiAgICAgICAgdmFyIHRyYWNlID0gY2FsY1RyYWNlWzBdLnRyYWNlO1xuXG4gICAgICAgIGlmKHRyYWNlLnhheGlzICsgdHJhY2UueWF4aXMgPT09IHN1YnBsb3RJZCkge1xuICAgICAgICAgICAgb3V0LnB1c2goY2FsY1RyYWNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGRyYXdNYXNrcyhyYW5nZVNsaWRlciwgZ2QsIGF4aXNPcHRzLCBvcHRzLCBvcHBBeGlzUmFuZ2VPcHRzKSB7XG4gICAgdmFyIG1hc2tNaW4gPSBMaWIuZW5zdXJlU2luZ2xlKHJhbmdlU2xpZGVyLCAncmVjdCcsIGNvbnN0YW50cy5tYXNrTWluQ2xhc3NOYW1lLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHMuYXR0cih7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICdzaGFwZS1yZW5kZXJpbmcnOiAnY3Jpc3BFZGdlcydcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBtYXNrTWluXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBvcHRzLl9oZWlnaHQpXG4gICAgICAgIC5jYWxsKENvbG9yLmZpbGwsIGNvbnN0YW50cy5tYXNrQ29sb3IpO1xuXG4gICAgdmFyIG1hc2tNYXggPSBMaWIuZW5zdXJlU2luZ2xlKHJhbmdlU2xpZGVyLCAncmVjdCcsIGNvbnN0YW50cy5tYXNrTWF4Q2xhc3NOYW1lLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHMuYXR0cih7XG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgJ3NoYXBlLXJlbmRlcmluZyc6ICdjcmlzcEVkZ2VzJ1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIG1hc2tNYXhcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIG9wdHMuX2hlaWdodClcbiAgICAgICAgLmNhbGwoQ29sb3IuZmlsbCwgY29uc3RhbnRzLm1hc2tDb2xvcik7XG5cbiAgICAvLyBtYXNrcyB1c2VkIGZvciBvcHBBeGlzIHpvb21cbiAgICBpZihvcHBBeGlzUmFuZ2VPcHRzLnJhbmdlbW9kZSAhPT0gJ21hdGNoJykge1xuICAgICAgICB2YXIgbWFza01pbk9wcEF4aXMgPSBMaWIuZW5zdXJlU2luZ2xlKHJhbmdlU2xpZGVyLCAncmVjdCcsIGNvbnN0YW50cy5tYXNrTWluT3BwQXhpc0NsYXNzTmFtZSwgZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgcy5hdHRyKHtcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICdzaGFwZS1yZW5kZXJpbmcnOiAnY3Jpc3BFZGdlcydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBtYXNrTWluT3BwQXhpc1xuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgb3B0cy5fd2lkdGgpXG4gICAgICAgICAgICAuY2FsbChDb2xvci5maWxsLCBjb25zdGFudHMubWFza09wcEF4aXNDb2xvcik7XG5cbiAgICAgICAgdmFyIG1hc2tNYXhPcHBBeGlzID0gTGliLmVuc3VyZVNpbmdsZShyYW5nZVNsaWRlciwgJ3JlY3QnLCBjb25zdGFudHMubWFza01heE9wcEF4aXNDbGFzc05hbWUsIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIHMuYXR0cih7XG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAnc2hhcGUtcmVuZGVyaW5nJzogJ2NyaXNwRWRnZXMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWFza01heE9wcEF4aXNcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG9wdHMuX3dpZHRoKVxuICAgICAgICAgICAgLnN0eWxlKCdib3JkZXItdG9wJywgY29uc3RhbnRzLm1hc2tPcHBCb3JkZXIpXG4gICAgICAgICAgICAuY2FsbChDb2xvci5maWxsLCBjb25zdGFudHMubWFza09wcEF4aXNDb2xvcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmF3U2xpZGVCb3gocmFuZ2VTbGlkZXIsIGdkLCBheGlzT3B0cywgb3B0cykge1xuICAgIGlmKGdkLl9jb250ZXh0LnN0YXRpY1Bsb3QpIHJldHVybjtcblxuICAgIHZhciBzbGlkZUJveCA9IExpYi5lbnN1cmVTaW5nbGUocmFuZ2VTbGlkZXIsICdyZWN0JywgY29uc3RhbnRzLnNsaWRlQm94Q2xhc3NOYW1lLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHMuYXR0cih7XG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgY3Vyc29yOiBjb25zdGFudHMuc2xpZGVCb3hDdXJzb3IsXG4gICAgICAgICAgICAnc2hhcGUtcmVuZGVyaW5nJzogJ2NyaXNwRWRnZXMnXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2xpZGVCb3guYXR0cih7XG4gICAgICAgIGhlaWdodDogb3B0cy5faGVpZ2h0LFxuICAgICAgICBmaWxsOiBjb25zdGFudHMuc2xpZGVCb3hGaWxsXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGRyYXdHcmFiYmVycyhyYW5nZVNsaWRlciwgZ2QsIGF4aXNPcHRzLCBvcHRzKSB7XG4gICAgLy8gPGcgZ3JhYmJlciAvPlxuICAgIHZhciBncmFiYmVyTWluID0gTGliLmVuc3VyZVNpbmdsZShyYW5nZVNsaWRlciwgJ2cnLCBjb25zdGFudHMuZ3JhYmJlck1pbkNsYXNzTmFtZSk7XG4gICAgdmFyIGdyYWJiZXJNYXggPSBMaWIuZW5zdXJlU2luZ2xlKHJhbmdlU2xpZGVyLCAnZycsIGNvbnN0YW50cy5ncmFiYmVyTWF4Q2xhc3NOYW1lKTtcblxuICAgIC8vIDxnIGhhbmRsZSAvPlxuICAgIHZhciBoYW5kbGVGaXhBdHRycyA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgd2lkdGg6IGNvbnN0YW50cy5oYW5kbGVXaWR0aCxcbiAgICAgICAgcng6IGNvbnN0YW50cy5oYW5kbGVSYWRpdXMsXG4gICAgICAgIGZpbGw6IENvbG9yLmJhY2tncm91bmQsXG4gICAgICAgIHN0cm9rZTogQ29sb3IuZGVmYXVsdExpbmUsXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiBjb25zdGFudHMuaGFuZGxlU3Ryb2tlV2lkdGgsXG4gICAgICAgICdzaGFwZS1yZW5kZXJpbmcnOiAnY3Jpc3BFZGdlcydcbiAgICB9O1xuICAgIHZhciBoYW5kbGVEeW5hbWljQXR0cnMgPSB7XG4gICAgICAgIHk6IE1hdGgucm91bmQob3B0cy5faGVpZ2h0IC8gNCksXG4gICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChvcHRzLl9oZWlnaHQgLyAyKSxcbiAgICB9O1xuICAgIHZhciBoYW5kbGVNaW4gPSBMaWIuZW5zdXJlU2luZ2xlKGdyYWJiZXJNaW4sICdyZWN0JywgY29uc3RhbnRzLmhhbmRsZU1pbkNsYXNzTmFtZSwgZnVuY3Rpb24ocykge1xuICAgICAgICBzLmF0dHIoaGFuZGxlRml4QXR0cnMpO1xuICAgIH0pO1xuICAgIGhhbmRsZU1pbi5hdHRyKGhhbmRsZUR5bmFtaWNBdHRycyk7XG5cbiAgICB2YXIgaGFuZGxlTWF4ID0gTGliLmVuc3VyZVNpbmdsZShncmFiYmVyTWF4LCAncmVjdCcsIGNvbnN0YW50cy5oYW5kbGVNYXhDbGFzc05hbWUsIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcy5hdHRyKGhhbmRsZUZpeEF0dHJzKTtcbiAgICB9KTtcbiAgICBoYW5kbGVNYXguYXR0cihoYW5kbGVEeW5hbWljQXR0cnMpO1xuXG4gICAgLy8gPGcgZ3JhYmFyZWEgLz5cbiAgICBpZihnZC5fY29udGV4dC5zdGF0aWNQbG90KSByZXR1cm47XG5cbiAgICB2YXIgZ3JhYkFyZWFGaXhBdHRycyA9IHtcbiAgICAgICAgd2lkdGg6IGNvbnN0YW50cy5ncmFiQXJlYVdpZHRoLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBmaWxsOiBjb25zdGFudHMuZ3JhYkFyZWFGaWxsLFxuICAgICAgICBjdXJzb3I6IGNvbnN0YW50cy5ncmFiQXJlYUN1cnNvclxuICAgIH07XG5cbiAgICB2YXIgZ3JhYkFyZWFNaW4gPSBMaWIuZW5zdXJlU2luZ2xlKGdyYWJiZXJNaW4sICdyZWN0JywgY29uc3RhbnRzLmdyYWJBcmVhTWluQ2xhc3NOYW1lLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHMuYXR0cihncmFiQXJlYUZpeEF0dHJzKTtcbiAgICB9KTtcbiAgICBncmFiQXJlYU1pbi5hdHRyKCdoZWlnaHQnLCBvcHRzLl9oZWlnaHQpO1xuXG4gICAgdmFyIGdyYWJBcmVhTWF4ID0gTGliLmVuc3VyZVNpbmdsZShncmFiYmVyTWF4LCAncmVjdCcsIGNvbnN0YW50cy5ncmFiQXJlYU1heENsYXNzTmFtZSwgZnVuY3Rpb24ocykge1xuICAgICAgICBzLmF0dHIoZ3JhYkFyZWFGaXhBdHRycyk7XG4gICAgfSk7XG4gICAgZ3JhYkFyZWFNYXguYXR0cignaGVpZ2h0Jywgb3B0cy5faGVpZ2h0KTtcbn1cbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF4aXNJRHMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9jYXJ0ZXNpYW4vYXhpc19pZHMnKTtcbnZhciBzdmdUZXh0VXRpbHMgPSByZXF1aXJlKCcuLi8uLi9saWIvc3ZnX3RleHRfdXRpbHMnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xudmFyIExJTkVfU1BBQ0lORyA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0YW50cy9hbGlnbm1lbnQnKS5MSU5FX1NQQUNJTkc7XG52YXIgbmFtZSA9IGNvbnN0YW50cy5uYW1lO1xuXG5mdW5jdGlvbiBpc1Zpc2libGUoYXgpIHtcbiAgICB2YXIgcmFuZ2VTbGlkZXIgPSBheCAmJiBheFtuYW1lXTtcbiAgICByZXR1cm4gcmFuZ2VTbGlkZXIgJiYgcmFuZ2VTbGlkZXIudmlzaWJsZTtcbn1cbmV4cG9ydHMuaXNWaXNpYmxlID0gaXNWaXNpYmxlO1xuXG5leHBvcnRzLm1ha2VEYXRhID0gZnVuY3Rpb24oZnVsbExheW91dCkge1xuICAgIHZhciBheGVzID0gYXhpc0lEcy5saXN0KHsgX2Z1bGxMYXlvdXQ6IGZ1bGxMYXlvdXQgfSwgJ3gnLCB0cnVlKTtcbiAgICB2YXIgbWFyZ2luID0gZnVsbExheW91dC5tYXJnaW47XG4gICAgdmFyIHJhbmdlU2xpZGVyRGF0YSA9IFtdO1xuXG4gICAgaWYoIWZ1bGxMYXlvdXQuX2hhcygnZ2wyZCcpKSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXggPSBheGVzW2ldO1xuXG4gICAgICAgICAgICBpZihpc1Zpc2libGUoYXgpKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VTbGlkZXJEYXRhLnB1c2goYXgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG9wdHMgPSBheFtuYW1lXTtcbiAgICAgICAgICAgICAgICBvcHRzLl9pZCA9IG5hbWUgKyBheC5faWQ7XG4gICAgICAgICAgICAgICAgb3B0cy5faGVpZ2h0ID0gKGZ1bGxMYXlvdXQuaGVpZ2h0IC0gbWFyZ2luLmIgLSBtYXJnaW4udCkgKiBvcHRzLnRoaWNrbmVzcztcbiAgICAgICAgICAgICAgICBvcHRzLl9vZmZzZXRTaGlmdCA9IE1hdGguZmxvb3Iob3B0cy5ib3JkZXJ3aWR0aCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVsbExheW91dC5fcmFuZ2VTbGlkZXJEYXRhID0gcmFuZ2VTbGlkZXJEYXRhO1xufTtcblxuZXhwb3J0cy5hdXRvTWFyZ2luT3B0cyA9IGZ1bmN0aW9uKGdkLCBheCkge1xuICAgIHZhciBmdWxsTGF5b3V0ID0gZ2QuX2Z1bGxMYXlvdXQ7XG4gICAgdmFyIG9wdHMgPSBheFtuYW1lXTtcbiAgICB2YXIgYXhMZXR0ZXIgPSBheC5faWQuY2hhckF0KDApO1xuXG4gICAgdmFyIGJvdHRvbURlcHRoID0gMDtcbiAgICB2YXIgdGl0bGVIZWlnaHQgPSAwO1xuICAgIGlmKGF4LnNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGJvdHRvbURlcHRoID0gYXguX2RlcHRoO1xuICAgICAgICBpZihheC50aXRsZS50ZXh0ICE9PSBmdWxsTGF5b3V0Ll9kZmx0VGl0bGVbYXhMZXR0ZXJdKSB7XG4gICAgICAgICAgICAvLyBhcyBpbiByYW5nZXNsaWRlci9kcmF3LmpzXG4gICAgICAgICAgICB0aXRsZUhlaWdodCA9IDEuNSAqIGF4LnRpdGxlLmZvbnQuc2l6ZSArIDEwICsgb3B0cy5fb2Zmc2V0U2hpZnQ7XG4gICAgICAgICAgICAvLyBtdWx0aS1saW5lIGV4dHJhIGJ1bXBcbiAgICAgICAgICAgIHZhciBleHRyYUxpbmVzID0gKGF4LnRpdGxlLnRleHQubWF0Y2goc3ZnVGV4dFV0aWxzLkJSX1RBR19BTEwpIHx8IFtdKS5sZW5ndGg7XG4gICAgICAgICAgICB0aXRsZUhlaWdodCArPSBleHRyYUxpbmVzICogYXgudGl0bGUuZm9udC5zaXplICogTElORV9TUEFDSU5HO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogYXguX2NvdW50ZXJEb21haW5NaW4sXG4gICAgICAgIGw6IDAsXG4gICAgICAgIHI6IDAsXG4gICAgICAgIHQ6IDAsXG4gICAgICAgIGI6IG9wdHMuX2hlaWdodCArIGJvdHRvbURlcHRoICsgTWF0aC5tYXgoZnVsbExheW91dC5tYXJnaW4uYiwgdGl0bGVIZWlnaHQpLFxuICAgICAgICBwYWQ6IGNvbnN0YW50cy5leHRyYVBhZCArIG9wdHMuX29mZnNldFNoaWZ0ICogMlxuICAgIH07XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGliID0gcmVxdWlyZSgnLi4vLi4vbGliJyk7XG52YXIgYXR0cnMgPSByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKTtcbnZhciBvcHBBeGlzQXR0cnMgPSByZXF1aXJlKCcuL29wcGF4aXNfYXR0cmlidXRlcycpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbW9kdWxlVHlwZTogJ2NvbXBvbmVudCcsXG4gICAgbmFtZTogJ3Jhbmdlc2xpZGVyJyxcblxuICAgIHNjaGVtYToge1xuICAgICAgICBzdWJwbG90czoge1xuICAgICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgICAgICByYW5nZXNsaWRlcjogTGliLmV4dGVuZEZsYXQoe30sIGF0dHJzLCB7XG4gICAgICAgICAgICAgICAgICAgIHlheGlzOiBvcHBBeGlzQXR0cnNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGxheW91dEF0dHJpYnV0ZXM6IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpLFxuICAgIGhhbmRsZURlZmF1bHRzOiByZXF1aXJlKCcuL2RlZmF1bHRzJyksXG4gICAgY2FsY0F1dG9yYW5nZTogcmVxdWlyZSgnLi9jYWxjX2F1dG9yYW5nZScpLFxuICAgIGRyYXc6IHJlcXVpcmUoJy4vZHJhdycpLFxuICAgIGlzVmlzaWJsZTogaGVscGVycy5pc1Zpc2libGUsXG4gICAgbWFrZURhdGE6IGhlbHBlcnMubWFrZURhdGEsXG4gICAgYXV0b01hcmdpbk9wdHM6IGhlbHBlcnMuYXV0b01hcmdpbk9wdHNcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8vIG5vdCByZWFsbHkgYSAnc3VicGxvdCcgYXR0cmlidXRlIGNvbnRhaW5lcixcbiAgICAvLyBidXQgdGhpcyBpcyB0aGUgZmxhZyB3ZSB1c2UgdG8gZGVub3RlIGF0dHJpYnV0ZXMgdGhhdFxuICAgIC8vIHN1cHBvcnQgeWF4aXMsIHlheGlzMiwgeWF4aXMzLCAuLi4gY291bnRlcnNcbiAgICBfaXNTdWJwbG90T2JqOiB0cnVlLFxuXG4gICAgcmFuZ2Vtb2RlOiB7XG4gICAgICAgIHZhbFR5cGU6ICdlbnVtZXJhdGVkJyxcbiAgICAgICAgdmFsdWVzOiBbJ2F1dG8nLCAnZml4ZWQnLCAnbWF0Y2gnXSxcbiAgICAgICAgZGZsdDogJ21hdGNoJyxcbiAgICAgICAgcm9sZTogJ3N0eWxlJyxcbiAgICAgICAgZWRpdFR5cGU6ICdjYWxjJyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSByYW5nZSBvZiB0aGlzIGF4aXMgaW4nLFxuICAgICAgICAgICAgJ3RoZSByYW5nZXNsaWRlciB1c2UgdGhlIHNhbWUgdmFsdWUgdGhhbiBpbiB0aGUgbWFpbiBwbG90JyxcbiAgICAgICAgICAgICd3aGVuIHpvb21pbmcgaW4vb3V0LicsXG4gICAgICAgICAgICAnSWYgKmF1dG8qLCB0aGUgYXV0b3JhbmdlIHdpbGwgYmUgdXNlZC4nLFxuICAgICAgICAgICAgJ0lmICpmaXhlZCosIHRoZSBgcmFuZ2VgIGlzIHVzZWQuJyxcbiAgICAgICAgICAgICdJZiAqbWF0Y2gqLCB0aGUgY3VycmVudCByYW5nZSBvZiB0aGUgY29ycmVzcG9uZGluZyB5LWF4aXMgb24gdGhlIG1haW4gc3VicGxvdCBpcyB1c2VkLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuICAgIHJhbmdlOiB7XG4gICAgICAgIHZhbFR5cGU6ICdpbmZvX2FycmF5JyxcbiAgICAgICAgcm9sZTogJ3N0eWxlJyxcbiAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgIHt2YWxUeXBlOiAnYW55JywgZWRpdFR5cGU6ICdwbG90J30sXG4gICAgICAgICAgICB7dmFsVHlwZTogJ2FueScsIGVkaXRUeXBlOiAncGxvdCd9XG4gICAgICAgIF0sXG4gICAgICAgIGVkaXRUeXBlOiAncGxvdCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU2V0cyB0aGUgcmFuZ2Ugb2YgdGhpcyBheGlzIGZvciB0aGUgcmFuZ2VzbGlkZXIuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgZWRpdFR5cGU6ICdjYWxjJ1xufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFubkF0dHJzID0gcmVxdWlyZSgnLi4vYW5ub3RhdGlvbnMvYXR0cmlidXRlcycpO1xudmFyIHNjYXR0ZXJMaW5lQXR0cnMgPSByZXF1aXJlKCcuLi8uLi90cmFjZXMvc2NhdHRlci9hdHRyaWJ1dGVzJykubGluZTtcbnZhciBkYXNoID0gcmVxdWlyZSgnLi4vZHJhd2luZy9hdHRyaWJ1dGVzJykuZGFzaDtcbnZhciBleHRlbmRGbGF0ID0gcmVxdWlyZSgnLi4vLi4vbGliL2V4dGVuZCcpLmV4dGVuZEZsYXQ7XG52YXIgdGVtcGxhdGVkQXJyYXkgPSByZXF1aXJlKCcuLi8uLi9wbG90X2FwaS9wbG90X3RlbXBsYXRlJykudGVtcGxhdGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGVkQXJyYXkoJ3NoYXBlJywge1xuICAgIHZpc2libGU6IHtcbiAgICAgICAgdmFsVHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGRmbHQ6IHRydWUsXG4gICAgICAgIGVkaXRUeXBlOiAnY2FsYythcnJheWRyYXcnLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ0RldGVybWluZXMgd2hldGhlciBvciBub3QgdGhpcyBzaGFwZSBpcyB2aXNpYmxlLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuXG4gICAgdHlwZToge1xuICAgICAgICB2YWxUeXBlOiAnZW51bWVyYXRlZCcsXG4gICAgICAgIHZhbHVlczogWydjaXJjbGUnLCAncmVjdCcsICdwYXRoJywgJ2xpbmUnXSxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBlZGl0VHlwZTogJ2NhbGMrYXJyYXlkcmF3JyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTcGVjaWZpZXMgdGhlIHNoYXBlIHR5cGUgdG8gYmUgZHJhd24uJyxcblxuICAgICAgICAgICAgJ0lmICpsaW5lKiwgYSBsaW5lIGlzIGRyYXduIGZyb20gKGB4MGAsYHkwYCkgdG8gKGB4MWAsYHkxYCknLFxuICAgICAgICAgICAgJ3dpdGggcmVzcGVjdCB0byB0aGUgYXhlc1xcJyBzaXppbmcgbW9kZS4nLFxuXG4gICAgICAgICAgICAnSWYgKmNpcmNsZSosIGEgY2lyY2xlIGlzIGRyYXduIGZyb20nLFxuICAgICAgICAgICAgJygoYHgwYCtgeDFgKS8yLCAoYHkwYCtgeTFgKS8yKSknLFxuICAgICAgICAgICAgJ3dpdGggcmFkaXVzJyxcbiAgICAgICAgICAgICcofChgeDBgK2B4MWApLzIgLSBgeDBgfCwgfChgeTBgK2B5MWApLzIgLWB5MGApfCknLFxuICAgICAgICAgICAgJ3dpdGggcmVzcGVjdCB0byB0aGUgYXhlc1xcJyBzaXppbmcgbW9kZS4nLFxuXG4gICAgICAgICAgICAnSWYgKnJlY3QqLCBhIHJlY3RhbmdsZSBpcyBkcmF3biBsaW5raW5nJyxcbiAgICAgICAgICAgICcoYHgwYCxgeTBgKSwgKGB4MWAsYHkwYCksIChgeDFgLGB5MWApLCAoYHgwYCxgeTFgKSwgKGB4MGAsYHkwYCknLFxuICAgICAgICAgICAgJ3dpdGggcmVzcGVjdCB0byB0aGUgYXhlc1xcJyBzaXppbmcgbW9kZS4nLFxuXG4gICAgICAgICAgICAnSWYgKnBhdGgqLCBkcmF3IGEgY3VzdG9tIFNWRyBwYXRoIHVzaW5nIGBwYXRoYC4nLFxuICAgICAgICAgICAgJ3dpdGggcmVzcGVjdCB0byB0aGUgYXhlc1xcJyBzaXppbmcgbW9kZS4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcblxuICAgIGxheWVyOiB7XG4gICAgICAgIHZhbFR5cGU6ICdlbnVtZXJhdGVkJyxcbiAgICAgICAgdmFsdWVzOiBbJ2JlbG93JywgJ2Fib3ZlJ10sXG4gICAgICAgIGRmbHQ6ICdhYm92ZScsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgZWRpdFR5cGU6ICdhcnJheWRyYXcnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1NwZWNpZmllcyB3aGV0aGVyIHNoYXBlcyBhcmUgZHJhd24gYmVsb3cgb3IgYWJvdmUgdHJhY2VzLidcbiAgICB9LFxuXG4gICAgeHJlZjogZXh0ZW5kRmxhdCh7fSwgYW5uQXR0cnMueHJlZiwge1xuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1NldHMgdGhlIHNoYXBlXFwncyB4IGNvb3JkaW5hdGUgYXhpcy4nLFxuICAgICAgICAgICAgJ0lmIHNldCB0byBhbiB4IGF4aXMgaWQgKGUuZy4gKngqIG9yICp4MiopLCB0aGUgYHhgIHBvc2l0aW9uJyxcbiAgICAgICAgICAgICdyZWZlcnMgdG8gYW4geCBjb29yZGluYXRlLicsXG4gICAgICAgICAgICAnSWYgc2V0IHRvICpwYXBlciosIHRoZSBgeGAgcG9zaXRpb24gcmVmZXJzIHRvIHRoZSBkaXN0YW5jZSBmcm9tJyxcbiAgICAgICAgICAgICd0aGUgbGVmdCBzaWRlIG9mIHRoZSBwbG90dGluZyBhcmVhIGluIG5vcm1hbGl6ZWQgY29vcmRpbmF0ZXMnLFxuICAgICAgICAgICAgJ3doZXJlICowKiAoKjEqKSBjb3JyZXNwb25kcyB0byB0aGUgbGVmdCAocmlnaHQpIHNpZGUuJyxcbiAgICAgICAgICAgICdJZiB0aGUgYXhpcyBgdHlwZWAgaXMgKmxvZyosIHRoZW4geW91IG11c3QgdGFrZSB0aGUnLFxuICAgICAgICAgICAgJ2xvZyBvZiB5b3VyIGRlc2lyZWQgcmFuZ2UuJyxcbiAgICAgICAgICAgICdJZiB0aGUgYXhpcyBgdHlwZWAgaXMgKmRhdGUqLCB0aGVuIHlvdSBtdXN0IGNvbnZlcnQnLFxuICAgICAgICAgICAgJ3RoZSBkYXRlIHRvIHVuaXggdGltZSBpbiBtaWxsaXNlY29uZHMuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0pLFxuICAgIHhzaXplbW9kZToge1xuICAgICAgICB2YWxUeXBlOiAnZW51bWVyYXRlZCcsXG4gICAgICAgIHZhbHVlczogWydzY2FsZWQnLCAncGl4ZWwnXSxcbiAgICAgICAgZGZsdDogJ3NjYWxlZCcsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgZWRpdFR5cGU6ICdjYWxjK2FycmF5ZHJhdycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU2V0cyB0aGUgc2hhcGVzXFwncyBzaXppbmcgbW9kZSBhbG9uZyB0aGUgeCBheGlzLicsXG4gICAgICAgICAgICAnSWYgc2V0IHRvICpzY2FsZWQqLCBgeDBgLCBgeDFgIGFuZCB4IGNvb3JkaW5hdGVzIHdpdGhpbiBgcGF0aGAgcmVmZXIgdG8nLFxuICAgICAgICAgICAgJ2RhdGEgdmFsdWVzIG9uIHRoZSB4IGF4aXMgb3IgYSBmcmFjdGlvbiBvZiB0aGUgcGxvdCBhcmVhXFwncyB3aWR0aCcsXG4gICAgICAgICAgICAnKGB4cmVmYCBzZXQgdG8gKnBhcGVyKikuJyxcbiAgICAgICAgICAgICdJZiBzZXQgdG8gKnBpeGVsKiwgYHhhbmNob3JgIHNwZWNpZmllcyB0aGUgeCBwb3NpdGlvbiBpbiB0ZXJtcycsXG4gICAgICAgICAgICAnb2YgZGF0YSBvciBwbG90IGZyYWN0aW9uIGJ1dCBgeDBgLCBgeDFgIGFuZCB4IGNvb3JkaW5hdGVzIHdpdGhpbiBgcGF0aGAnLFxuICAgICAgICAgICAgJ2FyZSBwaXhlbHMgcmVsYXRpdmUgdG8gYHhhbmNob3JgLiBUaGlzIHdheSwgdGhlIHNoYXBlIGNhbiBoYXZlJyxcbiAgICAgICAgICAgICdhIGZpeGVkIHdpZHRoIHdoaWxlIG1haW50YWluaW5nIGEgcG9zaXRpb24gcmVsYXRpdmUgdG8gZGF0YSBvcicsXG4gICAgICAgICAgICAncGxvdCBmcmFjdGlvbi4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICB4YW5jaG9yOiB7XG4gICAgICAgIHZhbFR5cGU6ICdhbnknLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGVkaXRUeXBlOiAnY2FsYythcnJheWRyYXcnLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ09ubHkgcmVsZXZhbnQgaW4gY29uanVuY3Rpb24gd2l0aCBgeHNpemVtb2RlYCBzZXQgdG8gKnBpeGVsKi4nLFxuICAgICAgICAgICAgJ1NwZWNpZmllcyB0aGUgYW5jaG9yIHBvaW50IG9uIHRoZSB4IGF4aXMgdG8gd2hpY2ggYHgwYCwgYHgxYCcsXG4gICAgICAgICAgICAnYW5kIHggY29vcmRpbmF0ZXMgd2l0aGluIGBwYXRoYCBhcmUgcmVsYXRpdmUgdG8uJyxcbiAgICAgICAgICAgICdFLmcuIHVzZWZ1bCB0byBhdHRhY2ggYSBwaXhlbCBzaXplZCBzaGFwZSB0byBhIGNlcnRhaW4gZGF0YSB2YWx1ZS4nLFxuICAgICAgICAgICAgJ05vIGVmZmVjdCB3aGVuIGB4c2l6ZW1vZGVgIG5vdCBzZXQgdG8gKnBpeGVsKi4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICB4MDoge1xuICAgICAgICB2YWxUeXBlOiAnYW55JyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBlZGl0VHlwZTogJ2NhbGMrYXJyYXlkcmF3JyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSBzaGFwZVxcJ3Mgc3RhcnRpbmcgeCBwb3NpdGlvbi4nLFxuICAgICAgICAgICAgJ1NlZSBgdHlwZWAgYW5kIGB4c2l6ZW1vZGVgIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgeDE6IHtcbiAgICAgICAgdmFsVHlwZTogJ2FueScsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgZWRpdFR5cGU6ICdjYWxjK2FycmF5ZHJhdycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU2V0cyB0aGUgc2hhcGVcXCdzIGVuZCB4IHBvc2l0aW9uLicsXG4gICAgICAgICAgICAnU2VlIGB0eXBlYCBhbmQgYHhzaXplbW9kZWAgZm9yIG1vcmUgaW5mby4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcblxuICAgIHlyZWY6IGV4dGVuZEZsYXQoe30sIGFubkF0dHJzLnlyZWYsIHtcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSBhbm5vdGF0aW9uXFwncyB5IGNvb3JkaW5hdGUgYXhpcy4nLFxuICAgICAgICAgICAgJ0lmIHNldCB0byBhbiB5IGF4aXMgaWQgKGUuZy4gKnkqIG9yICp5MiopLCB0aGUgYHlgIHBvc2l0aW9uJyxcbiAgICAgICAgICAgICdyZWZlcnMgdG8gYW4geSBjb29yZGluYXRlJyxcbiAgICAgICAgICAgICdJZiBzZXQgdG8gKnBhcGVyKiwgdGhlIGB5YCBwb3NpdGlvbiByZWZlcnMgdG8gdGhlIGRpc3RhbmNlIGZyb20nLFxuICAgICAgICAgICAgJ3RoZSBib3R0b20gb2YgdGhlIHBsb3R0aW5nIGFyZWEgaW4gbm9ybWFsaXplZCBjb29yZGluYXRlcycsXG4gICAgICAgICAgICAnd2hlcmUgKjAqICgqMSopIGNvcnJlc3BvbmRzIHRvIHRoZSBib3R0b20gKHRvcCkuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0pLFxuICAgIHlzaXplbW9kZToge1xuICAgICAgICB2YWxUeXBlOiAnZW51bWVyYXRlZCcsXG4gICAgICAgIHZhbHVlczogWydzY2FsZWQnLCAncGl4ZWwnXSxcbiAgICAgICAgZGZsdDogJ3NjYWxlZCcsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgZWRpdFR5cGU6ICdjYWxjK2FycmF5ZHJhdycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU2V0cyB0aGUgc2hhcGVzXFwncyBzaXppbmcgbW9kZSBhbG9uZyB0aGUgeSBheGlzLicsXG4gICAgICAgICAgICAnSWYgc2V0IHRvICpzY2FsZWQqLCBgeTBgLCBgeTFgIGFuZCB5IGNvb3JkaW5hdGVzIHdpdGhpbiBgcGF0aGAgcmVmZXIgdG8nLFxuICAgICAgICAgICAgJ2RhdGEgdmFsdWVzIG9uIHRoZSB5IGF4aXMgb3IgYSBmcmFjdGlvbiBvZiB0aGUgcGxvdCBhcmVhXFwncyBoZWlnaHQnLFxuICAgICAgICAgICAgJyhgeXJlZmAgc2V0IHRvICpwYXBlciopLicsXG4gICAgICAgICAgICAnSWYgc2V0IHRvICpwaXhlbCosIGB5YW5jaG9yYCBzcGVjaWZpZXMgdGhlIHkgcG9zaXRpb24gaW4gdGVybXMnLFxuICAgICAgICAgICAgJ29mIGRhdGEgb3IgcGxvdCBmcmFjdGlvbiBidXQgYHkwYCwgYHkxYCBhbmQgeSBjb29yZGluYXRlcyB3aXRoaW4gYHBhdGhgJyxcbiAgICAgICAgICAgICdhcmUgcGl4ZWxzIHJlbGF0aXZlIHRvIGB5YW5jaG9yYC4gVGhpcyB3YXksIHRoZSBzaGFwZSBjYW4gaGF2ZScsXG4gICAgICAgICAgICAnYSBmaXhlZCBoZWlnaHQgd2hpbGUgbWFpbnRhaW5pbmcgYSBwb3NpdGlvbiByZWxhdGl2ZSB0byBkYXRhIG9yJyxcbiAgICAgICAgICAgICdwbG90IGZyYWN0aW9uLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuICAgIHlhbmNob3I6IHtcbiAgICAgICAgdmFsVHlwZTogJ2FueScsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgZWRpdFR5cGU6ICdjYWxjK2FycmF5ZHJhdycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnT25seSByZWxldmFudCBpbiBjb25qdW5jdGlvbiB3aXRoIGB5c2l6ZW1vZGVgIHNldCB0byAqcGl4ZWwqLicsXG4gICAgICAgICAgICAnU3BlY2lmaWVzIHRoZSBhbmNob3IgcG9pbnQgb24gdGhlIHkgYXhpcyB0byB3aGljaCBgeTBgLCBgeTFgJyxcbiAgICAgICAgICAgICdhbmQgeSBjb29yZGluYXRlcyB3aXRoaW4gYHBhdGhgIGFyZSByZWxhdGl2ZSB0by4nLFxuICAgICAgICAgICAgJ0UuZy4gdXNlZnVsIHRvIGF0dGFjaCBhIHBpeGVsIHNpemVkIHNoYXBlIHRvIGEgY2VydGFpbiBkYXRhIHZhbHVlLicsXG4gICAgICAgICAgICAnTm8gZWZmZWN0IHdoZW4gYHlzaXplbW9kZWAgbm90IHNldCB0byAqcGl4ZWwqLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuICAgIHkwOiB7XG4gICAgICAgIHZhbFR5cGU6ICdhbnknLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGVkaXRUeXBlOiAnY2FsYythcnJheWRyYXcnLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1NldHMgdGhlIHNoYXBlXFwncyBzdGFydGluZyB5IHBvc2l0aW9uLicsXG4gICAgICAgICAgICAnU2VlIGB0eXBlYCBhbmQgYHlzaXplbW9kZWAgZm9yIG1vcmUgaW5mby4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICB5MToge1xuICAgICAgICB2YWxUeXBlOiAnYW55JyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBlZGl0VHlwZTogJ2NhbGMrYXJyYXlkcmF3JyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSBzaGFwZVxcJ3MgZW5kIHkgcG9zaXRpb24uJyxcbiAgICAgICAgICAgICdTZWUgYHR5cGVgIGFuZCBgeXNpemVtb2RlYCBmb3IgbW9yZSBpbmZvLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuXG4gICAgcGF0aDoge1xuICAgICAgICB2YWxUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBlZGl0VHlwZTogJ2NhbGMrYXJyYXlkcmF3JyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdGb3IgYHR5cGVgICpwYXRoKiAtIGEgdmFsaWQgU1ZHIHBhdGggd2l0aCB0aGUgcGl4ZWwgdmFsdWVzJyxcbiAgICAgICAgICAgICdyZXBsYWNlZCBieSBkYXRhIHZhbHVlcyBpbiBgeHNpemVtb2RlYC9geXNpemVtb2RlYCBiZWluZyAqc2NhbGVkKicsXG4gICAgICAgICAgICAnYW5kIHRha2VuIHVubW9kaWZpZWQgYXMgcGl4ZWxzIHJlbGF0aXZlIHRvIGB4YW5jaG9yYCBhbmQgYHlhbmNob3JgJyxcbiAgICAgICAgICAgICdpbiBjYXNlIG9mICpwaXhlbCogc2l6ZSBtb2RlLicsXG4gICAgICAgICAgICAnVGhlcmUgYXJlIGEgZmV3IHJlc3RyaWN0aW9ucyAvIHF1aXJrcycsXG4gICAgICAgICAgICAnb25seSBhYnNvbHV0ZSBpbnN0cnVjdGlvbnMsIG5vdCByZWxhdGl2ZS4gU28gdGhlIGFsbG93ZWQgc2VnbWVudHMnLFxuICAgICAgICAgICAgJ2FyZTogTSwgTCwgSCwgViwgUSwgQywgVCwgUywgYW5kIFonLFxuICAgICAgICAgICAgJ2FyY3MgKEEpIGFyZSBub3QgYWxsb3dlZCBiZWNhdXNlIHJhZGl1cyByeCBhbmQgcnkgYXJlIHJlbGF0aXZlLicsXG5cbiAgICAgICAgICAgICdJbiB0aGUgZnV0dXJlIHdlIGNvdWxkIGNvbnNpZGVyIHN1cHBvcnRpbmcgcmVsYXRpdmUgY29tbWFuZHMsJyxcbiAgICAgICAgICAgICdidXQgd2Ugd291bGQgaGF2ZSB0byBkZWNpZGUgb24gaG93IHRvIGhhbmRsZSBkYXRlIGFuZCBsb2cgYXhlcy4nLFxuICAgICAgICAgICAgJ05vdGUgdGhhdCBldmVuIGFzIGlzLCBRIGFuZCBDIEJlemllciBwYXRocyB0aGF0IGFyZSBzbW9vdGggb24nLFxuICAgICAgICAgICAgJ2xpbmVhciBheGVzIG1heSBub3QgYmUgc21vb3RoIG9uIGxvZywgYW5kIHZpY2UgdmVyc2EuJyxcbiAgICAgICAgICAgICdubyBjaGFpbmVkIFwicG9seWJlemllclwiIGNvbW1hbmRzIC0gc3BlY2lmeSB0aGUgc2VnbWVudCB0eXBlIGZvcicsXG4gICAgICAgICAgICAnZWFjaCBvbmUuJyxcblxuICAgICAgICAgICAgJ09uIGNhdGVnb3J5IGF4ZXMsIHZhbHVlcyBhcmUgbnVtYmVycyBzY2FsZWQgdG8gdGhlIHNlcmlhbCBudW1iZXJzJyxcbiAgICAgICAgICAgICdvZiBjYXRlZ29yaWVzIGJlY2F1c2UgdXNpbmcgdGhlIGNhdGVnb3JpZXMgdGhlbXNlbHZlcyB0aGVyZSB3b3VsZCcsXG4gICAgICAgICAgICAnYmUgbm8gd2F5IHRvIGRlc2NyaWJlIGZyYWN0aW9uYWwgcG9zaXRpb25zJyxcbiAgICAgICAgICAgICdPbiBkYXRhIGF4ZXM6IGJlY2F1c2Ugc3BhY2UgYW5kIFQgYXJlIGJvdGggbm9ybWFsIGNvbXBvbmVudHMgb2YgcGF0aCcsXG4gICAgICAgICAgICAnc3RyaW5ncywgd2UgY2FuXFwndCB1c2UgZWl0aGVyIHRvIHNlcGFyYXRlIGRhdGUgZnJvbSB0aW1lIHBhcnRzLicsXG4gICAgICAgICAgICAnVGhlcmVmb3JlIHdlXFwnbGwgdXNlIHVuZGVyc2NvcmUgZm9yIHRoaXMgcHVycG9zZTonLFxuICAgICAgICAgICAgJzIwMTUtMDItMjFfMTM6NDU6NTYuNzg5J1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG5cbiAgICBvcGFjaXR5OiB7XG4gICAgICAgIHZhbFR5cGU6ICdudW1iZXInLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMSxcbiAgICAgICAgZGZsdDogMSxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBlZGl0VHlwZTogJ2FycmF5ZHJhdycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgc2hhcGUuJ1xuICAgIH0sXG4gICAgbGluZToge1xuICAgICAgICBjb2xvcjogZXh0ZW5kRmxhdCh7fSwgc2NhdHRlckxpbmVBdHRycy5jb2xvciwge2VkaXRUeXBlOiAnYXJyYXlkcmF3J30pLFxuICAgICAgICB3aWR0aDogZXh0ZW5kRmxhdCh7fSwgc2NhdHRlckxpbmVBdHRycy53aWR0aCwge2VkaXRUeXBlOiAnY2FsYythcnJheWRyYXcnfSksXG4gICAgICAgIGRhc2g6IGV4dGVuZEZsYXQoe30sIGRhc2gsIHtlZGl0VHlwZTogJ2FycmF5ZHJhdyd9KSxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBlZGl0VHlwZTogJ2NhbGMrYXJyYXlkcmF3J1xuICAgIH0sXG4gICAgZmlsbGNvbG9yOiB7XG4gICAgICAgIHZhbFR5cGU6ICdjb2xvcicsXG4gICAgICAgIGRmbHQ6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBlZGl0VHlwZTogJ2FycmF5ZHJhdycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU2V0cyB0aGUgY29sb3IgZmlsbGluZyB0aGUgc2hhcGVcXCdzIGludGVyaW9yLiBPbmx5IGFwcGxpZXMgdG8gY2xvc2VkIHNoYXBlcy4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICBmaWxscnVsZToge1xuICAgICAgICB2YWxUeXBlOiAnZW51bWVyYXRlZCcsXG4gICAgICAgIHZhbHVlczogWydldmVub2RkJywgJ25vbnplcm8nXSxcbiAgICAgICAgZGZsdDogJ2V2ZW5vZGQnLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGVkaXRUeXBlOiAnYXJyYXlkcmF3JyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdEZXRlcm1pbmVzIHdoaWNoIHJlZ2lvbnMgb2YgY29tcGxleCBwYXRocyBjb25zdGl0dXRlIHRoZSBpbnRlcmlvci4nLFxuICAgICAgICAgICAgJ0ZvciBtb3JlIGluZm8gcGxlYXNlIHZpc2l0IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvZmlsbC1ydWxlJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgZWRpdGFibGU6IHtcbiAgICAgICAgdmFsVHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGRmbHQ6IGZhbHNlLFxuICAgICAgICBlZGl0VHlwZTogJ2NhbGMrYXJyYXlkcmF3JyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNoYXBlIGNvdWxkIGJlIGFjdGl2YXRlZCBmb3IgZWRpdCBvciBub3QuJyxcbiAgICAgICAgICAgICdIYXMgbm8gZWZmZWN0IHdoZW4gdGhlIG9sZGVyIGVkaXRhYmxlIHNoYXBlcyBtb2RlIGlzIGVuYWJsZWQgdmlhJyxcbiAgICAgICAgICAgICdgY29uZmlnLmVkaXRhYmxlYCBvciBgY29uZmlnLmVkaXRzLnNoYXBlUG9zaXRpb25gLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuXG4gICAgZWRpdFR5cGU6ICdhcnJheWRyYXcnXG59KTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xudmFyIEF4ZXMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9jYXJ0ZXNpYW4vYXhlcycpO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxjQXV0b3JhbmdlKGdkKSB7XG4gICAgdmFyIGZ1bGxMYXlvdXQgPSBnZC5fZnVsbExheW91dDtcbiAgICB2YXIgc2hhcGVMaXN0ID0gTGliLmZpbHRlclZpc2libGUoZnVsbExheW91dC5zaGFwZXMpO1xuXG4gICAgaWYoIXNoYXBlTGlzdC5sZW5ndGggfHwgIWdkLl9mdWxsRGF0YS5sZW5ndGgpIHJldHVybjtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaGFwZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVMaXN0W2ldO1xuICAgICAgICBzaGFwZS5fZXh0cmVtZXMgPSB7fTtcblxuICAgICAgICB2YXIgYXgsIGJvdW5kcztcblxuICAgICAgICBpZihzaGFwZS54cmVmICE9PSAncGFwZXInKSB7XG4gICAgICAgICAgICB2YXIgdngwID0gc2hhcGUueHNpemVtb2RlID09PSAncGl4ZWwnID8gc2hhcGUueGFuY2hvciA6IHNoYXBlLngwO1xuICAgICAgICAgICAgdmFyIHZ4MSA9IHNoYXBlLnhzaXplbW9kZSA9PT0gJ3BpeGVsJyA/IHNoYXBlLnhhbmNob3IgOiBzaGFwZS54MTtcbiAgICAgICAgICAgIGF4ID0gQXhlcy5nZXRGcm9tSWQoZ2QsIHNoYXBlLnhyZWYpO1xuXG4gICAgICAgICAgICBib3VuZHMgPSBzaGFwZUJvdW5kcyhheCwgdngwLCB2eDEsIHNoYXBlLnBhdGgsIGNvbnN0YW50cy5wYXJhbUlzWCk7XG4gICAgICAgICAgICBpZihib3VuZHMpIHtcbiAgICAgICAgICAgICAgICBzaGFwZS5fZXh0cmVtZXNbYXguX2lkXSA9IEF4ZXMuZmluZEV4dHJlbWVzKGF4LCBib3VuZHMsIGNhbGNYUGFkZGluZ09wdGlvbnMoc2hhcGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHNoYXBlLnlyZWYgIT09ICdwYXBlcicpIHtcbiAgICAgICAgICAgIHZhciB2eTAgPSBzaGFwZS55c2l6ZW1vZGUgPT09ICdwaXhlbCcgPyBzaGFwZS55YW5jaG9yIDogc2hhcGUueTA7XG4gICAgICAgICAgICB2YXIgdnkxID0gc2hhcGUueXNpemVtb2RlID09PSAncGl4ZWwnID8gc2hhcGUueWFuY2hvciA6IHNoYXBlLnkxO1xuICAgICAgICAgICAgYXggPSBBeGVzLmdldEZyb21JZChnZCwgc2hhcGUueXJlZik7XG5cbiAgICAgICAgICAgIGJvdW5kcyA9IHNoYXBlQm91bmRzKGF4LCB2eTAsIHZ5MSwgc2hhcGUucGF0aCwgY29uc3RhbnRzLnBhcmFtSXNZKTtcbiAgICAgICAgICAgIGlmKGJvdW5kcykge1xuICAgICAgICAgICAgICAgIHNoYXBlLl9leHRyZW1lc1theC5faWRdID0gQXhlcy5maW5kRXh0cmVtZXMoYXgsIGJvdW5kcywgY2FsY1lQYWRkaW5nT3B0aW9ucyhzaGFwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gY2FsY1hQYWRkaW5nT3B0aW9ucyhzaGFwZSkge1xuICAgIHJldHVybiBjYWxjUGFkZGluZ09wdGlvbnMoc2hhcGUubGluZS53aWR0aCwgc2hhcGUueHNpemVtb2RlLCBzaGFwZS54MCwgc2hhcGUueDEsIHNoYXBlLnBhdGgsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gY2FsY1lQYWRkaW5nT3B0aW9ucyhzaGFwZSkge1xuICAgIHJldHVybiBjYWxjUGFkZGluZ09wdGlvbnMoc2hhcGUubGluZS53aWR0aCwgc2hhcGUueXNpemVtb2RlLCBzaGFwZS55MCwgc2hhcGUueTEsIHNoYXBlLnBhdGgsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBjYWxjUGFkZGluZ09wdGlvbnMobGluZVdpZHRoLCBzaXplTW9kZSwgdjAsIHYxLCBwYXRoLCBpc1lBeGlzKSB7XG4gICAgdmFyIHBwYWQgPSBsaW5lV2lkdGggLyAyO1xuICAgIHZhciBheGlzRGlyZWN0aW9uUmV2ZXJ0ZWQgPSBpc1lBeGlzO1xuXG4gICAgaWYoc2l6ZU1vZGUgPT09ICdwaXhlbCcpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IHBhdGggP1xuICAgICAgICAgICAgaGVscGVycy5leHRyYWN0UGF0aENvb3JkcyhwYXRoLCBpc1lBeGlzID8gY29uc3RhbnRzLnBhcmFtSXNZIDogY29uc3RhbnRzLnBhcmFtSXNYKSA6XG4gICAgICAgICAgICBbdjAsIHYxXTtcbiAgICAgICAgdmFyIG1heFZhbHVlID0gTGliLmFnZ051bXMoTWF0aC5tYXgsIG51bGwsIGNvb3Jkcyk7XG4gICAgICAgIHZhciBtaW5WYWx1ZSA9IExpYi5hZ2dOdW1zKE1hdGgubWluLCBudWxsLCBjb29yZHMpO1xuICAgICAgICB2YXIgYmVmb3JlUGFkID0gbWluVmFsdWUgPCAwID8gTWF0aC5hYnMobWluVmFsdWUpICsgcHBhZCA6IHBwYWQ7XG4gICAgICAgIHZhciBhZnRlclBhZCA9IG1heFZhbHVlID4gMCA/IG1heFZhbHVlICsgcHBhZCA6IHBwYWQ7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBwYWQ6IHBwYWQsXG4gICAgICAgICAgICBwcGFkcGx1czogYXhpc0RpcmVjdGlvblJldmVydGVkID8gYmVmb3JlUGFkIDogYWZ0ZXJQYWQsXG4gICAgICAgICAgICBwcGFkbWludXM6IGF4aXNEaXJlY3Rpb25SZXZlcnRlZCA/IGFmdGVyUGFkIDogYmVmb3JlUGFkXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtwcGFkOiBwcGFkfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNoYXBlQm91bmRzKGF4LCB2MCwgdjEsIHBhdGgsIHBhcmFtc1RvVXNlKSB7XG4gICAgdmFyIGNvbnZlcnRWYWwgPSAoYXgudHlwZSA9PT0gJ2NhdGVnb3J5JyB8fCBheC50eXBlID09PSAnbXVsdGljYXRlZ29yeScpID8gYXgucjJjIDogYXguZDJjO1xuXG4gICAgaWYodjAgIT09IHVuZGVmaW5lZCkgcmV0dXJuIFtjb252ZXJ0VmFsKHYwKSwgY29udmVydFZhbCh2MSldO1xuICAgIGlmKCFwYXRoKSByZXR1cm47XG5cbiAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICB2YXIgc2VnbWVudHMgPSBwYXRoLm1hdGNoKGNvbnN0YW50cy5zZWdtZW50UkUpO1xuICAgIHZhciBpO1xuICAgIHZhciBzZWdtZW50O1xuICAgIHZhciBkcmF3blBhcmFtO1xuICAgIHZhciBwYXJhbXM7XG4gICAgdmFyIHZhbDtcblxuICAgIGlmKGF4LnR5cGUgPT09ICdkYXRlJykgY29udmVydFZhbCA9IGhlbHBlcnMuZGVjb2RlRGF0ZShjb252ZXJ0VmFsKTtcblxuICAgIGZvcihpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgZHJhd25QYXJhbSA9IHBhcmFtc1RvVXNlW3NlZ21lbnQuY2hhckF0KDApXS5kcmF3bjtcbiAgICAgICAgaWYoZHJhd25QYXJhbSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcblxuICAgICAgICBwYXJhbXMgPSBzZWdtZW50c1tpXS5zdWJzdHIoMSkubWF0Y2goY29uc3RhbnRzLnBhcmFtUkUpO1xuICAgICAgICBpZighcGFyYW1zIHx8IHBhcmFtcy5sZW5ndGggPCBkcmF3blBhcmFtKSBjb250aW51ZTtcblxuICAgICAgICB2YWwgPSBjb252ZXJ0VmFsKHBhcmFtc1tkcmF3blBhcmFtXSk7XG4gICAgICAgIGlmKHZhbCA8IG1pbikgbWluID0gdmFsO1xuICAgICAgICBpZih2YWwgPiBtYXgpIG1heCA9IHZhbDtcbiAgICB9XG4gICAgaWYobWF4ID49IG1pbikgcmV0dXJuIFttaW4sIG1heF07XG59XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xudmFyIEF4ZXMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9jYXJ0ZXNpYW4vYXhlcycpO1xudmFyIGhhbmRsZUFycmF5Q29udGFpbmVyRGVmYXVsdHMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9hcnJheV9jb250YWluZXJfZGVmYXVsdHMnKTtcblxudmFyIGF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdXBwbHlMYXlvdXREZWZhdWx0cyhsYXlvdXRJbiwgbGF5b3V0T3V0KSB7XG4gICAgaGFuZGxlQXJyYXlDb250YWluZXJEZWZhdWx0cyhsYXlvdXRJbiwgbGF5b3V0T3V0LCB7XG4gICAgICAgIG5hbWU6ICdzaGFwZXMnLFxuICAgICAgICBoYW5kbGVJdGVtRGVmYXVsdHM6IGhhbmRsZVNoYXBlRGVmYXVsdHNcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGhhbmRsZVNoYXBlRGVmYXVsdHMoc2hhcGVJbiwgc2hhcGVPdXQsIGZ1bGxMYXlvdXQpIHtcbiAgICBmdW5jdGlvbiBjb2VyY2UoYXR0ciwgZGZsdCkge1xuICAgICAgICByZXR1cm4gTGliLmNvZXJjZShzaGFwZUluLCBzaGFwZU91dCwgYXR0cmlidXRlcywgYXR0ciwgZGZsdCk7XG4gICAgfVxuXG4gICAgdmFyIHZpc2libGUgPSBjb2VyY2UoJ3Zpc2libGUnKTtcbiAgICBpZighdmlzaWJsZSkgcmV0dXJuO1xuXG4gICAgdmFyIHBhdGggPSBjb2VyY2UoJ3BhdGgnKTtcbiAgICB2YXIgZGZsdFR5cGUgPSBwYXRoID8gJ3BhdGgnIDogJ3JlY3QnO1xuICAgIHZhciBzaGFwZVR5cGUgPSBjb2VyY2UoJ3R5cGUnLCBkZmx0VHlwZSk7XG4gICAgaWYoc2hhcGVPdXQudHlwZSAhPT0gJ3BhdGgnKSBkZWxldGUgc2hhcGVPdXQucGF0aDtcblxuICAgIGNvZXJjZSgnZWRpdGFibGUnKTtcbiAgICBjb2VyY2UoJ2xheWVyJyk7XG4gICAgY29lcmNlKCdvcGFjaXR5Jyk7XG4gICAgY29lcmNlKCdmaWxsY29sb3InKTtcbiAgICBjb2VyY2UoJ2ZpbGxydWxlJyk7XG4gICAgdmFyIGxpbmVXaWR0aCA9IGNvZXJjZSgnbGluZS53aWR0aCcpO1xuICAgIGlmKGxpbmVXaWR0aCkge1xuICAgICAgICBjb2VyY2UoJ2xpbmUuY29sb3InKTtcbiAgICAgICAgY29lcmNlKCdsaW5lLmRhc2gnKTtcbiAgICB9XG5cbiAgICB2YXIgeFNpemVNb2RlID0gY29lcmNlKCd4c2l6ZW1vZGUnKTtcbiAgICB2YXIgeVNpemVNb2RlID0gY29lcmNlKCd5c2l6ZW1vZGUnKTtcblxuICAgIC8vIHBvc2l0aW9uaW5nXG4gICAgdmFyIGF4TGV0dGVycyA9IFsneCcsICd5J107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICB2YXIgYXhMZXR0ZXIgPSBheExldHRlcnNbaV07XG4gICAgICAgIHZhciBhdHRyQW5jaG9yID0gYXhMZXR0ZXIgKyAnYW5jaG9yJztcbiAgICAgICAgdmFyIHNpemVNb2RlID0gYXhMZXR0ZXIgPT09ICd4JyA/IHhTaXplTW9kZSA6IHlTaXplTW9kZTtcbiAgICAgICAgdmFyIGdkTW9jayA9IHtfZnVsbExheW91dDogZnVsbExheW91dH07XG4gICAgICAgIHZhciBheDtcbiAgICAgICAgdmFyIHBvczJyO1xuICAgICAgICB2YXIgcjJwb3M7XG5cbiAgICAgICAgLy8geHJlZiwgeXJlZlxuICAgICAgICB2YXIgYXhSZWYgPSBBeGVzLmNvZXJjZVJlZihzaGFwZUluLCBzaGFwZU91dCwgZ2RNb2NrLCBheExldHRlciwgJycsICdwYXBlcicpO1xuXG4gICAgICAgIGlmKGF4UmVmICE9PSAncGFwZXInKSB7XG4gICAgICAgICAgICBheCA9IEF4ZXMuZ2V0RnJvbUlkKGdkTW9jaywgYXhSZWYpO1xuICAgICAgICAgICAgYXguX3NoYXBlSW5kaWNlcy5wdXNoKHNoYXBlT3V0Ll9pbmRleCk7XG4gICAgICAgICAgICByMnBvcyA9IGhlbHBlcnMucmFuZ2VUb1NoYXBlUG9zaXRpb24oYXgpO1xuICAgICAgICAgICAgcG9zMnIgPSBoZWxwZXJzLnNoYXBlUG9zaXRpb25Ub1JhbmdlKGF4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvczJyID0gcjJwb3MgPSBMaWIuaWRlbnRpdHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb2VyY2UgeDAsIHgxLCB5MCwgeTFcbiAgICAgICAgaWYoc2hhcGVUeXBlICE9PSAncGF0aCcpIHtcbiAgICAgICAgICAgIHZhciBkZmx0MCA9IDAuMjU7XG4gICAgICAgICAgICB2YXIgZGZsdDEgPSAwLjc1O1xuXG4gICAgICAgICAgICAvLyBoYWNrIHVudGlsIFYyLjAgd2hlbiBsb2cgaGFzIHJlZ3VsYXIgcmFuZ2UgYmVoYXZpb3IgLSBtYWtlIGl0IGxvb2sgbGlrZSBvdGhlclxuICAgICAgICAgICAgLy8gcmFuZ2VzIHRvIHNlbmQgdG8gY29lcmNlLCB0aGVuIHB1dCBpdCBiYWNrIGFmdGVyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGFsbCB0byBnaXZlIHJlYXNvbmFibGUgZGVmYXVsdCBwb3NpdGlvbiBiZWhhdmlvciBvbiBsb2cgYXhlcywgd2hpY2ggaXNcbiAgICAgICAgICAgIC8vIGEgcHJldHR5IHVuaW1wb3J0YW50IGVkZ2UgY2FzZSBzbyB3ZSBjb3VsZCBqdXN0IGlnbm9yZSB0aGlzLlxuICAgICAgICAgICAgdmFyIGF0dHIwID0gYXhMZXR0ZXIgKyAnMCc7XG4gICAgICAgICAgICB2YXIgYXR0cjEgPSBheExldHRlciArICcxJztcbiAgICAgICAgICAgIHZhciBpbjAgPSBzaGFwZUluW2F0dHIwXTtcbiAgICAgICAgICAgIHZhciBpbjEgPSBzaGFwZUluW2F0dHIxXTtcbiAgICAgICAgICAgIHNoYXBlSW5bYXR0cjBdID0gcG9zMnIoc2hhcGVJblthdHRyMF0sIHRydWUpO1xuICAgICAgICAgICAgc2hhcGVJblthdHRyMV0gPSBwb3MycihzaGFwZUluW2F0dHIxXSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmKHNpemVNb2RlID09PSAncGl4ZWwnKSB7XG4gICAgICAgICAgICAgICAgY29lcmNlKGF0dHIwLCAwKTtcbiAgICAgICAgICAgICAgICBjb2VyY2UoYXR0cjEsIDEwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgQXhlcy5jb2VyY2VQb3NpdGlvbihzaGFwZU91dCwgZ2RNb2NrLCBjb2VyY2UsIGF4UmVmLCBhdHRyMCwgZGZsdDApO1xuICAgICAgICAgICAgICAgIEF4ZXMuY29lcmNlUG9zaXRpb24oc2hhcGVPdXQsIGdkTW9jaywgY29lcmNlLCBheFJlZiwgYXR0cjEsIGRmbHQxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaGFjayBwYXJ0IDJcbiAgICAgICAgICAgIHNoYXBlT3V0W2F0dHIwXSA9IHIycG9zKHNoYXBlT3V0W2F0dHIwXSk7XG4gICAgICAgICAgICBzaGFwZU91dFthdHRyMV0gPSByMnBvcyhzaGFwZU91dFthdHRyMV0pO1xuICAgICAgICAgICAgc2hhcGVJblthdHRyMF0gPSBpbjA7XG4gICAgICAgICAgICBzaGFwZUluW2F0dHIxXSA9IGluMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvZXJjZSB4YW5jaG9yIGFuZCB5YW5jaG9yXG4gICAgICAgIGlmKHNpemVNb2RlID09PSAncGl4ZWwnKSB7XG4gICAgICAgICAgICAvLyBIYWNrIGZvciBsb2cgYXhpcyBkZXNjcmliZWQgYWJvdmVcbiAgICAgICAgICAgIHZhciBpbkFuY2hvciA9IHNoYXBlSW5bYXR0ckFuY2hvcl07XG4gICAgICAgICAgICBzaGFwZUluW2F0dHJBbmNob3JdID0gcG9zMnIoc2hhcGVJblthdHRyQW5jaG9yXSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIEF4ZXMuY29lcmNlUG9zaXRpb24oc2hhcGVPdXQsIGdkTW9jaywgY29lcmNlLCBheFJlZiwgYXR0ckFuY2hvciwgMC4yNSk7XG5cbiAgICAgICAgICAgIC8vIEhhY2sgcGFydCAyXG4gICAgICAgICAgICBzaGFwZU91dFthdHRyQW5jaG9yXSA9IHIycG9zKHNoYXBlT3V0W2F0dHJBbmNob3JdKTtcbiAgICAgICAgICAgIHNoYXBlSW5bYXR0ckFuY2hvcl0gPSBpbkFuY2hvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHNoYXBlVHlwZSA9PT0gJ3BhdGgnKSB7XG4gICAgICAgIGNvZXJjZSgncGF0aCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIExpYi5ub25lT3JBbGwoc2hhcGVJbiwgc2hhcGVPdXQsIFsneDAnLCAneDEnLCAneTAnLCAneTEnXSk7XG4gICAgfVxufVxuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDb2xvciA9IHJlcXVpcmUoJy4uLy4uL2NvbG9yJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdXBwbHlEcmF3TmV3U2hhcGVEZWZhdWx0cyhsYXlvdXRJbiwgbGF5b3V0T3V0LCBjb2VyY2UpIHtcbiAgICBjb2VyY2UoJ25ld3NoYXBlLmRyYXdkaXJlY3Rpb24nKTtcbiAgICBjb2VyY2UoJ25ld3NoYXBlLmxheWVyJyk7XG4gICAgY29lcmNlKCduZXdzaGFwZS5maWxsY29sb3InKTtcbiAgICBjb2VyY2UoJ25ld3NoYXBlLmZpbGxydWxlJyk7XG4gICAgY29lcmNlKCduZXdzaGFwZS5vcGFjaXR5Jyk7XG4gICAgdmFyIG5ld3NoYXBlTGluZVdpZHRoID0gY29lcmNlKCduZXdzaGFwZS5saW5lLndpZHRoJyk7XG4gICAgaWYobmV3c2hhcGVMaW5lV2lkdGgpIHtcbiAgICAgICAgdmFyIGJnY29sb3IgPSAobGF5b3V0SW4gfHwge30pLnBsb3RfYmdjb2xvciB8fCAnI0ZGRic7XG4gICAgICAgIGNvZXJjZSgnbmV3c2hhcGUubGluZS5jb2xvcicsIENvbG9yLmNvbnRyYXN0KGJnY29sb3IpKTtcbiAgICAgICAgY29lcmNlKCduZXdzaGFwZS5saW5lLmRhc2gnKTtcbiAgICB9XG5cbiAgICBjb2VyY2UoJ2FjdGl2ZXNoYXBlLmZpbGxjb2xvcicpO1xuICAgIGNvZXJjZSgnYWN0aXZlc2hhcGUub3BhY2l0eScpO1xufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZHJhd01vZHVsZSA9IHJlcXVpcmUoJy4vZHJhdycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtb2R1bGVUeXBlOiAnY29tcG9uZW50JyxcbiAgICBuYW1lOiAnc2hhcGVzJyxcblxuICAgIGxheW91dEF0dHJpYnV0ZXM6IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpLFxuICAgIHN1cHBseUxheW91dERlZmF1bHRzOiByZXF1aXJlKCcuL2RlZmF1bHRzJyksXG4gICAgc3VwcGx5RHJhd05ld1NoYXBlRGVmYXVsdHM6IHJlcXVpcmUoJy4vZHJhd19uZXdzaGFwZS9kZWZhdWx0cycpLFxuICAgIGluY2x1ZGVCYXNlUGxvdDogcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuL2luY2x1ZGVfY29tcG9uZW50cycpKCdzaGFwZXMnKSxcblxuICAgIGNhbGNBdXRvcmFuZ2U6IHJlcXVpcmUoJy4vY2FsY19hdXRvcmFuZ2UnKSxcbiAgICBkcmF3OiBkcmF3TW9kdWxlLmRyYXcsXG4gICAgZHJhd09uZTogZHJhd01vZHVsZS5kcmF3T25lXG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9udEF0dHJzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvZm9udF9hdHRyaWJ1dGVzJyk7XG52YXIgcGFkQXR0cnMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9wYWRfYXR0cmlidXRlcycpO1xudmFyIGV4dGVuZERlZXBBbGwgPSByZXF1aXJlKCcuLi8uLi9saWIvZXh0ZW5kJykuZXh0ZW5kRGVlcEFsbDtcbnZhciBvdmVycmlkZUFsbCA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RfYXBpL2VkaXRfdHlwZXMnKS5vdmVycmlkZUFsbDtcbnZhciBhbmltYXRpb25BdHRycyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2FuaW1hdGlvbl9hdHRyaWJ1dGVzJyk7XG52YXIgdGVtcGxhdGVkQXJyYXkgPSByZXF1aXJlKCcuLi8uLi9wbG90X2FwaS9wbG90X3RlbXBsYXRlJykudGVtcGxhdGVkQXJyYXk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxudmFyIHN0ZXBzQXR0cnMgPSB0ZW1wbGF0ZWRBcnJheSgnc3RlcCcsIHtcbiAgICB2aXNpYmxlOiB7XG4gICAgICAgIHZhbFR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZmx0OiB0cnVlLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ0RldGVybWluZXMgd2hldGhlciBvciBub3QgdGhpcyBzdGVwIGlzIGluY2x1ZGVkIGluIHRoZSBzbGlkZXIuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgbWV0aG9kOiB7XG4gICAgICAgIHZhbFR5cGU6ICdlbnVtZXJhdGVkJyxcbiAgICAgICAgdmFsdWVzOiBbJ3Jlc3R5bGUnLCAncmVsYXlvdXQnLCAnYW5pbWF0ZScsICd1cGRhdGUnLCAnc2tpcCddLFxuICAgICAgICBkZmx0OiAncmVzdHlsZScsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSBQbG90bHkgbWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBzbGlkZXIgdmFsdWUgaXMgY2hhbmdlZC4nLFxuICAgICAgICAgICAgJ0lmIHRoZSBgc2tpcGAgbWV0aG9kIGlzIHVzZWQsIHRoZSBBUEkgc2xpZGVyIHdpbGwgZnVuY3Rpb24gYXMgbm9ybWFsJyxcbiAgICAgICAgICAgICdidXQgd2lsbCBwZXJmb3JtIG5vIEFQSSBjYWxscyBhbmQgd2lsbCBub3QgYmluZCBhdXRvbWF0aWNhbGx5IHRvIHN0YXRlJyxcbiAgICAgICAgICAgICd1cGRhdGVzLiBUaGlzIG1heSBiZSB1c2VkIHRvIGNyZWF0ZSBhIGNvbXBvbmVudCBpbnRlcmZhY2UgYW5kIGF0dGFjaCB0bycsXG4gICAgICAgICAgICAnc2xpZGVyIGV2ZW50cyBtYW51YWxseSB2aWEgSmF2YVNjcmlwdC4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICBhcmdzOiB7XG4gICAgICAgIHZhbFR5cGU6ICdpbmZvX2FycmF5JyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBmcmVlTGVuZ3RoOiB0cnVlLFxuICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgeyB2YWxUeXBlOiAnYW55JyB9LFxuICAgICAgICAgICAgeyB2YWxUeXBlOiAnYW55JyB9LFxuICAgICAgICAgICAgeyB2YWxUeXBlOiAnYW55JyB9XG4gICAgICAgIF0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU2V0cyB0aGUgYXJndW1lbnRzIHZhbHVlcyB0byBiZSBwYXNzZWQgdG8gdGhlIFBsb3RseScsXG4gICAgICAgICAgICAnbWV0aG9kIHNldCBpbiBgbWV0aG9kYCBvbiBzbGlkZS4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICBsYWJlbDoge1xuICAgICAgICB2YWxUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIHRleHQgbGFiZWwgdG8gYXBwZWFyIG9uIHRoZSBzbGlkZXInXG4gICAgfSxcbiAgICB2YWx1ZToge1xuICAgICAgICB2YWxUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1NldHMgdGhlIHZhbHVlIG9mIHRoZSBzbGlkZXIgc3RlcCwgdXNlZCB0byByZWZlciB0byB0aGUgc3RlcCBwcm9ncmFtYXRpY2FsbHkuJyxcbiAgICAgICAgICAgICdEZWZhdWx0cyB0byB0aGUgc2xpZGVyIGxhYmVsIGlmIG5vdCBwcm92aWRlZC4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICBleGVjdXRlOiB7XG4gICAgICAgIHZhbFR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZmx0OiB0cnVlLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1doZW4gdHJ1ZSwgdGhlIEFQSSBtZXRob2QgaXMgZXhlY3V0ZWQuIFdoZW4gZmFsc2UsIGFsbCBvdGhlciBiZWhhdmlvcnMgYXJlIHRoZSBzYW1lJyxcbiAgICAgICAgICAgICdhbmQgY29tbWFuZCBleGVjdXRpb24gaXMgc2tpcHBlZC4gVGhpcyBtYXkgYmUgdXNlZnVsIHdoZW4gaG9va2luZyBpbnRvLCBmb3IgZXhhbXBsZSwnLFxuICAgICAgICAgICAgJ3RoZSBgcGxvdGx5X3NsaWRlcmNoYW5nZWAgbWV0aG9kIGFuZCBleGVjdXRpbmcgdGhlIEFQSSBjb21tYW5kIG1hbnVhbGx5IHdpdGhvdXQgbG9zaW5nJyxcbiAgICAgICAgICAgICd0aGUgYmVuZWZpdCBvZiB0aGUgc2xpZGVyIGF1dG9tYXRpY2FsbHkgYmluZGluZyB0byB0aGUgc3RhdGUgb2YgdGhlIHBsb3QgdGhyb3VnaCB0aGUnLFxuICAgICAgICAgICAgJ3NwZWNpZmljYXRpb24gb2YgYG1ldGhvZGAgYW5kIGBhcmdzYC4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlcnJpZGVBbGwodGVtcGxhdGVkQXJyYXkoJ3NsaWRlcicsIHtcbiAgICB2aXNpYmxlOiB7XG4gICAgICAgIHZhbFR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZmx0OiB0cnVlLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ0RldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIHNsaWRlciBpcyB2aXNpYmxlLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuXG4gICAgYWN0aXZlOiB7XG4gICAgICAgIHZhbFR5cGU6ICdudW1iZXInLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgZGZsdDogMCxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdEZXRlcm1pbmVzIHdoaWNoIGJ1dHRvbiAoYnkgaW5kZXggc3RhcnRpbmcgZnJvbSAwKSBpcycsXG4gICAgICAgICAgICAnY29uc2lkZXJlZCBhY3RpdmUuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG5cbiAgICBzdGVwczogc3RlcHNBdHRycyxcblxuICAgIGxlbm1vZGU6IHtcbiAgICAgICAgdmFsVHlwZTogJ2VudW1lcmF0ZWQnLFxuICAgICAgICB2YWx1ZXM6IFsnZnJhY3Rpb24nLCAncGl4ZWxzJ10sXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgZGZsdDogJ2ZyYWN0aW9uJyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBzbGlkZXIgbGVuZ3RoJyxcbiAgICAgICAgICAgICdpcyBzZXQgaW4gdW5pdHMgb2YgcGxvdCAqZnJhY3Rpb24qIG9yIGluICpwaXhlbHMuJyxcbiAgICAgICAgICAgICdVc2UgYGxlbmAgdG8gc2V0IHRoZSB2YWx1ZS4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICBsZW46IHtcbiAgICAgICAgdmFsVHlwZTogJ251bWJlcicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgZGZsdDogMSxcbiAgICAgICAgcm9sZTogJ3N0eWxlJyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSBsZW5ndGggb2YgdGhlIHNsaWRlcicsXG4gICAgICAgICAgICAnVGhpcyBtZWFzdXJlIGV4Y2x1ZGVzIHRoZSBwYWRkaW5nIG9mIGJvdGggZW5kcy4nLFxuICAgICAgICAgICAgJ1RoYXQgaXMsIHRoZSBzbGlkZXJcXCdzIGxlbmd0aCBpcyB0aGlzIGxlbmd0aCBtaW51cyB0aGUnLFxuICAgICAgICAgICAgJ3BhZGRpbmcgb24gYm90aCBlbmRzLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuICAgIHg6IHtcbiAgICAgICAgdmFsVHlwZTogJ251bWJlcicsXG4gICAgICAgIG1pbjogLTIsXG4gICAgICAgIG1heDogMyxcbiAgICAgICAgZGZsdDogMCxcbiAgICAgICAgcm9sZTogJ3N0eWxlJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdTZXRzIHRoZSB4IHBvc2l0aW9uIChpbiBub3JtYWxpemVkIGNvb3JkaW5hdGVzKSBvZiB0aGUgc2xpZGVyLidcbiAgICB9LFxuICAgIHBhZDogZXh0ZW5kRGVlcEFsbChwYWRBdHRycyh7ZWRpdFR5cGU6ICdhcnJheWRyYXcnfSksIHtcbiAgICAgICAgZGVzY3JpcHRpb246ICdTZXQgdGhlIHBhZGRpbmcgb2YgdGhlIHNsaWRlciBjb21wb25lbnQgYWxvbmcgZWFjaCBzaWRlLidcbiAgICB9LCB7dDoge2RmbHQ6IDIwfX0pLFxuICAgIHhhbmNob3I6IHtcbiAgICAgICAgdmFsVHlwZTogJ2VudW1lcmF0ZWQnLFxuICAgICAgICB2YWx1ZXM6IFsnYXV0bycsICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCddLFxuICAgICAgICBkZmx0OiAnbGVmdCcsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSBzbGlkZXJcXCdzIGhvcml6b250YWwgcG9zaXRpb24gYW5jaG9yLicsXG4gICAgICAgICAgICAnVGhpcyBhbmNob3IgYmluZHMgdGhlIGB4YCBwb3NpdGlvbiB0byB0aGUgKmxlZnQqLCAqY2VudGVyKicsXG4gICAgICAgICAgICAnb3IgKnJpZ2h0KiBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgeToge1xuICAgICAgICB2YWxUeXBlOiAnbnVtYmVyJyxcbiAgICAgICAgbWluOiAtMixcbiAgICAgICAgbWF4OiAzLFxuICAgICAgICBkZmx0OiAwLFxuICAgICAgICByb2xlOiAnc3R5bGUnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIHkgcG9zaXRpb24gKGluIG5vcm1hbGl6ZWQgY29vcmRpbmF0ZXMpIG9mIHRoZSBzbGlkZXIuJ1xuICAgIH0sXG4gICAgeWFuY2hvcjoge1xuICAgICAgICB2YWxUeXBlOiAnZW51bWVyYXRlZCcsXG4gICAgICAgIHZhbHVlczogWydhdXRvJywgJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJ10sXG4gICAgICAgIGRmbHQ6ICd0b3AnLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU2V0cyB0aGUgc2xpZGVyXFwncyB2ZXJ0aWNhbCBwb3NpdGlvbiBhbmNob3InLFxuICAgICAgICAgICAgJ1RoaXMgYW5jaG9yIGJpbmRzIHRoZSBgeWAgcG9zaXRpb24gdG8gdGhlICp0b3AqLCAqbWlkZGxlKicsXG4gICAgICAgICAgICAnb3IgKmJvdHRvbSogb2YgdGhlIHJhbmdlIHNlbGVjdG9yLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuXG4gICAgdHJhbnNpdGlvbjoge1xuICAgICAgICBkdXJhdGlvbjoge1xuICAgICAgICAgICAgdmFsVHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBkZmx0OiAxNTAsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIGR1cmF0aW9uIG9mIHRoZSBzbGlkZXIgdHJhbnNpdGlvbidcbiAgICAgICAgfSxcbiAgICAgICAgZWFzaW5nOiB7XG4gICAgICAgICAgICB2YWxUeXBlOiAnZW51bWVyYXRlZCcsXG4gICAgICAgICAgICB2YWx1ZXM6IGFuaW1hdGlvbkF0dHJzLnRyYW5zaXRpb24uZWFzaW5nLnZhbHVlcyxcbiAgICAgICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgICAgIGRmbHQ6ICdjdWJpYy1pbi1vdXQnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdTZXRzIHRoZSBlYXNpbmcgZnVuY3Rpb24gb2YgdGhlIHNsaWRlciB0cmFuc2l0aW9uJ1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGN1cnJlbnR2YWx1ZToge1xuICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgICB2YWxUeXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgICAgICBkZmx0OiB0cnVlLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICAgICAnU2hvd3MgdGhlIGN1cnJlbnRseS1zZWxlY3RlZCB2YWx1ZSBhYm92ZSB0aGUgc2xpZGVyLidcbiAgICAgICAgICAgIF0uam9pbignICcpXG4gICAgICAgIH0sXG5cbiAgICAgICAgeGFuY2hvcjoge1xuICAgICAgICAgICAgdmFsVHlwZTogJ2VudW1lcmF0ZWQnLFxuICAgICAgICAgICAgdmFsdWVzOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J10sXG4gICAgICAgICAgICBkZmx0OiAnbGVmdCcsXG4gICAgICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgICAgICdUaGUgYWxpZ25tZW50IG9mIHRoZSB2YWx1ZSByZWFkb3V0IHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHNsaWRlci4nXG4gICAgICAgICAgICBdLmpvaW4oJyAnKVxuICAgICAgICB9LFxuXG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgdmFsVHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBkZmx0OiAxMCxcbiAgICAgICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAgICAgJ1RoZSBhbW91bnQgb2Ygc3BhY2UsIGluIHBpeGVscywgYmV0d2VlbiB0aGUgY3VycmVudCB2YWx1ZSBsYWJlbCcsXG4gICAgICAgICAgICAgICAgJ2FuZCB0aGUgc2xpZGVyLidcbiAgICAgICAgICAgIF0uam9pbignICcpXG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlZml4OiB7XG4gICAgICAgICAgICB2YWxUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnV2hlbiBjdXJyZW50dmFsdWUudmlzaWJsZSBpcyB0cnVlLCB0aGlzIHNldHMgdGhlIHByZWZpeCBvZiB0aGUgbGFiZWwuJ1xuICAgICAgICB9LFxuXG4gICAgICAgIHN1ZmZpeDoge1xuICAgICAgICAgICAgdmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1doZW4gY3VycmVudHZhbHVlLnZpc2libGUgaXMgdHJ1ZSwgdGhpcyBzZXRzIHRoZSBzdWZmaXggb2YgdGhlIGxhYmVsLidcbiAgICAgICAgfSxcblxuICAgICAgICBmb250OiBmb250QXR0cnMoe1xuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdTZXRzIHRoZSBmb250IG9mIHRoZSBjdXJyZW50IHZhbHVlIGxhYmVsIHRleHQuJ1xuICAgICAgICB9KVxuICAgIH0sXG5cbiAgICBmb250OiBmb250QXR0cnMoe1xuICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIGZvbnQgb2YgdGhlIHNsaWRlciBzdGVwIGxhYmVscy4nXG4gICAgfSksXG5cbiAgICBhY3RpdmViZ2NvbG9yOiB7XG4gICAgICAgIHZhbFR5cGU6ICdjb2xvcicsXG4gICAgICAgIHJvbGU6ICdzdHlsZScsXG4gICAgICAgIGRmbHQ6IGNvbnN0YW50cy5ncmlwQmdBY3RpdmVDb2xvcixcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBzbGlkZXIgZ3JpcCcsXG4gICAgICAgICAgICAnd2hpbGUgZHJhZ2dpbmcuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgYmdjb2xvcjoge1xuICAgICAgICB2YWxUeXBlOiAnY29sb3InLFxuICAgICAgICByb2xlOiAnc3R5bGUnLFxuICAgICAgICBkZmx0OiBjb25zdGFudHMucmFpbEJnQ29sb3IsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU2V0cyB0aGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgc2xpZGVyLidcbiAgICB9LFxuICAgIGJvcmRlcmNvbG9yOiB7XG4gICAgICAgIHZhbFR5cGU6ICdjb2xvcicsXG4gICAgICAgIGRmbHQ6IGNvbnN0YW50cy5yYWlsQm9yZGVyQ29sb3IsXG4gICAgICAgIHJvbGU6ICdzdHlsZScsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU2V0cyB0aGUgY29sb3Igb2YgdGhlIGJvcmRlciBlbmNsb3NpbmcgdGhlIHNsaWRlci4nXG4gICAgfSxcbiAgICBib3JkZXJ3aWR0aDoge1xuICAgICAgICB2YWxUeXBlOiAnbnVtYmVyJyxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBkZmx0OiBjb25zdGFudHMucmFpbEJvcmRlcldpZHRoLFxuICAgICAgICByb2xlOiAnc3R5bGUnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIHdpZHRoIChpbiBweCkgb2YgdGhlIGJvcmRlciBlbmNsb3NpbmcgdGhlIHNsaWRlci4nXG4gICAgfSxcbiAgICB0aWNrbGVuOiB7XG4gICAgICAgIHZhbFR5cGU6ICdudW1iZXInLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIGRmbHQ6IGNvbnN0YW50cy50aWNrTGVuZ3RoLFxuICAgICAgICByb2xlOiAnc3R5bGUnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIGxlbmd0aCBpbiBwaXhlbHMgb2Ygc3RlcCB0aWNrIG1hcmtzJ1xuICAgIH0sXG4gICAgdGlja2NvbG9yOiB7XG4gICAgICAgIHZhbFR5cGU6ICdjb2xvcicsXG4gICAgICAgIGRmbHQ6IGNvbnN0YW50cy50aWNrQ29sb3IsXG4gICAgICAgIHJvbGU6ICdzdHlsZScsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU2V0cyB0aGUgY29sb3Igb2YgdGhlIGJvcmRlciBlbmNsb3NpbmcgdGhlIHNsaWRlci4nXG4gICAgfSxcbiAgICB0aWNrd2lkdGg6IHtcbiAgICAgICAgdmFsVHlwZTogJ251bWJlcicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgZGZsdDogMSxcbiAgICAgICAgcm9sZTogJ3N0eWxlJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdTZXRzIHRoZSB0aWNrIHdpZHRoIChpbiBweCkuJ1xuICAgIH0sXG4gICAgbWlub3J0aWNrbGVuOiB7XG4gICAgICAgIHZhbFR5cGU6ICdudW1iZXInLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIGRmbHQ6IGNvbnN0YW50cy5taW5vclRpY2tMZW5ndGgsXG4gICAgICAgIHJvbGU6ICdzdHlsZScsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU2V0cyB0aGUgbGVuZ3RoIGluIHBpeGVscyBvZiBtaW5vciBzdGVwIHRpY2sgbWFya3MnXG4gICAgfVxufSksICdhcnJheWRyYXcnLCAnZnJvbS1yb290Jyk7XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIC8vIGxheW91dCBhdHRyaWJ1dGUgbmFtZVxuICAgIG5hbWU6ICdzbGlkZXJzJyxcblxuICAgIC8vIGNsYXNzIG5hbWVzXG4gICAgY29udGFpbmVyQ2xhc3NOYW1lOiAnc2xpZGVyLWNvbnRhaW5lcicsXG4gICAgZ3JvdXBDbGFzc05hbWU6ICdzbGlkZXItZ3JvdXAnLFxuICAgIGlucHV0QXJlYUNsYXNzOiAnc2xpZGVyLWlucHV0LWFyZWEnLFxuICAgIHJhaWxSZWN0Q2xhc3M6ICdzbGlkZXItcmFpbC1yZWN0JyxcbiAgICByYWlsVG91Y2hSZWN0Q2xhc3M6ICdzbGlkZXItcmFpbC10b3VjaC1yZWN0JyxcbiAgICBncmlwUmVjdENsYXNzOiAnc2xpZGVyLWdyaXAtcmVjdCcsXG4gICAgdGlja1JlY3RDbGFzczogJ3NsaWRlci10aWNrLXJlY3QnLFxuICAgIGlucHV0UHJveHlDbGFzczogJ3NsaWRlci1pbnB1dC1wcm94eScsXG4gICAgbGFiZWxzQ2xhc3M6ICdzbGlkZXItbGFiZWxzJyxcbiAgICBsYWJlbEdyb3VwQ2xhc3M6ICdzbGlkZXItbGFiZWwtZ3JvdXAnLFxuICAgIGxhYmVsQ2xhc3M6ICdzbGlkZXItbGFiZWwnLFxuICAgIGN1cnJlbnRWYWx1ZUNsYXNzOiAnc2xpZGVyLWN1cnJlbnQtdmFsdWUnLFxuXG4gICAgcmFpbEhlaWdodDogNSxcblxuICAgIC8vIERPTSBhdHRyaWJ1dGUgbmFtZSBpbiBidXR0b24gZ3JvdXAga2VlcGluZyB0cmFja1xuICAgIC8vIG9mIGFjdGl2ZSB1cGRhdGUgbWVudVxuICAgIG1lbnVJbmRleEF0dHJOYW1lOiAnc2xpZGVyLWFjdGl2ZS1pbmRleCcsXG5cbiAgICAvLyBpZCByb290IHBhc3MgdG8gUGxvdHMuYXV0b01hcmdpblxuICAgIGF1dG9NYXJnaW5JZFJvb3Q6ICdzbGlkZXItJyxcblxuICAgIC8vIG1pbiBpdGVtIHdpZHRoIC8gaGVpZ2h0XG4gICAgbWluV2lkdGg6IDMwLFxuICAgIG1pbkhlaWdodDogMzAsXG5cbiAgICAvLyBwYWRkaW5nIGFyb3VuZCBpdGVtIHRleHRcbiAgICB0ZXh0UGFkWDogNDAsXG5cbiAgICAvLyBhcnJvdyBvZmZzZXQgb2ZmIHJpZ2h0IGVkZ2VcbiAgICBhcnJvd09mZnNldFg6IDQsXG5cbiAgICByYWlsUmFkaXVzOiAyLFxuICAgIHJhaWxXaWR0aDogNSxcbiAgICByYWlsQm9yZGVyOiA0LFxuICAgIHJhaWxCb3JkZXJXaWR0aDogMSxcbiAgICByYWlsQm9yZGVyQ29sb3I6ICcjYmVjOGQ5JyxcbiAgICByYWlsQmdDb2xvcjogJyNmOGZhZmMnLFxuXG4gICAgLy8gVGhlIGRpc3RhbmNlIG9mIHRoZSByYWlsIGZyb20gdGhlIGVkZ2Ugb2YgdGhlIHRvdWNoYWJsZSBhcmVhXG4gICAgLy8gU2xpZ2h0bHkgbGVzcyB0aGFuIHRoZSBzdGVwIGluc2V0IGJlY2F1c2Ugb2YgdGhlIGN1cnZlZCBlZGdlc1xuICAgIC8vIG9mIHRoZSByYWlsXG4gICAgcmFpbEluc2V0OiA4LFxuXG4gICAgLy8gVGhlIGRpc3RhbmNlIGZyb20gdGhlIGV4dHJlbWFsIHRpY2sgbWFya3MgdG8gdGhlIGVkZ2Ugb2YgdGhlXG4gICAgLy8gdG91Y2hhYmxlIGFyZWEuIFRoaXMgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzIHRoZSBncmlwIHJhZGl1cyxcbiAgICAvLyBidXQgZm9yIG90aGVyIHN0eWxlcyBpdCB3b3VsZG4ndCByZWFsbHkgbmVlZCB0byBiZS5cbiAgICBzdGVwSW5zZXQ6IDEwLFxuXG4gICAgZ3JpcFJhZGl1czogMTAsXG4gICAgZ3JpcFdpZHRoOiAyMCxcbiAgICBncmlwSGVpZ2h0OiAyMCxcbiAgICBncmlwQm9yZGVyOiAyMCxcbiAgICBncmlwQm9yZGVyV2lkdGg6IDEsXG4gICAgZ3JpcEJvcmRlckNvbG9yOiAnI2JlYzhkOScsXG4gICAgZ3JpcEJnQ29sb3I6ICcjZjZmOGZhJyxcbiAgICBncmlwQmdBY3RpdmVDb2xvcjogJyNkYmRkZTAnLFxuXG4gICAgbGFiZWxQYWRkaW5nOiA4LFxuICAgIGxhYmVsT2Zmc2V0OiAwLFxuXG4gICAgdGlja1dpZHRoOiAxLFxuICAgIHRpY2tDb2xvcjogJyMzMzMnLFxuICAgIHRpY2tPZmZzZXQ6IDI1LFxuICAgIHRpY2tMZW5ndGg6IDcsXG5cbiAgICBtaW5vclRpY2tPZmZzZXQ6IDI1LFxuICAgIG1pbm9yVGlja0NvbG9yOiAnIzMzMycsXG4gICAgbWlub3JUaWNrTGVuZ3RoOiA0LFxuXG4gICAgLy8gRXh0cmEgc3BhY2UgYmVsb3cgdGhlIGN1cnJlbnQgdmFsdWUgbGFiZWw6XG4gICAgY3VycmVudFZhbHVlUGFkZGluZzogOCxcbiAgICBjdXJyZW50VmFsdWVJbnNldDogMCxcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaWIgPSByZXF1aXJlKCcuLi8uLi9saWInKTtcbnZhciBoYW5kbGVBcnJheUNvbnRhaW5lckRlZmF1bHRzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvYXJyYXlfY29udGFpbmVyX2RlZmF1bHRzJyk7XG5cbnZhciBhdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxudmFyIG5hbWUgPSBjb25zdGFudHMubmFtZTtcbnZhciBzdGVwQXR0cnMgPSBhdHRyaWJ1dGVzLnN0ZXBzO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2xpZGVyc0RlZmF1bHRzKGxheW91dEluLCBsYXlvdXRPdXQpIHtcbiAgICBoYW5kbGVBcnJheUNvbnRhaW5lckRlZmF1bHRzKGxheW91dEluLCBsYXlvdXRPdXQsIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgaGFuZGxlSXRlbURlZmF1bHRzOiBzbGlkZXJEZWZhdWx0c1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gc2xpZGVyRGVmYXVsdHMoc2xpZGVySW4sIHNsaWRlck91dCwgbGF5b3V0T3V0KSB7XG4gICAgZnVuY3Rpb24gY29lcmNlKGF0dHIsIGRmbHQpIHtcbiAgICAgICAgcmV0dXJuIExpYi5jb2VyY2Uoc2xpZGVySW4sIHNsaWRlck91dCwgYXR0cmlidXRlcywgYXR0ciwgZGZsdCk7XG4gICAgfVxuXG4gICAgdmFyIHN0ZXBzID0gaGFuZGxlQXJyYXlDb250YWluZXJEZWZhdWx0cyhzbGlkZXJJbiwgc2xpZGVyT3V0LCB7XG4gICAgICAgIG5hbWU6ICdzdGVwcycsXG4gICAgICAgIGhhbmRsZUl0ZW1EZWZhdWx0czogc3RlcERlZmF1bHRzXG4gICAgfSk7XG5cbiAgICB2YXIgc3RlcENvdW50ID0gMDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3RlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoc3RlcHNbaV0udmlzaWJsZSkgc3RlcENvdW50Kys7XG4gICAgfVxuXG4gICAgdmFyIHZpc2libGU7XG4gICAgLy8gSWYgaXQgaGFzIGZld2VyIHRoYW4gdHdvIG9wdGlvbnMsIGl0J3Mgbm90IHJlYWxseSBhIHNsaWRlclxuICAgIGlmKHN0ZXBDb3VudCA8IDIpIHZpc2libGUgPSBzbGlkZXJPdXQudmlzaWJsZSA9IGZhbHNlO1xuICAgIGVsc2UgdmlzaWJsZSA9IGNvZXJjZSgndmlzaWJsZScpO1xuICAgIGlmKCF2aXNpYmxlKSByZXR1cm47XG5cbiAgICBzbGlkZXJPdXQuX3N0ZXBDb3VudCA9IHN0ZXBDb3VudDtcbiAgICB2YXIgdmlzU3RlcHMgPSBzbGlkZXJPdXQuX3Zpc2libGVTdGVwcyA9IExpYi5maWx0ZXJWaXNpYmxlKHN0ZXBzKTtcblxuICAgIHZhciBhY3RpdmUgPSBjb2VyY2UoJ2FjdGl2ZScpO1xuICAgIGlmKCEoc3RlcHNbYWN0aXZlXSB8fCB7fSkudmlzaWJsZSkgc2xpZGVyT3V0LmFjdGl2ZSA9IHZpc1N0ZXBzWzBdLl9pbmRleDtcblxuICAgIGNvZXJjZSgneCcpO1xuICAgIGNvZXJjZSgneScpO1xuICAgIExpYi5ub25lT3JBbGwoc2xpZGVySW4sIHNsaWRlck91dCwgWyd4JywgJ3knXSk7XG5cbiAgICBjb2VyY2UoJ3hhbmNob3InKTtcbiAgICBjb2VyY2UoJ3lhbmNob3InKTtcblxuICAgIGNvZXJjZSgnbGVuJyk7XG4gICAgY29lcmNlKCdsZW5tb2RlJyk7XG5cbiAgICBjb2VyY2UoJ3BhZC50Jyk7XG4gICAgY29lcmNlKCdwYWQucicpO1xuICAgIGNvZXJjZSgncGFkLmInKTtcbiAgICBjb2VyY2UoJ3BhZC5sJyk7XG5cbiAgICBMaWIuY29lcmNlRm9udChjb2VyY2UsICdmb250JywgbGF5b3V0T3V0LmZvbnQpO1xuXG4gICAgdmFyIGN1cnJlbnRWYWx1ZUlzVmlzaWJsZSA9IGNvZXJjZSgnY3VycmVudHZhbHVlLnZpc2libGUnKTtcblxuICAgIGlmKGN1cnJlbnRWYWx1ZUlzVmlzaWJsZSkge1xuICAgICAgICBjb2VyY2UoJ2N1cnJlbnR2YWx1ZS54YW5jaG9yJyk7XG4gICAgICAgIGNvZXJjZSgnY3VycmVudHZhbHVlLnByZWZpeCcpO1xuICAgICAgICBjb2VyY2UoJ2N1cnJlbnR2YWx1ZS5zdWZmaXgnKTtcbiAgICAgICAgY29lcmNlKCdjdXJyZW50dmFsdWUub2Zmc2V0Jyk7XG5cbiAgICAgICAgTGliLmNvZXJjZUZvbnQoY29lcmNlLCAnY3VycmVudHZhbHVlLmZvbnQnLCBzbGlkZXJPdXQuZm9udCk7XG4gICAgfVxuXG4gICAgY29lcmNlKCd0cmFuc2l0aW9uLmR1cmF0aW9uJyk7XG4gICAgY29lcmNlKCd0cmFuc2l0aW9uLmVhc2luZycpO1xuXG4gICAgY29lcmNlKCdiZ2NvbG9yJyk7XG4gICAgY29lcmNlKCdhY3RpdmViZ2NvbG9yJyk7XG4gICAgY29lcmNlKCdib3JkZXJjb2xvcicpO1xuICAgIGNvZXJjZSgnYm9yZGVyd2lkdGgnKTtcbiAgICBjb2VyY2UoJ3RpY2tsZW4nKTtcbiAgICBjb2VyY2UoJ3RpY2t3aWR0aCcpO1xuICAgIGNvZXJjZSgndGlja2NvbG9yJyk7XG4gICAgY29lcmNlKCdtaW5vcnRpY2tsZW4nKTtcbn1cblxuZnVuY3Rpb24gc3RlcERlZmF1bHRzKHZhbHVlSW4sIHZhbHVlT3V0KSB7XG4gICAgZnVuY3Rpb24gY29lcmNlKGF0dHIsIGRmbHQpIHtcbiAgICAgICAgcmV0dXJuIExpYi5jb2VyY2UodmFsdWVJbiwgdmFsdWVPdXQsIHN0ZXBBdHRycywgYXR0ciwgZGZsdCk7XG4gICAgfVxuXG4gICAgdmFyIHZpc2libGU7XG4gICAgaWYodmFsdWVJbi5tZXRob2QgIT09ICdza2lwJyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZUluLmFyZ3MpKSB7XG4gICAgICAgIHZpc2libGUgPSB2YWx1ZU91dC52aXNpYmxlID0gZmFsc2U7XG4gICAgfSBlbHNlIHZpc2libGUgPSBjb2VyY2UoJ3Zpc2libGUnKTtcblxuICAgIGlmKHZpc2libGUpIHtcbiAgICAgICAgY29lcmNlKCdtZXRob2QnKTtcbiAgICAgICAgY29lcmNlKCdhcmdzJyk7XG4gICAgICAgIHZhciBsYWJlbCA9IGNvZXJjZSgnbGFiZWwnLCAnc3RlcC0nICsgdmFsdWVPdXQuX2luZGV4KTtcbiAgICAgICAgY29lcmNlKCd2YWx1ZScsIGxhYmVsKTtcbiAgICAgICAgY29lcmNlKCdleGVjdXRlJyk7XG4gICAgfVxufVxuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZDMgPSByZXF1aXJlKCdkMycpO1xuXG52YXIgUGxvdHMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9wbG90cycpO1xudmFyIENvbG9yID0gcmVxdWlyZSgnLi4vY29sb3InKTtcbnZhciBEcmF3aW5nID0gcmVxdWlyZSgnLi4vZHJhd2luZycpO1xudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xudmFyIHN2Z1RleHRVdGlscyA9IHJlcXVpcmUoJy4uLy4uL2xpYi9zdmdfdGV4dF91dGlscycpO1xudmFyIGFycmF5RWRpdG9yID0gcmVxdWlyZSgnLi4vLi4vcGxvdF9hcGkvcGxvdF90ZW1wbGF0ZScpLmFycmF5RWRpdG9yO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBhbGlnbm1lbnRDb25zdGFudHMgPSByZXF1aXJlKCcuLi8uLi9jb25zdGFudHMvYWxpZ25tZW50Jyk7XG52YXIgTElORV9TUEFDSU5HID0gYWxpZ25tZW50Q29uc3RhbnRzLkxJTkVfU1BBQ0lORztcbnZhciBGUk9NX1RMID0gYWxpZ25tZW50Q29uc3RhbnRzLkZST01fVEw7XG52YXIgRlJPTV9CUiA9IGFsaWdubWVudENvbnN0YW50cy5GUk9NX0JSO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRyYXcoZ2QpIHtcbiAgICB2YXIgZnVsbExheW91dCA9IGdkLl9mdWxsTGF5b3V0O1xuICAgIHZhciBzbGlkZXJEYXRhID0gbWFrZVNsaWRlckRhdGEoZnVsbExheW91dCwgZ2QpO1xuXG4gICAgLy8gZHJhdyBhIGNvbnRhaW5lciBmb3IgKmFsbCogc2xpZGVyczpcbiAgICB2YXIgc2xpZGVycyA9IGZ1bGxMYXlvdXQuX2luZm9sYXllclxuICAgICAgICAuc2VsZWN0QWxsKCdnLicgKyBjb25zdGFudHMuY29udGFpbmVyQ2xhc3NOYW1lKVxuICAgICAgICAuZGF0YShzbGlkZXJEYXRhLmxlbmd0aCA+IDAgPyBbMF0gOiBbXSk7XG5cbiAgICBzbGlkZXJzLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgLmNsYXNzZWQoY29uc3RhbnRzLmNvbnRhaW5lckNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgICAgLnN0eWxlKCdjdXJzb3InLCAnZXctcmVzaXplJyk7XG5cbiAgICBmdW5jdGlvbiBjbGVhclNsaWRlcihzbGlkZXJPcHRzKSB7XG4gICAgICAgIGlmKHNsaWRlck9wdHMuX2NvbW1hbmRPYnNlcnZlcikge1xuICAgICAgICAgICAgc2xpZGVyT3B0cy5fY29tbWFuZE9ic2VydmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgZGVsZXRlIHNsaWRlck9wdHMuX2NvbW1hbmRPYnNlcnZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vc3QgY29tcG9uZW50cyBkb24ndCBuZWVkIHRvIGV4cGxpY2l0bHkgcmVtb3ZlIGF1dG9NYXJnaW4sIGJlY2F1c2VcbiAgICAgICAgLy8gbWFyZ2luUHVzaGVycyBkb2VzIHRoaXMgLSBidXQgc2xpZGVyIHVwZGF0ZXMgZG9uJ3QgZ28gdGhyb3VnaFxuICAgICAgICAvLyBhIGZ1bGwgcmVwbG90IHNvIHdlIG5lZWQgdG8gZXhwbGljaXRseSByZW1vdmUgaXQuXG4gICAgICAgIFBsb3RzLmF1dG9NYXJnaW4oZ2QsIGF1dG9NYXJnaW5JZChzbGlkZXJPcHRzKSk7XG4gICAgfVxuXG4gICAgc2xpZGVycy5leGl0KCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdEFsbCgnZy4nICsgY29uc3RhbnRzLmdyb3VwQ2xhc3NOYW1lKVxuICAgICAgICAgICAgLmVhY2goY2xlYXJTbGlkZXIpO1xuICAgIH0pXG4gICAgLnJlbW92ZSgpO1xuXG4gICAgLy8gUmV0dXJuIGVhcmx5IGlmIG5vIG1lbnVzIHZpc2libGU6XG4gICAgaWYoc2xpZGVyRGF0YS5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIHZhciBzbGlkZXJHcm91cHMgPSBzbGlkZXJzLnNlbGVjdEFsbCgnZy4nICsgY29uc3RhbnRzLmdyb3VwQ2xhc3NOYW1lKVxuICAgICAgICAuZGF0YShzbGlkZXJEYXRhLCBrZXlGdW5jdGlvbik7XG5cbiAgICBzbGlkZXJHcm91cHMuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAuY2xhc3NlZChjb25zdGFudHMuZ3JvdXBDbGFzc05hbWUsIHRydWUpO1xuXG4gICAgc2xpZGVyR3JvdXBzLmV4aXQoKVxuICAgICAgICAuZWFjaChjbGVhclNsaWRlcilcbiAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgLy8gRmluZCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgc2xpZGVyczpcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2xpZGVyRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2xpZGVyT3B0cyA9IHNsaWRlckRhdGFbaV07XG4gICAgICAgIGZpbmREaW1lbnNpb25zKGdkLCBzbGlkZXJPcHRzKTtcbiAgICB9XG5cbiAgICBzbGlkZXJHcm91cHMuZWFjaChmdW5jdGlvbihzbGlkZXJPcHRzKSB7XG4gICAgICAgIHZhciBnU2xpZGVyID0gZDMuc2VsZWN0KHRoaXMpO1xuXG4gICAgICAgIGNvbXB1dGVMYWJlbFN0ZXBzKHNsaWRlck9wdHMpO1xuXG4gICAgICAgIFBsb3RzLm1hbmFnZUNvbW1hbmRPYnNlcnZlcihnZCwgc2xpZGVyT3B0cywgc2xpZGVyT3B0cy5fdmlzaWJsZVN0ZXBzLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAvLyBOQjogU2FtZSBhcyBiZWxvdy4gVGhpcyBpcyAqbm90KiBhbHdheXMgdGhlIHNhbWUgYXMgc2xpZGVyT3B0cyBzaW5jZVxuICAgICAgICAgICAgLy8gaWYgYSBuZXcgc2V0IG9mIHN0ZXBzIGNvbWVzIGluLCB0aGUgcmVmZXJlbmNlIGluIHRoaXMgY2FsbGJhY2sgd291bGRcbiAgICAgICAgICAgIC8vIGJlIGludmFsaWQuIFdlIG5lZWQgdG8gcmVmZXRjaCBpdCBmcm9tIHRoZSBzbGlkZXIgZ3JvdXAsIHdoaWNoIGlzXG4gICAgICAgICAgICAvLyB0aGUgam9pbiBkYXRhIHRoYXQgY3JlYXRlcyB0aGlzIHNsaWRlci4gU28gaWYgdGhpcyBzbGlkZXIgc3RpbGwgZXhpc3RzLFxuICAgICAgICAgICAgLy8gdGhlIGdyb3VwIHNob3VsZCBiZSB2YWxpZCwgKnRvIHRoZSBiZXN0IG9mIG15IGtub3dsZWRnZS4qIElmIG5vdCxcbiAgICAgICAgICAgIC8vIHdlJ2QgaGF2ZSB0byBsb29rIGl0IHVwIGJ5IGQzIGRhdGEgam9pbiBpbmRleC9rZXkuXG4gICAgICAgICAgICB2YXIgb3B0cyA9IGdTbGlkZXIuZGF0YSgpWzBdO1xuXG4gICAgICAgICAgICBpZihvcHRzLmFjdGl2ZSA9PT0gZGF0YS5pbmRleCkgcmV0dXJuO1xuICAgICAgICAgICAgaWYob3B0cy5fZHJhZ2dpbmcpIHJldHVybjtcblxuICAgICAgICAgICAgc2V0QWN0aXZlKGdkLCBnU2xpZGVyLCBvcHRzLCBkYXRhLmluZGV4LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRyYXdTbGlkZXIoZ2QsIGQzLnNlbGVjdCh0aGlzKSwgc2xpZGVyT3B0cyk7XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBhdXRvTWFyZ2luSWQoc2xpZGVyT3B0cykge1xuICAgIHJldHVybiBjb25zdGFudHMuYXV0b01hcmdpbklkUm9vdCArIHNsaWRlck9wdHMuX2luZGV4O1xufVxuXG4vLyBUaGlzIHJlYWxseSBvbmx5IGp1c3QgZmlsdGVycyBieSB2aXNpYmlsaXR5OlxuZnVuY3Rpb24gbWFrZVNsaWRlckRhdGEoZnVsbExheW91dCwgZ2QpIHtcbiAgICB2YXIgY29udE9wdHMgPSBmdWxsTGF5b3V0W2NvbnN0YW50cy5uYW1lXTtcbiAgICB2YXIgc2xpZGVyRGF0YSA9IFtdO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvbnRPcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gY29udE9wdHNbaV07XG4gICAgICAgIGlmKCFpdGVtLnZpc2libGUpIGNvbnRpbnVlO1xuICAgICAgICBpdGVtLl9nZCA9IGdkO1xuICAgICAgICBzbGlkZXJEYXRhLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNsaWRlckRhdGE7XG59XG5cbi8vIFRoaXMgaXMgc2V0IGluIHRoZSBkZWZhdWx0cyBzdGVwOlxuZnVuY3Rpb24ga2V5RnVuY3Rpb24ob3B0cykge1xuICAgIHJldHVybiBvcHRzLl9pbmRleDtcbn1cblxuLy8gQ29tcHV0ZSB0aGUgZGltZW5zaW9ucyAobXV0YXRlcyBzbGlkZXJPcHRzKTpcbmZ1bmN0aW9uIGZpbmREaW1lbnNpb25zKGdkLCBzbGlkZXJPcHRzKSB7XG4gICAgdmFyIHNsaWRlckxhYmVscyA9IERyYXdpbmcudGVzdGVyLnNlbGVjdEFsbCgnZy4nICsgY29uc3RhbnRzLmxhYmVsR3JvdXBDbGFzcylcbiAgICAgICAgLmRhdGEoc2xpZGVyT3B0cy5fdmlzaWJsZVN0ZXBzKTtcblxuICAgIHNsaWRlckxhYmVscy5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgIC5jbGFzc2VkKGNvbnN0YW50cy5sYWJlbEdyb3VwQ2xhc3MsIHRydWUpO1xuXG4gICAgLy8gbG9vcCBvdmVyIGZha2UgYnV0dG9ucyB0byBmaW5kIHdpZHRoIC8gaGVpZ2h0XG4gICAgdmFyIG1heExhYmVsV2lkdGggPSAwO1xuICAgIHZhciBsYWJlbEhlaWdodCA9IDA7XG4gICAgc2xpZGVyTGFiZWxzLmVhY2goZnVuY3Rpb24oc3RlcE9wdHMpIHtcbiAgICAgICAgdmFyIGxhYmVsR3JvdXAgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgdmFyIHRleHQgPSBkcmF3TGFiZWwobGFiZWxHcm91cCwge3N0ZXA6IHN0ZXBPcHRzfSwgc2xpZGVyT3B0cyk7XG5cbiAgICAgICAgdmFyIHRleHROb2RlID0gdGV4dC5ub2RlKCk7XG4gICAgICAgIGlmKHRleHROb2RlKSB7XG4gICAgICAgICAgICB2YXIgYkJveCA9IERyYXdpbmcuYkJveCh0ZXh0Tm9kZSk7XG4gICAgICAgICAgICBsYWJlbEhlaWdodCA9IE1hdGgubWF4KGxhYmVsSGVpZ2h0LCBiQm94LmhlaWdodCk7XG4gICAgICAgICAgICBtYXhMYWJlbFdpZHRoID0gTWF0aC5tYXgobWF4TGFiZWxXaWR0aCwgYkJveC53aWR0aCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHNsaWRlckxhYmVscy5yZW1vdmUoKTtcblxuICAgIHZhciBkaW1zID0gc2xpZGVyT3B0cy5fZGltcyA9IHt9O1xuXG4gICAgZGltcy5pbnB1dEFyZWFXaWR0aCA9IE1hdGgubWF4KFxuICAgICAgICBjb25zdGFudHMucmFpbFdpZHRoLFxuICAgICAgICBjb25zdGFudHMuZ3JpcEhlaWdodFxuICAgICk7XG5cbiAgICAvLyBjYWxjdWxhdGUgc29tZSBvdmVyYWxsIGRpbWVuc2lvbnMgLSBzb21lIG9mIHRoZXNlIGFyZSBuZWVkZWQgZm9yXG4gICAgLy8gY2FsY3VsYXRpbmcgdGhlIGN1cnJlbnRWYWx1ZSBkaW1lbnNpb25zXG4gICAgdmFyIGdyYXBoU2l6ZSA9IGdkLl9mdWxsTGF5b3V0Ll9zaXplO1xuICAgIGRpbXMubHggPSBncmFwaFNpemUubCArIGdyYXBoU2l6ZS53ICogc2xpZGVyT3B0cy54O1xuICAgIGRpbXMubHkgPSBncmFwaFNpemUudCArIGdyYXBoU2l6ZS5oICogKDEgLSBzbGlkZXJPcHRzLnkpO1xuXG4gICAgaWYoc2xpZGVyT3B0cy5sZW5tb2RlID09PSAnZnJhY3Rpb24nKSB7XG4gICAgICAgIC8vIGZyYWN0aW9uOlxuICAgICAgICBkaW1zLm91dGVyTGVuZ3RoID0gTWF0aC5yb3VuZChncmFwaFNpemUudyAqIHNsaWRlck9wdHMubGVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwaXhlbHM6XG4gICAgICAgIGRpbXMub3V0ZXJMZW5ndGggPSBzbGlkZXJPcHRzLmxlbjtcbiAgICB9XG5cbiAgICAvLyBUaGUgbGVuZ3RoIG9mIHRoZSByYWlsLCAqZXhjbHVkaW5nKiBwYWRkaW5nIG9uIGVpdGhlciBlbmQ6XG4gICAgZGltcy5pbnB1dEFyZWFTdGFydCA9IDA7XG4gICAgZGltcy5pbnB1dEFyZWFMZW5ndGggPSBNYXRoLnJvdW5kKGRpbXMub3V0ZXJMZW5ndGggLSBzbGlkZXJPcHRzLnBhZC5sIC0gc2xpZGVyT3B0cy5wYWQucik7XG5cbiAgICB2YXIgdGV4dGFibGVJbnB1dExlbmd0aCA9IGRpbXMuaW5wdXRBcmVhTGVuZ3RoIC0gMiAqIGNvbnN0YW50cy5zdGVwSW5zZXQ7XG4gICAgdmFyIGF2YWlsYWJsZVNwYWNlUGVyTGFiZWwgPSB0ZXh0YWJsZUlucHV0TGVuZ3RoIC8gKHNsaWRlck9wdHMuX3N0ZXBDb3VudCAtIDEpO1xuICAgIHZhciBjb21wdXRlZFNwYWNlUGVyTGFiZWwgPSBtYXhMYWJlbFdpZHRoICsgY29uc3RhbnRzLmxhYmVsUGFkZGluZztcbiAgICBkaW1zLmxhYmVsU3RyaWRlID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKGNvbXB1dGVkU3BhY2VQZXJMYWJlbCAvIGF2YWlsYWJsZVNwYWNlUGVyTGFiZWwpKTtcbiAgICBkaW1zLmxhYmVsSGVpZ2h0ID0gbGFiZWxIZWlnaHQ7XG5cbiAgICAvLyBsb29wIG92ZXIgYWxsIHBvc3NpYmxlIHZhbHVlcyBmb3IgY3VycmVudFZhbHVlIHRvIGZpbmQgdGhlXG4gICAgLy8gYXJlYSB3ZSBuZWVkIGZvciBpdFxuICAgIGRpbXMuY3VycmVudFZhbHVlTWF4V2lkdGggPSAwO1xuICAgIGRpbXMuY3VycmVudFZhbHVlSGVpZ2h0ID0gMDtcbiAgICBkaW1zLmN1cnJlbnRWYWx1ZVRvdGFsSGVpZ2h0ID0gMDtcbiAgICBkaW1zLmN1cnJlbnRWYWx1ZU1heExpbmVzID0gMTtcblxuICAgIGlmKHNsaWRlck9wdHMuY3VycmVudHZhbHVlLnZpc2libGUpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBjdXJyZW50IHZhbHVlIGxhYmVsOlxuICAgICAgICB2YXIgZHVtbXlHcm91cCA9IERyYXdpbmcudGVzdGVyLmFwcGVuZCgnZycpO1xuXG4gICAgICAgIHNsaWRlckxhYmVscy5lYWNoKGZ1bmN0aW9uKHN0ZXBPcHRzKSB7XG4gICAgICAgICAgICB2YXIgY3VyVmFsUHJlZml4ID0gZHJhd0N1cnJlbnRWYWx1ZShkdW1teUdyb3VwLCBzbGlkZXJPcHRzLCBzdGVwT3B0cy5sYWJlbCk7XG4gICAgICAgICAgICB2YXIgY3VyVmFsU2l6ZSA9IChjdXJWYWxQcmVmaXgubm9kZSgpICYmIERyYXdpbmcuYkJveChjdXJWYWxQcmVmaXgubm9kZSgpKSkgfHwge3dpZHRoOiAwLCBoZWlnaHQ6IDB9O1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gc3ZnVGV4dFV0aWxzLmxpbmVDb3VudChjdXJWYWxQcmVmaXgpO1xuICAgICAgICAgICAgZGltcy5jdXJyZW50VmFsdWVNYXhXaWR0aCA9IE1hdGgubWF4KGRpbXMuY3VycmVudFZhbHVlTWF4V2lkdGgsIE1hdGguY2VpbChjdXJWYWxTaXplLndpZHRoKSk7XG4gICAgICAgICAgICBkaW1zLmN1cnJlbnRWYWx1ZUhlaWdodCA9IE1hdGgubWF4KGRpbXMuY3VycmVudFZhbHVlSGVpZ2h0LCBNYXRoLmNlaWwoY3VyVmFsU2l6ZS5oZWlnaHQpKTtcbiAgICAgICAgICAgIGRpbXMuY3VycmVudFZhbHVlTWF4TGluZXMgPSBNYXRoLm1heChkaW1zLmN1cnJlbnRWYWx1ZU1heExpbmVzLCBsaW5lcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRpbXMuY3VycmVudFZhbHVlVG90YWxIZWlnaHQgPSBkaW1zLmN1cnJlbnRWYWx1ZUhlaWdodCArIHNsaWRlck9wdHMuY3VycmVudHZhbHVlLm9mZnNldDtcblxuICAgICAgICBkdW1teUdyb3VwLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGRpbXMuaGVpZ2h0ID0gZGltcy5jdXJyZW50VmFsdWVUb3RhbEhlaWdodCArIGNvbnN0YW50cy50aWNrT2Zmc2V0ICsgc2xpZGVyT3B0cy50aWNrbGVuICsgY29uc3RhbnRzLmxhYmVsT2Zmc2V0ICsgZGltcy5sYWJlbEhlaWdodCArIHNsaWRlck9wdHMucGFkLnQgKyBzbGlkZXJPcHRzLnBhZC5iO1xuXG4gICAgdmFyIHhhbmNob3IgPSAnbGVmdCc7XG4gICAgaWYoTGliLmlzUmlnaHRBbmNob3Ioc2xpZGVyT3B0cykpIHtcbiAgICAgICAgZGltcy5seCAtPSBkaW1zLm91dGVyTGVuZ3RoO1xuICAgICAgICB4YW5jaG9yID0gJ3JpZ2h0JztcbiAgICB9XG4gICAgaWYoTGliLmlzQ2VudGVyQW5jaG9yKHNsaWRlck9wdHMpKSB7XG4gICAgICAgIGRpbXMubHggLT0gZGltcy5vdXRlckxlbmd0aCAvIDI7XG4gICAgICAgIHhhbmNob3IgPSAnY2VudGVyJztcbiAgICB9XG5cbiAgICB2YXIgeWFuY2hvciA9ICd0b3AnO1xuICAgIGlmKExpYi5pc0JvdHRvbUFuY2hvcihzbGlkZXJPcHRzKSkge1xuICAgICAgICBkaW1zLmx5IC09IGRpbXMuaGVpZ2h0O1xuICAgICAgICB5YW5jaG9yID0gJ2JvdHRvbSc7XG4gICAgfVxuICAgIGlmKExpYi5pc01pZGRsZUFuY2hvcihzbGlkZXJPcHRzKSkge1xuICAgICAgICBkaW1zLmx5IC09IGRpbXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgeWFuY2hvciA9ICdtaWRkbGUnO1xuICAgIH1cblxuICAgIGRpbXMub3V0ZXJMZW5ndGggPSBNYXRoLmNlaWwoZGltcy5vdXRlckxlbmd0aCk7XG4gICAgZGltcy5oZWlnaHQgPSBNYXRoLmNlaWwoZGltcy5oZWlnaHQpO1xuICAgIGRpbXMubHggPSBNYXRoLnJvdW5kKGRpbXMubHgpO1xuICAgIGRpbXMubHkgPSBNYXRoLnJvdW5kKGRpbXMubHkpO1xuXG4gICAgdmFyIG1hcmdpbk9wdHMgPSB7XG4gICAgICAgIHk6IHNsaWRlck9wdHMueSxcbiAgICAgICAgYjogZGltcy5oZWlnaHQgKiBGUk9NX0JSW3lhbmNob3JdLFxuICAgICAgICB0OiBkaW1zLmhlaWdodCAqIEZST01fVExbeWFuY2hvcl1cbiAgICB9O1xuXG4gICAgaWYoc2xpZGVyT3B0cy5sZW5tb2RlID09PSAnZnJhY3Rpb24nKSB7XG4gICAgICAgIG1hcmdpbk9wdHMubCA9IDA7XG4gICAgICAgIG1hcmdpbk9wdHMueGwgPSBzbGlkZXJPcHRzLnggLSBzbGlkZXJPcHRzLmxlbiAqIEZST01fVExbeGFuY2hvcl07XG4gICAgICAgIG1hcmdpbk9wdHMuciA9IDA7XG4gICAgICAgIG1hcmdpbk9wdHMueHIgPSBzbGlkZXJPcHRzLnggKyBzbGlkZXJPcHRzLmxlbiAqIEZST01fQlJbeGFuY2hvcl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbWFyZ2luT3B0cy54ID0gc2xpZGVyT3B0cy54O1xuICAgICAgICBtYXJnaW5PcHRzLmwgPSBkaW1zLm91dGVyTGVuZ3RoICogRlJPTV9UTFt4YW5jaG9yXTtcbiAgICAgICAgbWFyZ2luT3B0cy5yID0gZGltcy5vdXRlckxlbmd0aCAqIEZST01fQlJbeGFuY2hvcl07XG4gICAgfVxuXG4gICAgUGxvdHMuYXV0b01hcmdpbihnZCwgYXV0b01hcmdpbklkKHNsaWRlck9wdHMpLCBtYXJnaW5PcHRzKTtcbn1cblxuZnVuY3Rpb24gZHJhd1NsaWRlcihnZCwgc2xpZGVyR3JvdXAsIHNsaWRlck9wdHMpIHtcbiAgICAvLyBUaGlzIGlzIHJlbGF0ZWQgdG8gdGhlIG90aGVyIGxvbmcgbm90ZXMgaW4gdGhpcyBmaWxlIHJlZ2FyZGluZyB3aGF0IGhhcHBlbnNcbiAgICAvLyB3aGVuIHNsaWRlciBzdGVwcyBkaXNhcHBlYXIuIFRoaXMgcGFydGljdWxhciBmaXggaGFuZGxlcyB3aGF0IGhhcHBlbnMgd2hlblxuICAgIC8vIHRoZSAqY3VycmVudCogc2xpZGVyIHN0ZXAgaXMgcmVtb3ZlZC4gVGhlIGRyYXdpbmcgZnVuY3Rpb25zIHdpbGwgZXJyb3Igb3V0XG4gICAgLy8gd2hlbiB0aGV5IGZhaWwgdG8gZmluZCBpdCwgc28gdGhlIGZpeCBmb3Igbm93IGlzIHRoYXQgaXQgd2lsbCBqdXN0IGRyYXcgdGhlXG4gICAgLy8gc2xpZGVyIGluIHRoZSBmaXJzdCBwb3NpdGlvbiBidXQgd2lsbCBub3QgZXhlY3V0ZSB0aGUgY29tbWFuZC5cbiAgICBpZighKChzbGlkZXJPcHRzLnN0ZXBzW3NsaWRlck9wdHMuYWN0aXZlXSB8fCB7fSkudmlzaWJsZSkpIHtcbiAgICAgICAgc2xpZGVyT3B0cy5hY3RpdmUgPSBzbGlkZXJPcHRzLl92aXNpYmxlU3RlcHNbMF0uX2luZGV4O1xuICAgIH1cblxuICAgIC8vIFRoZXNlIGFyZSBjYXJlZnVsbHkgb3JkZXJlZCBmb3IgcHJvcGVyIHotb3JkZXJpbmc6XG4gICAgc2xpZGVyR3JvdXBcbiAgICAgICAgLmNhbGwoZHJhd0N1cnJlbnRWYWx1ZSwgc2xpZGVyT3B0cylcbiAgICAgICAgLmNhbGwoZHJhd1JhaWwsIHNsaWRlck9wdHMpXG4gICAgICAgIC5jYWxsKGRyYXdMYWJlbEdyb3VwLCBzbGlkZXJPcHRzKVxuICAgICAgICAuY2FsbChkcmF3VGlja3MsIHNsaWRlck9wdHMpXG4gICAgICAgIC5jYWxsKGRyYXdUb3VjaFJlY3QsIGdkLCBzbGlkZXJPcHRzKVxuICAgICAgICAuY2FsbChkcmF3R3JpcCwgZ2QsIHNsaWRlck9wdHMpO1xuXG4gICAgdmFyIGRpbXMgPSBzbGlkZXJPcHRzLl9kaW1zO1xuXG4gICAgLy8gUG9zaXRpb24gdGhlIHJlY3RhbmdsZTpcbiAgICBEcmF3aW5nLnNldFRyYW5zbGF0ZShzbGlkZXJHcm91cCwgZGltcy5seCArIHNsaWRlck9wdHMucGFkLmwsIGRpbXMubHkgKyBzbGlkZXJPcHRzLnBhZC50KTtcblxuICAgIHNsaWRlckdyb3VwLmNhbGwoc2V0R3JpcFBvc2l0aW9uLCBzbGlkZXJPcHRzLCBmYWxzZSk7XG4gICAgc2xpZGVyR3JvdXAuY2FsbChkcmF3Q3VycmVudFZhbHVlLCBzbGlkZXJPcHRzKTtcbn1cblxuZnVuY3Rpb24gZHJhd0N1cnJlbnRWYWx1ZShzbGlkZXJHcm91cCwgc2xpZGVyT3B0cywgdmFsdWVPdmVycmlkZSkge1xuICAgIGlmKCFzbGlkZXJPcHRzLmN1cnJlbnR2YWx1ZS52aXNpYmxlKSByZXR1cm47XG5cbiAgICB2YXIgZGltcyA9IHNsaWRlck9wdHMuX2RpbXM7XG4gICAgdmFyIHgwLCB0ZXh0QW5jaG9yO1xuXG4gICAgc3dpdGNoKHNsaWRlck9wdHMuY3VycmVudHZhbHVlLnhhbmNob3IpIHtcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhbmNob3JlZCBsZWZ0IGFuZCBhZGp1c3RlZCBieSB0aGUgd2lkdGggb2YgdGhlIGxvbmdlc3QgbGFiZWxcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIHByZWZpeCBkb2Vzbid0IG1vdmUuIFRoZSBnb2FsIG9mIHRoaXMgaXMgdG8gZW1waGFzaXplXG4gICAgICAgICAgICAvLyB3aGF0J3MgYWN0dWFsbHkgY2hhbmdpbmcgYW5kIG1ha2UgdGhlIHVwZGF0ZSBsZXNzIGRpc3RyYWN0aW5nLlxuICAgICAgICAgICAgeDAgPSBkaW1zLmlucHV0QXJlYUxlbmd0aCAtIGNvbnN0YW50cy5jdXJyZW50VmFsdWVJbnNldCAtIGRpbXMuY3VycmVudFZhbHVlTWF4V2lkdGg7XG4gICAgICAgICAgICB0ZXh0QW5jaG9yID0gJ2xlZnQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICB4MCA9IGRpbXMuaW5wdXRBcmVhTGVuZ3RoICogMC41O1xuICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB4MCA9IGNvbnN0YW50cy5jdXJyZW50VmFsdWVJbnNldDtcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSAnbGVmdCc7XG4gICAgfVxuXG4gICAgdmFyIHRleHQgPSBMaWIuZW5zdXJlU2luZ2xlKHNsaWRlckdyb3VwLCAndGV4dCcsIGNvbnN0YW50cy5sYWJlbENsYXNzLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHMuY2xhc3NlZCgndXNlci1zZWxlY3Qtbm9uZScsIHRydWUpXG4gICAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAgICAgJ3RleHQtYW5jaG9yJzogdGV4dEFuY2hvcixcbiAgICAgICAgICAgICAgICAnZGF0YS1ub3RleCc6IDFcbiAgICAgICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIHN0ciA9IHNsaWRlck9wdHMuY3VycmVudHZhbHVlLnByZWZpeCA/IHNsaWRlck9wdHMuY3VycmVudHZhbHVlLnByZWZpeCA6ICcnO1xuXG4gICAgaWYodHlwZW9mIHZhbHVlT3ZlcnJpZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN0ciArPSB2YWx1ZU92ZXJyaWRlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjdXJWYWwgPSBzbGlkZXJPcHRzLnN0ZXBzW3NsaWRlck9wdHMuYWN0aXZlXS5sYWJlbDtcbiAgICAgICAgdmFyIF9tZXRhID0gc2xpZGVyT3B0cy5fZ2QuX2Z1bGxMYXlvdXQuX21ldGE7XG4gICAgICAgIGlmKF9tZXRhKSBjdXJWYWwgPSBMaWIudGVtcGxhdGVTdHJpbmcoY3VyVmFsLCBfbWV0YSk7XG4gICAgICAgIHN0ciArPSBjdXJWYWw7XG4gICAgfVxuXG4gICAgaWYoc2xpZGVyT3B0cy5jdXJyZW50dmFsdWUuc3VmZml4KSB7XG4gICAgICAgIHN0ciArPSBzbGlkZXJPcHRzLmN1cnJlbnR2YWx1ZS5zdWZmaXg7XG4gICAgfVxuXG4gICAgdGV4dC5jYWxsKERyYXdpbmcuZm9udCwgc2xpZGVyT3B0cy5jdXJyZW50dmFsdWUuZm9udClcbiAgICAgICAgLnRleHQoc3RyKVxuICAgICAgICAuY2FsbChzdmdUZXh0VXRpbHMuY29udmVydFRvVHNwYW5zLCBzbGlkZXJPcHRzLl9nZCk7XG5cbiAgICB2YXIgbGluZXMgPSBzdmdUZXh0VXRpbHMubGluZUNvdW50KHRleHQpO1xuXG4gICAgdmFyIHkwID0gKGRpbXMuY3VycmVudFZhbHVlTWF4TGluZXMgKyAxIC0gbGluZXMpICpcbiAgICAgICAgc2xpZGVyT3B0cy5jdXJyZW50dmFsdWUuZm9udC5zaXplICogTElORV9TUEFDSU5HO1xuXG4gICAgc3ZnVGV4dFV0aWxzLnBvc2l0aW9uVGV4dCh0ZXh0LCB4MCwgeTApO1xuXG4gICAgcmV0dXJuIHRleHQ7XG59XG5cbmZ1bmN0aW9uIGRyYXdHcmlwKHNsaWRlckdyb3VwLCBnZCwgc2xpZGVyT3B0cykge1xuICAgIHZhciBncmlwID0gTGliLmVuc3VyZVNpbmdsZShzbGlkZXJHcm91cCwgJ3JlY3QnLCBjb25zdGFudHMuZ3JpcFJlY3RDbGFzcywgZnVuY3Rpb24ocykge1xuICAgICAgICBzLmNhbGwoYXR0YWNoR3JpcEV2ZW50cywgZ2QsIHNsaWRlckdyb3VwLCBzbGlkZXJPcHRzKVxuICAgICAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdhbGwnKTtcbiAgICB9KTtcblxuICAgIGdyaXAuYXR0cih7XG4gICAgICAgIHdpZHRoOiBjb25zdGFudHMuZ3JpcFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNvbnN0YW50cy5ncmlwSGVpZ2h0LFxuICAgICAgICByeDogY29uc3RhbnRzLmdyaXBSYWRpdXMsXG4gICAgICAgIHJ5OiBjb25zdGFudHMuZ3JpcFJhZGl1cyxcbiAgICB9KVxuICAgIC5jYWxsKENvbG9yLnN0cm9rZSwgc2xpZGVyT3B0cy5ib3JkZXJjb2xvcilcbiAgICAuY2FsbChDb2xvci5maWxsLCBzbGlkZXJPcHRzLmJnY29sb3IpXG4gICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBzbGlkZXJPcHRzLmJvcmRlcndpZHRoICsgJ3B4Jyk7XG59XG5cbmZ1bmN0aW9uIGRyYXdMYWJlbChpdGVtLCBkYXRhLCBzbGlkZXJPcHRzKSB7XG4gICAgdmFyIHRleHQgPSBMaWIuZW5zdXJlU2luZ2xlKGl0ZW0sICd0ZXh0JywgY29uc3RhbnRzLmxhYmVsQ2xhc3MsIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcy5jbGFzc2VkKCd1c2VyLXNlbGVjdC1ub25lJywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICAgICAndGV4dC1hbmNob3InOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICAnZGF0YS1ub3RleCc6IDFcbiAgICAgICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIHR4ID0gZGF0YS5zdGVwLmxhYmVsO1xuICAgIHZhciBfbWV0YSA9IHNsaWRlck9wdHMuX2dkLl9mdWxsTGF5b3V0Ll9tZXRhO1xuICAgIGlmKF9tZXRhKSB0eCA9IExpYi50ZW1wbGF0ZVN0cmluZyh0eCwgX21ldGEpO1xuXG4gICAgdGV4dC5jYWxsKERyYXdpbmcuZm9udCwgc2xpZGVyT3B0cy5mb250KVxuICAgICAgICAudGV4dCh0eClcbiAgICAgICAgLmNhbGwoc3ZnVGV4dFV0aWxzLmNvbnZlcnRUb1RzcGFucywgc2xpZGVyT3B0cy5fZ2QpO1xuXG4gICAgcmV0dXJuIHRleHQ7XG59XG5cbmZ1bmN0aW9uIGRyYXdMYWJlbEdyb3VwKHNsaWRlckdyb3VwLCBzbGlkZXJPcHRzKSB7XG4gICAgdmFyIGxhYmVscyA9IExpYi5lbnN1cmVTaW5nbGUoc2xpZGVyR3JvdXAsICdnJywgY29uc3RhbnRzLmxhYmVsc0NsYXNzKTtcbiAgICB2YXIgZGltcyA9IHNsaWRlck9wdHMuX2RpbXM7XG5cbiAgICB2YXIgbGFiZWxJdGVtcyA9IGxhYmVscy5zZWxlY3RBbGwoJ2cuJyArIGNvbnN0YW50cy5sYWJlbEdyb3VwQ2xhc3MpXG4gICAgICAgIC5kYXRhKGRpbXMubGFiZWxTdGVwcyk7XG5cbiAgICBsYWJlbEl0ZW1zLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgLmNsYXNzZWQoY29uc3RhbnRzLmxhYmVsR3JvdXBDbGFzcywgdHJ1ZSk7XG5cbiAgICBsYWJlbEl0ZW1zLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgIGxhYmVsSXRlbXMuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBpdGVtID0gZDMuc2VsZWN0KHRoaXMpO1xuXG4gICAgICAgIGl0ZW0uY2FsbChkcmF3TGFiZWwsIGQsIHNsaWRlck9wdHMpO1xuXG4gICAgICAgIERyYXdpbmcuc2V0VHJhbnNsYXRlKGl0ZW0sXG4gICAgICAgICAgICBub3JtYWxpemVkVmFsdWVUb1Bvc2l0aW9uKHNsaWRlck9wdHMsIGQuZnJhY3Rpb24pLFxuICAgICAgICAgICAgY29uc3RhbnRzLnRpY2tPZmZzZXQgK1xuICAgICAgICAgICAgICAgIHNsaWRlck9wdHMudGlja2xlbiArXG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb24gaXMgdGhlIGJhc2VsaW5lIG9mIHRoZSB0b3AgbGluZSBvZiB0ZXh0IG9ubHksIGV2ZW5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbGFiZWwgc3BhbnMgbXVsdGlwbGUgbGluZXNcbiAgICAgICAgICAgICAgICBzbGlkZXJPcHRzLmZvbnQuc2l6ZSAqIExJTkVfU1BBQ0lORyArXG4gICAgICAgICAgICAgICAgY29uc3RhbnRzLmxhYmVsT2Zmc2V0ICtcbiAgICAgICAgICAgICAgICBkaW1zLmN1cnJlbnRWYWx1ZVRvdGFsSGVpZ2h0XG4gICAgICAgICk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUlucHV0KGdkLCBzbGlkZXJHcm91cCwgc2xpZGVyT3B0cywgbm9ybWFsaXplZFBvc2l0aW9uLCBkb1RyYW5zaXRpb24pIHtcbiAgICB2YXIgcXVhbnRpemVkUG9zaXRpb24gPSBNYXRoLnJvdW5kKG5vcm1hbGl6ZWRQb3NpdGlvbiAqIChzbGlkZXJPcHRzLl9zdGVwQ291bnQgLSAxKSk7XG4gICAgdmFyIHF1YW50aXplZEluZGV4ID0gc2xpZGVyT3B0cy5fdmlzaWJsZVN0ZXBzW3F1YW50aXplZFBvc2l0aW9uXS5faW5kZXg7XG5cbiAgICBpZihxdWFudGl6ZWRJbmRleCAhPT0gc2xpZGVyT3B0cy5hY3RpdmUpIHtcbiAgICAgICAgc2V0QWN0aXZlKGdkLCBzbGlkZXJHcm91cCwgc2xpZGVyT3B0cywgcXVhbnRpemVkSW5kZXgsIHRydWUsIGRvVHJhbnNpdGlvbik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRBY3RpdmUoZ2QsIHNsaWRlckdyb3VwLCBzbGlkZXJPcHRzLCBpbmRleCwgZG9DYWxsYmFjaywgZG9UcmFuc2l0aW9uKSB7XG4gICAgdmFyIHByZXZpb3VzQWN0aXZlID0gc2xpZGVyT3B0cy5hY3RpdmU7XG4gICAgc2xpZGVyT3B0cy5hY3RpdmUgPSBpbmRleDtcblxuICAgIC8vIGR1ZSB0byB0ZW1wbGF0aW5nLCBpdCdzIHBvc3NpYmxlIHRoaXMgc2xpZGVyIGRvZXNuJ3QgZXZlbiBleGlzdCB5ZXRcbiAgICBhcnJheUVkaXRvcihnZC5sYXlvdXQsIGNvbnN0YW50cy5uYW1lLCBzbGlkZXJPcHRzKVxuICAgICAgICAuYXBwbHlVcGRhdGUoJ2FjdGl2ZScsIGluZGV4KTtcblxuICAgIHZhciBzdGVwID0gc2xpZGVyT3B0cy5zdGVwc1tzbGlkZXJPcHRzLmFjdGl2ZV07XG5cbiAgICBzbGlkZXJHcm91cC5jYWxsKHNldEdyaXBQb3NpdGlvbiwgc2xpZGVyT3B0cywgZG9UcmFuc2l0aW9uKTtcbiAgICBzbGlkZXJHcm91cC5jYWxsKGRyYXdDdXJyZW50VmFsdWUsIHNsaWRlck9wdHMpO1xuXG4gICAgZ2QuZW1pdCgncGxvdGx5X3NsaWRlcmNoYW5nZScsIHtcbiAgICAgICAgc2xpZGVyOiBzbGlkZXJPcHRzLFxuICAgICAgICBzdGVwOiBzbGlkZXJPcHRzLnN0ZXBzW3NsaWRlck9wdHMuYWN0aXZlXSxcbiAgICAgICAgaW50ZXJhY3Rpb246IGRvQ2FsbGJhY2ssXG4gICAgICAgIHByZXZpb3VzQWN0aXZlOiBwcmV2aW91c0FjdGl2ZVxuICAgIH0pO1xuXG4gICAgaWYoc3RlcCAmJiBzdGVwLm1ldGhvZCAmJiBkb0NhbGxiYWNrKSB7XG4gICAgICAgIGlmKHNsaWRlckdyb3VwLl9uZXh0TWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHF1ZXVlZCB1cCBhbiB1cGRhdGUsIGp1c3Qgb3ZlcndyaXRlIGl0IHdpdGggdGhlIG1vc3QgcmVjZW50OlxuICAgICAgICAgICAgc2xpZGVyR3JvdXAuX25leHRNZXRob2Quc3RlcCA9IHN0ZXA7XG4gICAgICAgICAgICBzbGlkZXJHcm91cC5fbmV4dE1ldGhvZC5kb0NhbGxiYWNrID0gZG9DYWxsYmFjaztcbiAgICAgICAgICAgIHNsaWRlckdyb3VwLl9uZXh0TWV0aG9kLmRvVHJhbnNpdGlvbiA9IGRvVHJhbnNpdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNsaWRlckdyb3VwLl9uZXh0TWV0aG9kID0ge3N0ZXA6IHN0ZXAsIGRvQ2FsbGJhY2s6IGRvQ2FsbGJhY2ssIGRvVHJhbnNpdGlvbjogZG9UcmFuc2l0aW9ufTtcbiAgICAgICAgICAgIHNsaWRlckdyb3VwLl9uZXh0TWV0aG9kUmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3N0ZXAgPSBzbGlkZXJHcm91cC5fbmV4dE1ldGhvZC5zdGVwO1xuICAgICAgICAgICAgICAgIGlmKCFfc3RlcC5tZXRob2QpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGlmKF9zdGVwLmV4ZWN1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgUGxvdHMuZXhlY3V0ZUFQSUNvbW1hbmQoZ2QsIF9zdGVwLm1ldGhvZCwgX3N0ZXAuYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2xpZGVyR3JvdXAuX25leHRNZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNsaWRlckdyb3VwLl9uZXh0TWV0aG9kUmFmID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhdHRhY2hHcmlwRXZlbnRzKGl0ZW0sIGdkLCBzbGlkZXJHcm91cCkge1xuICAgIHZhciBub2RlID0gc2xpZGVyR3JvdXAubm9kZSgpO1xuICAgIHZhciAkZ2QgPSBkMy5zZWxlY3QoZ2QpO1xuXG4gICAgLy8gTkI6IFRoaXMgaXMgKm5vdCogdGhlIHNhbWUgYXMgc2xpZGVyT3B0cyBpdHNlbGYhIFRoZXNlIGNhbGxiYWNrc1xuICAgIC8vIGFyZSBpbiBhIGNsb3N1cmUgc28gdGhpcyBhcnJheSB3b24ndCBhY3R1YWxseSBiZSBjb3JyZWN0IGlmIHRoZVxuICAgIC8vIHN0ZXBzIGhhdmUgY2hhbmdlZCBzaW5jZSB0aGlzIHdhcyBpbml0aWFsaXplZC4gVGhlIHNsaWRlckdyb3VwLFxuICAgIC8vIGhvd2V2ZXIsIGhhcyBub3QgY2hhbmdlZCBzaW5jZSB0aGF0ICppcyogdGhlIHNsaWRlciwgc28gaXQgbXVzdFxuICAgIC8vIGJlIHByZXNlbnQgdG8gcmVjZWl2ZSBtb3VzZSBldmVudHMuXG4gICAgZnVuY3Rpb24gZ2V0U2xpZGVyT3B0cygpIHtcbiAgICAgICAgcmV0dXJuIHNsaWRlckdyb3VwLmRhdGEoKVswXTtcbiAgICB9XG5cbiAgICBpdGVtLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNsaWRlck9wdHMgPSBnZXRTbGlkZXJPcHRzKCk7XG4gICAgICAgIGdkLmVtaXQoJ3Bsb3RseV9zbGlkZXJzdGFydCcsIHtzbGlkZXI6IHNsaWRlck9wdHN9KTtcblxuICAgICAgICB2YXIgZ3JpcCA9IHNsaWRlckdyb3VwLnNlbGVjdCgnLicgKyBjb25zdGFudHMuZ3JpcFJlY3RDbGFzcyk7XG5cbiAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGdyaXAuY2FsbChDb2xvci5maWxsLCBzbGlkZXJPcHRzLmFjdGl2ZWJnY29sb3IpO1xuXG4gICAgICAgIHZhciBub3JtYWxpemVkUG9zaXRpb24gPSBwb3NpdGlvblRvTm9ybWFsaXplZFZhbHVlKHNsaWRlck9wdHMsIGQzLm1vdXNlKG5vZGUpWzBdKTtcbiAgICAgICAgaGFuZGxlSW5wdXQoZ2QsIHNsaWRlckdyb3VwLCBzbGlkZXJPcHRzLCBub3JtYWxpemVkUG9zaXRpb24sIHRydWUpO1xuICAgICAgICBzbGlkZXJPcHRzLl9kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgJGdkLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzbGlkZXJPcHRzID0gZ2V0U2xpZGVyT3B0cygpO1xuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRQb3NpdGlvbiA9IHBvc2l0aW9uVG9Ob3JtYWxpemVkVmFsdWUoc2xpZGVyT3B0cywgZDMubW91c2Uobm9kZSlbMF0pO1xuICAgICAgICAgICAgaGFuZGxlSW5wdXQoZ2QsIHNsaWRlckdyb3VwLCBzbGlkZXJPcHRzLCBub3JtYWxpemVkUG9zaXRpb24sIGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJGdkLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2xpZGVyT3B0cyA9IGdldFNsaWRlck9wdHMoKTtcbiAgICAgICAgICAgIHNsaWRlck9wdHMuX2RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBncmlwLmNhbGwoQ29sb3IuZmlsbCwgc2xpZGVyT3B0cy5iZ2NvbG9yKTtcbiAgICAgICAgICAgICRnZC5vbignbW91c2V1cCcsIG51bGwpO1xuICAgICAgICAgICAgJGdkLm9uKCdtb3VzZW1vdmUnLCBudWxsKTtcblxuICAgICAgICAgICAgZ2QuZW1pdCgncGxvdGx5X3NsaWRlcmVuZCcsIHtcbiAgICAgICAgICAgICAgICBzbGlkZXI6IHNsaWRlck9wdHMsXG4gICAgICAgICAgICAgICAgc3RlcDogc2xpZGVyT3B0cy5zdGVwc1tzbGlkZXJPcHRzLmFjdGl2ZV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZHJhd1RpY2tzKHNsaWRlckdyb3VwLCBzbGlkZXJPcHRzKSB7XG4gICAgdmFyIHRpY2sgPSBzbGlkZXJHcm91cC5zZWxlY3RBbGwoJ3JlY3QuJyArIGNvbnN0YW50cy50aWNrUmVjdENsYXNzKVxuICAgICAgICAuZGF0YShzbGlkZXJPcHRzLl92aXNpYmxlU3RlcHMpO1xuICAgIHZhciBkaW1zID0gc2xpZGVyT3B0cy5fZGltcztcblxuICAgIHRpY2suZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuY2xhc3NlZChjb25zdGFudHMudGlja1JlY3RDbGFzcywgdHJ1ZSk7XG5cbiAgICB0aWNrLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgIHRpY2suYXR0cih7XG4gICAgICAgIHdpZHRoOiBzbGlkZXJPcHRzLnRpY2t3aWR0aCArICdweCcsXG4gICAgICAgICdzaGFwZS1yZW5kZXJpbmcnOiAnY3Jpc3BFZGdlcydcbiAgICB9KTtcblxuICAgIHRpY2suZWFjaChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIHZhciBpc01ham9yID0gaSAlIGRpbXMubGFiZWxTdHJpZGUgPT09IDA7XG4gICAgICAgIHZhciBpdGVtID0gZDMuc2VsZWN0KHRoaXMpO1xuXG4gICAgICAgIGl0ZW1cbiAgICAgICAgICAgIC5hdHRyKHtoZWlnaHQ6IGlzTWFqb3IgPyBzbGlkZXJPcHRzLnRpY2tsZW4gOiBzbGlkZXJPcHRzLm1pbm9ydGlja2xlbn0pXG4gICAgICAgICAgICAuY2FsbChDb2xvci5maWxsLCBpc01ham9yID8gc2xpZGVyT3B0cy50aWNrY29sb3IgOiBzbGlkZXJPcHRzLnRpY2tjb2xvcik7XG5cbiAgICAgICAgRHJhd2luZy5zZXRUcmFuc2xhdGUoaXRlbSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRWYWx1ZVRvUG9zaXRpb24oc2xpZGVyT3B0cywgaSAvIChzbGlkZXJPcHRzLl9zdGVwQ291bnQgLSAxKSkgLSAwLjUgKiBzbGlkZXJPcHRzLnRpY2t3aWR0aCxcbiAgICAgICAgICAgIChpc01ham9yID8gY29uc3RhbnRzLnRpY2tPZmZzZXQgOiBjb25zdGFudHMubWlub3JUaWNrT2Zmc2V0KSArIGRpbXMuY3VycmVudFZhbHVlVG90YWxIZWlnaHRcbiAgICAgICAgKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUxhYmVsU3RlcHMoc2xpZGVyT3B0cykge1xuICAgIHZhciBkaW1zID0gc2xpZGVyT3B0cy5fZGltcztcbiAgICBkaW1zLmxhYmVsU3RlcHMgPSBbXTtcbiAgICB2YXIgbnN0ZXBzID0gc2xpZGVyT3B0cy5fc3RlcENvdW50O1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG5zdGVwczsgaSArPSBkaW1zLmxhYmVsU3RyaWRlKSB7XG4gICAgICAgIGRpbXMubGFiZWxTdGVwcy5wdXNoKHtcbiAgICAgICAgICAgIGZyYWN0aW9uOiBpIC8gKG5zdGVwcyAtIDEpLFxuICAgICAgICAgICAgc3RlcDogc2xpZGVyT3B0cy5fdmlzaWJsZVN0ZXBzW2ldXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0R3JpcFBvc2l0aW9uKHNsaWRlckdyb3VwLCBzbGlkZXJPcHRzLCBkb1RyYW5zaXRpb24pIHtcbiAgICB2YXIgZ3JpcCA9IHNsaWRlckdyb3VwLnNlbGVjdCgncmVjdC4nICsgY29uc3RhbnRzLmdyaXBSZWN0Q2xhc3MpO1xuXG4gICAgdmFyIHF1YW50aXplZEluZGV4ID0gMDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2xpZGVyT3B0cy5fc3RlcENvdW50OyBpKyspIHtcbiAgICAgICAgaWYoc2xpZGVyT3B0cy5fdmlzaWJsZVN0ZXBzW2ldLl9pbmRleCA9PT0gc2xpZGVyT3B0cy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHF1YW50aXplZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHggPSBub3JtYWxpemVkVmFsdWVUb1Bvc2l0aW9uKHNsaWRlck9wdHMsIHF1YW50aXplZEluZGV4IC8gKHNsaWRlck9wdHMuX3N0ZXBDb3VudCAtIDEpKTtcblxuICAgIC8vIElmIHRoaXMgaXMgdHJ1ZSwgdGhlbiAqdGhpcyBjb21wb25lbnQqIGlzIGFscmVhZHkgaW52b2tpbmcgaXRzIG93biBjb21tYW5kXG4gICAgLy8gYW5kIGhhcyB0cmlnZ2VyZWQgaXRzIG93biBhbmltYXRpb24uXG4gICAgaWYoc2xpZGVyT3B0cy5faW52b2tpbmdDb21tYW5kKSByZXR1cm47XG5cbiAgICB2YXIgZWwgPSBncmlwO1xuICAgIGlmKGRvVHJhbnNpdGlvbiAmJiBzbGlkZXJPcHRzLnRyYW5zaXRpb24uZHVyYXRpb24gPiAwKSB7XG4gICAgICAgIGVsID0gZWwudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oc2xpZGVyT3B0cy50cmFuc2l0aW9uLmR1cmF0aW9uKVxuICAgICAgICAgICAgLmVhc2Uoc2xpZGVyT3B0cy50cmFuc2l0aW9uLmVhc2luZyk7XG4gICAgfVxuXG4gICAgLy8gRHJhd2luZy5zZXRUcmFuc2xhdGUgZG9lc24ndCB3b3JrIGhlcmUgYmVjYXN1ZSBvZiB0aGUgdHJhbnNpdGlvbiBkdWNrLXR5cGluZy5cbiAgICAvLyBJdCdzIGFsc28gbm90IG5lY2Vzc2FyeSBiZWNhdXNlIHRoZXJlIGFyZSBubyBvdGhlciB0cmFuc2l0aW9ucyB0byBwcmVzZXJ2ZS5cbiAgICBlbC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoeCAtIGNvbnN0YW50cy5ncmlwV2lkdGggKiAwLjUpICsgJywnICsgKHNsaWRlck9wdHMuX2RpbXMuY3VycmVudFZhbHVlVG90YWxIZWlnaHQpICsgJyknKTtcbn1cblxuLy8gQ29udmVydCBhIG51bWJlciBmcm9tIFswLTFdIHRvIGEgcGl4ZWwgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHNsaWRlciBncm91cCBjb250YWluZXI6XG5mdW5jdGlvbiBub3JtYWxpemVkVmFsdWVUb1Bvc2l0aW9uKHNsaWRlck9wdHMsIG5vcm1hbGl6ZWRQb3NpdGlvbikge1xuICAgIHZhciBkaW1zID0gc2xpZGVyT3B0cy5fZGltcztcbiAgICByZXR1cm4gZGltcy5pbnB1dEFyZWFTdGFydCArIGNvbnN0YW50cy5zdGVwSW5zZXQgK1xuICAgICAgICAoZGltcy5pbnB1dEFyZWFMZW5ndGggLSAyICogY29uc3RhbnRzLnN0ZXBJbnNldCkgKiBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBub3JtYWxpemVkUG9zaXRpb24pKTtcbn1cblxuLy8gQ29udmVydCBhIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzbGlkZXIgZ3JvdXAgdG8gYSBudWJtZXIgaW4gWzAsIDFdXG5mdW5jdGlvbiBwb3NpdGlvblRvTm9ybWFsaXplZFZhbHVlKHNsaWRlck9wdHMsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGRpbXMgPSBzbGlkZXJPcHRzLl9kaW1zO1xuICAgIHJldHVybiBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCAocG9zaXRpb24gLSBjb25zdGFudHMuc3RlcEluc2V0IC0gZGltcy5pbnB1dEFyZWFTdGFydCkgLyAoZGltcy5pbnB1dEFyZWFMZW5ndGggLSAyICogY29uc3RhbnRzLnN0ZXBJbnNldCAtIDIgKiBkaW1zLmlucHV0QXJlYVN0YXJ0KSkpO1xufVxuXG5mdW5jdGlvbiBkcmF3VG91Y2hSZWN0KHNsaWRlckdyb3VwLCBnZCwgc2xpZGVyT3B0cykge1xuICAgIHZhciBkaW1zID0gc2xpZGVyT3B0cy5fZGltcztcbiAgICB2YXIgcmVjdCA9IExpYi5lbnN1cmVTaW5nbGUoc2xpZGVyR3JvdXAsICdyZWN0JywgY29uc3RhbnRzLnJhaWxUb3VjaFJlY3RDbGFzcywgZnVuY3Rpb24ocykge1xuICAgICAgICBzLmNhbGwoYXR0YWNoR3JpcEV2ZW50cywgZ2QsIHNsaWRlckdyb3VwLCBzbGlkZXJPcHRzKVxuICAgICAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdhbGwnKTtcbiAgICB9KTtcblxuICAgIHJlY3QuYXR0cih7XG4gICAgICAgIHdpZHRoOiBkaW1zLmlucHV0QXJlYUxlbmd0aCxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChkaW1zLmlucHV0QXJlYVdpZHRoLCBjb25zdGFudHMudGlja09mZnNldCArIHNsaWRlck9wdHMudGlja2xlbiArIGRpbXMubGFiZWxIZWlnaHQpXG4gICAgfSlcbiAgICAgICAgLmNhbGwoQ29sb3IuZmlsbCwgc2xpZGVyT3B0cy5iZ2NvbG9yKVxuICAgICAgICAuYXR0cignb3BhY2l0eScsIDApO1xuXG4gICAgRHJhd2luZy5zZXRUcmFuc2xhdGUocmVjdCwgMCwgZGltcy5jdXJyZW50VmFsdWVUb3RhbEhlaWdodCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdSYWlsKHNsaWRlckdyb3VwLCBzbGlkZXJPcHRzKSB7XG4gICAgdmFyIGRpbXMgPSBzbGlkZXJPcHRzLl9kaW1zO1xuICAgIHZhciBjb21wdXRlZExlbmd0aCA9IGRpbXMuaW5wdXRBcmVhTGVuZ3RoIC0gY29uc3RhbnRzLnJhaWxJbnNldCAqIDI7XG4gICAgdmFyIHJlY3QgPSBMaWIuZW5zdXJlU2luZ2xlKHNsaWRlckdyb3VwLCAncmVjdCcsIGNvbnN0YW50cy5yYWlsUmVjdENsYXNzKTtcblxuICAgIHJlY3QuYXR0cih7XG4gICAgICAgIHdpZHRoOiBjb21wdXRlZExlbmd0aCxcbiAgICAgICAgaGVpZ2h0OiBjb25zdGFudHMucmFpbFdpZHRoLFxuICAgICAgICByeDogY29uc3RhbnRzLnJhaWxSYWRpdXMsXG4gICAgICAgIHJ5OiBjb25zdGFudHMucmFpbFJhZGl1cyxcbiAgICAgICAgJ3NoYXBlLXJlbmRlcmluZyc6ICdjcmlzcEVkZ2VzJ1xuICAgIH0pXG4gICAgLmNhbGwoQ29sb3Iuc3Ryb2tlLCBzbGlkZXJPcHRzLmJvcmRlcmNvbG9yKVxuICAgIC5jYWxsKENvbG9yLmZpbGwsIHNsaWRlck9wdHMuYmdjb2xvcilcbiAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHNsaWRlck9wdHMuYm9yZGVyd2lkdGggKyAncHgnKTtcblxuICAgIERyYXdpbmcuc2V0VHJhbnNsYXRlKHJlY3QsXG4gICAgICAgIGNvbnN0YW50cy5yYWlsSW5zZXQsXG4gICAgICAgIChkaW1zLmlucHV0QXJlYVdpZHRoIC0gY29uc3RhbnRzLnJhaWxXaWR0aCkgKiAwLjUgKyBkaW1zLmN1cnJlbnRWYWx1ZVRvdGFsSGVpZ2h0XG4gICAgKTtcbn1cbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1vZHVsZVR5cGU6ICdjb21wb25lbnQnLFxuICAgIG5hbWU6IGNvbnN0YW50cy5uYW1lLFxuXG4gICAgbGF5b3V0QXR0cmlidXRlczogcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyksXG4gICAgc3VwcGx5TGF5b3V0RGVmYXVsdHM6IHJlcXVpcmUoJy4vZGVmYXVsdHMnKSxcblxuICAgIGRyYXc6IHJlcXVpcmUoJy4vZHJhdycpXG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9udEF0dHJzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvZm9udF9hdHRyaWJ1dGVzJyk7XG52YXIgY29sb3JBdHRycyA9IHJlcXVpcmUoJy4uL2NvbG9yL2F0dHJpYnV0ZXMnKTtcbnZhciBleHRlbmRGbGF0ID0gcmVxdWlyZSgnLi4vLi4vbGliL2V4dGVuZCcpLmV4dGVuZEZsYXQ7XG52YXIgb3ZlcnJpZGVBbGwgPSByZXF1aXJlKCcuLi8uLi9wbG90X2FwaS9lZGl0X3R5cGVzJykub3ZlcnJpZGVBbGw7XG52YXIgcGFkQXR0cnMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9wYWRfYXR0cmlidXRlcycpO1xudmFyIHRlbXBsYXRlZEFycmF5ID0gcmVxdWlyZSgnLi4vLi4vcGxvdF9hcGkvcGxvdF90ZW1wbGF0ZScpLnRlbXBsYXRlZEFycmF5O1xuXG52YXIgYnV0dG9uc0F0dHJzID0gdGVtcGxhdGVkQXJyYXkoJ2J1dHRvbicsIHtcbiAgICB2aXNpYmxlOiB7XG4gICAgICAgIHZhbFR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0RldGVybWluZXMgd2hldGhlciBvciBub3QgdGhpcyBidXR0b24gaXMgdmlzaWJsZS4nXG4gICAgfSxcbiAgICBtZXRob2Q6IHtcbiAgICAgICAgdmFsVHlwZTogJ2VudW1lcmF0ZWQnLFxuICAgICAgICB2YWx1ZXM6IFsncmVzdHlsZScsICdyZWxheW91dCcsICdhbmltYXRlJywgJ3VwZGF0ZScsICdza2lwJ10sXG4gICAgICAgIGRmbHQ6ICdyZXN0eWxlJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1NldHMgdGhlIFBsb3RseSBtZXRob2QgdG8gYmUgY2FsbGVkIG9uIGNsaWNrLicsXG4gICAgICAgICAgICAnSWYgdGhlIGBza2lwYCBtZXRob2QgaXMgdXNlZCwgdGhlIEFQSSB1cGRhdGVtZW51IHdpbGwgZnVuY3Rpb24gYXMgbm9ybWFsJyxcbiAgICAgICAgICAgICdidXQgd2lsbCBwZXJmb3JtIG5vIEFQSSBjYWxscyBhbmQgd2lsbCBub3QgYmluZCBhdXRvbWF0aWNhbGx5IHRvIHN0YXRlJyxcbiAgICAgICAgICAgICd1cGRhdGVzLiBUaGlzIG1heSBiZSB1c2VkIHRvIGNyZWF0ZSBhIGNvbXBvbmVudCBpbnRlcmZhY2UgYW5kIGF0dGFjaCB0bycsXG4gICAgICAgICAgICAndXBkYXRlbWVudSBldmVudHMgbWFudWFsbHkgdmlhIEphdmFTY3JpcHQuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgYXJnczoge1xuICAgICAgICB2YWxUeXBlOiAnaW5mb19hcnJheScsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgZnJlZUxlbmd0aDogdHJ1ZSxcbiAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgIHt2YWxUeXBlOiAnYW55J30sXG4gICAgICAgICAgICB7dmFsVHlwZTogJ2FueSd9LFxuICAgICAgICAgICAge3ZhbFR5cGU6ICdhbnknfVxuICAgICAgICBdLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1NldHMgdGhlIGFyZ3VtZW50cyB2YWx1ZXMgdG8gYmUgcGFzc2VkIHRvIHRoZSBQbG90bHknLFxuICAgICAgICAgICAgJ21ldGhvZCBzZXQgaW4gYG1ldGhvZGAgb24gY2xpY2suJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgYXJnczI6IHtcbiAgICAgICAgdmFsVHlwZTogJ2luZm9fYXJyYXknLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGZyZWVMZW5ndGg6IHRydWUsXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICB7dmFsVHlwZTogJ2FueSd9LFxuICAgICAgICAgICAge3ZhbFR5cGU6ICdhbnknfSxcbiAgICAgICAgICAgIHt2YWxUeXBlOiAnYW55J31cbiAgICAgICAgXSxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIGEgMm5kIHNldCBvZiBgYXJnc2AsJyxcbiAgICAgICAgICAgICd0aGVzZSBhcmd1bWVudHMgdmFsdWVzIGFyZSBwYXNzZWQgdG8gdGhlIFBsb3RseScsXG4gICAgICAgICAgICAnbWV0aG9kIHNldCBpbiBgbWV0aG9kYCB3aGVuIGNsaWNraW5nIHRoaXMgYnV0dG9uIHdoaWxlIGluIHRoZSBhY3RpdmUgc3RhdGUuJyxcbiAgICAgICAgICAgICdVc2UgdGhpcyB0byBjcmVhdGUgdG9nZ2xlIGJ1dHRvbnMuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgbGFiZWw6IHtcbiAgICAgICAgdmFsVHlwZTogJ3N0cmluZycsXG4gICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgZGZsdDogJycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU2V0cyB0aGUgdGV4dCBsYWJlbCB0byBhcHBlYXIgb24gdGhlIGJ1dHRvbi4nXG4gICAgfSxcbiAgICBleGVjdXRlOiB7XG4gICAgICAgIHZhbFR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZmx0OiB0cnVlLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1doZW4gdHJ1ZSwgdGhlIEFQSSBtZXRob2QgaXMgZXhlY3V0ZWQuIFdoZW4gZmFsc2UsIGFsbCBvdGhlciBiZWhhdmlvcnMgYXJlIHRoZSBzYW1lJyxcbiAgICAgICAgICAgICdhbmQgY29tbWFuZCBleGVjdXRpb24gaXMgc2tpcHBlZC4gVGhpcyBtYXkgYmUgdXNlZnVsIHdoZW4gaG9va2luZyBpbnRvLCBmb3IgZXhhbXBsZSwnLFxuICAgICAgICAgICAgJ3RoZSBgcGxvdGx5X2J1dHRvbmNsaWNrZWRgIG1ldGhvZCBhbmQgZXhlY3V0aW5nIHRoZSBBUEkgY29tbWFuZCBtYW51YWxseSB3aXRob3V0IGxvc2luZycsXG4gICAgICAgICAgICAndGhlIGJlbmVmaXQgb2YgdGhlIHVwZGF0ZW1lbnUgYXV0b21hdGljYWxseSBiaW5kaW5nIHRvIHRoZSBzdGF0ZSBvZiB0aGUgcGxvdCB0aHJvdWdoIHRoZScsXG4gICAgICAgICAgICAnc3BlY2lmaWNhdGlvbiBvZiBgbWV0aG9kYCBhbmQgYGFyZ3NgLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBvdmVycmlkZUFsbCh0ZW1wbGF0ZWRBcnJheSgndXBkYXRlbWVudScsIHtcbiAgICBfYXJyYXlBdHRyUmVnZXhwczogWy9edXBkYXRlbWVudXNcXFsoMHxbMS05XVswLTldKylcXF1cXC5idXR0b25zL10sXG5cbiAgICB2aXNpYmxlOiB7XG4gICAgICAgIHZhbFR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ0RldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIHVwZGF0ZSBtZW51IGlzIHZpc2libGUuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG5cbiAgICB0eXBlOiB7XG4gICAgICAgIHZhbFR5cGU6ICdlbnVtZXJhdGVkJyxcbiAgICAgICAgdmFsdWVzOiBbJ2Ryb3Bkb3duJywgJ2J1dHRvbnMnXSxcbiAgICAgICAgZGZsdDogJ2Ryb3Bkb3duJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ0RldGVybWluZXMgd2hldGhlciB0aGUgYnV0dG9ucyBhcmUgYWNjZXNzaWJsZSB2aWEgYSBkcm9wZG93biBtZW51JyxcbiAgICAgICAgICAgICdvciB3aGV0aGVyIHRoZSBidXR0b25zIGFyZSBzdGFja2VkIGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5J1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG5cbiAgICBkaXJlY3Rpb246IHtcbiAgICAgICAgdmFsVHlwZTogJ2VudW1lcmF0ZWQnLFxuICAgICAgICB2YWx1ZXM6IFsnbGVmdCcsICdyaWdodCcsICd1cCcsICdkb3duJ10sXG4gICAgICAgIGRmbHQ6ICdkb3duJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ0RldGVybWluZXMgdGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGUgYnV0dG9ucyBhcmUgbGFpZCBvdXQsIHdoZXRoZXInLFxuICAgICAgICAgICAgJ2luIGEgZHJvcGRvd24gbWVudSBvciBhIHJvdy9jb2x1bW4gb2YgYnV0dG9ucy4gRm9yIGBsZWZ0YCBhbmQgYHVwYCwnLFxuICAgICAgICAgICAgJ3RoZSBidXR0b25zIHdpbGwgc3RpbGwgYXBwZWFyIGluIGxlZnQtdG8tcmlnaHQgb3IgdG9wLXRvLWJvdHRvbSBvcmRlcicsXG4gICAgICAgICAgICAncmVzcGVjdGl2ZWx5LidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuXG4gICAgYWN0aXZlOiB7XG4gICAgICAgIHZhbFR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBtaW46IC0xLFxuICAgICAgICBkZmx0OiAwLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ0RldGVybWluZXMgd2hpY2ggYnV0dG9uIChieSBpbmRleCBzdGFydGluZyBmcm9tIDApIGlzJyxcbiAgICAgICAgICAgICdjb25zaWRlcmVkIGFjdGl2ZS4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcblxuICAgIHNob3dhY3RpdmU6IHtcbiAgICAgICAgdmFsVHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGRmbHQ6IHRydWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnSGlnaGxpZ2h0cyBhY3RpdmUgZHJvcGRvd24gaXRlbSBvciBhY3RpdmUgYnV0dG9uIGlmIHRydWUuJ1xuICAgIH0sXG5cbiAgICBidXR0b25zOiBidXR0b25zQXR0cnMsXG5cbiAgICB4OiB7XG4gICAgICAgIHZhbFR5cGU6ICdudW1iZXInLFxuICAgICAgICBtaW46IC0yLFxuICAgICAgICBtYXg6IDMsXG4gICAgICAgIGRmbHQ6IC0wLjA1LFxuICAgICAgICByb2xlOiAnc3R5bGUnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIHggcG9zaXRpb24gKGluIG5vcm1hbGl6ZWQgY29vcmRpbmF0ZXMpIG9mIHRoZSB1cGRhdGUgbWVudS4nXG4gICAgfSxcbiAgICB4YW5jaG9yOiB7XG4gICAgICAgIHZhbFR5cGU6ICdlbnVtZXJhdGVkJyxcbiAgICAgICAgdmFsdWVzOiBbJ2F1dG8nLCAnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXSxcbiAgICAgICAgZGZsdDogJ3JpZ2h0JyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1NldHMgdGhlIHVwZGF0ZSBtZW51XFwncyBob3Jpem9udGFsIHBvc2l0aW9uIGFuY2hvci4nLFxuICAgICAgICAgICAgJ1RoaXMgYW5jaG9yIGJpbmRzIHRoZSBgeGAgcG9zaXRpb24gdG8gdGhlICpsZWZ0KiwgKmNlbnRlcionLFxuICAgICAgICAgICAgJ29yICpyaWdodCogb2YgdGhlIHJhbmdlIHNlbGVjdG9yLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgICAgdmFsVHlwZTogJ251bWJlcicsXG4gICAgICAgIG1pbjogLTIsXG4gICAgICAgIG1heDogMyxcbiAgICAgICAgZGZsdDogMSxcbiAgICAgICAgcm9sZTogJ3N0eWxlJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdTZXRzIHRoZSB5IHBvc2l0aW9uIChpbiBub3JtYWxpemVkIGNvb3JkaW5hdGVzKSBvZiB0aGUgdXBkYXRlIG1lbnUuJ1xuICAgIH0sXG4gICAgeWFuY2hvcjoge1xuICAgICAgICB2YWxUeXBlOiAnZW51bWVyYXRlZCcsXG4gICAgICAgIHZhbHVlczogWydhdXRvJywgJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJ10sXG4gICAgICAgIGRmbHQ6ICd0b3AnLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU2V0cyB0aGUgdXBkYXRlIG1lbnVcXCdzIHZlcnRpY2FsIHBvc2l0aW9uIGFuY2hvcicsXG4gICAgICAgICAgICAnVGhpcyBhbmNob3IgYmluZHMgdGhlIGB5YCBwb3NpdGlvbiB0byB0aGUgKnRvcCosICptaWRkbGUqJyxcbiAgICAgICAgICAgICdvciAqYm90dG9tKiBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG5cbiAgICBwYWQ6IGV4dGVuZEZsYXQocGFkQXR0cnMoe2VkaXRUeXBlOiAnYXJyYXlkcmF3J30pLCB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU2V0cyB0aGUgcGFkZGluZyBhcm91bmQgdGhlIGJ1dHRvbnMgb3IgZHJvcGRvd24gbWVudS4nXG4gICAgfSksXG5cbiAgICBmb250OiBmb250QXR0cnMoe1xuICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIGZvbnQgb2YgdGhlIHVwZGF0ZSBtZW51IGJ1dHRvbiB0ZXh0LidcbiAgICB9KSxcblxuICAgIGJnY29sb3I6IHtcbiAgICAgICAgdmFsVHlwZTogJ2NvbG9yJyxcbiAgICAgICAgcm9sZTogJ3N0eWxlJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdTZXRzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSB1cGRhdGUgbWVudSBidXR0b25zLidcbiAgICB9LFxuICAgIGJvcmRlcmNvbG9yOiB7XG4gICAgICAgIHZhbFR5cGU6ICdjb2xvcicsXG4gICAgICAgIGRmbHQ6IGNvbG9yQXR0cnMuYm9yZGVyTGluZSxcbiAgICAgICAgcm9sZTogJ3N0eWxlJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdTZXRzIHRoZSBjb2xvciBvZiB0aGUgYm9yZGVyIGVuY2xvc2luZyB0aGUgdXBkYXRlIG1lbnUuJ1xuICAgIH0sXG4gICAgYm9yZGVyd2lkdGg6IHtcbiAgICAgICAgdmFsVHlwZTogJ251bWJlcicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgZGZsdDogMSxcbiAgICAgICAgcm9sZTogJ3N0eWxlJyxcbiAgICAgICAgZWRpdFR5cGU6ICdhcnJheWRyYXcnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIHdpZHRoIChpbiBweCkgb2YgdGhlIGJvcmRlciBlbmNsb3NpbmcgdGhlIHVwZGF0ZSBtZW51LidcbiAgICB9XG59KSwgJ2FycmF5ZHJhdycsICdmcm9tLXJvb3QnKTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgLy8gbGF5b3V0IGF0dHJpYnV0ZSBuYW1lXG4gICAgbmFtZTogJ3VwZGF0ZW1lbnVzJyxcblxuICAgIC8vIGNsYXNzIG5hbWVzXG4gICAgY29udGFpbmVyQ2xhc3NOYW1lOiAndXBkYXRlbWVudS1jb250YWluZXInLFxuICAgIGhlYWRlckdyb3VwQ2xhc3NOYW1lOiAndXBkYXRlbWVudS1oZWFkZXItZ3JvdXAnLFxuICAgIGhlYWRlckNsYXNzTmFtZTogJ3VwZGF0ZW1lbnUtaGVhZGVyJyxcbiAgICBoZWFkZXJBcnJvd0NsYXNzTmFtZTogJ3VwZGF0ZW1lbnUtaGVhZGVyLWFycm93JyxcbiAgICBkcm9wZG93bkJ1dHRvbkdyb3VwQ2xhc3NOYW1lOiAndXBkYXRlbWVudS1kcm9wZG93bi1idXR0b24tZ3JvdXAnLFxuICAgIGRyb3Bkb3duQnV0dG9uQ2xhc3NOYW1lOiAndXBkYXRlbWVudS1kcm9wZG93bi1idXR0b24nLFxuICAgIGJ1dHRvbkNsYXNzTmFtZTogJ3VwZGF0ZW1lbnUtYnV0dG9uJyxcbiAgICBpdGVtUmVjdENsYXNzTmFtZTogJ3VwZGF0ZW1lbnUtaXRlbS1yZWN0JyxcbiAgICBpdGVtVGV4dENsYXNzTmFtZTogJ3VwZGF0ZW1lbnUtaXRlbS10ZXh0JyxcblxuICAgIC8vIERPTSBhdHRyaWJ1dGUgbmFtZSBpbiBidXR0b24gZ3JvdXAga2VlcGluZyB0cmFja1xuICAgIC8vIG9mIGFjdGl2ZSB1cGRhdGUgbWVudVxuICAgIG1lbnVJbmRleEF0dHJOYW1lOiAndXBkYXRlbWVudS1hY3RpdmUtaW5kZXgnLFxuXG4gICAgLy8gaWQgcm9vdCBwYXNzIHRvIFBsb3RzLmF1dG9NYXJnaW5cbiAgICBhdXRvTWFyZ2luSWRSb290OiAndXBkYXRlbWVudS0nLFxuXG4gICAgLy8gb3B0aW9ucyB3aGVuICdhY3RpdmU6IC0xJ1xuICAgIGJsYW5rSGVhZGVyT3B0czogeyBsYWJlbDogJyAgJyB9LFxuXG4gICAgLy8gbWluIGl0ZW0gd2lkdGggLyBoZWlnaHRcbiAgICBtaW5XaWR0aDogMzAsXG4gICAgbWluSGVpZ2h0OiAzMCxcblxuICAgIC8vIHBhZGRpbmcgYXJvdW5kIGl0ZW0gdGV4dFxuICAgIHRleHRQYWRYOiAyNCxcbiAgICBhcnJvd1BhZFg6IDE2LFxuXG4gICAgLy8gaXRlbSByZWN0IHJhZGlpXG4gICAgcng6IDIsXG4gICAgcnk6IDIsXG5cbiAgICAvLyBpdGVtICB0ZXh0IHggb2Zmc2V0IG9mZiBsZWZ0IGVkZ2VcbiAgICB0ZXh0T2Zmc2V0WDogMTIsXG5cbiAgICAvLyBpdGVtICB0ZXh0IHkgb2Zmc2V0ICh3LnIudC4gbWlkZGxlKVxuICAgIHRleHRPZmZzZXRZOiAzLFxuXG4gICAgLy8gYXJyb3cgb2Zmc2V0IG9mZiByaWdodCBlZGdlXG4gICAgYXJyb3dPZmZzZXRYOiA0LFxuXG4gICAgLy8gZ2FwIGJldHdlZW4gaGVhZGVyIGFuZCBidXR0b25zXG4gICAgZ2FwQnV0dG9uSGVhZGVyOiA1LFxuXG4gICAgLy8gZ2FwIGJldHdlZW4gYmV0d2VlbiBidXR0b25zXG4gICAgZ2FwQnV0dG9uOiAyLFxuXG4gICAgLy8gY29sb3IgZ2l2ZW4gdG8gYWN0aXZlIGJ1dHRvbnNcbiAgICBhY3RpdmVDb2xvcjogJyNGNEZBRkYnLFxuXG4gICAgLy8gY29sb3IgZ2l2ZW4gdG8gaG92ZXJlZCBidXR0b25zXG4gICAgaG92ZXJDb2xvcjogJyNGNEZBRkYnLFxuXG4gICAgLy8gc3ltYm9sIGZvciBtZW51IG9wZW4gYXJyb3dcbiAgICBhcnJvd1N5bWJvbDoge1xuICAgICAgICBsZWZ0OiAn4peEJyxcbiAgICAgICAgcmlnaHQ6ICfilronLFxuICAgICAgICB1cDogJ+KWsicsXG4gICAgICAgIGRvd246ICfilrwnXG4gICAgfVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xudmFyIGhhbmRsZUFycmF5Q29udGFpbmVyRGVmYXVsdHMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9hcnJheV9jb250YWluZXJfZGVmYXVsdHMnKTtcblxudmFyIGF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG52YXIgbmFtZSA9IGNvbnN0YW50cy5uYW1lO1xudmFyIGJ1dHRvbkF0dHJzID0gYXR0cmlidXRlcy5idXR0b25zO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdXBkYXRlTWVudXNEZWZhdWx0cyhsYXlvdXRJbiwgbGF5b3V0T3V0KSB7XG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGhhbmRsZUl0ZW1EZWZhdWx0czogbWVudURlZmF1bHRzXG4gICAgfTtcblxuICAgIGhhbmRsZUFycmF5Q29udGFpbmVyRGVmYXVsdHMobGF5b3V0SW4sIGxheW91dE91dCwgb3B0cyk7XG59O1xuXG5mdW5jdGlvbiBtZW51RGVmYXVsdHMobWVudUluLCBtZW51T3V0LCBsYXlvdXRPdXQpIHtcbiAgICBmdW5jdGlvbiBjb2VyY2UoYXR0ciwgZGZsdCkge1xuICAgICAgICByZXR1cm4gTGliLmNvZXJjZShtZW51SW4sIG1lbnVPdXQsIGF0dHJpYnV0ZXMsIGF0dHIsIGRmbHQpO1xuICAgIH1cblxuICAgIHZhciBidXR0b25zID0gaGFuZGxlQXJyYXlDb250YWluZXJEZWZhdWx0cyhtZW51SW4sIG1lbnVPdXQsIHtcbiAgICAgICAgbmFtZTogJ2J1dHRvbnMnLFxuICAgICAgICBoYW5kbGVJdGVtRGVmYXVsdHM6IGJ1dHRvbkRlZmF1bHRzXG4gICAgfSk7XG5cbiAgICB2YXIgdmlzaWJsZSA9IGNvZXJjZSgndmlzaWJsZScsIGJ1dHRvbnMubGVuZ3RoID4gMCk7XG4gICAgaWYoIXZpc2libGUpIHJldHVybjtcblxuICAgIGNvZXJjZSgnYWN0aXZlJyk7XG4gICAgY29lcmNlKCdkaXJlY3Rpb24nKTtcbiAgICBjb2VyY2UoJ3R5cGUnKTtcbiAgICBjb2VyY2UoJ3Nob3dhY3RpdmUnKTtcblxuICAgIGNvZXJjZSgneCcpO1xuICAgIGNvZXJjZSgneScpO1xuICAgIExpYi5ub25lT3JBbGwobWVudUluLCBtZW51T3V0LCBbJ3gnLCAneSddKTtcblxuICAgIGNvZXJjZSgneGFuY2hvcicpO1xuICAgIGNvZXJjZSgneWFuY2hvcicpO1xuXG4gICAgY29lcmNlKCdwYWQudCcpO1xuICAgIGNvZXJjZSgncGFkLnInKTtcbiAgICBjb2VyY2UoJ3BhZC5iJyk7XG4gICAgY29lcmNlKCdwYWQubCcpO1xuXG4gICAgTGliLmNvZXJjZUZvbnQoY29lcmNlLCAnZm9udCcsIGxheW91dE91dC5mb250KTtcblxuICAgIGNvZXJjZSgnYmdjb2xvcicsIGxheW91dE91dC5wYXBlcl9iZ2NvbG9yKTtcbiAgICBjb2VyY2UoJ2JvcmRlcmNvbG9yJyk7XG4gICAgY29lcmNlKCdib3JkZXJ3aWR0aCcpO1xufVxuXG5mdW5jdGlvbiBidXR0b25EZWZhdWx0cyhidXR0b25JbiwgYnV0dG9uT3V0KSB7XG4gICAgZnVuY3Rpb24gY29lcmNlKGF0dHIsIGRmbHQpIHtcbiAgICAgICAgcmV0dXJuIExpYi5jb2VyY2UoYnV0dG9uSW4sIGJ1dHRvbk91dCwgYnV0dG9uQXR0cnMsIGF0dHIsIGRmbHQpO1xuICAgIH1cblxuICAgIHZhciB2aXNpYmxlID0gY29lcmNlKCd2aXNpYmxlJyxcbiAgICAgICAgKGJ1dHRvbkluLm1ldGhvZCA9PT0gJ3NraXAnIHx8IEFycmF5LmlzQXJyYXkoYnV0dG9uSW4uYXJncykpKTtcbiAgICBpZih2aXNpYmxlKSB7XG4gICAgICAgIGNvZXJjZSgnbWV0aG9kJyk7XG4gICAgICAgIGNvZXJjZSgnYXJncycpO1xuICAgICAgICBjb2VyY2UoJ2FyZ3MyJyk7XG4gICAgICAgIGNvZXJjZSgnbGFiZWwnKTtcbiAgICAgICAgY29lcmNlKCdleGVjdXRlJyk7XG4gICAgfVxufVxuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkMyA9IHJlcXVpcmUoJ2QzJyk7XG5cbnZhciBQbG90cyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL3Bsb3RzJyk7XG52YXIgQ29sb3IgPSByZXF1aXJlKCcuLi9jb2xvcicpO1xudmFyIERyYXdpbmcgPSByZXF1aXJlKCcuLi9kcmF3aW5nJyk7XG52YXIgTGliID0gcmVxdWlyZSgnLi4vLi4vbGliJyk7XG52YXIgc3ZnVGV4dFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vbGliL3N2Z190ZXh0X3V0aWxzJyk7XG52YXIgYXJyYXlFZGl0b3IgPSByZXF1aXJlKCcuLi8uLi9wbG90X2FwaS9wbG90X3RlbXBsYXRlJykuYXJyYXlFZGl0b3I7XG5cbnZhciBMSU5FX1NQQUNJTkcgPSByZXF1aXJlKCcuLi8uLi9jb25zdGFudHMvYWxpZ25tZW50JykuTElORV9TUEFDSU5HO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBTY3JvbGxCb3ggPSByZXF1aXJlKCcuL3Njcm9sbGJveCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRyYXcoZ2QpIHtcbiAgICB2YXIgZnVsbExheW91dCA9IGdkLl9mdWxsTGF5b3V0O1xuICAgIHZhciBtZW51RGF0YSA9IExpYi5maWx0ZXJWaXNpYmxlKGZ1bGxMYXlvdXRbY29uc3RhbnRzLm5hbWVdKTtcblxuICAgIC8qIFVwZGF0ZSBtZW51IGRhdGEgaXMgYm91bmQgdG8gdGhlIGhlYWRlci1ncm91cC5cbiAgICAgKiBUaGUgaXRlbXMgaW4gdGhlIGhlYWRlciBncm91cCBhcmUgYWx3YXlzIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBVcG9uIGNsaWNraW5nIG9uIGEgaGVhZGVyIGl0cyBjb3JyZXNwb25kaW5nIGJ1dHRvblxuICAgICAqIGRhdGEgaXMgYm91bmQgdG8gdGhlIGJ1dHRvbi1ncm91cC5cbiAgICAgKlxuICAgICAqIFdlIGRyYXcgYWxsIGhlYWRlcnMgaW4gb25lIGdyb3VwIGJlZm9yZSBhbGwgYnV0dG9uc1xuICAgICAqIHNvIHRoYXQgdGhlIGJ1dHRvbnMgKmFsd2F5cyogYXBwZWFyIGFib3ZlIHRoZSBoZWFkZXJzLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IG9ubHkgb25lIHNldCBvZiBidXR0b25zIGFyZSB2aXNpYmxlIGF0IG9uY2UuXG4gICAgICpcbiAgICAgKiA8ZyBjb250YWluZXIgLz5cbiAgICAgKlxuICAgICAqICAgICA8ZyBoZWFkZXItZ3JvdXAgLz5cbiAgICAgKiAgICAgICAgIDxnIGl0ZW0gaGVhZGVyIC8+XG4gICAgICogICAgICAgICA8dGV4dCBpdGVtIGhlYWRlci1hcnJvdyAvPlxuICAgICAqICAgICA8ZyBoZWFkZXItZ3JvdXAgLz5cbiAgICAgKiAgICAgICAgIDxnIGl0ZW0gaGVhZGVyIC8+XG4gICAgICogICAgICAgICA8dGV4dCBpdGVtIGhlYWRlci1hcnJvdyAvPlxuICAgICAqICAgICAuLi5cbiAgICAgKlxuICAgICAqICAgICA8ZyBidXR0b24tZ3JvdXAgLz5cbiAgICAgKiAgICAgICAgIDxnIGl0ZW0gYnV0dG9uIC8+XG4gICAgICogICAgICAgICA8ZyBpdGVtIGJ1dHRvbiAvPlxuICAgICAqICAgICAgICAgLi4uXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjbGVhckF1dG9NYXJnaW4obWVudU9wdHMpIHtcbiAgICAgICAgUGxvdHMuYXV0b01hcmdpbihnZCwgYXV0b01hcmdpbklkKG1lbnVPcHRzKSk7XG4gICAgfVxuXG4gICAgLy8gZHJhdyB1cGRhdGUgbWVudSBjb250YWluZXJcbiAgICB2YXIgbWVudXMgPSBmdWxsTGF5b3V0Ll9tZW51bGF5ZXJcbiAgICAgICAgLnNlbGVjdEFsbCgnZy4nICsgY29uc3RhbnRzLmNvbnRhaW5lckNsYXNzTmFtZSlcbiAgICAgICAgLmRhdGEobWVudURhdGEubGVuZ3RoID4gMCA/IFswXSA6IFtdKTtcblxuICAgIG1lbnVzLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgLmNsYXNzZWQoY29uc3RhbnRzLmNvbnRhaW5lckNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgICAgLnN0eWxlKCdjdXJzb3InLCAncG9pbnRlcicpO1xuXG4gICAgbWVudXMuZXhpdCgpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIE1vc3QgY29tcG9uZW50cyBkb24ndCBuZWVkIHRvIGV4cGxpY2l0bHkgcmVtb3ZlIGF1dG9NYXJnaW4sIGJlY2F1c2VcbiAgICAgICAgLy8gbWFyZ2luUHVzaGVycyBkb2VzIHRoaXMgLSBidXQgdXBkYXRlbWVudSB1cGRhdGVzIGRvbid0IGdvIHRocm91Z2hcbiAgICAgICAgLy8gYSBmdWxsIHJlcGxvdCBzbyB3ZSBuZWVkIHRvIGV4cGxpY2l0bHkgcmVtb3ZlIGl0LlxuICAgICAgICAvLyBUaGlzIGlzIGZvciByZW1vdmluZyAqYWxsKiB1cGRhdGVtZW51cywgcmVtb3ZpbmcgaW5kaXZpZHVhbHMgaXNcbiAgICAgICAgLy8gaGFuZGxlZCBiZWxvdywgaW4gaGVhZGVyR3JvdXBzLmV4aXRcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdEFsbCgnZy4nICsgY29uc3RhbnRzLmhlYWRlckdyb3VwQ2xhc3NOYW1lKVxuICAgICAgICAgICAgLmVhY2goY2xlYXJBdXRvTWFyZ2luKTtcbiAgICB9KS5yZW1vdmUoKTtcblxuICAgIC8vIHJldHVybiBlYXJseSBpZiBubyB1cGRhdGUgbWVudXMgYXJlIHZpc2libGVcbiAgICBpZihtZW51RGF0YS5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIC8vIGpvaW4gaGVhZGVyIGdyb3VwXG4gICAgdmFyIGhlYWRlckdyb3VwcyA9IG1lbnVzLnNlbGVjdEFsbCgnZy4nICsgY29uc3RhbnRzLmhlYWRlckdyb3VwQ2xhc3NOYW1lKVxuICAgICAgICAuZGF0YShtZW51RGF0YSwga2V5RnVuY3Rpb24pO1xuXG4gICAgaGVhZGVyR3JvdXBzLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgLmNsYXNzZWQoY29uc3RhbnRzLmhlYWRlckdyb3VwQ2xhc3NOYW1lLCB0cnVlKTtcblxuICAgIC8vIGRyYXcgZHJvcGRvd24gYnV0dG9uIGNvbnRhaW5lclxuICAgIHZhciBnQnV0dG9uID0gTGliLmVuc3VyZVNpbmdsZShtZW51cywgJ2cnLCBjb25zdGFudHMuZHJvcGRvd25CdXR0b25Hcm91cENsYXNzTmFtZSwgZnVuY3Rpb24ocykge1xuICAgICAgICBzLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdhbGwnKTtcbiAgICB9KTtcblxuICAgIC8vIGZpbmQgZGltZW5zaW9ucyBiZWZvcmUgcGxvdHRpbmcgYW55dGhpbmcgKHRoaXMgbXV0YXRlcyBtZW51T3B0cylcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWVudURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG1lbnVPcHRzID0gbWVudURhdGFbaV07XG4gICAgICAgIGZpbmREaW1lbnNpb25zKGdkLCBtZW51T3B0cyk7XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgc2Nyb2xsYm94XG4gICAgdmFyIHNjcm9sbEJveElkID0gJ3VwZGF0ZW1lbnVzJyArIGZ1bGxMYXlvdXQuX3VpZDtcbiAgICB2YXIgc2Nyb2xsQm94ID0gbmV3IFNjcm9sbEJveChnZCwgZ0J1dHRvbiwgc2Nyb2xsQm94SWQpO1xuXG4gICAgLy8gcmVtb3ZlIGV4aXRpbmcgaGVhZGVyLCByZW1vdmUgZHJvcHBlZCBidXR0b25zIGFuZCByZXNldCBtYXJnaW5zXG4gICAgaWYoaGVhZGVyR3JvdXBzLmVudGVyKCkuc2l6ZSgpKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBnQnV0dG9uIGlzIG9uIHRvcCBvZiBhbGwgaGVhZGVyc1xuICAgICAgICBnQnV0dG9uLm5vZGUoKS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGdCdXR0b24ubm9kZSgpKTtcbiAgICAgICAgZ0J1dHRvbi5jYWxsKHJlbW92ZUFsbEJ1dHRvbnMpO1xuICAgIH1cblxuICAgIGhlYWRlckdyb3Vwcy5leGl0KCkuZWFjaChmdW5jdGlvbihtZW51T3B0cykge1xuICAgICAgICBnQnV0dG9uLmNhbGwocmVtb3ZlQWxsQnV0dG9ucyk7XG4gICAgICAgIGNsZWFyQXV0b01hcmdpbihtZW51T3B0cyk7XG4gICAgfSkucmVtb3ZlKCk7XG5cbiAgICAvLyBkcmF3IGhlYWRlcnMhXG4gICAgaGVhZGVyR3JvdXBzLmVhY2goZnVuY3Rpb24obWVudU9wdHMpIHtcbiAgICAgICAgdmFyIGdIZWFkZXIgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgdmFyIF9nQnV0dG9uID0gbWVudU9wdHMudHlwZSA9PT0gJ2Ryb3Bkb3duJyA/IGdCdXR0b24gOiBudWxsO1xuXG4gICAgICAgIFBsb3RzLm1hbmFnZUNvbW1hbmRPYnNlcnZlcihnZCwgbWVudU9wdHMsIG1lbnVPcHRzLmJ1dHRvbnMsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHNldEFjdGl2ZShnZCwgbWVudU9wdHMsIG1lbnVPcHRzLmJ1dHRvbnNbZGF0YS5pbmRleF0sIGdIZWFkZXIsIF9nQnV0dG9uLCBzY3JvbGxCb3gsIGRhdGEuaW5kZXgsIHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZihtZW51T3B0cy50eXBlID09PSAnZHJvcGRvd24nKSB7XG4gICAgICAgICAgICBkcmF3SGVhZGVyKGdkLCBnSGVhZGVyLCBnQnV0dG9uLCBzY3JvbGxCb3gsIG1lbnVPcHRzKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBtZW51IGlzIGFjdGl2ZSwgdXBkYXRlIHRoZSBkcm9wZG93biBjb250YWluZXJcbiAgICAgICAgICAgIGlmKGlzQWN0aXZlKGdCdXR0b24sIG1lbnVPcHRzKSkge1xuICAgICAgICAgICAgICAgIGRyYXdCdXR0b25zKGdkLCBnSGVhZGVyLCBnQnV0dG9uLCBzY3JvbGxCb3gsIG1lbnVPcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRyYXdCdXR0b25zKGdkLCBnSGVhZGVyLCBudWxsLCBudWxsLCBtZW51T3B0cyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8vIE5vdGUgdGhhdCAnX2luZGV4JyBpcyBzZXQgYXQgdGhlIGRlZmF1bHQgc3RlcCxcbi8vIGl0IGNvcnJlc3BvbmRzIHRvIHRoZSBtZW51IGluZGV4IGluIHRoZSB1c2VyIGxheW91dCB1cGRhdGUgbWVudSBjb250YWluZXIuXG4vLyBCZWNhdXNlIGEgbWVudSBjYW4gYmUgc2V0IGludmlzaWJsZSxcbi8vIHRoaXMgaXMgYSBtb3JlICdjb25zaXN0ZW50JyBmaWVsZCB0aGFuIHRoZSBpbmRleCBpbiB0aGUgbWVudURhdGEuXG5mdW5jdGlvbiBrZXlGdW5jdGlvbihtZW51T3B0cykge1xuICAgIHJldHVybiBtZW51T3B0cy5faW5kZXg7XG59XG5cbmZ1bmN0aW9uIGlzRm9sZGVkKGdCdXR0b24pIHtcbiAgICByZXR1cm4gK2dCdXR0b24uYXR0cihjb25zdGFudHMubWVudUluZGV4QXR0ck5hbWUpID09PSAtMTtcbn1cblxuZnVuY3Rpb24gaXNBY3RpdmUoZ0J1dHRvbiwgbWVudU9wdHMpIHtcbiAgICByZXR1cm4gK2dCdXR0b24uYXR0cihjb25zdGFudHMubWVudUluZGV4QXR0ck5hbWUpID09PSBtZW51T3B0cy5faW5kZXg7XG59XG5cbmZ1bmN0aW9uIHNldEFjdGl2ZShnZCwgbWVudU9wdHMsIGJ1dHRvbk9wdHMsIGdIZWFkZXIsIGdCdXR0b24sIHNjcm9sbEJveCwgYnV0dG9uSW5kZXgsIGlzU2lsZW50VXBkYXRlKSB7XG4gICAgLy8gdXBkYXRlICdhY3RpdmUnIGF0dHJpYnV0ZSBpbiBtZW51T3B0c1xuICAgIG1lbnVPcHRzLmFjdGl2ZSA9IGJ1dHRvbkluZGV4O1xuXG4gICAgLy8gZHVlIHRvIHRlbXBsYXRpbmcsIGl0J3MgcG9zc2libGUgdGhpcyBzbGlkZXIgZG9lc24ndCBldmVuIGV4aXN0IHlldFxuICAgIGFycmF5RWRpdG9yKGdkLmxheW91dCwgY29uc3RhbnRzLm5hbWUsIG1lbnVPcHRzKVxuICAgICAgICAuYXBwbHlVcGRhdGUoJ2FjdGl2ZScsIGJ1dHRvbkluZGV4KTtcblxuICAgIGlmKG1lbnVPcHRzLnR5cGUgPT09ICdidXR0b25zJykge1xuICAgICAgICBkcmF3QnV0dG9ucyhnZCwgZ0hlYWRlciwgbnVsbCwgbnVsbCwgbWVudU9wdHMpO1xuICAgIH0gZWxzZSBpZihtZW51T3B0cy50eXBlID09PSAnZHJvcGRvd24nKSB7XG4gICAgICAgIC8vIGZvbGQgdXAgYnV0dG9ucyBhbmQgcmVkcmF3IGhlYWRlclxuICAgICAgICBnQnV0dG9uLmF0dHIoY29uc3RhbnRzLm1lbnVJbmRleEF0dHJOYW1lLCAnLTEnKTtcblxuICAgICAgICBkcmF3SGVhZGVyKGdkLCBnSGVhZGVyLCBnQnV0dG9uLCBzY3JvbGxCb3gsIG1lbnVPcHRzKTtcblxuICAgICAgICBpZighaXNTaWxlbnRVcGRhdGUpIHtcbiAgICAgICAgICAgIGRyYXdCdXR0b25zKGdkLCBnSGVhZGVyLCBnQnV0dG9uLCBzY3JvbGxCb3gsIG1lbnVPcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhd0hlYWRlcihnZCwgZ0hlYWRlciwgZ0J1dHRvbiwgc2Nyb2xsQm94LCBtZW51T3B0cykge1xuICAgIHZhciBoZWFkZXIgPSBMaWIuZW5zdXJlU2luZ2xlKGdIZWFkZXIsICdnJywgY29uc3RhbnRzLmhlYWRlckNsYXNzTmFtZSwgZnVuY3Rpb24ocykge1xuICAgICAgICBzLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdhbGwnKTtcbiAgICB9KTtcblxuICAgIHZhciBkaW1zID0gbWVudU9wdHMuX2RpbXM7XG4gICAgdmFyIGFjdGl2ZSA9IG1lbnVPcHRzLmFjdGl2ZTtcbiAgICB2YXIgaGVhZGVyT3B0cyA9IG1lbnVPcHRzLmJ1dHRvbnNbYWN0aXZlXSB8fCBjb25zdGFudHMuYmxhbmtIZWFkZXJPcHRzO1xuICAgIHZhciBwb3NPcHRzID0geyB5OiBtZW51T3B0cy5wYWQudCwgeVBhZDogMCwgeDogbWVudU9wdHMucGFkLmwsIHhQYWQ6IDAsIGluZGV4OiAwIH07XG4gICAgdmFyIHBvc2l0aW9uT3ZlcnJpZGVzID0ge1xuICAgICAgICB3aWR0aDogZGltcy5oZWFkZXJXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBkaW1zLmhlYWRlckhlaWdodFxuICAgIH07XG5cbiAgICBoZWFkZXJcbiAgICAgICAgLmNhbGwoZHJhd0l0ZW0sIG1lbnVPcHRzLCBoZWFkZXJPcHRzLCBnZClcbiAgICAgICAgLmNhbGwoc2V0SXRlbVBvc2l0aW9uLCBtZW51T3B0cywgcG9zT3B0cywgcG9zaXRpb25PdmVycmlkZXMpO1xuXG4gICAgLy8gZHJhdyBkcm9wIGFycm93IGF0IHRoZSByaWdodCBlZGdlXG4gICAgdmFyIGFycm93ID0gTGliLmVuc3VyZVNpbmdsZShnSGVhZGVyLCAndGV4dCcsIGNvbnN0YW50cy5oZWFkZXJBcnJvd0NsYXNzTmFtZSwgZnVuY3Rpb24ocykge1xuICAgICAgICBzLmNsYXNzZWQoJ3VzZXItc2VsZWN0LW5vbmUnLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAuY2FsbChEcmF3aW5nLmZvbnQsIG1lbnVPcHRzLmZvbnQpXG4gICAgICAgICAgICAudGV4dChjb25zdGFudHMuYXJyb3dTeW1ib2xbbWVudU9wdHMuZGlyZWN0aW9uXSk7XG4gICAgfSk7XG5cbiAgICBhcnJvdy5hdHRyKHtcbiAgICAgICAgeDogZGltcy5oZWFkZXJXaWR0aCAtIGNvbnN0YW50cy5hcnJvd09mZnNldFggKyBtZW51T3B0cy5wYWQubCxcbiAgICAgICAgeTogZGltcy5oZWFkZXJIZWlnaHQgLyAyICsgY29uc3RhbnRzLnRleHRPZmZzZXRZICsgbWVudU9wdHMucGFkLnRcbiAgICB9KTtcblxuICAgIGhlYWRlci5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZ0J1dHRvbi5jYWxsKHJlbW92ZUFsbEJ1dHRvbnMsXG4gICAgICAgICAgICBTdHJpbmcoaXNBY3RpdmUoZ0J1dHRvbiwgbWVudU9wdHMpID8gLTEgOiBtZW51T3B0cy5faW5kZXgpXG4gICAgICAgICk7XG5cbiAgICAgICAgZHJhd0J1dHRvbnMoZ2QsIGdIZWFkZXIsIGdCdXR0b24sIHNjcm9sbEJveCwgbWVudU9wdHMpO1xuICAgIH0pO1xuXG4gICAgaGVhZGVyLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaGVhZGVyLmNhbGwoc3R5bGVPbk1vdXNlT3Zlcik7XG4gICAgfSk7XG5cbiAgICBoZWFkZXIub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGhlYWRlci5jYWxsKHN0eWxlT25Nb3VzZU91dCwgbWVudU9wdHMpO1xuICAgIH0pO1xuXG4gICAgLy8gdHJhbnNsYXRlIGhlYWRlciBncm91cFxuICAgIERyYXdpbmcuc2V0VHJhbnNsYXRlKGdIZWFkZXIsIGRpbXMubHgsIGRpbXMubHkpO1xufVxuXG5mdW5jdGlvbiBkcmF3QnV0dG9ucyhnZCwgZ0hlYWRlciwgZ0J1dHRvbiwgc2Nyb2xsQm94LCBtZW51T3B0cykge1xuICAgIC8vIElmIHRoaXMgaXMgYSBzZXQgb2YgYnV0dG9ucywgc2V0IHBvaW50ZXIgZXZlbnRzID0gYWxsIHNpbmNlIHdlIHBsYXlcbiAgICAvLyBzb21lIG1pbm9yIGdhbWVzIHdpdGggd2hpY2ggY29udGFpbmVyIGlzIHdoaWNoIGluIG9yZGVyIHRvIHNpbXBsaWZ5XG4gICAgLy8gdGhlIGRyYXdpbmcgb2YgKmVpdGhlciogYnV0dG9ucyBvciBtZW51c1xuICAgIGlmKCFnQnV0dG9uKSB7XG4gICAgICAgIGdCdXR0b24gPSBnSGVhZGVyO1xuICAgICAgICBnQnV0dG9uLmF0dHIoJ3BvaW50ZXItZXZlbnRzJywgJ2FsbCcpO1xuICAgIH1cblxuICAgIHZhciBidXR0b25EYXRhID0gKCFpc0ZvbGRlZChnQnV0dG9uKSB8fCBtZW51T3B0cy50eXBlID09PSAnYnV0dG9ucycpID9cbiAgICAgICAgbWVudU9wdHMuYnV0dG9ucyA6XG4gICAgICAgIFtdO1xuXG4gICAgdmFyIGtsYXNzID0gbWVudU9wdHMudHlwZSA9PT0gJ2Ryb3Bkb3duJyA/IGNvbnN0YW50cy5kcm9wZG93bkJ1dHRvbkNsYXNzTmFtZSA6IGNvbnN0YW50cy5idXR0b25DbGFzc05hbWU7XG5cbiAgICB2YXIgYnV0dG9ucyA9IGdCdXR0b24uc2VsZWN0QWxsKCdnLicgKyBrbGFzcylcbiAgICAgICAgLmRhdGEoTGliLmZpbHRlclZpc2libGUoYnV0dG9uRGF0YSkpO1xuXG4gICAgdmFyIGVudGVyID0gYnV0dG9ucy5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgIC5jbGFzc2VkKGtsYXNzLCB0cnVlKTtcblxuICAgIHZhciBleGl0ID0gYnV0dG9ucy5leGl0KCk7XG5cbiAgICBpZihtZW51T3B0cy50eXBlID09PSAnZHJvcGRvd24nKSB7XG4gICAgICAgIGVudGVyLmF0dHIoJ29wYWNpdHknLCAnMCcpXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cignb3BhY2l0eScsICcxJyk7XG5cbiAgICAgICAgZXhpdC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgJzAnKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXQucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgdmFyIHgwID0gMDtcbiAgICB2YXIgeTAgPSAwO1xuICAgIHZhciBkaW1zID0gbWVudU9wdHMuX2RpbXM7XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndXAnLCAnZG93biddLmluZGV4T2YobWVudU9wdHMuZGlyZWN0aW9uKSAhPT0gLTE7XG5cbiAgICBpZihtZW51T3B0cy50eXBlID09PSAnZHJvcGRvd24nKSB7XG4gICAgICAgIGlmKGlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIHkwID0gZGltcy5oZWFkZXJIZWlnaHQgKyBjb25zdGFudHMuZ2FwQnV0dG9uSGVhZGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeDAgPSBkaW1zLmhlYWRlcldpZHRoICsgY29uc3RhbnRzLmdhcEJ1dHRvbkhlYWRlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKG1lbnVPcHRzLnR5cGUgPT09ICdkcm9wZG93bicgJiYgbWVudU9wdHMuZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgICAgIHkwID0gLWNvbnN0YW50cy5nYXBCdXR0b25IZWFkZXIgKyBjb25zdGFudHMuZ2FwQnV0dG9uIC0gZGltcy5vcGVuSGVpZ2h0O1xuICAgIH1cblxuICAgIGlmKG1lbnVPcHRzLnR5cGUgPT09ICdkcm9wZG93bicgJiYgbWVudU9wdHMuZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDAgPSAtY29uc3RhbnRzLmdhcEJ1dHRvbkhlYWRlciArIGNvbnN0YW50cy5nYXBCdXR0b24gLSBkaW1zLm9wZW5XaWR0aDtcbiAgICB9XG5cbiAgICB2YXIgcG9zT3B0cyA9IHtcbiAgICAgICAgeDogZGltcy5seCArIHgwICsgbWVudU9wdHMucGFkLmwsXG4gICAgICAgIHk6IGRpbXMubHkgKyB5MCArIG1lbnVPcHRzLnBhZC50LFxuICAgICAgICB5UGFkOiBjb25zdGFudHMuZ2FwQnV0dG9uLFxuICAgICAgICB4UGFkOiBjb25zdGFudHMuZ2FwQnV0dG9uLFxuICAgICAgICBpbmRleDogMCxcbiAgICB9O1xuXG4gICAgdmFyIHNjcm9sbEJveFBvc2l0aW9uID0ge1xuICAgICAgICBsOiBwb3NPcHRzLnggKyBtZW51T3B0cy5ib3JkZXJ3aWR0aCxcbiAgICAgICAgdDogcG9zT3B0cy55ICsgbWVudU9wdHMuYm9yZGVyd2lkdGhcbiAgICB9O1xuXG4gICAgYnV0dG9ucy5lYWNoKGZ1bmN0aW9uKGJ1dHRvbk9wdHMsIGJ1dHRvbkluZGV4KSB7XG4gICAgICAgIHZhciBidXR0b24gPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgYnV0dG9uXG4gICAgICAgICAgICAuY2FsbChkcmF3SXRlbSwgbWVudU9wdHMsIGJ1dHRvbk9wdHMsIGdkKVxuICAgICAgICAgICAgLmNhbGwoc2V0SXRlbVBvc2l0aW9uLCBtZW51T3B0cywgcG9zT3B0cyk7XG5cbiAgICAgICAgYnV0dG9uLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gc2tpcCBgZHJhZ2VuZGAgZXZlbnRzXG4gICAgICAgICAgICBpZihkMy5ldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmKGJ1dHRvbk9wdHMuZXhlY3V0ZSkge1xuICAgICAgICAgICAgICAgIGlmKGJ1dHRvbk9wdHMuYXJnczIgJiYgbWVudU9wdHMuYWN0aXZlID09PSBidXR0b25JbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmUoZ2QsIG1lbnVPcHRzLCBidXR0b25PcHRzLCBnSGVhZGVyLCBnQnV0dG9uLCBzY3JvbGxCb3gsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgUGxvdHMuZXhlY3V0ZUFQSUNvbW1hbmQoZ2QsIGJ1dHRvbk9wdHMubWV0aG9kLCBidXR0b25PcHRzLmFyZ3MyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmUoZ2QsIG1lbnVPcHRzLCBidXR0b25PcHRzLCBnSGVhZGVyLCBnQnV0dG9uLCBzY3JvbGxCb3gsIGJ1dHRvbkluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgUGxvdHMuZXhlY3V0ZUFQSUNvbW1hbmQoZ2QsIGJ1dHRvbk9wdHMubWV0aG9kLCBidXR0b25PcHRzLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2QuZW1pdCgncGxvdGx5X2J1dHRvbmNsaWNrZWQnLCB7bWVudTogbWVudU9wdHMsIGJ1dHRvbjogYnV0dG9uT3B0cywgYWN0aXZlOiBtZW51T3B0cy5hY3RpdmV9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYnV0dG9uLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGJ1dHRvbi5jYWxsKHN0eWxlT25Nb3VzZU92ZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBidXR0b24ub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBidXR0b24uY2FsbChzdHlsZU9uTW91c2VPdXQsIG1lbnVPcHRzKTtcbiAgICAgICAgICAgIGJ1dHRvbnMuY2FsbChzdHlsZUJ1dHRvbnMsIG1lbnVPcHRzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBidXR0b25zLmNhbGwoc3R5bGVCdXR0b25zLCBtZW51T3B0cyk7XG5cbiAgICBpZihpc1ZlcnRpY2FsKSB7XG4gICAgICAgIHNjcm9sbEJveFBvc2l0aW9uLncgPSBNYXRoLm1heChkaW1zLm9wZW5XaWR0aCwgZGltcy5oZWFkZXJXaWR0aCk7XG4gICAgICAgIHNjcm9sbEJveFBvc2l0aW9uLmggPSBwb3NPcHRzLnkgLSBzY3JvbGxCb3hQb3NpdGlvbi50O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcm9sbEJveFBvc2l0aW9uLncgPSBwb3NPcHRzLnggLSBzY3JvbGxCb3hQb3NpdGlvbi5sO1xuICAgICAgICBzY3JvbGxCb3hQb3NpdGlvbi5oID0gTWF0aC5tYXgoZGltcy5vcGVuSGVpZ2h0LCBkaW1zLmhlYWRlckhlaWdodCk7XG4gICAgfVxuXG4gICAgc2Nyb2xsQm94UG9zaXRpb24uZGlyZWN0aW9uID0gbWVudU9wdHMuZGlyZWN0aW9uO1xuXG4gICAgaWYoc2Nyb2xsQm94KSB7XG4gICAgICAgIGlmKGJ1dHRvbnMuc2l6ZSgpKSB7XG4gICAgICAgICAgICBkcmF3U2Nyb2xsQm94KGdkLCBnSGVhZGVyLCBnQnV0dG9uLCBzY3JvbGxCb3gsIG1lbnVPcHRzLCBzY3JvbGxCb3hQb3NpdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWRlU2Nyb2xsQm94KHNjcm9sbEJveCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdTY3JvbGxCb3goZ2QsIGdIZWFkZXIsIGdCdXR0b24sIHNjcm9sbEJveCwgbWVudU9wdHMsIHBvc2l0aW9uKSB7XG4gICAgLy8gZW5hYmxlIHRoZSBzY3JvbGxib3hcbiAgICB2YXIgZGlyZWN0aW9uID0gbWVudU9wdHMuZGlyZWN0aW9uO1xuICAgIHZhciBpc1ZlcnRpY2FsID0gKGRpcmVjdGlvbiA9PT0gJ3VwJyB8fCBkaXJlY3Rpb24gPT09ICdkb3duJyk7XG4gICAgdmFyIGRpbXMgPSBtZW51T3B0cy5fZGltcztcblxuICAgIHZhciBhY3RpdmUgPSBtZW51T3B0cy5hY3RpdmU7XG4gICAgdmFyIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVk7XG4gICAgdmFyIGk7XG4gICAgaWYoaXNWZXJ0aWNhbCkge1xuICAgICAgICB0cmFuc2xhdGVZID0gMDtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgYWN0aXZlOyBpKyspIHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZVkgKz0gZGltcy5oZWlnaHRzW2ldICsgY29uc3RhbnRzLmdhcEJ1dHRvbjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zbGF0ZVggPSAwO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBhY3RpdmU7IGkrKykge1xuICAgICAgICAgICAgdHJhbnNsYXRlWCArPSBkaW1zLndpZHRoc1tpXSArIGNvbnN0YW50cy5nYXBCdXR0b247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzY3JvbGxCb3guZW5hYmxlKHBvc2l0aW9uLCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZKTtcblxuICAgIGlmKHNjcm9sbEJveC5oYmFyKSB7XG4gICAgICAgIHNjcm9sbEJveC5oYmFyXG4gICAgICAgICAgICAuYXR0cignb3BhY2l0eScsICcwJylcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgJzEnKTtcbiAgICB9XG5cbiAgICBpZihzY3JvbGxCb3gudmJhcikge1xuICAgICAgICBzY3JvbGxCb3gudmJhclxuICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAnMCcpXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cignb3BhY2l0eScsICcxJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoaWRlU2Nyb2xsQm94KHNjcm9sbEJveCkge1xuICAgIHZhciBoYXNIQmFyID0gISFzY3JvbGxCb3guaGJhcjtcbiAgICB2YXIgaGFzVkJhciA9ICEhc2Nyb2xsQm94LnZiYXI7XG5cbiAgICBpZihoYXNIQmFyKSB7XG4gICAgICAgIHNjcm9sbEJveC5oYmFyXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cignb3BhY2l0eScsICcwJylcbiAgICAgICAgICAgIC5lYWNoKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBoYXNIQmFyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYoIWhhc1ZCYXIpIHNjcm9sbEJveC5kaXNhYmxlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZihoYXNWQmFyKSB7XG4gICAgICAgIHNjcm9sbEJveC52YmFyXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cignb3BhY2l0eScsICcwJylcbiAgICAgICAgICAgIC5lYWNoKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBoYXNWQmFyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYoIWhhc0hCYXIpIHNjcm9sbEJveC5kaXNhYmxlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdJdGVtKGl0ZW0sIG1lbnVPcHRzLCBpdGVtT3B0cywgZ2QpIHtcbiAgICBpdGVtLmNhbGwoZHJhd0l0ZW1SZWN0LCBtZW51T3B0cylcbiAgICAgICAgLmNhbGwoZHJhd0l0ZW1UZXh0LCBtZW51T3B0cywgaXRlbU9wdHMsIGdkKTtcbn1cblxuZnVuY3Rpb24gZHJhd0l0ZW1SZWN0KGl0ZW0sIG1lbnVPcHRzKSB7XG4gICAgdmFyIHJlY3QgPSBMaWIuZW5zdXJlU2luZ2xlKGl0ZW0sICdyZWN0JywgY29uc3RhbnRzLml0ZW1SZWN0Q2xhc3NOYW1lLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHMuYXR0cih7XG4gICAgICAgICAgICByeDogY29uc3RhbnRzLnJ4LFxuICAgICAgICAgICAgcnk6IGNvbnN0YW50cy5yeSxcbiAgICAgICAgICAgICdzaGFwZS1yZW5kZXJpbmcnOiAnY3Jpc3BFZGdlcydcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZWN0LmNhbGwoQ29sb3Iuc3Ryb2tlLCBtZW51T3B0cy5ib3JkZXJjb2xvcilcbiAgICAgICAgLmNhbGwoQ29sb3IuZmlsbCwgbWVudU9wdHMuYmdjb2xvcilcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBtZW51T3B0cy5ib3JkZXJ3aWR0aCArICdweCcpO1xufVxuXG5mdW5jdGlvbiBkcmF3SXRlbVRleHQoaXRlbSwgbWVudU9wdHMsIGl0ZW1PcHRzLCBnZCkge1xuICAgIHZhciB0ZXh0ID0gTGliLmVuc3VyZVNpbmdsZShpdGVtLCAndGV4dCcsIGNvbnN0YW50cy5pdGVtVGV4dENsYXNzTmFtZSwgZnVuY3Rpb24ocykge1xuICAgICAgICBzLmNsYXNzZWQoJ3VzZXItc2VsZWN0LW5vbmUnLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgICAgICd0ZXh0LWFuY2hvcic6ICdzdGFydCcsXG4gICAgICAgICAgICAgICAgJ2RhdGEtbm90ZXgnOiAxXG4gICAgICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciB0eCA9IGl0ZW1PcHRzLmxhYmVsO1xuICAgIHZhciBfbWV0YSA9IGdkLl9mdWxsTGF5b3V0Ll9tZXRhO1xuICAgIGlmKF9tZXRhKSB0eCA9IExpYi50ZW1wbGF0ZVN0cmluZyh0eCwgX21ldGEpO1xuXG4gICAgdGV4dC5jYWxsKERyYXdpbmcuZm9udCwgbWVudU9wdHMuZm9udClcbiAgICAgICAgLnRleHQodHgpXG4gICAgICAgIC5jYWxsKHN2Z1RleHRVdGlscy5jb252ZXJ0VG9Uc3BhbnMsIGdkKTtcbn1cblxuZnVuY3Rpb24gc3R5bGVCdXR0b25zKGJ1dHRvbnMsIG1lbnVPcHRzKSB7XG4gICAgdmFyIGFjdGl2ZSA9IG1lbnVPcHRzLmFjdGl2ZTtcblxuICAgIGJ1dHRvbnMuZWFjaChmdW5jdGlvbihidXR0b25PcHRzLCBpKSB7XG4gICAgICAgIHZhciBidXR0b24gPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgaWYoaSA9PT0gYWN0aXZlICYmIG1lbnVPcHRzLnNob3dhY3RpdmUpIHtcbiAgICAgICAgICAgIGJ1dHRvbi5zZWxlY3QoJ3JlY3QuJyArIGNvbnN0YW50cy5pdGVtUmVjdENsYXNzTmFtZSlcbiAgICAgICAgICAgICAgICAuY2FsbChDb2xvci5maWxsLCBjb25zdGFudHMuYWN0aXZlQ29sb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHN0eWxlT25Nb3VzZU92ZXIoaXRlbSkge1xuICAgIGl0ZW0uc2VsZWN0KCdyZWN0LicgKyBjb25zdGFudHMuaXRlbVJlY3RDbGFzc05hbWUpXG4gICAgICAgIC5jYWxsKENvbG9yLmZpbGwsIGNvbnN0YW50cy5ob3ZlckNvbG9yKTtcbn1cblxuZnVuY3Rpb24gc3R5bGVPbk1vdXNlT3V0KGl0ZW0sIG1lbnVPcHRzKSB7XG4gICAgaXRlbS5zZWxlY3QoJ3JlY3QuJyArIGNvbnN0YW50cy5pdGVtUmVjdENsYXNzTmFtZSlcbiAgICAgICAgLmNhbGwoQ29sb3IuZmlsbCwgbWVudU9wdHMuYmdjb2xvcik7XG59XG5cbi8vIGZpbmQgaXRlbSBkaW1lbnNpb25zICh0aGlzIG11dGF0ZXMgbWVudU9wdHMpXG5mdW5jdGlvbiBmaW5kRGltZW5zaW9ucyhnZCwgbWVudU9wdHMpIHtcbiAgICB2YXIgZGltcyA9IG1lbnVPcHRzLl9kaW1zID0ge1xuICAgICAgICB3aWR0aDE6IDAsXG4gICAgICAgIGhlaWdodDE6IDAsXG4gICAgICAgIGhlaWdodHM6IFtdLFxuICAgICAgICB3aWR0aHM6IFtdLFxuICAgICAgICB0b3RhbFdpZHRoOiAwLFxuICAgICAgICB0b3RhbEhlaWdodDogMCxcbiAgICAgICAgb3BlbldpZHRoOiAwLFxuICAgICAgICBvcGVuSGVpZ2h0OiAwLFxuICAgICAgICBseDogMCxcbiAgICAgICAgbHk6IDBcbiAgICB9O1xuXG4gICAgdmFyIGZha2VCdXR0b25zID0gRHJhd2luZy50ZXN0ZXIuc2VsZWN0QWxsKCdnLicgKyBjb25zdGFudHMuZHJvcGRvd25CdXR0b25DbGFzc05hbWUpXG4gICAgICAgIC5kYXRhKExpYi5maWx0ZXJWaXNpYmxlKG1lbnVPcHRzLmJ1dHRvbnMpKTtcblxuICAgIGZha2VCdXR0b25zLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgLmNsYXNzZWQoY29uc3RhbnRzLmRyb3Bkb3duQnV0dG9uQ2xhc3NOYW1lLCB0cnVlKTtcblxuICAgIHZhciBpc1ZlcnRpY2FsID0gWyd1cCcsICdkb3duJ10uaW5kZXhPZihtZW51T3B0cy5kaXJlY3Rpb24pICE9PSAtMTtcblxuICAgIC8vIGxvb3Agb3ZlciBmYWtlIGJ1dHRvbnMgdG8gZmluZCB3aWR0aCAvIGhlaWdodFxuICAgIGZha2VCdXR0b25zLmVhY2goZnVuY3Rpb24oYnV0dG9uT3B0cywgaSkge1xuICAgICAgICB2YXIgYnV0dG9uID0gZDMuc2VsZWN0KHRoaXMpO1xuXG4gICAgICAgIGJ1dHRvbi5jYWxsKGRyYXdJdGVtLCBtZW51T3B0cywgYnV0dG9uT3B0cywgZ2QpO1xuXG4gICAgICAgIHZhciB0ZXh0ID0gYnV0dG9uLnNlbGVjdCgnLicgKyBjb25zdGFudHMuaXRlbVRleHRDbGFzc05hbWUpO1xuXG4gICAgICAgIC8vIHdpZHRoIGlzIGdpdmVuIGJ5IG1heCB3aWR0aCBvZiBhbGwgYnV0dG9uc1xuICAgICAgICB2YXIgdFdpZHRoID0gdGV4dC5ub2RlKCkgJiYgRHJhd2luZy5iQm94KHRleHQubm9kZSgpKS53aWR0aDtcbiAgICAgICAgdmFyIHdFZmYgPSBNYXRoLm1heCh0V2lkdGggKyBjb25zdGFudHMudGV4dFBhZFgsIGNvbnN0YW50cy5taW5XaWR0aCk7XG5cbiAgICAgICAgLy8gaGVpZ2h0IGlzIGRldGVybWluZWQgYnkgaXRlbSB0ZXh0XG4gICAgICAgIHZhciB0SGVpZ2h0ID0gbWVudU9wdHMuZm9udC5zaXplICogTElORV9TUEFDSU5HO1xuICAgICAgICB2YXIgdExpbmVzID0gc3ZnVGV4dFV0aWxzLmxpbmVDb3VudCh0ZXh0KTtcbiAgICAgICAgdmFyIGhFZmYgPSBNYXRoLm1heCh0SGVpZ2h0ICogdExpbmVzLCBjb25zdGFudHMubWluSGVpZ2h0KSArIGNvbnN0YW50cy50ZXh0T2Zmc2V0WTtcblxuICAgICAgICBoRWZmID0gTWF0aC5jZWlsKGhFZmYpO1xuICAgICAgICB3RWZmID0gTWF0aC5jZWlsKHdFZmYpO1xuXG4gICAgICAgIC8vIFN0b3JlIHBlci1pdGVtIHNpemVzIHNpbmNlIGEgcm93IG9mIGhvcml6b250YWwgYnV0dG9ucywgZm9yIGV4YW1wbGUsXG4gICAgICAgIC8vIGRvbid0IGFsbCBuZWVkIHRvIGJlIHRoZSBzYW1lIHdpZHRoOlxuICAgICAgICBkaW1zLndpZHRoc1tpXSA9IHdFZmY7XG4gICAgICAgIGRpbXMuaGVpZ2h0c1tpXSA9IGhFZmY7XG5cbiAgICAgICAgLy8gSGVpZ2h0IGFuZCB3aWR0aCBvZiBpbmRpdmlkdWFsIGVsZW1lbnQ6XG4gICAgICAgIGRpbXMuaGVpZ2h0MSA9IE1hdGgubWF4KGRpbXMuaGVpZ2h0MSwgaEVmZik7XG4gICAgICAgIGRpbXMud2lkdGgxID0gTWF0aC5tYXgoZGltcy53aWR0aDEsIHdFZmYpO1xuXG4gICAgICAgIGlmKGlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIGRpbXMudG90YWxXaWR0aCA9IE1hdGgubWF4KGRpbXMudG90YWxXaWR0aCwgd0VmZik7XG4gICAgICAgICAgICBkaW1zLm9wZW5XaWR0aCA9IGRpbXMudG90YWxXaWR0aDtcbiAgICAgICAgICAgIGRpbXMudG90YWxIZWlnaHQgKz0gaEVmZiArIGNvbnN0YW50cy5nYXBCdXR0b247XG4gICAgICAgICAgICBkaW1zLm9wZW5IZWlnaHQgKz0gaEVmZiArIGNvbnN0YW50cy5nYXBCdXR0b247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaW1zLnRvdGFsV2lkdGggKz0gd0VmZiArIGNvbnN0YW50cy5nYXBCdXR0b247XG4gICAgICAgICAgICBkaW1zLm9wZW5XaWR0aCArPSB3RWZmICsgY29uc3RhbnRzLmdhcEJ1dHRvbjtcbiAgICAgICAgICAgIGRpbXMudG90YWxIZWlnaHQgPSBNYXRoLm1heChkaW1zLnRvdGFsSGVpZ2h0LCBoRWZmKTtcbiAgICAgICAgICAgIGRpbXMub3BlbkhlaWdodCA9IGRpbXMudG90YWxIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmKGlzVmVydGljYWwpIHtcbiAgICAgICAgZGltcy50b3RhbEhlaWdodCAtPSBjb25zdGFudHMuZ2FwQnV0dG9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRpbXMudG90YWxXaWR0aCAtPSBjb25zdGFudHMuZ2FwQnV0dG9uO1xuICAgIH1cblxuXG4gICAgZGltcy5oZWFkZXJXaWR0aCA9IGRpbXMud2lkdGgxICsgY29uc3RhbnRzLmFycm93UGFkWDtcbiAgICBkaW1zLmhlYWRlckhlaWdodCA9IGRpbXMuaGVpZ2h0MTtcblxuICAgIGlmKG1lbnVPcHRzLnR5cGUgPT09ICdkcm9wZG93bicpIHtcbiAgICAgICAgaWYoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgZGltcy53aWR0aDEgKz0gY29uc3RhbnRzLmFycm93UGFkWDtcbiAgICAgICAgICAgIGRpbXMudG90YWxIZWlnaHQgPSBkaW1zLmhlaWdodDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaW1zLnRvdGFsV2lkdGggPSBkaW1zLndpZHRoMTtcbiAgICAgICAgfVxuICAgICAgICBkaW1zLnRvdGFsV2lkdGggKz0gY29uc3RhbnRzLmFycm93UGFkWDtcbiAgICB9XG5cbiAgICBmYWtlQnV0dG9ucy5yZW1vdmUoKTtcblxuICAgIHZhciBwYWRkZWRXaWR0aCA9IGRpbXMudG90YWxXaWR0aCArIG1lbnVPcHRzLnBhZC5sICsgbWVudU9wdHMucGFkLnI7XG4gICAgdmFyIHBhZGRlZEhlaWdodCA9IGRpbXMudG90YWxIZWlnaHQgKyBtZW51T3B0cy5wYWQudCArIG1lbnVPcHRzLnBhZC5iO1xuXG4gICAgdmFyIGdyYXBoU2l6ZSA9IGdkLl9mdWxsTGF5b3V0Ll9zaXplO1xuICAgIGRpbXMubHggPSBncmFwaFNpemUubCArIGdyYXBoU2l6ZS53ICogbWVudU9wdHMueDtcbiAgICBkaW1zLmx5ID0gZ3JhcGhTaXplLnQgKyBncmFwaFNpemUuaCAqICgxIC0gbWVudU9wdHMueSk7XG5cbiAgICB2YXIgeGFuY2hvciA9ICdsZWZ0JztcbiAgICBpZihMaWIuaXNSaWdodEFuY2hvcihtZW51T3B0cykpIHtcbiAgICAgICAgZGltcy5seCAtPSBwYWRkZWRXaWR0aDtcbiAgICAgICAgeGFuY2hvciA9ICdyaWdodCc7XG4gICAgfVxuICAgIGlmKExpYi5pc0NlbnRlckFuY2hvcihtZW51T3B0cykpIHtcbiAgICAgICAgZGltcy5seCAtPSBwYWRkZWRXaWR0aCAvIDI7XG4gICAgICAgIHhhbmNob3IgPSAnY2VudGVyJztcbiAgICB9XG5cbiAgICB2YXIgeWFuY2hvciA9ICd0b3AnO1xuICAgIGlmKExpYi5pc0JvdHRvbUFuY2hvcihtZW51T3B0cykpIHtcbiAgICAgICAgZGltcy5seSAtPSBwYWRkZWRIZWlnaHQ7XG4gICAgICAgIHlhbmNob3IgPSAnYm90dG9tJztcbiAgICB9XG4gICAgaWYoTGliLmlzTWlkZGxlQW5jaG9yKG1lbnVPcHRzKSkge1xuICAgICAgICBkaW1zLmx5IC09IHBhZGRlZEhlaWdodCAvIDI7XG4gICAgICAgIHlhbmNob3IgPSAnbWlkZGxlJztcbiAgICB9XG5cbiAgICBkaW1zLnRvdGFsV2lkdGggPSBNYXRoLmNlaWwoZGltcy50b3RhbFdpZHRoKTtcbiAgICBkaW1zLnRvdGFsSGVpZ2h0ID0gTWF0aC5jZWlsKGRpbXMudG90YWxIZWlnaHQpO1xuICAgIGRpbXMubHggPSBNYXRoLnJvdW5kKGRpbXMubHgpO1xuICAgIGRpbXMubHkgPSBNYXRoLnJvdW5kKGRpbXMubHkpO1xuXG4gICAgUGxvdHMuYXV0b01hcmdpbihnZCwgYXV0b01hcmdpbklkKG1lbnVPcHRzKSwge1xuICAgICAgICB4OiBtZW51T3B0cy54LFxuICAgICAgICB5OiBtZW51T3B0cy55LFxuICAgICAgICBsOiBwYWRkZWRXaWR0aCAqICh7cmlnaHQ6IDEsIGNlbnRlcjogMC41fVt4YW5jaG9yXSB8fCAwKSxcbiAgICAgICAgcjogcGFkZGVkV2lkdGggKiAoe2xlZnQ6IDEsIGNlbnRlcjogMC41fVt4YW5jaG9yXSB8fCAwKSxcbiAgICAgICAgYjogcGFkZGVkSGVpZ2h0ICogKHt0b3A6IDEsIG1pZGRsZTogMC41fVt5YW5jaG9yXSB8fCAwKSxcbiAgICAgICAgdDogcGFkZGVkSGVpZ2h0ICogKHtib3R0b206IDEsIG1pZGRsZTogMC41fVt5YW5jaG9yXSB8fCAwKVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBhdXRvTWFyZ2luSWQobWVudU9wdHMpIHtcbiAgICByZXR1cm4gY29uc3RhbnRzLmF1dG9NYXJnaW5JZFJvb3QgKyBtZW51T3B0cy5faW5kZXg7XG59XG5cbi8vIHNldCBpdGVtIHBvc2l0aW9ucyAobXV0YXRlcyBwb3NPcHRzKVxuZnVuY3Rpb24gc2V0SXRlbVBvc2l0aW9uKGl0ZW0sIG1lbnVPcHRzLCBwb3NPcHRzLCBvdmVycmlkZU9wdHMpIHtcbiAgICBvdmVycmlkZU9wdHMgPSBvdmVycmlkZU9wdHMgfHwge307XG4gICAgdmFyIHJlY3QgPSBpdGVtLnNlbGVjdCgnLicgKyBjb25zdGFudHMuaXRlbVJlY3RDbGFzc05hbWUpO1xuICAgIHZhciB0ZXh0ID0gaXRlbS5zZWxlY3QoJy4nICsgY29uc3RhbnRzLml0ZW1UZXh0Q2xhc3NOYW1lKTtcbiAgICB2YXIgYm9yZGVyV2lkdGggPSBtZW51T3B0cy5ib3JkZXJ3aWR0aDtcbiAgICB2YXIgaW5kZXggPSBwb3NPcHRzLmluZGV4O1xuICAgIHZhciBkaW1zID0gbWVudU9wdHMuX2RpbXM7XG5cbiAgICBEcmF3aW5nLnNldFRyYW5zbGF0ZShpdGVtLCBib3JkZXJXaWR0aCArIHBvc09wdHMueCwgYm9yZGVyV2lkdGggKyBwb3NPcHRzLnkpO1xuXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ3VwJywgJ2Rvd24nXS5pbmRleE9mKG1lbnVPcHRzLmRpcmVjdGlvbikgIT09IC0xO1xuICAgIHZhciBmaW5hbEhlaWdodCA9IG92ZXJyaWRlT3B0cy5oZWlnaHQgfHwgKGlzVmVydGljYWwgPyBkaW1zLmhlaWdodHNbaW5kZXhdIDogZGltcy5oZWlnaHQxKTtcblxuICAgIHJlY3QuYXR0cih7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiBvdmVycmlkZU9wdHMud2lkdGggfHwgKGlzVmVydGljYWwgPyBkaW1zLndpZHRoMSA6IGRpbXMud2lkdGhzW2luZGV4XSksXG4gICAgICAgIGhlaWdodDogZmluYWxIZWlnaHRcbiAgICB9KTtcblxuICAgIHZhciB0SGVpZ2h0ID0gbWVudU9wdHMuZm9udC5zaXplICogTElORV9TUEFDSU5HO1xuICAgIHZhciB0TGluZXMgPSBzdmdUZXh0VXRpbHMubGluZUNvdW50KHRleHQpO1xuICAgIHZhciBzcGFuT2Zmc2V0ID0gKCh0TGluZXMgLSAxKSAqIHRIZWlnaHQgLyAyKTtcblxuICAgIHN2Z1RleHRVdGlscy5wb3NpdGlvblRleHQodGV4dCwgY29uc3RhbnRzLnRleHRPZmZzZXRYLFxuICAgICAgICBmaW5hbEhlaWdodCAvIDIgLSBzcGFuT2Zmc2V0ICsgY29uc3RhbnRzLnRleHRPZmZzZXRZKTtcblxuICAgIGlmKGlzVmVydGljYWwpIHtcbiAgICAgICAgcG9zT3B0cy55ICs9IGRpbXMuaGVpZ2h0c1tpbmRleF0gKyBwb3NPcHRzLnlQYWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcG9zT3B0cy54ICs9IGRpbXMud2lkdGhzW2luZGV4XSArIHBvc09wdHMueFBhZDtcbiAgICB9XG5cbiAgICBwb3NPcHRzLmluZGV4Kys7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUFsbEJ1dHRvbnMoZ0J1dHRvbiwgbmV3TWVudUluZGV4QXR0cikge1xuICAgIGdCdXR0b25cbiAgICAgICAgLmF0dHIoY29uc3RhbnRzLm1lbnVJbmRleEF0dHJOYW1lLCBuZXdNZW51SW5kZXhBdHRyIHx8ICctMScpXG4gICAgICAgIC5zZWxlY3RBbGwoJ2cuJyArIGNvbnN0YW50cy5kcm9wZG93bkJ1dHRvbkNsYXNzTmFtZSkucmVtb3ZlKCk7XG59XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtb2R1bGVUeXBlOiAnY29tcG9uZW50JyxcbiAgICBuYW1lOiBjb25zdGFudHMubmFtZSxcblxuICAgIGxheW91dEF0dHJpYnV0ZXM6IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpLFxuICAgIHN1cHBseUxheW91dERlZmF1bHRzOiByZXF1aXJlKCcuL2RlZmF1bHRzJyksXG5cbiAgICBkcmF3OiByZXF1aXJlKCcuL2RyYXcnKVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JvbGxCb3g7XG5cbnZhciBkMyA9IHJlcXVpcmUoJ2QzJyk7XG5cbnZhciBDb2xvciA9IHJlcXVpcmUoJy4uL2NvbG9yJyk7XG52YXIgRHJhd2luZyA9IHJlcXVpcmUoJy4uL2RyYXdpbmcnKTtcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB0byBzZXR1cCBhIHNjcm9sbCBib3hcbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSAgICAgICAgICAgZ2QgICAgICAgICAgUGxvdGx5J3MgZ3JhcGggZGl2XG4gKiBAcGFyYW0gICAgICAgICAgIGNvbnRhaW5lciAgIENvbnRhaW5lciB0byBiZSBzY3JvbGwtYm94ZWQgKGFzIGEgRDMgc2VsZWN0aW9uKVxuICogQHBhcmFtIHtzdHJpbmd9ICBpZCAgICAgICAgICBJZCBmb3IgdGhlIGNsaXAgcGF0aCB0byBpbXBsZW1lbnQgdGhlIHNjcm9sbCBib3hcbiAqL1xuZnVuY3Rpb24gU2Nyb2xsQm94KGdkLCBjb250YWluZXIsIGlkKSB7XG4gICAgdGhpcy5nZCA9IGdkO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuaWQgPSBpZDtcblxuICAgIC8vIFNlZSBTY3JvbGxCb3gucHJvdG90eXBlLmVuYWJsZSBmb3IgZnVydGhlciBkZWZpbml0aW9uXG4gICAgdGhpcy5wb3NpdGlvbiA9IG51bGw7ICAvLyBzY3JvbGxib3ggcG9zaXRpb25cbiAgICB0aGlzLnRyYW5zbGF0ZVggPSBudWxsOyAgLy8gc2Nyb2xsYm94IGhvcml6b250YWwgdHJhbnNsYXRpb25cbiAgICB0aGlzLnRyYW5zbGF0ZVkgPSBudWxsOyAgLy8gc2Nyb2xsYm94IHZlcnRpY2FsIHRyYW5zbGF0aW9uXG4gICAgdGhpcy5oYmFyID0gbnVsbDsgIC8vIGhvcml6b250YWwgc2Nyb2xsYmFyIEQzIHNlbGVjdGlvblxuICAgIHRoaXMudmJhciA9IG51bGw7ICAvLyB2ZXJ0aWNhbCBzY3JvbGxiYXIgRDMgc2VsZWN0aW9uXG5cbiAgICAvLyA8cmVjdD4gZWxlbWVudCB0byBjYXB0dXJlIHBvaW50ZXIgZXZlbnRzXG4gICAgdGhpcy5iZyA9IHRoaXMuY29udGFpbmVyLnNlbGVjdEFsbCgncmVjdC5zY3JvbGxib3gtYmcnKS5kYXRhKFswXSk7XG5cbiAgICB0aGlzLmJnLmV4aXQoKVxuICAgICAgICAub24oJy5kcmFnJywgbnVsbClcbiAgICAgICAgLm9uKCd3aGVlbCcsIG51bGwpXG4gICAgICAgIC5yZW1vdmUoKTtcblxuICAgIHRoaXMuYmcuZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuY2xhc3NlZCgnc2Nyb2xsYm94LWJnJywgdHJ1ZSlcbiAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdhbGwnKVxuICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9KTtcbn1cblxuLy8gc2Nyb2xsIGJhciBkaW1lbnNpb25zXG5TY3JvbGxCb3guYmFyV2lkdGggPSAyO1xuU2Nyb2xsQm94LmJhckxlbmd0aCA9IDIwO1xuU2Nyb2xsQm94LmJhclJhZGl1cyA9IDI7XG5TY3JvbGxCb3guYmFyUGFkID0gMTtcblNjcm9sbEJveC5iYXJDb2xvciA9ICcjODA4QkE0JztcblxuLyoqXG4gKiBJZiBuZWVkZWQsIHNldHVwIGEgY2xpcCBwYXRoIGFuZCBzY3JvbGxiYXJzXG4gKlxuICogQG1ldGhvZFxuICogQHBhcmFtIHtPYmplY3R9ICBwb3NpdGlvblxuICogQHBhcmFtIHtudW1iZXJ9ICBwb3NpdGlvbi5sICBMZWZ0IHNpZGUgcG9zaXRpb24gKGluIHBpeGVscylcbiAqIEBwYXJhbSB7bnVtYmVyfSAgcG9zaXRpb24udCAgVG9wIHNpZGUgKGluIHBpeGVscylcbiAqIEBwYXJhbSB7bnVtYmVyfSAgcG9zaXRpb24udyAgV2lkdGggKGluIHBpeGVscylcbiAqIEBwYXJhbSB7bnVtYmVyfSAgcG9zaXRpb24uaCAgSGVpZ2h0IChpbiBwaXhlbHMpXG4gKiBAcGFyYW0ge3N0cmluZ30gIFtwb3NpdGlvbi5kaXJlY3Rpb249J2Rvd24nXVxuICogICAgICAgICAgICAgICAgICBFaXRoZXIgJ2Rvd24nLCAnbGVmdCcsICdyaWdodCcgb3IgJ3VwJ1xuICogQHBhcmFtIHtudW1iZXJ9ICBbdHJhbnNsYXRlWD0wXSAgSG9yaXpvbnRhbCBvZmZzZXQgKGluIHBpeGVscylcbiAqIEBwYXJhbSB7bnVtYmVyfSAgW3RyYW5zbGF0ZVk9MF0gIFZlcnRpY2FsIG9mZnNldCAoaW4gcGl4ZWxzKVxuICovXG5TY3JvbGxCb3gucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZShwb3NpdGlvbiwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSkge1xuICAgIHZhciBmdWxsTGF5b3V0ID0gdGhpcy5nZC5fZnVsbExheW91dDtcbiAgICB2YXIgZnVsbFdpZHRoID0gZnVsbExheW91dC53aWR0aDtcbiAgICB2YXIgZnVsbEhlaWdodCA9IGZ1bGxMYXlvdXQuaGVpZ2h0O1xuXG4gICAgLy8gY29tcHV0ZSBwb3NpdGlvbiBvZiBzY3JvbGxib3hcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG5cbiAgICB2YXIgbCA9IHRoaXMucG9zaXRpb24ubDtcbiAgICB2YXIgdyA9IHRoaXMucG9zaXRpb24udztcbiAgICB2YXIgdCA9IHRoaXMucG9zaXRpb24udDtcbiAgICB2YXIgaCA9IHRoaXMucG9zaXRpb24uaDtcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5wb3NpdGlvbi5kaXJlY3Rpb247XG4gICAgdmFyIGlzRG93biA9IChkaXJlY3Rpb24gPT09ICdkb3duJyk7XG4gICAgdmFyIGlzTGVmdCA9IChkaXJlY3Rpb24gPT09ICdsZWZ0Jyk7XG4gICAgdmFyIGlzUmlnaHQgPSAoZGlyZWN0aW9uID09PSAncmlnaHQnKTtcbiAgICB2YXIgaXNVcCA9IChkaXJlY3Rpb24gPT09ICd1cCcpO1xuICAgIHZhciBib3hXID0gdztcbiAgICB2YXIgYm94SCA9IGg7XG4gICAgdmFyIGJveEwsIGJveFI7XG4gICAgdmFyIGJveFQsIGJveEI7XG5cbiAgICBpZighaXNEb3duICYmICFpc0xlZnQgJiYgIWlzUmlnaHQgJiYgIWlzVXApIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5kaXJlY3Rpb24gPSAnZG93bic7XG4gICAgICAgIGlzRG93biA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGlzVmVydGljYWwgPSBpc0Rvd24gfHwgaXNVcDtcbiAgICBpZihpc1ZlcnRpY2FsKSB7XG4gICAgICAgIGJveEwgPSBsO1xuICAgICAgICBib3hSID0gYm94TCArIGJveFc7XG5cbiAgICAgICAgaWYoaXNEb3duKSB7XG4gICAgICAgICAgICAvLyBhbmNob3IgdG8gdG9wIHNpZGVcbiAgICAgICAgICAgIGJveFQgPSB0O1xuICAgICAgICAgICAgYm94QiA9IE1hdGgubWluKGJveFQgKyBib3hILCBmdWxsSGVpZ2h0KTtcbiAgICAgICAgICAgIGJveEggPSBib3hCIC0gYm94VDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFuY2hvciB0byBib3R0b20gc2lkZVxuICAgICAgICAgICAgYm94QiA9IHQgKyBib3hIO1xuICAgICAgICAgICAgYm94VCA9IE1hdGgubWF4KGJveEIgLSBib3hILCAwKTtcbiAgICAgICAgICAgIGJveEggPSBib3hCIC0gYm94VDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGJveFQgPSB0O1xuICAgICAgICBib3hCID0gYm94VCArIGJveEg7XG5cbiAgICAgICAgaWYoaXNMZWZ0KSB7XG4gICAgICAgICAgICAvLyBhbmNob3IgdG8gcmlnaHQgc2lkZVxuICAgICAgICAgICAgYm94UiA9IGwgKyBib3hXO1xuICAgICAgICAgICAgYm94TCA9IE1hdGgubWF4KGJveFIgLSBib3hXLCAwKTtcbiAgICAgICAgICAgIGJveFcgPSBib3hSIC0gYm94TDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFuY2hvciB0byBsZWZ0IHNpZGVcbiAgICAgICAgICAgIGJveEwgPSBsO1xuICAgICAgICAgICAgYm94UiA9IE1hdGgubWluKGJveEwgKyBib3hXLCBmdWxsV2lkdGgpO1xuICAgICAgICAgICAgYm94VyA9IGJveFIgLSBib3hMO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fYm94ID0ge1xuICAgICAgICBsOiBib3hMLFxuICAgICAgICB0OiBib3hULFxuICAgICAgICB3OiBib3hXLFxuICAgICAgICBoOiBib3hIXG4gICAgfTtcblxuICAgIC8vIGNvbXB1dGUgcG9zaXRpb24gb2YgaG9yaXpvbnRhbCBzY3JvbGwgYmFyXG4gICAgdmFyIG5lZWRzSG9yaXpvbnRhbFNjcm9sbEJhciA9ICh3ID4gYm94Vyk7XG4gICAgdmFyIGhiYXJXID0gU2Nyb2xsQm94LmJhckxlbmd0aCArIDIgKiBTY3JvbGxCb3guYmFyUGFkO1xuICAgIHZhciBoYmFySCA9IFNjcm9sbEJveC5iYXJXaWR0aCArIDIgKiBTY3JvbGxCb3guYmFyUGFkO1xuICAgIC8vIGRyYXcgaG9yaXpvbnRhbCBzY3JvbGxiYXIgb24gdGhlIGJvdHRvbSBzaWRlXG4gICAgdmFyIGhiYXJMID0gbDtcbiAgICB2YXIgaGJhclQgPSB0ICsgaDtcblxuICAgIGlmKGhiYXJUICsgaGJhckggPiBmdWxsSGVpZ2h0KSBoYmFyVCA9IGZ1bGxIZWlnaHQgLSBoYmFySDtcblxuICAgIHZhciBoYmFyID0gdGhpcy5jb250YWluZXIuc2VsZWN0QWxsKCdyZWN0LnNjcm9sbGJhci1ob3Jpem9udGFsJykuZGF0YShcbiAgICAgICAgICAgIChuZWVkc0hvcml6b250YWxTY3JvbGxCYXIpID8gWzBdIDogW10pO1xuXG4gICAgaGJhci5leGl0KClcbiAgICAgICAgLm9uKCcuZHJhZycsIG51bGwpXG4gICAgICAgIC5yZW1vdmUoKTtcblxuICAgIGhiYXIuZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuY2xhc3NlZCgnc2Nyb2xsYmFyLWhvcml6b250YWwnLCB0cnVlKVxuICAgICAgICAuY2FsbChDb2xvci5maWxsLCBTY3JvbGxCb3guYmFyQ29sb3IpO1xuXG4gICAgaWYobmVlZHNIb3Jpem9udGFsU2Nyb2xsQmFyKSB7XG4gICAgICAgIHRoaXMuaGJhciA9IGhiYXIuYXR0cih7XG4gICAgICAgICAgICAncngnOiBTY3JvbGxCb3guYmFyUmFkaXVzLFxuICAgICAgICAgICAgJ3J5JzogU2Nyb2xsQm94LmJhclJhZGl1cyxcbiAgICAgICAgICAgICd4JzogaGJhckwsXG4gICAgICAgICAgICAneSc6IGhiYXJULFxuICAgICAgICAgICAgJ3dpZHRoJzogaGJhclcsXG4gICAgICAgICAgICAnaGVpZ2h0JzogaGJhckhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaGJhciBjZW50ZXIgbW92ZXMgYmV0d2VlbiBoYmFyWE1pbiBhbmQgaGJhclhNaW4gKyBoYmFyVHJhbnNsYXRlTWF4XG4gICAgICAgIHRoaXMuX2hiYXJYTWluID0gaGJhckwgKyBoYmFyVyAvIDI7XG4gICAgICAgIHRoaXMuX2hiYXJUcmFuc2xhdGVNYXggPSBib3hXIC0gaGJhclc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuaGJhcjtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2hiYXJYTWluO1xuICAgICAgICBkZWxldGUgdGhpcy5faGJhclRyYW5zbGF0ZU1heDtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIHBvc2l0aW9uIG9mIHZlcnRpY2FsIHNjcm9sbCBiYXJcbiAgICB2YXIgbmVlZHNWZXJ0aWNhbFNjcm9sbEJhciA9IChoID4gYm94SCk7XG4gICAgdmFyIHZiYXJXID0gU2Nyb2xsQm94LmJhcldpZHRoICsgMiAqIFNjcm9sbEJveC5iYXJQYWQ7XG4gICAgdmFyIHZiYXJIID0gU2Nyb2xsQm94LmJhckxlbmd0aCArIDIgKiBTY3JvbGxCb3guYmFyUGFkO1xuICAgIC8vIGRyYXcgdmVydGljYWwgc2Nyb2xsYmFyIG9uIHRoZSByaWdodCBzaWRlXG4gICAgdmFyIHZiYXJMID0gbCArIHc7XG4gICAgdmFyIHZiYXJUID0gdDtcblxuICAgIGlmKHZiYXJMICsgdmJhclcgPiBmdWxsV2lkdGgpIHZiYXJMID0gZnVsbFdpZHRoIC0gdmJhclc7XG5cbiAgICB2YXIgdmJhciA9IHRoaXMuY29udGFpbmVyLnNlbGVjdEFsbCgncmVjdC5zY3JvbGxiYXItdmVydGljYWwnKS5kYXRhKFxuICAgICAgICAgICAgKG5lZWRzVmVydGljYWxTY3JvbGxCYXIpID8gWzBdIDogW10pO1xuXG4gICAgdmJhci5leGl0KClcbiAgICAgICAgLm9uKCcuZHJhZycsIG51bGwpXG4gICAgICAgIC5yZW1vdmUoKTtcblxuICAgIHZiYXIuZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuY2xhc3NlZCgnc2Nyb2xsYmFyLXZlcnRpY2FsJywgdHJ1ZSlcbiAgICAgICAgLmNhbGwoQ29sb3IuZmlsbCwgU2Nyb2xsQm94LmJhckNvbG9yKTtcblxuICAgIGlmKG5lZWRzVmVydGljYWxTY3JvbGxCYXIpIHtcbiAgICAgICAgdGhpcy52YmFyID0gdmJhci5hdHRyKHtcbiAgICAgICAgICAgICdyeCc6IFNjcm9sbEJveC5iYXJSYWRpdXMsXG4gICAgICAgICAgICAncnknOiBTY3JvbGxCb3guYmFyUmFkaXVzLFxuICAgICAgICAgICAgJ3gnOiB2YmFyTCxcbiAgICAgICAgICAgICd5JzogdmJhclQsXG4gICAgICAgICAgICAnd2lkdGgnOiB2YmFyVyxcbiAgICAgICAgICAgICdoZWlnaHQnOiB2YmFySFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB2YmFyIGNlbnRlciBtb3ZlcyBiZXR3ZWVuIHZiYXJZTWluIGFuZCB2YmFyWU1pbiArIHZiYXJUcmFuc2xhdGVNYXhcbiAgICAgICAgdGhpcy5fdmJhcllNaW4gPSB2YmFyVCArIHZiYXJIIC8gMjtcbiAgICAgICAgdGhpcy5fdmJhclRyYW5zbGF0ZU1heCA9IGJveEggLSB2YmFySDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy52YmFyO1xuICAgICAgICBkZWxldGUgdGhpcy5fdmJhcllNaW47XG4gICAgICAgIGRlbGV0ZSB0aGlzLl92YmFyVHJhbnNsYXRlTWF4O1xuICAgIH1cblxuICAgIC8vIHNldHVwIGEgY2xpcCBwYXRoIChpZiBzY3JvbGwgYmFycyBhcmUgbmVlZGVkKVxuICAgIHZhciBjbGlwSWQgPSB0aGlzLmlkO1xuICAgIHZhciBjbGlwTCA9IGJveEwgLSAwLjU7XG4gICAgdmFyIGNsaXBSID0gKG5lZWRzVmVydGljYWxTY3JvbGxCYXIpID8gYm94UiArIHZiYXJXICsgMC41IDogYm94UiArIDAuNTtcbiAgICB2YXIgY2xpcFQgPSBib3hUIC0gMC41O1xuICAgIHZhciBjbGlwQiA9IChuZWVkc0hvcml6b250YWxTY3JvbGxCYXIpID8gYm94QiArIGhiYXJIICsgMC41IDogYm94QiArIDAuNTtcblxuICAgIHZhciBjbGlwUGF0aCA9IGZ1bGxMYXlvdXQuX3RvcGRlZnMuc2VsZWN0QWxsKCcjJyArIGNsaXBJZClcbiAgICAgICAgLmRhdGEoKG5lZWRzSG9yaXpvbnRhbFNjcm9sbEJhciB8fCBuZWVkc1ZlcnRpY2FsU2Nyb2xsQmFyKSA/IFswXSA6IFtdKTtcblxuICAgIGNsaXBQYXRoLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgIGNsaXBQYXRoLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgnY2xpcFBhdGgnKS5hdHRyKCdpZCcsIGNsaXBJZClcbiAgICAgICAgLmFwcGVuZCgncmVjdCcpO1xuXG4gICAgaWYobmVlZHNIb3Jpem9udGFsU2Nyb2xsQmFyIHx8IG5lZWRzVmVydGljYWxTY3JvbGxCYXIpIHtcbiAgICAgICAgdGhpcy5fY2xpcFJlY3QgPSBjbGlwUGF0aC5zZWxlY3QoJ3JlY3QnKS5hdHRyKHtcbiAgICAgICAgICAgIHg6IE1hdGguZmxvb3IoY2xpcEwpLFxuICAgICAgICAgICAgeTogTWF0aC5mbG9vcihjbGlwVCksXG4gICAgICAgICAgICB3aWR0aDogTWF0aC5jZWlsKGNsaXBSKSAtIE1hdGguZmxvb3IoY2xpcEwpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLmNlaWwoY2xpcEIpIC0gTWF0aC5mbG9vcihjbGlwVClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jb250YWluZXIuY2FsbChEcmF3aW5nLnNldENsaXBVcmwsIGNsaXBJZCwgdGhpcy5nZCk7XG5cbiAgICAgICAgdGhpcy5iZy5hdHRyKHtcbiAgICAgICAgICAgIHg6IGwsXG4gICAgICAgICAgICB5OiB0LFxuICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iZy5hdHRyKHtcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbnRhaW5lclxuICAgICAgICAgICAgLm9uKCd3aGVlbCcsIG51bGwpXG4gICAgICAgICAgICAub24oJy5kcmFnJywgbnVsbClcbiAgICAgICAgICAgIC5jYWxsKERyYXdpbmcuc2V0Q2xpcFVybCwgbnVsbCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jbGlwUmVjdDtcbiAgICB9XG5cbiAgICAvLyBzZXQgdXAgZHJhZyBsaXN0ZW5lcnMgKGlmIHNjcm9sbCBiYXJzIGFyZSBuZWVkZWQpXG4gICAgaWYobmVlZHNIb3Jpem9udGFsU2Nyb2xsQmFyIHx8IG5lZWRzVmVydGljYWxTY3JvbGxCYXIpIHtcbiAgICAgICAgdmFyIG9uQm94RHJhZyA9IGQzLmJlaGF2aW9yLmRyYWcoKVxuICAgICAgICAgICAgLm9uKCdkcmFnc3RhcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zb3VyY2VFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZHJhZycsIHRoaXMuX29uQm94RHJhZy5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLmNvbnRhaW5lclxuICAgICAgICAgICAgLm9uKCd3aGVlbCcsIG51bGwpXG4gICAgICAgICAgICAub24oJ3doZWVsJywgdGhpcy5fb25Cb3hXaGVlbC5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLm9uKCcuZHJhZycsIG51bGwpXG4gICAgICAgICAgICAuY2FsbChvbkJveERyYWcpO1xuXG4gICAgICAgIHZhciBvbkJhckRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKClcbiAgICAgICAgICAgIC5vbignZHJhZ3N0YXJ0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZDMuZXZlbnQuc291cmNlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zb3VyY2VFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2RyYWcnLCB0aGlzLl9vbkJhckRyYWcuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgaWYobmVlZHNIb3Jpem9udGFsU2Nyb2xsQmFyKSB7XG4gICAgICAgICAgICB0aGlzLmhiYXJcbiAgICAgICAgICAgICAgICAub24oJy5kcmFnJywgbnVsbClcbiAgICAgICAgICAgICAgICAuY2FsbChvbkJhckRyYWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobmVlZHNWZXJ0aWNhbFNjcm9sbEJhcikge1xuICAgICAgICAgICAgdGhpcy52YmFyXG4gICAgICAgICAgICAgICAgLm9uKCcuZHJhZycsIG51bGwpXG4gICAgICAgICAgICAgICAgLmNhbGwob25CYXJEcmFnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldCBzY3JvbGxib3ggdHJhbnNsYXRpb25cbiAgICB0aGlzLnNldFRyYW5zbGF0ZSh0cmFuc2xhdGVYLCB0cmFuc2xhdGVZKTtcbn07XG5cbi8qKlxuICogSWYgcHJlc2VudCwgcmVtb3ZlIGNsaXAtcGF0aCBhbmQgc2Nyb2xsYmFyc1xuICpcbiAqIEBtZXRob2RcbiAqL1xuU2Nyb2xsQm94LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBpZih0aGlzLmhiYXIgfHwgdGhpcy52YmFyKSB7XG4gICAgICAgIHRoaXMuYmcuYXR0cih7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb250YWluZXJcbiAgICAgICAgICAgIC5vbignd2hlZWwnLCBudWxsKVxuICAgICAgICAgICAgLm9uKCcuZHJhZycsIG51bGwpXG4gICAgICAgICAgICAuY2FsbChEcmF3aW5nLnNldENsaXBVcmwsIG51bGwpO1xuICAgICAgICBkZWxldGUgdGhpcy5fY2xpcFJlY3Q7XG4gICAgfVxuXG4gICAgaWYodGhpcy5oYmFyKSB7XG4gICAgICAgIHRoaXMuaGJhci5vbignLmRyYWcnLCBudWxsKTtcbiAgICAgICAgdGhpcy5oYmFyLnJlbW92ZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5oYmFyO1xuICAgICAgICBkZWxldGUgdGhpcy5faGJhclhNaW47XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9oYmFyVHJhbnNsYXRlTWF4O1xuICAgIH1cblxuICAgIGlmKHRoaXMudmJhcikge1xuICAgICAgICB0aGlzLnZiYXIub24oJy5kcmFnJywgbnVsbCk7XG4gICAgICAgIHRoaXMudmJhci5yZW1vdmUoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMudmJhcjtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3ZiYXJZTWluO1xuICAgICAgICBkZWxldGUgdGhpcy5fdmJhclRyYW5zbGF0ZU1heDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgc2Nyb2xsIGJveCBkcmFnIGV2ZW50c1xuICpcbiAqIEBtZXRob2RcbiAqL1xuU2Nyb2xsQm94LnByb3RvdHlwZS5fb25Cb3hEcmFnID0gZnVuY3Rpb24gX29uQm94RHJhZygpIHtcbiAgICB2YXIgdHJhbnNsYXRlWCA9IHRoaXMudHJhbnNsYXRlWDtcbiAgICB2YXIgdHJhbnNsYXRlWSA9IHRoaXMudHJhbnNsYXRlWTtcblxuICAgIGlmKHRoaXMuaGJhcikge1xuICAgICAgICB0cmFuc2xhdGVYIC09IGQzLmV2ZW50LmR4O1xuICAgIH1cblxuICAgIGlmKHRoaXMudmJhcikge1xuICAgICAgICB0cmFuc2xhdGVZIC09IGQzLmV2ZW50LmR5O1xuICAgIH1cblxuICAgIHRoaXMuc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVkpO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIHNjcm9sbCBib3ggd2hlZWwgZXZlbnRzXG4gKlxuICogQG1ldGhvZFxuICovXG5TY3JvbGxCb3gucHJvdG90eXBlLl9vbkJveFdoZWVsID0gZnVuY3Rpb24gX29uQm94V2hlZWwoKSB7XG4gICAgdmFyIHRyYW5zbGF0ZVggPSB0aGlzLnRyYW5zbGF0ZVg7XG4gICAgdmFyIHRyYW5zbGF0ZVkgPSB0aGlzLnRyYW5zbGF0ZVk7XG5cbiAgICBpZih0aGlzLmhiYXIpIHtcbiAgICAgICAgdHJhbnNsYXRlWCArPSBkMy5ldmVudC5kZWx0YVk7XG4gICAgfVxuXG4gICAgaWYodGhpcy52YmFyKSB7XG4gICAgICAgIHRyYW5zbGF0ZVkgKz0gZDMuZXZlbnQuZGVsdGFZO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVkpO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIHNjcm9sbCBiYXIgZHJhZyBldmVudHNcbiAqXG4gKiBAbWV0aG9kXG4gKi9cblNjcm9sbEJveC5wcm90b3R5cGUuX29uQmFyRHJhZyA9IGZ1bmN0aW9uIF9vbkJhckRyYWcoKSB7XG4gICAgdmFyIHRyYW5zbGF0ZVggPSB0aGlzLnRyYW5zbGF0ZVg7XG4gICAgdmFyIHRyYW5zbGF0ZVkgPSB0aGlzLnRyYW5zbGF0ZVk7XG5cbiAgICBpZih0aGlzLmhiYXIpIHtcbiAgICAgICAgdmFyIHhNaW4gPSB0cmFuc2xhdGVYICsgdGhpcy5faGJhclhNaW47XG4gICAgICAgIHZhciB4TWF4ID0geE1pbiArIHRoaXMuX2hiYXJUcmFuc2xhdGVNYXg7XG4gICAgICAgIHZhciB4ID0gTGliLmNvbnN0cmFpbihkMy5ldmVudC54LCB4TWluLCB4TWF4KTtcbiAgICAgICAgdmFyIHhmID0gKHggLSB4TWluKSAvICh4TWF4IC0geE1pbik7XG5cbiAgICAgICAgdmFyIHRyYW5zbGF0ZVhNYXggPSB0aGlzLnBvc2l0aW9uLncgLSB0aGlzLl9ib3gudztcblxuICAgICAgICB0cmFuc2xhdGVYID0geGYgKiB0cmFuc2xhdGVYTWF4O1xuICAgIH1cblxuICAgIGlmKHRoaXMudmJhcikge1xuICAgICAgICB2YXIgeU1pbiA9IHRyYW5zbGF0ZVkgKyB0aGlzLl92YmFyWU1pbjtcbiAgICAgICAgdmFyIHlNYXggPSB5TWluICsgdGhpcy5fdmJhclRyYW5zbGF0ZU1heDtcbiAgICAgICAgdmFyIHkgPSBMaWIuY29uc3RyYWluKGQzLmV2ZW50LnksIHlNaW4sIHlNYXgpO1xuICAgICAgICB2YXIgeWYgPSAoeSAtIHlNaW4pIC8gKHlNYXggLSB5TWluKTtcblxuICAgICAgICB2YXIgdHJhbnNsYXRlWU1heCA9IHRoaXMucG9zaXRpb24uaCAtIHRoaXMuX2JveC5oO1xuXG4gICAgICAgIHRyYW5zbGF0ZVkgPSB5ZiAqIHRyYW5zbGF0ZVlNYXg7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRUcmFuc2xhdGUodHJhbnNsYXRlWCwgdHJhbnNsYXRlWSk7XG59O1xuXG4vKipcbiAqIFNldCBjbGlwIHBhdGggYW5kIHNjcm9sbCBiYXIgdHJhbnNsYXRlIHRyYW5zZm9ybVxuICpcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7bnVtYmVyfSAgW3RyYW5zbGF0ZVg9MF0gIEhvcml6b250YWwgb2Zmc2V0IChpbiBwaXhlbHMpXG4gKiBAcGFyYW0ge251bWJlcn0gIFt0cmFuc2xhdGVZPTBdICBWZXJ0aWNhbCBvZmZzZXQgKGluIHBpeGVscylcbiAqL1xuU2Nyb2xsQm94LnByb3RvdHlwZS5zZXRUcmFuc2xhdGUgPSBmdW5jdGlvbiBzZXRUcmFuc2xhdGUodHJhbnNsYXRlWCwgdHJhbnNsYXRlWSkge1xuICAgIC8vIHN0b3JlIHRyYW5zbGF0ZVggYW5kIHRyYW5zbGF0ZVkgKG5lZWRlZCBieSBtb3VzZSBldmVudCBoYW5kbGVycylcbiAgICB2YXIgdHJhbnNsYXRlWE1heCA9IHRoaXMucG9zaXRpb24udyAtIHRoaXMuX2JveC53O1xuICAgIHZhciB0cmFuc2xhdGVZTWF4ID0gdGhpcy5wb3NpdGlvbi5oIC0gdGhpcy5fYm94Lmg7XG5cbiAgICB0cmFuc2xhdGVYID0gTGliLmNvbnN0cmFpbih0cmFuc2xhdGVYIHx8IDAsIDAsIHRyYW5zbGF0ZVhNYXgpO1xuICAgIHRyYW5zbGF0ZVkgPSBMaWIuY29uc3RyYWluKHRyYW5zbGF0ZVkgfHwgMCwgMCwgdHJhbnNsYXRlWU1heCk7XG5cbiAgICB0aGlzLnRyYW5zbGF0ZVggPSB0cmFuc2xhdGVYO1xuICAgIHRoaXMudHJhbnNsYXRlWSA9IHRyYW5zbGF0ZVk7XG5cbiAgICB0aGlzLmNvbnRhaW5lci5jYWxsKERyYXdpbmcuc2V0VHJhbnNsYXRlLFxuICAgICAgICB0aGlzLl9ib3gubCAtIHRoaXMucG9zaXRpb24ubCAtIHRyYW5zbGF0ZVgsXG4gICAgICAgIHRoaXMuX2JveC50IC0gdGhpcy5wb3NpdGlvbi50IC0gdHJhbnNsYXRlWSk7XG5cbiAgICBpZih0aGlzLl9jbGlwUmVjdCkge1xuICAgICAgICB0aGlzLl9jbGlwUmVjdC5hdHRyKHtcbiAgICAgICAgICAgIHg6IE1hdGguZmxvb3IodGhpcy5wb3NpdGlvbi5sICsgdHJhbnNsYXRlWCAtIDAuNSksXG4gICAgICAgICAgICB5OiBNYXRoLmZsb29yKHRoaXMucG9zaXRpb24udCArIHRyYW5zbGF0ZVkgLSAwLjUpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmKHRoaXMuaGJhcikge1xuICAgICAgICB2YXIgeGYgPSB0cmFuc2xhdGVYIC8gdHJhbnNsYXRlWE1heDtcblxuICAgICAgICB0aGlzLmhiYXIuY2FsbChEcmF3aW5nLnNldFRyYW5zbGF0ZSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVggKyB4ZiAqIHRoaXMuX2hiYXJUcmFuc2xhdGVNYXgsXG4gICAgICAgICAgICB0cmFuc2xhdGVZKTtcbiAgICB9XG5cbiAgICBpZih0aGlzLnZiYXIpIHtcbiAgICAgICAgdmFyIHlmID0gdHJhbnNsYXRlWSAvIHRyYW5zbGF0ZVlNYXg7XG5cbiAgICAgICAgdGhpcy52YmFyLmNhbGwoRHJhd2luZy5zZXRUcmFuc2xhdGUsXG4gICAgICAgICAgICB0cmFuc2xhdGVYLFxuICAgICAgICAgICAgdHJhbnNsYXRlWSArIHlmICogdGhpcy5fdmJhclRyYW5zbGF0ZU1heCk7XG4gICAgfVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJykudmVyc2lvbjtcblxuLy8gaW5qZWN0IHByb21pc2UgcG9seWZpbGxcbnJlcXVpcmUoJ2VzNi1wcm9taXNlJykucG9seWZpbGwoKTtcblxuLy8gaW5qZWN0IHBsb3QgY3NzXG5yZXF1aXJlKCcuLi9idWlsZC9wbG90Y3NzJyk7XG5cbi8vIGluamVjdCBkZWZhdWx0IE1hdGhKYXggY29uZmlnXG5yZXF1aXJlKCcuL2ZvbnRzL21hdGhqYXhfY29uZmlnJykoKTtcblxuLy8gaW5jbHVkZSByZWdpc3RyeSBtb2R1bGUgYW5kIGV4cG9zZSByZWdpc3RlciBtZXRob2RcbnZhciBSZWdpc3RyeSA9IHJlcXVpcmUoJy4vcmVnaXN0cnknKTtcbnZhciByZWdpc3RlciA9IGV4cG9ydHMucmVnaXN0ZXIgPSBSZWdpc3RyeS5yZWdpc3RlcjtcblxuLy8gZXhwb3NlIHBsb3QgYXBpIG1ldGhvZHNcbnZhciBwbG90QXBpID0gcmVxdWlyZSgnLi9wbG90X2FwaScpO1xudmFyIG1ldGhvZE5hbWVzID0gT2JqZWN0LmtleXMocGxvdEFwaSk7XG5mb3IodmFyIGkgPSAwOyBpIDwgbWV0aG9kTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IG1ldGhvZE5hbWVzW2ldO1xuICAgIC8vIF8gLT4gcHJpdmF0ZSBBUEkgbWV0aG9kcywgYnV0IHN0aWxsIHJlZ2lzdGVyZWQgZm9yIGludGVybmFsIHVzZVxuICAgIGlmKG5hbWUuY2hhckF0KDApICE9PSAnXycpIGV4cG9ydHNbbmFtZV0gPSBwbG90QXBpW25hbWVdO1xuICAgIHJlZ2lzdGVyKHtcbiAgICAgICAgbW9kdWxlVHlwZTogJ2FwaU1ldGhvZCcsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGZuOiBwbG90QXBpW25hbWVdXG4gICAgfSk7XG59XG5cbi8vIHNjYXR0ZXIgaXMgdGhlIG9ubHkgdHJhY2UgaW5jbHVkZWQgYnkgZGVmYXVsdFxucmVnaXN0ZXIocmVxdWlyZSgnLi90cmFjZXMvc2NhdHRlcicpKTtcblxuLy8gcmVnaXN0ZXIgYWxsIHJlZ2lzdHJhYmxlIGNvbXBvbmVudHMgbW9kdWxlc1xucmVnaXN0ZXIoW1xuICAgIHJlcXVpcmUoJy4vY29tcG9uZW50cy9sZWdlbmQnKSxcbiAgICByZXF1aXJlKCcuL2NvbXBvbmVudHMvZngnKSwgLy8gZnggbmVlZHMgdG8gY29tZSBhZnRlciBsZWdlbmRcbiAgICByZXF1aXJlKCcuL2NvbXBvbmVudHMvYW5ub3RhdGlvbnMnKSxcbiAgICByZXF1aXJlKCcuL2NvbXBvbmVudHMvYW5ub3RhdGlvbnMzZCcpLFxuICAgIHJlcXVpcmUoJy4vY29tcG9uZW50cy9zaGFwZXMnKSxcbiAgICByZXF1aXJlKCcuL2NvbXBvbmVudHMvaW1hZ2VzJyksXG4gICAgcmVxdWlyZSgnLi9jb21wb25lbnRzL3VwZGF0ZW1lbnVzJyksXG4gICAgcmVxdWlyZSgnLi9jb21wb25lbnRzL3NsaWRlcnMnKSxcbiAgICByZXF1aXJlKCcuL2NvbXBvbmVudHMvcmFuZ2VzbGlkZXInKSxcbiAgICByZXF1aXJlKCcuL2NvbXBvbmVudHMvcmFuZ2VzZWxlY3RvcicpLFxuICAgIHJlcXVpcmUoJy4vY29tcG9uZW50cy9ncmlkJyksXG4gICAgcmVxdWlyZSgnLi9jb21wb25lbnRzL2Vycm9yYmFycycpLFxuICAgIHJlcXVpcmUoJy4vY29tcG9uZW50cy9jb2xvcnNjYWxlJyksXG4gICAgcmVxdWlyZSgnLi9jb21wb25lbnRzL2NvbG9yYmFyJylcbl0pO1xuXG4vLyBsb2NhbGVzIGVuIGFuZCBlbi1VUyBhcmUgcmVxdWlyZWQgZm9yIGRlZmF1bHQgYmVoYXZpb3JcbnJlZ2lzdGVyKFtcbiAgICByZXF1aXJlKCcuL2xvY2FsZS1lbicpLFxuICAgIHJlcXVpcmUoJy4vbG9jYWxlLWVuLXVzJylcbl0pO1xuXG4vLyBsb2NhbGVzIHRoYXQgYXJlIHByZXNlbnQgaW4gdGhlIHdpbmRvdyBzaG91bGQgYmUgbG9hZGVkXG5pZih3aW5kb3cuUGxvdGx5TG9jYWxlcyAmJiBBcnJheS5pc0FycmF5KHdpbmRvdy5QbG90bHlMb2NhbGVzKSkge1xuICAgIHJlZ2lzdGVyKHdpbmRvdy5QbG90bHlMb2NhbGVzKTtcbiAgICBkZWxldGUgd2luZG93LlBsb3RseUxvY2FsZXM7XG59XG5cbi8vIHBsb3QgaWNvbnNcbmV4cG9ydHMuSWNvbnMgPSByZXF1aXJlKCcuL2ZvbnRzL3Bsb3RpY29uJyk7XG5cbi8vIHVub2ZmaWNpYWwgJ2JldGEnIHBsb3QgbWV0aG9kcywgdXNlIGF0IHlvdXIgb3duIHJpc2tcbmV4cG9ydHMuUGxvdHMgPSByZXF1aXJlKCcuL3Bsb3RzL3Bsb3RzJyk7XG5leHBvcnRzLkZ4ID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2Z4Jyk7XG5leHBvcnRzLlNuYXBzaG90ID0gcmVxdWlyZSgnLi9zbmFwc2hvdCcpO1xuZXhwb3J0cy5QbG90U2NoZW1hID0gcmVxdWlyZSgnLi9wbG90X2FwaS9wbG90X3NjaGVtYScpO1xuZXhwb3J0cy5RdWV1ZSA9IHJlcXVpcmUoJy4vbGliL3F1ZXVlJyk7XG5cbi8vIGV4cG9ydCBkMyB1c2VkIGluIHRoZSBidW5kbGVcbmV4cG9ydHMuZDMgPSByZXF1aXJlKCdkMycpO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgTWF0aEpheDpmYWxzZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmKHR5cGVvZiBNYXRoSmF4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZ2xvYmFsQ29uZmlnID0gKHdpbmRvdy5QbG90bHlDb25maWcgfHwge30pLk1hdGhKYXhDb25maWcgIT09ICdsb2NhbCc7XG5cbiAgICAgICAgaWYoZ2xvYmFsQ29uZmlnKSB7XG4gICAgICAgICAgICBNYXRoSmF4Lkh1Yi5Db25maWcoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VTdHlsZTogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHNraXBTdGFydHVwVHlwZXNldDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5QWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICB0ZXgyamF4OiB7XG4gICAgICAgICAgICAgICAgICAgIGlubGluZU1hdGg6IFtbJyQnLCAnJCddLCBbJ1xcXFwoJywgJ1xcXFwpJ11dXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBNYXRoSmF4Lkh1Yi5Db25maWd1cmVkKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtb2R1bGVUeXBlOiAnbG9jYWxlJyxcbiAgICBuYW1lOiAnZW4tVVMnLFxuICAgIGRpY3Rpb25hcnk6IHtcbiAgICAgICAgJ0NsaWNrIHRvIGVudGVyIENvbG9yc2NhbGUgdGl0bGUnOiAnQ2xpY2sgdG8gZW50ZXIgQ29sb3JzY2FsZSB0aXRsZSdcbiAgICB9LFxuICAgIGZvcm1hdDoge1xuICAgICAgICBkYXRlOiAnJW0vJWQvJVknXG4gICAgfVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbW9kdWxlVHlwZTogJ2xvY2FsZScsXG4gICAgbmFtZTogJ2VuJyxcbiAgICBkaWN0aW9uYXJ5OiB7XG4gICAgICAgICdDbGljayB0byBlbnRlciBDb2xvcnNjYWxlIHRpdGxlJzogJ0NsaWNrIHRvIGVudGVyIENvbG91cnNjYWxlIHRpdGxlJ1xuICAgIH0sXG4gICAgZm9ybWF0OiB7XG4gICAgICAgIGRheXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcbiAgICAgICAgc2hvcnREYXlzOiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICAgICAgICBtb250aHM6IFtcbiAgICAgICAgICAgICdKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJyxcbiAgICAgICAgICAgICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlcidcbiAgICAgICAgXSxcbiAgICAgICAgc2hvcnRNb250aHM6IFtcbiAgICAgICAgICAgICdKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsXG4gICAgICAgICAgICAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXG4gICAgICAgIF0sXG4gICAgICAgIHBlcmlvZHM6IFsnQU0nLCAnUE0nXSxcbiAgICAgICAgZGF0ZVRpbWU6ICclYSAlYiAlZSAlWCAlWScsXG4gICAgICAgIGRhdGU6ICclZC8lbS8lWScsXG4gICAgICAgIHRpbWU6ICclSDolTTolUycsXG4gICAgICAgIGRlY2ltYWw6ICcuJyxcbiAgICAgICAgdGhvdXNhbmRzOiAnLCcsXG4gICAgICAgIGdyb3VwaW5nOiBbM10sXG4gICAgICAgIGN1cnJlbmN5OiBbJyQnLCAnJ10sXG4gICAgICAgIHllYXI6ICclWScsXG4gICAgICAgIG1vbnRoOiAnJWIgJVknLFxuICAgICAgICBkYXlNb250aDogJyViICUtZCcsXG4gICAgICAgIGRheU1vbnRoWWVhcjogJyViICUtZCwgJVknXG4gICAgfVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG1haW4gPSByZXF1aXJlKCcuL3Bsb3RfYXBpJyk7XG5cbmV4cG9ydHMucGxvdCA9IG1haW4ucGxvdDtcbmV4cG9ydHMubmV3UGxvdCA9IG1haW4ubmV3UGxvdDtcbmV4cG9ydHMucmVzdHlsZSA9IG1haW4ucmVzdHlsZTtcbmV4cG9ydHMucmVsYXlvdXQgPSBtYWluLnJlbGF5b3V0O1xuZXhwb3J0cy5yZWRyYXcgPSBtYWluLnJlZHJhdztcbmV4cG9ydHMudXBkYXRlID0gbWFpbi51cGRhdGU7XG5leHBvcnRzLl9ndWlSZXN0eWxlID0gbWFpbi5fZ3VpUmVzdHlsZTtcbmV4cG9ydHMuX2d1aVJlbGF5b3V0ID0gbWFpbi5fZ3VpUmVsYXlvdXQ7XG5leHBvcnRzLl9ndWlVcGRhdGUgPSBtYWluLl9ndWlVcGRhdGU7XG5leHBvcnRzLl9zdG9yZURpcmVjdEdVSUVkaXQgPSBtYWluLl9zdG9yZURpcmVjdEdVSUVkaXQ7XG5leHBvcnRzLnJlYWN0ID0gbWFpbi5yZWFjdDtcbmV4cG9ydHMuZXh0ZW5kVHJhY2VzID0gbWFpbi5leHRlbmRUcmFjZXM7XG5leHBvcnRzLnByZXBlbmRUcmFjZXMgPSBtYWluLnByZXBlbmRUcmFjZXM7XG5leHBvcnRzLmFkZFRyYWNlcyA9IG1haW4uYWRkVHJhY2VzO1xuZXhwb3J0cy5kZWxldGVUcmFjZXMgPSBtYWluLmRlbGV0ZVRyYWNlcztcbmV4cG9ydHMubW92ZVRyYWNlcyA9IG1haW4ubW92ZVRyYWNlcztcbmV4cG9ydHMucHVyZ2UgPSBtYWluLnB1cmdlO1xuZXhwb3J0cy5hZGRGcmFtZXMgPSBtYWluLmFkZEZyYW1lcztcbmV4cG9ydHMuZGVsZXRlRnJhbWVzID0gbWFpbi5kZWxldGVGcmFtZXM7XG5leHBvcnRzLmFuaW1hdGUgPSBtYWluLmFuaW1hdGU7XG5leHBvcnRzLnNldFBsb3RDb25maWcgPSBtYWluLnNldFBsb3RDb25maWc7XG5cbmV4cG9ydHMudG9JbWFnZSA9IHJlcXVpcmUoJy4vdG9faW1hZ2UnKTtcbmV4cG9ydHMudmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlJyk7XG5leHBvcnRzLmRvd25sb2FkSW1hZ2UgPSByZXF1aXJlKCcuLi9zbmFwc2hvdC9kb3dubG9hZCcpO1xuXG52YXIgdGVtcGxhdGVBcGkgPSByZXF1aXJlKCcuL3RlbXBsYXRlX2FwaScpO1xuZXhwb3J0cy5tYWtlVGVtcGxhdGUgPSB0ZW1wbGF0ZUFwaS5tYWtlVGVtcGxhdGU7XG5leHBvcnRzLnZhbGlkYXRlVGVtcGxhdGUgPSB0ZW1wbGF0ZUFwaS52YWxpZGF0ZVRlbXBsYXRlO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaWIgPSByZXF1aXJlKCcuLi9saWInKTtcbnZhciBpc1BsYWluT2JqZWN0ID0gTGliLmlzUGxhaW5PYmplY3Q7XG52YXIgUGxvdFNjaGVtYSA9IHJlcXVpcmUoJy4vcGxvdF9zY2hlbWEnKTtcbnZhciBQbG90cyA9IHJlcXVpcmUoJy4uL3Bsb3RzL3Bsb3RzJyk7XG52YXIgcGxvdEF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuLi9wbG90cy9hdHRyaWJ1dGVzJyk7XG52YXIgVGVtcGxhdGUgPSByZXF1aXJlKCcuL3Bsb3RfdGVtcGxhdGUnKTtcbnZhciBkZmx0Q29uZmlnID0gcmVxdWlyZSgnLi9wbG90X2NvbmZpZycpLmRmbHRDb25maWc7XG5cbi8qKlxuICogUGxvdGx5Lm1ha2VUZW1wbGF0ZTogY3JlYXRlIGEgdGVtcGxhdGUgb2ZmIGFuIGV4aXN0aW5nIGZpZ3VyZSB0byByZXVzZVxuICogc3R5bGUgYXR0cmlidXRlcyBvbiBvdGhlciBmaWd1cmVzLlxuICpcbiAqIE5vdGU6IHNlcGFyYXRlZCBmcm9tIHRoZSByZXN0IG9mIHRlbXBsYXRlcyBiZWNhdXNlIG90aGVyd2lzZSB3ZSBnZXQgY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgZHVlIHRvIFBsb3RTY2hlbWEuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8RE9NIGVsZW1lbnR8c3RyaW5nfSBmaWd1cmU6IFRoZSBmaWd1cmUgdG8gYmFzZSB0aGUgdGVtcGxhdGUgb25cbiAqICAgICBzaG91bGQgY29udGFpbiBhIHRyYWNlIGFycmF5IGBmaWd1cmUuZGF0YWBcbiAqICAgICBhbmQgYSBsYXlvdXQgb2JqZWN0IGBmaWd1cmUubGF5b3V0YFxuICogQHJldHVybnMge29iamVjdH0gdGVtcGxhdGU6IHRoZSBleHRyYWN0ZWQgdGVtcGxhdGUgLSBjYW4gdGhlbiBiZSB1c2VkIGFzXG4gKiAgICAgYGxheW91dC50ZW1wbGF0ZWAgaW4gYW5vdGhlciBmaWd1cmUuXG4gKi9cbmV4cG9ydHMubWFrZVRlbXBsYXRlID0gZnVuY3Rpb24oZmlndXJlKSB7XG4gICAgZmlndXJlID0gTGliLmlzUGxhaW5PYmplY3QoZmlndXJlKSA/IGZpZ3VyZSA6IExpYi5nZXRHcmFwaERpdihmaWd1cmUpO1xuICAgIGZpZ3VyZSA9IExpYi5leHRlbmREZWVwKHtfY29udGV4dDogZGZsdENvbmZpZ30sIHtkYXRhOiBmaWd1cmUuZGF0YSwgbGF5b3V0OiBmaWd1cmUubGF5b3V0fSk7XG4gICAgUGxvdHMuc3VwcGx5RGVmYXVsdHMoZmlndXJlKTtcbiAgICB2YXIgZGF0YSA9IGZpZ3VyZS5kYXRhIHx8IFtdO1xuICAgIHZhciBsYXlvdXQgPSBmaWd1cmUubGF5b3V0IHx8IHt9O1xuICAgIC8vIGNvcHkgb3ZlciBhIGZldyBpdGVtcyB0byBoZWxwIGZvbGxvdyB0aGUgc2NoZW1hXG4gICAgbGF5b3V0Ll9iYXNlUGxvdE1vZHVsZXMgPSBmaWd1cmUuX2Z1bGxMYXlvdXQuX2Jhc2VQbG90TW9kdWxlcztcbiAgICBsYXlvdXQuX21vZHVsZXMgPSBmaWd1cmUuX2Z1bGxMYXlvdXQuX21vZHVsZXM7XG5cbiAgICB2YXIgdGVtcGxhdGUgPSB7XG4gICAgICAgIGRhdGE6IHt9LFxuICAgICAgICBsYXlvdXQ6IHt9XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogTm90ZTogd2UgZG8gTk9UIHZhbGlkYXRlIHRlbXBsYXRlIHZhbHVlcywgd2UganVzdCB0YWtlIHdoYXQncyBpbiB0aGVcbiAgICAgKiB1c2VyIGlucHV0cyBkYXRhIGFuZCBsYXlvdXQsIG5vdCB0aGUgdmFsaWRhdGVkIHZhbHVlcyBpbiBmdWxsRGF0YSBhbmRcbiAgICAgKiBmdWxsTGF5b3V0LiBFdmVuIGlmIHdlIHdlcmUgdG8gdmFsaWRhdGUgaGVyZSwgdGhlcmUncyBubyBndWFyYW50ZWUgdGhhdFxuICAgICAqIHRoZXNlIHZhbHVlcyB3b3VsZCBzdGlsbCBiZSB2YWxpZCB3aGVuIGFwcGxpZWQgdG8gYSBuZXcgZmlndXJlLCB3aGljaFxuICAgICAqIG1heSBjb250YWluIGRpZmZlcmVudCB0cmFjZSBtb2RlcywgZGlmZmVyZW50IGF4ZXMsIGV0Yy4gU28gaXQnc1xuICAgICAqIGltcG9ydGFudCB0aGF0IHdoZW4gYXBwbHlpbmcgYSB0ZW1wbGF0ZSB3ZSBzdGlsbCB2YWxpZGF0ZSB0aGUgdGVtcGxhdGVcbiAgICAgKiB2YWx1ZXMsIHJhdGhlciB0aGFuIGp1c3QgdXNpbmcgdGhlbSBhcyBkZWZhdWx0cy5cbiAgICAgKi9cblxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbih0cmFjZSkge1xuICAgICAgICAvLyBUT0RPOiBXaGF0IGlmIG5vIHN0eWxlIGluZm8gaXMgZXh0cmFjdGVkIGZvciB0aGlzIHRyYWNlLiBXZSBtYXlcbiAgICAgICAgLy8gbm90IHdhbnQgYW4gZW1wdHkgb2JqZWN0IGFzIHRoZSBudWxsIHZhbHVlLlxuICAgICAgICAvLyBUT0RPOiBhbGxvdyB0cmFuc2Zvcm1zIHRvIGNvbnRyaWJ1dGUgdG8gdGVtcGxhdGVzP1xuICAgICAgICAvLyBhcyBpdCBzdGFuZHMgdGhleSBhcmUgaWdub3JlZCwgd2hpY2ggbWF5IGJlIGZvciB0aGUgYmVzdC4uLlxuXG4gICAgICAgIHZhciB0cmFjZVRlbXBsYXRlID0ge307XG4gICAgICAgIHdhbGtTdHlsZUtleXModHJhY2UsIHRyYWNlVGVtcGxhdGUsIGdldFRyYWNlSW5mby5iaW5kKG51bGwsIHRyYWNlKSk7XG5cbiAgICAgICAgdmFyIHRyYWNlVHlwZSA9IExpYi5jb2VyY2UodHJhY2UsIHt9LCBwbG90QXR0cmlidXRlcywgJ3R5cGUnKTtcbiAgICAgICAgdmFyIHR5cGVUZW1wbGF0ZXMgPSB0ZW1wbGF0ZS5kYXRhW3RyYWNlVHlwZV07XG4gICAgICAgIGlmKCF0eXBlVGVtcGxhdGVzKSB0eXBlVGVtcGxhdGVzID0gdGVtcGxhdGUuZGF0YVt0cmFjZVR5cGVdID0gW107XG4gICAgICAgIHR5cGVUZW1wbGF0ZXMucHVzaCh0cmFjZVRlbXBsYXRlKTtcbiAgICB9KTtcblxuICAgIHdhbGtTdHlsZUtleXMobGF5b3V0LCB0ZW1wbGF0ZS5sYXlvdXQsIGdldExheW91dEluZm8uYmluZChudWxsLCBsYXlvdXQpKTtcblxuICAgIC8qXG4gICAgICogQ29tcG9zZSB0aGUgbmV3IHRlbXBsYXRlIHdpdGggYW4gZXhpc3Rpbmcgb25lIHRvIHRoZSBzYW1lIGVmZmVjdFxuICAgICAqXG4gICAgICogTk9URTogdGhlcmUncyBhIHBvc3NpYmlsaXR5IG9mIHNsaWdodGx5IGRpZmZlcmVudCBiZWhhdmlvcjogaWYgdGhlIHBsb3RcbiAgICAgKiBoYXMgYW4gaW52YWxpZCB2YWx1ZSBhbmQgdGhlIG9sZCB0ZW1wbGF0ZSBoYXMgYSB2YWxpZCB2YWx1ZSBmb3IgdGhlIHNhbWVcbiAgICAgKiBhdHRyaWJ1dGUsIHRoZSBwbG90IHdpbGwgdXNlIHRoZSBvbGQgdGVtcGxhdGUgdmFsdWUgYnV0IHRoaXMgcm91dGluZVxuICAgICAqIHdpbGwgcHVsbCB0aGUgaW52YWxpZCB2YWx1ZSAocmVzdWx0aW5nIGluIHRoZSBvcmlnaW5hbCBkZWZhdWx0KS5cbiAgICAgKiBJbiB0aGUgZ2VuZXJhbCBjYXNlIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHNvbHZlIHRoaXMgd2l0aCBhIHNpbmdsZSB2YWx1ZSxcbiAgICAgKiBzaW5jZSB2YWxpZCBvcHRpb25zIGNhbiBiZSBjb250ZXh0LWRlcGVuZGVudC4gSXQgY291bGQgYmUgc29sdmVkIHdpdGhcbiAgICAgKiBhICpsaXN0KiBvZiB2YWx1ZXMsIGJ1dCB0aGF0IHdvdWxkIGJlIGh1Z2UgY29tcGxleGl0eSBmb3IgbGl0dGxlIGdhaW4uXG4gICAgICovXG4gICAgZGVsZXRlIHRlbXBsYXRlLmxheW91dC50ZW1wbGF0ZTtcbiAgICB2YXIgb2xkVGVtcGxhdGUgPSBsYXlvdXQudGVtcGxhdGU7XG4gICAgaWYoaXNQbGFpbk9iamVjdChvbGRUZW1wbGF0ZSkpIHtcbiAgICAgICAgdmFyIG9sZExheW91dFRlbXBsYXRlID0gb2xkVGVtcGxhdGUubGF5b3V0O1xuXG4gICAgICAgIHZhciBpLCB0cmFjZVR5cGUsIG9sZFR5cGVUZW1wbGF0ZXMsIG9sZFR5cGVMZW4sIHR5cGVUZW1wbGF0ZXMsIHR5cGVMZW47XG5cbiAgICAgICAgaWYoaXNQbGFpbk9iamVjdChvbGRMYXlvdXRUZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIG1lcmdlVGVtcGxhdGVzKG9sZExheW91dFRlbXBsYXRlLCB0ZW1wbGF0ZS5sYXlvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGREYXRhVGVtcGxhdGUgPSBvbGRUZW1wbGF0ZS5kYXRhO1xuICAgICAgICBpZihpc1BsYWluT2JqZWN0KG9sZERhdGFUZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIGZvcih0cmFjZVR5cGUgaW4gdGVtcGxhdGUuZGF0YSkge1xuICAgICAgICAgICAgICAgIG9sZFR5cGVUZW1wbGF0ZXMgPSBvbGREYXRhVGVtcGxhdGVbdHJhY2VUeXBlXTtcbiAgICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KG9sZFR5cGVUZW1wbGF0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVUZW1wbGF0ZXMgPSB0ZW1wbGF0ZS5kYXRhW3RyYWNlVHlwZV07XG4gICAgICAgICAgICAgICAgICAgIHR5cGVMZW4gPSB0eXBlVGVtcGxhdGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgb2xkVHlwZUxlbiA9IG9sZFR5cGVUZW1wbGF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCB0eXBlTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlVGVtcGxhdGVzKG9sZFR5cGVUZW1wbGF0ZXNbaSAlIG9sZFR5cGVMZW5dLCB0eXBlVGVtcGxhdGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IHR5cGVMZW47IGkgPCBvbGRUeXBlTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVUZW1wbGF0ZXMucHVzaChMaWIuZXh0ZW5kRGVlcCh7fSwgb2xkVHlwZVRlbXBsYXRlc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKHRyYWNlVHlwZSBpbiBvbGREYXRhVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICBpZighKHRyYWNlVHlwZSBpbiB0ZW1wbGF0ZS5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5kYXRhW3RyYWNlVHlwZV0gPSBMaWIuZXh0ZW5kRGVlcChbXSwgb2xkRGF0YVRlbXBsYXRlW3RyYWNlVHlwZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbn07XG5cbmZ1bmN0aW9uIG1lcmdlVGVtcGxhdGVzKG9sZFRlbXBsYXRlLCBuZXdUZW1wbGF0ZSkge1xuICAgIC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgc3BlZWQgaGVyZSwganVzdCBtYWtlIHN1cmUgd2UgaGF2ZSBhIHRvdGFsbHlcbiAgICAvLyBkaXN0aW5jdCBvYmplY3QgZnJvbSB0aGUgcHJldmlvdXMgdGVtcGxhdGVcbiAgICBvbGRUZW1wbGF0ZSA9IExpYi5leHRlbmREZWVwKHt9LCBvbGRUZW1wbGF0ZSk7XG5cbiAgICAvLyBzb3J0IGtleXMgc28gd2UgYWx3YXlzIGdldCBhbm5vdGF0aW9uZGVmYXVsdHMgYmVmb3JlIGFubm90YXRpb25zIGV0Y1xuICAgIC8vIHNvIGFycmF5VGVtcGxhdGVyIHdpbGwgd29yayByaWdodFxuICAgIHZhciBvbGRLZXlzID0gT2JqZWN0LmtleXMob2xkVGVtcGxhdGUpLnNvcnQoKTtcbiAgICB2YXIgaSwgajtcblxuICAgIGZ1bmN0aW9uIG1lcmdlT25lKG9sZFZhbCwgbmV3VmFsLCBrZXkpIHtcbiAgICAgICAgaWYoaXNQbGFpbk9iamVjdChuZXdWYWwpICYmIGlzUGxhaW5PYmplY3Qob2xkVmFsKSkge1xuICAgICAgICAgICAgbWVyZ2VUZW1wbGF0ZXMob2xkVmFsLCBuZXdWYWwpO1xuICAgICAgICB9IGVsc2UgaWYoQXJyYXkuaXNBcnJheShuZXdWYWwpICYmIEFycmF5LmlzQXJyYXkob2xkVmFsKSkge1xuICAgICAgICAgICAgLy8gTm90ZTogb21pdHRlZCBgaW5jbHVzaW9uQXR0cmAgZnJvbSBhcnJheVRlbXBsYXRlciBoZXJlLFxuICAgICAgICAgICAgLy8gaXQncyBpcnJlbGV2YW50IGFzIHdlIG9ubHkgd2FudCB0aGUgcmVzdWx0aW5nIGBfdGVtcGxhdGVgLlxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlciA9IFRlbXBsYXRlLmFycmF5VGVtcGxhdGVyKHtfdGVtcGxhdGU6IG9sZFRlbXBsYXRlfSwga2V5KTtcbiAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IG5ld1ZhbC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gbmV3VmFsW2pdO1xuICAgICAgICAgICAgICAgIHZhciBvbGRJdGVtID0gdGVtcGxhdGVyLm5ld0l0ZW0oaXRlbSkuX3RlbXBsYXRlO1xuICAgICAgICAgICAgICAgIGlmKG9sZEl0ZW0pIG1lcmdlVGVtcGxhdGVzKG9sZEl0ZW0sIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlZmF1bHRJdGVtcyA9IHRlbXBsYXRlci5kZWZhdWx0SXRlbXMoKTtcbiAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IGRlZmF1bHRJdGVtcy5sZW5ndGg7IGorKykgbmV3VmFsLnB1c2goZGVmYXVsdEl0ZW1zW2pdLl90ZW1wbGF0ZSk7XG5cbiAgICAgICAgICAgIC8vIHRlbXBsYXRlaXRlbW5hbWUgb25seSBhcHBsaWVzIHRvIHJlY2VpdmluZyBwbG90c1xuICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgbmV3VmFsLmxlbmd0aDsgaisrKSBkZWxldGUgbmV3VmFsW2pdLnRlbXBsYXRlaXRlbW5hbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IoaSA9IDA7IGkgPCBvbGRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBvbGRLZXlzW2ldO1xuICAgICAgICB2YXIgb2xkVmFsID0gb2xkVGVtcGxhdGVba2V5XTtcbiAgICAgICAgaWYoa2V5IGluIG5ld1RlbXBsYXRlKSB7XG4gICAgICAgICAgICBtZXJnZU9uZShvbGRWYWwsIG5ld1RlbXBsYXRlW2tleV0sIGtleSk7XG4gICAgICAgIH0gZWxzZSBuZXdUZW1wbGF0ZVtrZXldID0gb2xkVmFsO1xuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSBiYXNlIGtleSBmcm9tIHRoZSBvbGQgdGVtcGxhdGUgKGVnIHhheGlzKSwgbG9vayBmb3JcbiAgICAgICAgLy8gZXh0ZW5kZWQga2V5cyAoZWcgeGF4aXMyKSBpbiB0aGUgbmV3IHRlbXBsYXRlIHRvIG1lcmdlIGludG9cbiAgICAgICAgaWYoZ2V0QmFzZUtleShrZXkpID09PSBrZXkpIHtcbiAgICAgICAgICAgIGZvcih2YXIga2V5MiBpbiBuZXdUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBiYXNlS2V5MiA9IGdldEJhc2VLZXkoa2V5Mik7XG4gICAgICAgICAgICAgICAgaWYoa2V5MiAhPT0gYmFzZUtleTIgJiYgYmFzZUtleTIgPT09IGtleSAmJiAhKGtleTIgaW4gb2xkVGVtcGxhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlT25lKG9sZFZhbCwgbmV3VGVtcGxhdGVba2V5Ml0sIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRCYXNlS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkucmVwbGFjZSgvWzAtOV0rJC8sICcnKTtcbn1cblxuZnVuY3Rpb24gd2Fsa1N0eWxlS2V5cyhwYXJlbnQsIHRlbXBsYXRlT3V0LCBnZXRBdHRyaWJ1dGVJbmZvLCBwYXRoLCBiYXNlUGF0aCkge1xuICAgIHZhciBwYXRoQXR0ciA9IGJhc2VQYXRoICYmIGdldEF0dHJpYnV0ZUluZm8oYmFzZVBhdGgpO1xuICAgIGZvcih2YXIga2V5IGluIHBhcmVudCkge1xuICAgICAgICB2YXIgY2hpbGQgPSBwYXJlbnRba2V5XTtcbiAgICAgICAgdmFyIG5leHRQYXRoID0gZ2V0TmV4dFBhdGgocGFyZW50LCBrZXksIHBhdGgpO1xuICAgICAgICB2YXIgbmV4dEJhc2VQYXRoID0gZ2V0TmV4dFBhdGgocGFyZW50LCBrZXksIGJhc2VQYXRoKTtcbiAgICAgICAgdmFyIGF0dHIgPSBnZXRBdHRyaWJ1dGVJbmZvKG5leHRCYXNlUGF0aCk7XG4gICAgICAgIGlmKCFhdHRyKSB7XG4gICAgICAgICAgICB2YXIgYmFzZUtleSA9IGdldEJhc2VLZXkoa2V5KTtcbiAgICAgICAgICAgIGlmKGJhc2VLZXkgIT09IGtleSkge1xuICAgICAgICAgICAgICAgIG5leHRCYXNlUGF0aCA9IGdldE5leHRQYXRoKHBhcmVudCwgYmFzZUtleSwgYmFzZVBhdGgpO1xuICAgICAgICAgICAgICAgIGF0dHIgPSBnZXRBdHRyaWJ1dGVJbmZvKG5leHRCYXNlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSdsbCBnZXQgYW4gYXR0ciBpZiBwYXRoIHN0YXJ0cyB3aXRoIGEgdmFsaWQgcGFydCwgdGhlbiBoYXMgYW5cbiAgICAgICAgLy8gaW52YWxpZCBlbmRpbmcuIE1ha2Ugc3VyZSB3ZSBnb3QgYWxsIHRoZSB3YXkgdG8gdGhlIGVuZC5cbiAgICAgICAgaWYocGF0aEF0dHIgJiYgKHBhdGhBdHRyID09PSBhdHRyKSkgY29udGludWU7XG5cbiAgICAgICAgaWYoIWF0dHIgfHwgYXR0ci5fbm9UZW1wbGF0aW5nIHx8XG4gICAgICAgICAgICBhdHRyLnZhbFR5cGUgPT09ICdkYXRhX2FycmF5JyB8fFxuICAgICAgICAgICAgKGF0dHIuYXJyYXlPayAmJiBBcnJheS5pc0FycmF5KGNoaWxkKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFhdHRyLnZhbFR5cGUgJiYgaXNQbGFpbk9iamVjdChjaGlsZCkpIHtcbiAgICAgICAgICAgIHdhbGtTdHlsZUtleXMoY2hpbGQsIHRlbXBsYXRlT3V0LCBnZXRBdHRyaWJ1dGVJbmZvLCBuZXh0UGF0aCwgbmV4dEJhc2VQYXRoKTtcbiAgICAgICAgfSBlbHNlIGlmKGF0dHIuX2lzTGlua2VkVG9BcnJheSAmJiBBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAgICAgdmFyIGRmbHREb25lID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbmFtZWRJbmRleCA9IDA7XG4gICAgICAgICAgICB2YXIgdXNlZE5hbWVzID0ge307XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2hpbGQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGNoaWxkW2ldO1xuICAgICAgICAgICAgICAgIGlmKGlzUGxhaW5PYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBpdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCF1c2VkTmFtZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuYW1lZCBhcnJheSBpdGVtczogYWxsb3cgYWxsIGF0dHJpYnV0ZXMgZXhjZXB0IGRhdGEgYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Fsa1N0eWxlS2V5cyhpdGVtLCB0ZW1wbGF0ZU91dCwgZ2V0QXR0cmlidXRlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TmV4dFBhdGgoY2hpbGQsIG5hbWVkSW5kZXgsIG5leHRQYXRoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TmV4dFBhdGgoY2hpbGQsIG5hbWVkSW5kZXgsIG5leHRCYXNlUGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVkSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkTmFtZXNbbmFtZV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoIWRmbHREb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGZsdEtleSA9IFRlbXBsYXRlLmFycmF5RGVmYXVsdEtleShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRmbHRQYXRoID0gZ2V0TmV4dFBhdGgocGFyZW50LCBkZmx0S2V5LCBwYXRoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0QXR0cmlidXRlSW5mbyB3aWxsIGZhaWwgaWYgd2UgdHJ5IHRvIHVzZSBkZmx0S2V5IGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBwdXQgdGhpcyBpdGVtIGludG8gdGhlIG5leHQgYXJyYXkgZWxlbWVudCwgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVsbCBpdCBvdXQgYW5kIG1vdmUgaXQgdG8gZGZsdEtleS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoSW5BcnJheSA9IGdldE5leHRQYXRoKGNoaWxkLCBuYW1lZEluZGV4LCBuZXh0UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxrU3R5bGVLZXlzKGl0ZW0sIHRlbXBsYXRlT3V0LCBnZXRBdHRyaWJ1dGVJbmZvLCBwYXRoSW5BcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXROZXh0UGF0aChjaGlsZCwgbmFtZWRJbmRleCwgbmV4dEJhc2VQYXRoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbVByb3BJbkFycmF5ID0gTGliLm5lc3RlZFByb3BlcnR5KHRlbXBsYXRlT3V0LCBwYXRoSW5BcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGZsdFByb3AgPSBMaWIubmVzdGVkUHJvcGVydHkodGVtcGxhdGVPdXQsIGRmbHRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRmbHRQcm9wLnNldChpdGVtUHJvcEluQXJyYXkuZ2V0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVByb3BJbkFycmF5LnNldChudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGZsdERvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlUHJvcCA9IExpYi5uZXN0ZWRQcm9wZXJ0eSh0ZW1wbGF0ZU91dCwgbmV4dFBhdGgpO1xuICAgICAgICAgICAgdGVtcGxhdGVQcm9wLnNldChjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldExheW91dEluZm8obGF5b3V0LCBwYXRoKSB7XG4gICAgcmV0dXJuIFBsb3RTY2hlbWEuZ2V0TGF5b3V0VmFsT2JqZWN0KFxuICAgICAgICBsYXlvdXQsIExpYi5uZXN0ZWRQcm9wZXJ0eSh7fSwgcGF0aCkucGFydHNcbiAgICApO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFjZUluZm8odHJhY2UsIHBhdGgpIHtcbiAgICByZXR1cm4gUGxvdFNjaGVtYS5nZXRUcmFjZVZhbE9iamVjdChcbiAgICAgICAgdHJhY2UsIExpYi5uZXN0ZWRQcm9wZXJ0eSh7fSwgcGF0aCkucGFydHNcbiAgICApO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0UGF0aChwYXJlbnQsIGtleSwgcGF0aCkge1xuICAgIHZhciBuZXh0UGF0aDtcbiAgICBpZighcGF0aCkgbmV4dFBhdGggPSBrZXk7XG4gICAgZWxzZSBpZihBcnJheS5pc0FycmF5KHBhcmVudCkpIG5leHRQYXRoID0gcGF0aCArICdbJyArIGtleSArICddJztcbiAgICBlbHNlIG5leHRQYXRoID0gcGF0aCArICcuJyArIGtleTtcblxuICAgIHJldHVybiBuZXh0UGF0aDtcbn1cblxuLyoqXG4gKiB2YWxpZGF0ZVRlbXBsYXRlOiBUZXN0IGZvciBjb25zaXN0ZW5jeSBiZXR3ZWVuIHRoZSBnaXZlbiBmaWd1cmUgYW5kXG4gKiBhIHRlbXBsYXRlLCBlaXRoZXIgYWxyZWFkeSBpbmNsdWRlZCBpbiB0aGUgZmlndXJlIG9yIGdpdmVuIHNlcGFyYXRlbHkuXG4gKiBOb3RlIHRoYXQgbm90IGV2ZXJ5IGlzc3VlIHdlIGlkZW50aWZ5IGhlcmUgaXMgbmVjZXNzYXJpbHkgYSBwcm9ibGVtLFxuICogaXQgZGVwZW5kcyBvbiB3aGF0IHlvdSdyZSB1c2luZyB0aGUgdGVtcGxhdGUgZm9yLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fERPTSBlbGVtZW50fSBmaWd1cmU6IHRoZSBwbG90LCB3aXRoIHtkYXRhLCBsYXlvdXR9IG1lbWJlcnMsXG4gKiAgICAgdG8gdGVzdCB0aGUgdGVtcGxhdGUgYWdhaW5zdFxuICogQHBhcmFtIHtPcHRpb25hbChvYmplY3QpfSB0ZW1wbGF0ZTogdGhlIHRlbXBsYXRlLCB3aXRoIGl0cyBvd24ge2RhdGEsIGxheW91dH0sXG4gKiAgICAgdG8gdGVzdC4gSWYgb21pdHRlZCwgd2Ugd2lsbCBsb29rIGZvciBhIHRlbXBsYXRlIGFscmVhZHkgYXR0YWNoZWQgYXMgdGhlXG4gKiAgICAgcGxvdCdzIGBsYXlvdXQudGVtcGxhdGVgIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcmV0dXJucyB7YXJyYXl9IGFycmF5IG9mIGVycm9yIG9iamVjdHMgZWFjaCBjb250YWluaW5nOlxuICogIC0ge3N0cmluZ30gY29kZVxuICogICAgICBlcnJvciBjb2RlICgnbWlzc2luZycsICd1bnVzZWQnLCAncmV1c2VkJywgJ25vTGF5b3V0JywgJ25vRGF0YScpXG4gKiAgLSB7c3RyaW5nfSBtc2dcbiAqICAgICAgYSBmdWxsIHJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBpc3N1ZS5cbiAqL1xuZXhwb3J0cy52YWxpZGF0ZVRlbXBsYXRlID0gZnVuY3Rpb24oZmlndXJlSW4sIHRlbXBsYXRlKSB7XG4gICAgdmFyIGZpZ3VyZSA9IExpYi5leHRlbmREZWVwKHt9LCB7XG4gICAgICAgIF9jb250ZXh0OiBkZmx0Q29uZmlnLFxuICAgICAgICBkYXRhOiBmaWd1cmVJbi5kYXRhLFxuICAgICAgICBsYXlvdXQ6IGZpZ3VyZUluLmxheW91dFxuICAgIH0pO1xuICAgIHZhciBsYXlvdXQgPSBmaWd1cmUubGF5b3V0IHx8IHt9O1xuICAgIGlmKCFpc1BsYWluT2JqZWN0KHRlbXBsYXRlKSkgdGVtcGxhdGUgPSBsYXlvdXQudGVtcGxhdGUgfHwge307XG4gICAgdmFyIGxheW91dFRlbXBsYXRlID0gdGVtcGxhdGUubGF5b3V0O1xuICAgIHZhciBkYXRhVGVtcGxhdGUgPSB0ZW1wbGF0ZS5kYXRhO1xuICAgIHZhciBlcnJvckxpc3QgPSBbXTtcblxuICAgIGZpZ3VyZS5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgZmlndXJlLmxheW91dC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIFBsb3RzLnN1cHBseURlZmF1bHRzKGZpZ3VyZSk7XG5cbiAgICB2YXIgZnVsbExheW91dCA9IGZpZ3VyZS5fZnVsbExheW91dDtcbiAgICB2YXIgZnVsbERhdGEgPSBmaWd1cmUuX2Z1bGxEYXRhO1xuXG4gICAgdmFyIGxheW91dFBhdGhzID0ge307XG4gICAgZnVuY3Rpb24gY3Jhd2xMYXlvdXRGb3JDb250YWluZXJzKG9iaiwgcGF0aHMpIHtcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZihrZXkuY2hhckF0KDApICE9PSAnXycgJiYgaXNQbGFpbk9iamVjdChvYmpba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZUtleSA9IGdldEJhc2VLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFBhdGhzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBhdGhzLnB1c2goZ2V0TmV4dFBhdGgob2JqLCBrZXksIHBhdGhzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGJhc2VLZXkgIT09IGtleSkgbmV4dFBhdGhzLnB1c2goZ2V0TmV4dFBhdGgob2JqLCBiYXNlS2V5LCBwYXRoc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBuZXh0UGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0UGF0aHNbbmV4dFBhdGhzW2ldXSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNyYXdsTGF5b3V0Rm9yQ29udGFpbmVycyhvYmpba2V5XSwgbmV4dFBhdGhzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyYXdsTGF5b3V0VGVtcGxhdGVGb3JDb250YWluZXJzKG9iaiwgcGF0aCkge1xuICAgICAgICBmb3IodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmKGtleS5pbmRleE9mKCdkZWZhdWx0cycpID09PSAtMSAmJiBpc1BsYWluT2JqZWN0KG9ialtrZXldKSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0UGF0aCA9IGdldE5leHRQYXRoKG9iaiwga2V5LCBwYXRoKTtcbiAgICAgICAgICAgICAgICBpZihsYXlvdXRQYXRoc1tuZXh0UGF0aF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3Jhd2xMYXlvdXRUZW1wbGF0ZUZvckNvbnRhaW5lcnMob2JqW2tleV0sIG5leHRQYXRoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckxpc3QucHVzaCh7Y29kZTogJ3VudXNlZCcsIHBhdGg6IG5leHRQYXRofSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoIWlzUGxhaW5PYmplY3QobGF5b3V0VGVtcGxhdGUpKSB7XG4gICAgICAgIGVycm9yTGlzdC5wdXNoKHtjb2RlOiAnbGF5b3V0J30pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNyYXdsTGF5b3V0Rm9yQ29udGFpbmVycyhmdWxsTGF5b3V0LCBbJ2xheW91dCddKTtcbiAgICAgICAgY3Jhd2xMYXlvdXRUZW1wbGF0ZUZvckNvbnRhaW5lcnMobGF5b3V0VGVtcGxhdGUsICdsYXlvdXQnKTtcbiAgICB9XG5cbiAgICBpZighaXNQbGFpbk9iamVjdChkYXRhVGVtcGxhdGUpKSB7XG4gICAgICAgIGVycm9yTGlzdC5wdXNoKHtjb2RlOiAnZGF0YSd9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdHlwZUNvdW50ID0ge307XG4gICAgICAgIHZhciB0cmFjZVR5cGU7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBmdWxsRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZ1bGxUcmFjZSA9IGZ1bGxEYXRhW2ldO1xuICAgICAgICAgICAgdHJhY2VUeXBlID0gZnVsbFRyYWNlLnR5cGU7XG4gICAgICAgICAgICB0eXBlQ291bnRbdHJhY2VUeXBlXSA9ICh0eXBlQ291bnRbdHJhY2VUeXBlXSB8fCAwKSArIDE7XG4gICAgICAgICAgICBpZighZnVsbFRyYWNlLl9mdWxsSW5wdXQuX3RlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyB0YWtlcyBjYXJlIG9mIHRoZSBjYXNlIG9mIHRyYWNlVHlwZSBpbiB0aGUgZGF0YSBidXQgbm90XG4gICAgICAgICAgICAgICAgLy8gdGhlIHRlbXBsYXRlXG4gICAgICAgICAgICAgICAgZXJyb3JMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAnbWlzc2luZycsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBmdWxsVHJhY2UuX2Z1bGxJbnB1dC5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VUeXBlOiB0cmFjZVR5cGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IodHJhY2VUeXBlIGluIGRhdGFUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlQ291bnQgPSBkYXRhVGVtcGxhdGVbdHJhY2VUeXBlXS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZGF0YUNvdW50ID0gdHlwZUNvdW50W3RyYWNlVHlwZV0gfHwgMDtcbiAgICAgICAgICAgIGlmKHRlbXBsYXRlQ291bnQgPiBkYXRhQ291bnQpIHtcbiAgICAgICAgICAgICAgICBlcnJvckxpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6ICd1bnVzZWQnLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZVR5cGU6IHRyYWNlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVDb3VudDogdGVtcGxhdGVDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YUNvdW50OiBkYXRhQ291bnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihkYXRhQ291bnQgPiB0ZW1wbGF0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgZXJyb3JMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAncmV1c2VkJyxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VUeXBlOiB0cmFjZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlQ291bnQ6IHRlbXBsYXRlQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFDb3VudDogZGF0YUNvdW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBfdGVtcGxhdGU6IGZhbHNlIGlzIHdoZW4gc29tZW9uZSB0cmllZCB0byBtb2RpZnkgYW4gYXJyYXkgaXRlbVxuICAgIC8vIGJ1dCB0aGVyZSB3YXMgbm8gdGVtcGxhdGUgd2l0aCBtYXRjaGluZyBuYW1lXG4gICAgZnVuY3Rpb24gY3Jhd2xGb3JNaXNzaW5nVGVtcGxhdGVzKG9iaiwgcGF0aCkge1xuICAgICAgICBmb3IodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmKGtleS5jaGFyQXQoMCkgPT09ICdfJykgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdmFsID0gb2JqW2tleV07XG4gICAgICAgICAgICB2YXIgbmV4dFBhdGggPSBnZXROZXh0UGF0aChvYmosIGtleSwgcGF0aCk7XG4gICAgICAgICAgICBpZihpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KG9iaikgJiYgdmFsLl90ZW1wbGF0ZSA9PT0gZmFsc2UgJiYgdmFsLnRlbXBsYXRlaXRlbW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogJ21pc3NpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogbmV4dFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZWl0ZW1uYW1lOiB2YWwudGVtcGxhdGVpdGVtbmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3Jhd2xGb3JNaXNzaW5nVGVtcGxhdGVzKHZhbCwgbmV4dFBhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKEFycmF5LmlzQXJyYXkodmFsKSAmJiBoYXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgY3Jhd2xGb3JNaXNzaW5nVGVtcGxhdGVzKHZhbCwgbmV4dFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNyYXdsRm9yTWlzc2luZ1RlbXBsYXRlcyh7ZGF0YTogZnVsbERhdGEsIGxheW91dDogZnVsbExheW91dH0sICcnKTtcblxuICAgIGlmKGVycm9yTGlzdC5sZW5ndGgpIHJldHVybiBlcnJvckxpc3QubWFwKGZvcm1hdCk7XG59O1xuXG5mdW5jdGlvbiBoYXNQbGFpbk9iamVjdChhcnIpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKGlzUGxhaW5PYmplY3QoYXJyW2ldKSkgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXQob3B0cykge1xuICAgIHZhciBtc2c7XG4gICAgc3dpdGNoKG9wdHMuY29kZSkge1xuICAgICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgICAgIG1zZyA9ICdUaGUgdGVtcGxhdGUgaGFzIG5vIGtleSBkYXRhLic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGF5b3V0JzpcbiAgICAgICAgICAgIG1zZyA9ICdUaGUgdGVtcGxhdGUgaGFzIG5vIGtleSBsYXlvdXQuJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaXNzaW5nJzpcbiAgICAgICAgICAgIGlmKG9wdHMucGF0aCkge1xuICAgICAgICAgICAgICAgIG1zZyA9ICdUaGVyZSBhcmUgbm8gdGVtcGxhdGVzIGZvciBpdGVtICcgKyBvcHRzLnBhdGggK1xuICAgICAgICAgICAgICAgICAgICAnIHdpdGggbmFtZSAnICsgb3B0cy50ZW1wbGF0ZWl0ZW1uYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAnVGhlcmUgYXJlIG5vIHRlbXBsYXRlcyBmb3IgdHJhY2UgJyArIG9wdHMuaW5kZXggK1xuICAgICAgICAgICAgICAgICAgICAnLCBvZiB0eXBlICcgKyBvcHRzLnRyYWNlVHlwZSArICcuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd1bnVzZWQnOlxuICAgICAgICAgICAgaWYob3B0cy5wYXRoKSB7XG4gICAgICAgICAgICAgICAgbXNnID0gJ1RoZSB0ZW1wbGF0ZSBpdGVtIGF0ICcgKyBvcHRzLnBhdGggK1xuICAgICAgICAgICAgICAgICAgICAnIHdhcyBub3QgdXNlZCBpbiBjb25zdHJ1Y3RpbmcgdGhlIHBsb3QuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZihvcHRzLmRhdGFDb3VudCkge1xuICAgICAgICAgICAgICAgIG1zZyA9ICdTb21lIG9mIHRoZSB0ZW1wbGF0ZXMgb2YgdHlwZSAnICsgb3B0cy50cmFjZVR5cGUgK1xuICAgICAgICAgICAgICAgICAgICAnIHdlcmUgbm90IHVzZWQuIFRoZSB0ZW1wbGF0ZSBoYXMgJyArIG9wdHMudGVtcGxhdGVDb3VudCArXG4gICAgICAgICAgICAgICAgICAgICcgdHJhY2VzLCB0aGUgZGF0YSBvbmx5IGhhcyAnICsgb3B0cy5kYXRhQ291bnQgK1xuICAgICAgICAgICAgICAgICAgICAnIG9mIHRoaXMgdHlwZS4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAnVGhlIHRlbXBsYXRlIGhhcyAnICsgb3B0cy50ZW1wbGF0ZUNvdW50ICtcbiAgICAgICAgICAgICAgICAgICAgJyB0cmFjZXMgb2YgdHlwZSAnICsgb3B0cy50cmFjZVR5cGUgK1xuICAgICAgICAgICAgICAgICAgICAnIGJ1dCB0aGVyZSBhcmUgbm9uZSBpbiB0aGUgZGF0YS4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JldXNlZCc6XG4gICAgICAgICAgICBtc2cgPSAnU29tZSBvZiB0aGUgdGVtcGxhdGVzIG9mIHR5cGUgJyArIG9wdHMudHJhY2VUeXBlICtcbiAgICAgICAgICAgICAgICAnIHdlcmUgdXNlZCBtb3JlIHRoYW4gb25jZS4gVGhlIHRlbXBsYXRlIGhhcyAnICtcbiAgICAgICAgICAgICAgICBvcHRzLnRlbXBsYXRlQ291bnQgKyAnIHRyYWNlcywgdGhlIGRhdGEgaGFzICcgK1xuICAgICAgICAgICAgICAgIG9wdHMuZGF0YUNvdW50ICsgJyBvZiB0aGlzIHR5cGUuJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvcHRzLm1zZyA9IG1zZztcblxuICAgIHJldHVybiBvcHRzO1xufVxuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNOdW1lcmljID0gcmVxdWlyZSgnZmFzdC1pc251bWVyaWMnKTtcblxudmFyIHBsb3RBcGkgPSByZXF1aXJlKCcuL3Bsb3RfYXBpJyk7XG52YXIgcGxvdHMgPSByZXF1aXJlKCcuLi9wbG90cy9wbG90cycpO1xudmFyIExpYiA9IHJlcXVpcmUoJy4uL2xpYicpO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4uL3NuYXBzaG90L2hlbHBlcnMnKTtcbnZhciB0b1NWRyA9IHJlcXVpcmUoJy4uL3NuYXBzaG90L3Rvc3ZnJyk7XG52YXIgc3ZnVG9JbWcgPSByZXF1aXJlKCcuLi9zbmFwc2hvdC9zdmd0b2ltZycpO1xudmFyIHZlcnNpb24gPSByZXF1aXJlKCcuLi92ZXJzaW9uJykudmVyc2lvbjtcblxudmFyIGF0dHJzID0ge1xuICAgIGZvcm1hdDoge1xuICAgICAgICB2YWxUeXBlOiAnZW51bWVyYXRlZCcsXG4gICAgICAgIHZhbHVlczogWydwbmcnLCAnanBlZycsICd3ZWJwJywgJ3N2ZycsICdmdWxsLWpzb24nXSxcbiAgICAgICAgZGZsdDogJ3BuZycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU2V0cyB0aGUgZm9ybWF0IG9mIGV4cG9ydGVkIGltYWdlLidcbiAgICB9LFxuICAgIHdpZHRoOiB7XG4gICAgICAgIHZhbFR5cGU6ICdudW1iZXInLFxuICAgICAgICBtaW46IDEsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU2V0cyB0aGUgZXhwb3J0ZWQgaW1hZ2Ugd2lkdGguJyxcbiAgICAgICAgICAgICdEZWZhdWx0cyB0byB0aGUgdmFsdWUgZm91bmQgaW4gYGxheW91dC53aWR0aGAnLFxuICAgICAgICAgICAgJ0lmIHNldCB0byAqbnVsbCosIHRoZSBleHBvcnRlZCBpbWFnZSB3aWR0aCB3aWxsIG1hdGNoIHRoZSBjdXJyZW50IGdyYXBoIHdpZHRoLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgICB2YWxUeXBlOiAnbnVtYmVyJyxcbiAgICAgICAgbWluOiAxLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1NldHMgdGhlIGV4cG9ydGVkIGltYWdlIGhlaWdodC4nLFxuICAgICAgICAgICAgJ0RlZmF1bHRzIHRvIHRoZSB2YWx1ZSBmb3VuZCBpbiBgbGF5b3V0LmhlaWdodGAnLFxuICAgICAgICAgICAgJ0lmIHNldCB0byAqbnVsbCosIHRoZSBleHBvcnRlZCBpbWFnZSBoZWlnaHQgd2lsbCBtYXRjaCB0aGUgY3VycmVudCBncmFwaCBoZWlnaHQuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgc2NhbGU6IHtcbiAgICAgICAgdmFsVHlwZTogJ251bWJlcicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgZGZsdDogMSxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIGEgc2NhbGluZyBmb3IgdGhlIGdlbmVyYXRlZCBpbWFnZS4nLFxuICAgICAgICAgICAgJ0lmIHNldCwgYWxsIGZlYXR1cmVzIG9mIGEgZ3JhcGhzIChlLmcuIHRleHQsIGxpbmUgd2lkdGgpJyxcbiAgICAgICAgICAgICdhcmUgc2NhbGVkLCB1bmxpa2Ugc2ltcGx5IHNldHRpbmcnLFxuICAgICAgICAgICAgJ2EgYmlnZ2VyICp3aWR0aCogYW5kICpoZWlnaHQqLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9LFxuICAgIHNldEJhY2tncm91bmQ6IHtcbiAgICAgICAgdmFsVHlwZTogJ2FueScsXG4gICAgICAgIGRmbHQ6IGZhbHNlLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1NldHMgdGhlIGltYWdlIGJhY2tncm91bmQgbW9kZS4nLFxuICAgICAgICAgICAgJ0J5IGRlZmF1bHQsIHRoZSBpbWFnZSBiYWNrZ3JvdW5kIGlzIGRldGVybWluZWQgYnkgYGxheW91dC5wYXBlcl9iZ2NvbG9yYCwnLFxuICAgICAgICAgICAgJ3RoZSAqdHJhbnNwYXJlbnQqIG1vZGUuJyxcbiAgICAgICAgICAgICdPbmUgbWlnaHQgY29uc2lkZXIgc2V0dGluZyBgc2V0QmFja2dyb3VuZGAgdG8gKm9wYXF1ZSonLFxuICAgICAgICAgICAgJ3doZW4gZXhwb3J0aW5nIGEgKmpwZWcqIGltYWdlIGFzIEpQRUdzIGRvIG5vdCBzdXBwb3J0IG9wYWNpdHkuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgaW1hZ2VEYXRhT25seToge1xuICAgICAgICB2YWxUeXBlOiAnYm9vbGVhbicsXG4gICAgICAgIGRmbHQ6IGZhbHNlLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ0RldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIHJldHVybiB2YWx1ZSBpcyBwcmVmaXhlZCBieScsXG4gICAgICAgICAgICAndGhlIGltYWdlIGZvcm1hdFxcJ3MgY29ycmVzcG9uZGluZyBcXCdkYXRhOmltYWdlO1xcJyBzcGVjLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9XG59O1xuXG4vKiogUGxvdGx5LnRvSW1hZ2VcbiAqXG4gKiBAcGFyYW0ge29iamVjdCB8IHN0cmluZyB8IEhUTUwgZGl2fSBnZFxuICogICBjYW4gZWl0aGVyIGJlIGEgZGF0YS9sYXlvdXQvY29uZmlnIG9iamVjdFxuICogICBvciBhbiBleGlzdGluZyBncmFwaCA8ZGl2PlxuICogICBvciBhbiBpZCB0byBhbiBleGlzdGluZyBncmFwaCA8ZGl2PlxuICogQHBhcmFtIHtvYmplY3R9IG9wdHMgKHNlZSBhYm92ZSlcbiAqIEByZXR1cm4ge3Byb21pc2V9XG4gKi9cbmZ1bmN0aW9uIHRvSW1hZ2UoZ2QsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHZhciBkYXRhO1xuICAgIHZhciBsYXlvdXQ7XG4gICAgdmFyIGNvbmZpZztcbiAgICB2YXIgZnVsbExheW91dDtcblxuICAgIGlmKExpYi5pc1BsYWluT2JqZWN0KGdkKSkge1xuICAgICAgICBkYXRhID0gZ2QuZGF0YSB8fCBbXTtcbiAgICAgICAgbGF5b3V0ID0gZ2QubGF5b3V0IHx8IHt9O1xuICAgICAgICBjb25maWcgPSBnZC5jb25maWcgfHwge307XG4gICAgICAgIGZ1bGxMYXlvdXQgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZCA9IExpYi5nZXRHcmFwaERpdihnZCk7XG4gICAgICAgIGRhdGEgPSBMaWIuZXh0ZW5kRGVlcChbXSwgZ2QuZGF0YSk7XG4gICAgICAgIGxheW91dCA9IExpYi5leHRlbmREZWVwKHt9LCBnZC5sYXlvdXQpO1xuICAgICAgICBjb25maWcgPSBnZC5fY29udGV4dDtcbiAgICAgICAgZnVsbExheW91dCA9IGdkLl9mdWxsTGF5b3V0IHx8IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW1wbGllZE9yVmFsaWQoYXR0cikge1xuICAgICAgICByZXR1cm4gIShhdHRyIGluIG9wdHMpIHx8IExpYi52YWxpZGF0ZShvcHRzW2F0dHJdLCBhdHRyc1thdHRyXSk7XG4gICAgfVxuXG4gICAgaWYoKCFpc0ltcGxpZWRPclZhbGlkKCd3aWR0aCcpICYmIG9wdHMud2lkdGggIT09IG51bGwpIHx8XG4gICAgICAgICghaXNJbXBsaWVkT3JWYWxpZCgnaGVpZ2h0JykgJiYgb3B0cy5oZWlnaHQgIT09IG51bGwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGVpZ2h0IGFuZCB3aWR0aCBzaG91bGQgYmUgcGl4ZWwgdmFsdWVzLicpO1xuICAgIH1cblxuICAgIGlmKCFpc0ltcGxpZWRPclZhbGlkKCdmb3JtYXQnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGZvcm1hdCBpcyBub3QganBlZywgcG5nLCBzdmcgb3Igd2VicC4nKTtcbiAgICB9XG5cbiAgICB2YXIgZnVsbE9wdHMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGNvZXJjZShhdHRyLCBkZmx0KSB7XG4gICAgICAgIHJldHVybiBMaWIuY29lcmNlKG9wdHMsIGZ1bGxPcHRzLCBhdHRycywgYXR0ciwgZGZsdCk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdCA9IGNvZXJjZSgnZm9ybWF0Jyk7XG4gICAgdmFyIHdpZHRoID0gY29lcmNlKCd3aWR0aCcpO1xuICAgIHZhciBoZWlnaHQgPSBjb2VyY2UoJ2hlaWdodCcpO1xuICAgIHZhciBzY2FsZSA9IGNvZXJjZSgnc2NhbGUnKTtcbiAgICB2YXIgc2V0QmFja2dyb3VuZCA9IGNvZXJjZSgnc2V0QmFja2dyb3VuZCcpO1xuICAgIHZhciBpbWFnZURhdGFPbmx5ID0gY29lcmNlKCdpbWFnZURhdGFPbmx5Jyk7XG5cbiAgICAvLyBwdXQgdGhlIGNsb25lZCBkaXYgc29tZXdoZXJlIG9mZiBzY3JlZW4gYmVmb3JlIGF0dGFjaGluZyB0byBET01cbiAgICB2YXIgY2xvbmVkR2QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjbG9uZWRHZC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgY2xvbmVkR2Quc3R5bGUubGVmdCA9ICctNTAwMHB4JztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNsb25lZEdkKTtcblxuICAgIC8vIGV4dGVuZCBsYXlvdXQgd2l0aCBpbWFnZSBvcHRpb25zXG4gICAgdmFyIGxheW91dEltYWdlID0gTGliLmV4dGVuZEZsYXQoe30sIGxheW91dCk7XG4gICAgaWYod2lkdGgpIHtcbiAgICAgICAgbGF5b3V0SW1hZ2Uud2lkdGggPSB3aWR0aDtcbiAgICB9IGVsc2UgaWYob3B0cy53aWR0aCA9PT0gbnVsbCAmJiBpc051bWVyaWMoZnVsbExheW91dC53aWR0aCkpIHtcbiAgICAgICAgbGF5b3V0SW1hZ2Uud2lkdGggPSBmdWxsTGF5b3V0LndpZHRoO1xuICAgIH1cbiAgICBpZihoZWlnaHQpIHtcbiAgICAgICAgbGF5b3V0SW1hZ2UuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0gZWxzZSBpZihvcHRzLmhlaWdodCA9PT0gbnVsbCAmJiBpc051bWVyaWMoZnVsbExheW91dC5oZWlnaHQpKSB7XG4gICAgICAgIGxheW91dEltYWdlLmhlaWdodCA9IGZ1bGxMYXlvdXQuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCBjb25maWcgZm9yIHN0YXRpYyBwbG90XG4gICAgdmFyIGNvbmZpZ0ltYWdlID0gTGliLmV4dGVuZEZsYXQoe30sIGNvbmZpZywge1xuICAgICAgICBfZXhwb3J0ZWRQbG90OiB0cnVlLFxuICAgICAgICBzdGF0aWNQbG90OiB0cnVlLFxuICAgICAgICBzZXRCYWNrZ3JvdW5kOiBzZXRCYWNrZ3JvdW5kXG4gICAgfSk7XG5cbiAgICB2YXIgcmVkcmF3RnVuYyA9IGhlbHBlcnMuZ2V0UmVkcmF3RnVuYyhjbG9uZWRHZCk7XG5cbiAgICBmdW5jdGlvbiB3YWl0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBoZWxwZXJzLmdldERlbGF5KGNsb25lZEdkLl9mdWxsTGF5b3V0KSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBzdmcgPSB0b1NWRyhjbG9uZWRHZCwgZm9ybWF0LCBzY2FsZSk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBjbG9uZWRHZC5fZnVsbExheW91dC53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBjbG9uZWRHZC5fZnVsbExheW91dC5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgICAgICAgICAgcGxvdEFwaS5wdXJnZShjbG9uZWRHZCk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjbG9uZWRHZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGZvcm1hdCA9PT0gJ2Z1bGwtanNvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IHBsb3RzLmdyYXBoSnNvbihjbG9uZWRHZCwgZmFsc2UsICdrZWVwZGF0YScsICdvYmplY3QnLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBqc29uLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgIGpzb24gPSBKU09OLnN0cmluZ2lmeShqc29uKTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgaWYoaW1hZ2VEYXRhT25seSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShqc29uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShoZWxwZXJzLmVuY29kZUpTT04oanNvbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgICBpZihmb3JtYXQgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgaWYoaW1hZ2VEYXRhT25seSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShzdmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGhlbHBlcnMuZW5jb2RlU1ZHKHN2ZykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY2FudmFzLmlkID0gTGliLnJhbmRzdHIoKTtcblxuICAgICAgICAgICAgc3ZnVG9JbWcoe1xuICAgICAgICAgICAgICAgIGZvcm1hdDogZm9ybWF0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICAgICAgICAgICAgc3ZnOiBzdmcsXG4gICAgICAgICAgICAgICAgLy8gYXNrIHN2Z1RvSW1nIHRvIHJldHVybiBhIFByb21pc2VcbiAgICAgICAgICAgICAgICAvLyAgcmF0aGVyIHRoYW4gRXZlbnRFbWl0dGVyXG4gICAgICAgICAgICAgICAgLy8gIGxlYXZlIEV2ZW50RW1pdHRlciBmb3IgYmFja3dhcmRcbiAgICAgICAgICAgICAgICAvLyAgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgIHByb21pc2U6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVybFRvSW1hZ2VEYXRhKHVybCkge1xuICAgICAgICBpZihpbWFnZURhdGFPbmx5KSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsLnJlcGxhY2UoaGVscGVycy5JTUFHRV9VUkxfUFJFRklYLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwbG90QXBpLnBsb3QoY2xvbmVkR2QsIGRhdGEsIGxheW91dEltYWdlLCBjb25maWdJbWFnZSlcbiAgICAgICAgICAgIC50aGVuKHJlZHJhd0Z1bmMpXG4gICAgICAgICAgICAudGhlbih3YWl0KVxuICAgICAgICAgICAgLnRoZW4oY29udmVydClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHVybCkgeyByZXNvbHZlKHVybFRvSW1hZ2VEYXRhKHVybCkpOyB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikgeyByZWplY3QoZXJyKTsgfSk7XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9JbWFnZTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uL2xpYicpO1xudmFyIFBsb3RzID0gcmVxdWlyZSgnLi4vcGxvdHMvcGxvdHMnKTtcbnZhciBQbG90U2NoZW1hID0gcmVxdWlyZSgnLi9wbG90X3NjaGVtYScpO1xudmFyIGRmbHRDb25maWcgPSByZXF1aXJlKCcuL3Bsb3RfY29uZmlnJykuZGZsdENvbmZpZztcblxudmFyIGlzUGxhaW5PYmplY3QgPSBMaWIuaXNQbGFpbk9iamVjdDtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBpc0FycmF5T3JUeXBlZEFycmF5ID0gTGliLmlzQXJyYXlPclR5cGVkQXJyYXk7XG5cbi8qKlxuICogVmFsaWRhdGUgYSBkYXRhIGFycmF5IGFuZCBsYXlvdXQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBsYXlvdXRcbiAqXG4gKiBAcmV0dXJuIHthcnJheX0gYXJyYXkgb2YgZXJyb3Igb2JqZWN0cyBlYWNoIGNvbnRhaW5pbmc6XG4gKiAgLSB7c3RyaW5nfSBjb2RlXG4gKiAgICAgIGVycm9yIGNvZGUgKCdvYmplY3QnLCAnYXJyYXknLCAnc2NoZW1hJywgJ3VudXNlZCcsICdpbnZpc2libGUnIG9yICd2YWx1ZScpXG4gKiAgLSB7c3RyaW5nfSBjb250YWluZXJcbiAqICAgICAgY29udGFpbmVyIHdoZXJlIHRoZSBlcnJvciBvY2N1cnMgKCdkYXRhJyBvciAnbGF5b3V0JylcbiAqICAtIHtudW1iZXJ9IHRyYWNlXG4gKiAgICAgIHRyYWNlIGluZGV4IG9mIHRoZSAnZGF0YScgY29udGFpbmVyIHdoZXJlIHRoZSBlcnJvciBvY2N1cnNcbiAqICAtIHthcnJheX0gcGF0aFxuICogICAgICBuZXN0ZWQgcGF0aCB0byB0aGUga2V5IHRoYXQgY2F1c2VzIHRoZSBlcnJvclxuICogIC0ge3N0cmluZ30gYXN0clxuICogICAgICBhdHRyaWJ1dGUgc3RyaW5nIHZhcmlhbnQgb2YgJ3BhdGgnIGNvbXBhdGlibGUgd2l0aCBQbG90bHkucmVzdHlsZSBhbmRcbiAqICAgICAgUGxvdGx5LnJlbGF5b3V0LlxuICogIC0ge3N0cmluZ30gbXNnXG4gKiAgICAgIGVycm9yIG1lc3NhZ2UgKHNob3duIGluIGNvbnNvbGUgaW4gbG9nZ2VyIGNvbmZpZyBhcmd1bWVudCBpcyBlbmFibGUpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGUoZGF0YSwgbGF5b3V0KSB7XG4gICAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSBkYXRhID0gW107XG4gICAgaWYobGF5b3V0ID09PSB1bmRlZmluZWQpIGxheW91dCA9IHt9O1xuXG4gICAgdmFyIHNjaGVtYSA9IFBsb3RTY2hlbWEuZ2V0KCk7XG4gICAgdmFyIGVycm9yTGlzdCA9IFtdO1xuICAgIHZhciBnZCA9IHtfY29udGV4dDogTGliLmV4dGVuZEZsYXQoe30sIGRmbHRDb25maWcpfTtcblxuICAgIHZhciBkYXRhSW4sIGxheW91dEluO1xuXG4gICAgaWYoaXNBcnJheShkYXRhKSkge1xuICAgICAgICBnZC5kYXRhID0gTGliLmV4dGVuZERlZXAoW10sIGRhdGEpO1xuICAgICAgICBkYXRhSW4gPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdkLmRhdGEgPSBbXTtcbiAgICAgICAgZGF0YUluID0gW107XG4gICAgICAgIGVycm9yTGlzdC5wdXNoKGZvcm1hdCgnYXJyYXknLCAnZGF0YScpKTtcbiAgICB9XG5cbiAgICBpZihpc1BsYWluT2JqZWN0KGxheW91dCkpIHtcbiAgICAgICAgZ2QubGF5b3V0ID0gTGliLmV4dGVuZERlZXAoe30sIGxheW91dCk7XG4gICAgICAgIGxheW91dEluID0gbGF5b3V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdkLmxheW91dCA9IHt9O1xuICAgICAgICBsYXlvdXRJbiA9IHt9O1xuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZXJyb3JMaXN0LnB1c2goZm9ybWF0KCdvYmplY3QnLCAnbGF5b3V0JykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTi5CLiBkYXRhSW4gYW5kIGxheW91dEluIGFyZSBpbiBnZW5lcmFsIG5vdCB0aGUgc2FtZSBhc1xuICAgIC8vIGdkLmRhdGEgYW5kIGdkLmxheW91dCBhZnRlciBzdXBwbHlEZWZhdWx0cyBhcyBzb21lIGF0dHJpYnV0ZXNcbiAgICAvLyBpbiBnZC5kYXRhIGFuZCBnZC5sYXlvdXQgKHN0aWxsKSBnZXQgbXV0YXRlZCBkdXJpbmcgdGhpcyBzdGVwLlxuXG4gICAgUGxvdHMuc3VwcGx5RGVmYXVsdHMoZ2QpO1xuXG4gICAgdmFyIGRhdGFPdXQgPSBnZC5fZnVsbERhdGE7XG4gICAgdmFyIGxlbiA9IGRhdGFJbi5sZW5ndGg7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYWNlSW4gPSBkYXRhSW5baV07XG4gICAgICAgIHZhciBiYXNlID0gWydkYXRhJywgaV07XG5cbiAgICAgICAgaWYoIWlzUGxhaW5PYmplY3QodHJhY2VJbikpIHtcbiAgICAgICAgICAgIGVycm9yTGlzdC5wdXNoKGZvcm1hdCgnb2JqZWN0JywgYmFzZSkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhY2VPdXQgPSBkYXRhT3V0W2ldO1xuICAgICAgICB2YXIgdHJhY2VUeXBlID0gdHJhY2VPdXQudHlwZTtcbiAgICAgICAgdmFyIHRyYWNlU2NoZW1hID0gc2NoZW1hLnRyYWNlc1t0cmFjZVR5cGVdLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgLy8gUGxvdFNjaGVtYSBkb2VzIHNvbWV0aGluZyBmYW5jeSB3aXRoIHRyYWNlICd0eXBlJywgcmVzZXQgaXQgaGVyZVxuICAgICAgICAvLyB0byBtYWtlIHRoZSB0cmFjZSBzY2hlbWEgY29tcGF0aWJsZSB3aXRoIExpYi52YWxpZGF0ZS5cbiAgICAgICAgdHJhY2VTY2hlbWEudHlwZSA9IHtcbiAgICAgICAgICAgIHZhbFR5cGU6ICdlbnVtZXJhdGVkJyxcbiAgICAgICAgICAgIHZhbHVlczogW3RyYWNlVHlwZV1cbiAgICAgICAgfTtcblxuICAgICAgICBpZih0cmFjZU91dC52aXNpYmxlID09PSBmYWxzZSAmJiB0cmFjZUluLnZpc2libGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBlcnJvckxpc3QucHVzaChmb3JtYXQoJ2ludmlzaWJsZScsIGJhc2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNyYXdsKHRyYWNlSW4sIHRyYWNlT3V0LCB0cmFjZVNjaGVtYSwgZXJyb3JMaXN0LCBiYXNlKTtcblxuICAgICAgICB2YXIgdHJhbnNmb3Jtc0luID0gdHJhY2VJbi50cmFuc2Zvcm1zO1xuICAgICAgICB2YXIgdHJhbnNmb3Jtc091dCA9IHRyYWNlT3V0LnRyYW5zZm9ybXM7XG5cbiAgICAgICAgaWYodHJhbnNmb3Jtc0luKSB7XG4gICAgICAgICAgICBpZighaXNBcnJheSh0cmFuc2Zvcm1zSW4pKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JMaXN0LnB1c2goZm9ybWF0KCdhcnJheScsIGJhc2UsIFsndHJhbnNmb3JtcyddKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhc2UucHVzaCgndHJhbnNmb3JtcycpO1xuXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgdHJhbnNmb3Jtc0luLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBbJ3RyYW5zZm9ybXMnLCBqXTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtVHlwZSA9IHRyYW5zZm9ybXNJbltqXS50eXBlO1xuXG4gICAgICAgICAgICAgICAgaWYoIWlzUGxhaW5PYmplY3QodHJhbnNmb3Jtc0luW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckxpc3QucHVzaChmb3JtYXQoJ29iamVjdCcsIGJhc2UsIHBhdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybVNjaGVtYSA9IHNjaGVtYS50cmFuc2Zvcm1zW3RyYW5zZm9ybVR5cGVdID9cbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hLnRyYW5zZm9ybXNbdHJhbnNmb3JtVHlwZV0uYXR0cmlidXRlcyA6XG4gICAgICAgICAgICAgICAgICAgIHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gYWRkICd0eXBlJyB0byB0cmFuc2Zvcm0gc2NoZW1hIHRvIHZhbGlkYXRlIHRoZSB0cmFuc2Zvcm0gdHlwZVxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVNjaGVtYS50eXBlID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWxUeXBlOiAnZW51bWVyYXRlZCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogT2JqZWN0LmtleXMoc2NoZW1hLnRyYW5zZm9ybXMpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNyYXdsKHRyYW5zZm9ybXNJbltqXSwgdHJhbnNmb3Jtc091dFtqXSwgdHJhbnNmb3JtU2NoZW1hLCBlcnJvckxpc3QsIGJhc2UsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxheW91dE91dCA9IGdkLl9mdWxsTGF5b3V0O1xuICAgIHZhciBsYXlvdXRTY2hlbWEgPSBmaWxsTGF5b3V0U2NoZW1hKHNjaGVtYSwgZGF0YU91dCk7XG5cbiAgICBjcmF3bChsYXlvdXRJbiwgbGF5b3V0T3V0LCBsYXlvdXRTY2hlbWEsIGVycm9yTGlzdCwgJ2xheW91dCcpO1xuXG4gICAgLy8gcmV0dXJuIHVuZGVmaW5lZCBpZiBubyB2YWxpZGF0aW9uIGVycm9ycyB3ZXJlIGZvdW5kXG4gICAgcmV0dXJuIChlcnJvckxpc3QubGVuZ3RoID09PSAwKSA/IHZvaWQoMCkgOiBlcnJvckxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjcmF3bChvYmpJbiwgb2JqT3V0LCBzY2hlbWEsIGxpc3QsIGJhc2UsIHBhdGgpIHtcbiAgICBwYXRoID0gcGF0aCB8fCBbXTtcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqSW4pO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW2ldO1xuXG4gICAgICAgIC8vIHRyYW5zZm9ybXMgYXJlIGhhbmRsZWQgc2VwYXJhdGVseVxuICAgICAgICBpZihrID09PSAndHJhbnNmb3JtcycpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgICAgICBwLnB1c2goayk7XG5cbiAgICAgICAgdmFyIHZhbEluID0gb2JqSW5ba107XG4gICAgICAgIHZhciB2YWxPdXQgPSBvYmpPdXRba107XG5cbiAgICAgICAgdmFyIG5lc3RlZFNjaGVtYSA9IGdldE5lc3RlZFNjaGVtYShzY2hlbWEsIGspO1xuICAgICAgICB2YXIgbmVzdGVkVmFsVHlwZSA9IChuZXN0ZWRTY2hlbWEgfHwge30pLnZhbFR5cGU7XG4gICAgICAgIHZhciBpc0luZm9BcnJheSA9IG5lc3RlZFZhbFR5cGUgPT09ICdpbmZvX2FycmF5JztcbiAgICAgICAgdmFyIGlzQ29sb3JzY2FsZSA9IG5lc3RlZFZhbFR5cGUgPT09ICdjb2xvcnNjYWxlJztcbiAgICAgICAgdmFyIGl0ZW1zID0gKG5lc3RlZFNjaGVtYSB8fCB7fSkuaXRlbXM7XG5cbiAgICAgICAgaWYoIWlzSW5TY2hlbWEoc2NoZW1hLCBrKSkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKGZvcm1hdCgnc2NoZW1hJywgYmFzZSwgcCkpO1xuICAgICAgICB9IGVsc2UgaWYoaXNQbGFpbk9iamVjdCh2YWxJbikgJiYgaXNQbGFpbk9iamVjdCh2YWxPdXQpICYmIG5lc3RlZFZhbFR5cGUgIT09ICdhbnknKSB7XG4gICAgICAgICAgICBjcmF3bCh2YWxJbiwgdmFsT3V0LCBuZXN0ZWRTY2hlbWEsIGxpc3QsIGJhc2UsIHApO1xuICAgICAgICB9IGVsc2UgaWYoaXNJbmZvQXJyYXkgJiYgaXNBcnJheSh2YWxJbikpIHtcbiAgICAgICAgICAgIGlmKHZhbEluLmxlbmd0aCA+IHZhbE91dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goZm9ybWF0KCd1bnVzZWQnLCBiYXNlLCBwLmNvbmNhdCh2YWxPdXQubGVuZ3RoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlbiA9IHZhbE91dC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYXJyYXlJdGVtcyA9IEFycmF5LmlzQXJyYXkoaXRlbXMpO1xuICAgICAgICAgICAgaWYoYXJyYXlJdGVtcykgbGVuID0gTWF0aC5taW4obGVuLCBpdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIG0sIG4sIGl0ZW0sIHZhbEluUGFydCwgdmFsT3V0UGFydDtcbiAgICAgICAgICAgIGlmKG5lc3RlZFNjaGVtYS5kaW1lbnNpb25zID09PSAyKSB7XG4gICAgICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNBcnJheSh2YWxJbltuXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHZhbEluW25dLmxlbmd0aCA+IHZhbE91dFtuXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goZm9ybWF0KCd1bnVzZWQnLCBiYXNlLCBwLmNvbmNhdChuLCB2YWxPdXRbbl0ubGVuZ3RoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbjIgPSB2YWxPdXRbbl0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKG0gPSAwOyBtIDwgKGFycmF5SXRlbXMgPyBNYXRoLm1pbihsZW4yLCBpdGVtc1tuXS5sZW5ndGgpIDogbGVuMik7IG0rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBhcnJheUl0ZW1zID8gaXRlbXNbbl1bbV0gOiBpdGVtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxJblBhcnQgPSB2YWxJbltuXVttXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxPdXRQYXJ0ID0gdmFsT3V0W25dW21dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFMaWIudmFsaWRhdGUodmFsSW5QYXJ0LCBpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goZm9ybWF0KCd2YWx1ZScsIGJhc2UsIHAuY29uY2F0KG4sIG0pLCB2YWxJblBhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYodmFsT3V0UGFydCAhPT0gdmFsSW5QYXJ0ICYmIHZhbE91dFBhcnQgIT09ICt2YWxJblBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKGZvcm1hdCgnZHluYW1pYycsIGJhc2UsIHAuY29uY2F0KG4sIG0pLCB2YWxJblBhcnQsIHZhbE91dFBhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goZm9ybWF0KCdhcnJheScsIGJhc2UsIHAuY29uY2F0KG4pLCB2YWxJbltuXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gYXJyYXlJdGVtcyA/IGl0ZW1zW25dIDogaXRlbXM7XG4gICAgICAgICAgICAgICAgICAgIHZhbEluUGFydCA9IHZhbEluW25dO1xuICAgICAgICAgICAgICAgICAgICB2YWxPdXRQYXJ0ID0gdmFsT3V0W25dO1xuICAgICAgICAgICAgICAgICAgICBpZighTGliLnZhbGlkYXRlKHZhbEluUGFydCwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChmb3JtYXQoJ3ZhbHVlJywgYmFzZSwgcC5jb25jYXQobiksIHZhbEluUGFydCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYodmFsT3V0UGFydCAhPT0gdmFsSW5QYXJ0ICYmIHZhbE91dFBhcnQgIT09ICt2YWxJblBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChmb3JtYXQoJ2R5bmFtaWMnLCBiYXNlLCBwLmNvbmNhdChuKSwgdmFsSW5QYXJ0LCB2YWxPdXRQYXJ0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihuZXN0ZWRTY2hlbWEuaXRlbXMgJiYgIWlzSW5mb0FycmF5ICYmIGlzQXJyYXkodmFsSW4pKSB7XG4gICAgICAgICAgICB2YXIgX25lc3RlZFNjaGVtYSA9IGl0ZW1zW09iamVjdC5rZXlzKGl0ZW1zKVswXV07XG4gICAgICAgICAgICB2YXIgaW5kZXhMaXN0ID0gW107XG5cbiAgICAgICAgICAgIHZhciBqLCBfcDtcblxuICAgICAgICAgICAgLy8gbG9vcCBvdmVyIHZhbE91dCBpdGVtcyB3aGlsZSBrZWVwaW5nIHRyYWNrIG9mIHRoZWlyXG4gICAgICAgICAgICAvLyBjb3JyZXNwb25kaW5nIGlucHV0IGNvbnRhaW5lciBpbmRleCAoZ2l2ZW4gYnkgX2luZGV4KVxuICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgdmFsT3V0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9pbmRleCA9IHZhbE91dFtqXS5faW5kZXggfHwgajtcblxuICAgICAgICAgICAgICAgIF9wID0gcC5zbGljZSgpO1xuICAgICAgICAgICAgICAgIF9wLnB1c2goX2luZGV4KTtcblxuICAgICAgICAgICAgICAgIGlmKGlzUGxhaW5PYmplY3QodmFsSW5bX2luZGV4XSkgJiYgaXNQbGFpbk9iamVjdCh2YWxPdXRbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4TGlzdC5wdXNoKF9pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWxJbmogPSB2YWxJbltfaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsT3V0aiA9IHZhbE91dFtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNQbGFpbk9iamVjdCh2YWxJbmopICYmIHZhbEluai52aXNpYmxlICE9PSBmYWxzZSAmJiB2YWxPdXRqLnZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goZm9ybWF0KCdpbnZpc2libGUnLCBiYXNlLCBfcCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgY3Jhd2wodmFsSW5qLCB2YWxPdXRqLCBfbmVzdGVkU2NoZW1hLCBsaXN0LCBiYXNlLCBfcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBsb29wIG92ZXIgdmFsSW4gdG8gZGV0ZXJtaW5lIHdoZXJlIGl0IHdlbnQgd3JvbmcgZm9yIHNvbWUgaXRlbXNcbiAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IHZhbEluLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgX3AgPSBwLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgX3AucHVzaChqKTtcblxuICAgICAgICAgICAgICAgIGlmKCFpc1BsYWluT2JqZWN0KHZhbEluW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goZm9ybWF0KCdvYmplY3QnLCBiYXNlLCBfcCwgdmFsSW5bal0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoaW5kZXhMaXN0LmluZGV4T2YoaikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChmb3JtYXQoJ3VudXNlZCcsIGJhc2UsIF9wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIWlzUGxhaW5PYmplY3QodmFsSW4pICYmIGlzUGxhaW5PYmplY3QodmFsT3V0KSkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKGZvcm1hdCgnb2JqZWN0JywgYmFzZSwgcCwgdmFsSW4pKTtcbiAgICAgICAgfSBlbHNlIGlmKCFpc0FycmF5T3JUeXBlZEFycmF5KHZhbEluKSAmJiBpc0FycmF5T3JUeXBlZEFycmF5KHZhbE91dCkgJiYgIWlzSW5mb0FycmF5ICYmICFpc0NvbG9yc2NhbGUpIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChmb3JtYXQoJ2FycmF5JywgYmFzZSwgcCwgdmFsSW4pKTtcbiAgICAgICAgfSBlbHNlIGlmKCEoayBpbiBvYmpPdXQpKSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goZm9ybWF0KCd1bnVzZWQnLCBiYXNlLCBwLCB2YWxJbikpO1xuICAgICAgICB9IGVsc2UgaWYoIUxpYi52YWxpZGF0ZSh2YWxJbiwgbmVzdGVkU2NoZW1hKSkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKGZvcm1hdCgndmFsdWUnLCBiYXNlLCBwLCB2YWxJbikpO1xuICAgICAgICB9IGVsc2UgaWYobmVzdGVkU2NoZW1hLnZhbFR5cGUgPT09ICdlbnVtZXJhdGVkJyAmJlxuICAgICAgICAgICAgKChuZXN0ZWRTY2hlbWEuY29lcmNlTnVtYmVyICYmIHZhbEluICE9PSArdmFsT3V0KSB8fCB2YWxJbiAhPT0gdmFsT3V0KVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChmb3JtYXQoJ2R5bmFtaWMnLCBiYXNlLCBwLCB2YWxJbiwgdmFsT3V0KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gdGhlICdmdWxsJyBsYXlvdXQgc2NoZW1hIGRlcGVuZHMgb24gdGhlIHRyYWNlcyB0eXBlcyBwcmVzZW50c1xuZnVuY3Rpb24gZmlsbExheW91dFNjaGVtYShzY2hlbWEsIGRhdGFPdXQpIHtcbiAgICB2YXIgbGF5b3V0U2NoZW1hID0gc2NoZW1hLmxheW91dC5sYXlvdXRBdHRyaWJ1dGVzO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGRhdGFPdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYWNlT3V0ID0gZGF0YU91dFtpXTtcbiAgICAgICAgdmFyIHRyYWNlU2NoZW1hID0gc2NoZW1hLnRyYWNlc1t0cmFjZU91dC50eXBlXTtcbiAgICAgICAgdmFyIHRyYWNlTGF5b3V0QXR0ciA9IHRyYWNlU2NoZW1hLmxheW91dEF0dHJpYnV0ZXM7XG5cbiAgICAgICAgaWYodHJhY2VMYXlvdXRBdHRyKSB7XG4gICAgICAgICAgICBpZih0cmFjZU91dC5zdWJwbG90KSB7XG4gICAgICAgICAgICAgICAgTGliLmV4dGVuZEZsYXQobGF5b3V0U2NoZW1hW3RyYWNlU2NoZW1hLmF0dHJpYnV0ZXMuc3VicGxvdC5kZmx0XSwgdHJhY2VMYXlvdXRBdHRyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgTGliLmV4dGVuZEZsYXQobGF5b3V0U2NoZW1hLCB0cmFjZUxheW91dEF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheW91dFNjaGVtYTtcbn1cblxuLy8gdmFsaWRhdGlvbiBlcnJvciBjb2Rlc1xudmFyIGNvZGUybXNnRnVuYyA9IHtcbiAgICBvYmplY3Q6IGZ1bmN0aW9uKGJhc2UsIGFzdHIpIHtcbiAgICAgICAgdmFyIHByZWZpeDtcblxuICAgICAgICBpZihiYXNlID09PSAnbGF5b3V0JyAmJiBhc3RyID09PSAnJykgcHJlZml4ID0gJ1RoZSBsYXlvdXQgYXJndW1lbnQnO1xuICAgICAgICBlbHNlIGlmKGJhc2VbMF0gPT09ICdkYXRhJyAmJiBhc3RyID09PSAnJykge1xuICAgICAgICAgICAgcHJlZml4ID0gJ1RyYWNlICcgKyBiYXNlWzFdICsgJyBpbiB0aGUgZGF0YSBhcmd1bWVudCc7XG4gICAgICAgIH0gZWxzZSBwcmVmaXggPSBpbkJhc2UoYmFzZSkgKyAna2V5ICcgKyBhc3RyO1xuXG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnIG11c3QgYmUgbGlua2VkIHRvIGFuIG9iamVjdCBjb250YWluZXInO1xuICAgIH0sXG4gICAgYXJyYXk6IGZ1bmN0aW9uKGJhc2UsIGFzdHIpIHtcbiAgICAgICAgdmFyIHByZWZpeDtcblxuICAgICAgICBpZihiYXNlID09PSAnZGF0YScpIHByZWZpeCA9ICdUaGUgZGF0YSBhcmd1bWVudCc7XG4gICAgICAgIGVsc2UgcHJlZml4ID0gaW5CYXNlKGJhc2UpICsgJ2tleSAnICsgYXN0cjtcblxuICAgICAgICByZXR1cm4gcHJlZml4ICsgJyBtdXN0IGJlIGxpbmtlZCB0byBhbiBhcnJheSBjb250YWluZXInO1xuICAgIH0sXG4gICAgc2NoZW1hOiBmdW5jdGlvbihiYXNlLCBhc3RyKSB7XG4gICAgICAgIHJldHVybiBpbkJhc2UoYmFzZSkgKyAna2V5ICcgKyBhc3RyICsgJyBpcyBub3QgcGFydCBvZiB0aGUgc2NoZW1hJztcbiAgICB9LFxuICAgIHVudXNlZDogZnVuY3Rpb24oYmFzZSwgYXN0ciwgdmFsSW4pIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGlzUGxhaW5PYmplY3QodmFsSW4pID8gJ2NvbnRhaW5lcicgOiAna2V5JztcblxuICAgICAgICByZXR1cm4gaW5CYXNlKGJhc2UpICsgdGFyZ2V0ICsgJyAnICsgYXN0ciArICcgZGlkIG5vdCBnZXQgY29lcmNlZCc7XG4gICAgfSxcbiAgICBkeW5hbWljOiBmdW5jdGlvbihiYXNlLCBhc3RyLCB2YWxJbiwgdmFsT3V0KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBpbkJhc2UoYmFzZSkgKyAna2V5JyxcbiAgICAgICAgICAgIGFzdHIsXG4gICAgICAgICAgICAnKHNldCB0byBcXCcnICsgdmFsSW4gKyAnXFwnKScsXG4gICAgICAgICAgICAnZ290IHJlc2V0IHRvJyxcbiAgICAgICAgICAgICdcXCcnICsgdmFsT3V0ICsgJ1xcJycsXG4gICAgICAgICAgICAnZHVyaW5nIGRlZmF1bHRzLidcbiAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgfSxcbiAgICBpbnZpc2libGU6IGZ1bmN0aW9uKGJhc2UsIGFzdHIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGFzdHIgPyAoaW5CYXNlKGJhc2UpICsgJ2l0ZW0gJyArIGFzdHIpIDogKCdUcmFjZSAnICsgYmFzZVsxXSlcbiAgICAgICAgKSArICcgZ290IGRlZmF1bHRlZCB0byBiZSBub3QgdmlzaWJsZSc7XG4gICAgfSxcbiAgICB2YWx1ZTogZnVuY3Rpb24oYmFzZSwgYXN0ciwgdmFsSW4pIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGluQmFzZShiYXNlKSArICdrZXkgJyArIGFzdHIsXG4gICAgICAgICAgICAnaXMgc2V0IHRvIGFuIGludmFsaWQgdmFsdWUgKCcgKyB2YWxJbiArICcpJ1xuICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBpbkJhc2UoYmFzZSkge1xuICAgIGlmKGlzQXJyYXkoYmFzZSkpIHJldHVybiAnSW4gZGF0YSB0cmFjZSAnICsgYmFzZVsxXSArICcsICc7XG5cbiAgICByZXR1cm4gJ0luICcgKyBiYXNlICsgJywgJztcbn1cblxuZnVuY3Rpb24gZm9ybWF0KGNvZGUsIGJhc2UsIHBhdGgsIHZhbEluLCB2YWxPdXQpIHtcbiAgICBwYXRoID0gcGF0aCB8fCAnJztcblxuICAgIHZhciBjb250YWluZXIsIHRyYWNlO1xuXG4gICAgLy8gY29udGFpbmVyIGlzIGVpdGhlciAnZGF0YScgb3IgJ2xheW91dFxuICAgIC8vIHRyYWNlIGlzIHRoZSB0cmFjZSBpbmRleCBpZiAnZGF0YScsIG51bGwgb3RoZXJ3aXNlXG5cbiAgICBpZihpc0FycmF5KGJhc2UpKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGJhc2VbMF07XG4gICAgICAgIHRyYWNlID0gYmFzZVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIgPSBiYXNlO1xuICAgICAgICB0cmFjZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGFzdHIgPSBjb252ZXJ0UGF0aFRvQXR0cmlidXRlU3RyaW5nKHBhdGgpO1xuICAgIHZhciBtc2cgPSBjb2RlMm1zZ0Z1bmNbY29kZV0oYmFzZSwgYXN0ciwgdmFsSW4sIHZhbE91dCk7XG5cbiAgICAvLyBsb2cgdG8gY29uc29sZSBpZiBsb2dnZXIgY29uZmlnIG9wdGlvbiBpcyBlbmFibGVkXG4gICAgTGliLmxvZyhtc2cpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIHRyYWNlOiB0cmFjZSxcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgYXN0cjogYXN0cixcbiAgICAgICAgbXNnOiBtc2dcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpc0luU2NoZW1hKHNjaGVtYSwga2V5KSB7XG4gICAgdmFyIHBhcnRzID0gc3BsaXRLZXkoa2V5KTtcbiAgICB2YXIga2V5TWludXNJZCA9IHBhcnRzLmtleU1pbnVzSWQ7XG4gICAgdmFyIGlkID0gcGFydHMuaWQ7XG5cbiAgICBpZigoa2V5TWludXNJZCBpbiBzY2hlbWEpICYmIHNjaGVtYVtrZXlNaW51c0lkXS5faXNTdWJwbG90T2JqICYmIGlkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiAoa2V5IGluIHNjaGVtYSk7XG59XG5cbmZ1bmN0aW9uIGdldE5lc3RlZFNjaGVtYShzY2hlbWEsIGtleSkge1xuICAgIGlmKGtleSBpbiBzY2hlbWEpIHJldHVybiBzY2hlbWFba2V5XTtcblxuICAgIHZhciBwYXJ0cyA9IHNwbGl0S2V5KGtleSk7XG5cbiAgICByZXR1cm4gc2NoZW1hW3BhcnRzLmtleU1pbnVzSWRdO1xufVxuXG52YXIgaWRSZWdleCA9IExpYi5jb3VudGVyUmVnZXgoJyhbYS16XSspJyk7XG5cbmZ1bmN0aW9uIHNwbGl0S2V5KGtleSkge1xuICAgIHZhciBpZE1hdGNoID0ga2V5Lm1hdGNoKGlkUmVnZXgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5TWludXNJZDogaWRNYXRjaCAmJiBpZE1hdGNoWzFdLFxuICAgICAgICBpZDogaWRNYXRjaCAmJiBpZE1hdGNoWzJdXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydFBhdGhUb0F0dHJpYnV0ZVN0cmluZyhwYXRoKSB7XG4gICAgaWYoIWlzQXJyYXkocGF0aCkpIHJldHVybiBTdHJpbmcocGF0aCk7XG5cbiAgICB2YXIgYXN0ciA9ICcnO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBwYXRoW2ldO1xuXG4gICAgICAgIGlmKHR5cGVvZiBwID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYXN0ciA9IGFzdHIuc3Vic3RyKDAsIGFzdHIubGVuZ3RoIC0gMSkgKyAnWycgKyBwICsgJ10nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXN0ciArPSBwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoaSA8IHBhdGgubGVuZ3RoIC0gMSkgYXN0ciArPSAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzdHI7XG59XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi4vLi4vcmVnaXN0cnknKTtcbnZhciBMaWIgPSByZXF1aXJlKCcuLi8uLi9saWInKTtcblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBjaGVja2luZyBjb21wb25lbnQgYXJyYXlzIGZvciBzdWJwbG90IHJlZmVyZW5jZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRhaW5lckFycmF5TmFtZTogdGhlIHRvcC1sZXZlbCBhcnJheSBpbiBnZC5sYXlvdXQgdG8gY2hlY2tcbiAqICAgSWYgYW4gaXRlbSBpbiB0aGlzIGNvbnRhaW5lciBpcyBmb3VuZCB0aGF0IHJlZmVyZW5jZXMgYSBjYXJ0ZXNpYW4geCBhbmQvb3IgeSBheGlzLFxuICogICBlbnN1cmUgY2FydGVzaWFuIGlzIG1hcmtlZCBhcyBhIGJhc2UgcGxvdCBtb2R1bGUgYW5kIHJlY29yZCB0aGUgYXhlcyAoYW5kIHN1YnBsb3RcbiAqICAgaWYgYm90aCByZWZzIGFyZSBheGVzKSBpbiBnZC5fZnVsbExheW91dFxuICpcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufTogd2l0aCBhcmdzIGxheW91dEluIChnZC5sYXlvdXQpIGFuZCBsYXlvdXRPdXQgKGdkLl9mdWxsTGF5b3V0KVxuICogYXMgZXhwZWN0ZWQgb2YgYSBjb21wb25lbnQgaW5jbHVkZUJhc2VQbG90IG1ldGhvZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1ha2VJbmNsdWRlQ29tcG9uZW50cyhjb250YWluZXJBcnJheU5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaW5jbHVkZUNvbXBvbmVudHMobGF5b3V0SW4sIGxheW91dE91dCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBsYXlvdXRJbltjb250YWluZXJBcnJheU5hbWVdO1xuICAgICAgICBpZighQXJyYXkuaXNBcnJheShhcnJheSkpIHJldHVybjtcblxuICAgICAgICB2YXIgQ2FydGVzaWFuID0gUmVnaXN0cnkuc3VicGxvdHNSZWdpc3RyeS5jYXJ0ZXNpYW47XG4gICAgICAgIHZhciBpZFJlZ2V4ID0gQ2FydGVzaWFuLmlkUmVnZXg7XG4gICAgICAgIHZhciBzdWJwbG90cyA9IGxheW91dE91dC5fc3VicGxvdHM7XG4gICAgICAgIHZhciB4YUxpc3QgPSBzdWJwbG90cy54YXhpcztcbiAgICAgICAgdmFyIHlhTGlzdCA9IHN1YnBsb3RzLnlheGlzO1xuICAgICAgICB2YXIgY2FydGVzaWFuTGlzdCA9IHN1YnBsb3RzLmNhcnRlc2lhbjtcbiAgICAgICAgdmFyIGhhc0NhcnRlc2lhbk9yR0wyRCA9IGxheW91dE91dC5faGFzKCdjYXJ0ZXNpYW4nKSB8fCBsYXlvdXRPdXQuX2hhcygnZ2wyZCcpO1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW1pID0gYXJyYXlbaV07XG4gICAgICAgICAgICBpZighTGliLmlzUGxhaW5PYmplY3QoaXRlbWkpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIHhyZWYgPSBpdGVtaS54cmVmO1xuICAgICAgICAgICAgdmFyIHlyZWYgPSBpdGVtaS55cmVmO1xuXG4gICAgICAgICAgICB2YXIgaGFzWHJlZiA9IGlkUmVnZXgueC50ZXN0KHhyZWYpO1xuICAgICAgICAgICAgdmFyIGhhc1lyZWYgPSBpZFJlZ2V4LnkudGVzdCh5cmVmKTtcbiAgICAgICAgICAgIGlmKGhhc1hyZWYgfHwgaGFzWXJlZikge1xuICAgICAgICAgICAgICAgIGlmKCFoYXNDYXJ0ZXNpYW5PckdMMkQpIExpYi5wdXNoVW5pcXVlKGxheW91dE91dC5fYmFzZVBsb3RNb2R1bGVzLCBDYXJ0ZXNpYW4pO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5ld0F4aXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZihoYXNYcmVmICYmIHhhTGlzdC5pbmRleE9mKHhyZWYpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB4YUxpc3QucHVzaCh4cmVmKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3QXhpcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGhhc1lyZWYgJiYgeWFMaXN0LmluZGV4T2YoeXJlZikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHlhTGlzdC5wdXNoKHlyZWYpO1xuICAgICAgICAgICAgICAgICAgICBuZXdBeGlzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIE5vdGljZSB0aGUgbG9naWMgaGVyZTogb25seSBhZGQgYSBzdWJwbG90IGZvciBhIGNvbXBvbmVudCBpZlxuICAgICAgICAgICAgICAgICAqIGl0J3MgcmVmZXJlbmNpbmcgYm90aCB4IGFuZCB5IGF4ZXMgQU5EIGl0J3MgY3JlYXRpbmcgYSBuZXcgYXhpc1xuICAgICAgICAgICAgICAgICAqIHNvIGZvciBleGFtcGxlIGlmIHlvdXIgcGxvdCBhbHJlYWR5IGhhcyB4eSBhbmQgeDJ5MiwgYW4gYW5ub3RhdGlvblxuICAgICAgICAgICAgICAgICAqIG9uIHgyeSBvciB4eTIgd2lsbCBub3QgY3JlYXRlIGEgbmV3IHN1YnBsb3QuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYobmV3QXhpcyAmJiBoYXNYcmVmICYmIGhhc1lyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FydGVzaWFuTGlzdC5wdXNoKHhyZWYgKyB5cmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiB4Zm9ybU1hdHJpeChtLCB2KSB7XG4gICAgdmFyIG91dCA9IFswLCAwLCAwLCAwXTtcbiAgICB2YXIgaSwgajtcblxuICAgIGZvcihpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICBmb3IoaiA9IDA7IGogPCA0OyArK2opIHtcbiAgICAgICAgICAgIG91dFtqXSArPSBtWzQgKiBpICsgal0gKiB2W2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gcHJvamVjdChjYW1lcmEsIHYpIHtcbiAgICB2YXIgcCA9IHhmb3JtTWF0cml4KGNhbWVyYS5wcm9qZWN0aW9uLFxuICAgICAgICB4Zm9ybU1hdHJpeChjYW1lcmEudmlldyxcbiAgICAgICAgeGZvcm1NYXRyaXgoY2FtZXJhLm1vZGVsLCBbdlswXSwgdlsxXSwgdlsyXSwgMV0pKSk7XG4gICAgcmV0dXJuIHA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvamVjdDtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi4vcmVnaXN0cnknKTtcbnZhciBMaWIgPSByZXF1aXJlKCcuLi9saWInKTtcblxudmFyIGV4dGVuZEZsYXQgPSBMaWIuZXh0ZW5kRmxhdDtcbnZhciBleHRlbmREZWVwID0gTGliLmV4dGVuZERlZXA7XG5cbi8vIFB1dCBkZWZhdWx0IHBsb3RUaWxlIGxheW91dHMgaGVyZVxuZnVuY3Rpb24gY2xvbmVMYXlvdXRPdmVycmlkZSh0aWxlQ2xhc3MpIHtcbiAgICB2YXIgb3ZlcnJpZGU7XG5cbiAgICBzd2l0Y2godGlsZUNsYXNzKSB7XG4gICAgICAgIGNhc2UgJ3RoZW1lc19fdGh1bWInOlxuICAgICAgICAgICAgb3ZlcnJpZGUgPSB7XG4gICAgICAgICAgICAgICAgYXV0b3NpemU6IHRydWUsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDE1MCxcbiAgICAgICAgICAgICAgICB0aXRsZToge3RleHQ6ICcnfSxcbiAgICAgICAgICAgICAgICBzaG93bGVnZW5kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtYXJnaW46IHtsOiA1LCByOiA1LCB0OiA1LCBiOiA1LCBwYWQ6IDB9LFxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RodW1ibmFpbCc6XG4gICAgICAgICAgICBvdmVycmlkZSA9IHtcbiAgICAgICAgICAgICAgICB0aXRsZToge3RleHQ6ICcnfSxcbiAgICAgICAgICAgICAgICBoaWRlc291cmNlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaG93bGVnZW5kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBib3JkZXJ3aWR0aDogMCxcbiAgICAgICAgICAgICAgICBib3JkZXJjb2xvcjogJycsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiB7bDogMSwgcjogMSwgdDogMSwgYjogMSwgcGFkOiAwfSxcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgb3ZlcnJpZGUgPSB7fTtcbiAgICB9XG5cblxuICAgIHJldHVybiBvdmVycmlkZTtcbn1cblxuZnVuY3Rpb24ga2V5SXNBeGlzKGtleU5hbWUpIHtcbiAgICB2YXIgdHlwZXMgPSBbJ3hheGlzJywgJ3lheGlzJywgJ3pheGlzJ107XG4gICAgcmV0dXJuICh0eXBlcy5pbmRleE9mKGtleU5hbWUuc2xpY2UoMCwgNSkpID4gLTEpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2xvbmVQbG90KGdyYXBoT2JqLCBvcHRpb25zKSB7XG4gICAgLy8gUG9sYXIgcGxvdCBjb21wYXRpYmlsaXR5XG4gICAgaWYoZ3JhcGhPYmouZnJhbWV3b3JrICYmIGdyYXBoT2JqLmZyYW1ld29yay5pc1BvbGFyKSB7XG4gICAgICAgIGdyYXBoT2JqID0gZ3JhcGhPYmouZnJhbWV3b3JrLmdldENvbmZpZygpO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBvbGREYXRhID0gZ3JhcGhPYmouZGF0YTtcbiAgICB2YXIgb2xkTGF5b3V0ID0gZ3JhcGhPYmoubGF5b3V0O1xuICAgIHZhciBuZXdEYXRhID0gZXh0ZW5kRGVlcChbXSwgb2xkRGF0YSk7XG4gICAgdmFyIG5ld0xheW91dCA9IGV4dGVuZERlZXAoe30sIG9sZExheW91dCwgY2xvbmVMYXlvdXRPdmVycmlkZShvcHRpb25zLnRpbGVDbGFzcykpO1xuICAgIHZhciBjb250ZXh0ID0gZ3JhcGhPYmouX2NvbnRleHQgfHwge307XG5cbiAgICBpZihvcHRpb25zLndpZHRoKSBuZXdMYXlvdXQud2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgIGlmKG9wdGlvbnMuaGVpZ2h0KSBuZXdMYXlvdXQuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG5cbiAgICBpZihvcHRpb25zLnRpbGVDbGFzcyA9PT0gJ3RodW1ibmFpbCcgfHwgb3B0aW9ucy50aWxlQ2xhc3MgPT09ICd0aGVtZXNfX3RodW1iJykge1xuICAgICAgICAvLyBraWxsIGFubm90YXRpb25zXG4gICAgICAgIG5ld0xheW91dC5hbm5vdGF0aW9ucyA9IFtdO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5ld0xheW91dCk7XG5cbiAgICAgICAgZm9yKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYoa2V5SXNBeGlzKGtleXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgbmV3TGF5b3V0W2tleXNbaV1dLnRpdGxlID0ge3RleHQ6ICcnfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGtpbGwgY29sb3JiYXIgYW5kIHBpZSBsYWJlbHNcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbmV3RGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRyYWNlID0gbmV3RGF0YVtpXTtcbiAgICAgICAgICAgIHRyYWNlLnNob3dzY2FsZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYodHJhY2UubWFya2VyKSB0cmFjZS5tYXJrZXIuc2hvd3NjYWxlID0gZmFsc2U7XG4gICAgICAgICAgICBpZihSZWdpc3RyeS50cmFjZUlzKHRyYWNlLCAncGllLWxpa2UnKSkgdHJhY2UudGV4dHBvc2l0aW9uID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoQXJyYXkuaXNBcnJheShvcHRpb25zLmFubm90YXRpb25zKSkge1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBvcHRpb25zLmFubm90YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdMYXlvdXQuYW5ub3RhdGlvbnMucHVzaChvcHRpb25zLmFubm90YXRpb25zW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IGRvZXMgdGhpcyBzY2VuZSBtb2RpZmljYXRpb24gcmVhbGx5IGJlbG9uZyBoZXJlP1xuICAgIC8vIElmIHdlIHN0aWxsIG5lZWQgaXQsIGNhbiBpdCBtb3ZlIGludG8gdGhlIGdsM2QgbW9kdWxlP1xuICAgIHZhciBzY2VuZUlkcyA9IE9iamVjdC5rZXlzKG5ld0xheW91dCkuZmlsdGVyKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5Lm1hdGNoKC9ec2NlbmVcXGQqJC8pO1xuICAgIH0pO1xuICAgIGlmKHNjZW5lSWRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgYXhlc0ltYWdlT3ZlcnJpZGUgPSB7fTtcbiAgICAgICAgaWYob3B0aW9ucy50aWxlQ2xhc3MgPT09ICd0aHVtYm5haWwnKSB7XG4gICAgICAgICAgICBheGVzSW1hZ2VPdmVycmlkZSA9IHtcbiAgICAgICAgICAgICAgICB0aXRsZToge3RleHQ6ICcnfSxcbiAgICAgICAgICAgICAgICBzaG93YXhlc2xhYmVsczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd3RpY2tsYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxpbmV0aWNrZW5hYmxlOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBzY2VuZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNjZW5lID0gbmV3TGF5b3V0W3NjZW5lSWRzW2ldXTtcblxuICAgICAgICAgICAgaWYoIXNjZW5lLnhheGlzKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUueGF4aXMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIXNjZW5lLnlheGlzKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUueWF4aXMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIXNjZW5lLnpheGlzKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUuemF4aXMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXh0ZW5kRmxhdChzY2VuZS54YXhpcywgYXhlc0ltYWdlT3ZlcnJpZGUpO1xuICAgICAgICAgICAgZXh0ZW5kRmxhdChzY2VuZS55YXhpcywgYXhlc0ltYWdlT3ZlcnJpZGUpO1xuICAgICAgICAgICAgZXh0ZW5kRmxhdChzY2VuZS56YXhpcywgYXhlc0ltYWdlT3ZlcnJpZGUpO1xuXG4gICAgICAgICAgICAvLyBUT0RPIHdoYXQgZG9lcyB0aGlzIGRvP1xuICAgICAgICAgICAgc2NlbmUuX3NjZW5lID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGlmKG9wdGlvbnMudGlsZUNsYXNzKSBnZC5jbGFzc05hbWUgPSBvcHRpb25zLnRpbGVDbGFzcztcblxuICAgIHZhciBwbG90VGlsZSA9IHtcbiAgICAgICAgZ2Q6IGdkLFxuICAgICAgICB0ZDogZ2QsIC8vIGZvciBleHRlcm5hbCAoaW1hZ2Ugc2VydmVyKSBjb21wYXRpYmlsaXR5XG4gICAgICAgIGxheW91dDogbmV3TGF5b3V0LFxuICAgICAgICBkYXRhOiBuZXdEYXRhLFxuICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgIHN0YXRpY1Bsb3Q6IChvcHRpb25zLnN0YXRpY1Bsb3QgPT09IHVuZGVmaW5lZCkgP1xuICAgICAgICAgICAgICAgIHRydWUgOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdGljUGxvdCxcbiAgICAgICAgICAgIHBsb3RHbFBpeGVsUmF0aW86IChvcHRpb25zLnBsb3RHbFBpeGVsUmF0aW8gPT09IHVuZGVmaW5lZCkgP1xuICAgICAgICAgICAgICAgIDIgOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGxvdEdsUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIGRpc3BsYXlsb2dvOiBvcHRpb25zLmRpc3BsYXlsb2dvIHx8IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0xpbms6IG9wdGlvbnMuc2hvd0xpbmsgfHwgZmFsc2UsXG4gICAgICAgICAgICBzaG93VGlwczogb3B0aW9ucy5zaG93VGlwcyB8fCBmYWxzZSxcbiAgICAgICAgICAgIG1hcGJveEFjY2Vzc1Rva2VuOiBjb250ZXh0Lm1hcGJveEFjY2Vzc1Rva2VuXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYob3B0aW9ucy5zZXRCYWNrZ3JvdW5kICE9PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgIHBsb3RUaWxlLmNvbmZpZy5zZXRCYWNrZ3JvdW5kID0gb3B0aW9ucy5zZXRCYWNrZ3JvdW5kIHx8ICdvcGFxdWUnO1xuICAgIH1cblxuICAgIC8vIGF0dGFjaGluZyB0aGUgZGVmYXVsdCBMYXlvdXQgdGhlIGdkLCBzbyB5b3UgY2FuIGdyYWIgaXQgbGF0ZXJcbiAgICBwbG90VGlsZS5nZC5kZWZhdWx0TGF5b3V0ID0gY2xvbmVMYXlvdXRPdmVycmlkZShvcHRpb25zLnRpbGVDbGFzcyk7XG5cbiAgICByZXR1cm4gcGxvdFRpbGU7XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGliID0gcmVxdWlyZSgnLi4vbGliJyk7XG5cbnZhciB0b0ltYWdlID0gcmVxdWlyZSgnLi4vcGxvdF9hcGkvdG9faW1hZ2UnKTtcblxudmFyIGZpbGVTYXZlciA9IHJlcXVpcmUoJy4vZmlsZXNhdmVyJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG4vKipcbiAqIFBsb3RseS5kb3dubG9hZEltYWdlXG4gKlxuICogQHBhcmFtIHtvYmplY3QgfCBzdHJpbmcgfCBIVE1MIGRpdn0gZ2RcbiAqICAgY2FuIGVpdGhlciBiZSBhIGRhdGEvbGF5b3V0L2NvbmZpZyBvYmplY3RcbiAqICAgb3IgYW4gZXhpc3RpbmcgZ3JhcGggPGRpdj5cbiAqICAgb3IgYW4gaWQgdG8gYW4gZXhpc3RpbmcgZ3JhcGggPGRpdj5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIChzZWUgUGxvdGx5LnRvSW1hZ2UgaW4gLi4vcGxvdF9hcGkvdG9faW1hZ2UpXG4gKiBAcmV0dXJuIHtwcm9taXNlfVxuICovXG5mdW5jdGlvbiBkb3dubG9hZEltYWdlKGdkLCBvcHRzKSB7XG4gICAgdmFyIF9nZDtcbiAgICBpZighTGliLmlzUGxhaW5PYmplY3QoZ2QpKSBfZ2QgPSBMaWIuZ2V0R3JhcGhEaXYoZ2QpO1xuXG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgb3B0cy5mb3JtYXQgPSBvcHRzLmZvcm1hdCB8fCAncG5nJztcbiAgICBvcHRzLmltYWdlRGF0YU9ubHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZihfZ2QgJiYgX2dkLl9zbmFwc2hvdEluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1NuYXBzaG90dGluZyBhbHJlYWR5IGluIHByb2dyZXNzLicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlZSBjb21tZW50cyB3aXRoaW4gc3ZndG9pbWcgZm9yIGFkZGl0aW9uYWxcbiAgICAgICAgLy8gICBkaXNjdXNzaW9uIG9mIHByb2JsZW1zIHdpdGggSUVcbiAgICAgICAgLy8gICBjYW4gbm93IGRyYXcgdG8gY2FudmFzLCBidXQgQ09SUyB0YWludGVkIGNhbnZhc1xuICAgICAgICAvLyAgIGRvZXMgbm90IGFsbG93IHRvRGF0YVVSTFxuICAgICAgICAvLyAgIHN2ZyBmb3JtYXQgd2lsbCB3b3JrIHRob3VnaFxuICAgICAgICBpZihMaWIuaXNJRSgpICYmIG9wdHMuZm9ybWF0ICE9PSAnc3ZnJykge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihoZWxwZXJzLk1TR19JRV9CQURfRk9STUFUKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihfZ2QpIF9nZC5fc25hcHNob3RJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0b0ltYWdlKGdkLCBvcHRzKTtcblxuICAgICAgICB2YXIgZmlsZW5hbWUgPSBvcHRzLmZpbGVuYW1lIHx8IGdkLmZuIHx8ICduZXdwbG90JztcbiAgICAgICAgZmlsZW5hbWUgKz0gJy4nICsgb3B0cy5mb3JtYXQucmVwbGFjZSgnLScsICcuJyk7XG5cbiAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYoX2dkKSBfZ2QuX3NuYXBzaG90SW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVTYXZlcihyZXN1bHQsIGZpbGVuYW1lLCBvcHRzLmZvcm1hdCk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShuYW1lKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpZihfZ2QpIF9nZC5fc25hcHNob3RJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG93bmxvYWRJbWFnZTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uL2xpYicpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxuLypcbiogc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhpcyBjb2RlIGZyb20gRmlsZVNhdmVyLmpzXG4qIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L0ZpbGVTYXZlci5qc1xuKiBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vZWxpZ3JleS9GaWxlU2F2ZXIuanMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuKiBGaWxlU2F2ZXIuanNcbiogQSBzYXZlQXMoKSBGaWxlU2F2ZXIgaW1wbGVtZW50YXRpb24uXG4qIDEuMS4yMDE2MDMyOFxuKlxuKiBCeSBFbGkgR3JleSwgaHR0cDovL2VsaWdyZXkuY29tXG4qIExpY2Vuc2U6IE1JVFxuKiAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZWxpZ3JleS9GaWxlU2F2ZXIuanMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuKi9cbmZ1bmN0aW9uIGZpbGVTYXZlcih1cmwsIG5hbWUsIGZvcm1hdCkge1xuICAgIHZhciBzYXZlTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB2YXIgY2FuVXNlU2F2ZUxpbmsgPSAnZG93bmxvYWQnIGluIHNhdmVMaW5rO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGJsb2I7XG4gICAgICAgIHZhciBvYmplY3RVcmw7XG5cbiAgICAgICAgaWYoTGliLmlzSUU5b3JCZWxvdygpKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdJRSA8IDEwIHVuc3VwcG9ydGVkJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgYWxsb3cgZG93bmxvYWRpbmcgb2YgYmxvYiB1cmxzXG4gICAgICAgIGlmKExpYi5pc1NhZmFyaSgpKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gZm9ybWF0ID09PSAnc3ZnJyA/ICcsJyA6ICc7YmFzZTY0LCc7XG4gICAgICAgICAgICBoZWxwZXJzLm9jdGV0U3RyZWFtKHByZWZpeCArIGVuY29kZVVSSUNvbXBvbmVudCh1cmwpKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSUUgMTArIChuYXRpdmUgc2F2ZUFzKVxuICAgICAgICBpZihMaWIuaXNJRSgpKSB7XG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGFyZSBvbmx5IGRlYWxpbmcgd2l0aCBhIGRlY29kZWQgU1ZHIGFzXG4gICAgICAgICAgICAvLyBhIGRhdGEgVVJMIChzaW5jZSBJRSBvbmx5IHN1cHBvcnRzIFNWRylcbiAgICAgICAgICAgIGJsb2IgPSBoZWxwZXJzLmNyZWF0ZUJsb2IodXJsLCAnc3ZnJyk7XG4gICAgICAgICAgICB3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZUJsb2IoYmxvYiwgbmFtZSk7XG4gICAgICAgICAgICBibG9iID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoY2FuVXNlU2F2ZUxpbmspIHtcbiAgICAgICAgICAgIGJsb2IgPSBoZWxwZXJzLmNyZWF0ZUJsb2IodXJsLCBmb3JtYXQpO1xuICAgICAgICAgICAgb2JqZWN0VXJsID0gaGVscGVycy5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cbiAgICAgICAgICAgIHNhdmVMaW5rLmhyZWYgPSBvYmplY3RVcmw7XG4gICAgICAgICAgICBzYXZlTGluay5kb3dubG9hZCA9IG5hbWU7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNhdmVMaW5rKTtcbiAgICAgICAgICAgIHNhdmVMaW5rLmNsaWNrKCk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2F2ZUxpbmspO1xuICAgICAgICAgICAgaGVscGVycy5yZXZva2VPYmplY3RVUkwob2JqZWN0VXJsKTtcbiAgICAgICAgICAgIGJsb2IgPSBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2Rvd25sb2FkIGVycm9yJykpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmaWxlU2F2ZXI7XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWdpc3RyeSA9IHJlcXVpcmUoJy4uL3JlZ2lzdHJ5Jyk7XG5cbmV4cG9ydHMuZ2V0RGVsYXkgPSBmdW5jdGlvbihmdWxsTGF5b3V0KSB7XG4gICAgaWYoIWZ1bGxMYXlvdXQuX2hhcykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICBmdWxsTGF5b3V0Ll9oYXMoJ2dsM2QnKSB8fFxuICAgICAgICBmdWxsTGF5b3V0Ll9oYXMoJ2dsMmQnKSB8fFxuICAgICAgICBmdWxsTGF5b3V0Ll9oYXMoJ21hcGJveCcpXG4gICAgKSA/IDUwMCA6IDA7XG59O1xuXG5leHBvcnRzLmdldFJlZHJhd0Z1bmMgPSBmdW5jdGlvbihnZCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZ1bGxMYXlvdXQgPSBnZC5fZnVsbExheW91dCB8fCB7fTtcbiAgICAgICAgdmFyIGhhc1BvbGFyID0gZnVsbExheW91dC5faGFzICYmIGZ1bGxMYXlvdXQuX2hhcygncG9sYXInKTtcbiAgICAgICAgdmFyIGhhc0xlZ2FjeVBvbGFyID0gIWhhc1BvbGFyICYmIGdkLmRhdGEgJiYgZ2QuZGF0YVswXSAmJiBnZC5kYXRhWzBdLnI7XG5cbiAgICAgICAgaWYoIWhhc0xlZ2FjeVBvbGFyKSB7XG4gICAgICAgICAgICBSZWdpc3RyeS5nZXRDb21wb25lbnRNZXRob2QoJ2NvbG9yYmFyJywgJ2RyYXcnKShnZCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuZXhwb3J0cy5lbmNvZGVTVkcgPSBmdW5jdGlvbihzdmcpIHtcbiAgICByZXR1cm4gJ2RhdGE6aW1hZ2Uvc3ZnK3htbCwnICsgZW5jb2RlVVJJQ29tcG9uZW50KHN2Zyk7XG59O1xuXG5leHBvcnRzLmVuY29kZUpTT04gPSBmdW5jdGlvbihqc29uKSB7XG4gICAgcmV0dXJuICdkYXRhOmFwcGxpY2F0aW9uL2pzb24sJyArIGVuY29kZVVSSUNvbXBvbmVudChqc29uKTtcbn07XG5cbnZhciBET01fVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuXG5leHBvcnRzLmNyZWF0ZU9iamVjdFVSTCA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgICByZXR1cm4gRE9NX1VSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59O1xuXG5leHBvcnRzLnJldm9rZU9iamVjdFVSTCA9IGZ1bmN0aW9uKHVybCkge1xuICAgIHJldHVybiBET01fVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xufTtcblxuZXhwb3J0cy5jcmVhdGVCbG9iID0gZnVuY3Rpb24odXJsLCBmb3JtYXQpIHtcbiAgICBpZihmb3JtYXQgPT09ICdzdmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgd2luZG93LkJsb2IoW3VybF0sIHt0eXBlOiAnaW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04J30pO1xuICAgIH0gZWxzZSBpZihmb3JtYXQgPT09ICdmdWxsLWpzb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgd2luZG93LkJsb2IoW3VybF0sIHt0eXBlOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04J30pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBiaW5hcnkgPSBmaXhCaW5hcnkod2luZG93LmF0b2IodXJsKSk7XG4gICAgICAgIHJldHVybiBuZXcgd2luZG93LkJsb2IoW2JpbmFyeV0sIHt0eXBlOiAnaW1hZ2UvJyArIGZvcm1hdH0pO1xuICAgIH1cbn07XG5cbmV4cG9ydHMub2N0ZXRTdHJlYW0gPSBmdW5jdGlvbihzKSB7XG4gICAgZG9jdW1lbnQubG9jYXRpb24uaHJlZiA9ICdkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgKyBzO1xufTtcblxuLy8gVGFrZW4gZnJvbSBodHRwczovL2JsLm9ja3Mub3JnL25vbGFubGF3c29uLzBlYWMzMDZlNGRhYzIxMTRjNzUyXG5mdW5jdGlvbiBmaXhCaW5hcnkoYikge1xuICAgIHZhciBsZW4gPSBiLmxlbmd0aDtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKGxlbik7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zjtcbn1cblxuZXhwb3J0cy5JTUFHRV9VUkxfUFJFRklYID0gL15kYXRhOmltYWdlXFwvXFx3KztiYXNlNjQsLztcblxuZXhwb3J0cy5NU0dfSUVfQkFEX0ZPUk1BVCA9ICdTb3JyeSBJRSBkb2VzIG5vdCBzdXBwb3J0IGRvd25sb2FkaW5nIGZyb20gY2FudmFzLiBUcnkge2Zvcm1hdDpcXCdzdmdcXCd9IGluc3RlYWQuJztcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG52YXIgU25hcHNob3QgPSB7XG4gICAgZ2V0RGVsYXk6IGhlbHBlcnMuZ2V0RGVsYXksXG4gICAgZ2V0UmVkcmF3RnVuYzogaGVscGVycy5nZXRSZWRyYXdGdW5jLFxuICAgIGNsb25lOiByZXF1aXJlKCcuL2Nsb25lcGxvdCcpLFxuICAgIHRvU1ZHOiByZXF1aXJlKCcuL3Rvc3ZnJyksXG4gICAgc3ZnVG9JbWc6IHJlcXVpcmUoJy4vc3ZndG9pbWcnKSxcbiAgICB0b0ltYWdlOiByZXF1aXJlKCcuL3RvaW1hZ2UnKSxcbiAgICBkb3dubG9hZEltYWdlOiByZXF1aXJlKCcuL2Rvd25sb2FkJylcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU25hcHNob3Q7XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaWIgPSByZXF1aXJlKCcuLi9saWInKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbmZ1bmN0aW9uIHN2Z1RvSW1nKG9wdHMpIHtcbiAgICB2YXIgZXYgPSBvcHRzLmVtaXR0ZXIgfHwgbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIEltYWdlID0gd2luZG93LkltYWdlO1xuICAgICAgICB2YXIgc3ZnID0gb3B0cy5zdmc7XG4gICAgICAgIHZhciBmb3JtYXQgPSBvcHRzLmZvcm1hdCB8fCAncG5nJztcblxuICAgICAgICAvLyBJRSBvbmx5IHN1cHBvcnQgc3ZnXG4gICAgICAgIGlmKExpYi5pc0lFKCkgJiYgZm9ybWF0ICE9PSAnc3ZnJykge1xuICAgICAgICAgICAgdmFyIGllU3ZnRXJyb3IgPSBuZXcgRXJyb3IoaGVscGVycy5NU0dfSUVfQkFEX0ZPUk1BVCk7XG4gICAgICAgICAgICByZWplY3QoaWVTdmdFcnJvcik7XG4gICAgICAgICAgICAvLyBldmVudHVhbGx5IHJlbW92ZSB0aGUgZXZcbiAgICAgICAgICAgIC8vICBpbiBmYXZvciBvZiBwcm9taXNlc1xuICAgICAgICAgICAgaWYoIW9wdHMucHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldi5lbWl0KCdlcnJvcicsIGllU3ZnRXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXMgPSBvcHRzLmNhbnZhcztcbiAgICAgICAgdmFyIHNjYWxlID0gb3B0cy5zY2FsZSB8fCAxO1xuICAgICAgICB2YXIgdzAgPSBvcHRzLndpZHRoIHx8IDMwMDtcbiAgICAgICAgdmFyIGgwID0gb3B0cy5oZWlnaHQgfHwgMTUwO1xuICAgICAgICB2YXIgdzEgPSBzY2FsZSAqIHcwO1xuICAgICAgICB2YXIgaDEgPSBzY2FsZSAqIGgwO1xuXG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICB2YXIgc3ZnQmxvYiwgdXJsO1xuXG4gICAgICAgIGlmKGZvcm1hdCA9PT0gJ3N2ZycgfHwgTGliLmlzSUU5b3JCZWxvdygpIHx8IExpYi5pc1NhZmFyaSgpKSB7XG4gICAgICAgICAgICB1cmwgPSBoZWxwZXJzLmVuY29kZVNWRyhzdmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ZnQmxvYiA9IGhlbHBlcnMuY3JlYXRlQmxvYihzdmcsICdzdmcnKTtcbiAgICAgICAgICAgIHVybCA9IGhlbHBlcnMuY3JlYXRlT2JqZWN0VVJMKHN2Z0Jsb2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FudmFzLndpZHRoID0gdzE7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoMTtcblxuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW1nRGF0YTtcblxuICAgICAgICAgICAgc3ZnQmxvYiA9IG51bGw7XG4gICAgICAgICAgICBoZWxwZXJzLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuXG4gICAgICAgICAgICAvLyBkb24ndCBuZWVkIHRvIGRyYXcgdG8gY2FudmFzIGlmIHN2Z1xuICAgICAgICAgICAgLy8gIHNhdmUgc29tZSB0aW1lIGFuZCBhbHNvIGF2b2lkIGZhaWx1cmUgb24gSUVcbiAgICAgICAgICAgIGlmKGZvcm1hdCAhPT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgdzEsIGgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2pwZWcnOlxuICAgICAgICAgICAgICAgICAgICBpbWdEYXRhID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwbmcnOlxuICAgICAgICAgICAgICAgICAgICBpbWdEYXRhID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlYnAnOlxuICAgICAgICAgICAgICAgICAgICBpbWdEYXRhID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2Uvd2VicCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdmcnOlxuICAgICAgICAgICAgICAgICAgICBpbWdEYXRhID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JNc2cgPSAnSW1hZ2UgZm9ybWF0IGlzIG5vdCBqcGVnLCBwbmcsIHN2ZyBvciB3ZWJwLic7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyb3JNc2cpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnR1YWxseSByZW1vdmUgdGhlIGV2XG4gICAgICAgICAgICAgICAgICAgIC8vICBpbiBmYXZvciBvZiBwcm9taXNlc1xuICAgICAgICAgICAgICAgICAgICBpZighb3B0cy5wcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXYuZW1pdCgnZXJyb3InLCBlcnJvck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoaW1nRGF0YSk7XG4gICAgICAgICAgICAvLyBldmVudHVhbGx5IHJlbW92ZSB0aGUgZXZcbiAgICAgICAgICAgIC8vICBpbiBmYXZvciBvZiBwcm9taXNlc1xuICAgICAgICAgICAgaWYoIW9wdHMucHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGV2LmVtaXQoJ3N1Y2Nlc3MnLCBpbWdEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgc3ZnQmxvYiA9IG51bGw7XG4gICAgICAgICAgICBoZWxwZXJzLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuXG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIC8vIGV2ZW50dWFsbHkgcmVtb3ZlIHRoZSBldlxuICAgICAgICAgICAgLy8gIGluIGZhdm9yIG9mIHByb21pc2VzXG4gICAgICAgICAgICBpZighb3B0cy5wcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgIH0pO1xuXG4gICAgLy8gdGVtcG9yYXJ5IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgLy8gIG1vdmUgdG8gb25seSBQcm9taXNlIGluIDIuMC4wXG4gICAgLy8gIGFuZCBlbGltaW5hdGUgdGhlIEV2ZW50RW1pdHRlclxuICAgIGlmKG9wdHMucHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3ZnVG9JbWc7XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBSZWdpc3RyeSA9IHJlcXVpcmUoJy4uL3JlZ2lzdHJ5Jyk7XG52YXIgTGliID0gcmVxdWlyZSgnLi4vbGliJyk7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG52YXIgY2xvbmVQbG90ID0gcmVxdWlyZSgnLi9jbG9uZXBsb3QnKTtcbnZhciB0b1NWRyA9IHJlcXVpcmUoJy4vdG9zdmcnKTtcbnZhciBzdmdUb0ltZyA9IHJlcXVpcmUoJy4vc3ZndG9pbWcnKTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZ2QgZmlndXJlIE9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IG9wdHMgb3B0aW9uIG9iamVjdFxuICogQHBhcmFtIG9wdHMuZm9ybWF0ICdqcGVnJyB8ICdwbmcnIHwgJ3dlYnAnIHwgJ3N2ZydcbiAqL1xuZnVuY3Rpb24gdG9JbWFnZShnZCwgb3B0cykge1xuICAgIC8vIGZpcnN0IGNsb25lIHRoZSBHRCBzbyB3ZSBjYW4gb3BlcmF0ZSBpbiBhIGNsZWFuIGVudmlyb25tZW50XG4gICAgdmFyIGV2ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgdmFyIGNsb25lID0gY2xvbmVQbG90KGdkLCB7Zm9ybWF0OiAncG5nJ30pO1xuICAgIHZhciBjbG9uZWRHZCA9IGNsb25lLmdkO1xuXG4gICAgLy8gcHV0IHRoZSBjbG9uZWQgZGl2IHNvbWV3aGVyZSBvZmYgc2NyZWVuIGJlZm9yZSBhdHRhY2hpbmcgdG8gRE9NXG4gICAgY2xvbmVkR2Quc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGNsb25lZEdkLnN0eWxlLmxlZnQgPSAnLTUwMDBweCc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjbG9uZWRHZCk7XG5cbiAgICBmdW5jdGlvbiB3YWl0KCkge1xuICAgICAgICB2YXIgZGVsYXkgPSBoZWxwZXJzLmdldERlbGF5KGNsb25lZEdkLl9mdWxsTGF5b3V0KTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHN2ZyA9IHRvU1ZHKGNsb25lZEdkKTtcblxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY2FudmFzLmlkID0gTGliLnJhbmRzdHIoKTtcblxuICAgICAgICAgICAgZXYgPSBzdmdUb0ltZyh7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiBvcHRzLmZvcm1hdCxcbiAgICAgICAgICAgICAgICB3aWR0aDogY2xvbmVkR2QuX2Z1bGxMYXlvdXQud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBjbG9uZWRHZC5fZnVsbExheW91dC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICAgICAgICAgICAgZW1pdHRlcjogZXYsXG4gICAgICAgICAgICAgICAgc3ZnOiBzdmdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBldi5jbGVhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmKGNsb25lZEdkKSBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNsb25lZEdkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9XG5cbiAgICB2YXIgcmVkcmF3RnVuYyA9IGhlbHBlcnMuZ2V0UmVkcmF3RnVuYyhjbG9uZWRHZCk7XG5cbiAgICBSZWdpc3RyeS5jYWxsKCdwbG90JywgY2xvbmVkR2QsIGNsb25lLmRhdGEsIGNsb25lLmxheW91dCwgY2xvbmUuY29uZmlnKVxuICAgICAgICAudGhlbihyZWRyYXdGdW5jKVxuICAgICAgICAudGhlbih3YWl0KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBldi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIH0pO1xuXG5cbiAgICByZXR1cm4gZXY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9JbWFnZTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZDMgPSByZXF1aXJlKCdkMycpO1xuXG52YXIgTGliID0gcmVxdWlyZSgnLi4vbGliJyk7XG52YXIgRHJhd2luZyA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvZHJhd2luZycpO1xudmFyIENvbG9yID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9jb2xvcicpO1xuXG52YXIgeG1sbnNOYW1lc3BhY2VzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL3htbG5zX25hbWVzcGFjZXMnKTtcbnZhciBET1VCTEVRVU9URV9SRUdFWCA9IC9cIi9nO1xudmFyIERVTU1ZX1NVQiA9ICdUT0JFU1RSSVBQRUQnO1xudmFyIERVTU1ZX1JFR0VYID0gbmV3IFJlZ0V4cCgnKFwiJyArIERVTU1ZX1NVQiArICcpfCgnICsgRFVNTVlfU1VCICsgJ1wiKScsICdnJyk7XG5cbmZ1bmN0aW9uIGh0bWxFbnRpdHlEZWNvZGUocykge1xuICAgIHZhciBoaWRkZW5EaXYgPSBkMy5zZWxlY3QoJ2JvZHknKS5hcHBlbmQoJ2RpdicpLnN0eWxlKHtkaXNwbGF5OiAnbm9uZSd9KS5odG1sKCcnKTtcbiAgICB2YXIgcmVwbGFjZWQgPSBzLnJlcGxhY2UoLygmW147XSo7KS9naSwgZnVuY3Rpb24oZCkge1xuICAgICAgICBpZihkID09PSAnJmx0OycpIHsgcmV0dXJuICcmIzYwOyc7IH0gLy8gc3BlY2lhbCBoYW5kbGluZyBmb3IgYnJhY2tldHNcbiAgICAgICAgaWYoZCA9PT0gJyZydDsnKSB7IHJldHVybiAnJiM2MjsnOyB9XG4gICAgICAgIGlmKGQuaW5kZXhPZignPCcpICE9PSAtMSB8fCBkLmluZGV4T2YoJz4nKSAhPT0gLTEpIHsgcmV0dXJuICcnOyB9XG4gICAgICAgIHJldHVybiBoaWRkZW5EaXYuaHRtbChkKS50ZXh0KCk7IC8vIGV2ZXJ5dGhpbmcgZWxzZSwgbGV0IHRoZSBicm93c2VyIGRlY29kZSBpdCB0byB1bmljb2RlXG4gICAgfSk7XG4gICAgaGlkZGVuRGl2LnJlbW92ZSgpO1xuICAgIHJldHVybiByZXBsYWNlZDtcbn1cblxuZnVuY3Rpb24geG1sRW50aXR5RW5jb2RlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJig/IVxcdys7fFxcI1swLTldKzt8IFxcI3hbMC05QS1GXSs7KS9nLCAnJmFtcDsnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0b1NWRyhnZCwgZm9ybWF0LCBzY2FsZSkge1xuICAgIHZhciBmdWxsTGF5b3V0ID0gZ2QuX2Z1bGxMYXlvdXQ7XG4gICAgdmFyIHN2ZyA9IGZ1bGxMYXlvdXQuX3BhcGVyO1xuICAgIHZhciB0b3BwYXBlciA9IGZ1bGxMYXlvdXQuX3RvcHBhcGVyO1xuICAgIHZhciB3aWR0aCA9IGZ1bGxMYXlvdXQud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGZ1bGxMYXlvdXQuaGVpZ2h0O1xuICAgIHZhciBpO1xuXG4gICAgLy8gbWFrZSBiYWNrZ3JvdW5kIGNvbG9yIGEgcmVjdCBpbiB0aGUgc3ZnLCB0aGVuIHJldmVydCBhZnRlciBzY3JhcGluZ1xuICAgIC8vIGFsbCBvdGhlciBhbHRlcmF0aW9ucyBoYXZlIGJlZW4gZGVhbHQgd2l0aCBieSBwcm9wZXJseSBwcmVwYXJpbmcgdGhlIHN2Z1xuICAgIC8vIGluIHRoZSBmaXJzdCBwbGFjZS4uLiBsaWtlIHNldHRpbmcgY3Vyc29ycyB3aXRoIGNzcyBjbGFzc2VzIHNvIHdlIGRvbid0XG4gICAgLy8gaGF2ZSB0byByZW1vdmUgdGhlbSwgYW5kIHByb3ZpZGluZyB0aGUgcmlnaHQgbmFtZXNwYWNlcyBpbiB0aGUgc3ZnIHRvXG4gICAgLy8gYmVnaW4gd2l0aFxuICAgIHN2Zy5pbnNlcnQoJ3JlY3QnLCAnOmZpcnN0LWNoaWxkJylcbiAgICAgICAgLmNhbGwoRHJhd2luZy5zZXRSZWN0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICAuY2FsbChDb2xvci5maWxsLCBmdWxsTGF5b3V0LnBhcGVyX2JnY29sb3IpO1xuXG4gICAgLy8gc3VicGxvdC1zcGVjaWZpYyB0by1TVkcgbWV0aG9kc1xuICAgIC8vIHdoaWNoIG5vdGFibHkgYWRkIHRoZSBjb250ZW50cyBvZiB0aGUgZ2wtY29udGFpbmVyXG4gICAgLy8gaW50byB0aGUgbWFpbiBzdmcgbm9kZVxuICAgIHZhciBiYXNlUGxvdE1vZHVsZXMgPSBmdWxsTGF5b3V0Ll9iYXNlUGxvdE1vZHVsZXMgfHwgW107XG4gICAgZm9yKGkgPSAwOyBpIDwgYmFzZVBsb3RNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlID0gYmFzZVBsb3RNb2R1bGVzW2ldO1xuXG4gICAgICAgIGlmKF9tb2R1bGUudG9TVkcpIF9tb2R1bGUudG9TVkcoZ2QpO1xuICAgIH1cblxuICAgIC8vIGFkZCB0b3AgaXRlbXMgYWJvdmUgdGhlbSBhc3N1bWVzIGV2ZXJ5dGhpbmcgaW4gdG9wcGFwZXIgaXMgZWl0aGVyXG4gICAgLy8gYSBncm91cCBvciBhIGRlZnMsIGFuZCBpZiBpdCdzIGVtcHR5IChsaWtlIGhvdmVybGF5ZXIpIHdlIGNhbiBpZ25vcmUgaXQuXG4gICAgaWYodG9wcGFwZXIpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gdG9wcGFwZXIubm9kZSgpLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgLy8gbWFrZSBjb3B5IG9mIG5vZGVzIGFzIGNoaWxkTm9kZXMgcHJvcCBnZXRzIG11dGF0ZWQgaW4gbG9vcCBiZWxvd1xuICAgICAgICB2YXIgdG9wR3JvdXBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZXMpO1xuXG4gICAgICAgIGZvcihpID0gMDsgaSA8IHRvcEdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRvcEdyb3VwID0gdG9wR3JvdXBzW2ldO1xuXG4gICAgICAgICAgICBpZih0b3BHcm91cC5jaGlsZE5vZGVzLmxlbmd0aCkgc3ZnLm5vZGUoKS5hcHBlbmRDaGlsZCh0b3BHcm91cCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgZHJhZ2xheWVyIGZvciBBZG9iZSBJbGx1c3RyYXRvciBjb21wYXRpYmlsaXR5XG4gICAgaWYoZnVsbExheW91dC5fZHJhZ2dlcnMpIHtcbiAgICAgICAgZnVsbExheW91dC5fZHJhZ2dlcnMucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgLy8gaW4gY2FzZSB0aGUgc3ZnIGVsZW1lbnQgaGFkIGFuIGV4cGxpY2l0IGJhY2tncm91bmQgY29sb3IsIHJlbW92ZSB0aGlzXG4gICAgLy8gd2Ugd2FudCB0aGUgcmVjdCB0byBnZXQgdGhlIGNvbG9yIHNvIGl0J3MgdGhlIHJpZ2h0IHNpemU7IHN2ZyBiZyB3aWxsXG4gICAgLy8gZmlsbCB3aGF0ZXZlciBjb250YWluZXIgaXQncyBkaXNwbGF5ZWQgaW4gcmVnYXJkbGVzcyBvZiBwbG90IHNpemUuXG4gICAgc3ZnLm5vZGUoKS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG5cbiAgICBzdmcuc2VsZWN0QWxsKCd0ZXh0JylcbiAgICAgICAgLmF0dHIoeydkYXRhLXVuZm9ybWF0dGVkJzogbnVsbCwgJ2RhdGEtbWF0aCc6IG51bGx9KVxuICAgICAgICAuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0eHQgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIGhpZGRlbiB0ZXh0IGlzIHByZS1mb3JtYXR0aW5nIG1hdGhqYXgsIHRoZSBicm93c2VyIGlnbm9yZXMgaXRcbiAgICAgICAgICAgIC8vIGJ1dCBpbiBhIHN0YXRpYyBwbG90IGl0J3MgdXNlbGVzcyBhbmQgaXQgY2FuIGNvbmZ1c2UgYmF0aWtcbiAgICAgICAgICAgIC8vIHdlJ3ZlIHRyaWVkIHRvIHN0YW5kYXJkaXplIG9uIGRpc3BsYXk6bm9uZSBidXQgbWFrZSBzdXJlIHdlIHN0aWxsXG4gICAgICAgICAgICAvLyBjYXRjaCB2aXNpYmlsaXR5OmhpZGRlbiBpZiBpdCBldmVyIGFyaXNlc1xuICAgICAgICAgICAgaWYodGhpcy5zdHlsZS52aXNpYmlsaXR5ID09PSAnaGlkZGVuJyB8fCB0aGlzLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIHR4dC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNsZWFyIG90aGVyIHZpc2liaWxpdHkvZGlzcGxheSB2YWx1ZXMgdG8gZGVmYXVsdFxuICAgICAgICAgICAgICAgIC8vIHRvIG5vdCBwb3RlbnRpYWxseSBjb25mdXNlIG5vbi1icm93c2VyIFNWRyBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICAgICAgICB0eHQuc3R5bGUoe3Zpc2liaWxpdHk6IG51bGwsIGRpc3BsYXk6IG51bGx9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRm9udCBmYW1pbHkgc3R5bGVzIGJyZWFrIHRoaW5ncyBiZWNhdXNlIG9mIHF1b3RhdGlvbiBtYXJrcyxcbiAgICAgICAgICAgIC8vIHNvIHdlIG11c3QgcmVtb3ZlIHRoZW0gKmFmdGVyKiB0aGUgU1ZHIERPTSBoYXMgYmVlbiBzZXJpYWxpemVkXG4gICAgICAgICAgICAvLyB0byBhIHN0cmluZyAoYnJvd3NlcnMgY29udmVydCBzaW5nbGVzIGJhY2spXG4gICAgICAgICAgICB2YXIgZmYgPSB0aGlzLnN0eWxlLmZvbnRGYW1pbHk7XG4gICAgICAgICAgICBpZihmZiAmJiBmZi5pbmRleE9mKCdcIicpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHR4dC5zdHlsZSgnZm9udC1mYW1pbHknLCBmZi5yZXBsYWNlKERPVUJMRVFVT1RFX1JFR0VYLCBEVU1NWV9TVUIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cblxuICAgIGlmKGZ1bGxMYXlvdXQuX2dyYWRpZW50VXJsUXVlcnlQYXJ0cykge1xuICAgICAgICB2YXIgcXVlcnlQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IodmFyIGsgaW4gZnVsbExheW91dC5fZ3JhZGllbnRVcmxRdWVyeVBhcnRzKSBxdWVyeVBhcnRzLnB1c2goayk7XG5cbiAgICAgICAgaWYocXVlcnlQYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwocXVlcnlQYXJ0cy5qb2luKCcsJykpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHB0ID0gZDMuc2VsZWN0KHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2ltaWxhciB0byBmb250IGZhbWlseSBzdHlsZXMgYWJvdmUsXG4gICAgICAgICAgICAgICAgLy8gd2UgbXVzdCByZW1vdmUgXCIgYWZ0ZXIgdGhlIFNWRyBET00gaGFzIGJlZW4gc2VyaWFsaXplZFxuICAgICAgICAgICAgICAgIHZhciBmaWxsID0gdGhpcy5zdHlsZS5maWxsO1xuICAgICAgICAgICAgICAgIGlmKGZpbGwgJiYgZmlsbC5pbmRleE9mKCd1cmwoJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHB0LnN0eWxlKCdmaWxsJywgZmlsbC5yZXBsYWNlKERPVUJMRVFVT1RFX1JFR0VYLCBEVU1NWV9TVUIpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3Ryb2tlID0gdGhpcy5zdHlsZS5zdHJva2U7XG4gICAgICAgICAgICAgICAgaWYoc3Ryb2tlICYmIHN0cm9rZS5pbmRleE9mKCd1cmwoJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHB0LnN0eWxlKCdzdHJva2UnLCBzdHJva2UucmVwbGFjZShET1VCTEVRVU9URV9SRUdFWCwgRFVNTVlfU1VCKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihmb3JtYXQgPT09ICdwZGYnIHx8IGZvcm1hdCA9PT0gJ2VwcycpIHtcbiAgICAgICAgLy8gdGhlc2UgZm9ybWF0cyBtYWtlIHRoZSBleHRyYSBsaW5lIE1hdGhKYXggYWRkcyBhcm91bmQgc3ltYm9scyBsb29rIHN1cGVyIHRoaWNrIGluIHNvbWUgY2FzZXNcbiAgICAgICAgLy8gaXQgbG9va3MgYmV0dGVyIGlmIHRoaXMgaXMgcmVtb3ZlZCBlbnRpcmVseS5cbiAgICAgICAgc3ZnLnNlbGVjdEFsbCgnI01hdGhKYXhfU1ZHX2dseXBocyBwYXRoJylcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKTtcbiAgICB9XG5cbiAgICAvLyBmaXggZm9yIElFIG5hbWVzcGFjaW5nIHF1aXJrP1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTk2MTAwODkvdW53YW50ZWQtbmFtZXNwYWNlcy1vbi1zdmctbWFya3VwLXdoZW4tdXNpbmcteG1sc2VyaWFsaXplci1pbi1qYXZhc2NyaXB0LXdpdGgtaWVcbiAgICBzdmcubm9kZSgpLnNldEF0dHJpYnV0ZU5TKHhtbG5zTmFtZXNwYWNlcy54bWxucywgJ3htbG5zJywgeG1sbnNOYW1lc3BhY2VzLnN2Zyk7XG4gICAgc3ZnLm5vZGUoKS5zZXRBdHRyaWJ1dGVOUyh4bWxuc05hbWVzcGFjZXMueG1sbnMsICd4bWxuczp4bGluaycsIHhtbG5zTmFtZXNwYWNlcy54bGluayk7XG5cbiAgICBpZihmb3JtYXQgPT09ICdzdmcnICYmIHNjYWxlKSB7XG4gICAgICAgIHN2Zy5hdHRyKCd3aWR0aCcsIHNjYWxlICogd2lkdGgpO1xuICAgICAgICBzdmcuYXR0cignaGVpZ2h0Jywgc2NhbGUgKiBoZWlnaHQpO1xuICAgICAgICBzdmcuYXR0cigndmlld0JveCcsICcwIDAgJyArIHdpZHRoICsgJyAnICsgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB2YXIgcyA9IG5ldyB3aW5kb3cuWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Zy5ub2RlKCkpO1xuICAgIHMgPSBodG1sRW50aXR5RGVjb2RlKHMpO1xuICAgIHMgPSB4bWxFbnRpdHlFbmNvZGUocyk7XG5cbiAgICAvLyBGaXggcXVvdGF0aW9ucyBhcm91bmQgZm9udCBzdHJpbmdzIGFuZCBncmFkaWVudCBVUkxzXG4gICAgcyA9IHMucmVwbGFjZShEVU1NWV9SRUdFWCwgJ1xcJycpO1xuXG4gICAgLy8gSUUgaXMgdmVyeSBzdHJpY3QsIHNvIHdlIHdpbGwgbmVlZCB0byBjbGVhblxuICAgIC8vICBzdmcgd2l0aCB0aGUgZm9sbG93aW5nIHJlZ2V4XG4gICAgLy8gIHllcyB0aGlzIGlzIG1lc3N5LCBidXQgZG8gbm90IGtub3cgYSBiZXR0ZXIgd2F5XG4gICAgLy8gRXZlbiB3aXRoIHRoaXMgSUUgd2lsbCBub3Qgd29yayBkdWUgdG8gdGFpbnRlZCBjYW52YXNcbiAgICAvLyAgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5nYXgvZmFicmljLmpzL2lzc3Vlcy8xOTU3XG4gICAgLy8gICAgICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4MTEyMDQ3L2NhbnZhcy10b2RhdGF1cmwtd29ya2luZy1pbi1hbGwtYnJvd3NlcnMtZXhjZXB0LWllMTBcbiAgICAvLyBMZWF2ZSBoZXJlIGp1c3QgaW4gY2FzZSB0aGUgQ09SUy90YWludGVkIElFIGlzc3VlIGdldHMgcmVzb2x2ZWRcbiAgICBpZihMaWIuaXNJRSgpKSB7XG4gICAgICAgIC8vIHJlcGxhY2UgZG91YmxlIHF1b3RlIHdpdGggc2luZ2xlIHF1b3RlXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoL1wiL2dpLCAnXFwnJyk7XG4gICAgICAgIC8vIHVybCBpbiBzdmcgYXJlIHNpbmdsZSBxdW90ZWRcbiAgICAgICAgLy8gICBzaW5jZSB3ZSBjaGFuZ2VkIGRvdWJsZSB0byBzaW5nbGVcbiAgICAgICAgLy8gICB3ZSdsbCBuZWVkIHRvIGNoYW5nZSB0aGVzZSB0byBkb3VibGUtcXVvdGVkXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoLyhcXCgnIykoW14nXSopKCdcXCkpL2dpLCAnKFxcXCIjJDJcXFwiKScpO1xuICAgICAgICAvLyBmb250IG5hbWVzIHdpdGggc3BhY2VzIHdpbGwgYmUgZXNjYXBlZCBzaW5nbGUtcXVvdGVkXG4gICAgICAgIC8vICAgd2UnbGwgbmVlZCB0byBjaGFuZ2UgdGhlc2UgdG8gZG91YmxlLXF1b3RlZFxuICAgICAgICBzID0gcy5yZXBsYWNlKC8oXFxcXCcpL2dpLCAnXFxcIicpO1xuICAgIH1cblxuICAgIHJldHVybiBzO1xufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gcGFja2FnZSB2ZXJzaW9uIGluamVjdGVkIGJ5IGBucG0gcnVuIHByZXByb2Nlc3NgXG5leHBvcnRzLnZlcnNpb24gPSAnMS41NC41JztcbiJdLCJzb3VyY2VSb290IjoiIn0=