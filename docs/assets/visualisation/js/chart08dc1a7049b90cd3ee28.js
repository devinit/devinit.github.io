(self["webpackChunkdi_website"] = self["webpackChunkdi_website"] || []).push([["vendors-node_modules_plotly_js_lib_splom_js"],{

/***/ "./node_modules/array-range/index.js":
/*!*******************************************!*\
  !*** ./node_modules/array-range/index.js ***!
  \*******************************************/
/***/ ((module) => {


module.exports = function newArray(start, end) {
    var n0 = typeof start === 'number',
        n1 = typeof end === 'number'

    if (n0 && !n1) {
        end = start
        start = 0
    } else if (!n0 && !n1) {
        start = 0
        end = 0
    }

    start = start|0
    end = end|0
    var len = end-start
    if (len<0)
        throw new Error('array length must be positive')
    
    var a = new Array(len)
    for (var i=0, c=start; i<len; i++, c++)
        a[i] = c
    return a
}

/***/ }),

/***/ "./node_modules/performance-now/lib/performance-now.js":
/*!*************************************************************!*\
  !*** ./node_modules/performance-now/lib/performance-now.js ***!
  \*************************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

//# sourceMappingURL=performance-now.js.map


/***/ }),

/***/ "./node_modules/plotly.js/lib/splom.js":
/*!*********************************************!*\
  !*** ./node_modules/plotly.js/lib/splom.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/traces/splom */ "./node_modules/plotly.js/src/traces/splom/index.js");


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/splom/attributes.js":
/*!***************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/splom/attributes.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var scatterAttrs = __webpack_require__(/*! ../scatter/attributes */ "./node_modules/plotly.js/src/traces/scatter/attributes.js");
var colorScaleAttrs = __webpack_require__(/*! ../../components/colorscale/attributes */ "./node_modules/plotly.js/src/components/colorscale/attributes.js");
var hovertemplateAttrs = __webpack_require__(/*! ../../plots/template_attributes */ "./node_modules/plotly.js/src/plots/template_attributes.js").hovertemplateAttrs;
var scatterGlAttrs = __webpack_require__(/*! ../scattergl/attributes */ "./node_modules/plotly.js/src/traces/scattergl/attributes.js");
var cartesianIdRegex = __webpack_require__(/*! ../../plots/cartesian/constants */ "./node_modules/plotly.js/src/plots/cartesian/constants.js").idRegex;
var templatedArray = __webpack_require__(/*! ../../plot_api/plot_template */ "./node_modules/plotly.js/src/plot_api/plot_template.js").templatedArray;
var extendFlat = __webpack_require__(/*! ../../lib/extend */ "./node_modules/plotly.js/src/lib/extend.js").extendFlat;

var scatterMarkerAttrs = scatterAttrs.marker;
var scatterMarkerLineAttrs = scatterMarkerAttrs.line;

var markerLineAttrs = extendFlat(colorScaleAttrs('marker.line', {editTypeOverride: 'calc'}), {
    width: extendFlat({}, scatterMarkerLineAttrs.width, {editType: 'calc'}),
    editType: 'calc'
});

var markerAttrs = extendFlat(colorScaleAttrs('marker'), {
    symbol: scatterMarkerAttrs.symbol,
    size: extendFlat({}, scatterMarkerAttrs.size, {editType: 'markerSize'}),
    sizeref: scatterMarkerAttrs.sizeref,
    sizemin: scatterMarkerAttrs.sizemin,
    sizemode: scatterMarkerAttrs.sizemode,
    opacity: scatterMarkerAttrs.opacity,
    colorbar: scatterMarkerAttrs.colorbar,
    line: markerLineAttrs,
    editType: 'calc'
});

markerAttrs.color.editType = markerAttrs.cmin.editType = markerAttrs.cmax.editType = 'style';

function makeAxesValObject(axLetter) {
    return {
        valType: 'info_array',
        freeLength: true,
        role: 'info',
        editType: 'calc',
        items: {
            valType: 'subplotid',
            regex: cartesianIdRegex[axLetter],
            editType: 'plot'
        },
        description: [
            'Sets the list of ' + axLetter + ' axes',
            'corresponding to dimensions of this splom trace.',
            'By default, a splom will match the first N ' + axLetter + 'axes',
            'where N is the number of input dimensions.',
            'Note that, in case where `diagonal.visible` is false and `showupperhalf`',
            'or `showlowerhalf` is false, this splom trace will generate',
            'one less x-axis and one less y-axis.',
        ].join(' ')
    };
}

module.exports = {
    dimensions: templatedArray('dimension', {
        visible: {
            valType: 'boolean',
            role: 'info',
            dflt: true,
            editType: 'calc',
            description: [
                'Determines whether or not this dimension is shown on the graph.',
                'Note that even visible false dimension contribute to the',
                'default grid generate by this splom trace.'
            ].join(' ')
        },
        label: {
            valType: 'string',
            role: 'info',
            editType: 'calc',
            description: 'Sets the label corresponding to this splom dimension.'
        },
        values: {
            valType: 'data_array',
            role: 'info',
            editType: 'calc+clearAxisTypes',
            description: 'Sets the dimension values to be plotted.'
        },

        axis: {
            type: {
                valType: 'enumerated',
                values: ['linear', 'log', 'date', 'category'],
                role: 'info',
                editType: 'calc+clearAxisTypes',
                description: [
                    'Sets the axis type for this dimension\'s generated',
                    'x and y axes.',
                    'Note that the axis `type` values set in layout take',
                    'precedence over this attribute.'
                ].join(' ')
            },

            // TODO make 'true' the default in v2?
            matches: {
                valType: 'boolean',
                dflt: false,
                role: 'info',
                editType: 'calc',
                description: [
                    'Determines whether or not the x & y axes generated by this',
                    'dimension match.',
                    'Equivalent to setting the `matches` axis attribute in the layout',
                    'with the correct axis id.'
                ].join(' ')
            },

            editType: 'calc+clearAxisTypes'
        },

        // TODO should add an attribute to pin down x only vars and y only vars
        // like https://seaborn.pydata.org/generated/seaborn.pairplot.html
        // x_vars and y_vars

        // maybe more axis defaulting option e.g. `showgrid: false`

        editType: 'calc+clearAxisTypes'
    }),

    // mode: {}, (only 'markers' for now)

    text: extendFlat({}, scatterGlAttrs.text, {
        description: [
            'Sets text elements associated with each (x,y) pair to appear on hover.',
            'If a single string, the same string appears over',
            'all the data points.',
            'If an array of string, the items are mapped in order to the',
            'this trace\'s (x,y) coordinates.'
        ].join(' ')
    }),
    hovertext: extendFlat({}, scatterGlAttrs.hovertext, {
        description: 'Same as `text`.'
    }),

    hovertemplate: hovertemplateAttrs(),

    marker: markerAttrs,

    xaxes: makeAxesValObject('x'),
    yaxes: makeAxesValObject('y'),

    diagonal: {
        visible: {
            valType: 'boolean',
            role: 'info',
            dflt: true,
            editType: 'calc',
            description: [
                'Determines whether or not subplots on the diagonal are displayed.'
            ].join(' ')
        },

        // type: 'scattergl' | 'histogram' | 'box' | 'violin'
        // ...
        // more options

        editType: 'calc'
    },

    showupperhalf: {
        valType: 'boolean',
        role: 'info',
        dflt: true,
        editType: 'calc',
        description: [
            'Determines whether or not subplots on the upper half',
            'from the diagonal are displayed.'
        ].join(' ')
    },
    showlowerhalf: {
        valType: 'boolean',
        role: 'info',
        dflt: true,
        editType: 'calc',
        description: [
            'Determines whether or not subplots on the lower half',
            'from the diagonal are displayed.'
        ].join(' ')
    },

    selected: {
        marker: scatterGlAttrs.selected.marker,
        editType: 'calc'
    },
    unselected: {
        marker: scatterGlAttrs.unselected.marker,
        editType: 'calc'
    },

    opacity: scatterGlAttrs.opacity
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/splom/base_plot.js":
/*!**************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/splom/base_plot.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var createLine = __webpack_require__(/*! regl-line2d */ "./node_modules/regl-line2d/index.js");

var Registry = __webpack_require__(/*! ../../registry */ "./node_modules/plotly.js/src/registry.js");
var prepareRegl = __webpack_require__(/*! ../../lib/prepare_regl */ "./node_modules/plotly.js/src/lib/prepare_regl.js");
var getModuleCalcData = __webpack_require__(/*! ../../plots/get_data */ "./node_modules/plotly.js/src/plots/get_data.js").getModuleCalcData;
var Cartesian = __webpack_require__(/*! ../../plots/cartesian */ "./node_modules/plotly.js/src/plots/cartesian/index.js");
var getFromId = __webpack_require__(/*! ../../plots/cartesian/axis_ids */ "./node_modules/plotly.js/src/plots/cartesian/axis_ids.js").getFromId;
var shouldShowZeroLine = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js").shouldShowZeroLine;

var SPLOM = 'splom';

function plot(gd) {
    var fullLayout = gd._fullLayout;
    var _module = Registry.getModule(SPLOM);
    var splomCalcData = getModuleCalcData(gd.calcdata, _module)[0];

    var success = prepareRegl(gd, ['ANGLE_instanced_arrays', 'OES_element_index_uint']);
    if(!success) return;

    if(fullLayout._hasOnlyLargeSploms) {
        updateGrid(gd);
    }

    _module.plot(gd, {}, splomCalcData);
}

function drag(gd) {
    var cd = gd.calcdata;
    var fullLayout = gd._fullLayout;

    if(fullLayout._hasOnlyLargeSploms) {
        updateGrid(gd);
    }

    for(var i = 0; i < cd.length; i++) {
        var cd0 = cd[i][0];
        var trace = cd0.trace;
        var scene = fullLayout._splomScenes[trace.uid];

        if(trace.type === 'splom' && scene && scene.matrix) {
            dragOne(gd, trace, scene);
        }
    }
}

function dragOne(gd, trace, scene) {
    var visibleLength = scene.matrixOptions.data.length;
    var visibleDims = trace._visibleDims;
    var ranges = scene.viewOpts.ranges = new Array(visibleLength);

    for(var k = 0; k < visibleDims.length; k++) {
        var i = visibleDims[k];
        var rng = ranges[k] = new Array(4);

        var xa = getFromId(gd, trace._diag[i][0]);
        if(xa) {
            rng[0] = xa.r2l(xa.range[0]);
            rng[2] = xa.r2l(xa.range[1]);
        }

        var ya = getFromId(gd, trace._diag[i][1]);
        if(ya) {
            rng[1] = ya.r2l(ya.range[0]);
            rng[3] = ya.r2l(ya.range[1]);
        }
    }

    if(scene.selectBatch.length || scene.unselectBatch.length) {
        scene.matrix.update({ranges: ranges}, {ranges: ranges});
    } else {
        scene.matrix.update({ranges: ranges});
    }
}

function updateGrid(gd) {
    var fullLayout = gd._fullLayout;
    var regl = fullLayout._glcanvas.data()[0].regl;
    var splomGrid = fullLayout._splomGrid;

    if(!splomGrid) {
        splomGrid = fullLayout._splomGrid = createLine(regl);
    }
    splomGrid.update(makeGridData(gd));
}

function makeGridData(gd) {
    var fullLayout = gd._fullLayout;
    var gs = fullLayout._size;
    var fullView = [0, 0, fullLayout.width, fullLayout.height];
    var lookup = {};
    var k;

    function push(prefix, ax, x0, x1, y0, y1) {
        var lcolor = ax[prefix + 'color'];
        var lwidth = ax[prefix + 'width'];
        var key = String(lcolor + lwidth);

        if(key in lookup) {
            lookup[key].data.push(NaN, NaN, x0, x1, y0, y1);
        } else {
            lookup[key] = {
                data: [x0, x1, y0, y1],
                join: 'rect',
                thickness: lwidth,
                color: lcolor,
                viewport: fullView,
                range: fullView,
                overlay: false
            };
        }
    }

    for(k in fullLayout._splomSubplots) {
        var sp = fullLayout._plots[k];
        var xa = sp.xaxis;
        var ya = sp.yaxis;
        var xVals = xa._gridVals;
        var yVals = ya._gridVals;
        // ya.l2p assumes top-to-bottom coordinate system (a la SVG),
        // we need to compute bottom-to-top offsets and slopes:
        var yOffset = gs.b + ya.domain[0] * gs.h;
        var ym = -ya._m;
        var yb = -ym * ya.r2l(ya.range[0], ya.calendar);
        var x, y;

        if(xa.showgrid) {
            for(k = 0; k < xVals.length; k++) {
                x = xa._offset + xa.l2p(xVals[k].x);
                push('grid', xa, x, yOffset, x, yOffset + ya._length);
            }
        }
        if(ya.showgrid) {
            for(k = 0; k < yVals.length; k++) {
                y = yOffset + yb + ym * yVals[k].x;
                push('grid', ya, xa._offset, y, xa._offset + xa._length, y);
            }
        }
        if(shouldShowZeroLine(gd, xa, ya)) {
            x = xa._offset + xa.l2p(0);
            push('zeroline', xa, x, yOffset, x, yOffset + ya._length);
        }
        if(shouldShowZeroLine(gd, ya, xa)) {
            y = yOffset + yb + 0;
            push('zeroline', ya, xa._offset, y, xa._offset + xa._length, y);
        }
    }

    var gridBatches = [];
    for(k in lookup) {
        gridBatches.push(lookup[k]);
    }

    return gridBatches;
}

function clean(newFullData, newFullLayout, oldFullData, oldFullLayout) {
    var lookup = {};
    var i;

    if(oldFullLayout._splomScenes) {
        for(i = 0; i < newFullData.length; i++) {
            var newTrace = newFullData[i];
            if(newTrace.type === 'splom') {
                lookup[newTrace.uid] = 1;
            }
        }
        for(i = 0; i < oldFullData.length; i++) {
            var oldTrace = oldFullData[i];
            if(!lookup[oldTrace.uid]) {
                var scene = oldFullLayout._splomScenes[oldTrace.uid];
                if(scene && scene.destroy) scene.destroy();
                // must first set scene to null in order to get garbage collected
                oldFullLayout._splomScenes[oldTrace.uid] = null;
                delete oldFullLayout._splomScenes[oldTrace.uid];
            }
        }
    }

    if(Object.keys(oldFullLayout._splomScenes || {}).length === 0) {
        delete oldFullLayout._splomScenes;
    }

    if(oldFullLayout._splomGrid &&
        (!newFullLayout._hasOnlyLargeSploms && oldFullLayout._hasOnlyLargeSploms)) {
        // must first set scene to null in order to get garbage collected
        oldFullLayout._splomGrid.destroy();
        oldFullLayout._splomGrid = null;
        delete oldFullLayout._splomGrid;
    }

    Cartesian.clean(newFullData, newFullLayout, oldFullData, oldFullLayout);
}

module.exports = {
    name: SPLOM,
    attr: Cartesian.attr,
    attrRegex: Cartesian.attrRegex,
    layoutAttributes: Cartesian.layoutAttributes,
    supplyLayoutDefaults: Cartesian.supplyLayoutDefaults,
    drawFramework: Cartesian.drawFramework,
    plot: plot,
    drag: drag,
    updateGrid: updateGrid,
    clean: clean,
    updateFx: Cartesian.updateFx,
    toSVG: Cartesian.toSVG
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/splom/calc.js":
/*!*********************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/splom/calc.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var AxisIDs = __webpack_require__(/*! ../../plots/cartesian/axis_ids */ "./node_modules/plotly.js/src/plots/cartesian/axis_ids.js");

var calcMarkerSize = __webpack_require__(/*! ../scatter/calc */ "./node_modules/plotly.js/src/traces/scatter/calc.js").calcMarkerSize;
var calcAxisExpansion = __webpack_require__(/*! ../scatter/calc */ "./node_modules/plotly.js/src/traces/scatter/calc.js").calcAxisExpansion;
var calcColorscale = __webpack_require__(/*! ../scatter/colorscale_calc */ "./node_modules/plotly.js/src/traces/scatter/colorscale_calc.js");
var convertMarkerSelection = __webpack_require__(/*! ../scattergl/convert */ "./node_modules/plotly.js/src/traces/scattergl/convert.js").markerSelection;
var convertMarkerStyle = __webpack_require__(/*! ../scattergl/convert */ "./node_modules/plotly.js/src/traces/scattergl/convert.js").markerStyle;
var sceneUpdate = __webpack_require__(/*! ./scene_update */ "./node_modules/plotly.js/src/traces/splom/scene_update.js");

var BADNUM = __webpack_require__(/*! ../../constants/numerical */ "./node_modules/plotly.js/src/constants/numerical.js").BADNUM;
var TOO_MANY_POINTS = __webpack_require__(/*! ../scattergl/constants */ "./node_modules/plotly.js/src/traces/scattergl/constants.js").TOO_MANY_POINTS;

module.exports = function calc(gd, trace) {
    var dimensions = trace.dimensions;
    var commonLength = trace._length;
    var opts = {};
    // 'c' for calculated, 'l' for linear,
    // only differ here for log axes, pass ldata to createMatrix as 'data'
    var cdata = opts.cdata = [];
    var ldata = opts.data = [];
    // keep track of visible dimensions
    var visibleDims = trace._visibleDims = [];
    var i, k, dim, xa, ya;

    function makeCalcdata(ax, dim) {
        // call makeCalcdata with fake input
        var ccol = ax.makeCalcdata({
            v: dim.values,
            vcalendar: trace.calendar
        }, 'v');

        for(var j = 0; j < ccol.length; j++) {
            ccol[j] = ccol[j] === BADNUM ? NaN : ccol[j];
        }
        cdata.push(ccol);
        ldata.push(ax.type === 'log' ? Lib.simpleMap(ccol, ax.c2l) : ccol);
    }

    for(i = 0; i < dimensions.length; i++) {
        dim = dimensions[i];

        if(dim.visible) {
            xa = AxisIDs.getFromId(gd, trace._diag[i][0]);
            ya = AxisIDs.getFromId(gd, trace._diag[i][1]);

            // if corresponding x & y axes don't have matching types, skip dim
            if(xa && ya && xa.type !== ya.type) {
                Lib.log('Skipping splom dimension ' + i + ' with conflicting axis types');
                continue;
            }

            if(xa) {
                makeCalcdata(xa, dim);
                if(ya && ya.type === 'category') {
                    ya._categories = xa._categories.slice();
                }
            } else {
                // should not make it here, if both xa and ya undefined
                makeCalcdata(ya, dim);
            }

            visibleDims.push(i);
        }
    }

    calcColorscale(gd, trace);
    Lib.extendFlat(opts, convertMarkerStyle(trace));

    var visibleLength = cdata.length;
    var hasTooManyPoints = (visibleLength * commonLength) > TOO_MANY_POINTS;

    // Reuse SVG scatter axis expansion routine.
    // For graphs with very large number of points and array marker.size,
    // use average marker size instead to speed things up.
    var ppad;
    if(hasTooManyPoints) {
        ppad = 2 * (opts.sizeAvg || Math.max(opts.size, 3));
    } else {
        ppad = calcMarkerSize(trace, commonLength);
    }

    for(k = 0; k < visibleDims.length; k++) {
        i = visibleDims[k];
        dim = dimensions[i];
        xa = AxisIDs.getFromId(gd, trace._diag[i][0]) || {};
        ya = AxisIDs.getFromId(gd, trace._diag[i][1]) || {};
        calcAxisExpansion(gd, trace, xa, ya, cdata[k], cdata[k], ppad);
    }

    var scene = sceneUpdate(gd, trace);
    if(!scene.matrix) scene.matrix = true;
    scene.matrixOptions = opts;

    scene.selectedOptions = convertMarkerSelection(trace, trace.selected);
    scene.unselectedOptions = convertMarkerSelection(trace, trace.unselected);

    return [{x: false, y: false, t: {}, trace: trace}];
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/splom/defaults.js":
/*!*************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/splom/defaults.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var handleArrayContainerDefaults = __webpack_require__(/*! ../../plots/array_container_defaults */ "./node_modules/plotly.js/src/plots/array_container_defaults.js");

var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/splom/attributes.js");
var subTypes = __webpack_require__(/*! ../scatter/subtypes */ "./node_modules/plotly.js/src/traces/scatter/subtypes.js");
var handleMarkerDefaults = __webpack_require__(/*! ../scatter/marker_defaults */ "./node_modules/plotly.js/src/traces/scatter/marker_defaults.js");
var mergeLength = __webpack_require__(/*! ../parcoords/merge_length */ "./node_modules/plotly.js/src/traces/parcoords/merge_length.js");
var isOpenSymbol = __webpack_require__(/*! ../scattergl/helpers */ "./node_modules/plotly.js/src/traces/scattergl/helpers.js").isOpenSymbol;

module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
    function coerce(attr, dflt) {
        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
    }

    var dimensions = handleArrayContainerDefaults(traceIn, traceOut, {
        name: 'dimensions',
        handleItemDefaults: dimensionDefaults
    });

    var showDiag = coerce('diagonal.visible');
    var showUpper = coerce('showupperhalf');
    var showLower = coerce('showlowerhalf');

    var dimLength = mergeLength(traceOut, dimensions, 'values');

    if(!dimLength || (!showDiag && !showUpper && !showLower)) {
        traceOut.visible = false;
        return;
    }

    coerce('text');
    coerce('hovertext');
    coerce('hovertemplate');

    handleMarkerDefaults(traceIn, traceOut, defaultColor, layout, coerce);

    var isOpen = isOpenSymbol(traceOut.marker.symbol);
    var isBubble = subTypes.isBubble(traceOut);
    coerce('marker.line.width', isOpen || isBubble ? 1 : 0);

    handleAxisDefaults(traceIn, traceOut, layout, coerce);

    Lib.coerceSelectionMarkerOpacity(traceOut, coerce);
};

function dimensionDefaults(dimIn, dimOut) {
    function coerce(attr, dflt) {
        return Lib.coerce(dimIn, dimOut, attributes.dimensions, attr, dflt);
    }

    coerce('label');
    var values = coerce('values');

    if(!(values && values.length)) dimOut.visible = false;
    else coerce('visible');

    coerce('axis.type');
    coerce('axis.matches');
}

function handleAxisDefaults(traceIn, traceOut, layout, coerce) {
    var dimensions = traceOut.dimensions;
    var dimLength = dimensions.length;
    var showUpper = traceOut.showupperhalf;
    var showLower = traceOut.showlowerhalf;
    var showDiag = traceOut.diagonal.visible;
    var i, j;

    var xAxesDflt = new Array(dimLength);
    var yAxesDflt = new Array(dimLength);

    for(i = 0; i < dimLength; i++) {
        var suffix = i ? i + 1 : '';
        xAxesDflt[i] = 'x' + suffix;
        yAxesDflt[i] = 'y' + suffix;
    }

    var xaxes = coerce('xaxes', xAxesDflt);
    var yaxes = coerce('yaxes', yAxesDflt);

    // build list of [x,y] axis corresponding to each dimensions[i],
    // very useful for passing options to regl-splom
    var diag = traceOut._diag = new Array(dimLength);

    // lookup for 'drawn' x|y axes, to avoid costly indexOf downstream
    traceOut._xaxes = {};
    traceOut._yaxes = {};

    // list of 'drawn' x|y axes, use to generate list of subplots
    var xList = [];
    var yList = [];

    function fillAxisStashes(axId, counterAxId, dim, list) {
        if(!axId) return;

        var axLetter = axId.charAt(0);
        var stash = layout._splomAxes[axLetter];

        traceOut['_' + axLetter + 'axes'][axId] = 1;
        list.push(axId);

        if(!(axId in stash)) {
            var s = stash[axId] = {};
            if(dim) {
                s.label = dim.label || '';
                if(dim.visible && dim.axis) {
                    if(dim.axis.type) s.type = dim.axis.type;
                    if(dim.axis.matches) s.matches = counterAxId;
                }
            }
        }
    }

    // cases where showDiag and showLower or showUpper are false
    // no special treatment as the 'drawn' x-axes and y-axes no longer match
    // the dimensions items and xaxes|yaxes 1-to-1
    var mustShiftX = !showDiag && !showLower;
    var mustShiftY = !showDiag && !showUpper;

    traceOut._axesDim = {};
    for(i = 0; i < dimLength; i++) {
        var dim = dimensions[i];
        var i0 = i === 0;
        var iN = i === dimLength - 1;

        var xaId = (i0 && mustShiftX) || (iN && mustShiftY) ?
            undefined :
            xaxes[i];

        var yaId = (i0 && mustShiftY) || (iN && mustShiftX) ?
            undefined :
            yaxes[i];

        fillAxisStashes(xaId, yaId, dim, xList);
        fillAxisStashes(yaId, xaId, dim, yList);
        diag[i] = [xaId, yaId];
        traceOut._axesDim[xaId] = i;
        traceOut._axesDim[yaId] = i;
    }

    // fill in splom subplot keys
    for(i = 0; i < xList.length; i++) {
        for(j = 0; j < yList.length; j++) {
            var id = xList[i] + yList[j];

            if(i > j && showUpper) {
                layout._splomSubplots[id] = 1;
            } else if(i < j && showLower) {
                layout._splomSubplots[id] = 1;
            } else if(i === j && (showDiag || !showLower || !showUpper)) {
                // need to include diagonal subplots when
                // hiding one half and the diagonal
                layout._splomSubplots[id] = 1;
            }
        }
    }

    // when lower half is omitted, or when just the diagonal is gone,
    // override grid default to make sure axes remain on
    // the left/bottom of the plot area
    if(!showLower || (!showDiag && showUpper && showLower)) {
        layout._splomGridDflt.xside = 'bottom';
        layout._splomGridDflt.yside = 'left';
    }
}


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/splom/edit_style.js":
/*!***************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/splom/edit_style.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var calcColorscale = __webpack_require__(/*! ../scatter/colorscale_calc */ "./node_modules/plotly.js/src/traces/scatter/colorscale_calc.js");
var convertMarkerStyle = __webpack_require__(/*! ../scattergl/convert */ "./node_modules/plotly.js/src/traces/scattergl/convert.js").markerStyle;

module.exports = function editStyle(gd, cd0) {
    var trace = cd0.trace;
    var scene = gd._fullLayout._splomScenes[trace.uid];

    if(scene) {
        calcColorscale(gd, trace);

        Lib.extendFlat(scene.matrixOptions, convertMarkerStyle(trace));
        // TODO [un]selected styles?

        var opts = Lib.extendFlat({}, scene.matrixOptions, scene.viewOpts);

        // TODO this is too long for arrayOk attributes!
        scene.matrix.update(opts, null);
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/splom/helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/splom/helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



exports.getDimIndex = function getDimIndex(trace, ax) {
    var axId = ax._id;
    var axLetter = axId.charAt(0);
    var ind = {x: 0, y: 1}[axLetter];
    var visibleDims = trace._visibleDims;

    for(var k = 0; k < visibleDims.length; k++) {
        var i = visibleDims[k];
        if(trace._diag[i][ind] === axId) return k;
    }
    return false;
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/splom/hover.js":
/*!**********************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/splom/hover.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/plotly.js/src/traces/splom/helpers.js");
var calcHover = __webpack_require__(/*! ../scattergl/hover */ "./node_modules/plotly.js/src/traces/scattergl/hover.js").calcHover;

function hoverPoints(pointData, xval, yval) {
    var cd = pointData.cd;
    var trace = cd[0].trace;
    var scene = pointData.scene;
    var cdata = scene.matrixOptions.cdata;
    var xa = pointData.xa;
    var ya = pointData.ya;
    var xpx = xa.c2p(xval);
    var ypx = ya.c2p(yval);
    var maxDistance = pointData.distance;

    var xi = helpers.getDimIndex(trace, xa);
    var yi = helpers.getDimIndex(trace, ya);
    if(xi === false || yi === false) return [pointData];

    var x = cdata[xi];
    var y = cdata[yi];

    var id, dxy;
    var minDist = maxDistance;

    for(var i = 0; i < x.length; i++) {
        var ptx = x[i];
        var pty = y[i];
        var dx = xa.c2p(ptx) - xpx;
        var dy = ya.c2p(pty) - ypx;
        var dist = Math.sqrt(dx * dx + dy * dy);

        if(dist < minDist) {
            minDist = dxy = dist;
            id = i;
        }
    }

    pointData.index = id;
    pointData.distance = minDist;
    pointData.dxy = dxy;

    if(id === undefined) return [pointData];

    return [calcHover(pointData, x, y, trace)];
}

module.exports = {
    hoverPoints: hoverPoints
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/splom/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/splom/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Registry = __webpack_require__(/*! ../../registry */ "./node_modules/plotly.js/src/registry.js");
var Grid = __webpack_require__(/*! ../../components/grid */ "./node_modules/plotly.js/src/components/grid/index.js");

module.exports = {
    moduleType: 'trace',
    name: 'splom',

    basePlotModule: __webpack_require__(/*! ./base_plot */ "./node_modules/plotly.js/src/traces/splom/base_plot.js"),
    categories: ['gl', 'regl', 'cartesian', 'symbols', 'showLegend', 'scatter-like'],

    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/splom/attributes.js"),
    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/splom/defaults.js"),
    colorbar: __webpack_require__(/*! ../scatter/marker_colorbar */ "./node_modules/plotly.js/src/traces/scatter/marker_colorbar.js"),

    calc: __webpack_require__(/*! ./calc */ "./node_modules/plotly.js/src/traces/splom/calc.js"),
    plot: __webpack_require__(/*! ./plot */ "./node_modules/plotly.js/src/traces/splom/plot.js"),
    hoverPoints: __webpack_require__(/*! ./hover */ "./node_modules/plotly.js/src/traces/splom/hover.js").hoverPoints,
    selectPoints: __webpack_require__(/*! ./select */ "./node_modules/plotly.js/src/traces/splom/select.js"),
    editStyle: __webpack_require__(/*! ./edit_style */ "./node_modules/plotly.js/src/traces/splom/edit_style.js"),

    meta: {
        description: [
            'Splom traces generate scatter plot matrix visualizations.',
            'Each splom `dimensions` items correspond to a generated axis.',
            'Values for each of those dimensions are set in `dimensions[i].values`.',
            'Splom traces support all `scattergl` marker style attributes.',
            'Specify `layout.grid` attributes and/or layout x-axis and y-axis attributes',
            'for more control over the axis positioning and style. '
        ].join(' ')
    }
};

// splom traces use the 'grid' component to generate their axes,
// register it here
Registry.register(Grid);


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/splom/plot.js":
/*!*********************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/splom/plot.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var createMatrix = __webpack_require__(/*! regl-splom */ "./node_modules/regl-splom/index.js");

var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var AxisIDs = __webpack_require__(/*! ../../plots/cartesian/axis_ids */ "./node_modules/plotly.js/src/plots/cartesian/axis_ids.js");
var selectMode = __webpack_require__(/*! ../../components/dragelement/helpers */ "./node_modules/plotly.js/src/components/dragelement/helpers.js").selectMode;

module.exports = function plot(gd, _, splomCalcData) {
    if(!splomCalcData.length) return;

    for(var i = 0; i < splomCalcData.length; i++) {
        plotOne(gd, splomCalcData[i][0]);
    }
};

function plotOne(gd, cd0) {
    var fullLayout = gd._fullLayout;
    var gs = fullLayout._size;
    var trace = cd0.trace;
    var stash = cd0.t;
    var scene = fullLayout._splomScenes[trace.uid];
    var matrixOpts = scene.matrixOptions;
    var cdata = matrixOpts.cdata;
    var regl = fullLayout._glcanvas.data()[0].regl;
    var dragmode = fullLayout.dragmode;
    var xa, ya;
    var i, j, k;

    if(cdata.length === 0) return;

    // augment options with proper upper/lower halves
    // regl-splom's default grid starts from bottom-left
    matrixOpts.lower = trace.showupperhalf;
    matrixOpts.upper = trace.showlowerhalf;
    matrixOpts.diagonal = trace.diagonal.visible;

    var visibleDims = trace._visibleDims;
    var visibleLength = cdata.length;
    var viewOpts = scene.viewOpts = {};
    viewOpts.ranges = new Array(visibleLength);
    viewOpts.domains = new Array(visibleLength);

    for(k = 0; k < visibleDims.length; k++) {
        i = visibleDims[k];

        var rng = viewOpts.ranges[k] = new Array(4);
        var dmn = viewOpts.domains[k] = new Array(4);

        xa = AxisIDs.getFromId(gd, trace._diag[i][0]);
        if(xa) {
            rng[0] = xa._rl[0];
            rng[2] = xa._rl[1];
            dmn[0] = xa.domain[0];
            dmn[2] = xa.domain[1];
        }

        ya = AxisIDs.getFromId(gd, trace._diag[i][1]);
        if(ya) {
            rng[1] = ya._rl[0];
            rng[3] = ya._rl[1];
            dmn[1] = ya.domain[0];
            dmn[3] = ya.domain[1];
        }
    }

    viewOpts.viewport = [gs.l, gs.b, gs.w + gs.l, gs.h + gs.b];

    if(scene.matrix === true) {
        scene.matrix = createMatrix(regl);
    }

    var clickSelectEnabled = fullLayout.clickmode.indexOf('select') > -1;
    var isSelectMode = selectMode(dragmode) ||
      !!trace.selectedpoints || clickSelectEnabled;
    var needsBaseUpdate = true;

    if(isSelectMode) {
        var commonLength = trace._length;

        // regenerate scene batch, if traces number changed during selection
        if(trace.selectedpoints) {
            scene.selectBatch = trace.selectedpoints;

            var selPts = trace.selectedpoints;
            var selDict = {};
            for(i = 0; i < selPts.length; i++) {
                selDict[selPts[i]] = true;
            }
            var unselPts = [];
            for(i = 0; i < commonLength; i++) {
                if(!selDict[i]) unselPts.push(i);
            }
            scene.unselectBatch = unselPts;
        }

        // precalculate px coords since we are not going to pan during select
        var xpx = stash.xpx = new Array(visibleLength);
        var ypx = stash.ypx = new Array(visibleLength);

        for(k = 0; k < visibleDims.length; k++) {
            i = visibleDims[k];

            xa = AxisIDs.getFromId(gd, trace._diag[i][0]);
            if(xa) {
                xpx[k] = new Array(commonLength);
                for(j = 0; j < commonLength; j++) {
                    xpx[k][j] = xa.c2p(cdata[k][j]);
                }
            }

            ya = AxisIDs.getFromId(gd, trace._diag[i][1]);
            if(ya) {
                ypx[k] = new Array(commonLength);
                for(j = 0; j < commonLength; j++) {
                    ypx[k][j] = ya.c2p(cdata[k][j]);
                }
            }
        }

        if(scene.selectBatch.length || scene.unselectBatch.length) {
            var unselOpts = Lib.extendFlat({}, matrixOpts, scene.unselectedOptions, viewOpts);
            var selOpts = Lib.extendFlat({}, matrixOpts, scene.selectedOptions, viewOpts);
            scene.matrix.update(unselOpts, selOpts);
            needsBaseUpdate = false;
        }
    } else {
        stash.xpx = stash.ypx = null;
    }

    if(needsBaseUpdate) {
        var opts = Lib.extendFlat({}, matrixOpts, viewOpts);
        scene.matrix.update(opts, null);
    }
}


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/splom/scene_update.js":
/*!*****************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/splom/scene_update.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");

module.exports = function sceneUpdate(gd, trace) {
    var fullLayout = gd._fullLayout;
    var uid = trace.uid;

    // must place ref to 'scene' in fullLayout, so that:
    // - it can be relinked properly on updates
    // - it can be destroyed properly when needed
    var splomScenes = fullLayout._splomScenes;
    if(!splomScenes) splomScenes = fullLayout._splomScenes = {};

    var reset = {
        dirty: true,
        selectBatch: [],
        unselectBatch: []
    };

    var first = {
        matrix: false,
        selectBatch: [],
        unselectBatch: []
    };

    var scene = splomScenes[trace.uid];

    if(!scene) {
        scene = splomScenes[uid] = Lib.extendFlat({}, reset, first);

        scene.draw = function draw() {
            if(scene.matrix && scene.matrix.draw) {
                if(scene.selectBatch.length || scene.unselectBatch.length) {
                    scene.matrix.draw(scene.unselectBatch, scene.selectBatch);
                } else {
                    scene.matrix.draw();
                }
            }

            scene.dirty = false;
        };

        // remove scene resources
        scene.destroy = function destroy() {
            if(scene.matrix && scene.matrix.destroy) {
                scene.matrix.destroy();
            }
            scene.matrixOptions = null;
            scene.selectBatch = null;
            scene.unselectBatch = null;
            scene = null;
        };
    }

    // In case if we have scene from the last calc - reset data
    if(!scene.dirty) {
        Lib.extendFlat(scene, reset);
    }

    return scene;
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/splom/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/splom/select.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var subTypes = __webpack_require__(/*! ../scatter/subtypes */ "./node_modules/plotly.js/src/traces/scatter/subtypes.js");
var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/plotly.js/src/traces/splom/helpers.js");

module.exports = function select(searchInfo, selectionTester) {
    var cd = searchInfo.cd;
    var trace = cd[0].trace;
    var stash = cd[0].t;
    var scene = searchInfo.scene;
    var cdata = scene.matrixOptions.cdata;
    var xa = searchInfo.xaxis;
    var ya = searchInfo.yaxis;
    var selection = [];

    if(!scene) return selection;

    var hasOnlyLines = (!subTypes.hasMarkers(trace) && !subTypes.hasText(trace));
    if(trace.visible !== true || hasOnlyLines) return selection;

    var xi = helpers.getDimIndex(trace, xa);
    var yi = helpers.getDimIndex(trace, ya);
    if(xi === false || yi === false) return selection;

    var xpx = stash.xpx[xi];
    var ypx = stash.ypx[yi];
    var x = cdata[xi];
    var y = cdata[yi];
    var els = [];
    var unels = [];

    // degenerate polygon does not enable selection
    // filter out points by visible scatter ones
    if(selectionTester !== false && !selectionTester.degenerate) {
        for(var i = 0; i < x.length; i++) {
            if(selectionTester.contains([xpx[i], ypx[i]], null, i, searchInfo)) {
                els.push(i);
                selection.push({
                    pointNumber: i,
                    x: x[i],
                    y: y[i]
                });
            } else {
                unels.push(i);
            }
        }
    }

    var matrixOpts = scene.matrixOptions;

    if(!els.length && !unels.length) {
        scene.matrix.update(matrixOpts, null);
    } else if(!scene.selectBatch.length && !scene.unselectBatch.length) {
        scene.matrix.update(
            scene.unselectedOptions,
            Lib.extendFlat({}, matrixOpts, scene.selectedOptions, scene.viewOpts)
        );
    }

    scene.selectBatch = els;
    scene.unselectBatch = unels;

    return selection;
};


/***/ }),

/***/ "./node_modules/raf/index.js":
/*!***********************************!*\
  !*** ./node_modules/raf/index.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var now = __webpack_require__(/*! performance-now */ "./node_modules/performance-now/lib/performance-now.js")
  , root = typeof window === 'undefined' ? __webpack_require__.g : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf
  object.cancelAnimationFrame = caf
}


/***/ }),

/***/ "./node_modules/regl-splom/index.js":
/*!******************************************!*\
  !*** ./node_modules/regl-splom/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



const createScatter = __webpack_require__(/*! regl-scatter2d */ "./node_modules/regl-scatter2d/bundle.js")
const pick = __webpack_require__(/*! pick-by-alias */ "./node_modules/pick-by-alias/index.js")
const getBounds = __webpack_require__(/*! array-bounds */ "./node_modules/array-bounds/index.js")
const raf = __webpack_require__(/*! raf */ "./node_modules/raf/index.js")
const arrRange = __webpack_require__(/*! array-range */ "./node_modules/array-range/index.js")
const rect = __webpack_require__(/*! parse-rect */ "./node_modules/parse-rect/index.js")
const flatten = __webpack_require__(/*! flatten-vertex-data */ "./node_modules/flatten-vertex-data/index.js")


module.exports = SPLOM


// @constructor
function SPLOM (regl, options) {
	if (!(this instanceof SPLOM)) return new SPLOM(regl, options)

	// render passes
	this.traces = []

	// passes for scatter, combined across traces
	this.passes = {}

	this.regl = regl

	// main scatter drawing instance
	this.scatter = createScatter(regl)

	this.canvas = this.scatter.canvas
}


// update & draw passes once per frame
SPLOM.prototype.render = function (...args) {
	if (args.length) {
		this.update(...args)
	}

	if (this.regl.attributes.preserveDrawingBuffer) return this.draw()

	// make sure draw is not called more often than once a frame
	if (this.dirty) {
		if (this.planned == null) {
			this.planned = raf(() => {
				this.draw()
				this.dirty = true
				this.planned = null
			})
		}
	}
	else {
		this.draw()
		this.dirty = true
		raf(() => {
			this.dirty = false
		})
	}

	return this
}


// update passes
SPLOM.prototype.update = function (...args) {
	if (!args.length) return

	for (let i = 0; i < args.length; i++) {
		this.updateItem(i, args[i])
	}

	// remove nulled passes
	this.traces = this.traces.filter(Boolean)

	// FIXME: update passes independently
	let passes = []
	let offset = 0
	for (let i = 0; i < this.traces.length; i++) {
		let trace = this.traces[i]
		let tracePasses = this.traces[i].passes
		for (let j = 0; j < tracePasses.length; j++) {
			passes.push(this.passes[tracePasses[j]])
		}
		// save offset of passes
		trace.passOffset = offset
		offset += trace.passes.length
	}

	this.scatter.update(...passes)

	return this
}


// update trace by index, not supposed to be called directly
SPLOM.prototype.updateItem = function (i, options) {
	let { regl } = this

	// remove pass if null
	if (options === null) {
		this.traces[i] = null
		return this
	}

	if (!options) return this

	let o = pick(options, {
		data: 'data items columns rows values dimensions samples x',
		snap: 'snap cluster',
		size: 'sizes size radius',
		color: 'colors color fill fill-color fillColor',
		opacity: 'opacity alpha transparency opaque',
		borderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',
		borderColor: 'borderColors borderColor bordercolor stroke stroke-color strokeColor',
		marker: 'markers marker shape',
		range: 'range ranges databox dataBox',
		viewport: 'viewport viewBox viewbox',
		domain: 'domain domains area areas',
		padding: 'pad padding paddings pads margin margins',
		transpose: 'transpose transposed',
		diagonal: 'diagonal diag showDiagonal',
		upper: 'upper up top upperhalf upperHalf showupperhalf showUpper showUpperHalf',
		lower: 'lower low bottom lowerhalf lowerHalf showlowerhalf showLowerHalf showLower'
	})

	// we provide regl buffer per-trace, since trace data can be changed
	let trace = (this.traces[i] || (this.traces[i] = {
		id: i,
		buffer: regl.buffer({
			usage: 'dynamic',
			type: 'float',
			data: new Uint8Array()
		}),
		color: 'black',
		marker: null,
		size: 12,
		borderColor: 'transparent',
		borderSize: 1,
		viewport:  rect([regl._gl.drawingBufferWidth, regl._gl.drawingBufferHeight]),
		padding: [0, 0, 0, 0],
		opacity: 1,
		diagonal: true,
		upper: true,
		lower: true
	}))


	// save styles
	if (o.color != null) {
		trace.color = o.color
	}
	if (o.size != null) {
		trace.size = o.size
	}
	if (o.marker != null) {
		trace.marker = o.marker
	}
	if (o.borderColor != null) {
		trace.borderColor = o.borderColor
	}
	if (o.borderSize != null) {
		trace.borderSize = o.borderSize
	}
	if (o.opacity != null) {
		trace.opacity = o.opacity
	}
	if (o.viewport) {
		trace.viewport = rect(o.viewport)
	}
	if (o.diagonal != null) trace.diagonal = o.diagonal
	if (o.upper != null) trace.upper = o.upper
	if (o.lower != null) trace.lower = o.lower

	// put flattened data into buffer
	if (o.data) {
		trace.buffer(flatten(o.data))
		trace.columns = o.data.length
		trace.count = o.data[0].length

		// detect bounds per-column
		trace.bounds = []

		for (let i = 0; i < trace.columns; i++) {
			trace.bounds[i] = getBounds(o.data[i], 1)
		}
	}

	// add proper range updating markers
	let multirange
	if (o.range) {
		trace.range = o.range
		multirange = trace.range && typeof trace.range[0] !== 'number'
	}

	if (o.domain) {
		trace.domain = o.domain
	}
	let multipadding = false
	if (o.padding != null) {
		// multiple paddings
		if (Array.isArray(o.padding) && o.padding.length === trace.columns && typeof o.padding[o.padding.length - 1] === 'number') {
			trace.padding = o.padding.map(getPad)
			multipadding = true
		}
		// single padding
		else {
			trace.padding = getPad(o.padding)
		}
	}

	// create passes
	let m = trace.columns
	let n = trace.count

	let w = trace.viewport.width
	let h = trace.viewport.height
	let left = trace.viewport.x
	let top = trace.viewport.y
	let iw = w / m
	let ih = h / m

	trace.passes = []

	for (let i = 0; i < m; i++) {
		for (let j = 0; j < m; j++) {
			if (!trace.diagonal && j === i) continue
			if (!trace.upper && i > j) continue
			if (!trace.lower && i < j) continue

			let key = passId(trace.id, i, j)

			let pass = this.passes[key] || (this.passes[key] = {})

			if (o.data) {
				if (o.transpose) {
					pass.positions = {
						x: {buffer: trace.buffer, offset: j, count: n, stride: m},
						y: {buffer: trace.buffer, offset: i, count: n, stride: m}
					}
				}
				else {
					pass.positions = {
						x: {buffer: trace.buffer, offset: j * n, count: n},
						y: {buffer: trace.buffer, offset: i * n, count: n}
					}
				}

				pass.bounds = getBox(trace.bounds, i, j)
			}

			if (o.domain || o.viewport || o.data) {
				let pad = multipadding ? getBox(trace.padding, i, j) : trace.padding
				if (trace.domain) {
					let [lox, loy, hix, hiy] = getBox(trace.domain, i, j)

					pass.viewport = [
						left + lox * w + pad[0],
						top + loy * h + pad[1],
						left + hix * w - pad[2],
						top + hiy * h - pad[3]
					]
				}
				// consider auto-domain equipartial
				else {
					pass.viewport = [
						left + j * iw + iw * pad[0],
						top + i * ih + ih * pad[1],
						left + (j + 1) * iw - iw * pad[2],
						top + (i + 1) * ih - ih * pad[3]
					]
				}
			}

			if (o.color) pass.color = trace.color
			if (o.size) pass.size = trace.size
			if (o.marker) pass.marker = trace.marker
			if (o.borderSize) pass.borderSize = trace.borderSize
			if (o.borderColor) pass.borderColor = trace.borderColor
			if (o.opacity) pass.opacity = trace.opacity

			if (o.range) {
				pass.range = multirange ? getBox(trace.range, i, j) : trace.range || pass.bounds
			}

			trace.passes.push(key)
		}
	}

	return this
}


// draw all or passed passes
SPLOM.prototype.draw = function (...args) {
	if (!args.length) {
		this.scatter.draw()
	}
	else {
		let idx = []
		for (let i = 0; i < args.length; i++) {
			// draw(0, 2, 5) - draw traces
			if (typeof args[i] === 'number' ) {
				let { passes, passOffset } = this.traces[args[i]]
				idx.push(...arrRange(passOffset, passOffset + passes.length))
			}
			// draw([0, 1, 2 ...], [3, 4, 5]) - draw points
			else if (args[i].length) {
				let els = args[i]
				let { passes, passOffset } = this.traces[i]
				passes = passes.map((passId, i) => {
					idx[passOffset + i] = els
				})
			}
		}
		this.scatter.draw(...idx)
	}

	return this
}


// dispose resources
SPLOM.prototype.destroy = function () {
	this.traces.forEach(trace => {
		if (trace.buffer && trace.buffer.destroy) trace.buffer.destroy()
	})
	this.traces = null
	this.passes = null

	this.scatter.destroy()

	return this
}


// return pass corresponding to trace i- j- square
function passId (trace, i, j) {
	let id = (trace.id != null ? trace.id : trace)
	let n = i
	let m = j
	let key = id << 16 | (n & 0xff) << 8 | m & 0xff

	return key
}


// return bounding box corresponding to a pass
function getBox (items, i, j) {
	let ilox, iloy, ihix, ihiy, jlox, jloy, jhix, jhiy
	let iitem = items[i], jitem = items[j]

	if (iitem.length > 2) {
		ilox = iitem[0]
		ihix = iitem[2]
		iloy = iitem[1]
		ihiy = iitem[3]
	}
	else if (iitem.length) {
		ilox = iloy = iitem[0]
		ihix = ihiy = iitem[1]
	}
	else {
		ilox = iitem.x
		iloy = iitem.y
		ihix = iitem.x + iitem.width
		ihiy = iitem.y + iitem.height
	}

	if (jitem.length > 2) {
		jlox = jitem[0]
		jhix = jitem[2]
		jloy = jitem[1]
		jhiy = jitem[3]
	}
	else if (jitem.length) {
		jlox = jloy = jitem[0]
		jhix = jhiy = jitem[1]
	}
	else {
		jlox = jitem.x
		jloy = jitem.y
		jhix = jitem.x + jitem.width
		jhiy = jitem.y + jitem.height
	}

	return [ jlox, iloy, jhix, ihiy ]
}


function getPad (arg) {
	if (typeof arg === 'number') return [arg, arg, arg, arg]
	else if (arg.length === 2) return [arg[0], arg[1], arg[0], arg[1]]
	else {
		let box = rect(arg)
		return [box.x, box.y, box.x + box.width, box.y + box.height]
	}
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2FycmF5LXJhbmdlL2luZGV4LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGVyZm9ybWFuY2Utbm93L2xpYi9wZXJmb3JtYW5jZS1ub3cuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvbGliL3NwbG9tLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvc3Bsb20vYXR0cmlidXRlcy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL3NwbG9tL2Jhc2VfcGxvdC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL3NwbG9tL2NhbGMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9zcGxvbS9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL3NwbG9tL2VkaXRfc3R5bGUuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9zcGxvbS9oZWxwZXJzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvc3Bsb20vaG92ZXIuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9zcGxvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL3NwbG9tL3Bsb3QuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9zcGxvbS9zY2VuZV91cGRhdGUuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9zcGxvbS9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yYWYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yZWdsLXNwbG9tL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0EsQzs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLHFIQUErQzs7Ozs7Ozs7Ozs7O0FDVi9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLHdGQUF1QjtBQUNsRCxzQkFBc0IsbUJBQU8sQ0FBQyxnSEFBd0M7QUFDdEUseUJBQXlCLDBJQUE2RDtBQUN0RixxQkFBcUIsbUJBQU8sQ0FBQyw0RkFBeUI7QUFDdEQsdUJBQXVCLCtIQUFrRDtBQUN6RSxxQkFBcUIsZ0lBQXNEO0FBQzNF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Q0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImNoYXJ0MDhkYzFhNzA0OWI5MGNkM2VlMjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbmV3QXJyYXkoc3RhcnQsIGVuZCkge1xuICAgIHZhciBuMCA9IHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicsXG4gICAgICAgIG4xID0gdHlwZW9mIGVuZCA9PT0gJ251bWJlcidcblxuICAgIGlmIChuMCAmJiAhbjEpIHtcbiAgICAgICAgZW5kID0gc3RhcnRcbiAgICAgICAgc3RhcnQgPSAwXG4gICAgfSBlbHNlIGlmICghbjAgJiYgIW4xKSB7XG4gICAgICAgIHN0YXJ0ID0gMFxuICAgICAgICBlbmQgPSAwXG4gICAgfVxuXG4gICAgc3RhcnQgPSBzdGFydHwwXG4gICAgZW5kID0gZW5kfDBcbiAgICB2YXIgbGVuID0gZW5kLXN0YXJ0XG4gICAgaWYgKGxlbjwwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGxlbmd0aCBtdXN0IGJlIHBvc2l0aXZlJylcbiAgICBcbiAgICB2YXIgYSA9IG5ldyBBcnJheShsZW4pXG4gICAgZm9yICh2YXIgaT0wLCBjPXN0YXJ0OyBpPGxlbjsgaSsrLCBjKyspXG4gICAgICAgIGFbaV0gPSBjXG4gICAgcmV0dXJuIGFcbn0iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZ2V0TmFub1NlY29uZHMsIGhydGltZSwgbG9hZFRpbWUsIG1vZHVsZUxvYWRUaW1lLCBub2RlTG9hZFRpbWUsIHVwVGltZTtcblxuICBpZiAoKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwZXJmb3JtYW5jZSAhPT0gbnVsbCkgJiYgcGVyZm9ybWFuY2Uubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzICE9PSBudWxsKSAmJiBwcm9jZXNzLmhydGltZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGdldE5hbm9TZWNvbmRzKCkgLSBub2RlTG9hZFRpbWUpIC8gMWU2O1xuICAgIH07XG4gICAgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWU7XG4gICAgZ2V0TmFub1NlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBocjtcbiAgICAgIGhyID0gaHJ0aW1lKCk7XG4gICAgICByZXR1cm4gaHJbMF0gKiAxZTkgKyBoclsxXTtcbiAgICB9O1xuICAgIG1vZHVsZUxvYWRUaW1lID0gZ2V0TmFub1NlY29uZHMoKTtcbiAgICB1cFRpbWUgPSBwcm9jZXNzLnVwdGltZSgpICogMWU5O1xuICAgIG5vZGVMb2FkVGltZSA9IG1vZHVsZUxvYWRUaW1lIC0gdXBUaW1lO1xuICB9IGVsc2UgaWYgKERhdGUubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IERhdGUubm93KCk7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJmb3JtYW5jZS1ub3cuanMubWFwXG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vc3JjL3RyYWNlcy9zcGxvbScpO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2NhdHRlckF0dHJzID0gcmVxdWlyZSgnLi4vc2NhdHRlci9hdHRyaWJ1dGVzJyk7XG52YXIgY29sb3JTY2FsZUF0dHJzID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50cy9jb2xvcnNjYWxlL2F0dHJpYnV0ZXMnKTtcbnZhciBob3ZlcnRlbXBsYXRlQXR0cnMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy90ZW1wbGF0ZV9hdHRyaWJ1dGVzJykuaG92ZXJ0ZW1wbGF0ZUF0dHJzO1xudmFyIHNjYXR0ZXJHbEF0dHJzID0gcmVxdWlyZSgnLi4vc2NhdHRlcmdsL2F0dHJpYnV0ZXMnKTtcbnZhciBjYXJ0ZXNpYW5JZFJlZ2V4ID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuL2NvbnN0YW50cycpLmlkUmVnZXg7XG52YXIgdGVtcGxhdGVkQXJyYXkgPSByZXF1aXJlKCcuLi8uLi9wbG90X2FwaS9wbG90X3RlbXBsYXRlJykudGVtcGxhdGVkQXJyYXk7XG52YXIgZXh0ZW5kRmxhdCA9IHJlcXVpcmUoJy4uLy4uL2xpYi9leHRlbmQnKS5leHRlbmRGbGF0O1xuXG52YXIgc2NhdHRlck1hcmtlckF0dHJzID0gc2NhdHRlckF0dHJzLm1hcmtlcjtcbnZhciBzY2F0dGVyTWFya2VyTGluZUF0dHJzID0gc2NhdHRlck1hcmtlckF0dHJzLmxpbmU7XG5cbnZhciBtYXJrZXJMaW5lQXR0cnMgPSBleHRlbmRGbGF0KGNvbG9yU2NhbGVBdHRycygnbWFya2VyLmxpbmUnLCB7ZWRpdFR5cGVPdmVycmlkZTogJ2NhbGMnfSksIHtcbiAgICB3aWR0aDogZXh0ZW5kRmxhdCh7fSwgc2NhdHRlck1hcmtlckxpbmVBdHRycy53aWR0aCwge2VkaXRUeXBlOiAnY2FsYyd9KSxcbiAgICBlZGl0VHlwZTogJ2NhbGMnXG59KTtcblxudmFyIG1hcmtlckF0dHJzID0gZXh0ZW5kRmxhdChjb2xvclNjYWxlQXR0cnMoJ21hcmtlcicpLCB7XG4gICAgc3ltYm9sOiBzY2F0dGVyTWFya2VyQXR0cnMuc3ltYm9sLFxuICAgIHNpemU6IGV4dGVuZEZsYXQoe30sIHNjYXR0ZXJNYXJrZXJBdHRycy5zaXplLCB7ZWRpdFR5cGU6ICdtYXJrZXJTaXplJ30pLFxuICAgIHNpemVyZWY6IHNjYXR0ZXJNYXJrZXJBdHRycy5zaXplcmVmLFxuICAgIHNpemVtaW46IHNjYXR0ZXJNYXJrZXJBdHRycy5zaXplbWluLFxuICAgIHNpemVtb2RlOiBzY2F0dGVyTWFya2VyQXR0cnMuc2l6ZW1vZGUsXG4gICAgb3BhY2l0eTogc2NhdHRlck1hcmtlckF0dHJzLm9wYWNpdHksXG4gICAgY29sb3JiYXI6IHNjYXR0ZXJNYXJrZXJBdHRycy5jb2xvcmJhcixcbiAgICBsaW5lOiBtYXJrZXJMaW5lQXR0cnMsXG4gICAgZWRpdFR5cGU6ICdjYWxjJ1xufSk7XG5cbm1hcmtlckF0dHJzLmNvbG9yLmVkaXRUeXBlID0gbWFya2VyQXR0cnMuY21pbi5lZGl0VHlwZSA9IG1hcmtlckF0dHJzLmNtYXguZWRpdFR5cGUgPSAnc3R5bGUnO1xuXG5mdW5jdGlvbiBtYWtlQXhlc1ZhbE9iamVjdChheExldHRlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbFR5cGU6ICdpbmZvX2FycmF5JyxcbiAgICAgICAgZnJlZUxlbmd0aDogdHJ1ZSxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBlZGl0VHlwZTogJ2NhbGMnLFxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgdmFsVHlwZTogJ3N1YnBsb3RpZCcsXG4gICAgICAgICAgICByZWdleDogY2FydGVzaWFuSWRSZWdleFtheExldHRlcl0sXG4gICAgICAgICAgICBlZGl0VHlwZTogJ3Bsb3QnXG4gICAgICAgIH0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnU2V0cyB0aGUgbGlzdCBvZiAnICsgYXhMZXR0ZXIgKyAnIGF4ZXMnLFxuICAgICAgICAgICAgJ2NvcnJlc3BvbmRpbmcgdG8gZGltZW5zaW9ucyBvZiB0aGlzIHNwbG9tIHRyYWNlLicsXG4gICAgICAgICAgICAnQnkgZGVmYXVsdCwgYSBzcGxvbSB3aWxsIG1hdGNoIHRoZSBmaXJzdCBOICcgKyBheExldHRlciArICdheGVzJyxcbiAgICAgICAgICAgICd3aGVyZSBOIGlzIHRoZSBudW1iZXIgb2YgaW5wdXQgZGltZW5zaW9ucy4nLFxuICAgICAgICAgICAgJ05vdGUgdGhhdCwgaW4gY2FzZSB3aGVyZSBgZGlhZ29uYWwudmlzaWJsZWAgaXMgZmFsc2UgYW5kIGBzaG93dXBwZXJoYWxmYCcsXG4gICAgICAgICAgICAnb3IgYHNob3dsb3dlcmhhbGZgIGlzIGZhbHNlLCB0aGlzIHNwbG9tIHRyYWNlIHdpbGwgZ2VuZXJhdGUnLFxuICAgICAgICAgICAgJ29uZSBsZXNzIHgtYXhpcyBhbmQgb25lIGxlc3MgeS1heGlzLicsXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGltZW5zaW9uczogdGVtcGxhdGVkQXJyYXkoJ2RpbWVuc2lvbicsIHtcbiAgICAgICAgdmlzaWJsZToge1xuICAgICAgICAgICAgdmFsVHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICAgICAgZGZsdDogdHJ1ZSxcbiAgICAgICAgICAgIGVkaXRUeXBlOiAnY2FsYycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgICAgICdEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoaXMgZGltZW5zaW9uIGlzIHNob3duIG9uIHRoZSBncmFwaC4nLFxuICAgICAgICAgICAgICAgICdOb3RlIHRoYXQgZXZlbiB2aXNpYmxlIGZhbHNlIGRpbWVuc2lvbiBjb250cmlidXRlIHRvIHRoZScsXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHQgZ3JpZCBnZW5lcmF0ZSBieSB0aGlzIHNwbG9tIHRyYWNlLidcbiAgICAgICAgICAgIF0uam9pbignICcpXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICB2YWxUeXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgICAgIGVkaXRUeXBlOiAnY2FsYycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIGxhYmVsIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBzcGxvbSBkaW1lbnNpb24uJ1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIHZhbFR5cGU6ICdkYXRhX2FycmF5JyxcbiAgICAgICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgICAgIGVkaXRUeXBlOiAnY2FsYytjbGVhckF4aXNUeXBlcycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1NldHMgdGhlIGRpbWVuc2lvbiB2YWx1ZXMgdG8gYmUgcGxvdHRlZC4nXG4gICAgICAgIH0sXG5cbiAgICAgICAgYXhpczoge1xuICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgIHZhbFR5cGU6ICdlbnVtZXJhdGVkJyxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFsnbGluZWFyJywgJ2xvZycsICdkYXRlJywgJ2NhdGVnb3J5J10sXG4gICAgICAgICAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICAgICAgICAgIGVkaXRUeXBlOiAnY2FsYytjbGVhckF4aXNUeXBlcycsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICAgICAgICAgJ1NldHMgdGhlIGF4aXMgdHlwZSBmb3IgdGhpcyBkaW1lbnNpb25cXCdzIGdlbmVyYXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICd4IGFuZCB5IGF4ZXMuJyxcbiAgICAgICAgICAgICAgICAgICAgJ05vdGUgdGhhdCB0aGUgYXhpcyBgdHlwZWAgdmFsdWVzIHNldCBpbiBsYXlvdXQgdGFrZScsXG4gICAgICAgICAgICAgICAgICAgICdwcmVjZWRlbmNlIG92ZXIgdGhpcyBhdHRyaWJ1dGUuJ1xuICAgICAgICAgICAgICAgIF0uam9pbignICcpXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBUT0RPIG1ha2UgJ3RydWUnIHRoZSBkZWZhdWx0IGluIHYyP1xuICAgICAgICAgICAgbWF0Y2hlczoge1xuICAgICAgICAgICAgICAgIHZhbFR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICBkZmx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgICAgICAgICAgZWRpdFR5cGU6ICdjYWxjJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgICAgICAgICAnRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgeCAmIHkgYXhlcyBnZW5lcmF0ZWQgYnkgdGhpcycsXG4gICAgICAgICAgICAgICAgICAgICdkaW1lbnNpb24gbWF0Y2guJyxcbiAgICAgICAgICAgICAgICAgICAgJ0VxdWl2YWxlbnQgdG8gc2V0dGluZyB0aGUgYG1hdGNoZXNgIGF4aXMgYXR0cmlidXRlIGluIHRoZSBsYXlvdXQnLFxuICAgICAgICAgICAgICAgICAgICAnd2l0aCB0aGUgY29ycmVjdCBheGlzIGlkLidcbiAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZWRpdFR5cGU6ICdjYWxjK2NsZWFyQXhpc1R5cGVzJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRPRE8gc2hvdWxkIGFkZCBhbiBhdHRyaWJ1dGUgdG8gcGluIGRvd24geCBvbmx5IHZhcnMgYW5kIHkgb25seSB2YXJzXG4gICAgICAgIC8vIGxpa2UgaHR0cHM6Ly9zZWFib3JuLnB5ZGF0YS5vcmcvZ2VuZXJhdGVkL3NlYWJvcm4ucGFpcnBsb3QuaHRtbFxuICAgICAgICAvLyB4X3ZhcnMgYW5kIHlfdmFyc1xuXG4gICAgICAgIC8vIG1heWJlIG1vcmUgYXhpcyBkZWZhdWx0aW5nIG9wdGlvbiBlLmcuIGBzaG93Z3JpZDogZmFsc2VgXG5cbiAgICAgICAgZWRpdFR5cGU6ICdjYWxjK2NsZWFyQXhpc1R5cGVzJ1xuICAgIH0pLFxuXG4gICAgLy8gbW9kZToge30sIChvbmx5ICdtYXJrZXJzJyBmb3Igbm93KVxuXG4gICAgdGV4dDogZXh0ZW5kRmxhdCh7fSwgc2NhdHRlckdsQXR0cnMudGV4dCwge1xuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1NldHMgdGV4dCBlbGVtZW50cyBhc3NvY2lhdGVkIHdpdGggZWFjaCAoeCx5KSBwYWlyIHRvIGFwcGVhciBvbiBob3Zlci4nLFxuICAgICAgICAgICAgJ0lmIGEgc2luZ2xlIHN0cmluZywgdGhlIHNhbWUgc3RyaW5nIGFwcGVhcnMgb3ZlcicsXG4gICAgICAgICAgICAnYWxsIHRoZSBkYXRhIHBvaW50cy4nLFxuICAgICAgICAgICAgJ0lmIGFuIGFycmF5IG9mIHN0cmluZywgdGhlIGl0ZW1zIGFyZSBtYXBwZWQgaW4gb3JkZXIgdG8gdGhlJyxcbiAgICAgICAgICAgICd0aGlzIHRyYWNlXFwncyAoeCx5KSBjb29yZGluYXRlcy4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSksXG4gICAgaG92ZXJ0ZXh0OiBleHRlbmRGbGF0KHt9LCBzY2F0dGVyR2xBdHRycy5ob3ZlcnRleHQsIHtcbiAgICAgICAgZGVzY3JpcHRpb246ICdTYW1lIGFzIGB0ZXh0YC4nXG4gICAgfSksXG5cbiAgICBob3ZlcnRlbXBsYXRlOiBob3ZlcnRlbXBsYXRlQXR0cnMoKSxcblxuICAgIG1hcmtlcjogbWFya2VyQXR0cnMsXG5cbiAgICB4YXhlczogbWFrZUF4ZXNWYWxPYmplY3QoJ3gnKSxcbiAgICB5YXhlczogbWFrZUF4ZXNWYWxPYmplY3QoJ3knKSxcblxuICAgIGRpYWdvbmFsOiB7XG4gICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICAgIHZhbFR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgIHJvbGU6ICdpbmZvJyxcbiAgICAgICAgICAgIGRmbHQ6IHRydWUsXG4gICAgICAgICAgICBlZGl0VHlwZTogJ2NhbGMnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICAgICAnRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCBzdWJwbG90cyBvbiB0aGUgZGlhZ29uYWwgYXJlIGRpc3BsYXllZC4nXG4gICAgICAgICAgICBdLmpvaW4oJyAnKVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHR5cGU6ICdzY2F0dGVyZ2wnIHwgJ2hpc3RvZ3JhbScgfCAnYm94JyB8ICd2aW9saW4nXG4gICAgICAgIC8vIC4uLlxuICAgICAgICAvLyBtb3JlIG9wdGlvbnNcblxuICAgICAgICBlZGl0VHlwZTogJ2NhbGMnXG4gICAgfSxcblxuICAgIHNob3d1cHBlcmhhbGY6IHtcbiAgICAgICAgdmFsVHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgIGRmbHQ6IHRydWUsXG4gICAgICAgIGVkaXRUeXBlOiAnY2FsYycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCBzdWJwbG90cyBvbiB0aGUgdXBwZXIgaGFsZicsXG4gICAgICAgICAgICAnZnJvbSB0aGUgZGlhZ29uYWwgYXJlIGRpc3BsYXllZC4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICBzaG93bG93ZXJoYWxmOiB7XG4gICAgICAgIHZhbFR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgcm9sZTogJ2luZm8nLFxuICAgICAgICBkZmx0OiB0cnVlLFxuICAgICAgICBlZGl0VHlwZTogJ2NhbGMnLFxuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ0RldGVybWluZXMgd2hldGhlciBvciBub3Qgc3VicGxvdHMgb24gdGhlIGxvd2VyIGhhbGYnLFxuICAgICAgICAgICAgJ2Zyb20gdGhlIGRpYWdvbmFsIGFyZSBkaXNwbGF5ZWQuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH0sXG5cbiAgICBzZWxlY3RlZDoge1xuICAgICAgICBtYXJrZXI6IHNjYXR0ZXJHbEF0dHJzLnNlbGVjdGVkLm1hcmtlcixcbiAgICAgICAgZWRpdFR5cGU6ICdjYWxjJ1xuICAgIH0sXG4gICAgdW5zZWxlY3RlZDoge1xuICAgICAgICBtYXJrZXI6IHNjYXR0ZXJHbEF0dHJzLnVuc2VsZWN0ZWQubWFya2VyLFxuICAgICAgICBlZGl0VHlwZTogJ2NhbGMnXG4gICAgfSxcblxuICAgIG9wYWNpdHk6IHNjYXR0ZXJHbEF0dHJzLm9wYWNpdHlcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVMaW5lID0gcmVxdWlyZSgncmVnbC1saW5lMmQnKTtcblxudmFyIFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi4vLi4vcmVnaXN0cnknKTtcbnZhciBwcmVwYXJlUmVnbCA9IHJlcXVpcmUoJy4uLy4uL2xpYi9wcmVwYXJlX3JlZ2wnKTtcbnZhciBnZXRNb2R1bGVDYWxjRGF0YSA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2dldF9kYXRhJykuZ2V0TW9kdWxlQ2FsY0RhdGE7XG52YXIgQ2FydGVzaWFuID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuJyk7XG52YXIgZ2V0RnJvbUlkID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuL2F4aXNfaWRzJykuZ2V0RnJvbUlkO1xudmFyIHNob3VsZFNob3daZXJvTGluZSA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2NhcnRlc2lhbi9heGVzJykuc2hvdWxkU2hvd1plcm9MaW5lO1xuXG52YXIgU1BMT00gPSAnc3Bsb20nO1xuXG5mdW5jdGlvbiBwbG90KGdkKSB7XG4gICAgdmFyIGZ1bGxMYXlvdXQgPSBnZC5fZnVsbExheW91dDtcbiAgICB2YXIgX21vZHVsZSA9IFJlZ2lzdHJ5LmdldE1vZHVsZShTUExPTSk7XG4gICAgdmFyIHNwbG9tQ2FsY0RhdGEgPSBnZXRNb2R1bGVDYWxjRGF0YShnZC5jYWxjZGF0YSwgX21vZHVsZSlbMF07XG5cbiAgICB2YXIgc3VjY2VzcyA9IHByZXBhcmVSZWdsKGdkLCBbJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnLCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCddKTtcbiAgICBpZighc3VjY2VzcykgcmV0dXJuO1xuXG4gICAgaWYoZnVsbExheW91dC5faGFzT25seUxhcmdlU3Bsb21zKSB7XG4gICAgICAgIHVwZGF0ZUdyaWQoZ2QpO1xuICAgIH1cblxuICAgIF9tb2R1bGUucGxvdChnZCwge30sIHNwbG9tQ2FsY0RhdGEpO1xufVxuXG5mdW5jdGlvbiBkcmFnKGdkKSB7XG4gICAgdmFyIGNkID0gZ2QuY2FsY2RhdGE7XG4gICAgdmFyIGZ1bGxMYXlvdXQgPSBnZC5fZnVsbExheW91dDtcblxuICAgIGlmKGZ1bGxMYXlvdXQuX2hhc09ubHlMYXJnZVNwbG9tcykge1xuICAgICAgICB1cGRhdGVHcmlkKGdkKTtcbiAgICB9XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNkMCA9IGNkW2ldWzBdO1xuICAgICAgICB2YXIgdHJhY2UgPSBjZDAudHJhY2U7XG4gICAgICAgIHZhciBzY2VuZSA9IGZ1bGxMYXlvdXQuX3NwbG9tU2NlbmVzW3RyYWNlLnVpZF07XG5cbiAgICAgICAgaWYodHJhY2UudHlwZSA9PT0gJ3NwbG9tJyAmJiBzY2VuZSAmJiBzY2VuZS5tYXRyaXgpIHtcbiAgICAgICAgICAgIGRyYWdPbmUoZ2QsIHRyYWNlLCBzY2VuZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWdPbmUoZ2QsIHRyYWNlLCBzY2VuZSkge1xuICAgIHZhciB2aXNpYmxlTGVuZ3RoID0gc2NlbmUubWF0cml4T3B0aW9ucy5kYXRhLmxlbmd0aDtcbiAgICB2YXIgdmlzaWJsZURpbXMgPSB0cmFjZS5fdmlzaWJsZURpbXM7XG4gICAgdmFyIHJhbmdlcyA9IHNjZW5lLnZpZXdPcHRzLnJhbmdlcyA9IG5ldyBBcnJheSh2aXNpYmxlTGVuZ3RoKTtcblxuICAgIGZvcih2YXIgayA9IDA7IGsgPCB2aXNpYmxlRGltcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaSA9IHZpc2libGVEaW1zW2tdO1xuICAgICAgICB2YXIgcm5nID0gcmFuZ2VzW2tdID0gbmV3IEFycmF5KDQpO1xuXG4gICAgICAgIHZhciB4YSA9IGdldEZyb21JZChnZCwgdHJhY2UuX2RpYWdbaV1bMF0pO1xuICAgICAgICBpZih4YSkge1xuICAgICAgICAgICAgcm5nWzBdID0geGEucjJsKHhhLnJhbmdlWzBdKTtcbiAgICAgICAgICAgIHJuZ1syXSA9IHhhLnIybCh4YS5yYW5nZVsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeWEgPSBnZXRGcm9tSWQoZ2QsIHRyYWNlLl9kaWFnW2ldWzFdKTtcbiAgICAgICAgaWYoeWEpIHtcbiAgICAgICAgICAgIHJuZ1sxXSA9IHlhLnIybCh5YS5yYW5nZVswXSk7XG4gICAgICAgICAgICBybmdbM10gPSB5YS5yMmwoeWEucmFuZ2VbMV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoc2NlbmUuc2VsZWN0QmF0Y2gubGVuZ3RoIHx8IHNjZW5lLnVuc2VsZWN0QmF0Y2gubGVuZ3RoKSB7XG4gICAgICAgIHNjZW5lLm1hdHJpeC51cGRhdGUoe3JhbmdlczogcmFuZ2VzfSwge3JhbmdlczogcmFuZ2VzfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2NlbmUubWF0cml4LnVwZGF0ZSh7cmFuZ2VzOiByYW5nZXN9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUdyaWQoZ2QpIHtcbiAgICB2YXIgZnVsbExheW91dCA9IGdkLl9mdWxsTGF5b3V0O1xuICAgIHZhciByZWdsID0gZnVsbExheW91dC5fZ2xjYW52YXMuZGF0YSgpWzBdLnJlZ2w7XG4gICAgdmFyIHNwbG9tR3JpZCA9IGZ1bGxMYXlvdXQuX3NwbG9tR3JpZDtcblxuICAgIGlmKCFzcGxvbUdyaWQpIHtcbiAgICAgICAgc3Bsb21HcmlkID0gZnVsbExheW91dC5fc3Bsb21HcmlkID0gY3JlYXRlTGluZShyZWdsKTtcbiAgICB9XG4gICAgc3Bsb21HcmlkLnVwZGF0ZShtYWtlR3JpZERhdGEoZ2QpKTtcbn1cblxuZnVuY3Rpb24gbWFrZUdyaWREYXRhKGdkKSB7XG4gICAgdmFyIGZ1bGxMYXlvdXQgPSBnZC5fZnVsbExheW91dDtcbiAgICB2YXIgZ3MgPSBmdWxsTGF5b3V0Ll9zaXplO1xuICAgIHZhciBmdWxsVmlldyA9IFswLCAwLCBmdWxsTGF5b3V0LndpZHRoLCBmdWxsTGF5b3V0LmhlaWdodF07XG4gICAgdmFyIGxvb2t1cCA9IHt9O1xuICAgIHZhciBrO1xuXG4gICAgZnVuY3Rpb24gcHVzaChwcmVmaXgsIGF4LCB4MCwgeDEsIHkwLCB5MSkge1xuICAgICAgICB2YXIgbGNvbG9yID0gYXhbcHJlZml4ICsgJ2NvbG9yJ107XG4gICAgICAgIHZhciBsd2lkdGggPSBheFtwcmVmaXggKyAnd2lkdGgnXTtcbiAgICAgICAgdmFyIGtleSA9IFN0cmluZyhsY29sb3IgKyBsd2lkdGgpO1xuXG4gICAgICAgIGlmKGtleSBpbiBsb29rdXApIHtcbiAgICAgICAgICAgIGxvb2t1cFtrZXldLmRhdGEucHVzaChOYU4sIE5hTiwgeDAsIHgxLCB5MCwgeTEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9va3VwW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogW3gwLCB4MSwgeTAsIHkxXSxcbiAgICAgICAgICAgICAgICBqb2luOiAncmVjdCcsXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBsd2lkdGgsXG4gICAgICAgICAgICAgICAgY29sb3I6IGxjb2xvcixcbiAgICAgICAgICAgICAgICB2aWV3cG9ydDogZnVsbFZpZXcsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGZ1bGxWaWV3LFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yKGsgaW4gZnVsbExheW91dC5fc3Bsb21TdWJwbG90cykge1xuICAgICAgICB2YXIgc3AgPSBmdWxsTGF5b3V0Ll9wbG90c1trXTtcbiAgICAgICAgdmFyIHhhID0gc3AueGF4aXM7XG4gICAgICAgIHZhciB5YSA9IHNwLnlheGlzO1xuICAgICAgICB2YXIgeFZhbHMgPSB4YS5fZ3JpZFZhbHM7XG4gICAgICAgIHZhciB5VmFscyA9IHlhLl9ncmlkVmFscztcbiAgICAgICAgLy8geWEubDJwIGFzc3VtZXMgdG9wLXRvLWJvdHRvbSBjb29yZGluYXRlIHN5c3RlbSAoYSBsYSBTVkcpLFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGNvbXB1dGUgYm90dG9tLXRvLXRvcCBvZmZzZXRzIGFuZCBzbG9wZXM6XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gZ3MuYiArIHlhLmRvbWFpblswXSAqIGdzLmg7XG4gICAgICAgIHZhciB5bSA9IC15YS5fbTtcbiAgICAgICAgdmFyIHliID0gLXltICogeWEucjJsKHlhLnJhbmdlWzBdLCB5YS5jYWxlbmRhcik7XG4gICAgICAgIHZhciB4LCB5O1xuXG4gICAgICAgIGlmKHhhLnNob3dncmlkKSB7XG4gICAgICAgICAgICBmb3IoayA9IDA7IGsgPCB4VmFscy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHggPSB4YS5fb2Zmc2V0ICsgeGEubDJwKHhWYWxzW2tdLngpO1xuICAgICAgICAgICAgICAgIHB1c2goJ2dyaWQnLCB4YSwgeCwgeU9mZnNldCwgeCwgeU9mZnNldCArIHlhLl9sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKHlhLnNob3dncmlkKSB7XG4gICAgICAgICAgICBmb3IoayA9IDA7IGsgPCB5VmFscy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHkgPSB5T2Zmc2V0ICsgeWIgKyB5bSAqIHlWYWxzW2tdLng7XG4gICAgICAgICAgICAgICAgcHVzaCgnZ3JpZCcsIHlhLCB4YS5fb2Zmc2V0LCB5LCB4YS5fb2Zmc2V0ICsgeGEuX2xlbmd0aCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoc2hvdWxkU2hvd1plcm9MaW5lKGdkLCB4YSwgeWEpKSB7XG4gICAgICAgICAgICB4ID0geGEuX29mZnNldCArIHhhLmwycCgwKTtcbiAgICAgICAgICAgIHB1c2goJ3plcm9saW5lJywgeGEsIHgsIHlPZmZzZXQsIHgsIHlPZmZzZXQgKyB5YS5fbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZihzaG91bGRTaG93WmVyb0xpbmUoZ2QsIHlhLCB4YSkpIHtcbiAgICAgICAgICAgIHkgPSB5T2Zmc2V0ICsgeWIgKyAwO1xuICAgICAgICAgICAgcHVzaCgnemVyb2xpbmUnLCB5YSwgeGEuX29mZnNldCwgeSwgeGEuX29mZnNldCArIHhhLl9sZW5ndGgsIHkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGdyaWRCYXRjaGVzID0gW107XG4gICAgZm9yKGsgaW4gbG9va3VwKSB7XG4gICAgICAgIGdyaWRCYXRjaGVzLnB1c2gobG9va3VwW2tdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JpZEJhdGNoZXM7XG59XG5cbmZ1bmN0aW9uIGNsZWFuKG5ld0Z1bGxEYXRhLCBuZXdGdWxsTGF5b3V0LCBvbGRGdWxsRGF0YSwgb2xkRnVsbExheW91dCkge1xuICAgIHZhciBsb29rdXAgPSB7fTtcbiAgICB2YXIgaTtcblxuICAgIGlmKG9sZEZ1bGxMYXlvdXQuX3NwbG9tU2NlbmVzKSB7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IG5ld0Z1bGxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmV3VHJhY2UgPSBuZXdGdWxsRGF0YVtpXTtcbiAgICAgICAgICAgIGlmKG5ld1RyYWNlLnR5cGUgPT09ICdzcGxvbScpIHtcbiAgICAgICAgICAgICAgICBsb29rdXBbbmV3VHJhY2UudWlkXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgb2xkRnVsbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvbGRUcmFjZSA9IG9sZEZ1bGxEYXRhW2ldO1xuICAgICAgICAgICAgaWYoIWxvb2t1cFtvbGRUcmFjZS51aWRdKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjZW5lID0gb2xkRnVsbExheW91dC5fc3Bsb21TY2VuZXNbb2xkVHJhY2UudWlkXTtcbiAgICAgICAgICAgICAgICBpZihzY2VuZSAmJiBzY2VuZS5kZXN0cm95KSBzY2VuZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgLy8gbXVzdCBmaXJzdCBzZXQgc2NlbmUgdG8gbnVsbCBpbiBvcmRlciB0byBnZXQgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICAgICAgICAgICAgICBvbGRGdWxsTGF5b3V0Ll9zcGxvbVNjZW5lc1tvbGRUcmFjZS51aWRdID0gbnVsbDtcbiAgICAgICAgICAgICAgICBkZWxldGUgb2xkRnVsbExheW91dC5fc3Bsb21TY2VuZXNbb2xkVHJhY2UudWlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKE9iamVjdC5rZXlzKG9sZEZ1bGxMYXlvdXQuX3NwbG9tU2NlbmVzIHx8IHt9KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIG9sZEZ1bGxMYXlvdXQuX3NwbG9tU2NlbmVzO1xuICAgIH1cblxuICAgIGlmKG9sZEZ1bGxMYXlvdXQuX3NwbG9tR3JpZCAmJlxuICAgICAgICAoIW5ld0Z1bGxMYXlvdXQuX2hhc09ubHlMYXJnZVNwbG9tcyAmJiBvbGRGdWxsTGF5b3V0Ll9oYXNPbmx5TGFyZ2VTcGxvbXMpKSB7XG4gICAgICAgIC8vIG11c3QgZmlyc3Qgc2V0IHNjZW5lIHRvIG51bGwgaW4gb3JkZXIgdG8gZ2V0IGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgIG9sZEZ1bGxMYXlvdXQuX3NwbG9tR3JpZC5kZXN0cm95KCk7XG4gICAgICAgIG9sZEZ1bGxMYXlvdXQuX3NwbG9tR3JpZCA9IG51bGw7XG4gICAgICAgIGRlbGV0ZSBvbGRGdWxsTGF5b3V0Ll9zcGxvbUdyaWQ7XG4gICAgfVxuXG4gICAgQ2FydGVzaWFuLmNsZWFuKG5ld0Z1bGxEYXRhLCBuZXdGdWxsTGF5b3V0LCBvbGRGdWxsRGF0YSwgb2xkRnVsbExheW91dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG5hbWU6IFNQTE9NLFxuICAgIGF0dHI6IENhcnRlc2lhbi5hdHRyLFxuICAgIGF0dHJSZWdleDogQ2FydGVzaWFuLmF0dHJSZWdleCxcbiAgICBsYXlvdXRBdHRyaWJ1dGVzOiBDYXJ0ZXNpYW4ubGF5b3V0QXR0cmlidXRlcyxcbiAgICBzdXBwbHlMYXlvdXREZWZhdWx0czogQ2FydGVzaWFuLnN1cHBseUxheW91dERlZmF1bHRzLFxuICAgIGRyYXdGcmFtZXdvcms6IENhcnRlc2lhbi5kcmF3RnJhbWV3b3JrLFxuICAgIHBsb3Q6IHBsb3QsXG4gICAgZHJhZzogZHJhZyxcbiAgICB1cGRhdGVHcmlkOiB1cGRhdGVHcmlkLFxuICAgIGNsZWFuOiBjbGVhbixcbiAgICB1cGRhdGVGeDogQ2FydGVzaWFuLnVwZGF0ZUZ4LFxuICAgIHRvU1ZHOiBDYXJ0ZXNpYW4udG9TVkdcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaWIgPSByZXF1aXJlKCcuLi8uLi9saWInKTtcbnZhciBBeGlzSURzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuL2F4aXNfaWRzJyk7XG5cbnZhciBjYWxjTWFya2VyU2l6ZSA9IHJlcXVpcmUoJy4uL3NjYXR0ZXIvY2FsYycpLmNhbGNNYXJrZXJTaXplO1xudmFyIGNhbGNBeGlzRXhwYW5zaW9uID0gcmVxdWlyZSgnLi4vc2NhdHRlci9jYWxjJykuY2FsY0F4aXNFeHBhbnNpb247XG52YXIgY2FsY0NvbG9yc2NhbGUgPSByZXF1aXJlKCcuLi9zY2F0dGVyL2NvbG9yc2NhbGVfY2FsYycpO1xudmFyIGNvbnZlcnRNYXJrZXJTZWxlY3Rpb24gPSByZXF1aXJlKCcuLi9zY2F0dGVyZ2wvY29udmVydCcpLm1hcmtlclNlbGVjdGlvbjtcbnZhciBjb252ZXJ0TWFya2VyU3R5bGUgPSByZXF1aXJlKCcuLi9zY2F0dGVyZ2wvY29udmVydCcpLm1hcmtlclN0eWxlO1xudmFyIHNjZW5lVXBkYXRlID0gcmVxdWlyZSgnLi9zY2VuZV91cGRhdGUnKTtcblxudmFyIEJBRE5VTSA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0YW50cy9udW1lcmljYWwnKS5CQUROVU07XG52YXIgVE9PX01BTllfUE9JTlRTID0gcmVxdWlyZSgnLi4vc2NhdHRlcmdsL2NvbnN0YW50cycpLlRPT19NQU5ZX1BPSU5UUztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxjKGdkLCB0cmFjZSkge1xuICAgIHZhciBkaW1lbnNpb25zID0gdHJhY2UuZGltZW5zaW9ucztcbiAgICB2YXIgY29tbW9uTGVuZ3RoID0gdHJhY2UuX2xlbmd0aDtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIC8vICdjJyBmb3IgY2FsY3VsYXRlZCwgJ2wnIGZvciBsaW5lYXIsXG4gICAgLy8gb25seSBkaWZmZXIgaGVyZSBmb3IgbG9nIGF4ZXMsIHBhc3MgbGRhdGEgdG8gY3JlYXRlTWF0cml4IGFzICdkYXRhJ1xuICAgIHZhciBjZGF0YSA9IG9wdHMuY2RhdGEgPSBbXTtcbiAgICB2YXIgbGRhdGEgPSBvcHRzLmRhdGEgPSBbXTtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHZpc2libGUgZGltZW5zaW9uc1xuICAgIHZhciB2aXNpYmxlRGltcyA9IHRyYWNlLl92aXNpYmxlRGltcyA9IFtdO1xuICAgIHZhciBpLCBrLCBkaW0sIHhhLCB5YTtcblxuICAgIGZ1bmN0aW9uIG1ha2VDYWxjZGF0YShheCwgZGltKSB7XG4gICAgICAgIC8vIGNhbGwgbWFrZUNhbGNkYXRhIHdpdGggZmFrZSBpbnB1dFxuICAgICAgICB2YXIgY2NvbCA9IGF4Lm1ha2VDYWxjZGF0YSh7XG4gICAgICAgICAgICB2OiBkaW0udmFsdWVzLFxuICAgICAgICAgICAgdmNhbGVuZGFyOiB0cmFjZS5jYWxlbmRhclxuICAgICAgICB9LCAndicpO1xuXG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBjY29sLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjY29sW2pdID0gY2NvbFtqXSA9PT0gQkFETlVNID8gTmFOIDogY2NvbFtqXTtcbiAgICAgICAgfVxuICAgICAgICBjZGF0YS5wdXNoKGNjb2wpO1xuICAgICAgICBsZGF0YS5wdXNoKGF4LnR5cGUgPT09ICdsb2cnID8gTGliLnNpbXBsZU1hcChjY29sLCBheC5jMmwpIDogY2NvbCk7XG4gICAgfVxuXG4gICAgZm9yKGkgPSAwOyBpIDwgZGltZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkaW0gPSBkaW1lbnNpb25zW2ldO1xuXG4gICAgICAgIGlmKGRpbS52aXNpYmxlKSB7XG4gICAgICAgICAgICB4YSA9IEF4aXNJRHMuZ2V0RnJvbUlkKGdkLCB0cmFjZS5fZGlhZ1tpXVswXSk7XG4gICAgICAgICAgICB5YSA9IEF4aXNJRHMuZ2V0RnJvbUlkKGdkLCB0cmFjZS5fZGlhZ1tpXVsxXSk7XG5cbiAgICAgICAgICAgIC8vIGlmIGNvcnJlc3BvbmRpbmcgeCAmIHkgYXhlcyBkb24ndCBoYXZlIG1hdGNoaW5nIHR5cGVzLCBza2lwIGRpbVxuICAgICAgICAgICAgaWYoeGEgJiYgeWEgJiYgeGEudHlwZSAhPT0geWEudHlwZSkge1xuICAgICAgICAgICAgICAgIExpYi5sb2coJ1NraXBwaW5nIHNwbG9tIGRpbWVuc2lvbiAnICsgaSArICcgd2l0aCBjb25mbGljdGluZyBheGlzIHR5cGVzJyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHhhKSB7XG4gICAgICAgICAgICAgICAgbWFrZUNhbGNkYXRhKHhhLCBkaW0pO1xuICAgICAgICAgICAgICAgIGlmKHlhICYmIHlhLnR5cGUgPT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgICAgICAgICAgICAgeWEuX2NhdGVnb3JpZXMgPSB4YS5fY2F0ZWdvcmllcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIG5vdCBtYWtlIGl0IGhlcmUsIGlmIGJvdGggeGEgYW5kIHlhIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIG1ha2VDYWxjZGF0YSh5YSwgZGltKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlzaWJsZURpbXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGNDb2xvcnNjYWxlKGdkLCB0cmFjZSk7XG4gICAgTGliLmV4dGVuZEZsYXQob3B0cywgY29udmVydE1hcmtlclN0eWxlKHRyYWNlKSk7XG5cbiAgICB2YXIgdmlzaWJsZUxlbmd0aCA9IGNkYXRhLmxlbmd0aDtcbiAgICB2YXIgaGFzVG9vTWFueVBvaW50cyA9ICh2aXNpYmxlTGVuZ3RoICogY29tbW9uTGVuZ3RoKSA+IFRPT19NQU5ZX1BPSU5UUztcblxuICAgIC8vIFJldXNlIFNWRyBzY2F0dGVyIGF4aXMgZXhwYW5zaW9uIHJvdXRpbmUuXG4gICAgLy8gRm9yIGdyYXBocyB3aXRoIHZlcnkgbGFyZ2UgbnVtYmVyIG9mIHBvaW50cyBhbmQgYXJyYXkgbWFya2VyLnNpemUsXG4gICAgLy8gdXNlIGF2ZXJhZ2UgbWFya2VyIHNpemUgaW5zdGVhZCB0byBzcGVlZCB0aGluZ3MgdXAuXG4gICAgdmFyIHBwYWQ7XG4gICAgaWYoaGFzVG9vTWFueVBvaW50cykge1xuICAgICAgICBwcGFkID0gMiAqIChvcHRzLnNpemVBdmcgfHwgTWF0aC5tYXgob3B0cy5zaXplLCAzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHBhZCA9IGNhbGNNYXJrZXJTaXplKHRyYWNlLCBjb21tb25MZW5ndGgpO1xuICAgIH1cblxuICAgIGZvcihrID0gMDsgayA8IHZpc2libGVEaW1zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGkgPSB2aXNpYmxlRGltc1trXTtcbiAgICAgICAgZGltID0gZGltZW5zaW9uc1tpXTtcbiAgICAgICAgeGEgPSBBeGlzSURzLmdldEZyb21JZChnZCwgdHJhY2UuX2RpYWdbaV1bMF0pIHx8IHt9O1xuICAgICAgICB5YSA9IEF4aXNJRHMuZ2V0RnJvbUlkKGdkLCB0cmFjZS5fZGlhZ1tpXVsxXSkgfHwge307XG4gICAgICAgIGNhbGNBeGlzRXhwYW5zaW9uKGdkLCB0cmFjZSwgeGEsIHlhLCBjZGF0YVtrXSwgY2RhdGFba10sIHBwYWQpO1xuICAgIH1cblxuICAgIHZhciBzY2VuZSA9IHNjZW5lVXBkYXRlKGdkLCB0cmFjZSk7XG4gICAgaWYoIXNjZW5lLm1hdHJpeCkgc2NlbmUubWF0cml4ID0gdHJ1ZTtcbiAgICBzY2VuZS5tYXRyaXhPcHRpb25zID0gb3B0cztcblxuICAgIHNjZW5lLnNlbGVjdGVkT3B0aW9ucyA9IGNvbnZlcnRNYXJrZXJTZWxlY3Rpb24odHJhY2UsIHRyYWNlLnNlbGVjdGVkKTtcbiAgICBzY2VuZS51bnNlbGVjdGVkT3B0aW9ucyA9IGNvbnZlcnRNYXJrZXJTZWxlY3Rpb24odHJhY2UsIHRyYWNlLnVuc2VsZWN0ZWQpO1xuXG4gICAgcmV0dXJuIFt7eDogZmFsc2UsIHk6IGZhbHNlLCB0OiB7fSwgdHJhY2U6IHRyYWNlfV07XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGliID0gcmVxdWlyZSgnLi4vLi4vbGliJyk7XG52YXIgaGFuZGxlQXJyYXlDb250YWluZXJEZWZhdWx0cyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2FycmF5X2NvbnRhaW5lcl9kZWZhdWx0cycpO1xuXG52YXIgYXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpO1xudmFyIHN1YlR5cGVzID0gcmVxdWlyZSgnLi4vc2NhdHRlci9zdWJ0eXBlcycpO1xudmFyIGhhbmRsZU1hcmtlckRlZmF1bHRzID0gcmVxdWlyZSgnLi4vc2NhdHRlci9tYXJrZXJfZGVmYXVsdHMnKTtcbnZhciBtZXJnZUxlbmd0aCA9IHJlcXVpcmUoJy4uL3BhcmNvb3Jkcy9tZXJnZV9sZW5ndGgnKTtcbnZhciBpc09wZW5TeW1ib2wgPSByZXF1aXJlKCcuLi9zY2F0dGVyZ2wvaGVscGVycycpLmlzT3BlblN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdXBwbHlEZWZhdWx0cyh0cmFjZUluLCB0cmFjZU91dCwgZGVmYXVsdENvbG9yLCBsYXlvdXQpIHtcbiAgICBmdW5jdGlvbiBjb2VyY2UoYXR0ciwgZGZsdCkge1xuICAgICAgICByZXR1cm4gTGliLmNvZXJjZSh0cmFjZUluLCB0cmFjZU91dCwgYXR0cmlidXRlcywgYXR0ciwgZGZsdCk7XG4gICAgfVxuXG4gICAgdmFyIGRpbWVuc2lvbnMgPSBoYW5kbGVBcnJheUNvbnRhaW5lckRlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCB7XG4gICAgICAgIG5hbWU6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgaGFuZGxlSXRlbURlZmF1bHRzOiBkaW1lbnNpb25EZWZhdWx0c1xuICAgIH0pO1xuXG4gICAgdmFyIHNob3dEaWFnID0gY29lcmNlKCdkaWFnb25hbC52aXNpYmxlJyk7XG4gICAgdmFyIHNob3dVcHBlciA9IGNvZXJjZSgnc2hvd3VwcGVyaGFsZicpO1xuICAgIHZhciBzaG93TG93ZXIgPSBjb2VyY2UoJ3Nob3dsb3dlcmhhbGYnKTtcblxuICAgIHZhciBkaW1MZW5ndGggPSBtZXJnZUxlbmd0aCh0cmFjZU91dCwgZGltZW5zaW9ucywgJ3ZhbHVlcycpO1xuXG4gICAgaWYoIWRpbUxlbmd0aCB8fCAoIXNob3dEaWFnICYmICFzaG93VXBwZXIgJiYgIXNob3dMb3dlcikpIHtcbiAgICAgICAgdHJhY2VPdXQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29lcmNlKCd0ZXh0Jyk7XG4gICAgY29lcmNlKCdob3ZlcnRleHQnKTtcbiAgICBjb2VyY2UoJ2hvdmVydGVtcGxhdGUnKTtcblxuICAgIGhhbmRsZU1hcmtlckRlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCBkZWZhdWx0Q29sb3IsIGxheW91dCwgY29lcmNlKTtcblxuICAgIHZhciBpc09wZW4gPSBpc09wZW5TeW1ib2wodHJhY2VPdXQubWFya2VyLnN5bWJvbCk7XG4gICAgdmFyIGlzQnViYmxlID0gc3ViVHlwZXMuaXNCdWJibGUodHJhY2VPdXQpO1xuICAgIGNvZXJjZSgnbWFya2VyLmxpbmUud2lkdGgnLCBpc09wZW4gfHwgaXNCdWJibGUgPyAxIDogMCk7XG5cbiAgICBoYW5kbGVBeGlzRGVmYXVsdHModHJhY2VJbiwgdHJhY2VPdXQsIGxheW91dCwgY29lcmNlKTtcblxuICAgIExpYi5jb2VyY2VTZWxlY3Rpb25NYXJrZXJPcGFjaXR5KHRyYWNlT3V0LCBjb2VyY2UpO1xufTtcblxuZnVuY3Rpb24gZGltZW5zaW9uRGVmYXVsdHMoZGltSW4sIGRpbU91dCkge1xuICAgIGZ1bmN0aW9uIGNvZXJjZShhdHRyLCBkZmx0KSB7XG4gICAgICAgIHJldHVybiBMaWIuY29lcmNlKGRpbUluLCBkaW1PdXQsIGF0dHJpYnV0ZXMuZGltZW5zaW9ucywgYXR0ciwgZGZsdCk7XG4gICAgfVxuXG4gICAgY29lcmNlKCdsYWJlbCcpO1xuICAgIHZhciB2YWx1ZXMgPSBjb2VyY2UoJ3ZhbHVlcycpO1xuXG4gICAgaWYoISh2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCkpIGRpbU91dC52aXNpYmxlID0gZmFsc2U7XG4gICAgZWxzZSBjb2VyY2UoJ3Zpc2libGUnKTtcblxuICAgIGNvZXJjZSgnYXhpcy50eXBlJyk7XG4gICAgY29lcmNlKCdheGlzLm1hdGNoZXMnKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQXhpc0RlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCBsYXlvdXQsIGNvZXJjZSkge1xuICAgIHZhciBkaW1lbnNpb25zID0gdHJhY2VPdXQuZGltZW5zaW9ucztcbiAgICB2YXIgZGltTGVuZ3RoID0gZGltZW5zaW9ucy5sZW5ndGg7XG4gICAgdmFyIHNob3dVcHBlciA9IHRyYWNlT3V0LnNob3d1cHBlcmhhbGY7XG4gICAgdmFyIHNob3dMb3dlciA9IHRyYWNlT3V0LnNob3dsb3dlcmhhbGY7XG4gICAgdmFyIHNob3dEaWFnID0gdHJhY2VPdXQuZGlhZ29uYWwudmlzaWJsZTtcbiAgICB2YXIgaSwgajtcblxuICAgIHZhciB4QXhlc0RmbHQgPSBuZXcgQXJyYXkoZGltTGVuZ3RoKTtcbiAgICB2YXIgeUF4ZXNEZmx0ID0gbmV3IEFycmF5KGRpbUxlbmd0aCk7XG5cbiAgICBmb3IoaSA9IDA7IGkgPCBkaW1MZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VmZml4ID0gaSA/IGkgKyAxIDogJyc7XG4gICAgICAgIHhBeGVzRGZsdFtpXSA9ICd4JyArIHN1ZmZpeDtcbiAgICAgICAgeUF4ZXNEZmx0W2ldID0gJ3knICsgc3VmZml4O1xuICAgIH1cblxuICAgIHZhciB4YXhlcyA9IGNvZXJjZSgneGF4ZXMnLCB4QXhlc0RmbHQpO1xuICAgIHZhciB5YXhlcyA9IGNvZXJjZSgneWF4ZXMnLCB5QXhlc0RmbHQpO1xuXG4gICAgLy8gYnVpbGQgbGlzdCBvZiBbeCx5XSBheGlzIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBkaW1lbnNpb25zW2ldLFxuICAgIC8vIHZlcnkgdXNlZnVsIGZvciBwYXNzaW5nIG9wdGlvbnMgdG8gcmVnbC1zcGxvbVxuICAgIHZhciBkaWFnID0gdHJhY2VPdXQuX2RpYWcgPSBuZXcgQXJyYXkoZGltTGVuZ3RoKTtcblxuICAgIC8vIGxvb2t1cCBmb3IgJ2RyYXduJyB4fHkgYXhlcywgdG8gYXZvaWQgY29zdGx5IGluZGV4T2YgZG93bnN0cmVhbVxuICAgIHRyYWNlT3V0Ll94YXhlcyA9IHt9O1xuICAgIHRyYWNlT3V0Ll95YXhlcyA9IHt9O1xuXG4gICAgLy8gbGlzdCBvZiAnZHJhd24nIHh8eSBheGVzLCB1c2UgdG8gZ2VuZXJhdGUgbGlzdCBvZiBzdWJwbG90c1xuICAgIHZhciB4TGlzdCA9IFtdO1xuICAgIHZhciB5TGlzdCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gZmlsbEF4aXNTdGFzaGVzKGF4SWQsIGNvdW50ZXJBeElkLCBkaW0sIGxpc3QpIHtcbiAgICAgICAgaWYoIWF4SWQpIHJldHVybjtcblxuICAgICAgICB2YXIgYXhMZXR0ZXIgPSBheElkLmNoYXJBdCgwKTtcbiAgICAgICAgdmFyIHN0YXNoID0gbGF5b3V0Ll9zcGxvbUF4ZXNbYXhMZXR0ZXJdO1xuXG4gICAgICAgIHRyYWNlT3V0WydfJyArIGF4TGV0dGVyICsgJ2F4ZXMnXVtheElkXSA9IDE7XG4gICAgICAgIGxpc3QucHVzaChheElkKTtcblxuICAgICAgICBpZighKGF4SWQgaW4gc3Rhc2gpKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHN0YXNoW2F4SWRdID0ge307XG4gICAgICAgICAgICBpZihkaW0pIHtcbiAgICAgICAgICAgICAgICBzLmxhYmVsID0gZGltLmxhYmVsIHx8ICcnO1xuICAgICAgICAgICAgICAgIGlmKGRpbS52aXNpYmxlICYmIGRpbS5heGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGRpbS5heGlzLnR5cGUpIHMudHlwZSA9IGRpbS5heGlzLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmKGRpbS5heGlzLm1hdGNoZXMpIHMubWF0Y2hlcyA9IGNvdW50ZXJBeElkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhc2VzIHdoZXJlIHNob3dEaWFnIGFuZCBzaG93TG93ZXIgb3Igc2hvd1VwcGVyIGFyZSBmYWxzZVxuICAgIC8vIG5vIHNwZWNpYWwgdHJlYXRtZW50IGFzIHRoZSAnZHJhd24nIHgtYXhlcyBhbmQgeS1heGVzIG5vIGxvbmdlciBtYXRjaFxuICAgIC8vIHRoZSBkaW1lbnNpb25zIGl0ZW1zIGFuZCB4YXhlc3x5YXhlcyAxLXRvLTFcbiAgICB2YXIgbXVzdFNoaWZ0WCA9ICFzaG93RGlhZyAmJiAhc2hvd0xvd2VyO1xuICAgIHZhciBtdXN0U2hpZnRZID0gIXNob3dEaWFnICYmICFzaG93VXBwZXI7XG5cbiAgICB0cmFjZU91dC5fYXhlc0RpbSA9IHt9O1xuICAgIGZvcihpID0gMDsgaSA8IGRpbUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkaW0gPSBkaW1lbnNpb25zW2ldO1xuICAgICAgICB2YXIgaTAgPSBpID09PSAwO1xuICAgICAgICB2YXIgaU4gPSBpID09PSBkaW1MZW5ndGggLSAxO1xuXG4gICAgICAgIHZhciB4YUlkID0gKGkwICYmIG11c3RTaGlmdFgpIHx8IChpTiAmJiBtdXN0U2hpZnRZKSA/XG4gICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgeGF4ZXNbaV07XG5cbiAgICAgICAgdmFyIHlhSWQgPSAoaTAgJiYgbXVzdFNoaWZ0WSkgfHwgKGlOICYmIG11c3RTaGlmdFgpID9cbiAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICB5YXhlc1tpXTtcblxuICAgICAgICBmaWxsQXhpc1N0YXNoZXMoeGFJZCwgeWFJZCwgZGltLCB4TGlzdCk7XG4gICAgICAgIGZpbGxBeGlzU3Rhc2hlcyh5YUlkLCB4YUlkLCBkaW0sIHlMaXN0KTtcbiAgICAgICAgZGlhZ1tpXSA9IFt4YUlkLCB5YUlkXTtcbiAgICAgICAgdHJhY2VPdXQuX2F4ZXNEaW1beGFJZF0gPSBpO1xuICAgICAgICB0cmFjZU91dC5fYXhlc0RpbVt5YUlkXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gZmlsbCBpbiBzcGxvbSBzdWJwbG90IGtleXNcbiAgICBmb3IoaSA9IDA7IGkgPCB4TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IoaiA9IDA7IGogPCB5TGlzdC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGlkID0geExpc3RbaV0gKyB5TGlzdFtqXTtcblxuICAgICAgICAgICAgaWYoaSA+IGogJiYgc2hvd1VwcGVyKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0Ll9zcGxvbVN1YnBsb3RzW2lkXSA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYoaSA8IGogJiYgc2hvd0xvd2VyKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0Ll9zcGxvbVN1YnBsb3RzW2lkXSA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYoaSA9PT0gaiAmJiAoc2hvd0RpYWcgfHwgIXNob3dMb3dlciB8fCAhc2hvd1VwcGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gaW5jbHVkZSBkaWFnb25hbCBzdWJwbG90cyB3aGVuXG4gICAgICAgICAgICAgICAgLy8gaGlkaW5nIG9uZSBoYWxmIGFuZCB0aGUgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICBsYXlvdXQuX3NwbG9tU3VicGxvdHNbaWRdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdoZW4gbG93ZXIgaGFsZiBpcyBvbWl0dGVkLCBvciB3aGVuIGp1c3QgdGhlIGRpYWdvbmFsIGlzIGdvbmUsXG4gICAgLy8gb3ZlcnJpZGUgZ3JpZCBkZWZhdWx0IHRvIG1ha2Ugc3VyZSBheGVzIHJlbWFpbiBvblxuICAgIC8vIHRoZSBsZWZ0L2JvdHRvbSBvZiB0aGUgcGxvdCBhcmVhXG4gICAgaWYoIXNob3dMb3dlciB8fCAoIXNob3dEaWFnICYmIHNob3dVcHBlciAmJiBzaG93TG93ZXIpKSB7XG4gICAgICAgIGxheW91dC5fc3Bsb21HcmlkRGZsdC54c2lkZSA9ICdib3R0b20nO1xuICAgICAgICBsYXlvdXQuX3NwbG9tR3JpZERmbHQueXNpZGUgPSAnbGVmdCc7XG4gICAgfVxufVxuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGliID0gcmVxdWlyZSgnLi4vLi4vbGliJyk7XG52YXIgY2FsY0NvbG9yc2NhbGUgPSByZXF1aXJlKCcuLi9zY2F0dGVyL2NvbG9yc2NhbGVfY2FsYycpO1xudmFyIGNvbnZlcnRNYXJrZXJTdHlsZSA9IHJlcXVpcmUoJy4uL3NjYXR0ZXJnbC9jb252ZXJ0JykubWFya2VyU3R5bGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZWRpdFN0eWxlKGdkLCBjZDApIHtcbiAgICB2YXIgdHJhY2UgPSBjZDAudHJhY2U7XG4gICAgdmFyIHNjZW5lID0gZ2QuX2Z1bGxMYXlvdXQuX3NwbG9tU2NlbmVzW3RyYWNlLnVpZF07XG5cbiAgICBpZihzY2VuZSkge1xuICAgICAgICBjYWxjQ29sb3JzY2FsZShnZCwgdHJhY2UpO1xuXG4gICAgICAgIExpYi5leHRlbmRGbGF0KHNjZW5lLm1hdHJpeE9wdGlvbnMsIGNvbnZlcnRNYXJrZXJTdHlsZSh0cmFjZSkpO1xuICAgICAgICAvLyBUT0RPIFt1bl1zZWxlY3RlZCBzdHlsZXM/XG5cbiAgICAgICAgdmFyIG9wdHMgPSBMaWIuZXh0ZW5kRmxhdCh7fSwgc2NlbmUubWF0cml4T3B0aW9ucywgc2NlbmUudmlld09wdHMpO1xuXG4gICAgICAgIC8vIFRPRE8gdGhpcyBpcyB0b28gbG9uZyBmb3IgYXJyYXlPayBhdHRyaWJ1dGVzIVxuICAgICAgICBzY2VuZS5tYXRyaXgudXBkYXRlKG9wdHMsIG51bGwpO1xuICAgIH1cbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZ2V0RGltSW5kZXggPSBmdW5jdGlvbiBnZXREaW1JbmRleCh0cmFjZSwgYXgpIHtcbiAgICB2YXIgYXhJZCA9IGF4Ll9pZDtcbiAgICB2YXIgYXhMZXR0ZXIgPSBheElkLmNoYXJBdCgwKTtcbiAgICB2YXIgaW5kID0ge3g6IDAsIHk6IDF9W2F4TGV0dGVyXTtcbiAgICB2YXIgdmlzaWJsZURpbXMgPSB0cmFjZS5fdmlzaWJsZURpbXM7XG5cbiAgICBmb3IodmFyIGsgPSAwOyBrIDwgdmlzaWJsZURpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGkgPSB2aXNpYmxlRGltc1trXTtcbiAgICAgICAgaWYodHJhY2UuX2RpYWdbaV1baW5kXSA9PT0gYXhJZCkgcmV0dXJuIGs7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG52YXIgY2FsY0hvdmVyID0gcmVxdWlyZSgnLi4vc2NhdHRlcmdsL2hvdmVyJykuY2FsY0hvdmVyO1xuXG5mdW5jdGlvbiBob3ZlclBvaW50cyhwb2ludERhdGEsIHh2YWwsIHl2YWwpIHtcbiAgICB2YXIgY2QgPSBwb2ludERhdGEuY2Q7XG4gICAgdmFyIHRyYWNlID0gY2RbMF0udHJhY2U7XG4gICAgdmFyIHNjZW5lID0gcG9pbnREYXRhLnNjZW5lO1xuICAgIHZhciBjZGF0YSA9IHNjZW5lLm1hdHJpeE9wdGlvbnMuY2RhdGE7XG4gICAgdmFyIHhhID0gcG9pbnREYXRhLnhhO1xuICAgIHZhciB5YSA9IHBvaW50RGF0YS55YTtcbiAgICB2YXIgeHB4ID0geGEuYzJwKHh2YWwpO1xuICAgIHZhciB5cHggPSB5YS5jMnAoeXZhbCk7XG4gICAgdmFyIG1heERpc3RhbmNlID0gcG9pbnREYXRhLmRpc3RhbmNlO1xuXG4gICAgdmFyIHhpID0gaGVscGVycy5nZXREaW1JbmRleCh0cmFjZSwgeGEpO1xuICAgIHZhciB5aSA9IGhlbHBlcnMuZ2V0RGltSW5kZXgodHJhY2UsIHlhKTtcbiAgICBpZih4aSA9PT0gZmFsc2UgfHwgeWkgPT09IGZhbHNlKSByZXR1cm4gW3BvaW50RGF0YV07XG5cbiAgICB2YXIgeCA9IGNkYXRhW3hpXTtcbiAgICB2YXIgeSA9IGNkYXRhW3lpXTtcblxuICAgIHZhciBpZCwgZHh5O1xuICAgIHZhciBtaW5EaXN0ID0gbWF4RGlzdGFuY2U7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHR4ID0geFtpXTtcbiAgICAgICAgdmFyIHB0eSA9IHlbaV07XG4gICAgICAgIHZhciBkeCA9IHhhLmMycChwdHgpIC0geHB4O1xuICAgICAgICB2YXIgZHkgPSB5YS5jMnAocHR5KSAtIHlweDtcbiAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICBtaW5EaXN0ID0gZHh5ID0gZGlzdDtcbiAgICAgICAgICAgIGlkID0gaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBvaW50RGF0YS5pbmRleCA9IGlkO1xuICAgIHBvaW50RGF0YS5kaXN0YW5jZSA9IG1pbkRpc3Q7XG4gICAgcG9pbnREYXRhLmR4eSA9IGR4eTtcblxuICAgIGlmKGlkID09PSB1bmRlZmluZWQpIHJldHVybiBbcG9pbnREYXRhXTtcblxuICAgIHJldHVybiBbY2FsY0hvdmVyKHBvaW50RGF0YSwgeCwgeSwgdHJhY2UpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaG92ZXJQb2ludHM6IGhvdmVyUG9pbnRzXG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVnaXN0cnkgPSByZXF1aXJlKCcuLi8uLi9yZWdpc3RyeScpO1xudmFyIEdyaWQgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzL2dyaWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbW9kdWxlVHlwZTogJ3RyYWNlJyxcbiAgICBuYW1lOiAnc3Bsb20nLFxuXG4gICAgYmFzZVBsb3RNb2R1bGU6IHJlcXVpcmUoJy4vYmFzZV9wbG90JyksXG4gICAgY2F0ZWdvcmllczogWydnbCcsICdyZWdsJywgJ2NhcnRlc2lhbicsICdzeW1ib2xzJywgJ3Nob3dMZWdlbmQnLCAnc2NhdHRlci1saWtlJ10sXG5cbiAgICBhdHRyaWJ1dGVzOiByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKSxcbiAgICBzdXBwbHlEZWZhdWx0czogcmVxdWlyZSgnLi9kZWZhdWx0cycpLFxuICAgIGNvbG9yYmFyOiByZXF1aXJlKCcuLi9zY2F0dGVyL21hcmtlcl9jb2xvcmJhcicpLFxuXG4gICAgY2FsYzogcmVxdWlyZSgnLi9jYWxjJyksXG4gICAgcGxvdDogcmVxdWlyZSgnLi9wbG90JyksXG4gICAgaG92ZXJQb2ludHM6IHJlcXVpcmUoJy4vaG92ZXInKS5ob3ZlclBvaW50cyxcbiAgICBzZWxlY3RQb2ludHM6IHJlcXVpcmUoJy4vc2VsZWN0JyksXG4gICAgZWRpdFN0eWxlOiByZXF1aXJlKCcuL2VkaXRfc3R5bGUnKSxcblxuICAgIG1ldGE6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTcGxvbSB0cmFjZXMgZ2VuZXJhdGUgc2NhdHRlciBwbG90IG1hdHJpeCB2aXN1YWxpemF0aW9ucy4nLFxuICAgICAgICAgICAgJ0VhY2ggc3Bsb20gYGRpbWVuc2lvbnNgIGl0ZW1zIGNvcnJlc3BvbmQgdG8gYSBnZW5lcmF0ZWQgYXhpcy4nLFxuICAgICAgICAgICAgJ1ZhbHVlcyBmb3IgZWFjaCBvZiB0aG9zZSBkaW1lbnNpb25zIGFyZSBzZXQgaW4gYGRpbWVuc2lvbnNbaV0udmFsdWVzYC4nLFxuICAgICAgICAgICAgJ1NwbG9tIHRyYWNlcyBzdXBwb3J0IGFsbCBgc2NhdHRlcmdsYCBtYXJrZXIgc3R5bGUgYXR0cmlidXRlcy4nLFxuICAgICAgICAgICAgJ1NwZWNpZnkgYGxheW91dC5ncmlkYCBhdHRyaWJ1dGVzIGFuZC9vciBsYXlvdXQgeC1heGlzIGFuZCB5LWF4aXMgYXR0cmlidXRlcycsXG4gICAgICAgICAgICAnZm9yIG1vcmUgY29udHJvbCBvdmVyIHRoZSBheGlzIHBvc2l0aW9uaW5nIGFuZCBzdHlsZS4gJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH1cbn07XG5cbi8vIHNwbG9tIHRyYWNlcyB1c2UgdGhlICdncmlkJyBjb21wb25lbnQgdG8gZ2VuZXJhdGUgdGhlaXIgYXhlcyxcbi8vIHJlZ2lzdGVyIGl0IGhlcmVcblJlZ2lzdHJ5LnJlZ2lzdGVyKEdyaWQpO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlTWF0cml4ID0gcmVxdWlyZSgncmVnbC1zcGxvbScpO1xuXG52YXIgTGliID0gcmVxdWlyZSgnLi4vLi4vbGliJyk7XG52YXIgQXhpc0lEcyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2NhcnRlc2lhbi9heGlzX2lkcycpO1xudmFyIHNlbGVjdE1vZGUgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzL2RyYWdlbGVtZW50L2hlbHBlcnMnKS5zZWxlY3RNb2RlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBsb3QoZ2QsIF8sIHNwbG9tQ2FsY0RhdGEpIHtcbiAgICBpZighc3Bsb21DYWxjRGF0YS5sZW5ndGgpIHJldHVybjtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzcGxvbUNhbGNEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBsb3RPbmUoZ2QsIHNwbG9tQ2FsY0RhdGFbaV1bMF0pO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHBsb3RPbmUoZ2QsIGNkMCkge1xuICAgIHZhciBmdWxsTGF5b3V0ID0gZ2QuX2Z1bGxMYXlvdXQ7XG4gICAgdmFyIGdzID0gZnVsbExheW91dC5fc2l6ZTtcbiAgICB2YXIgdHJhY2UgPSBjZDAudHJhY2U7XG4gICAgdmFyIHN0YXNoID0gY2QwLnQ7XG4gICAgdmFyIHNjZW5lID0gZnVsbExheW91dC5fc3Bsb21TY2VuZXNbdHJhY2UudWlkXTtcbiAgICB2YXIgbWF0cml4T3B0cyA9IHNjZW5lLm1hdHJpeE9wdGlvbnM7XG4gICAgdmFyIGNkYXRhID0gbWF0cml4T3B0cy5jZGF0YTtcbiAgICB2YXIgcmVnbCA9IGZ1bGxMYXlvdXQuX2dsY2FudmFzLmRhdGEoKVswXS5yZWdsO1xuICAgIHZhciBkcmFnbW9kZSA9IGZ1bGxMYXlvdXQuZHJhZ21vZGU7XG4gICAgdmFyIHhhLCB5YTtcbiAgICB2YXIgaSwgaiwgaztcblxuICAgIGlmKGNkYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgLy8gYXVnbWVudCBvcHRpb25zIHdpdGggcHJvcGVyIHVwcGVyL2xvd2VyIGhhbHZlc1xuICAgIC8vIHJlZ2wtc3Bsb20ncyBkZWZhdWx0IGdyaWQgc3RhcnRzIGZyb20gYm90dG9tLWxlZnRcbiAgICBtYXRyaXhPcHRzLmxvd2VyID0gdHJhY2Uuc2hvd3VwcGVyaGFsZjtcbiAgICBtYXRyaXhPcHRzLnVwcGVyID0gdHJhY2Uuc2hvd2xvd2VyaGFsZjtcbiAgICBtYXRyaXhPcHRzLmRpYWdvbmFsID0gdHJhY2UuZGlhZ29uYWwudmlzaWJsZTtcblxuICAgIHZhciB2aXNpYmxlRGltcyA9IHRyYWNlLl92aXNpYmxlRGltcztcbiAgICB2YXIgdmlzaWJsZUxlbmd0aCA9IGNkYXRhLmxlbmd0aDtcbiAgICB2YXIgdmlld09wdHMgPSBzY2VuZS52aWV3T3B0cyA9IHt9O1xuICAgIHZpZXdPcHRzLnJhbmdlcyA9IG5ldyBBcnJheSh2aXNpYmxlTGVuZ3RoKTtcbiAgICB2aWV3T3B0cy5kb21haW5zID0gbmV3IEFycmF5KHZpc2libGVMZW5ndGgpO1xuXG4gICAgZm9yKGsgPSAwOyBrIDwgdmlzaWJsZURpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgaSA9IHZpc2libGVEaW1zW2tdO1xuXG4gICAgICAgIHZhciBybmcgPSB2aWV3T3B0cy5yYW5nZXNba10gPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgIHZhciBkbW4gPSB2aWV3T3B0cy5kb21haW5zW2tdID0gbmV3IEFycmF5KDQpO1xuXG4gICAgICAgIHhhID0gQXhpc0lEcy5nZXRGcm9tSWQoZ2QsIHRyYWNlLl9kaWFnW2ldWzBdKTtcbiAgICAgICAgaWYoeGEpIHtcbiAgICAgICAgICAgIHJuZ1swXSA9IHhhLl9ybFswXTtcbiAgICAgICAgICAgIHJuZ1syXSA9IHhhLl9ybFsxXTtcbiAgICAgICAgICAgIGRtblswXSA9IHhhLmRvbWFpblswXTtcbiAgICAgICAgICAgIGRtblsyXSA9IHhhLmRvbWFpblsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHlhID0gQXhpc0lEcy5nZXRGcm9tSWQoZ2QsIHRyYWNlLl9kaWFnW2ldWzFdKTtcbiAgICAgICAgaWYoeWEpIHtcbiAgICAgICAgICAgIHJuZ1sxXSA9IHlhLl9ybFswXTtcbiAgICAgICAgICAgIHJuZ1szXSA9IHlhLl9ybFsxXTtcbiAgICAgICAgICAgIGRtblsxXSA9IHlhLmRvbWFpblswXTtcbiAgICAgICAgICAgIGRtblszXSA9IHlhLmRvbWFpblsxXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZpZXdPcHRzLnZpZXdwb3J0ID0gW2dzLmwsIGdzLmIsIGdzLncgKyBncy5sLCBncy5oICsgZ3MuYl07XG5cbiAgICBpZihzY2VuZS5tYXRyaXggPT09IHRydWUpIHtcbiAgICAgICAgc2NlbmUubWF0cml4ID0gY3JlYXRlTWF0cml4KHJlZ2wpO1xuICAgIH1cblxuICAgIHZhciBjbGlja1NlbGVjdEVuYWJsZWQgPSBmdWxsTGF5b3V0LmNsaWNrbW9kZS5pbmRleE9mKCdzZWxlY3QnKSA+IC0xO1xuICAgIHZhciBpc1NlbGVjdE1vZGUgPSBzZWxlY3RNb2RlKGRyYWdtb2RlKSB8fFxuICAgICAgISF0cmFjZS5zZWxlY3RlZHBvaW50cyB8fCBjbGlja1NlbGVjdEVuYWJsZWQ7XG4gICAgdmFyIG5lZWRzQmFzZVVwZGF0ZSA9IHRydWU7XG5cbiAgICBpZihpc1NlbGVjdE1vZGUpIHtcbiAgICAgICAgdmFyIGNvbW1vbkxlbmd0aCA9IHRyYWNlLl9sZW5ndGg7XG5cbiAgICAgICAgLy8gcmVnZW5lcmF0ZSBzY2VuZSBiYXRjaCwgaWYgdHJhY2VzIG51bWJlciBjaGFuZ2VkIGR1cmluZyBzZWxlY3Rpb25cbiAgICAgICAgaWYodHJhY2Uuc2VsZWN0ZWRwb2ludHMpIHtcbiAgICAgICAgICAgIHNjZW5lLnNlbGVjdEJhdGNoID0gdHJhY2Uuc2VsZWN0ZWRwb2ludHM7XG5cbiAgICAgICAgICAgIHZhciBzZWxQdHMgPSB0cmFjZS5zZWxlY3RlZHBvaW50cztcbiAgICAgICAgICAgIHZhciBzZWxEaWN0ID0ge307XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBzZWxQdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzZWxEaWN0W3NlbFB0c1tpXV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVuc2VsUHRzID0gW107XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBjb21tb25MZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmKCFzZWxEaWN0W2ldKSB1bnNlbFB0cy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NlbmUudW5zZWxlY3RCYXRjaCA9IHVuc2VsUHRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJlY2FsY3VsYXRlIHB4IGNvb3JkcyBzaW5jZSB3ZSBhcmUgbm90IGdvaW5nIHRvIHBhbiBkdXJpbmcgc2VsZWN0XG4gICAgICAgIHZhciB4cHggPSBzdGFzaC54cHggPSBuZXcgQXJyYXkodmlzaWJsZUxlbmd0aCk7XG4gICAgICAgIHZhciB5cHggPSBzdGFzaC55cHggPSBuZXcgQXJyYXkodmlzaWJsZUxlbmd0aCk7XG5cbiAgICAgICAgZm9yKGsgPSAwOyBrIDwgdmlzaWJsZURpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGkgPSB2aXNpYmxlRGltc1trXTtcblxuICAgICAgICAgICAgeGEgPSBBeGlzSURzLmdldEZyb21JZChnZCwgdHJhY2UuX2RpYWdbaV1bMF0pO1xuICAgICAgICAgICAgaWYoeGEpIHtcbiAgICAgICAgICAgICAgICB4cHhba10gPSBuZXcgQXJyYXkoY29tbW9uTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IoaiA9IDA7IGogPCBjb21tb25MZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB4cHhba11bal0gPSB4YS5jMnAoY2RhdGFba11bal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeWEgPSBBeGlzSURzLmdldEZyb21JZChnZCwgdHJhY2UuX2RpYWdbaV1bMV0pO1xuICAgICAgICAgICAgaWYoeWEpIHtcbiAgICAgICAgICAgICAgICB5cHhba10gPSBuZXcgQXJyYXkoY29tbW9uTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IoaiA9IDA7IGogPCBjb21tb25MZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB5cHhba11bal0gPSB5YS5jMnAoY2RhdGFba11bal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHNjZW5lLnNlbGVjdEJhdGNoLmxlbmd0aCB8fCBzY2VuZS51bnNlbGVjdEJhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHVuc2VsT3B0cyA9IExpYi5leHRlbmRGbGF0KHt9LCBtYXRyaXhPcHRzLCBzY2VuZS51bnNlbGVjdGVkT3B0aW9ucywgdmlld09wdHMpO1xuICAgICAgICAgICAgdmFyIHNlbE9wdHMgPSBMaWIuZXh0ZW5kRmxhdCh7fSwgbWF0cml4T3B0cywgc2NlbmUuc2VsZWN0ZWRPcHRpb25zLCB2aWV3T3B0cyk7XG4gICAgICAgICAgICBzY2VuZS5tYXRyaXgudXBkYXRlKHVuc2VsT3B0cywgc2VsT3B0cyk7XG4gICAgICAgICAgICBuZWVkc0Jhc2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXNoLnhweCA9IHN0YXNoLnlweCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYobmVlZHNCYXNlVXBkYXRlKSB7XG4gICAgICAgIHZhciBvcHRzID0gTGliLmV4dGVuZEZsYXQoe30sIG1hdHJpeE9wdHMsIHZpZXdPcHRzKTtcbiAgICAgICAgc2NlbmUubWF0cml4LnVwZGF0ZShvcHRzLCBudWxsKTtcbiAgICB9XG59XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaWIgPSByZXF1aXJlKCcuLi8uLi9saWInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzY2VuZVVwZGF0ZShnZCwgdHJhY2UpIHtcbiAgICB2YXIgZnVsbExheW91dCA9IGdkLl9mdWxsTGF5b3V0O1xuICAgIHZhciB1aWQgPSB0cmFjZS51aWQ7XG5cbiAgICAvLyBtdXN0IHBsYWNlIHJlZiB0byAnc2NlbmUnIGluIGZ1bGxMYXlvdXQsIHNvIHRoYXQ6XG4gICAgLy8gLSBpdCBjYW4gYmUgcmVsaW5rZWQgcHJvcGVybHkgb24gdXBkYXRlc1xuICAgIC8vIC0gaXQgY2FuIGJlIGRlc3Ryb3llZCBwcm9wZXJseSB3aGVuIG5lZWRlZFxuICAgIHZhciBzcGxvbVNjZW5lcyA9IGZ1bGxMYXlvdXQuX3NwbG9tU2NlbmVzO1xuICAgIGlmKCFzcGxvbVNjZW5lcykgc3Bsb21TY2VuZXMgPSBmdWxsTGF5b3V0Ll9zcGxvbVNjZW5lcyA9IHt9O1xuXG4gICAgdmFyIHJlc2V0ID0ge1xuICAgICAgICBkaXJ0eTogdHJ1ZSxcbiAgICAgICAgc2VsZWN0QmF0Y2g6IFtdLFxuICAgICAgICB1bnNlbGVjdEJhdGNoOiBbXVxuICAgIH07XG5cbiAgICB2YXIgZmlyc3QgPSB7XG4gICAgICAgIG1hdHJpeDogZmFsc2UsXG4gICAgICAgIHNlbGVjdEJhdGNoOiBbXSxcbiAgICAgICAgdW5zZWxlY3RCYXRjaDogW11cbiAgICB9O1xuXG4gICAgdmFyIHNjZW5lID0gc3Bsb21TY2VuZXNbdHJhY2UudWlkXTtcblxuICAgIGlmKCFzY2VuZSkge1xuICAgICAgICBzY2VuZSA9IHNwbG9tU2NlbmVzW3VpZF0gPSBMaWIuZXh0ZW5kRmxhdCh7fSwgcmVzZXQsIGZpcnN0KTtcblxuICAgICAgICBzY2VuZS5kcmF3ID0gZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgICAgICAgIGlmKHNjZW5lLm1hdHJpeCAmJiBzY2VuZS5tYXRyaXguZHJhdykge1xuICAgICAgICAgICAgICAgIGlmKHNjZW5lLnNlbGVjdEJhdGNoLmxlbmd0aCB8fCBzY2VuZS51bnNlbGVjdEJhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzY2VuZS5tYXRyaXguZHJhdyhzY2VuZS51bnNlbGVjdEJhdGNoLCBzY2VuZS5zZWxlY3RCYXRjaCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2NlbmUubWF0cml4LmRyYXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjZW5lLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVtb3ZlIHNjZW5lIHJlc291cmNlc1xuICAgICAgICBzY2VuZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGlmKHNjZW5lLm1hdHJpeCAmJiBzY2VuZS5tYXRyaXguZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIHNjZW5lLm1hdHJpeC5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY2VuZS5tYXRyaXhPcHRpb25zID0gbnVsbDtcbiAgICAgICAgICAgIHNjZW5lLnNlbGVjdEJhdGNoID0gbnVsbDtcbiAgICAgICAgICAgIHNjZW5lLnVuc2VsZWN0QmF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgc2NlbmUgPSBudWxsO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEluIGNhc2UgaWYgd2UgaGF2ZSBzY2VuZSBmcm9tIHRoZSBsYXN0IGNhbGMgLSByZXNldCBkYXRhXG4gICAgaWYoIXNjZW5lLmRpcnR5KSB7XG4gICAgICAgIExpYi5leHRlbmRGbGF0KHNjZW5lLCByZXNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjZW5lO1xufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xudmFyIHN1YlR5cGVzID0gcmVxdWlyZSgnLi4vc2NhdHRlci9zdWJ0eXBlcycpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZWxlY3Qoc2VhcmNoSW5mbywgc2VsZWN0aW9uVGVzdGVyKSB7XG4gICAgdmFyIGNkID0gc2VhcmNoSW5mby5jZDtcbiAgICB2YXIgdHJhY2UgPSBjZFswXS50cmFjZTtcbiAgICB2YXIgc3Rhc2ggPSBjZFswXS50O1xuICAgIHZhciBzY2VuZSA9IHNlYXJjaEluZm8uc2NlbmU7XG4gICAgdmFyIGNkYXRhID0gc2NlbmUubWF0cml4T3B0aW9ucy5jZGF0YTtcbiAgICB2YXIgeGEgPSBzZWFyY2hJbmZvLnhheGlzO1xuICAgIHZhciB5YSA9IHNlYXJjaEluZm8ueWF4aXM7XG4gICAgdmFyIHNlbGVjdGlvbiA9IFtdO1xuXG4gICAgaWYoIXNjZW5lKSByZXR1cm4gc2VsZWN0aW9uO1xuXG4gICAgdmFyIGhhc09ubHlMaW5lcyA9ICghc3ViVHlwZXMuaGFzTWFya2Vycyh0cmFjZSkgJiYgIXN1YlR5cGVzLmhhc1RleHQodHJhY2UpKTtcbiAgICBpZih0cmFjZS52aXNpYmxlICE9PSB0cnVlIHx8IGhhc09ubHlMaW5lcykgcmV0dXJuIHNlbGVjdGlvbjtcblxuICAgIHZhciB4aSA9IGhlbHBlcnMuZ2V0RGltSW5kZXgodHJhY2UsIHhhKTtcbiAgICB2YXIgeWkgPSBoZWxwZXJzLmdldERpbUluZGV4KHRyYWNlLCB5YSk7XG4gICAgaWYoeGkgPT09IGZhbHNlIHx8IHlpID09PSBmYWxzZSkgcmV0dXJuIHNlbGVjdGlvbjtcblxuICAgIHZhciB4cHggPSBzdGFzaC54cHhbeGldO1xuICAgIHZhciB5cHggPSBzdGFzaC55cHhbeWldO1xuICAgIHZhciB4ID0gY2RhdGFbeGldO1xuICAgIHZhciB5ID0gY2RhdGFbeWldO1xuICAgIHZhciBlbHMgPSBbXTtcbiAgICB2YXIgdW5lbHMgPSBbXTtcblxuICAgIC8vIGRlZ2VuZXJhdGUgcG9seWdvbiBkb2VzIG5vdCBlbmFibGUgc2VsZWN0aW9uXG4gICAgLy8gZmlsdGVyIG91dCBwb2ludHMgYnkgdmlzaWJsZSBzY2F0dGVyIG9uZXNcbiAgICBpZihzZWxlY3Rpb25UZXN0ZXIgIT09IGZhbHNlICYmICFzZWxlY3Rpb25UZXN0ZXIuZGVnZW5lcmF0ZSkge1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYoc2VsZWN0aW9uVGVzdGVyLmNvbnRhaW5zKFt4cHhbaV0sIHlweFtpXV0sIG51bGwsIGksIHNlYXJjaEluZm8pKSB7XG4gICAgICAgICAgICAgICAgZWxzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwb2ludE51bWJlcjogaSxcbiAgICAgICAgICAgICAgICAgICAgeDogeFtpXSxcbiAgICAgICAgICAgICAgICAgICAgeTogeVtpXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bmVscy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1hdHJpeE9wdHMgPSBzY2VuZS5tYXRyaXhPcHRpb25zO1xuXG4gICAgaWYoIWVscy5sZW5ndGggJiYgIXVuZWxzLmxlbmd0aCkge1xuICAgICAgICBzY2VuZS5tYXRyaXgudXBkYXRlKG1hdHJpeE9wdHMsIG51bGwpO1xuICAgIH0gZWxzZSBpZighc2NlbmUuc2VsZWN0QmF0Y2gubGVuZ3RoICYmICFzY2VuZS51bnNlbGVjdEJhdGNoLmxlbmd0aCkge1xuICAgICAgICBzY2VuZS5tYXRyaXgudXBkYXRlKFxuICAgICAgICAgICAgc2NlbmUudW5zZWxlY3RlZE9wdGlvbnMsXG4gICAgICAgICAgICBMaWIuZXh0ZW5kRmxhdCh7fSwgbWF0cml4T3B0cywgc2NlbmUuc2VsZWN0ZWRPcHRpb25zLCBzY2VuZS52aWV3T3B0cylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzY2VuZS5zZWxlY3RCYXRjaCA9IGVscztcbiAgICBzY2VuZS51bnNlbGVjdEJhdGNoID0gdW5lbHM7XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uO1xufTtcbiIsInZhciBub3cgPSByZXF1aXJlKCdwZXJmb3JtYW5jZS1ub3cnKVxuICAsIHJvb3QgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvd1xuICAsIHZlbmRvcnMgPSBbJ21veicsICd3ZWJraXQnXVxuICAsIHN1ZmZpeCA9ICdBbmltYXRpb25GcmFtZSdcbiAgLCByYWYgPSByb290WydyZXF1ZXN0JyArIHN1ZmZpeF1cbiAgLCBjYWYgPSByb290WydjYW5jZWwnICsgc3VmZml4XSB8fCByb290WydjYW5jZWxSZXF1ZXN0JyArIHN1ZmZpeF1cblxuZm9yKHZhciBpID0gMDsgIXJhZiAmJiBpIDwgdmVuZG9ycy5sZW5ndGg7IGkrKykge1xuICByYWYgPSByb290W3ZlbmRvcnNbaV0gKyAnUmVxdWVzdCcgKyBzdWZmaXhdXG4gIGNhZiA9IHJvb3RbdmVuZG9yc1tpXSArICdDYW5jZWwnICsgc3VmZml4XVxuICAgICAgfHwgcm9vdFt2ZW5kb3JzW2ldICsgJ0NhbmNlbFJlcXVlc3QnICsgc3VmZml4XVxufVxuXG4vLyBTb21lIHZlcnNpb25zIG9mIEZGIGhhdmUgckFGIGJ1dCBub3QgY0FGXG5pZighcmFmIHx8ICFjYWYpIHtcbiAgdmFyIGxhc3QgPSAwXG4gICAgLCBpZCA9IDBcbiAgICAsIHF1ZXVlID0gW11cbiAgICAsIGZyYW1lRHVyYXRpb24gPSAxMDAwIC8gNjBcblxuICByYWYgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIF9ub3cgPSBub3coKVxuICAgICAgICAsIG5leHQgPSBNYXRoLm1heCgwLCBmcmFtZUR1cmF0aW9uIC0gKF9ub3cgLSBsYXN0KSlcbiAgICAgIGxhc3QgPSBuZXh0ICsgX25vd1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNwID0gcXVldWUuc2xpY2UoMClcbiAgICAgICAgLy8gQ2xlYXIgcXVldWUgaGVyZSB0byBwcmV2ZW50XG4gICAgICAgIC8vIGNhbGxiYWNrcyBmcm9tIGFwcGVuZGluZyBsaXN0ZW5lcnNcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgZnJhbWUncyBxdWV1ZVxuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKCFjcFtpXS5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgY3BbaV0uY2FsbGJhY2sobGFzdClcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0aHJvdyBlIH0sIDApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBNYXRoLnJvdW5kKG5leHQpKVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKHtcbiAgICAgIGhhbmRsZTogKytpZCxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIGNhbmNlbGxlZDogZmFsc2VcbiAgICB9KVxuICAgIHJldHVybiBpZFxuICB9XG5cbiAgY2FmID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihxdWV1ZVtpXS5oYW5kbGUgPT09IGhhbmRsZSkge1xuICAgICAgICBxdWV1ZVtpXS5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4pIHtcbiAgLy8gV3JhcCBpbiBhIG5ldyBmdW5jdGlvbiB0byBwcmV2ZW50XG4gIC8vIGBjYW5jZWxgIHBvdGVudGlhbGx5IGJlaW5nIGFzc2lnbmVkXG4gIC8vIHRvIHRoZSBuYXRpdmUgckFGIGZ1bmN0aW9uXG4gIHJldHVybiByYWYuY2FsbChyb290LCBmbilcbn1cbm1vZHVsZS5leHBvcnRzLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICBjYWYuYXBwbHkocm9vdCwgYXJndW1lbnRzKVxufVxubW9kdWxlLmV4cG9ydHMucG9seWZpbGwgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICBvYmplY3QgPSByb290O1xuICB9XG4gIG9iamVjdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByYWZcbiAgb2JqZWN0LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2FmXG59XG4iLCIndXNlIHN0cmljdCdcclxuXHJcblxyXG5jb25zdCBjcmVhdGVTY2F0dGVyID0gcmVxdWlyZSgncmVnbC1zY2F0dGVyMmQnKVxyXG5jb25zdCBwaWNrID0gcmVxdWlyZSgncGljay1ieS1hbGlhcycpXHJcbmNvbnN0IGdldEJvdW5kcyA9IHJlcXVpcmUoJ2FycmF5LWJvdW5kcycpXHJcbmNvbnN0IHJhZiA9IHJlcXVpcmUoJ3JhZicpXHJcbmNvbnN0IGFyclJhbmdlID0gcmVxdWlyZSgnYXJyYXktcmFuZ2UnKVxyXG5jb25zdCByZWN0ID0gcmVxdWlyZSgncGFyc2UtcmVjdCcpXHJcbmNvbnN0IGZsYXR0ZW4gPSByZXF1aXJlKCdmbGF0dGVuLXZlcnRleC1kYXRhJylcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNQTE9NXHJcblxyXG5cclxuLy8gQGNvbnN0cnVjdG9yXHJcbmZ1bmN0aW9uIFNQTE9NIChyZWdsLCBvcHRpb25zKSB7XHJcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFNQTE9NKSkgcmV0dXJuIG5ldyBTUExPTShyZWdsLCBvcHRpb25zKVxyXG5cclxuXHQvLyByZW5kZXIgcGFzc2VzXHJcblx0dGhpcy50cmFjZXMgPSBbXVxyXG5cclxuXHQvLyBwYXNzZXMgZm9yIHNjYXR0ZXIsIGNvbWJpbmVkIGFjcm9zcyB0cmFjZXNcclxuXHR0aGlzLnBhc3NlcyA9IHt9XHJcblxyXG5cdHRoaXMucmVnbCA9IHJlZ2xcclxuXHJcblx0Ly8gbWFpbiBzY2F0dGVyIGRyYXdpbmcgaW5zdGFuY2VcclxuXHR0aGlzLnNjYXR0ZXIgPSBjcmVhdGVTY2F0dGVyKHJlZ2wpXHJcblxyXG5cdHRoaXMuY2FudmFzID0gdGhpcy5zY2F0dGVyLmNhbnZhc1xyXG59XHJcblxyXG5cclxuLy8gdXBkYXRlICYgZHJhdyBwYXNzZXMgb25jZSBwZXIgZnJhbWVcclxuU1BMT00ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcblx0aWYgKGFyZ3MubGVuZ3RoKSB7XHJcblx0XHR0aGlzLnVwZGF0ZSguLi5hcmdzKVxyXG5cdH1cclxuXHJcblx0aWYgKHRoaXMucmVnbC5hdHRyaWJ1dGVzLnByZXNlcnZlRHJhd2luZ0J1ZmZlcikgcmV0dXJuIHRoaXMuZHJhdygpXHJcblxyXG5cdC8vIG1ha2Ugc3VyZSBkcmF3IGlzIG5vdCBjYWxsZWQgbW9yZSBvZnRlbiB0aGFuIG9uY2UgYSBmcmFtZVxyXG5cdGlmICh0aGlzLmRpcnR5KSB7XHJcblx0XHRpZiAodGhpcy5wbGFubmVkID09IG51bGwpIHtcclxuXHRcdFx0dGhpcy5wbGFubmVkID0gcmFmKCgpID0+IHtcclxuXHRcdFx0XHR0aGlzLmRyYXcoKVxyXG5cdFx0XHRcdHRoaXMuZGlydHkgPSB0cnVlXHJcblx0XHRcdFx0dGhpcy5wbGFubmVkID0gbnVsbFxyXG5cdFx0XHR9KVxyXG5cdFx0fVxyXG5cdH1cclxuXHRlbHNlIHtcclxuXHRcdHRoaXMuZHJhdygpXHJcblx0XHR0aGlzLmRpcnR5ID0gdHJ1ZVxyXG5cdFx0cmFmKCgpID0+IHtcclxuXHRcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlXHJcblx0XHR9KVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXNcclxufVxyXG5cclxuXHJcbi8vIHVwZGF0ZSBwYXNzZXNcclxuU1BMT00ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcblx0aWYgKCFhcmdzLmxlbmd0aCkgcmV0dXJuXHJcblxyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dGhpcy51cGRhdGVJdGVtKGksIGFyZ3NbaV0pXHJcblx0fVxyXG5cclxuXHQvLyByZW1vdmUgbnVsbGVkIHBhc3Nlc1xyXG5cdHRoaXMudHJhY2VzID0gdGhpcy50cmFjZXMuZmlsdGVyKEJvb2xlYW4pXHJcblxyXG5cdC8vIEZJWE1FOiB1cGRhdGUgcGFzc2VzIGluZGVwZW5kZW50bHlcclxuXHRsZXQgcGFzc2VzID0gW11cclxuXHRsZXQgb2Zmc2V0ID0gMFxyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50cmFjZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGxldCB0cmFjZSA9IHRoaXMudHJhY2VzW2ldXHJcblx0XHRsZXQgdHJhY2VQYXNzZXMgPSB0aGlzLnRyYWNlc1tpXS5wYXNzZXNcclxuXHRcdGZvciAobGV0IGogPSAwOyBqIDwgdHJhY2VQYXNzZXMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0cGFzc2VzLnB1c2godGhpcy5wYXNzZXNbdHJhY2VQYXNzZXNbal1dKVxyXG5cdFx0fVxyXG5cdFx0Ly8gc2F2ZSBvZmZzZXQgb2YgcGFzc2VzXHJcblx0XHR0cmFjZS5wYXNzT2Zmc2V0ID0gb2Zmc2V0XHJcblx0XHRvZmZzZXQgKz0gdHJhY2UucGFzc2VzLmxlbmd0aFxyXG5cdH1cclxuXHJcblx0dGhpcy5zY2F0dGVyLnVwZGF0ZSguLi5wYXNzZXMpXHJcblxyXG5cdHJldHVybiB0aGlzXHJcbn1cclxuXHJcblxyXG4vLyB1cGRhdGUgdHJhY2UgYnkgaW5kZXgsIG5vdCBzdXBwb3NlZCB0byBiZSBjYWxsZWQgZGlyZWN0bHlcclxuU1BMT00ucHJvdG90eXBlLnVwZGF0ZUl0ZW0gPSBmdW5jdGlvbiAoaSwgb3B0aW9ucykge1xyXG5cdGxldCB7IHJlZ2wgfSA9IHRoaXNcclxuXHJcblx0Ly8gcmVtb3ZlIHBhc3MgaWYgbnVsbFxyXG5cdGlmIChvcHRpb25zID09PSBudWxsKSB7XHJcblx0XHR0aGlzLnRyYWNlc1tpXSA9IG51bGxcclxuXHRcdHJldHVybiB0aGlzXHJcblx0fVxyXG5cclxuXHRpZiAoIW9wdGlvbnMpIHJldHVybiB0aGlzXHJcblxyXG5cdGxldCBvID0gcGljayhvcHRpb25zLCB7XHJcblx0XHRkYXRhOiAnZGF0YSBpdGVtcyBjb2x1bW5zIHJvd3MgdmFsdWVzIGRpbWVuc2lvbnMgc2FtcGxlcyB4JyxcclxuXHRcdHNuYXA6ICdzbmFwIGNsdXN0ZXInLFxyXG5cdFx0c2l6ZTogJ3NpemVzIHNpemUgcmFkaXVzJyxcclxuXHRcdGNvbG9yOiAnY29sb3JzIGNvbG9yIGZpbGwgZmlsbC1jb2xvciBmaWxsQ29sb3InLFxyXG5cdFx0b3BhY2l0eTogJ29wYWNpdHkgYWxwaGEgdHJhbnNwYXJlbmN5IG9wYXF1ZScsXHJcblx0XHRib3JkZXJTaXplOiAnYm9yZGVyU2l6ZXMgYm9yZGVyU2l6ZSBib3JkZXItc2l6ZSBib3JkZXJzaXplIGJvcmRlcldpZHRoIGJvcmRlcldpZHRocyBib3JkZXItd2lkdGggYm9yZGVyd2lkdGggc3Ryb2tlLXdpZHRoIHN0cm9rZVdpZHRoIHN0cm9rZXdpZHRoIG91dGxpbmUnLFxyXG5cdFx0Ym9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcnMgYm9yZGVyQ29sb3IgYm9yZGVyY29sb3Igc3Ryb2tlIHN0cm9rZS1jb2xvciBzdHJva2VDb2xvcicsXHJcblx0XHRtYXJrZXI6ICdtYXJrZXJzIG1hcmtlciBzaGFwZScsXHJcblx0XHRyYW5nZTogJ3JhbmdlIHJhbmdlcyBkYXRhYm94IGRhdGFCb3gnLFxyXG5cdFx0dmlld3BvcnQ6ICd2aWV3cG9ydCB2aWV3Qm94IHZpZXdib3gnLFxyXG5cdFx0ZG9tYWluOiAnZG9tYWluIGRvbWFpbnMgYXJlYSBhcmVhcycsXHJcblx0XHRwYWRkaW5nOiAncGFkIHBhZGRpbmcgcGFkZGluZ3MgcGFkcyBtYXJnaW4gbWFyZ2lucycsXHJcblx0XHR0cmFuc3Bvc2U6ICd0cmFuc3Bvc2UgdHJhbnNwb3NlZCcsXHJcblx0XHRkaWFnb25hbDogJ2RpYWdvbmFsIGRpYWcgc2hvd0RpYWdvbmFsJyxcclxuXHRcdHVwcGVyOiAndXBwZXIgdXAgdG9wIHVwcGVyaGFsZiB1cHBlckhhbGYgc2hvd3VwcGVyaGFsZiBzaG93VXBwZXIgc2hvd1VwcGVySGFsZicsXHJcblx0XHRsb3dlcjogJ2xvd2VyIGxvdyBib3R0b20gbG93ZXJoYWxmIGxvd2VySGFsZiBzaG93bG93ZXJoYWxmIHNob3dMb3dlckhhbGYgc2hvd0xvd2VyJ1xyXG5cdH0pXHJcblxyXG5cdC8vIHdlIHByb3ZpZGUgcmVnbCBidWZmZXIgcGVyLXRyYWNlLCBzaW5jZSB0cmFjZSBkYXRhIGNhbiBiZSBjaGFuZ2VkXHJcblx0bGV0IHRyYWNlID0gKHRoaXMudHJhY2VzW2ldIHx8ICh0aGlzLnRyYWNlc1tpXSA9IHtcclxuXHRcdGlkOiBpLFxyXG5cdFx0YnVmZmVyOiByZWdsLmJ1ZmZlcih7XHJcblx0XHRcdHVzYWdlOiAnZHluYW1pYycsXHJcblx0XHRcdHR5cGU6ICdmbG9hdCcsXHJcblx0XHRcdGRhdGE6IG5ldyBVaW50OEFycmF5KClcclxuXHRcdH0pLFxyXG5cdFx0Y29sb3I6ICdibGFjaycsXHJcblx0XHRtYXJrZXI6IG51bGwsXHJcblx0XHRzaXplOiAxMixcclxuXHRcdGJvcmRlckNvbG9yOiAndHJhbnNwYXJlbnQnLFxyXG5cdFx0Ym9yZGVyU2l6ZTogMSxcclxuXHRcdHZpZXdwb3J0OiAgcmVjdChbcmVnbC5fZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCByZWdsLl9nbC5kcmF3aW5nQnVmZmVySGVpZ2h0XSksXHJcblx0XHRwYWRkaW5nOiBbMCwgMCwgMCwgMF0sXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cdFx0ZGlhZ29uYWw6IHRydWUsXHJcblx0XHR1cHBlcjogdHJ1ZSxcclxuXHRcdGxvd2VyOiB0cnVlXHJcblx0fSkpXHJcblxyXG5cclxuXHQvLyBzYXZlIHN0eWxlc1xyXG5cdGlmIChvLmNvbG9yICE9IG51bGwpIHtcclxuXHRcdHRyYWNlLmNvbG9yID0gby5jb2xvclxyXG5cdH1cclxuXHRpZiAoby5zaXplICE9IG51bGwpIHtcclxuXHRcdHRyYWNlLnNpemUgPSBvLnNpemVcclxuXHR9XHJcblx0aWYgKG8ubWFya2VyICE9IG51bGwpIHtcclxuXHRcdHRyYWNlLm1hcmtlciA9IG8ubWFya2VyXHJcblx0fVxyXG5cdGlmIChvLmJvcmRlckNvbG9yICE9IG51bGwpIHtcclxuXHRcdHRyYWNlLmJvcmRlckNvbG9yID0gby5ib3JkZXJDb2xvclxyXG5cdH1cclxuXHRpZiAoby5ib3JkZXJTaXplICE9IG51bGwpIHtcclxuXHRcdHRyYWNlLmJvcmRlclNpemUgPSBvLmJvcmRlclNpemVcclxuXHR9XHJcblx0aWYgKG8ub3BhY2l0eSAhPSBudWxsKSB7XHJcblx0XHR0cmFjZS5vcGFjaXR5ID0gby5vcGFjaXR5XHJcblx0fVxyXG5cdGlmIChvLnZpZXdwb3J0KSB7XHJcblx0XHR0cmFjZS52aWV3cG9ydCA9IHJlY3Qoby52aWV3cG9ydClcclxuXHR9XHJcblx0aWYgKG8uZGlhZ29uYWwgIT0gbnVsbCkgdHJhY2UuZGlhZ29uYWwgPSBvLmRpYWdvbmFsXHJcblx0aWYgKG8udXBwZXIgIT0gbnVsbCkgdHJhY2UudXBwZXIgPSBvLnVwcGVyXHJcblx0aWYgKG8ubG93ZXIgIT0gbnVsbCkgdHJhY2UubG93ZXIgPSBvLmxvd2VyXHJcblxyXG5cdC8vIHB1dCBmbGF0dGVuZWQgZGF0YSBpbnRvIGJ1ZmZlclxyXG5cdGlmIChvLmRhdGEpIHtcclxuXHRcdHRyYWNlLmJ1ZmZlcihmbGF0dGVuKG8uZGF0YSkpXHJcblx0XHR0cmFjZS5jb2x1bW5zID0gby5kYXRhLmxlbmd0aFxyXG5cdFx0dHJhY2UuY291bnQgPSBvLmRhdGFbMF0ubGVuZ3RoXHJcblxyXG5cdFx0Ly8gZGV0ZWN0IGJvdW5kcyBwZXItY29sdW1uXHJcblx0XHR0cmFjZS5ib3VuZHMgPSBbXVxyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2UuY29sdW1uczsgaSsrKSB7XHJcblx0XHRcdHRyYWNlLmJvdW5kc1tpXSA9IGdldEJvdW5kcyhvLmRhdGFbaV0sIDEpXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBhZGQgcHJvcGVyIHJhbmdlIHVwZGF0aW5nIG1hcmtlcnNcclxuXHRsZXQgbXVsdGlyYW5nZVxyXG5cdGlmIChvLnJhbmdlKSB7XHJcblx0XHR0cmFjZS5yYW5nZSA9IG8ucmFuZ2VcclxuXHRcdG11bHRpcmFuZ2UgPSB0cmFjZS5yYW5nZSAmJiB0eXBlb2YgdHJhY2UucmFuZ2VbMF0gIT09ICdudW1iZXInXHJcblx0fVxyXG5cclxuXHRpZiAoby5kb21haW4pIHtcclxuXHRcdHRyYWNlLmRvbWFpbiA9IG8uZG9tYWluXHJcblx0fVxyXG5cdGxldCBtdWx0aXBhZGRpbmcgPSBmYWxzZVxyXG5cdGlmIChvLnBhZGRpbmcgIT0gbnVsbCkge1xyXG5cdFx0Ly8gbXVsdGlwbGUgcGFkZGluZ3NcclxuXHRcdGlmIChBcnJheS5pc0FycmF5KG8ucGFkZGluZykgJiYgby5wYWRkaW5nLmxlbmd0aCA9PT0gdHJhY2UuY29sdW1ucyAmJiB0eXBlb2Ygby5wYWRkaW5nW28ucGFkZGluZy5sZW5ndGggLSAxXSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0dHJhY2UucGFkZGluZyA9IG8ucGFkZGluZy5tYXAoZ2V0UGFkKVxyXG5cdFx0XHRtdWx0aXBhZGRpbmcgPSB0cnVlXHJcblx0XHR9XHJcblx0XHQvLyBzaW5nbGUgcGFkZGluZ1xyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHRyYWNlLnBhZGRpbmcgPSBnZXRQYWQoby5wYWRkaW5nKVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gY3JlYXRlIHBhc3Nlc1xyXG5cdGxldCBtID0gdHJhY2UuY29sdW1uc1xyXG5cdGxldCBuID0gdHJhY2UuY291bnRcclxuXHJcblx0bGV0IHcgPSB0cmFjZS52aWV3cG9ydC53aWR0aFxyXG5cdGxldCBoID0gdHJhY2Uudmlld3BvcnQuaGVpZ2h0XHJcblx0bGV0IGxlZnQgPSB0cmFjZS52aWV3cG9ydC54XHJcblx0bGV0IHRvcCA9IHRyYWNlLnZpZXdwb3J0LnlcclxuXHRsZXQgaXcgPSB3IC8gbVxyXG5cdGxldCBpaCA9IGggLyBtXHJcblxyXG5cdHRyYWNlLnBhc3NlcyA9IFtdXHJcblxyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XHJcblx0XHRmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xyXG5cdFx0XHRpZiAoIXRyYWNlLmRpYWdvbmFsICYmIGogPT09IGkpIGNvbnRpbnVlXHJcblx0XHRcdGlmICghdHJhY2UudXBwZXIgJiYgaSA+IGopIGNvbnRpbnVlXHJcblx0XHRcdGlmICghdHJhY2UubG93ZXIgJiYgaSA8IGopIGNvbnRpbnVlXHJcblxyXG5cdFx0XHRsZXQga2V5ID0gcGFzc0lkKHRyYWNlLmlkLCBpLCBqKVxyXG5cclxuXHRcdFx0bGV0IHBhc3MgPSB0aGlzLnBhc3Nlc1trZXldIHx8ICh0aGlzLnBhc3Nlc1trZXldID0ge30pXHJcblxyXG5cdFx0XHRpZiAoby5kYXRhKSB7XHJcblx0XHRcdFx0aWYgKG8udHJhbnNwb3NlKSB7XHJcblx0XHRcdFx0XHRwYXNzLnBvc2l0aW9ucyA9IHtcclxuXHRcdFx0XHRcdFx0eDoge2J1ZmZlcjogdHJhY2UuYnVmZmVyLCBvZmZzZXQ6IGosIGNvdW50OiBuLCBzdHJpZGU6IG19LFxyXG5cdFx0XHRcdFx0XHR5OiB7YnVmZmVyOiB0cmFjZS5idWZmZXIsIG9mZnNldDogaSwgY291bnQ6IG4sIHN0cmlkZTogbX1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRwYXNzLnBvc2l0aW9ucyA9IHtcclxuXHRcdFx0XHRcdFx0eDoge2J1ZmZlcjogdHJhY2UuYnVmZmVyLCBvZmZzZXQ6IGogKiBuLCBjb3VudDogbn0sXHJcblx0XHRcdFx0XHRcdHk6IHtidWZmZXI6IHRyYWNlLmJ1ZmZlciwgb2Zmc2V0OiBpICogbiwgY291bnQ6IG59XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwYXNzLmJvdW5kcyA9IGdldEJveCh0cmFjZS5ib3VuZHMsIGksIGopXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChvLmRvbWFpbiB8fCBvLnZpZXdwb3J0IHx8IG8uZGF0YSkge1xyXG5cdFx0XHRcdGxldCBwYWQgPSBtdWx0aXBhZGRpbmcgPyBnZXRCb3godHJhY2UucGFkZGluZywgaSwgaikgOiB0cmFjZS5wYWRkaW5nXHJcblx0XHRcdFx0aWYgKHRyYWNlLmRvbWFpbikge1xyXG5cdFx0XHRcdFx0bGV0IFtsb3gsIGxveSwgaGl4LCBoaXldID0gZ2V0Qm94KHRyYWNlLmRvbWFpbiwgaSwgailcclxuXHJcblx0XHRcdFx0XHRwYXNzLnZpZXdwb3J0ID0gW1xyXG5cdFx0XHRcdFx0XHRsZWZ0ICsgbG94ICogdyArIHBhZFswXSxcclxuXHRcdFx0XHRcdFx0dG9wICsgbG95ICogaCArIHBhZFsxXSxcclxuXHRcdFx0XHRcdFx0bGVmdCArIGhpeCAqIHcgLSBwYWRbMl0sXHJcblx0XHRcdFx0XHRcdHRvcCArIGhpeSAqIGggLSBwYWRbM11cclxuXHRcdFx0XHRcdF1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gY29uc2lkZXIgYXV0by1kb21haW4gZXF1aXBhcnRpYWxcclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHBhc3Mudmlld3BvcnQgPSBbXHJcblx0XHRcdFx0XHRcdGxlZnQgKyBqICogaXcgKyBpdyAqIHBhZFswXSxcclxuXHRcdFx0XHRcdFx0dG9wICsgaSAqIGloICsgaWggKiBwYWRbMV0sXHJcblx0XHRcdFx0XHRcdGxlZnQgKyAoaiArIDEpICogaXcgLSBpdyAqIHBhZFsyXSxcclxuXHRcdFx0XHRcdFx0dG9wICsgKGkgKyAxKSAqIGloIC0gaWggKiBwYWRbM11cclxuXHRcdFx0XHRcdF1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChvLmNvbG9yKSBwYXNzLmNvbG9yID0gdHJhY2UuY29sb3JcclxuXHRcdFx0aWYgKG8uc2l6ZSkgcGFzcy5zaXplID0gdHJhY2Uuc2l6ZVxyXG5cdFx0XHRpZiAoby5tYXJrZXIpIHBhc3MubWFya2VyID0gdHJhY2UubWFya2VyXHJcblx0XHRcdGlmIChvLmJvcmRlclNpemUpIHBhc3MuYm9yZGVyU2l6ZSA9IHRyYWNlLmJvcmRlclNpemVcclxuXHRcdFx0aWYgKG8uYm9yZGVyQ29sb3IpIHBhc3MuYm9yZGVyQ29sb3IgPSB0cmFjZS5ib3JkZXJDb2xvclxyXG5cdFx0XHRpZiAoby5vcGFjaXR5KSBwYXNzLm9wYWNpdHkgPSB0cmFjZS5vcGFjaXR5XHJcblxyXG5cdFx0XHRpZiAoby5yYW5nZSkge1xyXG5cdFx0XHRcdHBhc3MucmFuZ2UgPSBtdWx0aXJhbmdlID8gZ2V0Qm94KHRyYWNlLnJhbmdlLCBpLCBqKSA6IHRyYWNlLnJhbmdlIHx8IHBhc3MuYm91bmRzXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRyYWNlLnBhc3Nlcy5wdXNoKGtleSlcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzXHJcbn1cclxuXHJcblxyXG4vLyBkcmF3IGFsbCBvciBwYXNzZWQgcGFzc2VzXHJcblNQTE9NLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuXHRpZiAoIWFyZ3MubGVuZ3RoKSB7XHJcblx0XHR0aGlzLnNjYXR0ZXIuZHJhdygpXHJcblx0fVxyXG5cdGVsc2Uge1xyXG5cdFx0bGV0IGlkeCA9IFtdXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0Ly8gZHJhdygwLCAyLCA1KSAtIGRyYXcgdHJhY2VzXHJcblx0XHRcdGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gJ251bWJlcicgKSB7XHJcblx0XHRcdFx0bGV0IHsgcGFzc2VzLCBwYXNzT2Zmc2V0IH0gPSB0aGlzLnRyYWNlc1thcmdzW2ldXVxyXG5cdFx0XHRcdGlkeC5wdXNoKC4uLmFyclJhbmdlKHBhc3NPZmZzZXQsIHBhc3NPZmZzZXQgKyBwYXNzZXMubGVuZ3RoKSlcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBkcmF3KFswLCAxLCAyIC4uLl0sIFszLCA0LCA1XSkgLSBkcmF3IHBvaW50c1xyXG5cdFx0XHRlbHNlIGlmIChhcmdzW2ldLmxlbmd0aCkge1xyXG5cdFx0XHRcdGxldCBlbHMgPSBhcmdzW2ldXHJcblx0XHRcdFx0bGV0IHsgcGFzc2VzLCBwYXNzT2Zmc2V0IH0gPSB0aGlzLnRyYWNlc1tpXVxyXG5cdFx0XHRcdHBhc3NlcyA9IHBhc3Nlcy5tYXAoKHBhc3NJZCwgaSkgPT4ge1xyXG5cdFx0XHRcdFx0aWR4W3Bhc3NPZmZzZXQgKyBpXSA9IGVsc1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHRoaXMuc2NhdHRlci5kcmF3KC4uLmlkeClcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzXHJcbn1cclxuXHJcblxyXG4vLyBkaXNwb3NlIHJlc291cmNlc1xyXG5TUExPTS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLnRyYWNlcy5mb3JFYWNoKHRyYWNlID0+IHtcclxuXHRcdGlmICh0cmFjZS5idWZmZXIgJiYgdHJhY2UuYnVmZmVyLmRlc3Ryb3kpIHRyYWNlLmJ1ZmZlci5kZXN0cm95KClcclxuXHR9KVxyXG5cdHRoaXMudHJhY2VzID0gbnVsbFxyXG5cdHRoaXMucGFzc2VzID0gbnVsbFxyXG5cclxuXHR0aGlzLnNjYXR0ZXIuZGVzdHJveSgpXHJcblxyXG5cdHJldHVybiB0aGlzXHJcbn1cclxuXHJcblxyXG4vLyByZXR1cm4gcGFzcyBjb3JyZXNwb25kaW5nIHRvIHRyYWNlIGktIGotIHNxdWFyZVxyXG5mdW5jdGlvbiBwYXNzSWQgKHRyYWNlLCBpLCBqKSB7XHJcblx0bGV0IGlkID0gKHRyYWNlLmlkICE9IG51bGwgPyB0cmFjZS5pZCA6IHRyYWNlKVxyXG5cdGxldCBuID0gaVxyXG5cdGxldCBtID0galxyXG5cdGxldCBrZXkgPSBpZCA8PCAxNiB8IChuICYgMHhmZikgPDwgOCB8IG0gJiAweGZmXHJcblxyXG5cdHJldHVybiBrZXlcclxufVxyXG5cclxuXHJcbi8vIHJldHVybiBib3VuZGluZyBib3ggY29ycmVzcG9uZGluZyB0byBhIHBhc3NcclxuZnVuY3Rpb24gZ2V0Qm94IChpdGVtcywgaSwgaikge1xyXG5cdGxldCBpbG94LCBpbG95LCBpaGl4LCBpaGl5LCBqbG94LCBqbG95LCBqaGl4LCBqaGl5XHJcblx0bGV0IGlpdGVtID0gaXRlbXNbaV0sIGppdGVtID0gaXRlbXNbal1cclxuXHJcblx0aWYgKGlpdGVtLmxlbmd0aCA+IDIpIHtcclxuXHRcdGlsb3ggPSBpaXRlbVswXVxyXG5cdFx0aWhpeCA9IGlpdGVtWzJdXHJcblx0XHRpbG95ID0gaWl0ZW1bMV1cclxuXHRcdGloaXkgPSBpaXRlbVszXVxyXG5cdH1cclxuXHRlbHNlIGlmIChpaXRlbS5sZW5ndGgpIHtcclxuXHRcdGlsb3ggPSBpbG95ID0gaWl0ZW1bMF1cclxuXHRcdGloaXggPSBpaGl5ID0gaWl0ZW1bMV1cclxuXHR9XHJcblx0ZWxzZSB7XHJcblx0XHRpbG94ID0gaWl0ZW0ueFxyXG5cdFx0aWxveSA9IGlpdGVtLnlcclxuXHRcdGloaXggPSBpaXRlbS54ICsgaWl0ZW0ud2lkdGhcclxuXHRcdGloaXkgPSBpaXRlbS55ICsgaWl0ZW0uaGVpZ2h0XHJcblx0fVxyXG5cclxuXHRpZiAoaml0ZW0ubGVuZ3RoID4gMikge1xyXG5cdFx0amxveCA9IGppdGVtWzBdXHJcblx0XHRqaGl4ID0gaml0ZW1bMl1cclxuXHRcdGpsb3kgPSBqaXRlbVsxXVxyXG5cdFx0amhpeSA9IGppdGVtWzNdXHJcblx0fVxyXG5cdGVsc2UgaWYgKGppdGVtLmxlbmd0aCkge1xyXG5cdFx0amxveCA9IGpsb3kgPSBqaXRlbVswXVxyXG5cdFx0amhpeCA9IGpoaXkgPSBqaXRlbVsxXVxyXG5cdH1cclxuXHRlbHNlIHtcclxuXHRcdGpsb3ggPSBqaXRlbS54XHJcblx0XHRqbG95ID0gaml0ZW0ueVxyXG5cdFx0amhpeCA9IGppdGVtLnggKyBqaXRlbS53aWR0aFxyXG5cdFx0amhpeSA9IGppdGVtLnkgKyBqaXRlbS5oZWlnaHRcclxuXHR9XHJcblxyXG5cdHJldHVybiBbIGpsb3gsIGlsb3ksIGpoaXgsIGloaXkgXVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0UGFkIChhcmcpIHtcclxuXHRpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHJldHVybiBbYXJnLCBhcmcsIGFyZywgYXJnXVxyXG5cdGVsc2UgaWYgKGFyZy5sZW5ndGggPT09IDIpIHJldHVybiBbYXJnWzBdLCBhcmdbMV0sIGFyZ1swXSwgYXJnWzFdXVxyXG5cdGVsc2Uge1xyXG5cdFx0bGV0IGJveCA9IHJlY3QoYXJnKVxyXG5cdFx0cmV0dXJuIFtib3gueCwgYm94LnksIGJveC54ICsgYm94LndpZHRoLCBib3gueSArIGJveC5oZWlnaHRdXHJcblx0fVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=