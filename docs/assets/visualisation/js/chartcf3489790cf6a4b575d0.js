(self["webpackChunkdi_website"] = self["webpackChunkdi_website"] || []).push([["vendors-node_modules_plotly_js_lib_index_js"],{

/***/ "./node_modules/plotly.js/lib/bar.js":
/*!*******************************************!*\
  !*** ./node_modules/plotly.js/lib/bar.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/traces/bar */ "./node_modules/plotly.js/src/traces/bar/index.js");


/***/ }),

/***/ "./node_modules/plotly.js/lib/box.js":
/*!*******************************************!*\
  !*** ./node_modules/plotly.js/lib/box.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/traces/box */ "./node_modules/plotly.js/src/traces/box/index.js");


/***/ }),

/***/ "./node_modules/plotly.js/lib/candlestick.js":
/*!***************************************************!*\
  !*** ./node_modules/plotly.js/lib/candlestick.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/traces/candlestick */ "./node_modules/plotly.js/src/traces/candlestick/index.js");


/***/ }),

/***/ "./node_modules/plotly.js/lib/choropleth.js":
/*!**************************************************!*\
  !*** ./node_modules/plotly.js/lib/choropleth.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/traces/choropleth */ "./node_modules/plotly.js/src/traces/choropleth/index.js");


/***/ }),

/***/ "./node_modules/plotly.js/lib/contour.js":
/*!***********************************************!*\
  !*** ./node_modules/plotly.js/lib/contour.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/traces/contour */ "./node_modules/plotly.js/src/traces/contour/index.js");


/***/ }),

/***/ "./node_modules/plotly.js/lib/heatmap.js":
/*!***********************************************!*\
  !*** ./node_modules/plotly.js/lib/heatmap.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/traces/heatmap */ "./node_modules/plotly.js/src/traces/heatmap/index.js");


/***/ }),

/***/ "./node_modules/plotly.js/lib/heatmapgl.js":
/*!*************************************************!*\
  !*** ./node_modules/plotly.js/lib/heatmapgl.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/traces/heatmapgl */ "./node_modules/plotly.js/src/traces/heatmapgl/index.js");


/***/ }),

/***/ "./node_modules/plotly.js/lib/histogram2d.js":
/*!***************************************************!*\
  !*** ./node_modules/plotly.js/lib/histogram2d.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/traces/histogram2d */ "./node_modules/plotly.js/src/traces/histogram2d/index.js");


/***/ }),

/***/ "./node_modules/plotly.js/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/plotly.js/lib/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Plotly = __webpack_require__(/*! ./core */ "./node_modules/plotly.js/lib/core.js");

// traces
Plotly.register([
    __webpack_require__(/*! ./bar */ "./node_modules/plotly.js/lib/bar.js"),
    __webpack_require__(/*! ./box */ "./node_modules/plotly.js/lib/box.js"),
    __webpack_require__(/*! ./heatmap */ "./node_modules/plotly.js/lib/heatmap.js"),
    __webpack_require__(/*! ./histogram */ "./node_modules/plotly.js/lib/histogram.js"),
    __webpack_require__(/*! ./histogram2d */ "./node_modules/plotly.js/lib/histogram2d.js"),
    __webpack_require__(/*! ./histogram2dcontour */ "./node_modules/plotly.js/lib/histogram2dcontour.js"),
    __webpack_require__(/*! ./contour */ "./node_modules/plotly.js/lib/contour.js"),
    __webpack_require__(/*! ./scatterternary */ "./node_modules/plotly.js/lib/scatterternary.js"),
    __webpack_require__(/*! ./violin */ "./node_modules/plotly.js/lib/violin.js"),
    __webpack_require__(/*! ./funnel */ "./node_modules/plotly.js/lib/funnel.js"),
    __webpack_require__(/*! ./waterfall */ "./node_modules/plotly.js/lib/waterfall.js"),
    __webpack_require__(/*! ./image */ "./node_modules/plotly.js/lib/image.js"),

    __webpack_require__(/*! ./pie */ "./node_modules/plotly.js/lib/pie.js"),
    __webpack_require__(/*! ./sunburst */ "./node_modules/plotly.js/lib/sunburst.js"),
    __webpack_require__(/*! ./treemap */ "./node_modules/plotly.js/lib/treemap.js"),
    __webpack_require__(/*! ./funnelarea */ "./node_modules/plotly.js/lib/funnelarea.js"),

    __webpack_require__(/*! ./scatter3d */ "./node_modules/plotly.js/lib/scatter3d.js"),
    __webpack_require__(/*! ./surface */ "./node_modules/plotly.js/lib/surface.js"),
    __webpack_require__(/*! ./isosurface */ "./node_modules/plotly.js/lib/isosurface.js"),
    __webpack_require__(/*! ./volume */ "./node_modules/plotly.js/lib/volume.js"),
    __webpack_require__(/*! ./mesh3d */ "./node_modules/plotly.js/lib/mesh3d.js"),
    __webpack_require__(/*! ./cone */ "./node_modules/plotly.js/lib/cone.js"),
    __webpack_require__(/*! ./streamtube */ "./node_modules/plotly.js/lib/streamtube.js"),

    __webpack_require__(/*! ./scattergeo */ "./node_modules/plotly.js/lib/scattergeo.js"),
    __webpack_require__(/*! ./choropleth */ "./node_modules/plotly.js/lib/choropleth.js"),

    __webpack_require__(/*! ./scattergl */ "./node_modules/plotly.js/lib/scattergl.js"),
    __webpack_require__(/*! ./splom */ "./node_modules/plotly.js/lib/splom.js"),

    __webpack_require__(/*! ./pointcloud */ "./node_modules/plotly.js/lib/pointcloud.js"),
    __webpack_require__(/*! ./heatmapgl */ "./node_modules/plotly.js/lib/heatmapgl.js"),

    __webpack_require__(/*! ./parcoords */ "./node_modules/plotly.js/lib/parcoords.js"),

    __webpack_require__(/*! ./parcats */ "./node_modules/plotly.js/lib/parcats.js"),

    __webpack_require__(/*! ./scattermapbox */ "./node_modules/plotly.js/lib/scattermapbox.js"),
    __webpack_require__(/*! ./choroplethmapbox */ "./node_modules/plotly.js/lib/choroplethmapbox.js"),
    __webpack_require__(/*! ./densitymapbox */ "./node_modules/plotly.js/lib/densitymapbox.js"),

    __webpack_require__(/*! ./sankey */ "./node_modules/plotly.js/lib/sankey.js"),
    __webpack_require__(/*! ./indicator */ "./node_modules/plotly.js/lib/indicator.js"),

    __webpack_require__(/*! ./table */ "./node_modules/plotly.js/lib/table.js"),

    __webpack_require__(/*! ./carpet */ "./node_modules/plotly.js/lib/carpet.js"),
    __webpack_require__(/*! ./scattercarpet */ "./node_modules/plotly.js/lib/scattercarpet.js"),
    __webpack_require__(/*! ./contourcarpet */ "./node_modules/plotly.js/lib/contourcarpet.js"),

    __webpack_require__(/*! ./ohlc */ "./node_modules/plotly.js/lib/ohlc.js"),
    __webpack_require__(/*! ./candlestick */ "./node_modules/plotly.js/lib/candlestick.js"),

    __webpack_require__(/*! ./scatterpolar */ "./node_modules/plotly.js/lib/scatterpolar.js"),
    __webpack_require__(/*! ./scatterpolargl */ "./node_modules/plotly.js/lib/scatterpolargl.js"),
    __webpack_require__(/*! ./barpolar */ "./node_modules/plotly.js/lib/barpolar.js")
]);

// transforms
//
// Please note that all *transform* methods are executed before
// all *calcTransform* methods - which could possibly lead to
// unexpected results when applying multiple transforms of different types
// to a given trace.
//
// For more info, see:
// https://github.com/plotly/plotly.js/pull/978#pullrequestreview-2403353
//
Plotly.register([
    __webpack_require__(/*! ./aggregate */ "./node_modules/plotly.js/lib/aggregate.js"),
    __webpack_require__(/*! ./filter */ "./node_modules/plotly.js/lib/filter.js"),
    __webpack_require__(/*! ./groupby */ "./node_modules/plotly.js/lib/groupby.js"),
    __webpack_require__(/*! ./sort */ "./node_modules/plotly.js/lib/sort.js")
]);

// components
Plotly.register([
    __webpack_require__(/*! ./calendars */ "./node_modules/plotly.js/lib/calendars.js")
]);

module.exports = Plotly;


/***/ }),

/***/ "./node_modules/plotly.js/lib/isosurface.js":
/*!**************************************************!*\
  !*** ./node_modules/plotly.js/lib/isosurface.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/traces/isosurface */ "./node_modules/plotly.js/src/traces/isosurface/index.js");


/***/ }),

/***/ "./node_modules/plotly.js/lib/ohlc.js":
/*!********************************************!*\
  !*** ./node_modules/plotly.js/lib/ohlc.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/traces/ohlc */ "./node_modules/plotly.js/src/traces/ohlc/index.js");


/***/ }),

/***/ "./node_modules/plotly.js/lib/pie.js":
/*!*******************************************!*\
  !*** ./node_modules/plotly.js/lib/pie.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/traces/pie */ "./node_modules/plotly.js/src/traces/pie/index.js");


/***/ }),

/***/ "./node_modules/plotly.js/lib/scatterpolar.js":
/*!****************************************************!*\
  !*** ./node_modules/plotly.js/lib/scatterpolar.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/traces/scatterpolar */ "./node_modules/plotly.js/src/traces/scatterpolar/index.js");


/***/ }),

/***/ "./node_modules/plotly.js/lib/sunburst.js":
/*!************************************************!*\
  !*** ./node_modules/plotly.js/lib/sunburst.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/traces/sunburst */ "./node_modules/plotly.js/src/traces/sunburst/index.js");


/***/ }),

/***/ "./node_modules/plotly.js/lib/volume.js":
/*!**********************************************!*\
  !*** ./node_modules/plotly.js/lib/volume.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = __webpack_require__(/*! ../src/traces/volume */ "./node_modules/plotly.js/src/traces/volume/index.js");


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/bar/calc.js":
/*!*******************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/bar/calc.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Axes = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js");
var hasColorscale = __webpack_require__(/*! ../../components/colorscale/helpers */ "./node_modules/plotly.js/src/components/colorscale/helpers.js").hasColorscale;
var colorscaleCalc = __webpack_require__(/*! ../../components/colorscale/calc */ "./node_modules/plotly.js/src/components/colorscale/calc.js");
var arraysToCalcdata = __webpack_require__(/*! ./arrays_to_calcdata */ "./node_modules/plotly.js/src/traces/bar/arrays_to_calcdata.js");
var calcSelection = __webpack_require__(/*! ../scatter/calc_selection */ "./node_modules/plotly.js/src/traces/scatter/calc_selection.js");

module.exports = function calc(gd, trace) {
    var xa = Axes.getFromId(gd, trace.xaxis || 'x');
    var ya = Axes.getFromId(gd, trace.yaxis || 'y');
    var size, pos;

    var sizeOpts = {
        msUTC: !!(trace.base || trace.base === 0)
    };

    if(trace.orientation === 'h') {
        size = xa.makeCalcdata(trace, 'x', sizeOpts);
        pos = ya.makeCalcdata(trace, 'y');
    } else {
        size = ya.makeCalcdata(trace, 'y', sizeOpts);
        pos = xa.makeCalcdata(trace, 'x');
    }

    // create the "calculated data" to plot
    var serieslen = Math.min(pos.length, size.length);
    var cd = new Array(serieslen);

    // set position and size
    for(var i = 0; i < serieslen; i++) {
        cd[i] = { p: pos[i], s: size[i] };

        if(trace.ids) {
            cd[i].id = String(trace.ids[i]);
        }
    }

    // auto-z and autocolorscale if applicable
    if(hasColorscale(trace, 'marker')) {
        colorscaleCalc(gd, trace, {
            vals: trace.marker.color,
            containerStr: 'marker',
            cLetter: 'c'
        });
    }
    if(hasColorscale(trace, 'marker.line')) {
        colorscaleCalc(gd, trace, {
            vals: trace.marker.line.color,
            containerStr: 'marker.line',
            cLetter: 'c'
        });
    }

    arraysToCalcdata(cd, trace);
    calcSelection(cd, trace);

    return cd;
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/bar/event_data.js":
/*!*************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/bar/event_data.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = function eventData(out, pt, trace) {
    // standard cartesian event data
    out.x = 'xVal' in pt ? pt.xVal : pt.x;
    out.y = 'yVal' in pt ? pt.yVal : pt.y;
    if(pt.xa) out.xaxis = pt.xa;
    if(pt.ya) out.yaxis = pt.ya;

    if(trace.orientation === 'h') {
        out.label = out.y;
        out.value = out.x;
    } else {
        out.label = out.x;
        out.value = out.y;
    }

    return out;
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/bar/index.js":
/*!********************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/bar/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/bar/attributes.js"),
    layoutAttributes: __webpack_require__(/*! ./layout_attributes */ "./node_modules/plotly.js/src/traces/bar/layout_attributes.js"),
    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/bar/defaults.js").supplyDefaults,
    crossTraceDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/bar/defaults.js").crossTraceDefaults,
    supplyLayoutDefaults: __webpack_require__(/*! ./layout_defaults */ "./node_modules/plotly.js/src/traces/bar/layout_defaults.js"),
    calc: __webpack_require__(/*! ./calc */ "./node_modules/plotly.js/src/traces/bar/calc.js"),
    crossTraceCalc: __webpack_require__(/*! ./cross_trace_calc */ "./node_modules/plotly.js/src/traces/bar/cross_trace_calc.js").crossTraceCalc,
    colorbar: __webpack_require__(/*! ../scatter/marker_colorbar */ "./node_modules/plotly.js/src/traces/scatter/marker_colorbar.js"),
    arraysToCalcdata: __webpack_require__(/*! ./arrays_to_calcdata */ "./node_modules/plotly.js/src/traces/bar/arrays_to_calcdata.js"),
    plot: __webpack_require__(/*! ./plot */ "./node_modules/plotly.js/src/traces/bar/plot.js").plot,
    style: __webpack_require__(/*! ./style */ "./node_modules/plotly.js/src/traces/bar/style.js").style,
    styleOnSelect: __webpack_require__(/*! ./style */ "./node_modules/plotly.js/src/traces/bar/style.js").styleOnSelect,
    hoverPoints: __webpack_require__(/*! ./hover */ "./node_modules/plotly.js/src/traces/bar/hover.js").hoverPoints,
    eventData: __webpack_require__(/*! ./event_data */ "./node_modules/plotly.js/src/traces/bar/event_data.js"),
    selectPoints: __webpack_require__(/*! ./select */ "./node_modules/plotly.js/src/traces/bar/select.js"),

    moduleType: 'trace',
    name: 'bar',
    basePlotModule: __webpack_require__(/*! ../../plots/cartesian */ "./node_modules/plotly.js/src/plots/cartesian/index.js"),
    categories: ['bar-like', 'cartesian', 'svg', 'bar', 'oriented', 'errorBarsOK', 'showLegend', 'zoomScale'],
    animatable: true,
    meta: {
        description: [
            'The data visualized by the span of the bars is set in `y`',
            'if `orientation` is set th *v* (the default)',
            'and the labels are set in `x`.',
            'By setting `orientation` to *h*, the roles are interchanged.'
        ].join(' ')
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/box/event_data.js":
/*!*************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/box/event_data.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = function eventData(out, pt) {
    // Note: hoverOnBox property is needed for click-to-select
    // to ignore when a box was clicked. This is the reason box
    // implements this custom eventData function.
    if(pt.hoverOnBox) out.hoverOnBox = pt.hoverOnBox;

    if('xVal' in pt) out.x = pt.xVal;
    if('yVal' in pt) out.y = pt.yVal;
    if(pt.xa) out.xaxis = pt.xa;
    if(pt.ya) out.yaxis = pt.ya;

    return out;
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/box/index.js":
/*!********************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/box/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/box/attributes.js"),
    layoutAttributes: __webpack_require__(/*! ./layout_attributes */ "./node_modules/plotly.js/src/traces/box/layout_attributes.js"),
    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/box/defaults.js").supplyDefaults,
    crossTraceDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/box/defaults.js").crossTraceDefaults,
    supplyLayoutDefaults: __webpack_require__(/*! ./layout_defaults */ "./node_modules/plotly.js/src/traces/box/layout_defaults.js").supplyLayoutDefaults,
    calc: __webpack_require__(/*! ./calc */ "./node_modules/plotly.js/src/traces/box/calc.js"),
    crossTraceCalc: __webpack_require__(/*! ./cross_trace_calc */ "./node_modules/plotly.js/src/traces/box/cross_trace_calc.js").crossTraceCalc,
    plot: __webpack_require__(/*! ./plot */ "./node_modules/plotly.js/src/traces/box/plot.js").plot,
    style: __webpack_require__(/*! ./style */ "./node_modules/plotly.js/src/traces/box/style.js").style,
    styleOnSelect: __webpack_require__(/*! ./style */ "./node_modules/plotly.js/src/traces/box/style.js").styleOnSelect,
    hoverPoints: __webpack_require__(/*! ./hover */ "./node_modules/plotly.js/src/traces/box/hover.js").hoverPoints,
    eventData: __webpack_require__(/*! ./event_data */ "./node_modules/plotly.js/src/traces/box/event_data.js"),
    selectPoints: __webpack_require__(/*! ./select */ "./node_modules/plotly.js/src/traces/box/select.js"),

    moduleType: 'trace',
    name: 'box',
    basePlotModule: __webpack_require__(/*! ../../plots/cartesian */ "./node_modules/plotly.js/src/plots/cartesian/index.js"),
    categories: ['cartesian', 'svg', 'symbols', 'oriented', 'box-violin', 'showLegend', 'boxLayout', 'zoomScale'],
    meta: {
        description: [
            'Each box spans from quartile 1 (Q1) to quartile 3 (Q3).',
            'The second quartile (Q2, i.e. the median) is marked by a line inside the box.',
            'The fences grow outward from the boxes\' edges,',
            'by default they span +/- 1.5 times the interquartile range (IQR: Q3-Q1),',
            'The sample mean and standard deviation as well as notches and',
            'the sample, outlier and suspected outliers points can be optionally',
            'added to the box plot.',

            'The values and positions corresponding to each boxes can be input',
            'using two signatures.',

            'The first signature expects users to supply the sample values in the `y`',
            'data array for vertical boxes (`x` for horizontal boxes).',
            'By supplying an `x` (`y`) array, one box per distinct `x` (`y`) value is drawn',
            'If no `x` (`y`) {array} is provided, a single box is drawn.',
            'In this case, the box is positioned with the trace `name` or with `x0` (`y0`) if provided.',

            'The second signature expects users to supply the boxes corresponding Q1, median and Q3',
            'statistics in the `q1`, `median` and `q3` data arrays respectively.',
            'Other box features relying on statistics namely `lowerfence`, `upperfence`, `notchspan`',
            'can be set directly by the users.',
            'To have plotly compute them or to show sample points besides the boxes,',
            'users can set the `y` data array for vertical boxes (`x` for horizontal boxes)',
            'to a 2D array with the outer length corresponding',
            'to the number of boxes in the traces and the inner length corresponding the sample size.'
        ].join(' ')
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/box/style.js":
/*!********************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/box/style.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");
var Color = __webpack_require__(/*! ../../components/color */ "./node_modules/plotly.js/src/components/color/index.js");
var Drawing = __webpack_require__(/*! ../../components/drawing */ "./node_modules/plotly.js/src/components/drawing/index.js");

function style(gd, cd, sel) {
    var s = sel ? sel : d3.select(gd).selectAll('g.trace.boxes');

    s.style('opacity', function(d) { return d[0].trace.opacity; });

    s.each(function(d) {
        var el = d3.select(this);
        var trace = d[0].trace;
        var lineWidth = trace.line.width;

        function styleBox(boxSel, lineWidth, lineColor, fillColor) {
            boxSel.style('stroke-width', lineWidth + 'px')
                .call(Color.stroke, lineColor)
                .call(Color.fill, fillColor);
        }

        var allBoxes = el.selectAll('path.box');

        if(trace.type === 'candlestick') {
            allBoxes.each(function(boxData) {
                if(boxData.empty) return;

                var thisBox = d3.select(this);
                var container = trace[boxData.dir]; // dir = 'increasing' or 'decreasing'
                styleBox(thisBox, container.line.width, container.line.color, container.fillcolor);
                // TODO: custom selection style for candlesticks
                thisBox.style('opacity', trace.selectedpoints && !boxData.selected ? 0.3 : 1);
            });
        } else {
            styleBox(allBoxes, lineWidth, trace.line.color, trace.fillcolor);
            el.selectAll('path.mean')
                .style({
                    'stroke-width': lineWidth,
                    'stroke-dasharray': (2 * lineWidth) + 'px,' + lineWidth + 'px'
                })
                .call(Color.stroke, trace.line.color);

            var pts = el.selectAll('path.point');
            Drawing.pointStyle(pts, trace, gd);
        }
    });
}

function styleOnSelect(gd, cd, sel) {
    var trace = cd[0].trace;
    var pts = sel.selectAll('path.point');

    if(trace.selectedpoints) {
        Drawing.selectedPointStyle(pts, trace);
    } else {
        Drawing.pointStyle(pts, trace, gd);
    }
}

module.exports = {
    style: style,
    styleOnSelect: styleOnSelect
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/candlestick/attributes.js":
/*!*********************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/candlestick/attributes.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var extendFlat = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js").extendFlat;
var OHLCattrs = __webpack_require__(/*! ../ohlc/attributes */ "./node_modules/plotly.js/src/traces/ohlc/attributes.js");
var boxAttrs = __webpack_require__(/*! ../box/attributes */ "./node_modules/plotly.js/src/traces/box/attributes.js");

function directionAttrs(lineColorDefault) {
    return {
        line: {
            color: extendFlat({}, boxAttrs.line.color, {dflt: lineColorDefault}),
            width: boxAttrs.line.width,
            editType: 'style'
        },

        fillcolor: boxAttrs.fillcolor,
        editType: 'style'
    };
}

module.exports = {
    x: OHLCattrs.x,
    open: OHLCattrs.open,
    high: OHLCattrs.high,
    low: OHLCattrs.low,
    close: OHLCattrs.close,

    line: {
        width: extendFlat({}, boxAttrs.line.width, {
            description: [
                boxAttrs.line.width.description,
                'Note that this style setting can also be set per',
                'direction via `increasing.line.width` and',
                '`decreasing.line.width`.'
            ].join(' ')
        }),
        editType: 'style'
    },

    increasing: directionAttrs(OHLCattrs.increasing.line.color.dflt),

    decreasing: directionAttrs(OHLCattrs.decreasing.line.color.dflt),

    text: OHLCattrs.text,
    hovertext: OHLCattrs.hovertext,
    whiskerwidth: extendFlat({}, boxAttrs.whiskerwidth, { dflt: 0 }),

    hoverlabel: OHLCattrs.hoverlabel,
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/candlestick/calc.js":
/*!***************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/candlestick/calc.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Axes = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js");

var calcCommon = __webpack_require__(/*! ../ohlc/calc */ "./node_modules/plotly.js/src/traces/ohlc/calc.js").calcCommon;

module.exports = function(gd, trace) {
    var fullLayout = gd._fullLayout;
    var xa = Axes.getFromId(gd, trace.xaxis);
    var ya = Axes.getFromId(gd, trace.yaxis);

    var x = xa.makeCalcdata(trace, 'x');

    var cd = calcCommon(gd, trace, x, ya, ptFunc);

    if(cd.length) {
        Lib.extendFlat(cd[0].t, {
            num: fullLayout._numBoxes,
            dPos: Lib.distinctVals(x).minDiff / 2,
            posLetter: 'x',
            valLetter: 'y',
        });

        fullLayout._numBoxes++;
        return cd;
    } else {
        return [{t: {empty: true}}];
    }
};

function ptFunc(o, h, l, c) {
    return {
        min: l,
        q1: Math.min(o, c),
        med: c,
        q3: Math.max(o, c),
        max: h,
    };
}


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/candlestick/defaults.js":
/*!*******************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/candlestick/defaults.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var Color = __webpack_require__(/*! ../../components/color */ "./node_modules/plotly.js/src/components/color/index.js");
var handleOHLC = __webpack_require__(/*! ../ohlc/ohlc_defaults */ "./node_modules/plotly.js/src/traces/ohlc/ohlc_defaults.js");
var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/candlestick/attributes.js");

module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
    function coerce(attr, dflt) {
        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
    }

    var len = handleOHLC(traceIn, traceOut, coerce, layout);
    if(!len) {
        traceOut.visible = false;
        return;
    }

    coerce('line.width');

    handleDirection(traceIn, traceOut, coerce, 'increasing');
    handleDirection(traceIn, traceOut, coerce, 'decreasing');

    coerce('text');
    coerce('hovertext');
    coerce('whiskerwidth');

    layout._requestRangeslider[traceOut.xaxis] = true;
};

function handleDirection(traceIn, traceOut, coerce, direction) {
    var lineColor = coerce(direction + '.line.color');
    coerce(direction + '.line.width', traceOut.line.width);
    coerce(direction + '.fillcolor', Color.addOpacity(lineColor, 0.5));
}


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/candlestick/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/candlestick/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    moduleType: 'trace',
    name: 'candlestick',
    basePlotModule: __webpack_require__(/*! ../../plots/cartesian */ "./node_modules/plotly.js/src/plots/cartesian/index.js"),
    categories: ['cartesian', 'svg', 'showLegend', 'candlestick', 'boxLayout'],
    meta: {
        description: [
            'The candlestick is a style of financial chart describing',
            'open, high, low and close for a given `x` coordinate (most likely time).',

            'The boxes represent the spread between the `open` and `close` values and',
            'the lines represent the spread between the `low` and `high` values',

            'Sample points where the close value is higher (lower) then the open',
            'value are called increasing (decreasing).',

            'By default, increasing candles are drawn in green whereas',
            'decreasing are drawn in red.'
        ].join(' ')
    },

    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/candlestick/attributes.js"),
    layoutAttributes: __webpack_require__(/*! ../box/layout_attributes */ "./node_modules/plotly.js/src/traces/box/layout_attributes.js"),
    supplyLayoutDefaults: __webpack_require__(/*! ../box/layout_defaults */ "./node_modules/plotly.js/src/traces/box/layout_defaults.js").supplyLayoutDefaults,
    crossTraceCalc: __webpack_require__(/*! ../box/cross_trace_calc */ "./node_modules/plotly.js/src/traces/box/cross_trace_calc.js").crossTraceCalc,
    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/candlestick/defaults.js"),
    calc: __webpack_require__(/*! ./calc */ "./node_modules/plotly.js/src/traces/candlestick/calc.js"),
    plot: __webpack_require__(/*! ../box/plot */ "./node_modules/plotly.js/src/traces/box/plot.js").plot,
    layerName: 'boxlayer',
    style: __webpack_require__(/*! ../box/style */ "./node_modules/plotly.js/src/traces/box/style.js").style,
    hoverPoints: __webpack_require__(/*! ../ohlc/hover */ "./node_modules/plotly.js/src/traces/ohlc/hover.js").hoverPoints,
    selectPoints: __webpack_require__(/*! ../ohlc/select */ "./node_modules/plotly.js/src/traces/ohlc/select.js")
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/choropleth/defaults.js":
/*!******************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/choropleth/defaults.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var colorscaleDefaults = __webpack_require__(/*! ../../components/colorscale/defaults */ "./node_modules/plotly.js/src/components/colorscale/defaults.js");
var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/choropleth/attributes.js");

module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
    function coerce(attr, dflt) {
        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
    }

    var locations = coerce('locations');
    var z = coerce('z');

    if(!(locations && locations.length && Lib.isArrayOrTypedArray(z) && z.length)) {
        traceOut.visible = false;
        return;
    }

    traceOut._length = Math.min(locations.length, z.length);

    var geojson = coerce('geojson');

    var locationmodeDflt;
    if((typeof geojson === 'string' && geojson !== '') || Lib.isPlainObject(geojson)) {
        locationmodeDflt = 'geojson-id';
    }

    var locationMode = coerce('locationmode', locationmodeDflt);

    if(locationMode === 'geojson-id') {
        coerce('featureidkey');
    }

    coerce('text');
    coerce('hovertext');
    coerce('hovertemplate');

    var mlw = coerce('marker.line.width');
    if(mlw) coerce('marker.line.color');
    coerce('marker.opacity');

    colorscaleDefaults(traceIn, traceOut, layout, coerce, {prefix: '', cLetter: 'z'});

    Lib.coerceSelectionMarkerOpacity(traceOut, coerce);
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/choropleth/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/choropleth/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/choropleth/attributes.js"),
    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/choropleth/defaults.js"),
    colorbar: __webpack_require__(/*! ../heatmap/colorbar */ "./node_modules/plotly.js/src/traces/heatmap/colorbar.js"),
    calc: __webpack_require__(/*! ./calc */ "./node_modules/plotly.js/src/traces/choropleth/calc.js"),
    calcGeoJSON: __webpack_require__(/*! ./plot */ "./node_modules/plotly.js/src/traces/choropleth/plot.js").calcGeoJSON,
    plot: __webpack_require__(/*! ./plot */ "./node_modules/plotly.js/src/traces/choropleth/plot.js").plot,
    style: __webpack_require__(/*! ./style */ "./node_modules/plotly.js/src/traces/choropleth/style.js").style,
    styleOnSelect: __webpack_require__(/*! ./style */ "./node_modules/plotly.js/src/traces/choropleth/style.js").styleOnSelect,
    hoverPoints: __webpack_require__(/*! ./hover */ "./node_modules/plotly.js/src/traces/choropleth/hover.js"),
    eventData: __webpack_require__(/*! ./event_data */ "./node_modules/plotly.js/src/traces/choropleth/event_data.js"),
    selectPoints: __webpack_require__(/*! ./select */ "./node_modules/plotly.js/src/traces/choropleth/select.js"),

    moduleType: 'trace',
    name: 'choropleth',
    basePlotModule: __webpack_require__(/*! ../../plots/geo */ "./node_modules/plotly.js/src/plots/geo/index.js"),
    categories: ['geo', 'noOpacity', 'showLegend'],
    meta: {
        description: [
            'The data that describes the choropleth value-to-color mapping',
            'is set in `z`.',
            'The geographic locations corresponding to each value in `z`',
            'are set in `locations`.'
        ].join(' ')
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/choropleth/plot.js":
/*!**************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/choropleth/plot.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");

var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var geoUtils = __webpack_require__(/*! ../../lib/geo_location_utils */ "./node_modules/plotly.js/src/lib/geo_location_utils.js");
var getTopojsonFeatures = __webpack_require__(/*! ../../lib/topojson_utils */ "./node_modules/plotly.js/src/lib/topojson_utils.js").getTopojsonFeatures;
var findExtremes = __webpack_require__(/*! ../../plots/cartesian/autorange */ "./node_modules/plotly.js/src/plots/cartesian/autorange.js").findExtremes;

var style = __webpack_require__(/*! ./style */ "./node_modules/plotly.js/src/traces/choropleth/style.js").style;

function plot(gd, geo, calcData) {
    var choroplethLayer = geo.layers.backplot.select('.choroplethlayer');

    Lib.makeTraceGroups(choroplethLayer, calcData, 'trace choropleth').each(function(calcTrace) {
        var sel = d3.select(this);

        var paths = sel.selectAll('path.choroplethlocation')
            .data(Lib.identity);

        paths.enter().append('path')
            .classed('choroplethlocation', true);

        paths.exit().remove();

        // call style here within topojson request callback
        style(gd, calcTrace);
    });
}

function calcGeoJSON(calcTrace, fullLayout) {
    var trace = calcTrace[0].trace;
    var geoLayout = fullLayout[trace.geo];
    var geo = geoLayout._subplot;
    var locationmode = trace.locationmode;
    var len = trace._length;

    var features = locationmode === 'geojson-id' ?
        geoUtils.extractTraceFeature(calcTrace) :
        getTopojsonFeatures(trace, geo.topojson);

    var lonArray = [];
    var latArray = [];

    for(var i = 0; i < len; i++) {
        var calcPt = calcTrace[i];
        var feature = locationmode === 'geojson-id' ?
            calcPt.fOut :
            geoUtils.locationToFeature(locationmode, calcPt.loc, features);

        if(feature) {
            calcPt.geojson = feature;
            calcPt.ct = feature.properties.ct;
            calcPt._polygons = geoUtils.feature2polygons(feature);

            var bboxFeature = geoUtils.computeBbox(feature);
            lonArray.push(bboxFeature[0], bboxFeature[2]);
            latArray.push(bboxFeature[1], bboxFeature[3]);
        } else {
            calcPt.geojson = null;
        }
    }

    if(geoLayout.fitbounds === 'geojson' && locationmode === 'geojson-id') {
        var bboxGeojson = geoUtils.computeBbox(geoUtils.getTraceGeojson(trace));
        lonArray = [bboxGeojson[0], bboxGeojson[2]];
        latArray = [bboxGeojson[1], bboxGeojson[3]];
    }

    var opts = {padded: true};
    trace._extremes.lon = findExtremes(geoLayout.lonaxis._ax, lonArray, opts);
    trace._extremes.lat = findExtremes(geoLayout.lataxis._ax, latArray, opts);
}

module.exports = {
    calcGeoJSON: calcGeoJSON,
    plot: plot
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/choropleth/style.js":
/*!***************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/choropleth/style.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");
var Color = __webpack_require__(/*! ../../components/color */ "./node_modules/plotly.js/src/components/color/index.js");
var Drawing = __webpack_require__(/*! ../../components/drawing */ "./node_modules/plotly.js/src/components/drawing/index.js");
var Colorscale = __webpack_require__(/*! ../../components/colorscale */ "./node_modules/plotly.js/src/components/colorscale/index.js");

function style(gd, calcTrace) {
    if(calcTrace) styleTrace(gd, calcTrace);
}

function styleTrace(gd, calcTrace) {
    var trace = calcTrace[0].trace;
    var s = calcTrace[0].node3;
    var locs = s.selectAll('.choroplethlocation');
    var marker = trace.marker || {};
    var markerLine = marker.line || {};

    var sclFunc = Colorscale.makeColorScaleFuncFromTrace(trace);

    locs.each(function(d) {
        d3.select(this)
            .attr('fill', sclFunc(d.z))
            .call(Color.stroke, d.mlc || markerLine.color)
            .call(Drawing.dashLine, '', d.mlw || markerLine.width || 0)
            .style('opacity', marker.opacity);
    });

    Drawing.selectedPointStyle(locs, trace, gd);
}

function styleOnSelect(gd, calcTrace) {
    var s = calcTrace[0].node3;
    var trace = calcTrace[0].trace;

    if(trace.selectedpoints) {
        Drawing.selectedPointStyle(s.selectAll('.choroplethlocation'), trace, gd);
    } else {
        styleTrace(gd, calcTrace);
    }
}

module.exports = {
    style: style,
    styleOnSelect: styleOnSelect
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/contour/defaults.js":
/*!***************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/contour/defaults.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");

var handleXYZDefaults = __webpack_require__(/*! ../heatmap/xyz_defaults */ "./node_modules/plotly.js/src/traces/heatmap/xyz_defaults.js");
var handleConstraintDefaults = __webpack_require__(/*! ./constraint_defaults */ "./node_modules/plotly.js/src/traces/contour/constraint_defaults.js");
var handleContoursDefaults = __webpack_require__(/*! ./contours_defaults */ "./node_modules/plotly.js/src/traces/contour/contours_defaults.js");
var handleStyleDefaults = __webpack_require__(/*! ./style_defaults */ "./node_modules/plotly.js/src/traces/contour/style_defaults.js");
var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/contour/attributes.js");


module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
    function coerce(attr, dflt) {
        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
    }

    function coerce2(attr) {
        return Lib.coerce2(traceIn, traceOut, attributes, attr);
    }

    var len = handleXYZDefaults(traceIn, traceOut, coerce, layout);
    if(!len) {
        traceOut.visible = false;
        return;
    }

    coerce('text');
    coerce('hovertext');
    coerce('hovertemplate');
    coerce('hoverongaps');

    var isConstraint = (coerce('contours.type') === 'constraint');
    coerce('connectgaps', Lib.isArray1D(traceOut.z));

    if(isConstraint) {
        handleConstraintDefaults(traceIn, traceOut, coerce, layout, defaultColor);
    } else {
        handleContoursDefaults(traceIn, traceOut, coerce, coerce2);
        handleStyleDefaults(traceIn, traceOut, coerce, layout);
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/contour/index.js":
/*!************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/contour/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/contour/attributes.js"),
    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/contour/defaults.js"),
    calc: __webpack_require__(/*! ./calc */ "./node_modules/plotly.js/src/traces/contour/calc.js"),
    plot: __webpack_require__(/*! ./plot */ "./node_modules/plotly.js/src/traces/contour/plot.js").plot,
    style: __webpack_require__(/*! ./style */ "./node_modules/plotly.js/src/traces/contour/style.js"),
    colorbar: __webpack_require__(/*! ./colorbar */ "./node_modules/plotly.js/src/traces/contour/colorbar.js"),
    hoverPoints: __webpack_require__(/*! ./hover */ "./node_modules/plotly.js/src/traces/contour/hover.js"),

    moduleType: 'trace',
    name: 'contour',
    basePlotModule: __webpack_require__(/*! ../../plots/cartesian */ "./node_modules/plotly.js/src/plots/cartesian/index.js"),
    categories: ['cartesian', 'svg', '2dMap', 'contour', 'showLegend'],
    meta: {
        description: [
            'The data from which contour lines are computed is set in `z`.',
            'Data in `z` must be a {2D array} of numbers.',

            'Say that `z` has N rows and M columns, then by default,',
            'these N rows correspond to N y coordinates',
            '(set in `y` or auto-generated) and the M columns',
            'correspond to M x coordinates (set in `x` or auto-generated).',
            'By setting `transpose` to *true*, the above behavior is flipped.'
        ].join(' ')
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/heatmap/defaults.js":
/*!***************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/heatmap/defaults.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");

var handleXYZDefaults = __webpack_require__(/*! ./xyz_defaults */ "./node_modules/plotly.js/src/traces/heatmap/xyz_defaults.js");
var handleStyleDefaults = __webpack_require__(/*! ./style_defaults */ "./node_modules/plotly.js/src/traces/heatmap/style_defaults.js");
var colorscaleDefaults = __webpack_require__(/*! ../../components/colorscale/defaults */ "./node_modules/plotly.js/src/components/colorscale/defaults.js");
var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/heatmap/attributes.js");


module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
    function coerce(attr, dflt) {
        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
    }

    var validData = handleXYZDefaults(traceIn, traceOut, coerce, layout);
    if(!validData) {
        traceOut.visible = false;
        return;
    }

    coerce('text');
    coerce('hovertext');
    coerce('hovertemplate');

    handleStyleDefaults(traceIn, traceOut, coerce, layout);

    coerce('hoverongaps');
    coerce('connectgaps', Lib.isArray1D(traceOut.z) && (traceOut.zsmooth !== false));

    colorscaleDefaults(traceIn, traceOut, layout, coerce, {prefix: '', cLetter: 'z'});
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/heatmap/index.js":
/*!************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/heatmap/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/heatmap/attributes.js"),
    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/heatmap/defaults.js"),
    calc: __webpack_require__(/*! ./calc */ "./node_modules/plotly.js/src/traces/heatmap/calc.js"),
    plot: __webpack_require__(/*! ./plot */ "./node_modules/plotly.js/src/traces/heatmap/plot.js"),
    colorbar: __webpack_require__(/*! ./colorbar */ "./node_modules/plotly.js/src/traces/heatmap/colorbar.js"),
    style: __webpack_require__(/*! ./style */ "./node_modules/plotly.js/src/traces/heatmap/style.js"),
    hoverPoints: __webpack_require__(/*! ./hover */ "./node_modules/plotly.js/src/traces/heatmap/hover.js"),

    moduleType: 'trace',
    name: 'heatmap',
    basePlotModule: __webpack_require__(/*! ../../plots/cartesian */ "./node_modules/plotly.js/src/plots/cartesian/index.js"),
    categories: ['cartesian', 'svg', '2dMap', 'showLegend'],
    meta: {
        description: [
            'The data that describes the heatmap value-to-color mapping',
            'is set in `z`.',
            'Data in `z` can either be a {2D array} of values (ragged or not)',
            'or a 1D array of values.',

            'In the case where `z` is a {2D array},',
            'say that `z` has N rows and M columns.',
            'Then, by default, the resulting heatmap will have N partitions along',
            'the y axis and M partitions along the x axis.',
            'In other words, the i-th row/ j-th column cell in `z`',
            'is mapped to the i-th partition of the y axis',
            '(starting from the bottom of the plot) and the j-th partition',
            'of the x-axis (starting from the left of the plot).',
            'This behavior can be flipped by using `transpose`.',
            'Moreover, `x` (`y`) can be provided with M or M+1 (N or N+1) elements.',
            'If M (N), then the coordinates correspond to the center of the',
            'heatmap cells and the cells have equal width.',
            'If M+1 (N+1), then the coordinates correspond to the edges of the',
            'heatmap cells.',

            'In the case where `z` is a 1D {array}, the x and y coordinates must be',
            'provided in `x` and `y` respectively to form data triplets.'
        ].join(' ')
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/heatmap/style_defaults.js":
/*!*********************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/heatmap/style_defaults.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




module.exports = function handleStyleDefaults(traceIn, traceOut, coerce) {
    var zsmooth = coerce('zsmooth');
    if(zsmooth === false) {
        // ensure that xgap and ygap are coerced only when zsmooth allows them to have an effect.
        coerce('xgap');
        coerce('ygap');
    }

    coerce('zhoverformat');
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/heatmapgl/attributes.js":
/*!*******************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/heatmapgl/attributes.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var heatmapAttrs = __webpack_require__(/*! ../heatmap/attributes */ "./node_modules/plotly.js/src/traces/heatmap/attributes.js");
var colorScaleAttrs = __webpack_require__(/*! ../../components/colorscale/attributes */ "./node_modules/plotly.js/src/components/colorscale/attributes.js");

var extendFlat = __webpack_require__(/*! ../../lib/extend */ "./node_modules/plotly.js/src/lib/extend.js").extendFlat;
var overrideAll = __webpack_require__(/*! ../../plot_api/edit_types */ "./node_modules/plotly.js/src/plot_api/edit_types.js").overrideAll;

var commonList = [
    'z',
    'x', 'x0', 'dx',
    'y', 'y0', 'dy',
    'text', 'transpose',
    'xtype', 'ytype'
];

var attrs = {};

for(var i = 0; i < commonList.length; i++) {
    var k = commonList[i];
    attrs[k] = heatmapAttrs[k];
}

extendFlat(
    attrs,
    colorScaleAttrs('', {cLetter: 'z', autoColorDflt: false})
);

module.exports = overrideAll(attrs, 'calc', 'nested');


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/heatmapgl/convert.js":
/*!****************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/heatmapgl/convert.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var createHeatmap2D = __webpack_require__(/*! gl-heatmap2d */ "./node_modules/gl-heatmap2d/heatmap.js");
var Axes = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js");
var str2RGBArray = __webpack_require__(/*! ../../lib/str2rgbarray */ "./node_modules/plotly.js/src/lib/str2rgbarray.js");


function Heatmap(scene, uid) {
    this.scene = scene;
    this.uid = uid;
    this.type = 'heatmapgl';

    this.name = '';
    this.hoverinfo = 'all';

    this.xData = [];
    this.yData = [];
    this.zData = [];
    this.textLabels = [];

    this.idToIndex = [];
    this.bounds = [0, 0, 0, 0];

    this.options = {
        z: [],
        x: [],
        y: [],
        shape: [0, 0],
        colorLevels: [0],
        colorValues: [0, 0, 0, 1]
    };

    this.heatmap = createHeatmap2D(scene.glplot, this.options);
    this.heatmap._trace = this;
}

var proto = Heatmap.prototype;

proto.handlePick = function(pickResult) {
    var options = this.options;
    var shape = options.shape;
    var index = pickResult.pointId;
    var xIndex = index % shape[0];
    var yIndex = Math.floor(index / shape[0]);
    var zIndex = index;

    return {
        trace: this,
        dataCoord: pickResult.dataCoord,
        traceCoord: [
            options.x[xIndex],
            options.y[yIndex],
            options.z[zIndex]
        ],
        textLabel: this.textLabels[index],
        name: this.name,
        pointIndex: [yIndex, xIndex],
        hoverinfo: this.hoverinfo
    };
};

proto.update = function(fullTrace, calcTrace) {
    var calcPt = calcTrace[0];

    this.index = fullTrace.index;
    this.name = fullTrace.name;
    this.hoverinfo = fullTrace.hoverinfo;

    // convert z from 2D -> 1D
    var z = calcPt.z;
    this.options.z = [].concat.apply([], z);

    var rowLen = z[0].length;
    var colLen = z.length;
    this.options.shape = [rowLen, colLen];

    this.options.x = calcPt.x;
    this.options.y = calcPt.y;

    var colorOptions = convertColorscale(fullTrace);
    this.options.colorLevels = colorOptions.colorLevels;
    this.options.colorValues = colorOptions.colorValues;

    // convert text from 2D -> 1D
    this.textLabels = [].concat.apply([], fullTrace.text);

    this.heatmap.update(this.options);

    var xa = this.scene.xaxis;
    var ya = this.scene.yaxis;
    fullTrace._extremes[xa._id] = Axes.findExtremes(xa, calcPt.x);
    fullTrace._extremes[ya._id] = Axes.findExtremes(ya, calcPt.y);
};

proto.dispose = function() {
    this.heatmap.dispose();
};

function convertColorscale(fullTrace) {
    var scl = fullTrace.colorscale;
    var zmin = fullTrace.zmin;
    var zmax = fullTrace.zmax;

    var N = scl.length;
    var domain = new Array(N);
    var range = new Array(4 * N);

    for(var i = 0; i < N; i++) {
        var si = scl[i];
        var color = str2RGBArray(si[1]);

        domain[i] = zmin + si[0] * (zmax - zmin);

        for(var j = 0; j < 4; j++) {
            range[(4 * i) + j] = color[j];
        }
    }

    return {
        colorLevels: domain,
        colorValues: range
    };
}

function createHeatmap(scene, fullTrace, calcTrace) {
    var plot = new Heatmap(scene, fullTrace.uid);
    plot.update(fullTrace, calcTrace);
    return plot;
}

module.exports = createHeatmap;


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/heatmapgl/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/heatmapgl/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/heatmapgl/attributes.js"),
    supplyDefaults: __webpack_require__(/*! ../heatmap/defaults */ "./node_modules/plotly.js/src/traces/heatmap/defaults.js"),
    colorbar: __webpack_require__(/*! ../heatmap/colorbar */ "./node_modules/plotly.js/src/traces/heatmap/colorbar.js"),

    calc: __webpack_require__(/*! ../heatmap/calc */ "./node_modules/plotly.js/src/traces/heatmap/calc.js"),
    plot: __webpack_require__(/*! ./convert */ "./node_modules/plotly.js/src/traces/heatmapgl/convert.js"),

    moduleType: 'trace',
    name: 'heatmapgl',
    basePlotModule: __webpack_require__(/*! ../../plots/gl2d */ "./node_modules/plotly.js/src/plots/gl2d/index.js"),
    categories: ['gl', 'gl2d', '2dMap'],
    meta: {
        description: [
            'WebGL version of the heatmap trace type.'
        ].join(' ')
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/histogram2d/defaults.js":
/*!*******************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/histogram2d/defaults.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");

var handleSampleDefaults = __webpack_require__(/*! ./sample_defaults */ "./node_modules/plotly.js/src/traces/histogram2d/sample_defaults.js");
var handleStyleDefaults = __webpack_require__(/*! ../heatmap/style_defaults */ "./node_modules/plotly.js/src/traces/heatmap/style_defaults.js");
var colorscaleDefaults = __webpack_require__(/*! ../../components/colorscale/defaults */ "./node_modules/plotly.js/src/components/colorscale/defaults.js");
var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/histogram2d/attributes.js");


module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
    function coerce(attr, dflt) {
        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
    }

    handleSampleDefaults(traceIn, traceOut, coerce, layout);
    if(traceOut.visible === false) return;

    handleStyleDefaults(traceIn, traceOut, coerce, layout);
    colorscaleDefaults(traceIn, traceOut, layout, coerce, {prefix: '', cLetter: 'z'});
    coerce('hovertemplate');
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/histogram2d/hover.js":
/*!****************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/histogram2d/hover.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var heatmapHover = __webpack_require__(/*! ../heatmap/hover */ "./node_modules/plotly.js/src/traces/heatmap/hover.js");
var hoverLabelText = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js").hoverLabelText;

module.exports = function hoverPoints(pointData, xval, yval, hovermode, hoverLayer, contour) {
    var pts = heatmapHover(pointData, xval, yval, hovermode, hoverLayer, contour);

    if(!pts) return;

    pointData = pts[0];
    var indices = pointData.index;
    var ny = indices[0];
    var nx = indices[1];
    var cd0 = pointData.cd[0];
    var xRange = cd0.xRanges[nx];
    var yRange = cd0.yRanges[ny];

    pointData.xLabel = hoverLabelText(pointData.xa, xRange[0], xRange[1]);
    pointData.yLabel = hoverLabelText(pointData.ya, yRange[0], yRange[1]);

    return pts;
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/histogram2d/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/histogram2d/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/histogram2d/attributes.js"),
    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/histogram2d/defaults.js"),
    crossTraceDefaults: __webpack_require__(/*! ../histogram/cross_trace_defaults */ "./node_modules/plotly.js/src/traces/histogram/cross_trace_defaults.js"),
    calc: __webpack_require__(/*! ../heatmap/calc */ "./node_modules/plotly.js/src/traces/heatmap/calc.js"),
    plot: __webpack_require__(/*! ../heatmap/plot */ "./node_modules/plotly.js/src/traces/heatmap/plot.js"),
    layerName: 'heatmaplayer',
    colorbar: __webpack_require__(/*! ../heatmap/colorbar */ "./node_modules/plotly.js/src/traces/heatmap/colorbar.js"),
    style: __webpack_require__(/*! ../heatmap/style */ "./node_modules/plotly.js/src/traces/heatmap/style.js"),
    hoverPoints: __webpack_require__(/*! ./hover */ "./node_modules/plotly.js/src/traces/histogram2d/hover.js"),
    eventData: __webpack_require__(/*! ../histogram/event_data */ "./node_modules/plotly.js/src/traces/histogram/event_data.js"),

    moduleType: 'trace',
    name: 'histogram2d',
    basePlotModule: __webpack_require__(/*! ../../plots/cartesian */ "./node_modules/plotly.js/src/plots/cartesian/index.js"),
    categories: ['cartesian', 'svg', '2dMap', 'histogram', 'showLegend'],
    meta: {
        hrName: 'histogram_2d',
        description: [
            'The sample data from which statistics are computed is set in `x`',
            'and `y` (where `x` and `y` represent marginal distributions,',
            'binning is set in `xbins` and `ybins` in this case)',
            'or `z` (where `z` represent the 2D distribution and binning set,',
            'binning is set by `x` and `y` in this case).',
            'The resulting distribution is visualized as a heatmap.'
        ].join(' ')
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/isosurface/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/isosurface/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/isosurface/attributes.js"),
    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/isosurface/defaults.js").supplyDefaults,
    calc: __webpack_require__(/*! ./calc */ "./node_modules/plotly.js/src/traces/isosurface/calc.js"),
    colorbar: {
        min: 'cmin',
        max: 'cmax'
    },
    plot: __webpack_require__(/*! ./convert */ "./node_modules/plotly.js/src/traces/isosurface/convert.js").createIsosurfaceTrace,

    moduleType: 'trace',
    name: 'isosurface',
    basePlotModule: __webpack_require__(/*! ../../plots/gl3d */ "./node_modules/plotly.js/src/plots/gl3d/index.js"),
    categories: ['gl3d', 'showLegend'],
    meta: {
        description: [
            'Draws isosurfaces between iso-min and iso-max values with coordinates given by',
            'four 1-dimensional arrays containing the `value`, `x`, `y` and `z` of every vertex',
            'of a uniform or non-uniform 3-D grid. Horizontal or vertical slices, caps as well as',
            'spaceframe between iso-min and iso-max values could also be drawn using this trace.'
        ].join(' ')
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/ohlc/defaults.js":
/*!************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/ohlc/defaults.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var handleOHLC = __webpack_require__(/*! ./ohlc_defaults */ "./node_modules/plotly.js/src/traces/ohlc/ohlc_defaults.js");
var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/ohlc/attributes.js");

module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
    function coerce(attr, dflt) {
        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
    }

    var len = handleOHLC(traceIn, traceOut, coerce, layout);
    if(!len) {
        traceOut.visible = false;
        return;
    }

    coerce('line.width');
    coerce('line.dash');

    handleDirection(traceIn, traceOut, coerce, 'increasing');
    handleDirection(traceIn, traceOut, coerce, 'decreasing');

    coerce('text');
    coerce('hovertext');
    coerce('tickwidth');

    layout._requestRangeslider[traceOut.xaxis] = true;
};

function handleDirection(traceIn, traceOut, coerce, direction) {
    coerce(direction + '.line.color');
    coerce(direction + '.line.width', traceOut.line.width);
    coerce(direction + '.line.dash', traceOut.line.dash);
}


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/ohlc/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/ohlc/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    moduleType: 'trace',
    name: 'ohlc',
    basePlotModule: __webpack_require__(/*! ../../plots/cartesian */ "./node_modules/plotly.js/src/plots/cartesian/index.js"),
    categories: ['cartesian', 'svg', 'showLegend'],
    meta: {
        description: [
            'The ohlc (short for Open-High-Low-Close) is a style of financial chart describing',
            'open, high, low and close for a given `x` coordinate (most likely time).',

            'The tip of the lines represent the `low` and `high` values and',
            'the horizontal segments represent the `open` and `close` values.',

            'Sample points where the close value is higher (lower) then the open',
            'value are called increasing (decreasing).',

            'By default, increasing items are drawn in green whereas',
            'decreasing are drawn in red.'
        ].join(' ')
    },

    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/ohlc/attributes.js"),
    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/ohlc/defaults.js"),
    calc: __webpack_require__(/*! ./calc */ "./node_modules/plotly.js/src/traces/ohlc/calc.js").calc,
    plot: __webpack_require__(/*! ./plot */ "./node_modules/plotly.js/src/traces/ohlc/plot.js"),
    style: __webpack_require__(/*! ./style */ "./node_modules/plotly.js/src/traces/ohlc/style.js"),
    hoverPoints: __webpack_require__(/*! ./hover */ "./node_modules/plotly.js/src/traces/ohlc/hover.js").hoverPoints,
    selectPoints: __webpack_require__(/*! ./select */ "./node_modules/plotly.js/src/traces/ohlc/select.js")
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/ohlc/plot.js":
/*!********************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/ohlc/plot.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");

var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");

module.exports = function plot(gd, plotinfo, cdOHLC, ohlcLayer) {
    var ya = plotinfo.yaxis;
    var xa = plotinfo.xaxis;
    var posHasRangeBreaks = !!xa.rangebreaks;

    Lib.makeTraceGroups(ohlcLayer, cdOHLC, 'trace ohlc').each(function(cd) {
        var plotGroup = d3.select(this);
        var cd0 = cd[0];
        var t = cd0.t;
        var trace = cd0.trace;

        if(trace.visible !== true || t.empty) {
            plotGroup.remove();
            return;
        }

        var tickLen = t.tickLen;

        var paths = plotGroup.selectAll('path').data(Lib.identity);

        paths.enter().append('path');

        paths.exit().remove();

        paths.attr('d', function(d) {
            if(d.empty) return 'M0,0Z';

            var xo = xa.c2p(d.pos - tickLen, true);
            var xc = xa.c2p(d.pos + tickLen, true);
            var x = posHasRangeBreaks ? (xo + xc) / 2 : xa.c2p(d.pos, true);

            var yo = ya.c2p(d.o, true);
            var yh = ya.c2p(d.h, true);
            var yl = ya.c2p(d.l, true);
            var yc = ya.c2p(d.c, true);

            return 'M' + xo + ',' + yo + 'H' + x +
                'M' + x + ',' + yh + 'V' + yl +
                'M' + xc + ',' + yc + 'H' + x;
        });
    });
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/ohlc/style.js":
/*!*********************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/ohlc/style.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");
var Drawing = __webpack_require__(/*! ../../components/drawing */ "./node_modules/plotly.js/src/components/drawing/index.js");
var Color = __webpack_require__(/*! ../../components/color */ "./node_modules/plotly.js/src/components/color/index.js");

module.exports = function style(gd, cd, sel) {
    var s = sel ? sel : d3.select(gd).selectAll('g.ohlclayer').selectAll('g.trace');

    s.style('opacity', function(d) {
        return d[0].trace.opacity;
    });

    s.each(function(d) {
        var trace = d[0].trace;

        d3.select(this).selectAll('path').each(function(di) {
            if(di.empty) return;

            var dirLine = trace[di.dir].line;
            d3.select(this)
                .style('fill', 'none')
                .call(Color.stroke, dirLine.color)
                .call(Drawing.dashLine, dirLine.dash, dirLine.width)
                // TODO: custom selection style for OHLC
                .style('opacity', trace.selectedpoints && !di.selected ? 0.3 : 1);
        });
    });
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/pie/base_plot.js":
/*!************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/pie/base_plot.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var plots = __webpack_require__(/*! ../../plots/plots */ "./node_modules/plotly.js/src/plots/plots.js");

exports.name = 'pie';

exports.plot = function(gd, traces, transitionOpts, makeOnCompleteCallback) {
    plots.plotBasePlot(exports.name, gd, traces, transitionOpts, makeOnCompleteCallback);
};

exports.clean = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
    plots.cleanBasePlot(exports.name, newFullData, newFullLayout, oldFullData, oldFullLayout);
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/pie/index.js":
/*!********************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/pie/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/pie/attributes.js"),
    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/pie/defaults.js").supplyDefaults,
    supplyLayoutDefaults: __webpack_require__(/*! ./layout_defaults */ "./node_modules/plotly.js/src/traces/pie/layout_defaults.js"),
    layoutAttributes: __webpack_require__(/*! ./layout_attributes */ "./node_modules/plotly.js/src/traces/pie/layout_attributes.js"),

    calc: __webpack_require__(/*! ./calc */ "./node_modules/plotly.js/src/traces/pie/calc.js").calc,
    crossTraceCalc: __webpack_require__(/*! ./calc */ "./node_modules/plotly.js/src/traces/pie/calc.js").crossTraceCalc,

    plot: __webpack_require__(/*! ./plot */ "./node_modules/plotly.js/src/traces/pie/plot.js").plot,
    style: __webpack_require__(/*! ./style */ "./node_modules/plotly.js/src/traces/pie/style.js"),
    styleOne: __webpack_require__(/*! ./style_one */ "./node_modules/plotly.js/src/traces/pie/style_one.js"),

    moduleType: 'trace',
    name: 'pie',
    basePlotModule: __webpack_require__(/*! ./base_plot */ "./node_modules/plotly.js/src/traces/pie/base_plot.js"),
    categories: ['pie-like', 'pie', 'showLegend'],
    meta: {
        description: [
            'A data visualized by the sectors of the pie is set in `values`.',
            'The sector labels are set in `labels`.',
            'The sector colors are set in `marker.colors`'
        ].join(' ')
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/pie/layout_defaults.js":
/*!******************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/pie/layout_defaults.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");

var layoutAttributes = __webpack_require__(/*! ./layout_attributes */ "./node_modules/plotly.js/src/traces/pie/layout_attributes.js");

module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
    function coerce(attr, dflt) {
        return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
    }

    coerce('hiddenlabels');
    coerce('piecolorway', layoutOut.colorway);
    coerce('extendpiecolors');
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/pie/style.js":
/*!********************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/pie/style.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var d3 = __webpack_require__(/*! d3 */ "./node_modules/d3/d3.js");

var styleOne = __webpack_require__(/*! ./style_one */ "./node_modules/plotly.js/src/traces/pie/style_one.js");
var resizeText = __webpack_require__(/*! ../bar/uniform_text */ "./node_modules/plotly.js/src/traces/bar/uniform_text.js").resizeText;

module.exports = function style(gd) {
    var s = gd._fullLayout._pielayer.selectAll('.trace');
    resizeText(gd, s, 'pie');

    s.each(function(cd) {
        var cd0 = cd[0];
        var trace = cd0.trace;
        var traceSelection = d3.select(this);

        traceSelection.style({opacity: trace.opacity});

        traceSelection.selectAll('path.surface').each(function(pt) {
            d3.select(this).call(styleOne, pt, trace);
        });
    });
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/scatterpolar/calc.js":
/*!****************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/scatterpolar/calc.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/




var isNumeric = __webpack_require__(/*! fast-isnumeric */ "./node_modules/fast-isnumeric/index.js");
var BADNUM = __webpack_require__(/*! ../../constants/numerical */ "./node_modules/plotly.js/src/constants/numerical.js").BADNUM;

var Axes = __webpack_require__(/*! ../../plots/cartesian/axes */ "./node_modules/plotly.js/src/plots/cartesian/axes.js");

var calcColorscale = __webpack_require__(/*! ../scatter/colorscale_calc */ "./node_modules/plotly.js/src/traces/scatter/colorscale_calc.js");
var arraysToCalcdata = __webpack_require__(/*! ../scatter/arrays_to_calcdata */ "./node_modules/plotly.js/src/traces/scatter/arrays_to_calcdata.js");
var calcSelection = __webpack_require__(/*! ../scatter/calc_selection */ "./node_modules/plotly.js/src/traces/scatter/calc_selection.js");
var calcMarkerSize = __webpack_require__(/*! ../scatter/calc */ "./node_modules/plotly.js/src/traces/scatter/calc.js").calcMarkerSize;

module.exports = function calc(gd, trace) {
    var fullLayout = gd._fullLayout;
    var subplotId = trace.subplot;
    var radialAxis = fullLayout[subplotId].radialaxis;
    var angularAxis = fullLayout[subplotId].angularaxis;
    var rArray = radialAxis.makeCalcdata(trace, 'r');
    var thetaArray = angularAxis.makeCalcdata(trace, 'theta');
    var len = trace._length;
    var cd = new Array(len);

    for(var i = 0; i < len; i++) {
        var r = rArray[i];
        var theta = thetaArray[i];
        var cdi = cd[i] = {};

        if(isNumeric(r) && isNumeric(theta)) {
            cdi.r = r;
            cdi.theta = theta;
        } else {
            cdi.r = BADNUM;
        }
    }

    var ppad = calcMarkerSize(trace, len);
    trace._extremes.x = Axes.findExtremes(radialAxis, rArray, {ppad: ppad});

    calcColorscale(gd, trace);
    arraysToCalcdata(cd, trace);
    calcSelection(cd, trace);

    return cd;
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/scatterpolar/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/scatterpolar/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    moduleType: 'trace',
    name: 'scatterpolar',
    basePlotModule: __webpack_require__(/*! ../../plots/polar */ "./node_modules/plotly.js/src/plots/polar/index.js"),
    categories: ['polar', 'symbols', 'showLegend', 'scatter-like'],

    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/scatterpolar/attributes.js"),
    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/scatterpolar/defaults.js").supplyDefaults,
    colorbar: __webpack_require__(/*! ../scatter/marker_colorbar */ "./node_modules/plotly.js/src/traces/scatter/marker_colorbar.js"),
    formatLabels: __webpack_require__(/*! ./format_labels */ "./node_modules/plotly.js/src/traces/scatterpolar/format_labels.js"),
    calc: __webpack_require__(/*! ./calc */ "./node_modules/plotly.js/src/traces/scatterpolar/calc.js"),
    plot: __webpack_require__(/*! ./plot */ "./node_modules/plotly.js/src/traces/scatterpolar/plot.js"),
    style: __webpack_require__(/*! ../scatter/style */ "./node_modules/plotly.js/src/traces/scatter/style.js").style,
    styleOnSelect: __webpack_require__(/*! ../scatter/style */ "./node_modules/plotly.js/src/traces/scatter/style.js").styleOnSelect,
    hoverPoints: __webpack_require__(/*! ./hover */ "./node_modules/plotly.js/src/traces/scatterpolar/hover.js").hoverPoints,
    selectPoints: __webpack_require__(/*! ../scatter/select */ "./node_modules/plotly.js/src/traces/scatter/select.js"),

    meta: {
        hrName: 'scatter_polar',
        description: [
            'The scatterpolar trace type encompasses line charts, scatter charts, text charts, and bubble charts',
            'in polar coordinates.',
            'The data visualized as scatter point or lines is set in',
            '`r` (radial) and `theta` (angular) coordinates',
            'Text (appearing either on the chart or on hover only) is via `text`.',
            'Bubble charts are achieved by setting `marker.size` and/or `marker.color`',
            'to numerical arrays.'
        ].join(' ')
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/scatterpolar/plot.js":
/*!****************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/scatterpolar/plot.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var scatterPlot = __webpack_require__(/*! ../scatter/plot */ "./node_modules/plotly.js/src/traces/scatter/plot.js");
var BADNUM = __webpack_require__(/*! ../../constants/numerical */ "./node_modules/plotly.js/src/constants/numerical.js").BADNUM;

module.exports = function plot(gd, subplot, moduleCalcData) {
    var mlayer = subplot.layers.frontplot.select('g.scatterlayer');

    var plotinfo = {
        xaxis: subplot.xaxis,
        yaxis: subplot.yaxis,
        plot: subplot.framework,
        layerClipId: subplot._hasClipOnAxisFalse ? subplot.clipIds.forTraces : null
    };

    var radialAxis = subplot.radialAxis;
    var angularAxis = subplot.angularAxis;

    // convert:
    // 'c' (r,theta) -> 'geometric' (r,theta) -> (x,y)
    for(var i = 0; i < moduleCalcData.length; i++) {
        var cdi = moduleCalcData[i];

        for(var j = 0; j < cdi.length; j++) {
            var cd = cdi[j];
            var r = cd.r;

            if(r === BADNUM) {
                cd.x = cd.y = BADNUM;
            } else {
                var rg = radialAxis.c2g(r);
                var thetag = angularAxis.c2g(cd.theta);
                cd.x = rg * Math.cos(thetag);
                cd.y = rg * Math.sin(thetag);
            }
        }
    }

    scatterPlot(gd, plotinfo, moduleCalcData, mlayer);
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/sunburst/base_plot.js":
/*!*****************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/sunburst/base_plot.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var plots = __webpack_require__(/*! ../../plots/plots */ "./node_modules/plotly.js/src/plots/plots.js");

exports.name = 'sunburst';

exports.plot = function(gd, traces, transitionOpts, makeOnCompleteCallback) {
    plots.plotBasePlot(exports.name, gd, traces, transitionOpts, makeOnCompleteCallback);
};

exports.clean = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
    plots.cleanBasePlot(exports.name, newFullData, newFullLayout, oldFullData, oldFullLayout);
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/sunburst/defaults.js":
/*!****************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/sunburst/defaults.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/sunburst/attributes.js");
var handleDomainDefaults = __webpack_require__(/*! ../../plots/domain */ "./node_modules/plotly.js/src/plots/domain.js").defaults;
var handleText = __webpack_require__(/*! ../bar/defaults */ "./node_modules/plotly.js/src/traces/bar/defaults.js").handleText;

var Colorscale = __webpack_require__(/*! ../../components/colorscale */ "./node_modules/plotly.js/src/components/colorscale/index.js");
var hasColorscale = Colorscale.hasColorscale;
var colorscaleDefaults = Colorscale.handleDefaults;

module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
    function coerce(attr, dflt) {
        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
    }

    var labels = coerce('labels');
    var parents = coerce('parents');

    if(!labels || !labels.length || !parents || !parents.length) {
        traceOut.visible = false;
        return;
    }

    var vals = coerce('values');
    if(vals && vals.length) {
        coerce('branchvalues');
    } else {
        coerce('count');
    }

    coerce('level');
    coerce('maxdepth');

    var lineWidth = coerce('marker.line.width');
    if(lineWidth) coerce('marker.line.color', layout.paper_bgcolor);

    coerce('marker.colors');
    var withColorscale = traceOut._hasColorscale = (
        hasColorscale(traceIn, 'marker', 'colors') ||
        (traceIn.marker || {}).coloraxis // N.B. special logic to consider "values" colorscales
    );
    if(withColorscale) {
        colorscaleDefaults(traceIn, traceOut, layout, coerce, {prefix: 'marker.', cLetter: 'c'});
    }

    coerce('leaf.opacity', withColorscale ? 1 : 0.7);

    var text = coerce('text');
    coerce('texttemplate');
    if(!traceOut.texttemplate) coerce('textinfo', Array.isArray(text) ? 'text+label' : 'label');

    coerce('hovertext');
    coerce('hovertemplate');

    var textposition = 'auto';
    handleText(traceIn, traceOut, layout, coerce, textposition, {
        moduleHasSelected: false,
        moduleHasUnselected: false,
        moduleHasConstrain: false,
        moduleHasCliponaxis: false,
        moduleHasTextangle: false,
        moduleHasInsideanchor: false
    });

    coerce('insidetextorientation');

    handleDomainDefaults(traceOut, layout, coerce);

    // do not support transforms for now
    traceOut._length = null;
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/sunburst/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/sunburst/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    moduleType: 'trace',
    name: 'sunburst',
    basePlotModule: __webpack_require__(/*! ./base_plot */ "./node_modules/plotly.js/src/traces/sunburst/base_plot.js"),
    categories: [],
    animatable: true,

    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/sunburst/attributes.js"),
    layoutAttributes: __webpack_require__(/*! ./layout_attributes */ "./node_modules/plotly.js/src/traces/sunburst/layout_attributes.js"),
    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/sunburst/defaults.js"),
    supplyLayoutDefaults: __webpack_require__(/*! ./layout_defaults */ "./node_modules/plotly.js/src/traces/sunburst/layout_defaults.js"),

    calc: __webpack_require__(/*! ./calc */ "./node_modules/plotly.js/src/traces/sunburst/calc.js").calc,
    crossTraceCalc: __webpack_require__(/*! ./calc */ "./node_modules/plotly.js/src/traces/sunburst/calc.js").crossTraceCalc,

    plot: __webpack_require__(/*! ./plot */ "./node_modules/plotly.js/src/traces/sunburst/plot.js").plot,
    style: __webpack_require__(/*! ./style */ "./node_modules/plotly.js/src/traces/sunburst/style.js").style,

    colorbar: __webpack_require__(/*! ../scatter/marker_colorbar */ "./node_modules/plotly.js/src/traces/scatter/marker_colorbar.js"),

    meta: {
        description: [
            'Visualize hierarchal data spanning outward radially from root to leaves.',
            'The sunburst sectors are determined by the entries in *labels* or *ids*',
            'and in *parents*.'
        ].join(' ')
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/sunburst/layout_attributes.js":
/*!*************************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/sunburst/layout_attributes.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    sunburstcolorway: {
        valType: 'colorlist',
        role: 'style',
        editType: 'calc',
        description: [
            'Sets the default sunburst slice colors. Defaults to the main',
            '`colorway` used for trace colors. If you specify a new',
            'list here it can still be extended with lighter and darker',
            'colors, see `extendsunburstcolors`.'
        ].join(' ')
    },
    extendsunburstcolors: {
        valType: 'boolean',
        dflt: true,
        role: 'style',
        editType: 'calc',
        description: [
            'If `true`, the sunburst slice colors (whether given by `sunburstcolorway` or',
            'inherited from `colorway`) will be extended to three times its',
            'original length by first repeating every color 20% lighter then',
            'each color 20% darker. This is intended to reduce the likelihood',
            'of reusing the same color when you have many slices, but you can',
            'set `false` to disable.',
            'Colors provided in the trace, using `marker.colors`, are never',
            'extended.'
        ].join(' ')
    }
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/sunburst/layout_defaults.js":
/*!***********************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/sunburst/layout_defaults.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var layoutAttributes = __webpack_require__(/*! ./layout_attributes */ "./node_modules/plotly.js/src/traces/sunburst/layout_attributes.js");

module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
    function coerce(attr, dflt) {
        return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
    }
    coerce('sunburstcolorway', layoutOut.colorway);
    coerce('extendsunburstcolors');
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/volume/attributes.js":
/*!****************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/volume/attributes.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var colorScaleAttrs = __webpack_require__(/*! ../../components/colorscale/attributes */ "./node_modules/plotly.js/src/components/colorscale/attributes.js");
var isosurfaceAttrs = __webpack_require__(/*! ../isosurface/attributes */ "./node_modules/plotly.js/src/traces/isosurface/attributes.js");
var surfaceAttrs = __webpack_require__(/*! ../surface/attributes */ "./node_modules/plotly.js/src/traces/surface/attributes.js");
var baseAttrs = __webpack_require__(/*! ../../plots/attributes */ "./node_modules/plotly.js/src/plots/attributes.js");

var extendFlat = __webpack_require__(/*! ../../lib/extend */ "./node_modules/plotly.js/src/lib/extend.js").extendFlat;
var overrideAll = __webpack_require__(/*! ../../plot_api/edit_types */ "./node_modules/plotly.js/src/plot_api/edit_types.js").overrideAll;

var attrs = module.exports = overrideAll(extendFlat({
    x: isosurfaceAttrs.x,
    y: isosurfaceAttrs.y,
    z: isosurfaceAttrs.z,
    value: isosurfaceAttrs.value,
    isomin: isosurfaceAttrs.isomin,
    isomax: isosurfaceAttrs.isomax,
    surface: isosurfaceAttrs.surface,
    spaceframe: {
        show: {
            valType: 'boolean',
            role: 'info',
            dflt: false,
            description: [
                'Displays/hides tetrahedron shapes between minimum and',
                'maximum iso-values. Often useful when either caps or',
                'surfaces are disabled or filled with values less than 1.'
            ].join(' ')
        },
        fill: {
            valType: 'number',
            role: 'style',
            min: 0,
            max: 1,
            dflt: 1,
            description: [
                'Sets the fill ratio of the `spaceframe` elements. The default fill value',
                'is 1 meaning that they are entirely shaded. Applying a `fill` ratio less',
                'than one would allow the creation of openings parallel to the edges.'
            ].join(' ')
        }
    },

    slices: isosurfaceAttrs.slices,
    caps: isosurfaceAttrs.caps,
    text: isosurfaceAttrs.text,
    hovertext: isosurfaceAttrs.hovertext,
    hovertemplate: isosurfaceAttrs.hovertemplate
},

colorScaleAttrs('', {
    colorAttr: '`value`',
    showScaleDflt: true,
    editTypeOverride: 'calc'
}), {

    colorbar: isosurfaceAttrs.colorbar,
    opacity: isosurfaceAttrs.opacity,
    opacityscale: surfaceAttrs.opacityscale,

    lightposition: isosurfaceAttrs.lightposition,
    lighting: isosurfaceAttrs.lighting,
    flatshading: isosurfaceAttrs.flatshading,
    contour: isosurfaceAttrs.contour,

    hoverinfo: extendFlat({}, baseAttrs.hoverinfo),
    showlegend: extendFlat({}, baseAttrs.showlegend, {dflt: false})
}), 'calc', 'nested');

attrs.x.editType = attrs.y.editType = attrs.z.editType = attrs.value.editType = 'calc+clearAxisTypes';
attrs.transforms = undefined;


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/volume/convert.js":
/*!*************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/volume/convert.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var createMesh = __webpack_require__(/*! gl-mesh3d */ "./node_modules/gl-mesh3d/mesh.js");

var parseColorScale = __webpack_require__(/*! ../../lib/gl_format_color */ "./node_modules/plotly.js/src/lib/gl_format_color.js").parseColorScale;
var str2RgbaArray = __webpack_require__(/*! ../../lib/str2rgbarray */ "./node_modules/plotly.js/src/lib/str2rgbarray.js");
var extractOpts = __webpack_require__(/*! ../../components/colorscale */ "./node_modules/plotly.js/src/components/colorscale/index.js").extractOpts;
var zip3 = __webpack_require__(/*! ../../plots/gl3d/zip3 */ "./node_modules/plotly.js/src/plots/gl3d/zip3.js");

var findNearestOnAxis = __webpack_require__(/*! ../isosurface/convert */ "./node_modules/plotly.js/src/traces/isosurface/convert.js").findNearestOnAxis;
var generateIsoMeshes = __webpack_require__(/*! ../isosurface/convert */ "./node_modules/plotly.js/src/traces/isosurface/convert.js").generateIsoMeshes;

function VolumeTrace(scene, mesh, uid) {
    this.scene = scene;
    this.uid = uid;
    this.mesh = mesh;
    this.name = '';
    this.data = null;
    this.showContour = false;
}

var proto = VolumeTrace.prototype;

proto.handlePick = function(selection) {
    if(selection.object === this.mesh) {
        var rawId = selection.data.index;

        var x = this.data._meshX[rawId];
        var y = this.data._meshY[rawId];
        var z = this.data._meshZ[rawId];

        var height = this.data._Ys.length;
        var depth = this.data._Zs.length;

        var i = findNearestOnAxis(x, this.data._Xs).id;
        var j = findNearestOnAxis(y, this.data._Ys).id;
        var k = findNearestOnAxis(z, this.data._Zs).id;

        var selectIndex = selection.index = k + depth * j + depth * height * i;

        selection.traceCoordinate = [
            this.data._meshX[selectIndex],
            this.data._meshY[selectIndex],
            this.data._meshZ[selectIndex],
            this.data._value[selectIndex]
        ];

        var text = this.data.hovertext || this.data.text;
        if(Array.isArray(text) && text[selectIndex] !== undefined) {
            selection.textLabel = text[selectIndex];
        } else if(text) {
            selection.textLabel = text;
        }

        return true;
    }
};

proto.update = function(data) {
    var scene = this.scene;
    var layout = scene.fullSceneLayout;

    this.data = generateIsoMeshes(data);

    // Unpack position data
    function toDataCoords(axis, coord, scale, calendar) {
        return coord.map(function(x) {
            return axis.d2l(x, 0, calendar) * scale;
        });
    }

    var positions = zip3(
        toDataCoords(layout.xaxis, data._meshX, scene.dataScale[0], data.xcalendar),
        toDataCoords(layout.yaxis, data._meshY, scene.dataScale[1], data.ycalendar),
        toDataCoords(layout.zaxis, data._meshZ, scene.dataScale[2], data.zcalendar));

    var cells = zip3(data._meshI, data._meshJ, data._meshK);

    var config = {
        positions: positions,
        cells: cells,
        lightPosition: [data.lightposition.x, data.lightposition.y, data.lightposition.z],
        ambient: data.lighting.ambient,
        diffuse: data.lighting.diffuse,
        specular: data.lighting.specular,
        roughness: data.lighting.roughness,
        fresnel: data.lighting.fresnel,
        vertexNormalsEpsilon: data.lighting.vertexnormalsepsilon,
        faceNormalsEpsilon: data.lighting.facenormalsepsilon,
        opacity: data.opacity,
        opacityscale: data.opacityscale,
        contourEnable: data.contour.show,
        contourColor: str2RgbaArray(data.contour.color).slice(0, 3),
        contourWidth: data.contour.width,
        useFacetNormals: data.flatshading
    };

    var cOpts = extractOpts(data);
    config.vertexIntensity = data._meshIntensity;
    config.vertexIntensityBounds = [cOpts.min, cOpts.max];
    config.colormap = parseColorScale(data);

    // Update mesh
    this.mesh.update(config);
};

proto.dispose = function() {
    this.scene.glplot.remove(this.mesh);
    this.mesh.dispose();
};

function createVolumeTrace(scene, data) {
    var gl = scene.glplot.gl;
    var mesh = createMesh({gl: gl});
    var result = new VolumeTrace(scene, mesh, data.uid);

    mesh._trace = result;
    result.update(data);
    scene.glplot.add(mesh);
    return result;
}

module.exports = createVolumeTrace;


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/volume/defaults.js":
/*!**************************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/volume/defaults.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



var Lib = __webpack_require__(/*! ../../lib */ "./node_modules/plotly.js/src/lib/index.js");
var attributes = __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/volume/attributes.js");
var supplyIsoDefaults = __webpack_require__(/*! ../isosurface/defaults */ "./node_modules/plotly.js/src/traces/isosurface/defaults.js").supplyIsoDefaults;
var opacityscaleDefaults = __webpack_require__(/*! ../surface/defaults */ "./node_modules/plotly.js/src/traces/surface/defaults.js").opacityscaleDefaults;

module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
    function coerce(attr, dflt) {
        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
    }

    supplyIsoDefaults(traceIn, traceOut, defaultColor, layout, coerce);

    opacityscaleDefaults(traceIn, traceOut, layout, coerce);
};


/***/ }),

/***/ "./node_modules/plotly.js/src/traces/volume/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/plotly.js/src/traces/volume/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
* Copyright 2012-2020, Plotly, Inc.
* All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/



module.exports = {
    attributes: __webpack_require__(/*! ./attributes */ "./node_modules/plotly.js/src/traces/volume/attributes.js"),
    supplyDefaults: __webpack_require__(/*! ./defaults */ "./node_modules/plotly.js/src/traces/volume/defaults.js"),
    calc: __webpack_require__(/*! ../isosurface/calc */ "./node_modules/plotly.js/src/traces/isosurface/calc.js"),
    colorbar: {
        min: 'cmin',
        max: 'cmax'
    },
    plot: __webpack_require__(/*! ./convert */ "./node_modules/plotly.js/src/traces/volume/convert.js"),

    moduleType: 'trace',
    name: 'volume',
    basePlotModule: __webpack_require__(/*! ../../plots/gl3d */ "./node_modules/plotly.js/src/plots/gl3d/index.js"),
    categories: ['gl3d', 'showLegend'],
    meta: {
        description: [
            'Draws volume trace between iso-min and iso-max values with coordinates given by',
            'four 1-dimensional arrays containing the `value`, `x`, `y` and `z` of every vertex',
            'of a uniform or non-uniform 3-D grid. Horizontal or vertical slices, caps as well as',
            'spaceframe between iso-min and iso-max values could also be drawn using this trace.'
        ].join(' ')
    }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9saWIvYmFyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL2xpYi9ib3guanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvbGliL2NhbmRsZXN0aWNrLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL2xpYi9jaG9yb3BsZXRoLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL2xpYi9jb250b3VyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL2xpYi9oZWF0bWFwLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL2xpYi9oZWF0bWFwZ2wuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvbGliL2hpc3RvZ3JhbTJkLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9saWIvaXNvc3VyZmFjZS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9saWIvb2hsYy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9saWIvcGllLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL2xpYi9zY2F0dGVycG9sYXIuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvbGliL3N1bmJ1cnN0LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL2xpYi92b2x1bWUuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9iYXIvY2FsYy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL2Jhci9ldmVudF9kYXRhLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvYmFyL2luZGV4LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvYm94L2V2ZW50X2RhdGEuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9ib3gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9ib3gvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9jYW5kbGVzdGljay9hdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvY2FuZGxlc3RpY2svY2FsYy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL2NhbmRsZXN0aWNrL2RlZmF1bHRzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvY2FuZGxlc3RpY2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9jaG9yb3BsZXRoL2RlZmF1bHRzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvY2hvcm9wbGV0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL2Nob3JvcGxldGgvcGxvdC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL2Nob3JvcGxldGgvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9jb250b3VyL2RlZmF1bHRzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvY29udG91ci9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL2hlYXRtYXAvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9oZWF0bWFwL2luZGV4LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvaGVhdG1hcC9zdHlsZV9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL2hlYXRtYXBnbC9hdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvaGVhdG1hcGdsL2NvbnZlcnQuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9oZWF0bWFwZ2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9oaXN0b2dyYW0yZC9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL2hpc3RvZ3JhbTJkL2hvdmVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvaGlzdG9ncmFtMmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9pc29zdXJmYWNlL2luZGV4LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvb2hsYy9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL29obGMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9vaGxjL3Bsb3QuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9vaGxjL3N0eWxlLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvcGllL2Jhc2VfcGxvdC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL3BpZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL3BpZS9sYXlvdXRfZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9waWUvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9zY2F0dGVycG9sYXIvY2FsYy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL3NjYXR0ZXJwb2xhci9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL3NjYXR0ZXJwb2xhci9wbG90LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvc3VuYnVyc3QvYmFzZV9wbG90LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvc3VuYnVyc3QvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy9zdW5idXJzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL3N1bmJ1cnN0L2xheW91dF9hdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvc3VuYnVyc3QvbGF5b3V0X2RlZmF1bHRzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcGxvdGx5LmpzL3NyYy90cmFjZXMvdm9sdW1lL2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9wbG90bHkuanMvc3JjL3RyYWNlcy92b2x1bWUvY29udmVydC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL3ZvbHVtZS9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3Bsb3RseS5qcy9zcmMvdHJhY2VzL3ZvbHVtZS9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixpSEFBNkM7Ozs7Ozs7Ozs7OztBQ1Y3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixpSEFBNkM7Ozs7Ozs7Ozs7OztBQ1Y3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixpSUFBcUQ7Ozs7Ozs7Ozs7OztBQ1ZyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiwrSEFBb0Q7Ozs7Ozs7Ozs7OztBQ1ZwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYix5SEFBaUQ7Ozs7Ozs7Ozs7OztBQ1ZqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYix5SEFBaUQ7Ozs7Ozs7Ozs7OztBQ1ZqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiw2SEFBbUQ7Ozs7Ozs7Ozs7OztBQ1ZuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixpSUFBcUQ7Ozs7Ozs7Ozs7OztBQ1ZyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsb0RBQVE7O0FBRTdCO0FBQ0E7QUFDQSxJQUFJLG1CQUFPLENBQUMsa0RBQU87QUFDbkIsSUFBSSxtQkFBTyxDQUFDLGtEQUFPO0FBQ25CLElBQUksbUJBQU8sQ0FBQywwREFBVztBQUN2QixJQUFJLG1CQUFPLENBQUMsOERBQWE7QUFDekIsSUFBSSxtQkFBTyxDQUFDLGtFQUFlO0FBQzNCLElBQUksbUJBQU8sQ0FBQyxnRkFBc0I7QUFDbEMsSUFBSSxt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QUViO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQWM7QUFDdEMsb0JBQW9CLG1CQUFPLENBQUMsMEVBQVk7QUFDeEMsVUFBVSxtQkFBTyxDQUFDLGtGQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsVUFBVSxtQkFBTyxDQUFDLHdFQUFXOztBQUU3QjtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsMEVBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImNoYXJ0Y2YzNDg5NzkwY2Y2YTRiNTc1ZDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vc3JjL3RyYWNlcy9iYXInKTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9zcmMvdHJhY2VzL2JveCcpO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL3NyYy90cmFjZXMvY2FuZGxlc3RpY2snKTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9zcmMvdHJhY2VzL2Nob3JvcGxldGgnKTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9zcmMvdHJhY2VzL2NvbnRvdXInKTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9zcmMvdHJhY2VzL2hlYXRtYXAnKTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9zcmMvdHJhY2VzL2hlYXRtYXBnbCcpO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL3NyYy90cmFjZXMvaGlzdG9ncmFtMmQnKTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBsb3RseSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4vLyB0cmFjZXNcblBsb3RseS5yZWdpc3RlcihbXG4gICAgcmVxdWlyZSgnLi9iYXInKSxcbiAgICByZXF1aXJlKCcuL2JveCcpLFxuICAgIHJlcXVpcmUoJy4vaGVhdG1hcCcpLFxuICAgIHJlcXVpcmUoJy4vaGlzdG9ncmFtJyksXG4gICAgcmVxdWlyZSgnLi9oaXN0b2dyYW0yZCcpLFxuICAgIHJlcXVpcmUoJy4vaGlzdG9ncmFtMmRjb250b3VyJyksXG4gICAgcmVxdWlyZSgnLi9jb250b3VyJyksXG4gICAgcmVxdWlyZSgnLi9zY2F0dGVydGVybmFyeScpLFxuICAgIHJlcXVpcmUoJy4vdmlvbGluJyksXG4gICAgcmVxdWlyZSgnLi9mdW5uZWwnKSxcbiAgICByZXF1aXJlKCcuL3dhdGVyZmFsbCcpLFxuICAgIHJlcXVpcmUoJy4vaW1hZ2UnKSxcblxuICAgIHJlcXVpcmUoJy4vcGllJyksXG4gICAgcmVxdWlyZSgnLi9zdW5idXJzdCcpLFxuICAgIHJlcXVpcmUoJy4vdHJlZW1hcCcpLFxuICAgIHJlcXVpcmUoJy4vZnVubmVsYXJlYScpLFxuXG4gICAgcmVxdWlyZSgnLi9zY2F0dGVyM2QnKSxcbiAgICByZXF1aXJlKCcuL3N1cmZhY2UnKSxcbiAgICByZXF1aXJlKCcuL2lzb3N1cmZhY2UnKSxcbiAgICByZXF1aXJlKCcuL3ZvbHVtZScpLFxuICAgIHJlcXVpcmUoJy4vbWVzaDNkJyksXG4gICAgcmVxdWlyZSgnLi9jb25lJyksXG4gICAgcmVxdWlyZSgnLi9zdHJlYW10dWJlJyksXG5cbiAgICByZXF1aXJlKCcuL3NjYXR0ZXJnZW8nKSxcbiAgICByZXF1aXJlKCcuL2Nob3JvcGxldGgnKSxcblxuICAgIHJlcXVpcmUoJy4vc2NhdHRlcmdsJyksXG4gICAgcmVxdWlyZSgnLi9zcGxvbScpLFxuXG4gICAgcmVxdWlyZSgnLi9wb2ludGNsb3VkJyksXG4gICAgcmVxdWlyZSgnLi9oZWF0bWFwZ2wnKSxcblxuICAgIHJlcXVpcmUoJy4vcGFyY29vcmRzJyksXG5cbiAgICByZXF1aXJlKCcuL3BhcmNhdHMnKSxcblxuICAgIHJlcXVpcmUoJy4vc2NhdHRlcm1hcGJveCcpLFxuICAgIHJlcXVpcmUoJy4vY2hvcm9wbGV0aG1hcGJveCcpLFxuICAgIHJlcXVpcmUoJy4vZGVuc2l0eW1hcGJveCcpLFxuXG4gICAgcmVxdWlyZSgnLi9zYW5rZXknKSxcbiAgICByZXF1aXJlKCcuL2luZGljYXRvcicpLFxuXG4gICAgcmVxdWlyZSgnLi90YWJsZScpLFxuXG4gICAgcmVxdWlyZSgnLi9jYXJwZXQnKSxcbiAgICByZXF1aXJlKCcuL3NjYXR0ZXJjYXJwZXQnKSxcbiAgICByZXF1aXJlKCcuL2NvbnRvdXJjYXJwZXQnKSxcblxuICAgIHJlcXVpcmUoJy4vb2hsYycpLFxuICAgIHJlcXVpcmUoJy4vY2FuZGxlc3RpY2snKSxcblxuICAgIHJlcXVpcmUoJy4vc2NhdHRlcnBvbGFyJyksXG4gICAgcmVxdWlyZSgnLi9zY2F0dGVycG9sYXJnbCcpLFxuICAgIHJlcXVpcmUoJy4vYmFycG9sYXInKVxuXSk7XG5cbi8vIHRyYW5zZm9ybXNcbi8vXG4vLyBQbGVhc2Ugbm90ZSB0aGF0IGFsbCAqdHJhbnNmb3JtKiBtZXRob2RzIGFyZSBleGVjdXRlZCBiZWZvcmVcbi8vIGFsbCAqY2FsY1RyYW5zZm9ybSogbWV0aG9kcyAtIHdoaWNoIGNvdWxkIHBvc3NpYmx5IGxlYWQgdG9cbi8vIHVuZXhwZWN0ZWQgcmVzdWx0cyB3aGVuIGFwcGx5aW5nIG11bHRpcGxlIHRyYW5zZm9ybXMgb2YgZGlmZmVyZW50IHR5cGVzXG4vLyB0byBhIGdpdmVuIHRyYWNlLlxuLy9cbi8vIEZvciBtb3JlIGluZm8sIHNlZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbG90bHkvcGxvdGx5LmpzL3B1bGwvOTc4I3B1bGxyZXF1ZXN0cmV2aWV3LTI0MDMzNTNcbi8vXG5QbG90bHkucmVnaXN0ZXIoW1xuICAgIHJlcXVpcmUoJy4vYWdncmVnYXRlJyksXG4gICAgcmVxdWlyZSgnLi9maWx0ZXInKSxcbiAgICByZXF1aXJlKCcuL2dyb3VwYnknKSxcbiAgICByZXF1aXJlKCcuL3NvcnQnKVxuXSk7XG5cbi8vIGNvbXBvbmVudHNcblBsb3RseS5yZWdpc3RlcihbXG4gICAgcmVxdWlyZSgnLi9jYWxlbmRhcnMnKVxuXSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGxvdGx5O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL3NyYy90cmFjZXMvaXNvc3VyZmFjZScpO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL3NyYy90cmFjZXMvb2hsYycpO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL3NyYy90cmFjZXMvcGllJyk7XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vc3JjL3RyYWNlcy9zY2F0dGVycG9sYXInKTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9zcmMvdHJhY2VzL3N1bmJ1cnN0Jyk7XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vc3JjL3RyYWNlcy92b2x1bWUnKTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEF4ZXMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9jYXJ0ZXNpYW4vYXhlcycpO1xudmFyIGhhc0NvbG9yc2NhbGUgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzL2NvbG9yc2NhbGUvaGVscGVycycpLmhhc0NvbG9yc2NhbGU7XG52YXIgY29sb3JzY2FsZUNhbGMgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzL2NvbG9yc2NhbGUvY2FsYycpO1xudmFyIGFycmF5c1RvQ2FsY2RhdGEgPSByZXF1aXJlKCcuL2FycmF5c190b19jYWxjZGF0YScpO1xudmFyIGNhbGNTZWxlY3Rpb24gPSByZXF1aXJlKCcuLi9zY2F0dGVyL2NhbGNfc2VsZWN0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsYyhnZCwgdHJhY2UpIHtcbiAgICB2YXIgeGEgPSBBeGVzLmdldEZyb21JZChnZCwgdHJhY2UueGF4aXMgfHwgJ3gnKTtcbiAgICB2YXIgeWEgPSBBeGVzLmdldEZyb21JZChnZCwgdHJhY2UueWF4aXMgfHwgJ3knKTtcbiAgICB2YXIgc2l6ZSwgcG9zO1xuXG4gICAgdmFyIHNpemVPcHRzID0ge1xuICAgICAgICBtc1VUQzogISEodHJhY2UuYmFzZSB8fCB0cmFjZS5iYXNlID09PSAwKVxuICAgIH07XG5cbiAgICBpZih0cmFjZS5vcmllbnRhdGlvbiA9PT0gJ2gnKSB7XG4gICAgICAgIHNpemUgPSB4YS5tYWtlQ2FsY2RhdGEodHJhY2UsICd4Jywgc2l6ZU9wdHMpO1xuICAgICAgICBwb3MgPSB5YS5tYWtlQ2FsY2RhdGEodHJhY2UsICd5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IHlhLm1ha2VDYWxjZGF0YSh0cmFjZSwgJ3knLCBzaXplT3B0cyk7XG4gICAgICAgIHBvcyA9IHhhLm1ha2VDYWxjZGF0YSh0cmFjZSwgJ3gnKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgdGhlIFwiY2FsY3VsYXRlZCBkYXRhXCIgdG8gcGxvdFxuICAgIHZhciBzZXJpZXNsZW4gPSBNYXRoLm1pbihwb3MubGVuZ3RoLCBzaXplLmxlbmd0aCk7XG4gICAgdmFyIGNkID0gbmV3IEFycmF5KHNlcmllc2xlbik7XG5cbiAgICAvLyBzZXQgcG9zaXRpb24gYW5kIHNpemVcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VyaWVzbGVuOyBpKyspIHtcbiAgICAgICAgY2RbaV0gPSB7IHA6IHBvc1tpXSwgczogc2l6ZVtpXSB9O1xuXG4gICAgICAgIGlmKHRyYWNlLmlkcykge1xuICAgICAgICAgICAgY2RbaV0uaWQgPSBTdHJpbmcodHJhY2UuaWRzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGF1dG8teiBhbmQgYXV0b2NvbG9yc2NhbGUgaWYgYXBwbGljYWJsZVxuICAgIGlmKGhhc0NvbG9yc2NhbGUodHJhY2UsICdtYXJrZXInKSkge1xuICAgICAgICBjb2xvcnNjYWxlQ2FsYyhnZCwgdHJhY2UsIHtcbiAgICAgICAgICAgIHZhbHM6IHRyYWNlLm1hcmtlci5jb2xvcixcbiAgICAgICAgICAgIGNvbnRhaW5lclN0cjogJ21hcmtlcicsXG4gICAgICAgICAgICBjTGV0dGVyOiAnYydcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmKGhhc0NvbG9yc2NhbGUodHJhY2UsICdtYXJrZXIubGluZScpKSB7XG4gICAgICAgIGNvbG9yc2NhbGVDYWxjKGdkLCB0cmFjZSwge1xuICAgICAgICAgICAgdmFsczogdHJhY2UubWFya2VyLmxpbmUuY29sb3IsXG4gICAgICAgICAgICBjb250YWluZXJTdHI6ICdtYXJrZXIubGluZScsXG4gICAgICAgICAgICBjTGV0dGVyOiAnYydcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXJyYXlzVG9DYWxjZGF0YShjZCwgdHJhY2UpO1xuICAgIGNhbGNTZWxlY3Rpb24oY2QsIHRyYWNlKTtcblxuICAgIHJldHVybiBjZDtcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXZlbnREYXRhKG91dCwgcHQsIHRyYWNlKSB7XG4gICAgLy8gc3RhbmRhcmQgY2FydGVzaWFuIGV2ZW50IGRhdGFcbiAgICBvdXQueCA9ICd4VmFsJyBpbiBwdCA/IHB0LnhWYWwgOiBwdC54O1xuICAgIG91dC55ID0gJ3lWYWwnIGluIHB0ID8gcHQueVZhbCA6IHB0Lnk7XG4gICAgaWYocHQueGEpIG91dC54YXhpcyA9IHB0LnhhO1xuICAgIGlmKHB0LnlhKSBvdXQueWF4aXMgPSBwdC55YTtcblxuICAgIGlmKHRyYWNlLm9yaWVudGF0aW9uID09PSAnaCcpIHtcbiAgICAgICAgb3V0LmxhYmVsID0gb3V0Lnk7XG4gICAgICAgIG91dC52YWx1ZSA9IG91dC54O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dC5sYWJlbCA9IG91dC54O1xuICAgICAgICBvdXQudmFsdWUgPSBvdXQueTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXR0cmlidXRlczogcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyksXG4gICAgbGF5b3V0QXR0cmlidXRlczogcmVxdWlyZSgnLi9sYXlvdXRfYXR0cmlidXRlcycpLFxuICAgIHN1cHBseURlZmF1bHRzOiByZXF1aXJlKCcuL2RlZmF1bHRzJykuc3VwcGx5RGVmYXVsdHMsXG4gICAgY3Jvc3NUcmFjZURlZmF1bHRzOiByZXF1aXJlKCcuL2RlZmF1bHRzJykuY3Jvc3NUcmFjZURlZmF1bHRzLFxuICAgIHN1cHBseUxheW91dERlZmF1bHRzOiByZXF1aXJlKCcuL2xheW91dF9kZWZhdWx0cycpLFxuICAgIGNhbGM6IHJlcXVpcmUoJy4vY2FsYycpLFxuICAgIGNyb3NzVHJhY2VDYWxjOiByZXF1aXJlKCcuL2Nyb3NzX3RyYWNlX2NhbGMnKS5jcm9zc1RyYWNlQ2FsYyxcbiAgICBjb2xvcmJhcjogcmVxdWlyZSgnLi4vc2NhdHRlci9tYXJrZXJfY29sb3JiYXInKSxcbiAgICBhcnJheXNUb0NhbGNkYXRhOiByZXF1aXJlKCcuL2FycmF5c190b19jYWxjZGF0YScpLFxuICAgIHBsb3Q6IHJlcXVpcmUoJy4vcGxvdCcpLnBsb3QsXG4gICAgc3R5bGU6IHJlcXVpcmUoJy4vc3R5bGUnKS5zdHlsZSxcbiAgICBzdHlsZU9uU2VsZWN0OiByZXF1aXJlKCcuL3N0eWxlJykuc3R5bGVPblNlbGVjdCxcbiAgICBob3ZlclBvaW50czogcmVxdWlyZSgnLi9ob3ZlcicpLmhvdmVyUG9pbnRzLFxuICAgIGV2ZW50RGF0YTogcmVxdWlyZSgnLi9ldmVudF9kYXRhJyksXG4gICAgc2VsZWN0UG9pbnRzOiByZXF1aXJlKCcuL3NlbGVjdCcpLFxuXG4gICAgbW9kdWxlVHlwZTogJ3RyYWNlJyxcbiAgICBuYW1lOiAnYmFyJyxcbiAgICBiYXNlUGxvdE1vZHVsZTogcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuJyksXG4gICAgY2F0ZWdvcmllczogWydiYXItbGlrZScsICdjYXJ0ZXNpYW4nLCAnc3ZnJywgJ2JhcicsICdvcmllbnRlZCcsICdlcnJvckJhcnNPSycsICdzaG93TGVnZW5kJywgJ3pvb21TY2FsZSddLFxuICAgIGFuaW1hdGFibGU6IHRydWUsXG4gICAgbWV0YToge1xuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1RoZSBkYXRhIHZpc3VhbGl6ZWQgYnkgdGhlIHNwYW4gb2YgdGhlIGJhcnMgaXMgc2V0IGluIGB5YCcsXG4gICAgICAgICAgICAnaWYgYG9yaWVudGF0aW9uYCBpcyBzZXQgdGggKnYqICh0aGUgZGVmYXVsdCknLFxuICAgICAgICAgICAgJ2FuZCB0aGUgbGFiZWxzIGFyZSBzZXQgaW4gYHhgLicsXG4gICAgICAgICAgICAnQnkgc2V0dGluZyBgb3JpZW50YXRpb25gIHRvICpoKiwgdGhlIHJvbGVzIGFyZSBpbnRlcmNoYW5nZWQuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH1cbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXZlbnREYXRhKG91dCwgcHQpIHtcbiAgICAvLyBOb3RlOiBob3Zlck9uQm94IHByb3BlcnR5IGlzIG5lZWRlZCBmb3IgY2xpY2stdG8tc2VsZWN0XG4gICAgLy8gdG8gaWdub3JlIHdoZW4gYSBib3ggd2FzIGNsaWNrZWQuIFRoaXMgaXMgdGhlIHJlYXNvbiBib3hcbiAgICAvLyBpbXBsZW1lbnRzIHRoaXMgY3VzdG9tIGV2ZW50RGF0YSBmdW5jdGlvbi5cbiAgICBpZihwdC5ob3Zlck9uQm94KSBvdXQuaG92ZXJPbkJveCA9IHB0LmhvdmVyT25Cb3g7XG5cbiAgICBpZigneFZhbCcgaW4gcHQpIG91dC54ID0gcHQueFZhbDtcbiAgICBpZigneVZhbCcgaW4gcHQpIG91dC55ID0gcHQueVZhbDtcbiAgICBpZihwdC54YSkgb3V0LnhheGlzID0gcHQueGE7XG4gICAgaWYocHQueWEpIG91dC55YXhpcyA9IHB0LnlhO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGF0dHJpYnV0ZXM6IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpLFxuICAgIGxheW91dEF0dHJpYnV0ZXM6IHJlcXVpcmUoJy4vbGF5b3V0X2F0dHJpYnV0ZXMnKSxcbiAgICBzdXBwbHlEZWZhdWx0czogcmVxdWlyZSgnLi9kZWZhdWx0cycpLnN1cHBseURlZmF1bHRzLFxuICAgIGNyb3NzVHJhY2VEZWZhdWx0czogcmVxdWlyZSgnLi9kZWZhdWx0cycpLmNyb3NzVHJhY2VEZWZhdWx0cyxcbiAgICBzdXBwbHlMYXlvdXREZWZhdWx0czogcmVxdWlyZSgnLi9sYXlvdXRfZGVmYXVsdHMnKS5zdXBwbHlMYXlvdXREZWZhdWx0cyxcbiAgICBjYWxjOiByZXF1aXJlKCcuL2NhbGMnKSxcbiAgICBjcm9zc1RyYWNlQ2FsYzogcmVxdWlyZSgnLi9jcm9zc190cmFjZV9jYWxjJykuY3Jvc3NUcmFjZUNhbGMsXG4gICAgcGxvdDogcmVxdWlyZSgnLi9wbG90JykucGxvdCxcbiAgICBzdHlsZTogcmVxdWlyZSgnLi9zdHlsZScpLnN0eWxlLFxuICAgIHN0eWxlT25TZWxlY3Q6IHJlcXVpcmUoJy4vc3R5bGUnKS5zdHlsZU9uU2VsZWN0LFxuICAgIGhvdmVyUG9pbnRzOiByZXF1aXJlKCcuL2hvdmVyJykuaG92ZXJQb2ludHMsXG4gICAgZXZlbnREYXRhOiByZXF1aXJlKCcuL2V2ZW50X2RhdGEnKSxcbiAgICBzZWxlY3RQb2ludHM6IHJlcXVpcmUoJy4vc2VsZWN0JyksXG5cbiAgICBtb2R1bGVUeXBlOiAndHJhY2UnLFxuICAgIG5hbWU6ICdib3gnLFxuICAgIGJhc2VQbG90TW9kdWxlOiByZXF1aXJlKCcuLi8uLi9wbG90cy9jYXJ0ZXNpYW4nKSxcbiAgICBjYXRlZ29yaWVzOiBbJ2NhcnRlc2lhbicsICdzdmcnLCAnc3ltYm9scycsICdvcmllbnRlZCcsICdib3gtdmlvbGluJywgJ3Nob3dMZWdlbmQnLCAnYm94TGF5b3V0JywgJ3pvb21TY2FsZSddLFxuICAgIG1ldGE6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdFYWNoIGJveCBzcGFucyBmcm9tIHF1YXJ0aWxlIDEgKFExKSB0byBxdWFydGlsZSAzIChRMykuJyxcbiAgICAgICAgICAgICdUaGUgc2Vjb25kIHF1YXJ0aWxlIChRMiwgaS5lLiB0aGUgbWVkaWFuKSBpcyBtYXJrZWQgYnkgYSBsaW5lIGluc2lkZSB0aGUgYm94LicsXG4gICAgICAgICAgICAnVGhlIGZlbmNlcyBncm93IG91dHdhcmQgZnJvbSB0aGUgYm94ZXNcXCcgZWRnZXMsJyxcbiAgICAgICAgICAgICdieSBkZWZhdWx0IHRoZXkgc3BhbiArLy0gMS41IHRpbWVzIHRoZSBpbnRlcnF1YXJ0aWxlIHJhbmdlIChJUVI6IFEzLVExKSwnLFxuICAgICAgICAgICAgJ1RoZSBzYW1wbGUgbWVhbiBhbmQgc3RhbmRhcmQgZGV2aWF0aW9uIGFzIHdlbGwgYXMgbm90Y2hlcyBhbmQnLFxuICAgICAgICAgICAgJ3RoZSBzYW1wbGUsIG91dGxpZXIgYW5kIHN1c3BlY3RlZCBvdXRsaWVycyBwb2ludHMgY2FuIGJlIG9wdGlvbmFsbHknLFxuICAgICAgICAgICAgJ2FkZGVkIHRvIHRoZSBib3ggcGxvdC4nLFxuXG4gICAgICAgICAgICAnVGhlIHZhbHVlcyBhbmQgcG9zaXRpb25zIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBib3hlcyBjYW4gYmUgaW5wdXQnLFxuICAgICAgICAgICAgJ3VzaW5nIHR3byBzaWduYXR1cmVzLicsXG5cbiAgICAgICAgICAgICdUaGUgZmlyc3Qgc2lnbmF0dXJlIGV4cGVjdHMgdXNlcnMgdG8gc3VwcGx5IHRoZSBzYW1wbGUgdmFsdWVzIGluIHRoZSBgeWAnLFxuICAgICAgICAgICAgJ2RhdGEgYXJyYXkgZm9yIHZlcnRpY2FsIGJveGVzIChgeGAgZm9yIGhvcml6b250YWwgYm94ZXMpLicsXG4gICAgICAgICAgICAnQnkgc3VwcGx5aW5nIGFuIGB4YCAoYHlgKSBhcnJheSwgb25lIGJveCBwZXIgZGlzdGluY3QgYHhgIChgeWApIHZhbHVlIGlzIGRyYXduJyxcbiAgICAgICAgICAgICdJZiBubyBgeGAgKGB5YCkge2FycmF5fSBpcyBwcm92aWRlZCwgYSBzaW5nbGUgYm94IGlzIGRyYXduLicsXG4gICAgICAgICAgICAnSW4gdGhpcyBjYXNlLCB0aGUgYm94IGlzIHBvc2l0aW9uZWQgd2l0aCB0aGUgdHJhY2UgYG5hbWVgIG9yIHdpdGggYHgwYCAoYHkwYCkgaWYgcHJvdmlkZWQuJyxcblxuICAgICAgICAgICAgJ1RoZSBzZWNvbmQgc2lnbmF0dXJlIGV4cGVjdHMgdXNlcnMgdG8gc3VwcGx5IHRoZSBib3hlcyBjb3JyZXNwb25kaW5nIFExLCBtZWRpYW4gYW5kIFEzJyxcbiAgICAgICAgICAgICdzdGF0aXN0aWNzIGluIHRoZSBgcTFgLCBgbWVkaWFuYCBhbmQgYHEzYCBkYXRhIGFycmF5cyByZXNwZWN0aXZlbHkuJyxcbiAgICAgICAgICAgICdPdGhlciBib3ggZmVhdHVyZXMgcmVseWluZyBvbiBzdGF0aXN0aWNzIG5hbWVseSBgbG93ZXJmZW5jZWAsIGB1cHBlcmZlbmNlYCwgYG5vdGNoc3BhbmAnLFxuICAgICAgICAgICAgJ2NhbiBiZSBzZXQgZGlyZWN0bHkgYnkgdGhlIHVzZXJzLicsXG4gICAgICAgICAgICAnVG8gaGF2ZSBwbG90bHkgY29tcHV0ZSB0aGVtIG9yIHRvIHNob3cgc2FtcGxlIHBvaW50cyBiZXNpZGVzIHRoZSBib3hlcywnLFxuICAgICAgICAgICAgJ3VzZXJzIGNhbiBzZXQgdGhlIGB5YCBkYXRhIGFycmF5IGZvciB2ZXJ0aWNhbCBib3hlcyAoYHhgIGZvciBob3Jpem9udGFsIGJveGVzKScsXG4gICAgICAgICAgICAndG8gYSAyRCBhcnJheSB3aXRoIHRoZSBvdXRlciBsZW5ndGggY29ycmVzcG9uZGluZycsXG4gICAgICAgICAgICAndG8gdGhlIG51bWJlciBvZiBib3hlcyBpbiB0aGUgdHJhY2VzIGFuZCB0aGUgaW5uZXIgbGVuZ3RoIGNvcnJlc3BvbmRpbmcgdGhlIHNhbXBsZSBzaXplLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZDMgPSByZXF1aXJlKCdkMycpO1xudmFyIENvbG9yID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50cy9jb2xvcicpO1xudmFyIERyYXdpbmcgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzL2RyYXdpbmcnKTtcblxuZnVuY3Rpb24gc3R5bGUoZ2QsIGNkLCBzZWwpIHtcbiAgICB2YXIgcyA9IHNlbCA/IHNlbCA6IGQzLnNlbGVjdChnZCkuc2VsZWN0QWxsKCdnLnRyYWNlLmJveGVzJyk7XG5cbiAgICBzLnN0eWxlKCdvcGFjaXR5JywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZFswXS50cmFjZS5vcGFjaXR5OyB9KTtcblxuICAgIHMuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBlbCA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHRyYWNlID0gZFswXS50cmFjZTtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHRyYWNlLmxpbmUud2lkdGg7XG5cbiAgICAgICAgZnVuY3Rpb24gc3R5bGVCb3goYm94U2VsLCBsaW5lV2lkdGgsIGxpbmVDb2xvciwgZmlsbENvbG9yKSB7XG4gICAgICAgICAgICBib3hTZWwuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIGxpbmVXaWR0aCArICdweCcpXG4gICAgICAgICAgICAgICAgLmNhbGwoQ29sb3Iuc3Ryb2tlLCBsaW5lQ29sb3IpXG4gICAgICAgICAgICAgICAgLmNhbGwoQ29sb3IuZmlsbCwgZmlsbENvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbGxCb3hlcyA9IGVsLnNlbGVjdEFsbCgncGF0aC5ib3gnKTtcblxuICAgICAgICBpZih0cmFjZS50eXBlID09PSAnY2FuZGxlc3RpY2snKSB7XG4gICAgICAgICAgICBhbGxCb3hlcy5lYWNoKGZ1bmN0aW9uKGJveERhdGEpIHtcbiAgICAgICAgICAgICAgICBpZihib3hEYXRhLmVtcHR5KSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB2YXIgdGhpc0JveCA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdHJhY2VbYm94RGF0YS5kaXJdOyAvLyBkaXIgPSAnaW5jcmVhc2luZycgb3IgJ2RlY3JlYXNpbmcnXG4gICAgICAgICAgICAgICAgc3R5bGVCb3godGhpc0JveCwgY29udGFpbmVyLmxpbmUud2lkdGgsIGNvbnRhaW5lci5saW5lLmNvbG9yLCBjb250YWluZXIuZmlsbGNvbG9yKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBjdXN0b20gc2VsZWN0aW9uIHN0eWxlIGZvciBjYW5kbGVzdGlja3NcbiAgICAgICAgICAgICAgICB0aGlzQm94LnN0eWxlKCdvcGFjaXR5JywgdHJhY2Uuc2VsZWN0ZWRwb2ludHMgJiYgIWJveERhdGEuc2VsZWN0ZWQgPyAwLjMgOiAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVCb3goYWxsQm94ZXMsIGxpbmVXaWR0aCwgdHJhY2UubGluZS5jb2xvciwgdHJhY2UuZmlsbGNvbG9yKTtcbiAgICAgICAgICAgIGVsLnNlbGVjdEFsbCgncGF0aC5tZWFuJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogbGluZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICgyICogbGluZVdpZHRoKSArICdweCwnICsgbGluZVdpZHRoICsgJ3B4J1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhbGwoQ29sb3Iuc3Ryb2tlLCB0cmFjZS5saW5lLmNvbG9yKTtcblxuICAgICAgICAgICAgdmFyIHB0cyA9IGVsLnNlbGVjdEFsbCgncGF0aC5wb2ludCcpO1xuICAgICAgICAgICAgRHJhd2luZy5wb2ludFN0eWxlKHB0cywgdHJhY2UsIGdkKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBzdHlsZU9uU2VsZWN0KGdkLCBjZCwgc2VsKSB7XG4gICAgdmFyIHRyYWNlID0gY2RbMF0udHJhY2U7XG4gICAgdmFyIHB0cyA9IHNlbC5zZWxlY3RBbGwoJ3BhdGgucG9pbnQnKTtcblxuICAgIGlmKHRyYWNlLnNlbGVjdGVkcG9pbnRzKSB7XG4gICAgICAgIERyYXdpbmcuc2VsZWN0ZWRQb2ludFN0eWxlKHB0cywgdHJhY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIERyYXdpbmcucG9pbnRTdHlsZShwdHMsIHRyYWNlLCBnZCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgc3R5bGVPblNlbGVjdDogc3R5bGVPblNlbGVjdFxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXh0ZW5kRmxhdCA9IHJlcXVpcmUoJy4uLy4uL2xpYicpLmV4dGVuZEZsYXQ7XG52YXIgT0hMQ2F0dHJzID0gcmVxdWlyZSgnLi4vb2hsYy9hdHRyaWJ1dGVzJyk7XG52YXIgYm94QXR0cnMgPSByZXF1aXJlKCcuLi9ib3gvYXR0cmlidXRlcycpO1xuXG5mdW5jdGlvbiBkaXJlY3Rpb25BdHRycyhsaW5lQ29sb3JEZWZhdWx0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZToge1xuICAgICAgICAgICAgY29sb3I6IGV4dGVuZEZsYXQoe30sIGJveEF0dHJzLmxpbmUuY29sb3IsIHtkZmx0OiBsaW5lQ29sb3JEZWZhdWx0fSksXG4gICAgICAgICAgICB3aWR0aDogYm94QXR0cnMubGluZS53aWR0aCxcbiAgICAgICAgICAgIGVkaXRUeXBlOiAnc3R5bGUnXG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsbGNvbG9yOiBib3hBdHRycy5maWxsY29sb3IsXG4gICAgICAgIGVkaXRUeXBlOiAnc3R5bGUnXG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgeDogT0hMQ2F0dHJzLngsXG4gICAgb3BlbjogT0hMQ2F0dHJzLm9wZW4sXG4gICAgaGlnaDogT0hMQ2F0dHJzLmhpZ2gsXG4gICAgbG93OiBPSExDYXR0cnMubG93LFxuICAgIGNsb3NlOiBPSExDYXR0cnMuY2xvc2UsXG5cbiAgICBsaW5lOiB7XG4gICAgICAgIHdpZHRoOiBleHRlbmRGbGF0KHt9LCBib3hBdHRycy5saW5lLndpZHRoLCB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgICAgIGJveEF0dHJzLmxpbmUud2lkdGguZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgJ05vdGUgdGhhdCB0aGlzIHN0eWxlIHNldHRpbmcgY2FuIGFsc28gYmUgc2V0IHBlcicsXG4gICAgICAgICAgICAgICAgJ2RpcmVjdGlvbiB2aWEgYGluY3JlYXNpbmcubGluZS53aWR0aGAgYW5kJyxcbiAgICAgICAgICAgICAgICAnYGRlY3JlYXNpbmcubGluZS53aWR0aGAuJ1xuICAgICAgICAgICAgXS5qb2luKCcgJylcbiAgICAgICAgfSksXG4gICAgICAgIGVkaXRUeXBlOiAnc3R5bGUnXG4gICAgfSxcblxuICAgIGluY3JlYXNpbmc6IGRpcmVjdGlvbkF0dHJzKE9ITENhdHRycy5pbmNyZWFzaW5nLmxpbmUuY29sb3IuZGZsdCksXG5cbiAgICBkZWNyZWFzaW5nOiBkaXJlY3Rpb25BdHRycyhPSExDYXR0cnMuZGVjcmVhc2luZy5saW5lLmNvbG9yLmRmbHQpLFxuXG4gICAgdGV4dDogT0hMQ2F0dHJzLnRleHQsXG4gICAgaG92ZXJ0ZXh0OiBPSExDYXR0cnMuaG92ZXJ0ZXh0LFxuICAgIHdoaXNrZXJ3aWR0aDogZXh0ZW5kRmxhdCh7fSwgYm94QXR0cnMud2hpc2tlcndpZHRoLCB7IGRmbHQ6IDAgfSksXG5cbiAgICBob3ZlcmxhYmVsOiBPSExDYXR0cnMuaG92ZXJsYWJlbCxcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaWIgPSByZXF1aXJlKCcuLi8uLi9saWInKTtcbnZhciBBeGVzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuL2F4ZXMnKTtcblxudmFyIGNhbGNDb21tb24gPSByZXF1aXJlKCcuLi9vaGxjL2NhbGMnKS5jYWxjQ29tbW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGdkLCB0cmFjZSkge1xuICAgIHZhciBmdWxsTGF5b3V0ID0gZ2QuX2Z1bGxMYXlvdXQ7XG4gICAgdmFyIHhhID0gQXhlcy5nZXRGcm9tSWQoZ2QsIHRyYWNlLnhheGlzKTtcbiAgICB2YXIgeWEgPSBBeGVzLmdldEZyb21JZChnZCwgdHJhY2UueWF4aXMpO1xuXG4gICAgdmFyIHggPSB4YS5tYWtlQ2FsY2RhdGEodHJhY2UsICd4Jyk7XG5cbiAgICB2YXIgY2QgPSBjYWxjQ29tbW9uKGdkLCB0cmFjZSwgeCwgeWEsIHB0RnVuYyk7XG5cbiAgICBpZihjZC5sZW5ndGgpIHtcbiAgICAgICAgTGliLmV4dGVuZEZsYXQoY2RbMF0udCwge1xuICAgICAgICAgICAgbnVtOiBmdWxsTGF5b3V0Ll9udW1Cb3hlcyxcbiAgICAgICAgICAgIGRQb3M6IExpYi5kaXN0aW5jdFZhbHMoeCkubWluRGlmZiAvIDIsXG4gICAgICAgICAgICBwb3NMZXR0ZXI6ICd4JyxcbiAgICAgICAgICAgIHZhbExldHRlcjogJ3knLFxuICAgICAgICB9KTtcblxuICAgICAgICBmdWxsTGF5b3V0Ll9udW1Cb3hlcysrO1xuICAgICAgICByZXR1cm4gY2Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt7dDoge2VtcHR5OiB0cnVlfX1dO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHB0RnVuYyhvLCBoLCBsLCBjKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiBsLFxuICAgICAgICBxMTogTWF0aC5taW4obywgYyksXG4gICAgICAgIG1lZDogYyxcbiAgICAgICAgcTM6IE1hdGgubWF4KG8sIGMpLFxuICAgICAgICBtYXg6IGgsXG4gICAgfTtcbn1cbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGliID0gcmVxdWlyZSgnLi4vLi4vbGliJyk7XG52YXIgQ29sb3IgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzL2NvbG9yJyk7XG52YXIgaGFuZGxlT0hMQyA9IHJlcXVpcmUoJy4uL29obGMvb2hsY19kZWZhdWx0cycpO1xudmFyIGF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdXBwbHlEZWZhdWx0cyh0cmFjZUluLCB0cmFjZU91dCwgZGVmYXVsdENvbG9yLCBsYXlvdXQpIHtcbiAgICBmdW5jdGlvbiBjb2VyY2UoYXR0ciwgZGZsdCkge1xuICAgICAgICByZXR1cm4gTGliLmNvZXJjZSh0cmFjZUluLCB0cmFjZU91dCwgYXR0cmlidXRlcywgYXR0ciwgZGZsdCk7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGhhbmRsZU9ITEModHJhY2VJbiwgdHJhY2VPdXQsIGNvZXJjZSwgbGF5b3V0KTtcbiAgICBpZighbGVuKSB7XG4gICAgICAgIHRyYWNlT3V0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvZXJjZSgnbGluZS53aWR0aCcpO1xuXG4gICAgaGFuZGxlRGlyZWN0aW9uKHRyYWNlSW4sIHRyYWNlT3V0LCBjb2VyY2UsICdpbmNyZWFzaW5nJyk7XG4gICAgaGFuZGxlRGlyZWN0aW9uKHRyYWNlSW4sIHRyYWNlT3V0LCBjb2VyY2UsICdkZWNyZWFzaW5nJyk7XG5cbiAgICBjb2VyY2UoJ3RleHQnKTtcbiAgICBjb2VyY2UoJ2hvdmVydGV4dCcpO1xuICAgIGNvZXJjZSgnd2hpc2tlcndpZHRoJyk7XG5cbiAgICBsYXlvdXQuX3JlcXVlc3RSYW5nZXNsaWRlclt0cmFjZU91dC54YXhpc10gPSB0cnVlO1xufTtcblxuZnVuY3Rpb24gaGFuZGxlRGlyZWN0aW9uKHRyYWNlSW4sIHRyYWNlT3V0LCBjb2VyY2UsIGRpcmVjdGlvbikge1xuICAgIHZhciBsaW5lQ29sb3IgPSBjb2VyY2UoZGlyZWN0aW9uICsgJy5saW5lLmNvbG9yJyk7XG4gICAgY29lcmNlKGRpcmVjdGlvbiArICcubGluZS53aWR0aCcsIHRyYWNlT3V0LmxpbmUud2lkdGgpO1xuICAgIGNvZXJjZShkaXJlY3Rpb24gKyAnLmZpbGxjb2xvcicsIENvbG9yLmFkZE9wYWNpdHkobGluZUNvbG9yLCAwLjUpKTtcbn1cbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbW9kdWxlVHlwZTogJ3RyYWNlJyxcbiAgICBuYW1lOiAnY2FuZGxlc3RpY2snLFxuICAgIGJhc2VQbG90TW9kdWxlOiByZXF1aXJlKCcuLi8uLi9wbG90cy9jYXJ0ZXNpYW4nKSxcbiAgICBjYXRlZ29yaWVzOiBbJ2NhcnRlc2lhbicsICdzdmcnLCAnc2hvd0xlZ2VuZCcsICdjYW5kbGVzdGljaycsICdib3hMYXlvdXQnXSxcbiAgICBtZXRhOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnVGhlIGNhbmRsZXN0aWNrIGlzIGEgc3R5bGUgb2YgZmluYW5jaWFsIGNoYXJ0IGRlc2NyaWJpbmcnLFxuICAgICAgICAgICAgJ29wZW4sIGhpZ2gsIGxvdyBhbmQgY2xvc2UgZm9yIGEgZ2l2ZW4gYHhgIGNvb3JkaW5hdGUgKG1vc3QgbGlrZWx5IHRpbWUpLicsXG5cbiAgICAgICAgICAgICdUaGUgYm94ZXMgcmVwcmVzZW50IHRoZSBzcHJlYWQgYmV0d2VlbiB0aGUgYG9wZW5gIGFuZCBgY2xvc2VgIHZhbHVlcyBhbmQnLFxuICAgICAgICAgICAgJ3RoZSBsaW5lcyByZXByZXNlbnQgdGhlIHNwcmVhZCBiZXR3ZWVuIHRoZSBgbG93YCBhbmQgYGhpZ2hgIHZhbHVlcycsXG5cbiAgICAgICAgICAgICdTYW1wbGUgcG9pbnRzIHdoZXJlIHRoZSBjbG9zZSB2YWx1ZSBpcyBoaWdoZXIgKGxvd2VyKSB0aGVuIHRoZSBvcGVuJyxcbiAgICAgICAgICAgICd2YWx1ZSBhcmUgY2FsbGVkIGluY3JlYXNpbmcgKGRlY3JlYXNpbmcpLicsXG5cbiAgICAgICAgICAgICdCeSBkZWZhdWx0LCBpbmNyZWFzaW5nIGNhbmRsZXMgYXJlIGRyYXduIGluIGdyZWVuIHdoZXJlYXMnLFxuICAgICAgICAgICAgJ2RlY3JlYXNpbmcgYXJlIGRyYXduIGluIHJlZC4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcblxuICAgIGF0dHJpYnV0ZXM6IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpLFxuICAgIGxheW91dEF0dHJpYnV0ZXM6IHJlcXVpcmUoJy4uL2JveC9sYXlvdXRfYXR0cmlidXRlcycpLFxuICAgIHN1cHBseUxheW91dERlZmF1bHRzOiByZXF1aXJlKCcuLi9ib3gvbGF5b3V0X2RlZmF1bHRzJykuc3VwcGx5TGF5b3V0RGVmYXVsdHMsXG4gICAgY3Jvc3NUcmFjZUNhbGM6IHJlcXVpcmUoJy4uL2JveC9jcm9zc190cmFjZV9jYWxjJykuY3Jvc3NUcmFjZUNhbGMsXG4gICAgc3VwcGx5RGVmYXVsdHM6IHJlcXVpcmUoJy4vZGVmYXVsdHMnKSxcbiAgICBjYWxjOiByZXF1aXJlKCcuL2NhbGMnKSxcbiAgICBwbG90OiByZXF1aXJlKCcuLi9ib3gvcGxvdCcpLnBsb3QsXG4gICAgbGF5ZXJOYW1lOiAnYm94bGF5ZXInLFxuICAgIHN0eWxlOiByZXF1aXJlKCcuLi9ib3gvc3R5bGUnKS5zdHlsZSxcbiAgICBob3ZlclBvaW50czogcmVxdWlyZSgnLi4vb2hsYy9ob3ZlcicpLmhvdmVyUG9pbnRzLFxuICAgIHNlbGVjdFBvaW50czogcmVxdWlyZSgnLi4vb2hsYy9zZWxlY3QnKVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xudmFyIGNvbG9yc2NhbGVEZWZhdWx0cyA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMvY29sb3JzY2FsZS9kZWZhdWx0cycpO1xudmFyIGF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdXBwbHlEZWZhdWx0cyh0cmFjZUluLCB0cmFjZU91dCwgZGVmYXVsdENvbG9yLCBsYXlvdXQpIHtcbiAgICBmdW5jdGlvbiBjb2VyY2UoYXR0ciwgZGZsdCkge1xuICAgICAgICByZXR1cm4gTGliLmNvZXJjZSh0cmFjZUluLCB0cmFjZU91dCwgYXR0cmlidXRlcywgYXR0ciwgZGZsdCk7XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9ucyA9IGNvZXJjZSgnbG9jYXRpb25zJyk7XG4gICAgdmFyIHogPSBjb2VyY2UoJ3onKTtcblxuICAgIGlmKCEobG9jYXRpb25zICYmIGxvY2F0aW9ucy5sZW5ndGggJiYgTGliLmlzQXJyYXlPclR5cGVkQXJyYXkoeikgJiYgei5sZW5ndGgpKSB7XG4gICAgICAgIHRyYWNlT3V0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyYWNlT3V0Ll9sZW5ndGggPSBNYXRoLm1pbihsb2NhdGlvbnMubGVuZ3RoLCB6Lmxlbmd0aCk7XG5cbiAgICB2YXIgZ2VvanNvbiA9IGNvZXJjZSgnZ2VvanNvbicpO1xuXG4gICAgdmFyIGxvY2F0aW9ubW9kZURmbHQ7XG4gICAgaWYoKHR5cGVvZiBnZW9qc29uID09PSAnc3RyaW5nJyAmJiBnZW9qc29uICE9PSAnJykgfHwgTGliLmlzUGxhaW5PYmplY3QoZ2VvanNvbikpIHtcbiAgICAgICAgbG9jYXRpb25tb2RlRGZsdCA9ICdnZW9qc29uLWlkJztcbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb25Nb2RlID0gY29lcmNlKCdsb2NhdGlvbm1vZGUnLCBsb2NhdGlvbm1vZGVEZmx0KTtcblxuICAgIGlmKGxvY2F0aW9uTW9kZSA9PT0gJ2dlb2pzb24taWQnKSB7XG4gICAgICAgIGNvZXJjZSgnZmVhdHVyZWlka2V5Jyk7XG4gICAgfVxuXG4gICAgY29lcmNlKCd0ZXh0Jyk7XG4gICAgY29lcmNlKCdob3ZlcnRleHQnKTtcbiAgICBjb2VyY2UoJ2hvdmVydGVtcGxhdGUnKTtcblxuICAgIHZhciBtbHcgPSBjb2VyY2UoJ21hcmtlci5saW5lLndpZHRoJyk7XG4gICAgaWYobWx3KSBjb2VyY2UoJ21hcmtlci5saW5lLmNvbG9yJyk7XG4gICAgY29lcmNlKCdtYXJrZXIub3BhY2l0eScpO1xuXG4gICAgY29sb3JzY2FsZURlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCBsYXlvdXQsIGNvZXJjZSwge3ByZWZpeDogJycsIGNMZXR0ZXI6ICd6J30pO1xuXG4gICAgTGliLmNvZXJjZVNlbGVjdGlvbk1hcmtlck9wYWNpdHkodHJhY2VPdXQsIGNvZXJjZSk7XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhdHRyaWJ1dGVzOiByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKSxcbiAgICBzdXBwbHlEZWZhdWx0czogcmVxdWlyZSgnLi9kZWZhdWx0cycpLFxuICAgIGNvbG9yYmFyOiByZXF1aXJlKCcuLi9oZWF0bWFwL2NvbG9yYmFyJyksXG4gICAgY2FsYzogcmVxdWlyZSgnLi9jYWxjJyksXG4gICAgY2FsY0dlb0pTT046IHJlcXVpcmUoJy4vcGxvdCcpLmNhbGNHZW9KU09OLFxuICAgIHBsb3Q6IHJlcXVpcmUoJy4vcGxvdCcpLnBsb3QsXG4gICAgc3R5bGU6IHJlcXVpcmUoJy4vc3R5bGUnKS5zdHlsZSxcbiAgICBzdHlsZU9uU2VsZWN0OiByZXF1aXJlKCcuL3N0eWxlJykuc3R5bGVPblNlbGVjdCxcbiAgICBob3ZlclBvaW50czogcmVxdWlyZSgnLi9ob3ZlcicpLFxuICAgIGV2ZW50RGF0YTogcmVxdWlyZSgnLi9ldmVudF9kYXRhJyksXG4gICAgc2VsZWN0UG9pbnRzOiByZXF1aXJlKCcuL3NlbGVjdCcpLFxuXG4gICAgbW9kdWxlVHlwZTogJ3RyYWNlJyxcbiAgICBuYW1lOiAnY2hvcm9wbGV0aCcsXG4gICAgYmFzZVBsb3RNb2R1bGU6IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2dlbycpLFxuICAgIGNhdGVnb3JpZXM6IFsnZ2VvJywgJ25vT3BhY2l0eScsICdzaG93TGVnZW5kJ10sXG4gICAgbWV0YToge1xuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1RoZSBkYXRhIHRoYXQgZGVzY3JpYmVzIHRoZSBjaG9yb3BsZXRoIHZhbHVlLXRvLWNvbG9yIG1hcHBpbmcnLFxuICAgICAgICAgICAgJ2lzIHNldCBpbiBgemAuJyxcbiAgICAgICAgICAgICdUaGUgZ2VvZ3JhcGhpYyBsb2NhdGlvbnMgY29ycmVzcG9uZGluZyB0byBlYWNoIHZhbHVlIGluIGB6YCcsXG4gICAgICAgICAgICAnYXJlIHNldCBpbiBgbG9jYXRpb25zYC4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGQzID0gcmVxdWlyZSgnZDMnKTtcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xudmFyIGdlb1V0aWxzID0gcmVxdWlyZSgnLi4vLi4vbGliL2dlb19sb2NhdGlvbl91dGlscycpO1xudmFyIGdldFRvcG9qc29uRmVhdHVyZXMgPSByZXF1aXJlKCcuLi8uLi9saWIvdG9wb2pzb25fdXRpbHMnKS5nZXRUb3BvanNvbkZlYXR1cmVzO1xudmFyIGZpbmRFeHRyZW1lcyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2NhcnRlc2lhbi9hdXRvcmFuZ2UnKS5maW5kRXh0cmVtZXM7XG5cbnZhciBzdHlsZSA9IHJlcXVpcmUoJy4vc3R5bGUnKS5zdHlsZTtcblxuZnVuY3Rpb24gcGxvdChnZCwgZ2VvLCBjYWxjRGF0YSkge1xuICAgIHZhciBjaG9yb3BsZXRoTGF5ZXIgPSBnZW8ubGF5ZXJzLmJhY2twbG90LnNlbGVjdCgnLmNob3JvcGxldGhsYXllcicpO1xuXG4gICAgTGliLm1ha2VUcmFjZUdyb3VwcyhjaG9yb3BsZXRoTGF5ZXIsIGNhbGNEYXRhLCAndHJhY2UgY2hvcm9wbGV0aCcpLmVhY2goZnVuY3Rpb24oY2FsY1RyYWNlKSB7XG4gICAgICAgIHZhciBzZWwgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgdmFyIHBhdGhzID0gc2VsLnNlbGVjdEFsbCgncGF0aC5jaG9yb3BsZXRobG9jYXRpb24nKVxuICAgICAgICAgICAgLmRhdGEoTGliLmlkZW50aXR5KTtcblxuICAgICAgICBwYXRocy5lbnRlcigpLmFwcGVuZCgncGF0aCcpXG4gICAgICAgICAgICAuY2xhc3NlZCgnY2hvcm9wbGV0aGxvY2F0aW9uJywgdHJ1ZSk7XG5cbiAgICAgICAgcGF0aHMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vIGNhbGwgc3R5bGUgaGVyZSB3aXRoaW4gdG9wb2pzb24gcmVxdWVzdCBjYWxsYmFja1xuICAgICAgICBzdHlsZShnZCwgY2FsY1RyYWNlKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY2FsY0dlb0pTT04oY2FsY1RyYWNlLCBmdWxsTGF5b3V0KSB7XG4gICAgdmFyIHRyYWNlID0gY2FsY1RyYWNlWzBdLnRyYWNlO1xuICAgIHZhciBnZW9MYXlvdXQgPSBmdWxsTGF5b3V0W3RyYWNlLmdlb107XG4gICAgdmFyIGdlbyA9IGdlb0xheW91dC5fc3VicGxvdDtcbiAgICB2YXIgbG9jYXRpb25tb2RlID0gdHJhY2UubG9jYXRpb25tb2RlO1xuICAgIHZhciBsZW4gPSB0cmFjZS5fbGVuZ3RoO1xuXG4gICAgdmFyIGZlYXR1cmVzID0gbG9jYXRpb25tb2RlID09PSAnZ2VvanNvbi1pZCcgP1xuICAgICAgICBnZW9VdGlscy5leHRyYWN0VHJhY2VGZWF0dXJlKGNhbGNUcmFjZSkgOlxuICAgICAgICBnZXRUb3BvanNvbkZlYXR1cmVzKHRyYWNlLCBnZW8udG9wb2pzb24pO1xuXG4gICAgdmFyIGxvbkFycmF5ID0gW107XG4gICAgdmFyIGxhdEFycmF5ID0gW107XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGNhbGNQdCA9IGNhbGNUcmFjZVtpXTtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBsb2NhdGlvbm1vZGUgPT09ICdnZW9qc29uLWlkJyA/XG4gICAgICAgICAgICBjYWxjUHQuZk91dCA6XG4gICAgICAgICAgICBnZW9VdGlscy5sb2NhdGlvblRvRmVhdHVyZShsb2NhdGlvbm1vZGUsIGNhbGNQdC5sb2MsIGZlYXR1cmVzKTtcblxuICAgICAgICBpZihmZWF0dXJlKSB7XG4gICAgICAgICAgICBjYWxjUHQuZ2VvanNvbiA9IGZlYXR1cmU7XG4gICAgICAgICAgICBjYWxjUHQuY3QgPSBmZWF0dXJlLnByb3BlcnRpZXMuY3Q7XG4gICAgICAgICAgICBjYWxjUHQuX3BvbHlnb25zID0gZ2VvVXRpbHMuZmVhdHVyZTJwb2x5Z29ucyhmZWF0dXJlKTtcblxuICAgICAgICAgICAgdmFyIGJib3hGZWF0dXJlID0gZ2VvVXRpbHMuY29tcHV0ZUJib3goZmVhdHVyZSk7XG4gICAgICAgICAgICBsb25BcnJheS5wdXNoKGJib3hGZWF0dXJlWzBdLCBiYm94RmVhdHVyZVsyXSk7XG4gICAgICAgICAgICBsYXRBcnJheS5wdXNoKGJib3hGZWF0dXJlWzFdLCBiYm94RmVhdHVyZVszXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxjUHQuZ2VvanNvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihnZW9MYXlvdXQuZml0Ym91bmRzID09PSAnZ2VvanNvbicgJiYgbG9jYXRpb25tb2RlID09PSAnZ2VvanNvbi1pZCcpIHtcbiAgICAgICAgdmFyIGJib3hHZW9qc29uID0gZ2VvVXRpbHMuY29tcHV0ZUJib3goZ2VvVXRpbHMuZ2V0VHJhY2VHZW9qc29uKHRyYWNlKSk7XG4gICAgICAgIGxvbkFycmF5ID0gW2Jib3hHZW9qc29uWzBdLCBiYm94R2VvanNvblsyXV07XG4gICAgICAgIGxhdEFycmF5ID0gW2Jib3hHZW9qc29uWzFdLCBiYm94R2VvanNvblszXV07XG4gICAgfVxuXG4gICAgdmFyIG9wdHMgPSB7cGFkZGVkOiB0cnVlfTtcbiAgICB0cmFjZS5fZXh0cmVtZXMubG9uID0gZmluZEV4dHJlbWVzKGdlb0xheW91dC5sb25heGlzLl9heCwgbG9uQXJyYXksIG9wdHMpO1xuICAgIHRyYWNlLl9leHRyZW1lcy5sYXQgPSBmaW5kRXh0cmVtZXMoZ2VvTGF5b3V0LmxhdGF4aXMuX2F4LCBsYXRBcnJheSwgb3B0cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNhbGNHZW9KU09OOiBjYWxjR2VvSlNPTixcbiAgICBwbG90OiBwbG90XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZDMgPSByZXF1aXJlKCdkMycpO1xudmFyIENvbG9yID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50cy9jb2xvcicpO1xudmFyIERyYXdpbmcgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzL2RyYXdpbmcnKTtcbnZhciBDb2xvcnNjYWxlID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50cy9jb2xvcnNjYWxlJyk7XG5cbmZ1bmN0aW9uIHN0eWxlKGdkLCBjYWxjVHJhY2UpIHtcbiAgICBpZihjYWxjVHJhY2UpIHN0eWxlVHJhY2UoZ2QsIGNhbGNUcmFjZSk7XG59XG5cbmZ1bmN0aW9uIHN0eWxlVHJhY2UoZ2QsIGNhbGNUcmFjZSkge1xuICAgIHZhciB0cmFjZSA9IGNhbGNUcmFjZVswXS50cmFjZTtcbiAgICB2YXIgcyA9IGNhbGNUcmFjZVswXS5ub2RlMztcbiAgICB2YXIgbG9jcyA9IHMuc2VsZWN0QWxsKCcuY2hvcm9wbGV0aGxvY2F0aW9uJyk7XG4gICAgdmFyIG1hcmtlciA9IHRyYWNlLm1hcmtlciB8fCB7fTtcbiAgICB2YXIgbWFya2VyTGluZSA9IG1hcmtlci5saW5lIHx8IHt9O1xuXG4gICAgdmFyIHNjbEZ1bmMgPSBDb2xvcnNjYWxlLm1ha2VDb2xvclNjYWxlRnVuY0Zyb21UcmFjZSh0cmFjZSk7XG5cbiAgICBsb2NzLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgc2NsRnVuYyhkLnopKVxuICAgICAgICAgICAgLmNhbGwoQ29sb3Iuc3Ryb2tlLCBkLm1sYyB8fCBtYXJrZXJMaW5lLmNvbG9yKVxuICAgICAgICAgICAgLmNhbGwoRHJhd2luZy5kYXNoTGluZSwgJycsIGQubWx3IHx8IG1hcmtlckxpbmUud2lkdGggfHwgMClcbiAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIG1hcmtlci5vcGFjaXR5KTtcbiAgICB9KTtcblxuICAgIERyYXdpbmcuc2VsZWN0ZWRQb2ludFN0eWxlKGxvY3MsIHRyYWNlLCBnZCk7XG59XG5cbmZ1bmN0aW9uIHN0eWxlT25TZWxlY3QoZ2QsIGNhbGNUcmFjZSkge1xuICAgIHZhciBzID0gY2FsY1RyYWNlWzBdLm5vZGUzO1xuICAgIHZhciB0cmFjZSA9IGNhbGNUcmFjZVswXS50cmFjZTtcblxuICAgIGlmKHRyYWNlLnNlbGVjdGVkcG9pbnRzKSB7XG4gICAgICAgIERyYXdpbmcuc2VsZWN0ZWRQb2ludFN0eWxlKHMuc2VsZWN0QWxsKCcuY2hvcm9wbGV0aGxvY2F0aW9uJyksIHRyYWNlLCBnZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVUcmFjZShnZCwgY2FsY1RyYWNlKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHN0eWxlOiBzdHlsZSxcbiAgICBzdHlsZU9uU2VsZWN0OiBzdHlsZU9uU2VsZWN0XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGliID0gcmVxdWlyZSgnLi4vLi4vbGliJyk7XG5cbnZhciBoYW5kbGVYWVpEZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2hlYXRtYXAveHl6X2RlZmF1bHRzJyk7XG52YXIgaGFuZGxlQ29uc3RyYWludERlZmF1bHRzID0gcmVxdWlyZSgnLi9jb25zdHJhaW50X2RlZmF1bHRzJyk7XG52YXIgaGFuZGxlQ29udG91cnNEZWZhdWx0cyA9IHJlcXVpcmUoJy4vY29udG91cnNfZGVmYXVsdHMnKTtcbnZhciBoYW5kbGVTdHlsZURlZmF1bHRzID0gcmVxdWlyZSgnLi9zdHlsZV9kZWZhdWx0cycpO1xudmFyIGF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN1cHBseURlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCBkZWZhdWx0Q29sb3IsIGxheW91dCkge1xuICAgIGZ1bmN0aW9uIGNvZXJjZShhdHRyLCBkZmx0KSB7XG4gICAgICAgIHJldHVybiBMaWIuY29lcmNlKHRyYWNlSW4sIHRyYWNlT3V0LCBhdHRyaWJ1dGVzLCBhdHRyLCBkZmx0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2VyY2UyKGF0dHIpIHtcbiAgICAgICAgcmV0dXJuIExpYi5jb2VyY2UyKHRyYWNlSW4sIHRyYWNlT3V0LCBhdHRyaWJ1dGVzLCBhdHRyKTtcbiAgICB9XG5cbiAgICB2YXIgbGVuID0gaGFuZGxlWFlaRGVmYXVsdHModHJhY2VJbiwgdHJhY2VPdXQsIGNvZXJjZSwgbGF5b3V0KTtcbiAgICBpZighbGVuKSB7XG4gICAgICAgIHRyYWNlT3V0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvZXJjZSgndGV4dCcpO1xuICAgIGNvZXJjZSgnaG92ZXJ0ZXh0Jyk7XG4gICAgY29lcmNlKCdob3ZlcnRlbXBsYXRlJyk7XG4gICAgY29lcmNlKCdob3Zlcm9uZ2FwcycpO1xuXG4gICAgdmFyIGlzQ29uc3RyYWludCA9IChjb2VyY2UoJ2NvbnRvdXJzLnR5cGUnKSA9PT0gJ2NvbnN0cmFpbnQnKTtcbiAgICBjb2VyY2UoJ2Nvbm5lY3RnYXBzJywgTGliLmlzQXJyYXkxRCh0cmFjZU91dC56KSk7XG5cbiAgICBpZihpc0NvbnN0cmFpbnQpIHtcbiAgICAgICAgaGFuZGxlQ29uc3RyYWludERlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCBjb2VyY2UsIGxheW91dCwgZGVmYXVsdENvbG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVDb250b3Vyc0RlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCBjb2VyY2UsIGNvZXJjZTIpO1xuICAgICAgICBoYW5kbGVTdHlsZURlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCBjb2VyY2UsIGxheW91dCk7XG4gICAgfVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXR0cmlidXRlczogcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyksXG4gICAgc3VwcGx5RGVmYXVsdHM6IHJlcXVpcmUoJy4vZGVmYXVsdHMnKSxcbiAgICBjYWxjOiByZXF1aXJlKCcuL2NhbGMnKSxcbiAgICBwbG90OiByZXF1aXJlKCcuL3Bsb3QnKS5wbG90LFxuICAgIHN0eWxlOiByZXF1aXJlKCcuL3N0eWxlJyksXG4gICAgY29sb3JiYXI6IHJlcXVpcmUoJy4vY29sb3JiYXInKSxcbiAgICBob3ZlclBvaW50czogcmVxdWlyZSgnLi9ob3ZlcicpLFxuXG4gICAgbW9kdWxlVHlwZTogJ3RyYWNlJyxcbiAgICBuYW1lOiAnY29udG91cicsXG4gICAgYmFzZVBsb3RNb2R1bGU6IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2NhcnRlc2lhbicpLFxuICAgIGNhdGVnb3JpZXM6IFsnY2FydGVzaWFuJywgJ3N2ZycsICcyZE1hcCcsICdjb250b3VyJywgJ3Nob3dMZWdlbmQnXSxcbiAgICBtZXRhOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnVGhlIGRhdGEgZnJvbSB3aGljaCBjb250b3VyIGxpbmVzIGFyZSBjb21wdXRlZCBpcyBzZXQgaW4gYHpgLicsXG4gICAgICAgICAgICAnRGF0YSBpbiBgemAgbXVzdCBiZSBhIHsyRCBhcnJheX0gb2YgbnVtYmVycy4nLFxuXG4gICAgICAgICAgICAnU2F5IHRoYXQgYHpgIGhhcyBOIHJvd3MgYW5kIE0gY29sdW1ucywgdGhlbiBieSBkZWZhdWx0LCcsXG4gICAgICAgICAgICAndGhlc2UgTiByb3dzIGNvcnJlc3BvbmQgdG8gTiB5IGNvb3JkaW5hdGVzJyxcbiAgICAgICAgICAgICcoc2V0IGluIGB5YCBvciBhdXRvLWdlbmVyYXRlZCkgYW5kIHRoZSBNIGNvbHVtbnMnLFxuICAgICAgICAgICAgJ2NvcnJlc3BvbmQgdG8gTSB4IGNvb3JkaW5hdGVzIChzZXQgaW4gYHhgIG9yIGF1dG8tZ2VuZXJhdGVkKS4nLFxuICAgICAgICAgICAgJ0J5IHNldHRpbmcgYHRyYW5zcG9zZWAgdG8gKnRydWUqLCB0aGUgYWJvdmUgYmVoYXZpb3IgaXMgZmxpcHBlZC4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGliID0gcmVxdWlyZSgnLi4vLi4vbGliJyk7XG5cbnZhciBoYW5kbGVYWVpEZWZhdWx0cyA9IHJlcXVpcmUoJy4veHl6X2RlZmF1bHRzJyk7XG52YXIgaGFuZGxlU3R5bGVEZWZhdWx0cyA9IHJlcXVpcmUoJy4vc3R5bGVfZGVmYXVsdHMnKTtcbnZhciBjb2xvcnNjYWxlRGVmYXVsdHMgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzL2NvbG9yc2NhbGUvZGVmYXVsdHMnKTtcbnZhciBhdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdXBwbHlEZWZhdWx0cyh0cmFjZUluLCB0cmFjZU91dCwgZGVmYXVsdENvbG9yLCBsYXlvdXQpIHtcbiAgICBmdW5jdGlvbiBjb2VyY2UoYXR0ciwgZGZsdCkge1xuICAgICAgICByZXR1cm4gTGliLmNvZXJjZSh0cmFjZUluLCB0cmFjZU91dCwgYXR0cmlidXRlcywgYXR0ciwgZGZsdCk7XG4gICAgfVxuXG4gICAgdmFyIHZhbGlkRGF0YSA9IGhhbmRsZVhZWkRlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCBjb2VyY2UsIGxheW91dCk7XG4gICAgaWYoIXZhbGlkRGF0YSkge1xuICAgICAgICB0cmFjZU91dC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb2VyY2UoJ3RleHQnKTtcbiAgICBjb2VyY2UoJ2hvdmVydGV4dCcpO1xuICAgIGNvZXJjZSgnaG92ZXJ0ZW1wbGF0ZScpO1xuXG4gICAgaGFuZGxlU3R5bGVEZWZhdWx0cyh0cmFjZUluLCB0cmFjZU91dCwgY29lcmNlLCBsYXlvdXQpO1xuXG4gICAgY29lcmNlKCdob3Zlcm9uZ2FwcycpO1xuICAgIGNvZXJjZSgnY29ubmVjdGdhcHMnLCBMaWIuaXNBcnJheTFEKHRyYWNlT3V0LnopICYmICh0cmFjZU91dC56c21vb3RoICE9PSBmYWxzZSkpO1xuXG4gICAgY29sb3JzY2FsZURlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCBsYXlvdXQsIGNvZXJjZSwge3ByZWZpeDogJycsIGNMZXR0ZXI6ICd6J30pO1xufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXR0cmlidXRlczogcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyksXG4gICAgc3VwcGx5RGVmYXVsdHM6IHJlcXVpcmUoJy4vZGVmYXVsdHMnKSxcbiAgICBjYWxjOiByZXF1aXJlKCcuL2NhbGMnKSxcbiAgICBwbG90OiByZXF1aXJlKCcuL3Bsb3QnKSxcbiAgICBjb2xvcmJhcjogcmVxdWlyZSgnLi9jb2xvcmJhcicpLFxuICAgIHN0eWxlOiByZXF1aXJlKCcuL3N0eWxlJyksXG4gICAgaG92ZXJQb2ludHM6IHJlcXVpcmUoJy4vaG92ZXInKSxcblxuICAgIG1vZHVsZVR5cGU6ICd0cmFjZScsXG4gICAgbmFtZTogJ2hlYXRtYXAnLFxuICAgIGJhc2VQbG90TW9kdWxlOiByZXF1aXJlKCcuLi8uLi9wbG90cy9jYXJ0ZXNpYW4nKSxcbiAgICBjYXRlZ29yaWVzOiBbJ2NhcnRlc2lhbicsICdzdmcnLCAnMmRNYXAnLCAnc2hvd0xlZ2VuZCddLFxuICAgIG1ldGE6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdUaGUgZGF0YSB0aGF0IGRlc2NyaWJlcyB0aGUgaGVhdG1hcCB2YWx1ZS10by1jb2xvciBtYXBwaW5nJyxcbiAgICAgICAgICAgICdpcyBzZXQgaW4gYHpgLicsXG4gICAgICAgICAgICAnRGF0YSBpbiBgemAgY2FuIGVpdGhlciBiZSBhIHsyRCBhcnJheX0gb2YgdmFsdWVzIChyYWdnZWQgb3Igbm90KScsXG4gICAgICAgICAgICAnb3IgYSAxRCBhcnJheSBvZiB2YWx1ZXMuJyxcblxuICAgICAgICAgICAgJ0luIHRoZSBjYXNlIHdoZXJlIGB6YCBpcyBhIHsyRCBhcnJheX0sJyxcbiAgICAgICAgICAgICdzYXkgdGhhdCBgemAgaGFzIE4gcm93cyBhbmQgTSBjb2x1bW5zLicsXG4gICAgICAgICAgICAnVGhlbiwgYnkgZGVmYXVsdCwgdGhlIHJlc3VsdGluZyBoZWF0bWFwIHdpbGwgaGF2ZSBOIHBhcnRpdGlvbnMgYWxvbmcnLFxuICAgICAgICAgICAgJ3RoZSB5IGF4aXMgYW5kIE0gcGFydGl0aW9ucyBhbG9uZyB0aGUgeCBheGlzLicsXG4gICAgICAgICAgICAnSW4gb3RoZXIgd29yZHMsIHRoZSBpLXRoIHJvdy8gai10aCBjb2x1bW4gY2VsbCBpbiBgemAnLFxuICAgICAgICAgICAgJ2lzIG1hcHBlZCB0byB0aGUgaS10aCBwYXJ0aXRpb24gb2YgdGhlIHkgYXhpcycsXG4gICAgICAgICAgICAnKHN0YXJ0aW5nIGZyb20gdGhlIGJvdHRvbSBvZiB0aGUgcGxvdCkgYW5kIHRoZSBqLXRoIHBhcnRpdGlvbicsXG4gICAgICAgICAgICAnb2YgdGhlIHgtYXhpcyAoc3RhcnRpbmcgZnJvbSB0aGUgbGVmdCBvZiB0aGUgcGxvdCkuJyxcbiAgICAgICAgICAgICdUaGlzIGJlaGF2aW9yIGNhbiBiZSBmbGlwcGVkIGJ5IHVzaW5nIGB0cmFuc3Bvc2VgLicsXG4gICAgICAgICAgICAnTW9yZW92ZXIsIGB4YCAoYHlgKSBjYW4gYmUgcHJvdmlkZWQgd2l0aCBNIG9yIE0rMSAoTiBvciBOKzEpIGVsZW1lbnRzLicsXG4gICAgICAgICAgICAnSWYgTSAoTiksIHRoZW4gdGhlIGNvb3JkaW5hdGVzIGNvcnJlc3BvbmQgdG8gdGhlIGNlbnRlciBvZiB0aGUnLFxuICAgICAgICAgICAgJ2hlYXRtYXAgY2VsbHMgYW5kIHRoZSBjZWxscyBoYXZlIGVxdWFsIHdpZHRoLicsXG4gICAgICAgICAgICAnSWYgTSsxIChOKzEpLCB0aGVuIHRoZSBjb29yZGluYXRlcyBjb3JyZXNwb25kIHRvIHRoZSBlZGdlcyBvZiB0aGUnLFxuICAgICAgICAgICAgJ2hlYXRtYXAgY2VsbHMuJyxcblxuICAgICAgICAgICAgJ0luIHRoZSBjYXNlIHdoZXJlIGB6YCBpcyBhIDFEIHthcnJheX0sIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG11c3QgYmUnLFxuICAgICAgICAgICAgJ3Byb3ZpZGVkIGluIGB4YCBhbmQgYHlgIHJlc3BlY3RpdmVseSB0byBmb3JtIGRhdGEgdHJpcGxldHMuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH1cbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYW5kbGVTdHlsZURlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCBjb2VyY2UpIHtcbiAgICB2YXIgenNtb290aCA9IGNvZXJjZSgnenNtb290aCcpO1xuICAgIGlmKHpzbW9vdGggPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHhnYXAgYW5kIHlnYXAgYXJlIGNvZXJjZWQgb25seSB3aGVuIHpzbW9vdGggYWxsb3dzIHRoZW0gdG8gaGF2ZSBhbiBlZmZlY3QuXG4gICAgICAgIGNvZXJjZSgneGdhcCcpO1xuICAgICAgICBjb2VyY2UoJ3lnYXAnKTtcbiAgICB9XG5cbiAgICBjb2VyY2UoJ3pob3ZlcmZvcm1hdCcpO1xufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhlYXRtYXBBdHRycyA9IHJlcXVpcmUoJy4uL2hlYXRtYXAvYXR0cmlidXRlcycpO1xudmFyIGNvbG9yU2NhbGVBdHRycyA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMvY29sb3JzY2FsZS9hdHRyaWJ1dGVzJyk7XG5cbnZhciBleHRlbmRGbGF0ID0gcmVxdWlyZSgnLi4vLi4vbGliL2V4dGVuZCcpLmV4dGVuZEZsYXQ7XG52YXIgb3ZlcnJpZGVBbGwgPSByZXF1aXJlKCcuLi8uLi9wbG90X2FwaS9lZGl0X3R5cGVzJykub3ZlcnJpZGVBbGw7XG5cbnZhciBjb21tb25MaXN0ID0gW1xuICAgICd6JyxcbiAgICAneCcsICd4MCcsICdkeCcsXG4gICAgJ3knLCAneTAnLCAnZHknLFxuICAgICd0ZXh0JywgJ3RyYW5zcG9zZScsXG4gICAgJ3h0eXBlJywgJ3l0eXBlJ1xuXTtcblxudmFyIGF0dHJzID0ge307XG5cbmZvcih2YXIgaSA9IDA7IGkgPCBjb21tb25MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGsgPSBjb21tb25MaXN0W2ldO1xuICAgIGF0dHJzW2tdID0gaGVhdG1hcEF0dHJzW2tdO1xufVxuXG5leHRlbmRGbGF0KFxuICAgIGF0dHJzLFxuICAgIGNvbG9yU2NhbGVBdHRycygnJywge2NMZXR0ZXI6ICd6JywgYXV0b0NvbG9yRGZsdDogZmFsc2V9KVxuKTtcblxubW9kdWxlLmV4cG9ydHMgPSBvdmVycmlkZUFsbChhdHRycywgJ2NhbGMnLCAnbmVzdGVkJyk7XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUhlYXRtYXAyRCA9IHJlcXVpcmUoJ2dsLWhlYXRtYXAyZCcpO1xudmFyIEF4ZXMgPSByZXF1aXJlKCcuLi8uLi9wbG90cy9jYXJ0ZXNpYW4vYXhlcycpO1xudmFyIHN0cjJSR0JBcnJheSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9zdHIycmdiYXJyYXknKTtcblxuXG5mdW5jdGlvbiBIZWF0bWFwKHNjZW5lLCB1aWQpIHtcbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgdGhpcy51aWQgPSB1aWQ7XG4gICAgdGhpcy50eXBlID0gJ2hlYXRtYXBnbCc7XG5cbiAgICB0aGlzLm5hbWUgPSAnJztcbiAgICB0aGlzLmhvdmVyaW5mbyA9ICdhbGwnO1xuXG4gICAgdGhpcy54RGF0YSA9IFtdO1xuICAgIHRoaXMueURhdGEgPSBbXTtcbiAgICB0aGlzLnpEYXRhID0gW107XG4gICAgdGhpcy50ZXh0TGFiZWxzID0gW107XG5cbiAgICB0aGlzLmlkVG9JbmRleCA9IFtdO1xuICAgIHRoaXMuYm91bmRzID0gWzAsIDAsIDAsIDBdO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICB6OiBbXSxcbiAgICAgICAgeDogW10sXG4gICAgICAgIHk6IFtdLFxuICAgICAgICBzaGFwZTogWzAsIDBdLFxuICAgICAgICBjb2xvckxldmVsczogWzBdLFxuICAgICAgICBjb2xvclZhbHVlczogWzAsIDAsIDAsIDFdXG4gICAgfTtcblxuICAgIHRoaXMuaGVhdG1hcCA9IGNyZWF0ZUhlYXRtYXAyRChzY2VuZS5nbHBsb3QsIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5oZWF0bWFwLl90cmFjZSA9IHRoaXM7XG59XG5cbnZhciBwcm90byA9IEhlYXRtYXAucHJvdG90eXBlO1xuXG5wcm90by5oYW5kbGVQaWNrID0gZnVuY3Rpb24ocGlja1Jlc3VsdCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBzaGFwZSA9IG9wdGlvbnMuc2hhcGU7XG4gICAgdmFyIGluZGV4ID0gcGlja1Jlc3VsdC5wb2ludElkO1xuICAgIHZhciB4SW5kZXggPSBpbmRleCAlIHNoYXBlWzBdO1xuICAgIHZhciB5SW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gc2hhcGVbMF0pO1xuICAgIHZhciB6SW5kZXggPSBpbmRleDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRyYWNlOiB0aGlzLFxuICAgICAgICBkYXRhQ29vcmQ6IHBpY2tSZXN1bHQuZGF0YUNvb3JkLFxuICAgICAgICB0cmFjZUNvb3JkOiBbXG4gICAgICAgICAgICBvcHRpb25zLnhbeEluZGV4XSxcbiAgICAgICAgICAgIG9wdGlvbnMueVt5SW5kZXhdLFxuICAgICAgICAgICAgb3B0aW9ucy56W3pJbmRleF1cbiAgICAgICAgXSxcbiAgICAgICAgdGV4dExhYmVsOiB0aGlzLnRleHRMYWJlbHNbaW5kZXhdLFxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIHBvaW50SW5kZXg6IFt5SW5kZXgsIHhJbmRleF0sXG4gICAgICAgIGhvdmVyaW5mbzogdGhpcy5ob3ZlcmluZm9cbiAgICB9O1xufTtcblxucHJvdG8udXBkYXRlID0gZnVuY3Rpb24oZnVsbFRyYWNlLCBjYWxjVHJhY2UpIHtcbiAgICB2YXIgY2FsY1B0ID0gY2FsY1RyYWNlWzBdO1xuXG4gICAgdGhpcy5pbmRleCA9IGZ1bGxUcmFjZS5pbmRleDtcbiAgICB0aGlzLm5hbWUgPSBmdWxsVHJhY2UubmFtZTtcbiAgICB0aGlzLmhvdmVyaW5mbyA9IGZ1bGxUcmFjZS5ob3ZlcmluZm87XG5cbiAgICAvLyBjb252ZXJ0IHogZnJvbSAyRCAtPiAxRFxuICAgIHZhciB6ID0gY2FsY1B0Lno7XG4gICAgdGhpcy5vcHRpb25zLnogPSBbXS5jb25jYXQuYXBwbHkoW10sIHopO1xuXG4gICAgdmFyIHJvd0xlbiA9IHpbMF0ubGVuZ3RoO1xuICAgIHZhciBjb2xMZW4gPSB6Lmxlbmd0aDtcbiAgICB0aGlzLm9wdGlvbnMuc2hhcGUgPSBbcm93TGVuLCBjb2xMZW5dO1xuXG4gICAgdGhpcy5vcHRpb25zLnggPSBjYWxjUHQueDtcbiAgICB0aGlzLm9wdGlvbnMueSA9IGNhbGNQdC55O1xuXG4gICAgdmFyIGNvbG9yT3B0aW9ucyA9IGNvbnZlcnRDb2xvcnNjYWxlKGZ1bGxUcmFjZSk7XG4gICAgdGhpcy5vcHRpb25zLmNvbG9yTGV2ZWxzID0gY29sb3JPcHRpb25zLmNvbG9yTGV2ZWxzO1xuICAgIHRoaXMub3B0aW9ucy5jb2xvclZhbHVlcyA9IGNvbG9yT3B0aW9ucy5jb2xvclZhbHVlcztcblxuICAgIC8vIGNvbnZlcnQgdGV4dCBmcm9tIDJEIC0+IDFEXG4gICAgdGhpcy50ZXh0TGFiZWxzID0gW10uY29uY2F0LmFwcGx5KFtdLCBmdWxsVHJhY2UudGV4dCk7XG5cbiAgICB0aGlzLmhlYXRtYXAudXBkYXRlKHRoaXMub3B0aW9ucyk7XG5cbiAgICB2YXIgeGEgPSB0aGlzLnNjZW5lLnhheGlzO1xuICAgIHZhciB5YSA9IHRoaXMuc2NlbmUueWF4aXM7XG4gICAgZnVsbFRyYWNlLl9leHRyZW1lc1t4YS5faWRdID0gQXhlcy5maW5kRXh0cmVtZXMoeGEsIGNhbGNQdC54KTtcbiAgICBmdWxsVHJhY2UuX2V4dHJlbWVzW3lhLl9pZF0gPSBBeGVzLmZpbmRFeHRyZW1lcyh5YSwgY2FsY1B0LnkpO1xufTtcblxucHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGVhdG1hcC5kaXNwb3NlKCk7XG59O1xuXG5mdW5jdGlvbiBjb252ZXJ0Q29sb3JzY2FsZShmdWxsVHJhY2UpIHtcbiAgICB2YXIgc2NsID0gZnVsbFRyYWNlLmNvbG9yc2NhbGU7XG4gICAgdmFyIHptaW4gPSBmdWxsVHJhY2Uuem1pbjtcbiAgICB2YXIgem1heCA9IGZ1bGxUcmFjZS56bWF4O1xuXG4gICAgdmFyIE4gPSBzY2wubGVuZ3RoO1xuICAgIHZhciBkb21haW4gPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIHJhbmdlID0gbmV3IEFycmF5KDQgKiBOKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgdmFyIHNpID0gc2NsW2ldO1xuICAgICAgICB2YXIgY29sb3IgPSBzdHIyUkdCQXJyYXkoc2lbMV0pO1xuXG4gICAgICAgIGRvbWFpbltpXSA9IHptaW4gKyBzaVswXSAqICh6bWF4IC0gem1pbik7XG5cbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgcmFuZ2VbKDQgKiBpKSArIGpdID0gY29sb3Jbal07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb2xvckxldmVsczogZG9tYWluLFxuICAgICAgICBjb2xvclZhbHVlczogcmFuZ2VcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIZWF0bWFwKHNjZW5lLCBmdWxsVHJhY2UsIGNhbGNUcmFjZSkge1xuICAgIHZhciBwbG90ID0gbmV3IEhlYXRtYXAoc2NlbmUsIGZ1bGxUcmFjZS51aWQpO1xuICAgIHBsb3QudXBkYXRlKGZ1bGxUcmFjZSwgY2FsY1RyYWNlKTtcbiAgICByZXR1cm4gcGxvdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVIZWF0bWFwO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhdHRyaWJ1dGVzOiByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKSxcbiAgICBzdXBwbHlEZWZhdWx0czogcmVxdWlyZSgnLi4vaGVhdG1hcC9kZWZhdWx0cycpLFxuICAgIGNvbG9yYmFyOiByZXF1aXJlKCcuLi9oZWF0bWFwL2NvbG9yYmFyJyksXG5cbiAgICBjYWxjOiByZXF1aXJlKCcuLi9oZWF0bWFwL2NhbGMnKSxcbiAgICBwbG90OiByZXF1aXJlKCcuL2NvbnZlcnQnKSxcblxuICAgIG1vZHVsZVR5cGU6ICd0cmFjZScsXG4gICAgbmFtZTogJ2hlYXRtYXBnbCcsXG4gICAgYmFzZVBsb3RNb2R1bGU6IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2dsMmQnKSxcbiAgICBjYXRlZ29yaWVzOiBbJ2dsJywgJ2dsMmQnLCAnMmRNYXAnXSxcbiAgICBtZXRhOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnV2ViR0wgdmVyc2lvbiBvZiB0aGUgaGVhdG1hcCB0cmFjZSB0eXBlLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaWIgPSByZXF1aXJlKCcuLi8uLi9saWInKTtcblxudmFyIGhhbmRsZVNhbXBsZURlZmF1bHRzID0gcmVxdWlyZSgnLi9zYW1wbGVfZGVmYXVsdHMnKTtcbnZhciBoYW5kbGVTdHlsZURlZmF1bHRzID0gcmVxdWlyZSgnLi4vaGVhdG1hcC9zdHlsZV9kZWZhdWx0cycpO1xudmFyIGNvbG9yc2NhbGVEZWZhdWx0cyA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMvY29sb3JzY2FsZS9kZWZhdWx0cycpO1xudmFyIGF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN1cHBseURlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCBkZWZhdWx0Q29sb3IsIGxheW91dCkge1xuICAgIGZ1bmN0aW9uIGNvZXJjZShhdHRyLCBkZmx0KSB7XG4gICAgICAgIHJldHVybiBMaWIuY29lcmNlKHRyYWNlSW4sIHRyYWNlT3V0LCBhdHRyaWJ1dGVzLCBhdHRyLCBkZmx0KTtcbiAgICB9XG5cbiAgICBoYW5kbGVTYW1wbGVEZWZhdWx0cyh0cmFjZUluLCB0cmFjZU91dCwgY29lcmNlLCBsYXlvdXQpO1xuICAgIGlmKHRyYWNlT3V0LnZpc2libGUgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICBoYW5kbGVTdHlsZURlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCBjb2VyY2UsIGxheW91dCk7XG4gICAgY29sb3JzY2FsZURlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCBsYXlvdXQsIGNvZXJjZSwge3ByZWZpeDogJycsIGNMZXR0ZXI6ICd6J30pO1xuICAgIGNvZXJjZSgnaG92ZXJ0ZW1wbGF0ZScpO1xufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGVhdG1hcEhvdmVyID0gcmVxdWlyZSgnLi4vaGVhdG1hcC9ob3ZlcicpO1xudmFyIGhvdmVyTGFiZWxUZXh0ID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuL2F4ZXMnKS5ob3ZlckxhYmVsVGV4dDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBob3ZlclBvaW50cyhwb2ludERhdGEsIHh2YWwsIHl2YWwsIGhvdmVybW9kZSwgaG92ZXJMYXllciwgY29udG91cikge1xuICAgIHZhciBwdHMgPSBoZWF0bWFwSG92ZXIocG9pbnREYXRhLCB4dmFsLCB5dmFsLCBob3Zlcm1vZGUsIGhvdmVyTGF5ZXIsIGNvbnRvdXIpO1xuXG4gICAgaWYoIXB0cykgcmV0dXJuO1xuXG4gICAgcG9pbnREYXRhID0gcHRzWzBdO1xuICAgIHZhciBpbmRpY2VzID0gcG9pbnREYXRhLmluZGV4O1xuICAgIHZhciBueSA9IGluZGljZXNbMF07XG4gICAgdmFyIG54ID0gaW5kaWNlc1sxXTtcbiAgICB2YXIgY2QwID0gcG9pbnREYXRhLmNkWzBdO1xuICAgIHZhciB4UmFuZ2UgPSBjZDAueFJhbmdlc1tueF07XG4gICAgdmFyIHlSYW5nZSA9IGNkMC55UmFuZ2VzW255XTtcblxuICAgIHBvaW50RGF0YS54TGFiZWwgPSBob3ZlckxhYmVsVGV4dChwb2ludERhdGEueGEsIHhSYW5nZVswXSwgeFJhbmdlWzFdKTtcbiAgICBwb2ludERhdGEueUxhYmVsID0gaG92ZXJMYWJlbFRleHQocG9pbnREYXRhLnlhLCB5UmFuZ2VbMF0sIHlSYW5nZVsxXSk7XG5cbiAgICByZXR1cm4gcHRzO1xufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXR0cmlidXRlczogcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyksXG4gICAgc3VwcGx5RGVmYXVsdHM6IHJlcXVpcmUoJy4vZGVmYXVsdHMnKSxcbiAgICBjcm9zc1RyYWNlRGVmYXVsdHM6IHJlcXVpcmUoJy4uL2hpc3RvZ3JhbS9jcm9zc190cmFjZV9kZWZhdWx0cycpLFxuICAgIGNhbGM6IHJlcXVpcmUoJy4uL2hlYXRtYXAvY2FsYycpLFxuICAgIHBsb3Q6IHJlcXVpcmUoJy4uL2hlYXRtYXAvcGxvdCcpLFxuICAgIGxheWVyTmFtZTogJ2hlYXRtYXBsYXllcicsXG4gICAgY29sb3JiYXI6IHJlcXVpcmUoJy4uL2hlYXRtYXAvY29sb3JiYXInKSxcbiAgICBzdHlsZTogcmVxdWlyZSgnLi4vaGVhdG1hcC9zdHlsZScpLFxuICAgIGhvdmVyUG9pbnRzOiByZXF1aXJlKCcuL2hvdmVyJyksXG4gICAgZXZlbnREYXRhOiByZXF1aXJlKCcuLi9oaXN0b2dyYW0vZXZlbnRfZGF0YScpLFxuXG4gICAgbW9kdWxlVHlwZTogJ3RyYWNlJyxcbiAgICBuYW1lOiAnaGlzdG9ncmFtMmQnLFxuICAgIGJhc2VQbG90TW9kdWxlOiByZXF1aXJlKCcuLi8uLi9wbG90cy9jYXJ0ZXNpYW4nKSxcbiAgICBjYXRlZ29yaWVzOiBbJ2NhcnRlc2lhbicsICdzdmcnLCAnMmRNYXAnLCAnaGlzdG9ncmFtJywgJ3Nob3dMZWdlbmQnXSxcbiAgICBtZXRhOiB7XG4gICAgICAgIGhyTmFtZTogJ2hpc3RvZ3JhbV8yZCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnVGhlIHNhbXBsZSBkYXRhIGZyb20gd2hpY2ggc3RhdGlzdGljcyBhcmUgY29tcHV0ZWQgaXMgc2V0IGluIGB4YCcsXG4gICAgICAgICAgICAnYW5kIGB5YCAod2hlcmUgYHhgIGFuZCBgeWAgcmVwcmVzZW50IG1hcmdpbmFsIGRpc3RyaWJ1dGlvbnMsJyxcbiAgICAgICAgICAgICdiaW5uaW5nIGlzIHNldCBpbiBgeGJpbnNgIGFuZCBgeWJpbnNgIGluIHRoaXMgY2FzZSknLFxuICAgICAgICAgICAgJ29yIGB6YCAod2hlcmUgYHpgIHJlcHJlc2VudCB0aGUgMkQgZGlzdHJpYnV0aW9uIGFuZCBiaW5uaW5nIHNldCwnLFxuICAgICAgICAgICAgJ2Jpbm5pbmcgaXMgc2V0IGJ5IGB4YCBhbmQgYHlgIGluIHRoaXMgY2FzZSkuJyxcbiAgICAgICAgICAgICdUaGUgcmVzdWx0aW5nIGRpc3RyaWJ1dGlvbiBpcyB2aXN1YWxpemVkIGFzIGEgaGVhdG1hcC4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXR0cmlidXRlczogcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyksXG4gICAgc3VwcGx5RGVmYXVsdHM6IHJlcXVpcmUoJy4vZGVmYXVsdHMnKS5zdXBwbHlEZWZhdWx0cyxcbiAgICBjYWxjOiByZXF1aXJlKCcuL2NhbGMnKSxcbiAgICBjb2xvcmJhcjoge1xuICAgICAgICBtaW46ICdjbWluJyxcbiAgICAgICAgbWF4OiAnY21heCdcbiAgICB9LFxuICAgIHBsb3Q6IHJlcXVpcmUoJy4vY29udmVydCcpLmNyZWF0ZUlzb3N1cmZhY2VUcmFjZSxcblxuICAgIG1vZHVsZVR5cGU6ICd0cmFjZScsXG4gICAgbmFtZTogJ2lzb3N1cmZhY2UnLFxuICAgIGJhc2VQbG90TW9kdWxlOiByZXF1aXJlKCcuLi8uLi9wbG90cy9nbDNkJyksXG4gICAgY2F0ZWdvcmllczogWydnbDNkJywgJ3Nob3dMZWdlbmQnXSxcbiAgICBtZXRhOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnRHJhd3MgaXNvc3VyZmFjZXMgYmV0d2VlbiBpc28tbWluIGFuZCBpc28tbWF4IHZhbHVlcyB3aXRoIGNvb3JkaW5hdGVzIGdpdmVuIGJ5JyxcbiAgICAgICAgICAgICdmb3VyIDEtZGltZW5zaW9uYWwgYXJyYXlzIGNvbnRhaW5pbmcgdGhlIGB2YWx1ZWAsIGB4YCwgYHlgIGFuZCBgemAgb2YgZXZlcnkgdmVydGV4JyxcbiAgICAgICAgICAgICdvZiBhIHVuaWZvcm0gb3Igbm9uLXVuaWZvcm0gMy1EIGdyaWQuIEhvcml6b250YWwgb3IgdmVydGljYWwgc2xpY2VzLCBjYXBzIGFzIHdlbGwgYXMnLFxuICAgICAgICAgICAgJ3NwYWNlZnJhbWUgYmV0d2VlbiBpc28tbWluIGFuZCBpc28tbWF4IHZhbHVlcyBjb3VsZCBhbHNvIGJlIGRyYXduIHVzaW5nIHRoaXMgdHJhY2UuJ1xuICAgICAgICBdLmpvaW4oJyAnKVxuICAgIH1cbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xudmFyIGhhbmRsZU9ITEMgPSByZXF1aXJlKCcuL29obGNfZGVmYXVsdHMnKTtcbnZhciBhdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3VwcGx5RGVmYXVsdHModHJhY2VJbiwgdHJhY2VPdXQsIGRlZmF1bHRDb2xvciwgbGF5b3V0KSB7XG4gICAgZnVuY3Rpb24gY29lcmNlKGF0dHIsIGRmbHQpIHtcbiAgICAgICAgcmV0dXJuIExpYi5jb2VyY2UodHJhY2VJbiwgdHJhY2VPdXQsIGF0dHJpYnV0ZXMsIGF0dHIsIGRmbHQpO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBoYW5kbGVPSExDKHRyYWNlSW4sIHRyYWNlT3V0LCBjb2VyY2UsIGxheW91dCk7XG4gICAgaWYoIWxlbikge1xuICAgICAgICB0cmFjZU91dC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb2VyY2UoJ2xpbmUud2lkdGgnKTtcbiAgICBjb2VyY2UoJ2xpbmUuZGFzaCcpO1xuXG4gICAgaGFuZGxlRGlyZWN0aW9uKHRyYWNlSW4sIHRyYWNlT3V0LCBjb2VyY2UsICdpbmNyZWFzaW5nJyk7XG4gICAgaGFuZGxlRGlyZWN0aW9uKHRyYWNlSW4sIHRyYWNlT3V0LCBjb2VyY2UsICdkZWNyZWFzaW5nJyk7XG5cbiAgICBjb2VyY2UoJ3RleHQnKTtcbiAgICBjb2VyY2UoJ2hvdmVydGV4dCcpO1xuICAgIGNvZXJjZSgndGlja3dpZHRoJyk7XG5cbiAgICBsYXlvdXQuX3JlcXVlc3RSYW5nZXNsaWRlclt0cmFjZU91dC54YXhpc10gPSB0cnVlO1xufTtcblxuZnVuY3Rpb24gaGFuZGxlRGlyZWN0aW9uKHRyYWNlSW4sIHRyYWNlT3V0LCBjb2VyY2UsIGRpcmVjdGlvbikge1xuICAgIGNvZXJjZShkaXJlY3Rpb24gKyAnLmxpbmUuY29sb3InKTtcbiAgICBjb2VyY2UoZGlyZWN0aW9uICsgJy5saW5lLndpZHRoJywgdHJhY2VPdXQubGluZS53aWR0aCk7XG4gICAgY29lcmNlKGRpcmVjdGlvbiArICcubGluZS5kYXNoJywgdHJhY2VPdXQubGluZS5kYXNoKTtcbn1cbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbW9kdWxlVHlwZTogJ3RyYWNlJyxcbiAgICBuYW1lOiAnb2hsYycsXG4gICAgYmFzZVBsb3RNb2R1bGU6IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2NhcnRlc2lhbicpLFxuICAgIGNhdGVnb3JpZXM6IFsnY2FydGVzaWFuJywgJ3N2ZycsICdzaG93TGVnZW5kJ10sXG4gICAgbWV0YToge1xuICAgICAgICBkZXNjcmlwdGlvbjogW1xuICAgICAgICAgICAgJ1RoZSBvaGxjIChzaG9ydCBmb3IgT3Blbi1IaWdoLUxvdy1DbG9zZSkgaXMgYSBzdHlsZSBvZiBmaW5hbmNpYWwgY2hhcnQgZGVzY3JpYmluZycsXG4gICAgICAgICAgICAnb3BlbiwgaGlnaCwgbG93IGFuZCBjbG9zZSBmb3IgYSBnaXZlbiBgeGAgY29vcmRpbmF0ZSAobW9zdCBsaWtlbHkgdGltZSkuJyxcblxuICAgICAgICAgICAgJ1RoZSB0aXAgb2YgdGhlIGxpbmVzIHJlcHJlc2VudCB0aGUgYGxvd2AgYW5kIGBoaWdoYCB2YWx1ZXMgYW5kJyxcbiAgICAgICAgICAgICd0aGUgaG9yaXpvbnRhbCBzZWdtZW50cyByZXByZXNlbnQgdGhlIGBvcGVuYCBhbmQgYGNsb3NlYCB2YWx1ZXMuJyxcblxuICAgICAgICAgICAgJ1NhbXBsZSBwb2ludHMgd2hlcmUgdGhlIGNsb3NlIHZhbHVlIGlzIGhpZ2hlciAobG93ZXIpIHRoZW4gdGhlIG9wZW4nLFxuICAgICAgICAgICAgJ3ZhbHVlIGFyZSBjYWxsZWQgaW5jcmVhc2luZyAoZGVjcmVhc2luZykuJyxcblxuICAgICAgICAgICAgJ0J5IGRlZmF1bHQsIGluY3JlYXNpbmcgaXRlbXMgYXJlIGRyYXduIGluIGdyZWVuIHdoZXJlYXMnLFxuICAgICAgICAgICAgJ2RlY3JlYXNpbmcgYXJlIGRyYXduIGluIHJlZC4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcblxuICAgIGF0dHJpYnV0ZXM6IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpLFxuICAgIHN1cHBseURlZmF1bHRzOiByZXF1aXJlKCcuL2RlZmF1bHRzJyksXG4gICAgY2FsYzogcmVxdWlyZSgnLi9jYWxjJykuY2FsYyxcbiAgICBwbG90OiByZXF1aXJlKCcuL3Bsb3QnKSxcbiAgICBzdHlsZTogcmVxdWlyZSgnLi9zdHlsZScpLFxuICAgIGhvdmVyUG9pbnRzOiByZXF1aXJlKCcuL2hvdmVyJykuaG92ZXJQb2ludHMsXG4gICAgc2VsZWN0UG9pbnRzOiByZXF1aXJlKCcuL3NlbGVjdCcpXG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZDMgPSByZXF1aXJlKCdkMycpO1xuXG52YXIgTGliID0gcmVxdWlyZSgnLi4vLi4vbGliJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGxvdChnZCwgcGxvdGluZm8sIGNkT0hMQywgb2hsY0xheWVyKSB7XG4gICAgdmFyIHlhID0gcGxvdGluZm8ueWF4aXM7XG4gICAgdmFyIHhhID0gcGxvdGluZm8ueGF4aXM7XG4gICAgdmFyIHBvc0hhc1JhbmdlQnJlYWtzID0gISF4YS5yYW5nZWJyZWFrcztcblxuICAgIExpYi5tYWtlVHJhY2VHcm91cHMob2hsY0xheWVyLCBjZE9ITEMsICd0cmFjZSBvaGxjJykuZWFjaChmdW5jdGlvbihjZCkge1xuICAgICAgICB2YXIgcGxvdEdyb3VwID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICB2YXIgY2QwID0gY2RbMF07XG4gICAgICAgIHZhciB0ID0gY2QwLnQ7XG4gICAgICAgIHZhciB0cmFjZSA9IGNkMC50cmFjZTtcblxuICAgICAgICBpZih0cmFjZS52aXNpYmxlICE9PSB0cnVlIHx8IHQuZW1wdHkpIHtcbiAgICAgICAgICAgIHBsb3RHcm91cC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aWNrTGVuID0gdC50aWNrTGVuO1xuXG4gICAgICAgIHZhciBwYXRocyA9IHBsb3RHcm91cC5zZWxlY3RBbGwoJ3BhdGgnKS5kYXRhKExpYi5pZGVudGl0eSk7XG5cbiAgICAgICAgcGF0aHMuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKTtcblxuICAgICAgICBwYXRocy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgcGF0aHMuYXR0cignZCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGlmKGQuZW1wdHkpIHJldHVybiAnTTAsMFonO1xuXG4gICAgICAgICAgICB2YXIgeG8gPSB4YS5jMnAoZC5wb3MgLSB0aWNrTGVuLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB4YyA9IHhhLmMycChkLnBvcyArIHRpY2tMZW4sIHRydWUpO1xuICAgICAgICAgICAgdmFyIHggPSBwb3NIYXNSYW5nZUJyZWFrcyA/ICh4byArIHhjKSAvIDIgOiB4YS5jMnAoZC5wb3MsIHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgeW8gPSB5YS5jMnAoZC5vLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB5aCA9IHlhLmMycChkLmgsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHlsID0geWEuYzJwKGQubCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgeWMgPSB5YS5jMnAoZC5jLCB0cnVlKTtcblxuICAgICAgICAgICAgcmV0dXJuICdNJyArIHhvICsgJywnICsgeW8gKyAnSCcgKyB4ICtcbiAgICAgICAgICAgICAgICAnTScgKyB4ICsgJywnICsgeWggKyAnVicgKyB5bCArXG4gICAgICAgICAgICAgICAgJ00nICsgeGMgKyAnLCcgKyB5YyArICdIJyArIHg7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGQzID0gcmVxdWlyZSgnZDMnKTtcbnZhciBEcmF3aW5nID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50cy9kcmF3aW5nJyk7XG52YXIgQ29sb3IgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzL2NvbG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3R5bGUoZ2QsIGNkLCBzZWwpIHtcbiAgICB2YXIgcyA9IHNlbCA/IHNlbCA6IGQzLnNlbGVjdChnZCkuc2VsZWN0QWxsKCdnLm9obGNsYXllcicpLnNlbGVjdEFsbCgnZy50cmFjZScpO1xuXG4gICAgcy5zdHlsZSgnb3BhY2l0eScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGRbMF0udHJhY2Uub3BhY2l0eTtcbiAgICB9KTtcblxuICAgIHMuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciB0cmFjZSA9IGRbMF0udHJhY2U7XG5cbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdEFsbCgncGF0aCcpLmVhY2goZnVuY3Rpb24oZGkpIHtcbiAgICAgICAgICAgIGlmKGRpLmVtcHR5KSByZXR1cm47XG5cbiAgICAgICAgICAgIHZhciBkaXJMaW5lID0gdHJhY2VbZGkuZGlyXS5saW5lO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgJ25vbmUnKVxuICAgICAgICAgICAgICAgIC5jYWxsKENvbG9yLnN0cm9rZSwgZGlyTGluZS5jb2xvcilcbiAgICAgICAgICAgICAgICAuY2FsbChEcmF3aW5nLmRhc2hMaW5lLCBkaXJMaW5lLmRhc2gsIGRpckxpbmUud2lkdGgpXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogY3VzdG9tIHNlbGVjdGlvbiBzdHlsZSBmb3IgT0hMQ1xuICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIHRyYWNlLnNlbGVjdGVkcG9pbnRzICYmICFkaS5zZWxlY3RlZCA/IDAuMyA6IDEpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwbG90cyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL3Bsb3RzJyk7XG5cbmV4cG9ydHMubmFtZSA9ICdwaWUnO1xuXG5leHBvcnRzLnBsb3QgPSBmdW5jdGlvbihnZCwgdHJhY2VzLCB0cmFuc2l0aW9uT3B0cywgbWFrZU9uQ29tcGxldGVDYWxsYmFjaykge1xuICAgIHBsb3RzLnBsb3RCYXNlUGxvdChleHBvcnRzLm5hbWUsIGdkLCB0cmFjZXMsIHRyYW5zaXRpb25PcHRzLCBtYWtlT25Db21wbGV0ZUNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuY2xlYW4gPSBmdW5jdGlvbihuZXdGdWxsRGF0YSwgbmV3RnVsbExheW91dCwgb2xkRnVsbERhdGEsIG9sZEZ1bGxMYXlvdXQpIHtcbiAgICBwbG90cy5jbGVhbkJhc2VQbG90KGV4cG9ydHMubmFtZSwgbmV3RnVsbERhdGEsIG5ld0Z1bGxMYXlvdXQsIG9sZEZ1bGxEYXRhLCBvbGRGdWxsTGF5b3V0KTtcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGF0dHJpYnV0ZXM6IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpLFxuICAgIHN1cHBseURlZmF1bHRzOiByZXF1aXJlKCcuL2RlZmF1bHRzJykuc3VwcGx5RGVmYXVsdHMsXG4gICAgc3VwcGx5TGF5b3V0RGVmYXVsdHM6IHJlcXVpcmUoJy4vbGF5b3V0X2RlZmF1bHRzJyksXG4gICAgbGF5b3V0QXR0cmlidXRlczogcmVxdWlyZSgnLi9sYXlvdXRfYXR0cmlidXRlcycpLFxuXG4gICAgY2FsYzogcmVxdWlyZSgnLi9jYWxjJykuY2FsYyxcbiAgICBjcm9zc1RyYWNlQ2FsYzogcmVxdWlyZSgnLi9jYWxjJykuY3Jvc3NUcmFjZUNhbGMsXG5cbiAgICBwbG90OiByZXF1aXJlKCcuL3Bsb3QnKS5wbG90LFxuICAgIHN0eWxlOiByZXF1aXJlKCcuL3N0eWxlJyksXG4gICAgc3R5bGVPbmU6IHJlcXVpcmUoJy4vc3R5bGVfb25lJyksXG5cbiAgICBtb2R1bGVUeXBlOiAndHJhY2UnLFxuICAgIG5hbWU6ICdwaWUnLFxuICAgIGJhc2VQbG90TW9kdWxlOiByZXF1aXJlKCcuL2Jhc2VfcGxvdCcpLFxuICAgIGNhdGVnb3JpZXM6IFsncGllLWxpa2UnLCAncGllJywgJ3Nob3dMZWdlbmQnXSxcbiAgICBtZXRhOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnQSBkYXRhIHZpc3VhbGl6ZWQgYnkgdGhlIHNlY3RvcnMgb2YgdGhlIHBpZSBpcyBzZXQgaW4gYHZhbHVlc2AuJyxcbiAgICAgICAgICAgICdUaGUgc2VjdG9yIGxhYmVscyBhcmUgc2V0IGluIGBsYWJlbHNgLicsXG4gICAgICAgICAgICAnVGhlIHNlY3RvciBjb2xvcnMgYXJlIHNldCBpbiBgbWFya2VyLmNvbG9yc2AnXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xuXG52YXIgbGF5b3V0QXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vbGF5b3V0X2F0dHJpYnV0ZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdXBwbHlMYXlvdXREZWZhdWx0cyhsYXlvdXRJbiwgbGF5b3V0T3V0KSB7XG4gICAgZnVuY3Rpb24gY29lcmNlKGF0dHIsIGRmbHQpIHtcbiAgICAgICAgcmV0dXJuIExpYi5jb2VyY2UobGF5b3V0SW4sIGxheW91dE91dCwgbGF5b3V0QXR0cmlidXRlcywgYXR0ciwgZGZsdCk7XG4gICAgfVxuXG4gICAgY29lcmNlKCdoaWRkZW5sYWJlbHMnKTtcbiAgICBjb2VyY2UoJ3BpZWNvbG9yd2F5JywgbGF5b3V0T3V0LmNvbG9yd2F5KTtcbiAgICBjb2VyY2UoJ2V4dGVuZHBpZWNvbG9ycycpO1xufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGQzID0gcmVxdWlyZSgnZDMnKTtcblxudmFyIHN0eWxlT25lID0gcmVxdWlyZSgnLi9zdHlsZV9vbmUnKTtcbnZhciByZXNpemVUZXh0ID0gcmVxdWlyZSgnLi4vYmFyL3VuaWZvcm1fdGV4dCcpLnJlc2l6ZVRleHQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3R5bGUoZ2QpIHtcbiAgICB2YXIgcyA9IGdkLl9mdWxsTGF5b3V0Ll9waWVsYXllci5zZWxlY3RBbGwoJy50cmFjZScpO1xuICAgIHJlc2l6ZVRleHQoZ2QsIHMsICdwaWUnKTtcblxuICAgIHMuZWFjaChmdW5jdGlvbihjZCkge1xuICAgICAgICB2YXIgY2QwID0gY2RbMF07XG4gICAgICAgIHZhciB0cmFjZSA9IGNkMC50cmFjZTtcbiAgICAgICAgdmFyIHRyYWNlU2VsZWN0aW9uID0gZDMuc2VsZWN0KHRoaXMpO1xuXG4gICAgICAgIHRyYWNlU2VsZWN0aW9uLnN0eWxlKHtvcGFjaXR5OiB0cmFjZS5vcGFjaXR5fSk7XG5cbiAgICAgICAgdHJhY2VTZWxlY3Rpb24uc2VsZWN0QWxsKCdwYXRoLnN1cmZhY2UnKS5lYWNoKGZ1bmN0aW9uKHB0KSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChzdHlsZU9uZSwgcHQsIHRyYWNlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc051bWVyaWMgPSByZXF1aXJlKCdmYXN0LWlzbnVtZXJpYycpO1xudmFyIEJBRE5VTSA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0YW50cy9udW1lcmljYWwnKS5CQUROVU07XG5cbnZhciBBeGVzID0gcmVxdWlyZSgnLi4vLi4vcGxvdHMvY2FydGVzaWFuL2F4ZXMnKTtcblxudmFyIGNhbGNDb2xvcnNjYWxlID0gcmVxdWlyZSgnLi4vc2NhdHRlci9jb2xvcnNjYWxlX2NhbGMnKTtcbnZhciBhcnJheXNUb0NhbGNkYXRhID0gcmVxdWlyZSgnLi4vc2NhdHRlci9hcnJheXNfdG9fY2FsY2RhdGEnKTtcbnZhciBjYWxjU2VsZWN0aW9uID0gcmVxdWlyZSgnLi4vc2NhdHRlci9jYWxjX3NlbGVjdGlvbicpO1xudmFyIGNhbGNNYXJrZXJTaXplID0gcmVxdWlyZSgnLi4vc2NhdHRlci9jYWxjJykuY2FsY01hcmtlclNpemU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsYyhnZCwgdHJhY2UpIHtcbiAgICB2YXIgZnVsbExheW91dCA9IGdkLl9mdWxsTGF5b3V0O1xuICAgIHZhciBzdWJwbG90SWQgPSB0cmFjZS5zdWJwbG90O1xuICAgIHZhciByYWRpYWxBeGlzID0gZnVsbExheW91dFtzdWJwbG90SWRdLnJhZGlhbGF4aXM7XG4gICAgdmFyIGFuZ3VsYXJBeGlzID0gZnVsbExheW91dFtzdWJwbG90SWRdLmFuZ3VsYXJheGlzO1xuICAgIHZhciByQXJyYXkgPSByYWRpYWxBeGlzLm1ha2VDYWxjZGF0YSh0cmFjZSwgJ3InKTtcbiAgICB2YXIgdGhldGFBcnJheSA9IGFuZ3VsYXJBeGlzLm1ha2VDYWxjZGF0YSh0cmFjZSwgJ3RoZXRhJyk7XG4gICAgdmFyIGxlbiA9IHRyYWNlLl9sZW5ndGg7XG4gICAgdmFyIGNkID0gbmV3IEFycmF5KGxlbik7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHIgPSByQXJyYXlbaV07XG4gICAgICAgIHZhciB0aGV0YSA9IHRoZXRhQXJyYXlbaV07XG4gICAgICAgIHZhciBjZGkgPSBjZFtpXSA9IHt9O1xuXG4gICAgICAgIGlmKGlzTnVtZXJpYyhyKSAmJiBpc051bWVyaWModGhldGEpKSB7XG4gICAgICAgICAgICBjZGkuciA9IHI7XG4gICAgICAgICAgICBjZGkudGhldGEgPSB0aGV0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNkaS5yID0gQkFETlVNO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBwYWQgPSBjYWxjTWFya2VyU2l6ZSh0cmFjZSwgbGVuKTtcbiAgICB0cmFjZS5fZXh0cmVtZXMueCA9IEF4ZXMuZmluZEV4dHJlbWVzKHJhZGlhbEF4aXMsIHJBcnJheSwge3BwYWQ6IHBwYWR9KTtcblxuICAgIGNhbGNDb2xvcnNjYWxlKGdkLCB0cmFjZSk7XG4gICAgYXJyYXlzVG9DYWxjZGF0YShjZCwgdHJhY2UpO1xuICAgIGNhbGNTZWxlY3Rpb24oY2QsIHRyYWNlKTtcblxuICAgIHJldHVybiBjZDtcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1vZHVsZVR5cGU6ICd0cmFjZScsXG4gICAgbmFtZTogJ3NjYXR0ZXJwb2xhcicsXG4gICAgYmFzZVBsb3RNb2R1bGU6IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL3BvbGFyJyksXG4gICAgY2F0ZWdvcmllczogWydwb2xhcicsICdzeW1ib2xzJywgJ3Nob3dMZWdlbmQnLCAnc2NhdHRlci1saWtlJ10sXG5cbiAgICBhdHRyaWJ1dGVzOiByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKSxcbiAgICBzdXBwbHlEZWZhdWx0czogcmVxdWlyZSgnLi9kZWZhdWx0cycpLnN1cHBseURlZmF1bHRzLFxuICAgIGNvbG9yYmFyOiByZXF1aXJlKCcuLi9zY2F0dGVyL21hcmtlcl9jb2xvcmJhcicpLFxuICAgIGZvcm1hdExhYmVsczogcmVxdWlyZSgnLi9mb3JtYXRfbGFiZWxzJyksXG4gICAgY2FsYzogcmVxdWlyZSgnLi9jYWxjJyksXG4gICAgcGxvdDogcmVxdWlyZSgnLi9wbG90JyksXG4gICAgc3R5bGU6IHJlcXVpcmUoJy4uL3NjYXR0ZXIvc3R5bGUnKS5zdHlsZSxcbiAgICBzdHlsZU9uU2VsZWN0OiByZXF1aXJlKCcuLi9zY2F0dGVyL3N0eWxlJykuc3R5bGVPblNlbGVjdCxcbiAgICBob3ZlclBvaW50czogcmVxdWlyZSgnLi9ob3ZlcicpLmhvdmVyUG9pbnRzLFxuICAgIHNlbGVjdFBvaW50czogcmVxdWlyZSgnLi4vc2NhdHRlci9zZWxlY3QnKSxcblxuICAgIG1ldGE6IHtcbiAgICAgICAgaHJOYW1lOiAnc2NhdHRlcl9wb2xhcicsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnVGhlIHNjYXR0ZXJwb2xhciB0cmFjZSB0eXBlIGVuY29tcGFzc2VzIGxpbmUgY2hhcnRzLCBzY2F0dGVyIGNoYXJ0cywgdGV4dCBjaGFydHMsIGFuZCBidWJibGUgY2hhcnRzJyxcbiAgICAgICAgICAgICdpbiBwb2xhciBjb29yZGluYXRlcy4nLFxuICAgICAgICAgICAgJ1RoZSBkYXRhIHZpc3VhbGl6ZWQgYXMgc2NhdHRlciBwb2ludCBvciBsaW5lcyBpcyBzZXQgaW4nLFxuICAgICAgICAgICAgJ2ByYCAocmFkaWFsKSBhbmQgYHRoZXRhYCAoYW5ndWxhcikgY29vcmRpbmF0ZXMnLFxuICAgICAgICAgICAgJ1RleHQgKGFwcGVhcmluZyBlaXRoZXIgb24gdGhlIGNoYXJ0IG9yIG9uIGhvdmVyIG9ubHkpIGlzIHZpYSBgdGV4dGAuJyxcbiAgICAgICAgICAgICdCdWJibGUgY2hhcnRzIGFyZSBhY2hpZXZlZCBieSBzZXR0aW5nIGBtYXJrZXIuc2l6ZWAgYW5kL29yIGBtYXJrZXIuY29sb3JgJyxcbiAgICAgICAgICAgICd0byBudW1lcmljYWwgYXJyYXlzLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2NhdHRlclBsb3QgPSByZXF1aXJlKCcuLi9zY2F0dGVyL3Bsb3QnKTtcbnZhciBCQUROVU0gPSByZXF1aXJlKCcuLi8uLi9jb25zdGFudHMvbnVtZXJpY2FsJykuQkFETlVNO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBsb3QoZ2QsIHN1YnBsb3QsIG1vZHVsZUNhbGNEYXRhKSB7XG4gICAgdmFyIG1sYXllciA9IHN1YnBsb3QubGF5ZXJzLmZyb250cGxvdC5zZWxlY3QoJ2cuc2NhdHRlcmxheWVyJyk7XG5cbiAgICB2YXIgcGxvdGluZm8gPSB7XG4gICAgICAgIHhheGlzOiBzdWJwbG90LnhheGlzLFxuICAgICAgICB5YXhpczogc3VicGxvdC55YXhpcyxcbiAgICAgICAgcGxvdDogc3VicGxvdC5mcmFtZXdvcmssXG4gICAgICAgIGxheWVyQ2xpcElkOiBzdWJwbG90Ll9oYXNDbGlwT25BeGlzRmFsc2UgPyBzdWJwbG90LmNsaXBJZHMuZm9yVHJhY2VzIDogbnVsbFxuICAgIH07XG5cbiAgICB2YXIgcmFkaWFsQXhpcyA9IHN1YnBsb3QucmFkaWFsQXhpcztcbiAgICB2YXIgYW5ndWxhckF4aXMgPSBzdWJwbG90LmFuZ3VsYXJBeGlzO1xuXG4gICAgLy8gY29udmVydDpcbiAgICAvLyAnYycgKHIsdGhldGEpIC0+ICdnZW9tZXRyaWMnIChyLHRoZXRhKSAtPiAoeCx5KVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtb2R1bGVDYWxjRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2RpID0gbW9kdWxlQ2FsY0RhdGFbaV07XG5cbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGNkaS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGNkID0gY2RpW2pdO1xuICAgICAgICAgICAgdmFyIHIgPSBjZC5yO1xuXG4gICAgICAgICAgICBpZihyID09PSBCQUROVU0pIHtcbiAgICAgICAgICAgICAgICBjZC54ID0gY2QueSA9IEJBRE5VTTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJnID0gcmFkaWFsQXhpcy5jMmcocik7XG4gICAgICAgICAgICAgICAgdmFyIHRoZXRhZyA9IGFuZ3VsYXJBeGlzLmMyZyhjZC50aGV0YSk7XG4gICAgICAgICAgICAgICAgY2QueCA9IHJnICogTWF0aC5jb3ModGhldGFnKTtcbiAgICAgICAgICAgICAgICBjZC55ID0gcmcgKiBNYXRoLnNpbih0aGV0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2NhdHRlclBsb3QoZ2QsIHBsb3RpbmZvLCBtb2R1bGVDYWxjRGF0YSwgbWxheWVyKTtcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwbG90cyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL3Bsb3RzJyk7XG5cbmV4cG9ydHMubmFtZSA9ICdzdW5idXJzdCc7XG5cbmV4cG9ydHMucGxvdCA9IGZ1bmN0aW9uKGdkLCB0cmFjZXMsIHRyYW5zaXRpb25PcHRzLCBtYWtlT25Db21wbGV0ZUNhbGxiYWNrKSB7XG4gICAgcGxvdHMucGxvdEJhc2VQbG90KGV4cG9ydHMubmFtZSwgZ2QsIHRyYWNlcywgdHJhbnNpdGlvbk9wdHMsIG1ha2VPbkNvbXBsZXRlQ2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5jbGVhbiA9IGZ1bmN0aW9uKG5ld0Z1bGxEYXRhLCBuZXdGdWxsTGF5b3V0LCBvbGRGdWxsRGF0YSwgb2xkRnVsbExheW91dCkge1xuICAgIHBsb3RzLmNsZWFuQmFzZVBsb3QoZXhwb3J0cy5uYW1lLCBuZXdGdWxsRGF0YSwgbmV3RnVsbExheW91dCwgb2xkRnVsbERhdGEsIG9sZEZ1bGxMYXlvdXQpO1xufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xudmFyIGF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKTtcbnZhciBoYW5kbGVEb21haW5EZWZhdWx0cyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2RvbWFpbicpLmRlZmF1bHRzO1xudmFyIGhhbmRsZVRleHQgPSByZXF1aXJlKCcuLi9iYXIvZGVmYXVsdHMnKS5oYW5kbGVUZXh0O1xuXG52YXIgQ29sb3JzY2FsZSA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMvY29sb3JzY2FsZScpO1xudmFyIGhhc0NvbG9yc2NhbGUgPSBDb2xvcnNjYWxlLmhhc0NvbG9yc2NhbGU7XG52YXIgY29sb3JzY2FsZURlZmF1bHRzID0gQ29sb3JzY2FsZS5oYW5kbGVEZWZhdWx0cztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdXBwbHlEZWZhdWx0cyh0cmFjZUluLCB0cmFjZU91dCwgZGVmYXVsdENvbG9yLCBsYXlvdXQpIHtcbiAgICBmdW5jdGlvbiBjb2VyY2UoYXR0ciwgZGZsdCkge1xuICAgICAgICByZXR1cm4gTGliLmNvZXJjZSh0cmFjZUluLCB0cmFjZU91dCwgYXR0cmlidXRlcywgYXR0ciwgZGZsdCk7XG4gICAgfVxuXG4gICAgdmFyIGxhYmVscyA9IGNvZXJjZSgnbGFiZWxzJyk7XG4gICAgdmFyIHBhcmVudHMgPSBjb2VyY2UoJ3BhcmVudHMnKTtcblxuICAgIGlmKCFsYWJlbHMgfHwgIWxhYmVscy5sZW5ndGggfHwgIXBhcmVudHMgfHwgIXBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRyYWNlT3V0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2YWxzID0gY29lcmNlKCd2YWx1ZXMnKTtcbiAgICBpZih2YWxzICYmIHZhbHMubGVuZ3RoKSB7XG4gICAgICAgIGNvZXJjZSgnYnJhbmNodmFsdWVzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29lcmNlKCdjb3VudCcpO1xuICAgIH1cblxuICAgIGNvZXJjZSgnbGV2ZWwnKTtcbiAgICBjb2VyY2UoJ21heGRlcHRoJyk7XG5cbiAgICB2YXIgbGluZVdpZHRoID0gY29lcmNlKCdtYXJrZXIubGluZS53aWR0aCcpO1xuICAgIGlmKGxpbmVXaWR0aCkgY29lcmNlKCdtYXJrZXIubGluZS5jb2xvcicsIGxheW91dC5wYXBlcl9iZ2NvbG9yKTtcblxuICAgIGNvZXJjZSgnbWFya2VyLmNvbG9ycycpO1xuICAgIHZhciB3aXRoQ29sb3JzY2FsZSA9IHRyYWNlT3V0Ll9oYXNDb2xvcnNjYWxlID0gKFxuICAgICAgICBoYXNDb2xvcnNjYWxlKHRyYWNlSW4sICdtYXJrZXInLCAnY29sb3JzJykgfHxcbiAgICAgICAgKHRyYWNlSW4ubWFya2VyIHx8IHt9KS5jb2xvcmF4aXMgLy8gTi5CLiBzcGVjaWFsIGxvZ2ljIHRvIGNvbnNpZGVyIFwidmFsdWVzXCIgY29sb3JzY2FsZXNcbiAgICApO1xuICAgIGlmKHdpdGhDb2xvcnNjYWxlKSB7XG4gICAgICAgIGNvbG9yc2NhbGVEZWZhdWx0cyh0cmFjZUluLCB0cmFjZU91dCwgbGF5b3V0LCBjb2VyY2UsIHtwcmVmaXg6ICdtYXJrZXIuJywgY0xldHRlcjogJ2MnfSk7XG4gICAgfVxuXG4gICAgY29lcmNlKCdsZWFmLm9wYWNpdHknLCB3aXRoQ29sb3JzY2FsZSA/IDEgOiAwLjcpO1xuXG4gICAgdmFyIHRleHQgPSBjb2VyY2UoJ3RleHQnKTtcbiAgICBjb2VyY2UoJ3RleHR0ZW1wbGF0ZScpO1xuICAgIGlmKCF0cmFjZU91dC50ZXh0dGVtcGxhdGUpIGNvZXJjZSgndGV4dGluZm8nLCBBcnJheS5pc0FycmF5KHRleHQpID8gJ3RleHQrbGFiZWwnIDogJ2xhYmVsJyk7XG5cbiAgICBjb2VyY2UoJ2hvdmVydGV4dCcpO1xuICAgIGNvZXJjZSgnaG92ZXJ0ZW1wbGF0ZScpO1xuXG4gICAgdmFyIHRleHRwb3NpdGlvbiA9ICdhdXRvJztcbiAgICBoYW5kbGVUZXh0KHRyYWNlSW4sIHRyYWNlT3V0LCBsYXlvdXQsIGNvZXJjZSwgdGV4dHBvc2l0aW9uLCB7XG4gICAgICAgIG1vZHVsZUhhc1NlbGVjdGVkOiBmYWxzZSxcbiAgICAgICAgbW9kdWxlSGFzVW5zZWxlY3RlZDogZmFsc2UsXG4gICAgICAgIG1vZHVsZUhhc0NvbnN0cmFpbjogZmFsc2UsXG4gICAgICAgIG1vZHVsZUhhc0NsaXBvbmF4aXM6IGZhbHNlLFxuICAgICAgICBtb2R1bGVIYXNUZXh0YW5nbGU6IGZhbHNlLFxuICAgICAgICBtb2R1bGVIYXNJbnNpZGVhbmNob3I6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBjb2VyY2UoJ2luc2lkZXRleHRvcmllbnRhdGlvbicpO1xuXG4gICAgaGFuZGxlRG9tYWluRGVmYXVsdHModHJhY2VPdXQsIGxheW91dCwgY29lcmNlKTtcblxuICAgIC8vIGRvIG5vdCBzdXBwb3J0IHRyYW5zZm9ybXMgZm9yIG5vd1xuICAgIHRyYWNlT3V0Ll9sZW5ndGggPSBudWxsO1xufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbW9kdWxlVHlwZTogJ3RyYWNlJyxcbiAgICBuYW1lOiAnc3VuYnVyc3QnLFxuICAgIGJhc2VQbG90TW9kdWxlOiByZXF1aXJlKCcuL2Jhc2VfcGxvdCcpLFxuICAgIGNhdGVnb3JpZXM6IFtdLFxuICAgIGFuaW1hdGFibGU6IHRydWUsXG5cbiAgICBhdHRyaWJ1dGVzOiByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKSxcbiAgICBsYXlvdXRBdHRyaWJ1dGVzOiByZXF1aXJlKCcuL2xheW91dF9hdHRyaWJ1dGVzJyksXG4gICAgc3VwcGx5RGVmYXVsdHM6IHJlcXVpcmUoJy4vZGVmYXVsdHMnKSxcbiAgICBzdXBwbHlMYXlvdXREZWZhdWx0czogcmVxdWlyZSgnLi9sYXlvdXRfZGVmYXVsdHMnKSxcblxuICAgIGNhbGM6IHJlcXVpcmUoJy4vY2FsYycpLmNhbGMsXG4gICAgY3Jvc3NUcmFjZUNhbGM6IHJlcXVpcmUoJy4vY2FsYycpLmNyb3NzVHJhY2VDYWxjLFxuXG4gICAgcGxvdDogcmVxdWlyZSgnLi9wbG90JykucGxvdCxcbiAgICBzdHlsZTogcmVxdWlyZSgnLi9zdHlsZScpLnN0eWxlLFxuXG4gICAgY29sb3JiYXI6IHJlcXVpcmUoJy4uL3NjYXR0ZXIvbWFya2VyX2NvbG9yYmFyJyksXG5cbiAgICBtZXRhOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnVmlzdWFsaXplIGhpZXJhcmNoYWwgZGF0YSBzcGFubmluZyBvdXR3YXJkIHJhZGlhbGx5IGZyb20gcm9vdCB0byBsZWF2ZXMuJyxcbiAgICAgICAgICAgICdUaGUgc3VuYnVyc3Qgc2VjdG9ycyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZW50cmllcyBpbiAqbGFiZWxzKiBvciAqaWRzKicsXG4gICAgICAgICAgICAnYW5kIGluICpwYXJlbnRzKi4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc3VuYnVyc3Rjb2xvcndheToge1xuICAgICAgICB2YWxUeXBlOiAnY29sb3JsaXN0JyxcbiAgICAgICAgcm9sZTogJ3N0eWxlJyxcbiAgICAgICAgZWRpdFR5cGU6ICdjYWxjJyxcbiAgICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgICAgICdTZXRzIHRoZSBkZWZhdWx0IHN1bmJ1cnN0IHNsaWNlIGNvbG9ycy4gRGVmYXVsdHMgdG8gdGhlIG1haW4nLFxuICAgICAgICAgICAgJ2Bjb2xvcndheWAgdXNlZCBmb3IgdHJhY2UgY29sb3JzLiBJZiB5b3Ugc3BlY2lmeSBhIG5ldycsXG4gICAgICAgICAgICAnbGlzdCBoZXJlIGl0IGNhbiBzdGlsbCBiZSBleHRlbmRlZCB3aXRoIGxpZ2h0ZXIgYW5kIGRhcmtlcicsXG4gICAgICAgICAgICAnY29sb3JzLCBzZWUgYGV4dGVuZHN1bmJ1cnN0Y29sb3JzYC4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfSxcbiAgICBleHRlbmRzdW5idXJzdGNvbG9yczoge1xuICAgICAgICB2YWxUeXBlOiAnYm9vbGVhbicsXG4gICAgICAgIGRmbHQ6IHRydWUsXG4gICAgICAgIHJvbGU6ICdzdHlsZScsXG4gICAgICAgIGVkaXRUeXBlOiAnY2FsYycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnSWYgYHRydWVgLCB0aGUgc3VuYnVyc3Qgc2xpY2UgY29sb3JzICh3aGV0aGVyIGdpdmVuIGJ5IGBzdW5idXJzdGNvbG9yd2F5YCBvcicsXG4gICAgICAgICAgICAnaW5oZXJpdGVkIGZyb20gYGNvbG9yd2F5YCkgd2lsbCBiZSBleHRlbmRlZCB0byB0aHJlZSB0aW1lcyBpdHMnLFxuICAgICAgICAgICAgJ29yaWdpbmFsIGxlbmd0aCBieSBmaXJzdCByZXBlYXRpbmcgZXZlcnkgY29sb3IgMjAlIGxpZ2h0ZXIgdGhlbicsXG4gICAgICAgICAgICAnZWFjaCBjb2xvciAyMCUgZGFya2VyLiBUaGlzIGlzIGludGVuZGVkIHRvIHJlZHVjZSB0aGUgbGlrZWxpaG9vZCcsXG4gICAgICAgICAgICAnb2YgcmV1c2luZyB0aGUgc2FtZSBjb2xvciB3aGVuIHlvdSBoYXZlIG1hbnkgc2xpY2VzLCBidXQgeW91IGNhbicsXG4gICAgICAgICAgICAnc2V0IGBmYWxzZWAgdG8gZGlzYWJsZS4nLFxuICAgICAgICAgICAgJ0NvbG9ycyBwcm92aWRlZCBpbiB0aGUgdHJhY2UsIHVzaW5nIGBtYXJrZXIuY29sb3JzYCwgYXJlIG5ldmVyJyxcbiAgICAgICAgICAgICdleHRlbmRlZC4nXG4gICAgICAgIF0uam9pbignICcpXG4gICAgfVxufTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxMi0yMDIwLCBQbG90bHksIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4qIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpYiA9IHJlcXVpcmUoJy4uLy4uL2xpYicpO1xudmFyIGxheW91dEF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL2xheW91dF9hdHRyaWJ1dGVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3VwcGx5TGF5b3V0RGVmYXVsdHMobGF5b3V0SW4sIGxheW91dE91dCkge1xuICAgIGZ1bmN0aW9uIGNvZXJjZShhdHRyLCBkZmx0KSB7XG4gICAgICAgIHJldHVybiBMaWIuY29lcmNlKGxheW91dEluLCBsYXlvdXRPdXQsIGxheW91dEF0dHJpYnV0ZXMsIGF0dHIsIGRmbHQpO1xuICAgIH1cbiAgICBjb2VyY2UoJ3N1bmJ1cnN0Y29sb3J3YXknLCBsYXlvdXRPdXQuY29sb3J3YXkpO1xuICAgIGNvZXJjZSgnZXh0ZW5kc3VuYnVyc3Rjb2xvcnMnKTtcbn07XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb2xvclNjYWxlQXR0cnMgPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnRzL2NvbG9yc2NhbGUvYXR0cmlidXRlcycpO1xudmFyIGlzb3N1cmZhY2VBdHRycyA9IHJlcXVpcmUoJy4uL2lzb3N1cmZhY2UvYXR0cmlidXRlcycpO1xudmFyIHN1cmZhY2VBdHRycyA9IHJlcXVpcmUoJy4uL3N1cmZhY2UvYXR0cmlidXRlcycpO1xudmFyIGJhc2VBdHRycyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2F0dHJpYnV0ZXMnKTtcblxudmFyIGV4dGVuZEZsYXQgPSByZXF1aXJlKCcuLi8uLi9saWIvZXh0ZW5kJykuZXh0ZW5kRmxhdDtcbnZhciBvdmVycmlkZUFsbCA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RfYXBpL2VkaXRfdHlwZXMnKS5vdmVycmlkZUFsbDtcblxudmFyIGF0dHJzID0gbW9kdWxlLmV4cG9ydHMgPSBvdmVycmlkZUFsbChleHRlbmRGbGF0KHtcbiAgICB4OiBpc29zdXJmYWNlQXR0cnMueCxcbiAgICB5OiBpc29zdXJmYWNlQXR0cnMueSxcbiAgICB6OiBpc29zdXJmYWNlQXR0cnMueixcbiAgICB2YWx1ZTogaXNvc3VyZmFjZUF0dHJzLnZhbHVlLFxuICAgIGlzb21pbjogaXNvc3VyZmFjZUF0dHJzLmlzb21pbixcbiAgICBpc29tYXg6IGlzb3N1cmZhY2VBdHRycy5pc29tYXgsXG4gICAgc3VyZmFjZTogaXNvc3VyZmFjZUF0dHJzLnN1cmZhY2UsXG4gICAgc3BhY2VmcmFtZToge1xuICAgICAgICBzaG93OiB7XG4gICAgICAgICAgICB2YWxUeXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICByb2xlOiAnaW5mbycsXG4gICAgICAgICAgICBkZmx0OiBmYWxzZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAgICAgJ0Rpc3BsYXlzL2hpZGVzIHRldHJhaGVkcm9uIHNoYXBlcyBiZXR3ZWVuIG1pbmltdW0gYW5kJyxcbiAgICAgICAgICAgICAgICAnbWF4aW11bSBpc28tdmFsdWVzLiBPZnRlbiB1c2VmdWwgd2hlbiBlaXRoZXIgY2FwcyBvcicsXG4gICAgICAgICAgICAgICAgJ3N1cmZhY2VzIGFyZSBkaXNhYmxlZCBvciBmaWxsZWQgd2l0aCB2YWx1ZXMgbGVzcyB0aGFuIDEuJ1xuICAgICAgICAgICAgXS5qb2luKCcgJylcbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgdmFsVHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICByb2xlOiAnc3R5bGUnLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgICAgZGZsdDogMSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAgICAgJ1NldHMgdGhlIGZpbGwgcmF0aW8gb2YgdGhlIGBzcGFjZWZyYW1lYCBlbGVtZW50cy4gVGhlIGRlZmF1bHQgZmlsbCB2YWx1ZScsXG4gICAgICAgICAgICAgICAgJ2lzIDEgbWVhbmluZyB0aGF0IHRoZXkgYXJlIGVudGlyZWx5IHNoYWRlZC4gQXBwbHlpbmcgYSBgZmlsbGAgcmF0aW8gbGVzcycsXG4gICAgICAgICAgICAgICAgJ3RoYW4gb25lIHdvdWxkIGFsbG93IHRoZSBjcmVhdGlvbiBvZiBvcGVuaW5ncyBwYXJhbGxlbCB0byB0aGUgZWRnZXMuJ1xuICAgICAgICAgICAgXS5qb2luKCcgJylcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzbGljZXM6IGlzb3N1cmZhY2VBdHRycy5zbGljZXMsXG4gICAgY2FwczogaXNvc3VyZmFjZUF0dHJzLmNhcHMsXG4gICAgdGV4dDogaXNvc3VyZmFjZUF0dHJzLnRleHQsXG4gICAgaG92ZXJ0ZXh0OiBpc29zdXJmYWNlQXR0cnMuaG92ZXJ0ZXh0LFxuICAgIGhvdmVydGVtcGxhdGU6IGlzb3N1cmZhY2VBdHRycy5ob3ZlcnRlbXBsYXRlXG59LFxuXG5jb2xvclNjYWxlQXR0cnMoJycsIHtcbiAgICBjb2xvckF0dHI6ICdgdmFsdWVgJyxcbiAgICBzaG93U2NhbGVEZmx0OiB0cnVlLFxuICAgIGVkaXRUeXBlT3ZlcnJpZGU6ICdjYWxjJ1xufSksIHtcblxuICAgIGNvbG9yYmFyOiBpc29zdXJmYWNlQXR0cnMuY29sb3JiYXIsXG4gICAgb3BhY2l0eTogaXNvc3VyZmFjZUF0dHJzLm9wYWNpdHksXG4gICAgb3BhY2l0eXNjYWxlOiBzdXJmYWNlQXR0cnMub3BhY2l0eXNjYWxlLFxuXG4gICAgbGlnaHRwb3NpdGlvbjogaXNvc3VyZmFjZUF0dHJzLmxpZ2h0cG9zaXRpb24sXG4gICAgbGlnaHRpbmc6IGlzb3N1cmZhY2VBdHRycy5saWdodGluZyxcbiAgICBmbGF0c2hhZGluZzogaXNvc3VyZmFjZUF0dHJzLmZsYXRzaGFkaW5nLFxuICAgIGNvbnRvdXI6IGlzb3N1cmZhY2VBdHRycy5jb250b3VyLFxuXG4gICAgaG92ZXJpbmZvOiBleHRlbmRGbGF0KHt9LCBiYXNlQXR0cnMuaG92ZXJpbmZvKSxcbiAgICBzaG93bGVnZW5kOiBleHRlbmRGbGF0KHt9LCBiYXNlQXR0cnMuc2hvd2xlZ2VuZCwge2RmbHQ6IGZhbHNlfSlcbn0pLCAnY2FsYycsICduZXN0ZWQnKTtcblxuYXR0cnMueC5lZGl0VHlwZSA9IGF0dHJzLnkuZWRpdFR5cGUgPSBhdHRycy56LmVkaXRUeXBlID0gYXR0cnMudmFsdWUuZWRpdFR5cGUgPSAnY2FsYytjbGVhckF4aXNUeXBlcyc7XG5hdHRycy50cmFuc2Zvcm1zID0gdW5kZWZpbmVkO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlTWVzaCA9IHJlcXVpcmUoJ2dsLW1lc2gzZCcpO1xuXG52YXIgcGFyc2VDb2xvclNjYWxlID0gcmVxdWlyZSgnLi4vLi4vbGliL2dsX2Zvcm1hdF9jb2xvcicpLnBhcnNlQ29sb3JTY2FsZTtcbnZhciBzdHIyUmdiYUFycmF5ID0gcmVxdWlyZSgnLi4vLi4vbGliL3N0cjJyZ2JhcnJheScpO1xudmFyIGV4dHJhY3RPcHRzID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50cy9jb2xvcnNjYWxlJykuZXh0cmFjdE9wdHM7XG52YXIgemlwMyA9IHJlcXVpcmUoJy4uLy4uL3Bsb3RzL2dsM2QvemlwMycpO1xuXG52YXIgZmluZE5lYXJlc3RPbkF4aXMgPSByZXF1aXJlKCcuLi9pc29zdXJmYWNlL2NvbnZlcnQnKS5maW5kTmVhcmVzdE9uQXhpcztcbnZhciBnZW5lcmF0ZUlzb01lc2hlcyA9IHJlcXVpcmUoJy4uL2lzb3N1cmZhY2UvY29udmVydCcpLmdlbmVyYXRlSXNvTWVzaGVzO1xuXG5mdW5jdGlvbiBWb2x1bWVUcmFjZShzY2VuZSwgbWVzaCwgdWlkKSB7XG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIHRoaXMudWlkID0gdWlkO1xuICAgIHRoaXMubWVzaCA9IG1lc2g7XG4gICAgdGhpcy5uYW1lID0gJyc7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB0aGlzLnNob3dDb250b3VyID0gZmFsc2U7XG59XG5cbnZhciBwcm90byA9IFZvbHVtZVRyYWNlLnByb3RvdHlwZTtcblxucHJvdG8uaGFuZGxlUGljayA9IGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgIGlmKHNlbGVjdGlvbi5vYmplY3QgPT09IHRoaXMubWVzaCkge1xuICAgICAgICB2YXIgcmF3SWQgPSBzZWxlY3Rpb24uZGF0YS5pbmRleDtcblxuICAgICAgICB2YXIgeCA9IHRoaXMuZGF0YS5fbWVzaFhbcmF3SWRdO1xuICAgICAgICB2YXIgeSA9IHRoaXMuZGF0YS5fbWVzaFlbcmF3SWRdO1xuICAgICAgICB2YXIgeiA9IHRoaXMuZGF0YS5fbWVzaFpbcmF3SWRdO1xuXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmRhdGEuX1lzLmxlbmd0aDtcbiAgICAgICAgdmFyIGRlcHRoID0gdGhpcy5kYXRhLl9acy5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGkgPSBmaW5kTmVhcmVzdE9uQXhpcyh4LCB0aGlzLmRhdGEuX1hzKS5pZDtcbiAgICAgICAgdmFyIGogPSBmaW5kTmVhcmVzdE9uQXhpcyh5LCB0aGlzLmRhdGEuX1lzKS5pZDtcbiAgICAgICAgdmFyIGsgPSBmaW5kTmVhcmVzdE9uQXhpcyh6LCB0aGlzLmRhdGEuX1pzKS5pZDtcblxuICAgICAgICB2YXIgc2VsZWN0SW5kZXggPSBzZWxlY3Rpb24uaW5kZXggPSBrICsgZGVwdGggKiBqICsgZGVwdGggKiBoZWlnaHQgKiBpO1xuXG4gICAgICAgIHNlbGVjdGlvbi50cmFjZUNvb3JkaW5hdGUgPSBbXG4gICAgICAgICAgICB0aGlzLmRhdGEuX21lc2hYW3NlbGVjdEluZGV4XSxcbiAgICAgICAgICAgIHRoaXMuZGF0YS5fbWVzaFlbc2VsZWN0SW5kZXhdLFxuICAgICAgICAgICAgdGhpcy5kYXRhLl9tZXNoWltzZWxlY3RJbmRleF0sXG4gICAgICAgICAgICB0aGlzLmRhdGEuX3ZhbHVlW3NlbGVjdEluZGV4XVxuICAgICAgICBdO1xuXG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5kYXRhLmhvdmVydGV4dCB8fCB0aGlzLmRhdGEudGV4dDtcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheSh0ZXh0KSAmJiB0ZXh0W3NlbGVjdEluZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24udGV4dExhYmVsID0gdGV4dFtzZWxlY3RJbmRleF07XG4gICAgICAgIH0gZWxzZSBpZih0ZXh0KSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24udGV4dExhYmVsID0gdGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5cbnByb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgIHZhciBsYXlvdXQgPSBzY2VuZS5mdWxsU2NlbmVMYXlvdXQ7XG5cbiAgICB0aGlzLmRhdGEgPSBnZW5lcmF0ZUlzb01lc2hlcyhkYXRhKTtcblxuICAgIC8vIFVucGFjayBwb3NpdGlvbiBkYXRhXG4gICAgZnVuY3Rpb24gdG9EYXRhQ29vcmRzKGF4aXMsIGNvb3JkLCBzY2FsZSwgY2FsZW5kYXIpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkLm1hcChmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXhpcy5kMmwoeCwgMCwgY2FsZW5kYXIpICogc2NhbGU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBwb3NpdGlvbnMgPSB6aXAzKFxuICAgICAgICB0b0RhdGFDb29yZHMobGF5b3V0LnhheGlzLCBkYXRhLl9tZXNoWCwgc2NlbmUuZGF0YVNjYWxlWzBdLCBkYXRhLnhjYWxlbmRhciksXG4gICAgICAgIHRvRGF0YUNvb3JkcyhsYXlvdXQueWF4aXMsIGRhdGEuX21lc2hZLCBzY2VuZS5kYXRhU2NhbGVbMV0sIGRhdGEueWNhbGVuZGFyKSxcbiAgICAgICAgdG9EYXRhQ29vcmRzKGxheW91dC56YXhpcywgZGF0YS5fbWVzaFosIHNjZW5lLmRhdGFTY2FsZVsyXSwgZGF0YS56Y2FsZW5kYXIpKTtcblxuICAgIHZhciBjZWxscyA9IHppcDMoZGF0YS5fbWVzaEksIGRhdGEuX21lc2hKLCBkYXRhLl9tZXNoSyk7XG5cbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICBwb3NpdGlvbnM6IHBvc2l0aW9ucyxcbiAgICAgICAgY2VsbHM6IGNlbGxzLFxuICAgICAgICBsaWdodFBvc2l0aW9uOiBbZGF0YS5saWdodHBvc2l0aW9uLngsIGRhdGEubGlnaHRwb3NpdGlvbi55LCBkYXRhLmxpZ2h0cG9zaXRpb24uel0sXG4gICAgICAgIGFtYmllbnQ6IGRhdGEubGlnaHRpbmcuYW1iaWVudCxcbiAgICAgICAgZGlmZnVzZTogZGF0YS5saWdodGluZy5kaWZmdXNlLFxuICAgICAgICBzcGVjdWxhcjogZGF0YS5saWdodGluZy5zcGVjdWxhcixcbiAgICAgICAgcm91Z2huZXNzOiBkYXRhLmxpZ2h0aW5nLnJvdWdobmVzcyxcbiAgICAgICAgZnJlc25lbDogZGF0YS5saWdodGluZy5mcmVzbmVsLFxuICAgICAgICB2ZXJ0ZXhOb3JtYWxzRXBzaWxvbjogZGF0YS5saWdodGluZy52ZXJ0ZXhub3JtYWxzZXBzaWxvbixcbiAgICAgICAgZmFjZU5vcm1hbHNFcHNpbG9uOiBkYXRhLmxpZ2h0aW5nLmZhY2Vub3JtYWxzZXBzaWxvbixcbiAgICAgICAgb3BhY2l0eTogZGF0YS5vcGFjaXR5LFxuICAgICAgICBvcGFjaXR5c2NhbGU6IGRhdGEub3BhY2l0eXNjYWxlLFxuICAgICAgICBjb250b3VyRW5hYmxlOiBkYXRhLmNvbnRvdXIuc2hvdyxcbiAgICAgICAgY29udG91ckNvbG9yOiBzdHIyUmdiYUFycmF5KGRhdGEuY29udG91ci5jb2xvcikuc2xpY2UoMCwgMyksXG4gICAgICAgIGNvbnRvdXJXaWR0aDogZGF0YS5jb250b3VyLndpZHRoLFxuICAgICAgICB1c2VGYWNldE5vcm1hbHM6IGRhdGEuZmxhdHNoYWRpbmdcbiAgICB9O1xuXG4gICAgdmFyIGNPcHRzID0gZXh0cmFjdE9wdHMoZGF0YSk7XG4gICAgY29uZmlnLnZlcnRleEludGVuc2l0eSA9IGRhdGEuX21lc2hJbnRlbnNpdHk7XG4gICAgY29uZmlnLnZlcnRleEludGVuc2l0eUJvdW5kcyA9IFtjT3B0cy5taW4sIGNPcHRzLm1heF07XG4gICAgY29uZmlnLmNvbG9ybWFwID0gcGFyc2VDb2xvclNjYWxlKGRhdGEpO1xuXG4gICAgLy8gVXBkYXRlIG1lc2hcbiAgICB0aGlzLm1lc2gudXBkYXRlKGNvbmZpZyk7XG59O1xuXG5wcm90by5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zY2VuZS5nbHBsb3QucmVtb3ZlKHRoaXMubWVzaCk7XG4gICAgdGhpcy5tZXNoLmRpc3Bvc2UoKTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVZvbHVtZVRyYWNlKHNjZW5lLCBkYXRhKSB7XG4gICAgdmFyIGdsID0gc2NlbmUuZ2xwbG90LmdsO1xuICAgIHZhciBtZXNoID0gY3JlYXRlTWVzaCh7Z2w6IGdsfSk7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBWb2x1bWVUcmFjZShzY2VuZSwgbWVzaCwgZGF0YS51aWQpO1xuXG4gICAgbWVzaC5fdHJhY2UgPSByZXN1bHQ7XG4gICAgcmVzdWx0LnVwZGF0ZShkYXRhKTtcbiAgICBzY2VuZS5nbHBsb3QuYWRkKG1lc2gpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVm9sdW1lVHJhY2U7XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTItMjAyMCwgUGxvdGx5LCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaWIgPSByZXF1aXJlKCcuLi8uLi9saWInKTtcbnZhciBhdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyk7XG52YXIgc3VwcGx5SXNvRGVmYXVsdHMgPSByZXF1aXJlKCcuLi9pc29zdXJmYWNlL2RlZmF1bHRzJykuc3VwcGx5SXNvRGVmYXVsdHM7XG52YXIgb3BhY2l0eXNjYWxlRGVmYXVsdHMgPSByZXF1aXJlKCcuLi9zdXJmYWNlL2RlZmF1bHRzJykub3BhY2l0eXNjYWxlRGVmYXVsdHM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3VwcGx5RGVmYXVsdHModHJhY2VJbiwgdHJhY2VPdXQsIGRlZmF1bHRDb2xvciwgbGF5b3V0KSB7XG4gICAgZnVuY3Rpb24gY29lcmNlKGF0dHIsIGRmbHQpIHtcbiAgICAgICAgcmV0dXJuIExpYi5jb2VyY2UodHJhY2VJbiwgdHJhY2VPdXQsIGF0dHJpYnV0ZXMsIGF0dHIsIGRmbHQpO1xuICAgIH1cblxuICAgIHN1cHBseUlzb0RlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCBkZWZhdWx0Q29sb3IsIGxheW91dCwgY29lcmNlKTtcblxuICAgIG9wYWNpdHlzY2FsZURlZmF1bHRzKHRyYWNlSW4sIHRyYWNlT3V0LCBsYXlvdXQsIGNvZXJjZSk7XG59O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDEyLTIwMjAsIFBsb3RseSwgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhdHRyaWJ1dGVzOiByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKSxcbiAgICBzdXBwbHlEZWZhdWx0czogcmVxdWlyZSgnLi9kZWZhdWx0cycpLFxuICAgIGNhbGM6IHJlcXVpcmUoJy4uL2lzb3N1cmZhY2UvY2FsYycpLFxuICAgIGNvbG9yYmFyOiB7XG4gICAgICAgIG1pbjogJ2NtaW4nLFxuICAgICAgICBtYXg6ICdjbWF4J1xuICAgIH0sXG4gICAgcGxvdDogcmVxdWlyZSgnLi9jb252ZXJ0JyksXG5cbiAgICBtb2R1bGVUeXBlOiAndHJhY2UnLFxuICAgIG5hbWU6ICd2b2x1bWUnLFxuICAgIGJhc2VQbG90TW9kdWxlOiByZXF1aXJlKCcuLi8uLi9wbG90cy9nbDNkJyksXG4gICAgY2F0ZWdvcmllczogWydnbDNkJywgJ3Nob3dMZWdlbmQnXSxcbiAgICBtZXRhOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnRHJhd3Mgdm9sdW1lIHRyYWNlIGJldHdlZW4gaXNvLW1pbiBhbmQgaXNvLW1heCB2YWx1ZXMgd2l0aCBjb29yZGluYXRlcyBnaXZlbiBieScsXG4gICAgICAgICAgICAnZm91ciAxLWRpbWVuc2lvbmFsIGFycmF5cyBjb250YWluaW5nIHRoZSBgdmFsdWVgLCBgeGAsIGB5YCBhbmQgYHpgIG9mIGV2ZXJ5IHZlcnRleCcsXG4gICAgICAgICAgICAnb2YgYSB1bmlmb3JtIG9yIG5vbi11bmlmb3JtIDMtRCBncmlkLiBIb3Jpem9udGFsIG9yIHZlcnRpY2FsIHNsaWNlcywgY2FwcyBhcyB3ZWxsIGFzJyxcbiAgICAgICAgICAgICdzcGFjZWZyYW1lIGJldHdlZW4gaXNvLW1pbiBhbmQgaXNvLW1heCB2YWx1ZXMgY291bGQgYWxzbyBiZSBkcmF3biB1c2luZyB0aGlzIHRyYWNlLidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICB9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==