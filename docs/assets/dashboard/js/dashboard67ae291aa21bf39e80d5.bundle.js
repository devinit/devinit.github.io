(self["webpackChunkdi_website"] = self["webpackChunkdi_website"] || []).push([["vendors-node_modules_echarts_charts_js"],{

/***/ "./node_modules/echarts/charts.js":
/*!****************************************!*\
  !*** ./node_modules/echarts/charts.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BarChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.BarChart),
/* harmony export */   "BoxplotChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.BoxplotChart),
/* harmony export */   "CandlestickChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.CandlestickChart),
/* harmony export */   "CustomChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.CustomChart),
/* harmony export */   "EffectScatterChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.EffectScatterChart),
/* harmony export */   "FunnelChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.FunnelChart),
/* harmony export */   "GaugeChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.GaugeChart),
/* harmony export */   "GraphChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.GraphChart),
/* harmony export */   "HeatmapChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.HeatmapChart),
/* harmony export */   "LineChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.LineChart),
/* harmony export */   "LinesChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.LinesChart),
/* harmony export */   "MapChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.MapChart),
/* harmony export */   "ParallelChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.ParallelChart),
/* harmony export */   "PictorialBarChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.PictorialBarChart),
/* harmony export */   "PieChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.PieChart),
/* harmony export */   "RadarChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.RadarChart),
/* harmony export */   "SankeyChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.SankeyChart),
/* harmony export */   "ScatterChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.ScatterChart),
/* harmony export */   "SunburstChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.SunburstChart),
/* harmony export */   "ThemeRiverChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.ThemeRiverChart),
/* harmony export */   "TreeChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.TreeChart),
/* harmony export */   "TreemapChart": () => (/* reexport safe */ _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__.TreemapChart)
/* harmony export */ });
/* harmony import */ var _lib_export_charts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/export/charts */ "./node_modules/echarts/lib/export/charts.js");
/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


// In somehow. If we export like
// export * as LineChart './chart/line/install'
// The exported code will be transformed to
// import * as LineChart_1 './chart/line/install'; export {LineChart_1 as LineChart};
// Treeshaking in webpack will not work even if we configured sideEffects to false in package.json



/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/BarSeries.js":
/*!*********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/bar/BarSeries.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _BaseBarSeries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BaseBarSeries */ "./node_modules/echarts/lib/chart/bar/BaseBarSeries.js");
/* harmony import */ var _helper_createListFromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/createListFromArray */ "./node_modules/echarts/lib/chart/helper/createListFromArray.js");
/* harmony import */ var _util_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/component */ "./node_modules/echarts/lib/util/component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var BarSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(BarSeriesModel, _super);

  function BarSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = BarSeriesModel.type;
    return _this;
  }

  BarSeriesModel.prototype.getInitialData = function () {
    return (0,_helper_createListFromArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.getSource(), this, {
      useEncodeDefaulter: true,
      createInvertedIndices: !!this.get('realtimeSort', true) || null
    });
  };
  /**
   * @override
   */


  BarSeriesModel.prototype.getProgressive = function () {
    // Do not support progressive in normal mode.
    return this.get('large') ? this.get('progressive') : false;
  };
  /**
   * @override
   */


  BarSeriesModel.prototype.getProgressiveThreshold = function () {
    // Do not support progressive in normal mode.
    var progressiveThreshold = this.get('progressiveThreshold');
    var largeThreshold = this.get('largeThreshold');

    if (largeThreshold > progressiveThreshold) {
      progressiveThreshold = largeThreshold;
    }

    return progressiveThreshold;
  };

  BarSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {
    return selectors.rect(data.getItemLayout(dataIndex));
  };

  BarSeriesModel.type = 'series.bar';
  BarSeriesModel.dependencies = ['grid', 'polar'];
  BarSeriesModel.defaultOption = (0,_util_component__WEBPACK_IMPORTED_MODULE_2__.inheritDefaultOption)(_BaseBarSeries__WEBPACK_IMPORTED_MODULE_3__.default.defaultOption, {
    // If clipped
    // Only available on cartesian2d
    clip: true,
    roundCap: false,
    showBackground: false,
    backgroundStyle: {
      color: 'rgba(180, 180, 180, 0.2)',
      borderColor: null,
      borderWidth: 0,
      borderType: 'solid',
      borderRadius: 0,
      shadowBlur: 0,
      shadowColor: null,
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      opacity: 1
    },
    select: {
      itemStyle: {
        borderColor: '#212121'
      }
    },
    realtimeSort: false
  });
  return BarSeriesModel;
}(_BaseBarSeries__WEBPACK_IMPORTED_MODULE_3__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BarSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/BarView.js":
/*!*******************************************************!*\
  !*** ./node_modules/echarts/lib/chart/bar/BarView.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_graphic_Path__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! zrender/lib/graphic/Path */ "./node_modules/zrender/lib/graphic/Path.js");
/* harmony import */ var zrender_lib_graphic_Group__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/graphic/Group */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Sector.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _util_throttle__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../util/throttle */ "./node_modules/echarts/lib/util/throttle.js");
/* harmony import */ var _helper_createClipPathFromCoordSys__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helper/createClipPathFromCoordSys */ "./node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js");
/* harmony import */ var _util_shape_sausage__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/shape/sausage */ "./node_modules/echarts/lib/util/shape/sausage.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _coord_CoordinateSystem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../coord/CoordinateSystem */ "./node_modules/echarts/lib/coord/CoordinateSystem.js");
/* harmony import */ var _helper_labelHelper__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../helper/labelHelper */ "./node_modules/echarts/lib/chart/helper/labelHelper.js");
/* harmony import */ var _util_log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/log */ "./node_modules/echarts/lib/util/log.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/















var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'borderWidth'];
var BAR_BORDER_RADIUS_QUERY = ['itemStyle', 'borderRadius'];
var _eventPos = [0, 0];
var mathMax = Math.max;
var mathMin = Math.min;

function getClipArea(coord, data) {
  var coordSysClipArea = coord.getArea && coord.getArea();

  if ((0,_coord_CoordinateSystem__WEBPACK_IMPORTED_MODULE_0__.isCoordinateSystemType)(coord, 'cartesian2d')) {
    var baseAxis = coord.getBaseAxis(); // When boundaryGap is false or using time axis. bar may exceed the grid.
    // We should not clip this part.
    // See test/bar2.html

    if (baseAxis.type !== 'category' || !baseAxis.onBand) {
      var expandWidth = data.getLayout('bandWidth');

      if (baseAxis.isHorizontal()) {
        coordSysClipArea.x -= expandWidth;
        coordSysClipArea.width += expandWidth * 2;
      } else {
        coordSysClipArea.y -= expandWidth;
        coordSysClipArea.height += expandWidth * 2;
      }
    }
  }

  return coordSysClipArea;
}

var BarView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(BarView, _super);

  function BarView() {
    var _this = _super.call(this) || this;

    _this.type = BarView.type;
    _this._isFirstFrame = true;
    return _this;
  }

  BarView.prototype.render = function (seriesModel, ecModel, api, payload) {
    this._model = seriesModel;

    this._removeOnRenderedListener(api);

    this._updateDrawMode(seriesModel);

    var coordinateSystemType = seriesModel.get('coordinateSystem');

    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {
      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);
    } else if (true) {
      (0,_util_log__WEBPACK_IMPORTED_MODULE_2__.warn)('Only cartesian2d and polar supported for bar.');
    }
  };

  BarView.prototype.incrementalPrepareRender = function (seriesModel) {
    this._clear();

    this._updateDrawMode(seriesModel); // incremental also need to clip, otherwise might be overlow.
    // But must not set clip in each frame, otherwise all of the children will be marked redraw.


    this._updateLargeClip(seriesModel);
  };

  BarView.prototype.incrementalRender = function (params, seriesModel) {
    // Do not support progressive in normal mode.
    this._incrementalRenderLarge(params, seriesModel);
  };

  BarView.prototype._updateDrawMode = function (seriesModel) {
    var isLargeDraw = seriesModel.pipelineContext.large;

    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
      this._isLargeDraw = isLargeDraw;

      this._clear();
    }
  };

  BarView.prototype._renderNormal = function (seriesModel, ecModel, api, payload) {
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    var coord = seriesModel.coordinateSystem;
    var baseAxis = coord.getBaseAxis();
    var isHorizontalOrRadial;

    if (coord.type === 'cartesian2d') {
      isHorizontalOrRadial = baseAxis.isHorizontal();
    } else if (coord.type === 'polar') {
      isHorizontalOrRadial = baseAxis.dim === 'angle';
    }

    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
    var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);

    if (realtimeSortCfg) {
      this._enableRealtimeSort(realtimeSortCfg, data, api);
    }

    var needsClip = seriesModel.get('clip', true) || realtimeSortCfg;
    var coordSysClipArea = getClipArea(coord, data); // If there is clipPath created in large mode. Remove it.

    group.removeClipPath(); // We don't use clipPath in normal mode because we needs a perfect animation
    // And don't want the label are clipped.

    var roundCap = seriesModel.get('roundCap', true);
    var drawBackground = seriesModel.get('showBackground', true);
    var backgroundModel = seriesModel.getModel('backgroundStyle');
    var barBorderRadius = backgroundModel.get('borderRadius') || 0;
    var bgEls = [];
    var oldBgEls = this._backgroundEls;
    var isInitSort = payload && payload.isInitSort;
    var isChangeOrder = payload && payload.type === 'changeAxisOrder';

    function createBackground(dataIndex) {
      var bgLayout = getLayout[coord.type](data, dataIndex);
      var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
      bgEl.useStyle(backgroundModel.getItemStyle()); // Only cartesian2d support borderRadius.

      if (coord.type === 'cartesian2d') {
        bgEl.setShape('r', barBorderRadius);
      }

      bgEls[dataIndex] = bgEl;
      return bgEl;
    }

    ;
    data.diff(oldData).add(function (dataIndex) {
      var itemModel = data.getItemModel(dataIndex);
      var layout = getLayout[coord.type](data, dataIndex, itemModel);

      if (drawBackground) {
        createBackground(dataIndex);
      } // If dataZoom in filteMode: 'empty', the baseValue can be set as NaN in "axisProxy".


      if (!data.hasValue(dataIndex)) {
        return;
      }

      var isClipped = false;

      if (needsClip) {
        // Clip will modify the layout params.
        // And return a boolean to determine if the shape are fully clipped.
        isClipped = clip[coord.type](coordSysClipArea, layout);
      }

      var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);
      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');

      if (isInitSort) {
        el.attr({
          shape: layout
        });
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, dataIndex, isHorizontalOrRadial, false, false);
      } else {
        (0,_util_graphic__WEBPACK_IMPORTED_MODULE_3__.initProps)(el, {
          shape: layout
        }, seriesModel, dataIndex);
      }

      data.setItemGraphicEl(dataIndex, el);
      group.add(el);
      el.ignore = isClipped;
    }).update(function (newIndex, oldIndex) {
      var itemModel = data.getItemModel(newIndex);
      var layout = getLayout[coord.type](data, newIndex, itemModel);

      if (drawBackground) {
        var bgEl = void 0;

        if (oldBgEls.length === 0) {
          bgEl = createBackground(oldIndex);
        } else {
          bgEl = oldBgEls[oldIndex];
          bgEl.useStyle(backgroundModel.getItemStyle()); // Only cartesian2d support borderRadius.

          if (coord.type === 'cartesian2d') {
            bgEl.setShape('r', barBorderRadius);
          }

          bgEls[newIndex] = bgEl;
        }

        var bgLayout = getLayout[coord.type](data, newIndex);
        var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
        (0,_util_graphic__WEBPACK_IMPORTED_MODULE_3__.updateProps)(bgEl, {
          shape: shape
        }, animationModel, newIndex);
      }

      var el = oldData.getItemGraphicEl(oldIndex);

      if (!data.hasValue(newIndex)) {
        group.remove(el);
        el = null;
        return;
      }

      var isClipped = false;

      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout);

        if (isClipped) {
          group.remove(el);
        }
      }

      if (!el) {
        el = elementCreator[coord.type](seriesModel, data, newIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, !!el, roundCap);
      } // Not change anything if only order changed.
      // Especially not change label.


      if (!isChangeOrder) {
        updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
      }

      if (isInitSort) {
        el.attr({
          shape: layout
        });
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, newIndex, isHorizontalOrRadial, true, isChangeOrder);
      } else {
        (0,_util_graphic__WEBPACK_IMPORTED_MODULE_3__.updateProps)(el, {
          shape: layout
        }, seriesModel, newIndex, null);
      }

      data.setItemGraphicEl(newIndex, el);
      el.ignore = isClipped;
      group.add(el);
    }).remove(function (dataIndex) {
      var el = oldData.getItemGraphicEl(dataIndex);
      el && (0,_util_graphic__WEBPACK_IMPORTED_MODULE_3__.removeElementWithFadeOut)(el, seriesModel, dataIndex);
    }).execute();
    var bgGroup = this._backgroundGroup || (this._backgroundGroup = new zrender_lib_graphic_Group__WEBPACK_IMPORTED_MODULE_4__.default());
    bgGroup.removeAll();

    for (var i = 0; i < bgEls.length; ++i) {
      bgGroup.add(bgEls[i]);
    }

    group.add(bgGroup);
    this._backgroundEls = bgEls;
    this._data = data;
  };

  BarView.prototype._renderLarge = function (seriesModel, ecModel, api) {
    this._clear();

    createLarge(seriesModel, this.group);

    this._updateLargeClip(seriesModel);
  };

  BarView.prototype._incrementalRenderLarge = function (params, seriesModel) {
    this._removeBackground();

    createLarge(seriesModel, this.group, true);
  };

  BarView.prototype._updateLargeClip = function (seriesModel) {
    // Use clipPath in large mode.
    var clipPath = seriesModel.get('clip', true) ? (0,_helper_createClipPathFromCoordSys__WEBPACK_IMPORTED_MODULE_5__.createClipPath)(seriesModel.coordinateSystem, false, seriesModel) : null;

    if (clipPath) {
      this.group.setClipPath(clipPath);
    } else {
      this.group.removeClipPath();
    }
  };

  BarView.prototype._enableRealtimeSort = function (realtimeSortCfg, data, api) {
    var _this = this; // If no data in the first frame, wait for data to initSort


    if (!data.count()) {
      return;
    }

    var baseAxis = realtimeSortCfg.baseAxis;

    if (this._isFirstFrame) {
      this._dispatchInitSort(data, realtimeSortCfg, api);

      this._isFirstFrame = false;
    } else {
      var orderMapping_1 = function (idx) {
        var el = data.getItemGraphicEl(idx);

        if (el) {
          var shape = el.shape; // If data is NaN, shape.xxx may be NaN, so use || 0 here in case

          return (baseAxis.isHorizontal() // The result should be consistent with the initial sort by data value.
          // Do not support the case that both positive and negative exist.
          ? Math.abs(shape.height) : Math.abs(shape.width)) || 0;
        } else {
          return 0;
        }
      };

      this._onRendered = function () {
        _this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api);
      };

      api.getZr().on('rendered', this._onRendered);
    }
  };

  BarView.prototype._dataSort = function (data, baseAxis, orderMapping) {
    var info = [];
    data.each(data.mapDimension(baseAxis.dim), function (ordinalNumber, dataIdx) {
      var mappedValue = orderMapping(dataIdx);
      mappedValue = mappedValue == null ? NaN : mappedValue;
      info.push({
        dataIndex: dataIdx,
        mappedValue: mappedValue,
        ordinalNumber: ordinalNumber
      });
    });
    info.sort(function (a, b) {
      // If NaN, it will be treated as min val.
      return b.mappedValue - a.mappedValue;
    });
    return {
      ordinalNumbers: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_6__.map)(info, function (item) {
        return item.ordinalNumber;
      })
    };
  };

  BarView.prototype._isOrderChangedWithinSameData = function (data, orderMapping, baseAxis) {
    var scale = baseAxis.scale;
    var ordinalDataDim = data.mapDimension(baseAxis.dim);
    var lastValue = Number.MAX_VALUE;

    for (var tickNum = 0, len = scale.getOrdinalMeta().categories.length; tickNum < len; ++tickNum) {
      var rawIdx = data.rawIndexOf(ordinalDataDim, scale.getRawOrdinalNumber(tickNum));
      var value = rawIdx < 0 // If some tick have no bar, the tick will be treated as min.
      ? Number.MIN_VALUE // PENDING: if dataZoom on baseAxis exits, is it a performance issue?
      : orderMapping(data.indexOfRawIndex(rawIdx));

      if (value > lastValue) {
        return true;
      }

      lastValue = value;
    }

    return false;
  };
  /*
   * Consider the case when A and B changed order, whose representing
   * bars are both out of sight, we don't wish to trigger reorder action
   * as long as the order in the view doesn't change.
   */


  BarView.prototype._isOrderDifferentInView = function (orderInfo, baseAxis) {
    var scale = baseAxis.scale;
    var extent = scale.getExtent();
    var tickNum = Math.max(0, extent[0]);
    var tickMax = Math.min(extent[1], scale.getOrdinalMeta().categories.length - 1);

    for (; tickNum <= tickMax; ++tickNum) {
      if (orderInfo.ordinalNumbers[tickNum] !== scale.getRawOrdinalNumber(tickNum)) {
        return true;
      }
    }
  };

  BarView.prototype._updateSortWithinSameData = function (data, orderMapping, baseAxis, api) {
    if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {
      return;
    }

    var sortInfo = this._dataSort(data, baseAxis, orderMapping);

    if (this._isOrderDifferentInView(sortInfo, baseAxis)) {
      this._removeOnRenderedListener(api);

      api.dispatchAction({
        type: 'changeAxisOrder',
        componentType: baseAxis.dim + 'Axis',
        axisId: baseAxis.index,
        sortInfo: sortInfo
      });
    }
  };

  BarView.prototype._dispatchInitSort = function (data, realtimeSortCfg, api) {
    var baseAxis = realtimeSortCfg.baseAxis;

    var sortResult = this._dataSort(data, baseAxis, function (dataIdx) {
      return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);
    });

    api.dispatchAction({
      type: 'changeAxisOrder',
      componentType: baseAxis.dim + 'Axis',
      isInitSort: true,
      axisId: baseAxis.index,
      sortInfo: sortResult,
      animation: {
        // Update the axis label from the natural initial layout to
        // sorted layout should has no animation.
        duration: 0
      }
    });
  };

  BarView.prototype.remove = function (ecModel, api) {
    this._clear(this._model);

    this._removeOnRenderedListener(api);
  };

  BarView.prototype.dispose = function (ecModel, api) {
    this._removeOnRenderedListener(api);
  };

  BarView.prototype._removeOnRenderedListener = function (api) {
    if (this._onRendered) {
      api.getZr().off('rendered', this._onRendered);
      this._onRendered = null;
    }
  };

  BarView.prototype._clear = function (model) {
    var group = this.group;
    var data = this._data;

    if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {
      this._removeBackground();

      this._backgroundEls = [];
      data.eachItemGraphicEl(function (el) {
        (0,_util_graphic__WEBPACK_IMPORTED_MODULE_3__.removeElementWithFadeOut)(el, model, (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_7__.getECData)(el).dataIndex);
      });
    } else {
      group.removeAll();
    }

    this._data = null;
    this._isFirstFrame = true;
  };

  BarView.prototype._removeBackground = function () {
    this.group.remove(this._backgroundGroup);
    this._backgroundGroup = null;
  };

  BarView.type = 'bar';
  return BarView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_8__.default);

var clip = {
  cartesian2d: function (coordSysBoundingRect, layout) {
    var signWidth = layout.width < 0 ? -1 : 1;
    var signHeight = layout.height < 0 ? -1 : 1; // Needs positive width and height

    if (signWidth < 0) {
      layout.x += layout.width;
      layout.width = -layout.width;
    }

    if (signHeight < 0) {
      layout.y += layout.height;
      layout.height = -layout.height;
    }

    var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;
    var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;
    var x = mathMax(layout.x, coordSysBoundingRect.x);
    var x2 = mathMin(layout.x + layout.width, coordSysX2);
    var y = mathMax(layout.y, coordSysBoundingRect.y);
    var y2 = mathMin(layout.y + layout.height, coordSysY2);
    var xClipped = x2 < x;
    var yClipped = y2 < y; // When xClipped or yClipped, the element will be marked as `ignore`.
    // But we should also place the element at the edge of the coord sys bounding rect.
    // Beause if data changed and the bar show again, its transition animaiton
    // will begin at this place.

    layout.x = xClipped && x > coordSysX2 ? x2 : x;
    layout.y = yClipped && y > coordSysY2 ? y2 : y;
    layout.width = xClipped ? 0 : x2 - x;
    layout.height = yClipped ? 0 : y2 - y; // Reverse back

    if (signWidth < 0) {
      layout.x += layout.width;
      layout.width = -layout.width;
    }

    if (signHeight < 0) {
      layout.y += layout.height;
      layout.height = -layout.height;
    }

    return xClipped || yClipped;
  },
  polar: function (coordSysClipArea, layout) {
    var signR = layout.r0 <= layout.r ? 1 : -1; // Make sure r is larger than r0

    if (signR < 0) {
      var tmp = layout.r;
      layout.r = layout.r0;
      layout.r0 = tmp;
    }

    var r = mathMin(layout.r, coordSysClipArea.r);
    var r0 = mathMax(layout.r0, coordSysClipArea.r0);
    layout.r = r;
    layout.r0 = r0;
    var clipped = r - r0 < 0; // Reverse back

    if (signR < 0) {
      var tmp = layout.r;
      layout.r = layout.r0;
      layout.r0 = tmp;
    }

    return clipped;
  }
};
var elementCreator = {
  cartesian2d: function (seriesModel, data, newIndex, layout, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {
    var rect = new _util_graphic__WEBPACK_IMPORTED_MODULE_9__.default({
      shape: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_6__.extend)({}, layout),
      z2: 1
    });
    rect.__dataIndex = newIndex;
    rect.name = 'item';

    if (animationModel) {
      var rectShape = rect.shape;
      var animateProperty = isHorizontal ? 'height' : 'width';
      rectShape[animateProperty] = 0;
    }

    return rect;
  },
  polar: function (seriesModel, data, newIndex, layout, isRadial, animationModel, axisModel, isUpdate, roundCap) {
    // Keep the same logic with bar in catesion: use end value to control
    // direction. Notice that if clockwise is true (by default), the sector
    // will always draw clockwisely, no matter whether endAngle is greater
    // or less than startAngle.
    var clockwise = layout.startAngle < layout.endAngle;
    var ShapeClass = !isRadial && roundCap ? _util_shape_sausage__WEBPACK_IMPORTED_MODULE_10__.default : _util_graphic__WEBPACK_IMPORTED_MODULE_11__.default;
    var sector = new ShapeClass({
      shape: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_6__.defaults)({
        clockwise: clockwise
      }, layout),
      z2: 1
    });
    sector.name = 'item'; // Animation

    if (animationModel) {
      var sectorShape = sector.shape;
      var animateProperty = isRadial ? 'r' : 'endAngle';
      var animateTarget = {};
      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;
      animateTarget[animateProperty] = layout[animateProperty];
      (isUpdate ? _util_graphic__WEBPACK_IMPORTED_MODULE_3__.updateProps : _util_graphic__WEBPACK_IMPORTED_MODULE_3__.initProps)(sector, {
        shape: animateTarget // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue

      }, animationModel);
    }

    return sector;
  }
};

function shouldRealtimeSort(seriesModel, coordSys) {
  var realtimeSortOption = seriesModel.get('realtimeSort', true);
  var baseAxis = coordSys.getBaseAxis();

  if (true) {
    if (realtimeSortOption) {
      if (baseAxis.type !== 'category') {
        (0,_util_log__WEBPACK_IMPORTED_MODULE_2__.warn)('`realtimeSort` will not work because this bar series is not based on a category axis.');
      }

      if (coordSys.type !== 'cartesian2d') {
        (0,_util_log__WEBPACK_IMPORTED_MODULE_2__.warn)('`realtimeSort` will not work because this bar series is not on cartesian2d.');
      }
    }
  }

  if (realtimeSortOption && baseAxis.type === 'category' && coordSys.type === 'cartesian2d') {
    return {
      baseAxis: baseAxis,
      otherAxis: coordSys.getOtherAxis(baseAxis)
    };
  }
}

function updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout, newIndex, isHorizontal, isUpdate, isChangeOrder) {
  var seriesTarget;
  var axisTarget;

  if (isHorizontal) {
    axisTarget = {
      x: layout.x,
      width: layout.width
    };
    seriesTarget = {
      y: layout.y,
      height: layout.height
    };
  } else {
    axisTarget = {
      y: layout.y,
      height: layout.height
    };
    seriesTarget = {
      x: layout.x,
      width: layout.width
    };
  }

  if (!isChangeOrder) {
    // Keep the original growth animation if only axis order changed.
    // Not start a new animation.
    (isUpdate ? _util_graphic__WEBPACK_IMPORTED_MODULE_3__.updateProps : _util_graphic__WEBPACK_IMPORTED_MODULE_3__.initProps)(el, {
      shape: seriesTarget
    }, seriesAnimationModel, newIndex, null);
  }

  var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;
  (isUpdate ? _util_graphic__WEBPACK_IMPORTED_MODULE_3__.updateProps : _util_graphic__WEBPACK_IMPORTED_MODULE_3__.initProps)(el, {
    shape: axisTarget
  }, axisAnimationModel, newIndex);
}

var getLayout = {
  // itemModel is only used to get borderWidth, which is not needed
  // when calculating bar background layout.
  cartesian2d: function (data, dataIndex, itemModel) {
    var layout = data.getItemLayout(dataIndex);
    var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout) : 0; // fix layout with lineWidth

    var signX = layout.width > 0 ? 1 : -1;
    var signY = layout.height > 0 ? 1 : -1;
    return {
      x: layout.x + signX * fixedLineWidth / 2,
      y: layout.y + signY * fixedLineWidth / 2,
      width: layout.width - signX * fixedLineWidth,
      height: layout.height - signY * fixedLineWidth
    };
  },
  polar: function (data, dataIndex, itemModel) {
    var layout = data.getItemLayout(dataIndex);
    return {
      cx: layout.cx,
      cy: layout.cy,
      r0: layout.r0,
      r: layout.r,
      startAngle: layout.startAngle,
      endAngle: layout.endAngle
    };
  }
};

function isZeroOnPolar(layout) {
  return layout.startAngle != null && layout.endAngle != null && layout.startAngle === layout.endAngle;
}

function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {
  var style = data.getItemVisual(dataIndex, 'style');

  if (!isPolar) {
    el.setShape('r', itemModel.get(BAR_BORDER_RADIUS_QUERY) || 0);
  }

  el.useStyle(style);
  var cursorStyle = itemModel.getShallow('cursor');
  cursorStyle && el.attr('cursor', cursorStyle);

  if (!isPolar) {
    var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';
    var labelStatesModels = (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_12__.getLabelStatesModels)(itemModel);
    (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_12__.setLabelStyle)(el, labelStatesModels, {
      labelFetcher: seriesModel,
      labelDataIndex: dataIndex,
      defaultText: (0,_helper_labelHelper__WEBPACK_IMPORTED_MODULE_13__.getDefaultLabel)(seriesModel.getData(), dataIndex),
      inheritColor: style.fill,
      defaultOpacity: style.opacity,
      defaultOutsidePosition: labelPositionOutside
    });
    var label = el.getTextContent();
    (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_12__.setLabelValueAnimation)(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function (value) {
      return (0,_helper_labelHelper__WEBPACK_IMPORTED_MODULE_13__.getDefaultInterpolatedLabel)(data, value);
    });
  }

  var emphasisModel = itemModel.getModel(['emphasis']);
  (0,_util_states__WEBPACK_IMPORTED_MODULE_14__.enableHoverEmphasis)(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'));
  (0,_util_states__WEBPACK_IMPORTED_MODULE_14__.setStatesStylesFromModel)(el, itemModel);

  if (isZeroOnPolar(layout)) {
    el.style.fill = 'none';
    el.style.stroke = 'none';
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_6__.each)(el.states, function (state) {
      if (state.style) {
        state.style.fill = state.style.stroke = 'none';
      }
    });
  }
} // In case width or height are too small.


function getLineWidth(itemModel, rawLayout) {
  var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0; // width or height may be NaN for empty data

  var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
  var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
  return Math.min(lineWidth, width, height);
}

var LagePathShape =
/** @class */
function () {
  function LagePathShape() {}

  return LagePathShape;
}();

var LargePath =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(LargePath, _super);

  function LargePath(opts) {
    var _this = _super.call(this, opts) || this;

    _this.type = 'largeBar';
    return _this;
  }

  ;

  LargePath.prototype.getDefaultShape = function () {
    return new LagePathShape();
  };

  LargePath.prototype.buildPath = function (ctx, shape) {
    // Drawing lines is more efficient than drawing
    // a whole line or drawing rects.
    var points = shape.points;
    var startPoint = this.__startPoint;
    var baseDimIdx = this.__baseDimIdx;

    for (var i = 0; i < points.length; i += 2) {
      startPoint[baseDimIdx] = points[i + baseDimIdx];
      ctx.moveTo(startPoint[0], startPoint[1]);
      ctx.lineTo(points[i], points[i + 1]);
    }
  };

  return LargePath;
}(zrender_lib_graphic_Path__WEBPACK_IMPORTED_MODULE_15__.default);

function createLarge(seriesModel, group, incremental) {
  // TODO support polar
  var data = seriesModel.getData();
  var startPoint = [];
  var baseDimIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0;
  startPoint[1 - baseDimIdx] = data.getLayout('valueAxisStart');
  var largeDataIndices = data.getLayout('largeDataIndices');
  var barWidth = data.getLayout('barWidth');
  var backgroundModel = seriesModel.getModel('backgroundStyle');
  var drawBackground = seriesModel.get('showBackground', true);

  if (drawBackground) {
    var points = data.getLayout('largeBackgroundPoints');
    var backgroundStartPoint = [];
    backgroundStartPoint[1 - baseDimIdx] = data.getLayout('backgroundStart');
    var bgEl = new LargePath({
      shape: {
        points: points
      },
      incremental: !!incremental,
      silent: true,
      z2: 0
    });
    bgEl.__startPoint = backgroundStartPoint;
    bgEl.__baseDimIdx = baseDimIdx;
    bgEl.__largeDataIndices = largeDataIndices;
    bgEl.__barWidth = barWidth;
    setLargeBackgroundStyle(bgEl, backgroundModel, data);
    group.add(bgEl);
  }

  var el = new LargePath({
    shape: {
      points: data.getLayout('largePoints')
    },
    incremental: !!incremental
  });
  el.__startPoint = startPoint;
  el.__baseDimIdx = baseDimIdx;
  el.__largeDataIndices = largeDataIndices;
  el.__barWidth = barWidth;
  group.add(el);
  setLargeStyle(el, seriesModel, data); // Enable tooltip and user mouse/touch event handlers.

  (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_7__.getECData)(el).seriesIndex = seriesModel.seriesIndex;

  if (!seriesModel.get('silent')) {
    el.on('mousedown', largePathUpdateDataIndex);
    el.on('mousemove', largePathUpdateDataIndex);
  }
} // Use throttle to avoid frequently traverse to find dataIndex.


var largePathUpdateDataIndex = (0,_util_throttle__WEBPACK_IMPORTED_MODULE_16__.throttle)(function (event) {
  var largePath = this;
  var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
  (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_7__.getECData)(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;
}, 30, false);

function largePathFindDataIndex(largePath, x, y) {
  var baseDimIdx = largePath.__baseDimIdx;
  var valueDimIdx = 1 - baseDimIdx;
  var points = largePath.shape.points;
  var largeDataIndices = largePath.__largeDataIndices;
  var barWidthHalf = Math.abs(largePath.__barWidth / 2);
  var startValueVal = largePath.__startPoint[valueDimIdx];
  _eventPos[0] = x;
  _eventPos[1] = y;
  var pointerBaseVal = _eventPos[baseDimIdx];
  var pointerValueVal = _eventPos[1 - baseDimIdx];
  var baseLowerBound = pointerBaseVal - barWidthHalf;
  var baseUpperBound = pointerBaseVal + barWidthHalf;

  for (var i = 0, len = points.length / 2; i < len; i++) {
    var ii = i * 2;
    var barBaseVal = points[ii + baseDimIdx];
    var barValueVal = points[ii + valueDimIdx];

    if (barBaseVal >= baseLowerBound && barBaseVal <= baseUpperBound && (startValueVal <= barValueVal ? pointerValueVal >= startValueVal && pointerValueVal <= barValueVal : pointerValueVal >= barValueVal && pointerValueVal <= startValueVal)) {
      return largeDataIndices[i];
    }
  }

  return -1;
}

function setLargeStyle(el, seriesModel, data) {
  var globalStyle = data.getVisual('style');
  el.useStyle((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_6__.extend)({}, globalStyle)); // Use stroke instead of fill.

  el.style.fill = null;
  el.style.stroke = globalStyle.fill;
  el.style.lineWidth = data.getLayout('barWidth');
}

function setLargeBackgroundStyle(el, backgroundModel, data) {
  var borderColor = backgroundModel.get('borderColor') || backgroundModel.get('color');
  var itemStyle = backgroundModel.getItemStyle();
  el.useStyle(itemStyle);
  el.style.fill = null;
  el.style.stroke = borderColor;
  el.style.lineWidth = data.getLayout('barWidth');
}

function createBackgroundShape(isHorizontalOrRadial, layout, coord) {
  if ((0,_coord_CoordinateSystem__WEBPACK_IMPORTED_MODULE_0__.isCoordinateSystemType)(coord, 'cartesian2d')) {
    var rectShape = layout;
    var coordLayout = coord.getArea();
    return {
      x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,
      y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,
      width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,
      height: isHorizontalOrRadial ? coordLayout.height : rectShape.height
    };
  } else {
    var coordLayout = coord.getArea();
    var sectorShape = layout;
    return {
      cx: coordLayout.cx,
      cy: coordLayout.cy,
      r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,
      r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,
      startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,
      endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2
    };
  }
}

function createBackgroundEl(coord, isHorizontalOrRadial, layout) {
  var ElementClz = coord.type === 'polar' ? _util_graphic__WEBPACK_IMPORTED_MODULE_11__.default : _util_graphic__WEBPACK_IMPORTED_MODULE_9__.default;
  return new ElementClz({
    shape: createBackgroundShape(isHorizontalOrRadial, layout, coord),
    silent: true,
    z2: 0
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BarView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/BaseBarSeries.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/bar/BaseBarSeries.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var _helper_createListFromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/createListFromArray */ "./node_modules/echarts/lib/chart/helper/createListFromArray.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var BaseBarSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(BaseBarSeriesModel, _super);

  function BaseBarSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = BaseBarSeriesModel.type;
    return _this;
  }

  BaseBarSeriesModel.prototype.getInitialData = function (option, ecModel) {
    return (0,_helper_createListFromArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.getSource(), this, {
      useEncodeDefaulter: true
    });
  };

  BaseBarSeriesModel.prototype.getMarkerPosition = function (value) {
    var coordSys = this.coordinateSystem;

    if (coordSys) {
      // PENDING if clamp ?
      var pt = coordSys.dataToPoint(coordSys.clampData(value));
      var data = this.getData();
      var offset = data.getLayout('offset');
      var size = data.getLayout('size');
      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
      pt[offsetIndex] += offset + size / 2;
      return pt;
    }

    return [NaN, NaN];
  };

  BaseBarSeriesModel.type = 'series.__base_bar__';
  BaseBarSeriesModel.defaultOption = {
    zlevel: 0,
    z: 2,
    coordinateSystem: 'cartesian2d',
    legendHoverLink: true,
    // stack: null
    // Cartesian coordinate system
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    barMinHeight: 0,
    barMinAngle: 0,
    // cursor: null,
    large: false,
    largeThreshold: 400,
    progressive: 3e3,
    progressiveChunkMode: 'mod'
  };
  return BaseBarSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_2__.default);

_model_Series__WEBPACK_IMPORTED_MODULE_2__.default.registerClass(BaseBarSeriesModel);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseBarSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/PictorialBarSeries.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/bar/PictorialBarSeries.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _BaseBarSeries__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseBarSeries */ "./node_modules/echarts/lib/chart/bar/BaseBarSeries.js");
/* harmony import */ var _util_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/component */ "./node_modules/echarts/lib/util/component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var PictorialBarSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(PictorialBarSeriesModel, _super);

  function PictorialBarSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = PictorialBarSeriesModel.type;
    _this.hasSymbolVisual = true;
    _this.defaultSymbol = 'roundRect';
    return _this;
  }

  PictorialBarSeriesModel.prototype.getInitialData = function (option) {
    // Disable stack.
    option.stack = null;
    return _super.prototype.getInitialData.apply(this, arguments);
  };

  PictorialBarSeriesModel.type = 'series.pictorialBar';
  PictorialBarSeriesModel.dependencies = ['grid'];
  PictorialBarSeriesModel.defaultOption = (0,_util_component__WEBPACK_IMPORTED_MODULE_1__.inheritDefaultOption)(_BaseBarSeries__WEBPACK_IMPORTED_MODULE_2__.default.defaultOption, {
    symbol: 'circle',
    symbolSize: null,
    symbolRotate: null,
    symbolPosition: null,
    symbolOffset: null,
    symbolMargin: null,
    symbolRepeat: false,
    symbolRepeatDirection: 'end',
    symbolClip: false,
    symbolBoundingData: null,
    symbolPatternSize: 400,
    barGap: '-100%',
    // z can be set in data item, which is z2 actually.
    // Disable progressive
    progressive: 0,
    emphasis: {
      // By default pictorialBar do not hover scale. Hover scale is not suitable
      // for the case that both has foreground and background.
      scale: false
    },
    select: {
      itemStyle: {
        borderColor: '#212121'
      }
    }
  });
  return PictorialBarSeriesModel;
}(_BaseBarSeries__WEBPACK_IMPORTED_MODULE_2__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PictorialBarSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/PictorialBarView.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/bar/PictorialBarView.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Circle.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _util_symbol__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/symbol */ "./node_modules/echarts/lib/util/symbol.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _helper_labelHelper__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../helper/labelHelper */ "./node_modules/echarts/lib/chart/helper/labelHelper.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var zrender_lib_graphic_Image__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! zrender/lib/graphic/Image */ "./node_modules/zrender/lib/graphic/Image.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/











var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'borderWidth']; // index: +isHorizontal

var LAYOUT_ATTRS = [{
  xy: 'x',
  wh: 'width',
  index: 0,
  posDesc: ['left', 'right']
}, {
  xy: 'y',
  wh: 'height',
  index: 1,
  posDesc: ['top', 'bottom']
}];
var pathForLineWidth = new _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default();

var PictorialBarView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(PictorialBarView, _super);

  function PictorialBarView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = PictorialBarView.type;
    return _this;
  }

  PictorialBarView.prototype.render = function (seriesModel, ecModel, api) {
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var isHorizontal = baseAxis.isHorizontal();
    var coordSysRect = cartesian.master.getRect();
    var opt = {
      ecSize: {
        width: api.getWidth(),
        height: api.getHeight()
      },
      seriesModel: seriesModel,
      coordSys: cartesian,
      coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],
      isHorizontal: isHorizontal,
      valueDim: LAYOUT_ATTRS[+isHorizontal],
      categoryDim: LAYOUT_ATTRS[1 - +isHorizontal]
    };
    data.diff(oldData).add(function (dataIndex) {
      if (!data.hasValue(dataIndex)) {
        return;
      }

      var itemModel = getItemModel(data, dataIndex);
      var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);
      var bar = createBar(data, opt, symbolMeta);
      data.setItemGraphicEl(dataIndex, bar);
      group.add(bar);
      updateCommon(bar, opt, symbolMeta);
    }).update(function (newIndex, oldIndex) {
      var bar = oldData.getItemGraphicEl(oldIndex);

      if (!data.hasValue(newIndex)) {
        group.remove(bar);
        return;
      }

      var itemModel = getItemModel(data, newIndex);
      var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);
      var pictorialShapeStr = getShapeStr(data, symbolMeta);

      if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {
        group.remove(bar);
        data.setItemGraphicEl(newIndex, null);
        bar = null;
      }

      if (bar) {
        updateBar(bar, opt, symbolMeta);
      } else {
        bar = createBar(data, opt, symbolMeta, true);
      }

      data.setItemGraphicEl(newIndex, bar);
      bar.__pictorialSymbolMeta = symbolMeta; // Add back

      group.add(bar);
      updateCommon(bar, opt, symbolMeta);
    }).remove(function (dataIndex) {
      var bar = oldData.getItemGraphicEl(dataIndex);
      bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);
    }).execute();
    this._data = data;
    return this.group;
  };

  PictorialBarView.prototype.remove = function (ecModel, api) {
    var group = this.group;
    var data = this._data;

    if (ecModel.get('animation')) {
      if (data) {
        data.eachItemGraphicEl(function (bar) {
          removeBar(data, (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_2__.getECData)(bar).dataIndex, ecModel, bar);
        });
      }
    } else {
      group.removeAll();
    }
  };

  PictorialBarView.type = 'pictorialBar';
  return PictorialBarView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_3__.default); // Set or calculate default value about symbol, and calculate layout info.


function getSymbolMeta(data, dataIndex, itemModel, opt) {
  var layout = data.getItemLayout(dataIndex);
  var symbolRepeat = itemModel.get('symbolRepeat');
  var symbolClip = itemModel.get('symbolClip');
  var symbolPosition = itemModel.get('symbolPosition') || 'start';
  var symbolRotate = itemModel.get('symbolRotate');
  var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
  var symbolPatternSize = itemModel.get('symbolPatternSize') || 2;
  var isAnimationEnabled = itemModel.isAnimationEnabled();
  var symbolMeta = {
    dataIndex: dataIndex,
    layout: layout,
    itemModel: itemModel,
    symbolType: data.getItemVisual(dataIndex, 'symbol') || 'circle',
    style: data.getItemVisual(dataIndex, 'style'),
    symbolClip: symbolClip,
    symbolRepeat: symbolRepeat,
    symbolRepeatDirection: itemModel.get('symbolRepeatDirection'),
    symbolPatternSize: symbolPatternSize,
    rotation: rotation,
    animationModel: isAnimationEnabled ? itemModel : null,
    hoverScale: isAnimationEnabled && itemModel.get(['emphasis', 'scale']),
    z2: itemModel.getShallow('z', true) || 0
  };
  prepareBarLength(itemModel, symbolRepeat, layout, opt, symbolMeta);
  prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);
  prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);
  var symbolSize = symbolMeta.symbolSize;
  var symbolOffset = itemModel.get('symbolOffset');

  if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.isArray(symbolOffset)) {
    symbolOffset = [(0,_util_number__WEBPACK_IMPORTED_MODULE_5__.parsePercent)(symbolOffset[0], symbolSize[0]), (0,_util_number__WEBPACK_IMPORTED_MODULE_5__.parsePercent)(symbolOffset[1], symbolSize[1])];
  }

  prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);
  return symbolMeta;
} // bar length can be negative.


function prepareBarLength(itemModel, symbolRepeat, layout, opt, outputSymbolMeta) {
  var valueDim = opt.valueDim;
  var symbolBoundingData = itemModel.get('symbolBoundingData');
  var valueAxis = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());
  var zeroPx = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));
  var pxSignIdx = 1 - +(layout[valueDim.wh] <= 0);
  var boundingLength;

  if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.isArray(symbolBoundingData)) {
    var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis, symbolBoundingData[1]) - zeroPx];
    symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();
    boundingLength = symbolBoundingExtent[pxSignIdx];
  } else if (symbolBoundingData != null) {
    boundingLength = convertToCoordOnAxis(valueAxis, symbolBoundingData) - zeroPx;
  } else if (symbolRepeat) {
    boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;
  } else {
    boundingLength = layout[valueDim.wh];
  }

  outputSymbolMeta.boundingLength = boundingLength;

  if (symbolRepeat) {
    outputSymbolMeta.repeatCutLength = layout[valueDim.wh];
  }

  outputSymbolMeta.pxSign = boundingLength > 0 ? 1 : boundingLength < 0 ? -1 : 0;
}

function convertToCoordOnAxis(axis, value) {
  return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));
} // Support ['100%', '100%']


function prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, outputSymbolMeta) {
  var valueDim = opt.valueDim;
  var categoryDim = opt.categoryDim;
  var categorySize = Math.abs(layout[categoryDim.wh]);
  var symbolSize = data.getItemVisual(dataIndex, 'symbolSize');
  var parsedSymbolSize;

  if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.isArray(symbolSize)) {
    parsedSymbolSize = symbolSize.slice();
  } else {
    if (symbolSize == null) {
      // will parse to number below
      parsedSymbolSize = ['100%', '100%'];
    } else {
      parsedSymbolSize = [symbolSize, symbolSize];
    }
  } // Note: percentage symbolSize (like '100%') do not consider lineWidth, because it is
  // to complicated to calculate real percent value if considering scaled lineWidth.
  // So the actual size will bigger than layout size if lineWidth is bigger than zero,
  // which can be tolerated in pictorial chart.


  parsedSymbolSize[categoryDim.index] = (0,_util_number__WEBPACK_IMPORTED_MODULE_5__.parsePercent)(parsedSymbolSize[categoryDim.index], categorySize);
  parsedSymbolSize[valueDim.index] = (0,_util_number__WEBPACK_IMPORTED_MODULE_5__.parsePercent)(parsedSymbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));
  outputSymbolMeta.symbolSize = parsedSymbolSize; // If x or y is less than zero, show reversed shape.

  var symbolScale = outputSymbolMeta.symbolScale = [parsedSymbolSize[0] / symbolPatternSize, parsedSymbolSize[1] / symbolPatternSize]; // Follow convention, 'right' and 'top' is the normal scale.

  symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;
}

function prepareLineWidth(itemModel, symbolScale, rotation, opt, outputSymbolMeta) {
  // In symbols are drawn with scale, so do not need to care about the case that width
  // or height are too small. But symbol use strokeNoScale, where acture lineWidth should
  // be calculated.
  var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;

  if (valueLineWidth) {
    pathForLineWidth.attr({
      scaleX: symbolScale[0],
      scaleY: symbolScale[1],
      rotation: rotation
    });
    pathForLineWidth.updateTransform();
    valueLineWidth /= pathForLineWidth.getLineScale();
    valueLineWidth *= symbolScale[opt.valueDim.index];
  }

  outputSymbolMeta.valueLineWidth = valueLineWidth;
}

function prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, outputSymbolMeta) {
  var categoryDim = opt.categoryDim;
  var valueDim = opt.valueDim;
  var pxSign = outputSymbolMeta.pxSign;
  var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);
  var pathLen = unitLength; // Note: rotation will not effect the layout of symbols, because user may
  // want symbols to rotate on its center, which should not be translated
  // when rotating.

  if (symbolRepeat) {
    var absBoundingLength = Math.abs(boundingLength);
    var symbolMargin = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.retrieve(itemModel.get('symbolMargin'), '15%') + '';
    var hasEndGap = false;

    if (symbolMargin.lastIndexOf('!') === symbolMargin.length - 1) {
      hasEndGap = true;
      symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);
    }

    var symbolMarginNumeric = (0,_util_number__WEBPACK_IMPORTED_MODULE_5__.parsePercent)(symbolMargin, symbolSize[valueDim.index]);
    var uLenWithMargin = Math.max(unitLength + symbolMarginNumeric * 2, 0); // When symbol margin is less than 0, margin at both ends will be subtracted
    // to ensure that all of the symbols will not be overflow the given area.

    var endFix = hasEndGap ? 0 : symbolMarginNumeric * 2; // Both final repeatTimes and final symbolMarginNumeric area calculated based on
    // boundingLength.

    var repeatSpecified = (0,_util_number__WEBPACK_IMPORTED_MODULE_5__.isNumeric)(symbolRepeat);
    var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin); // Adjust calculate margin, to ensure each symbol is displayed
    // entirely in the given layout area.

    var mDiff = absBoundingLength - repeatTimes * unitLength;
    symbolMarginNumeric = mDiff / 2 / (hasEndGap ? repeatTimes : repeatTimes - 1);
    uLenWithMargin = unitLength + symbolMarginNumeric * 2;
    endFix = hasEndGap ? 0 : symbolMarginNumeric * 2; // Update repeatTimes when not all symbol will be shown.

    if (!repeatSpecified && symbolRepeat !== 'fixed') {
      repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;
    }

    pathLen = repeatTimes * uLenWithMargin - endFix;
    outputSymbolMeta.repeatTimes = repeatTimes;
    outputSymbolMeta.symbolMargin = symbolMarginNumeric;
  }

  var sizeFix = pxSign * (pathLen / 2);
  var pathPosition = outputSymbolMeta.pathPosition = [];
  pathPosition[categoryDim.index] = layout[categoryDim.wh] / 2;
  pathPosition[valueDim.index] = symbolPosition === 'start' ? sizeFix : symbolPosition === 'end' ? boundingLength - sizeFix : boundingLength / 2; // 'center'

  if (symbolOffset) {
    pathPosition[0] += symbolOffset[0];
    pathPosition[1] += symbolOffset[1];
  }

  var bundlePosition = outputSymbolMeta.bundlePosition = [];
  bundlePosition[categoryDim.index] = layout[categoryDim.xy];
  bundlePosition[valueDim.index] = layout[valueDim.xy];
  var barRectShape = outputSymbolMeta.barRectShape = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.extend({}, layout);
  barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));
  barRectShape[categoryDim.wh] = layout[categoryDim.wh];
  var clipShape = outputSymbolMeta.clipShape = {}; // Consider that symbol may be overflow layout rect.

  clipShape[categoryDim.xy] = -layout[categoryDim.xy];
  clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];
  clipShape[valueDim.xy] = 0;
  clipShape[valueDim.wh] = layout[valueDim.wh];
}

function createPath(symbolMeta) {
  var symbolPatternSize = symbolMeta.symbolPatternSize;
  var path = (0,_util_symbol__WEBPACK_IMPORTED_MODULE_6__.createSymbol)( // Consider texture img, make a big size.
  symbolMeta.symbolType, -symbolPatternSize / 2, -symbolPatternSize / 2, symbolPatternSize, symbolPatternSize);
  path.attr({
    culling: true
  });
  path.type !== 'image' && path.setStyle({
    strokeNoScale: true
  });
  return path;
}

function createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {
  var bundle = bar.__pictorialBundle;
  var symbolSize = symbolMeta.symbolSize;
  var valueLineWidth = symbolMeta.valueLineWidth;
  var pathPosition = symbolMeta.pathPosition;
  var valueDim = opt.valueDim;
  var repeatTimes = symbolMeta.repeatTimes || 0;
  var index = 0;
  var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;
  eachPath(bar, function (path) {
    path.__pictorialAnimationIndex = index;
    path.__pictorialRepeatTimes = repeatTimes;

    if (index < repeatTimes) {
      updateAttr(path, null, makeTarget(index), symbolMeta, isUpdate);
    } else {
      updateAttr(path, null, {
        scaleX: 0,
        scaleY: 0
      }, symbolMeta, isUpdate, function () {
        bundle.remove(path);
      });
    } // updateHoverAnimation(path, symbolMeta);


    index++;
  });

  for (; index < repeatTimes; index++) {
    var path = createPath(symbolMeta);
    path.__pictorialAnimationIndex = index;
    path.__pictorialRepeatTimes = repeatTimes;
    bundle.add(path);
    var target = makeTarget(index);
    updateAttr(path, {
      x: target.x,
      y: target.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: target.scaleX,
      scaleY: target.scaleY,
      rotation: target.rotation
    }, symbolMeta, isUpdate);
  }

  function makeTarget(index) {
    var position = pathPosition.slice(); // (start && pxSign > 0) || (end && pxSign < 0): i = repeatTimes - index
    // Otherwise: i = index;

    var pxSign = symbolMeta.pxSign;
    var i = index;

    if (symbolMeta.symbolRepeatDirection === 'start' ? pxSign > 0 : pxSign < 0) {
      i = repeatTimes - 1 - index;
    }

    position[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];
    return {
      x: position[0],
      y: position[1],
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1],
      rotation: symbolMeta.rotation
    };
  }
}

function createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {
  var bundle = bar.__pictorialBundle;
  var mainPath = bar.__pictorialMainPath;

  if (!mainPath) {
    mainPath = bar.__pictorialMainPath = createPath(symbolMeta);
    bundle.add(mainPath);
    updateAttr(mainPath, {
      x: symbolMeta.pathPosition[0],
      y: symbolMeta.pathPosition[1],
      scaleX: 0,
      scaleY: 0,
      rotation: symbolMeta.rotation
    }, {
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1]
    }, symbolMeta, isUpdate);
  } else {
    updateAttr(mainPath, null, {
      x: symbolMeta.pathPosition[0],
      y: symbolMeta.pathPosition[1],
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1],
      rotation: symbolMeta.rotation
    }, symbolMeta, isUpdate);
  }
} // bar rect is used for label.


function createOrUpdateBarRect(bar, symbolMeta, isUpdate) {
  var rectShape = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.extend({}, symbolMeta.barRectShape);
  var barRect = bar.__pictorialBarRect;

  if (!barRect) {
    barRect = bar.__pictorialBarRect = new _util_graphic__WEBPACK_IMPORTED_MODULE_7__.default({
      z2: 2,
      shape: rectShape,
      silent: true,
      style: {
        stroke: 'transparent',
        fill: 'transparent',
        lineWidth: 0
      }
    });
    bar.add(barRect);
  } else {
    updateAttr(barRect, null, {
      shape: rectShape
    }, symbolMeta, isUpdate);
  }
}

function createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {
  // If not clip, symbol will be remove and rebuilt.
  if (symbolMeta.symbolClip) {
    var clipPath = bar.__pictorialClipPath;
    var clipShape = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.extend({}, symbolMeta.clipShape);
    var valueDim = opt.valueDim;
    var animationModel = symbolMeta.animationModel;
    var dataIndex = symbolMeta.dataIndex;

    if (clipPath) {
      _util_graphic__WEBPACK_IMPORTED_MODULE_8__.updateProps(clipPath, {
        shape: clipShape
      }, animationModel, dataIndex);
    } else {
      clipShape[valueDim.wh] = 0;
      clipPath = new _util_graphic__WEBPACK_IMPORTED_MODULE_7__.default({
        shape: clipShape
      });

      bar.__pictorialBundle.setClipPath(clipPath);

      bar.__pictorialClipPath = clipPath;
      var target = {};
      target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];
      _util_graphic__WEBPACK_IMPORTED_MODULE_8__[isUpdate ? 'updateProps' : 'initProps'](clipPath, {
        shape: target
      }, animationModel, dataIndex);
    }
  }
}

function getItemModel(data, dataIndex) {
  var itemModel = data.getItemModel(dataIndex);
  itemModel.getAnimationDelayParams = getAnimationDelayParams;
  itemModel.isAnimationEnabled = isAnimationEnabled;
  return itemModel;
}

function getAnimationDelayParams(path) {
  // The order is the same as the z-order, see `symbolRepeatDiretion`.
  return {
    index: path.__pictorialAnimationIndex,
    count: path.__pictorialRepeatTimes
  };
}

function isAnimationEnabled() {
  // `animation` prop can be set on itemModel in pictorial bar chart.
  return this.parentModel.isAnimationEnabled() && !!this.getShallow('animation');
}

function createBar(data, opt, symbolMeta, isUpdate) {
  // bar is the main element for each data.
  var bar = new _util_graphic__WEBPACK_IMPORTED_MODULE_9__.default(); // bundle is used for location and clip.

  var bundle = new _util_graphic__WEBPACK_IMPORTED_MODULE_9__.default();
  bar.add(bundle);
  bar.__pictorialBundle = bundle;
  bundle.x = symbolMeta.bundlePosition[0];
  bundle.y = symbolMeta.bundlePosition[1];

  if (symbolMeta.symbolRepeat) {
    createOrUpdateRepeatSymbols(bar, opt, symbolMeta);
  } else {
    createOrUpdateSingleSymbol(bar, opt, symbolMeta);
  }

  createOrUpdateBarRect(bar, symbolMeta, isUpdate);
  createOrUpdateClip(bar, opt, symbolMeta, isUpdate);
  bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);
  bar.__pictorialSymbolMeta = symbolMeta;
  return bar;
}

function updateBar(bar, opt, symbolMeta) {
  var animationModel = symbolMeta.animationModel;
  var dataIndex = symbolMeta.dataIndex;
  var bundle = bar.__pictorialBundle;
  _util_graphic__WEBPACK_IMPORTED_MODULE_8__.updateProps(bundle, {
    x: symbolMeta.bundlePosition[0],
    y: symbolMeta.bundlePosition[1]
  }, animationModel, dataIndex);

  if (symbolMeta.symbolRepeat) {
    createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);
  } else {
    createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);
  }

  createOrUpdateBarRect(bar, symbolMeta, true);
  createOrUpdateClip(bar, opt, symbolMeta, true);
}

function removeBar(data, dataIndex, animationModel, bar) {
  // Not show text when animating
  var labelRect = bar.__pictorialBarRect;
  labelRect && labelRect.removeTextContent();
  var pathes = [];
  eachPath(bar, function (path) {
    pathes.push(path);
  });
  bar.__pictorialMainPath && pathes.push(bar.__pictorialMainPath); // I do not find proper remove animation for clip yet.

  bar.__pictorialClipPath && (animationModel = null);
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.each(pathes, function (path) {
    _util_graphic__WEBPACK_IMPORTED_MODULE_8__.removeElement(path, {
      scaleX: 0,
      scaleY: 0
    }, animationModel, dataIndex, function () {
      bar.parent && bar.parent.remove(bar);
    });
  });
  data.setItemGraphicEl(dataIndex, null);
}

function getShapeStr(data, symbolMeta) {
  return [data.getItemVisual(symbolMeta.dataIndex, 'symbol') || 'none', !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(':');
}

function eachPath(bar, cb, context) {
  // Do not use Group#eachChild, because it do not support remove.
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.each(bar.__pictorialBundle.children(), function (el) {
    el !== bar.__pictorialBarRect && cb.call(context, el);
  });
}

function updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {
  immediateAttrs && el.attr(immediateAttrs); // when symbolCip used, only clip path has init animation, otherwise it would be weird effect.

  if (symbolMeta.symbolClip && !isUpdate) {
    animationAttrs && el.attr(animationAttrs);
  } else {
    animationAttrs && _util_graphic__WEBPACK_IMPORTED_MODULE_8__[isUpdate ? 'updateProps' : 'initProps'](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);
  }
}

function updateCommon(bar, opt, symbolMeta) {
  var dataIndex = symbolMeta.dataIndex;
  var itemModel = symbolMeta.itemModel; // Color must be excluded.
  // Because symbol provide setColor individually to set fill and stroke

  var emphasisModel = itemModel.getModel('emphasis');
  var emphasisStyle = emphasisModel.getModel('itemStyle').getItemStyle();
  var blurStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle();
  var selectStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle();
  var cursorStyle = itemModel.getShallow('cursor');
  var focus = emphasisModel.get('focus');
  var blurScope = emphasisModel.get('blurScope');
  var hoverScale = emphasisModel.get('scale');
  eachPath(bar, function (path) {
    if (path instanceof zrender_lib_graphic_Image__WEBPACK_IMPORTED_MODULE_10__.default) {
      var pathStyle = path.style;
      path.useStyle(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.extend({
        // TODO other properties like dx, dy ?
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, symbolMeta.style));
    } else {
      path.useStyle(symbolMeta.style);
    }

    var emphasisState = path.ensureState('emphasis');
    emphasisState.style = emphasisStyle;

    if (hoverScale) {
      // NOTE: Must after scale is set after updateAttr
      emphasisState.scaleX = path.scaleX * 1.1;
      emphasisState.scaleY = path.scaleY * 1.1;
    }

    path.ensureState('blur').style = blurStyle;
    path.ensureState('select').style = selectStyle;
    cursorStyle && (path.cursor = cursorStyle);
    path.z2 = symbolMeta.z2;
  });
  var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];
  var barRect = bar.__pictorialBarRect;
  (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_11__.setLabelStyle)(barRect, (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_11__.getLabelStatesModels)(itemModel), {
    labelFetcher: opt.seriesModel,
    labelDataIndex: dataIndex,
    defaultText: (0,_helper_labelHelper__WEBPACK_IMPORTED_MODULE_12__.getDefaultLabel)(opt.seriesModel.getData(), dataIndex),
    inheritColor: symbolMeta.style.fill,
    defaultOpacity: symbolMeta.style.opacity,
    defaultOutsidePosition: barPositionOutside
  });
  (0,_util_states__WEBPACK_IMPORTED_MODULE_13__.enableHoverEmphasis)(bar, focus, blurScope);
}

function toIntTimes(times) {
  var roundedTimes = Math.round(times); // Escapse accurate error

  return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PictorialBarView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/install.js":
/*!*******************************************************!*\
  !*** ./node_modules/echarts/lib/chart/bar/install.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _layout_barGrid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../layout/barGrid */ "./node_modules/echarts/lib/layout/barGrid.js");
/* harmony import */ var _processor_dataSample__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../processor/dataSample */ "./node_modules/echarts/lib/processor/dataSample.js");
/* harmony import */ var _BarSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BarSeries */ "./node_modules/echarts/lib/chart/bar/BarSeries.js");
/* harmony import */ var _BarView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BarView */ "./node_modules/echarts/lib/chart/bar/BarView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





function install(registers) {
  registers.registerChartView(_BarView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerSeriesModel(_BarSeries__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.curry(_layout_barGrid__WEBPACK_IMPORTED_MODULE_3__.layout, 'bar')); // Use higher prority to avoid to be blocked by other overall layout, which do not
  // only exist in this module, but probably also exist in other modules, like `barPolar`.

  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, _layout_barGrid__WEBPACK_IMPORTED_MODULE_3__.largeLayout);
  registers.registerVisual({
    seriesType: 'bar',
    reset: function (seriesModel) {
      // Visual coding for legend
      seriesModel.getData().setVisual('legendSymbol', 'roundRect');
    }
  }); // Down sample after filter

  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, (0,_processor_dataSample__WEBPACK_IMPORTED_MODULE_4__.default)('bar'));
  /**
   * @payload
   * @property {string} [componentType=series]
   * @property {number} [dx]
   * @property {number} [dy]
   * @property {number} [zoom]
   * @property {number} [originX]
   * @property {number} [originY]
   */

  registers.registerAction({
    type: 'changeAxisOrder',
    event: 'changeAxisOrder',
    update: 'update'
  }, function (payload, ecModel) {
    var componentType = payload.componentType || 'series';
    ecModel.eachComponent({
      mainType: componentType,
      query: payload
    }, function (componentModel) {
      if (payload.sortInfo) {
        componentModel.axis.setCategorySortInfo(payload.sortInfo);
      }
    });
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/bar/installPictorialBar.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/bar/installPictorialBar.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _PictorialBarView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PictorialBarView */ "./node_modules/echarts/lib/chart/bar/PictorialBarView.js");
/* harmony import */ var _PictorialBarSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PictorialBarSeries */ "./node_modules/echarts/lib/chart/bar/PictorialBarSeries.js");
/* harmony import */ var _layout_barGrid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../layout/barGrid */ "./node_modules/echarts/lib/layout/barGrid.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




function install(registers) {
  registers.registerChartView(_PictorialBarView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerSeriesModel(_PictorialBarSeries__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerLayout((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.curry)(_layout_barGrid__WEBPACK_IMPORTED_MODULE_3__.layout, 'pictorialBar'));
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/boxplot/BoxplotSeries.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/boxplot/BoxplotSeries.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var _helper_whiskerBoxCommon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helper/whiskerBoxCommon */ "./node_modules/echarts/lib/chart/helper/whiskerBoxCommon.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var BoxplotSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(BoxplotSeriesModel, _super);

  function BoxplotSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = BoxplotSeriesModel.type; // TODO
    // box width represents group size, so dimension should have 'size'.

    /**
     * @see <https://en.wikipedia.org/wiki/Box_plot>
     * The meanings of 'min' and 'max' depend on user,
     * and echarts do not need to know it.
     * @readOnly
     */

    _this.defaultValueDimensions = [{
      name: 'min',
      defaultTooltip: true
    }, {
      name: 'Q1',
      defaultTooltip: true
    }, {
      name: 'median',
      defaultTooltip: true
    }, {
      name: 'Q3',
      defaultTooltip: true
    }, {
      name: 'max',
      defaultTooltip: true
    }];
    _this.visualDrawType = 'stroke';
    return _this;
  }

  BoxplotSeriesModel.type = 'series.boxplot';
  BoxplotSeriesModel.dependencies = ['xAxis', 'yAxis', 'grid'];
  BoxplotSeriesModel.defaultOption = {
    zlevel: 0,
    z: 2,
    coordinateSystem: 'cartesian2d',
    legendHoverLink: true,
    layout: null,
    boxWidth: [7, 50],
    itemStyle: {
      color: '#fff',
      borderWidth: 1
    },
    emphasis: {
      scale: true,
      itemStyle: {
        borderWidth: 2,
        shadowBlur: 5,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: 'rgba(0,0,0,0.2)'
      }
    },
    animationDuration: 800
  };
  return BoxplotSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_1__.default);

(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.mixin)(BoxplotSeriesModel, _helper_whiskerBoxCommon__WEBPACK_IMPORTED_MODULE_3__.WhiskerBoxCommonMixin, true);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BoxplotSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/boxplot/BoxplotView.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/boxplot/BoxplotView.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var zrender_lib_graphic_Path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/graphic/Path */ "./node_modules/zrender/lib/graphic/Path.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







var BoxplotView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(BoxplotView, _super);

  function BoxplotView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = BoxplotView.type;
    return _this;
  }

  BoxplotView.prototype.render = function (seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var group = this.group;
    var oldData = this._data; // There is no old data only when first rendering or switching from
    // stream mode to normal mode, where previous elements should be removed.

    if (!this._data) {
      group.removeAll();
    }

    var constDim = seriesModel.get('layout') === 'horizontal' ? 1 : 0;
    data.diff(oldData).add(function (newIdx) {
      if (data.hasValue(newIdx)) {
        var itemLayout = data.getItemLayout(newIdx);
        var symbolEl = createNormalBox(itemLayout, data, newIdx, constDim, true);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function (newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx); // Empty data

      if (!data.hasValue(newIdx)) {
        group.remove(symbolEl);
        return;
      }

      var itemLayout = data.getItemLayout(newIdx);

      if (!symbolEl) {
        symbolEl = createNormalBox(itemLayout, data, newIdx, constDim);
      } else {
        updateNormalBoxData(itemLayout, symbolEl, data, newIdx);
      }

      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function (oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && group.remove(el);
    }).execute();
    this._data = data;
  };

  BoxplotView.prototype.remove = function (ecModel) {
    var group = this.group;
    var data = this._data;
    this._data = null;
    data && data.eachItemGraphicEl(function (el) {
      el && group.remove(el);
    });
  };

  BoxplotView.type = 'boxplot';
  return BoxplotView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_1__.default);

var BoxPathShape =
/** @class */
function () {
  function BoxPathShape() {}

  return BoxPathShape;
}();

var BoxPath =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(BoxPath, _super);

  function BoxPath(opts) {
    var _this = _super.call(this, opts) || this;

    _this.type = 'boxplotBoxPath';
    return _this;
  }

  BoxPath.prototype.getDefaultShape = function () {
    return new BoxPathShape();
  };

  BoxPath.prototype.buildPath = function (ctx, shape) {
    var ends = shape.points;
    var i = 0;
    ctx.moveTo(ends[i][0], ends[i][1]);
    i++;

    for (; i < 4; i++) {
      ctx.lineTo(ends[i][0], ends[i][1]);
    }

    ctx.closePath();

    for (; i < ends.length; i++) {
      ctx.moveTo(ends[i][0], ends[i][1]);
      i++;
      ctx.lineTo(ends[i][0], ends[i][1]);
    }
  };

  return BoxPath;
}(zrender_lib_graphic_Path__WEBPACK_IMPORTED_MODULE_2__.default);

function createNormalBox(itemLayout, data, dataIndex, constDim, isInit) {
  var ends = itemLayout.ends;
  var el = new BoxPath({
    shape: {
      points: isInit ? transInit(ends, constDim, itemLayout) : ends
    }
  });
  updateNormalBoxData(itemLayout, el, data, dataIndex, isInit);
  return el;
}

function updateNormalBoxData(itemLayout, el, data, dataIndex, isInit) {
  var seriesModel = data.hostModel;
  var updateMethod = _util_graphic__WEBPACK_IMPORTED_MODULE_3__[isInit ? 'initProps' : 'updateProps'];
  updateMethod(el, {
    shape: {
      points: itemLayout.ends
    }
  }, seriesModel, dataIndex);
  el.useStyle(data.getItemVisual(dataIndex, 'style'));
  el.style.strokeNoScale = true;
  el.z2 = 100;
  var itemModel = data.getItemModel(dataIndex);
  (0,_util_states__WEBPACK_IMPORTED_MODULE_4__.setStatesStylesFromModel)(el, itemModel);
  (0,_util_states__WEBPACK_IMPORTED_MODULE_4__.enableHoverEmphasis)(el, itemModel.get(['emphasis', 'focus']), itemModel.get(['emphasis', 'blurScope']));
}

function transInit(points, dim, itemLayout) {
  return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.map(points, function (point) {
    point = point.slice();
    point[dim] = itemLayout.initBaseline;
    return point;
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BoxplotView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/boxplot/boxplotLayout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/boxplot/boxplotLayout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ boxplotLayout)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


var each = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each;
function boxplotLayout(ecModel) {
  var groupResult = groupSeriesByAxis(ecModel);
  each(groupResult, function (groupItem) {
    var seriesModels = groupItem.seriesModels;

    if (!seriesModels.length) {
      return;
    }

    calculateBase(groupItem);
    each(seriesModels, function (seriesModel, idx) {
      layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);
    });
  });
}
/**
 * Group series by axis.
 */

function groupSeriesByAxis(ecModel) {
  var result = [];
  var axisList = [];
  ecModel.eachSeriesByType('boxplot', function (seriesModel) {
    var baseAxis = seriesModel.getBaseAxis();
    var idx = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.indexOf(axisList, baseAxis);

    if (idx < 0) {
      idx = axisList.length;
      axisList[idx] = baseAxis;
      result[idx] = {
        axis: baseAxis,
        seriesModels: []
      };
    }

    result[idx].seriesModels.push(seriesModel);
  });
  return result;
}
/**
 * Calculate offset and box width for each series.
 */


function calculateBase(groupItem) {
  var extent;
  var baseAxis = groupItem.axis;
  var seriesModels = groupItem.seriesModels;
  var seriesCount = seriesModels.length;
  var boxWidthList = groupItem.boxWidthList = [];
  var boxOffsetList = groupItem.boxOffsetList = [];
  var boundList = [];
  var bandWidth;

  if (baseAxis.type === 'category') {
    bandWidth = baseAxis.getBandWidth();
  } else {
    var maxDataCount_1 = 0;
    each(seriesModels, function (seriesModel) {
      maxDataCount_1 = Math.max(maxDataCount_1, seriesModel.getData().count());
    });
    extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / maxDataCount_1;
  }

  each(seriesModels, function (seriesModel) {
    var boxWidthBound = seriesModel.get('boxWidth');

    if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(boxWidthBound)) {
      boxWidthBound = [boxWidthBound, boxWidthBound];
    }

    boundList.push([(0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(boxWidthBound[0], bandWidth) || 0, (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(boxWidthBound[1], bandWidth) || 0]);
  });
  var availableWidth = bandWidth * 0.8 - 2;
  var boxGap = availableWidth / seriesCount * 0.3;
  var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;
  var base = boxWidth / 2 - availableWidth / 2;
  each(seriesModels, function (seriesModel, idx) {
    boxOffsetList.push(base);
    base += boxGap + boxWidth;
    boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));
  });
}
/**
 * Calculate points location for each series.
 */


function layoutSingleSeries(seriesModel, offset, boxWidth) {
  var coordSys = seriesModel.coordinateSystem;
  var data = seriesModel.getData();
  var halfWidth = boxWidth / 2;
  var cDimIdx = seriesModel.get('layout') === 'horizontal' ? 0 : 1;
  var vDimIdx = 1 - cDimIdx;
  var coordDims = ['x', 'y'];
  var cDim = data.mapDimension(coordDims[cDimIdx]);
  var vDims = data.mapDimensionsAll(coordDims[vDimIdx]);

  if (cDim == null || vDims.length < 5) {
    return;
  }

  for (var dataIndex = 0; dataIndex < data.count(); dataIndex++) {
    var axisDimVal = data.get(cDim, dataIndex);
    var median = getPoint(axisDimVal, vDims[2], dataIndex);
    var end1 = getPoint(axisDimVal, vDims[0], dataIndex);
    var end2 = getPoint(axisDimVal, vDims[1], dataIndex);
    var end4 = getPoint(axisDimVal, vDims[3], dataIndex);
    var end5 = getPoint(axisDimVal, vDims[4], dataIndex);
    var ends = [];
    addBodyEnd(ends, end2, false);
    addBodyEnd(ends, end4, true);
    ends.push(end1, end2, end5, end4);
    layEndLine(ends, end1);
    layEndLine(ends, end5);
    layEndLine(ends, median);
    data.setItemLayout(dataIndex, {
      initBaseline: median[vDimIdx],
      ends: ends
    });
  }

  function getPoint(axisDimVal, dim, dataIndex) {
    var val = data.get(dim, dataIndex);
    var p = [];
    p[cDimIdx] = axisDimVal;
    p[vDimIdx] = val;
    var point;

    if (isNaN(axisDimVal) || isNaN(val)) {
      point = [NaN, NaN];
    } else {
      point = coordSys.dataToPoint(p);
      point[cDimIdx] += offset;
    }

    return point;
  }

  function addBodyEnd(ends, point, start) {
    var point1 = point.slice();
    var point2 = point.slice();
    point1[cDimIdx] += halfWidth;
    point2[cDimIdx] -= halfWidth;
    start ? ends.push(point1, point2) : ends.push(point2, point1);
  }

  function layEndLine(ends, endCenter) {
    var from = endCenter.slice();
    var to = endCenter.slice();
    from[cDimIdx] -= halfWidth;
    to[cDimIdx] += halfWidth;
    ends.push(from, to);
  }
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/boxplot/boxplotTransform.js":
/*!********************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/boxplot/boxplotTransform.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "boxplotTransform": () => (/* binding */ boxplotTransform)
/* harmony export */ });
/* harmony import */ var _prepareBoxplotData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./prepareBoxplotData */ "./node_modules/echarts/lib/chart/boxplot/prepareBoxplotData.js");
/* harmony import */ var _util_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/log */ "./node_modules/echarts/lib/util/log.js");
/* harmony import */ var _util_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/types */ "./node_modules/echarts/lib/util/types.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var boxplotTransform = {
  type: 'echarts:boxplot',
  transform: function transform(params) {
    var upstream = params.upstream;

    if (upstream.sourceFormat !== _util_types__WEBPACK_IMPORTED_MODULE_0__.SOURCE_FORMAT_ARRAY_ROWS) {
      var errMsg = '';

      if (true) {
        errMsg = (0,_util_log__WEBPACK_IMPORTED_MODULE_1__.makePrintable)('source data is not applicable for this boxplot transform. Expect number[][].');
      }

      (0,_util_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
    }

    var result = (0,_prepareBoxplotData__WEBPACK_IMPORTED_MODULE_2__.default)(upstream.getRawData(), params.config);
    return [{
      dimensions: ['ItemName', 'Low', 'Q1', 'Q2', 'Q3', 'High'],
      data: result.boxData
    }, {
      data: result.outliers
    }];
  }
};

/***/ }),

/***/ "./node_modules/echarts/lib/chart/boxplot/boxplotVisual.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/boxplot/boxplotVisual.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ boxplotVisual)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function boxplotVisual(ecModel, api) {
  ecModel.eachRawSeriesByType('boxplot', function (seriesModel) {
    seriesModel.getData().setVisual('legendSymbol', 'roundRect');
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/boxplot/install.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/boxplot/install.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _BoxplotSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BoxplotSeries */ "./node_modules/echarts/lib/chart/boxplot/BoxplotSeries.js");
/* harmony import */ var _BoxplotView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BoxplotView */ "./node_modules/echarts/lib/chart/boxplot/BoxplotView.js");
/* harmony import */ var _boxplotVisual__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./boxplotVisual */ "./node_modules/echarts/lib/chart/boxplot/boxplotVisual.js");
/* harmony import */ var _boxplotLayout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./boxplotLayout */ "./node_modules/echarts/lib/chart/boxplot/boxplotLayout.js");
/* harmony import */ var _boxplotTransform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./boxplotTransform */ "./node_modules/echarts/lib/chart/boxplot/boxplotTransform.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





function install(registers) {
  registers.registerSeriesModel(_BoxplotSeries__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerChartView(_BoxplotView__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerVisual(_boxplotVisual__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerLayout(_boxplotLayout__WEBPACK_IMPORTED_MODULE_3__.default);
  registers.registerTransform(_boxplotTransform__WEBPACK_IMPORTED_MODULE_4__.boxplotTransform);
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/boxplot/prepareBoxplotData.js":
/*!**********************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/boxplot/prepareBoxplotData.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ prepareBoxplotData)
/* harmony export */ });
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * See:
 *  <https://en.wikipedia.org/wiki/Box_plot#cite_note-frigge_hoaglin_iglewicz-2>
 *  <http://stat.ethz.ch/R-manual/R-devel/library/grDevices/html/boxplot.stats.html>
 *
 * Helper method for preparing data.
 *
 * @param rawData like
 *        [
 *            [12,232,443], (raw data set for the first box)
 *            [3843,5545,1232], (raw data set for the second box)
 *            ...
 *        ]
 * @param opt.boundIQR=1.5 Data less than min bound is outlier.
 *      default 1.5, means Q1 - 1.5 * (Q3 - Q1).
 *      If 'none'/0 passed, min bound will not be used.
 */

function prepareBoxplotData(rawData, opt) {
  opt = opt || {};
  var boxData = [];
  var outliers = [];
  var boundIQR = opt.boundIQR;
  var useExtreme = boundIQR === 'none' || boundIQR === 0;

  for (var i = 0; i < rawData.length; i++) {
    var ascList = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.asc)(rawData[i].slice());
    var Q1 = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.quantile)(ascList, 0.25);
    var Q2 = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.quantile)(ascList, 0.5);
    var Q3 = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.quantile)(ascList, 0.75);
    var min = ascList[0];
    var max = ascList[ascList.length - 1];
    var bound = (boundIQR == null ? 1.5 : boundIQR) * (Q3 - Q1);
    var low = useExtreme ? min : Math.max(min, Q1 - bound);
    var high = useExtreme ? max : Math.min(max, Q3 + bound);
    var itemNameFormatter = opt.itemNameFormatter;
    var itemName = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(itemNameFormatter) ? itemNameFormatter({
      value: i
    }) : (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isString)(itemNameFormatter) ? itemNameFormatter.replace('{value}', i + '') : i + '';
    boxData.push([itemName, low, Q1, Q2, Q3, high]);

    for (var j = 0; j < ascList.length; j++) {
      var dataItem = ascList[j];

      if (dataItem < low || dataItem > high) {
        var outlier = [itemName, dataItem];
        outliers.push(outlier);
      }
    }
  }

  return {
    boxData: boxData,
    outliers: outliers
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/candlestick/CandlestickSeries.js":
/*!*************************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/candlestick/CandlestickSeries.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var _helper_whiskerBoxCommon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helper/whiskerBoxCommon */ "./node_modules/echarts/lib/chart/helper/whiskerBoxCommon.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var CandlestickSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(CandlestickSeriesModel, _super);

  function CandlestickSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CandlestickSeriesModel.type;
    _this.defaultValueDimensions = [{
      name: 'open',
      defaultTooltip: true
    }, {
      name: 'close',
      defaultTooltip: true
    }, {
      name: 'lowest',
      defaultTooltip: true
    }, {
      name: 'highest',
      defaultTooltip: true
    }];
    return _this;
  }
  /**
   * Get dimension for shadow in dataZoom
   * @return dimension name
   */


  CandlestickSeriesModel.prototype.getShadowDim = function () {
    return 'open';
  };

  CandlestickSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {
    var itemLayout = data.getItemLayout(dataIndex);
    return itemLayout && selectors.rect(itemLayout.brushRect);
  };

  CandlestickSeriesModel.type = 'series.candlestick';
  CandlestickSeriesModel.dependencies = ['xAxis', 'yAxis', 'grid'];
  CandlestickSeriesModel.defaultOption = {
    zlevel: 0,
    z: 2,
    coordinateSystem: 'cartesian2d',
    legendHoverLink: true,
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    layout: null,
    clip: true,
    itemStyle: {
      color: '#eb5454',
      color0: '#47b262',
      borderColor: '#eb5454',
      borderColor0: '#47b262',
      // borderColor: '#d24040',
      // borderColor0: '#398f4f',
      borderWidth: 1
    },
    emphasis: {
      scale: true,
      itemStyle: {
        borderWidth: 2
      }
    },
    barMaxWidth: null,
    barMinWidth: null,
    barWidth: null,
    large: true,
    largeThreshold: 600,
    progressive: 3e3,
    progressiveThreshold: 1e4,
    progressiveChunkMode: 'mod',
    animationEasing: 'linear',
    animationDuration: 300
  };
  return CandlestickSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_1__.default);

(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.mixin)(CandlestickSeriesModel, _helper_whiskerBoxCommon__WEBPACK_IMPORTED_MODULE_3__.WhiskerBoxCommonMixin, true);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CandlestickSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/candlestick/CandlestickView.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/candlestick/CandlestickView.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var zrender_lib_graphic_Path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/graphic/Path */ "./node_modules/zrender/lib/graphic/Path.js");
/* harmony import */ var _helper_createClipPathFromCoordSys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helper/createClipPathFromCoordSys */ "./node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







var SKIP_PROPS = ['color', 'borderColor'];

var CandlestickView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(CandlestickView, _super);

  function CandlestickView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CandlestickView.type;
    return _this;
  }

  CandlestickView.prototype.render = function (seriesModel, ecModel, api) {
    // If there is clipPath created in large mode. Remove it.
    this.group.removeClipPath();

    this._updateDrawMode(seriesModel);

    this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel);
  };

  CandlestickView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {
    this._clear();

    this._updateDrawMode(seriesModel);
  };

  CandlestickView.prototype.incrementalRender = function (params, seriesModel, ecModel, api) {
    this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel);
  };

  CandlestickView.prototype._updateDrawMode = function (seriesModel) {
    var isLargeDraw = seriesModel.pipelineContext.large;

    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
      this._isLargeDraw = isLargeDraw;

      this._clear();
    }
  };

  CandlestickView.prototype._renderNormal = function (seriesModel) {
    var data = seriesModel.getData();
    var oldData = this._data;
    var group = this.group;
    var isSimpleBox = data.getLayout('isSimpleBox');
    var needsClip = seriesModel.get('clip', true);
    var coord = seriesModel.coordinateSystem;
    var clipArea = coord.getArea && coord.getArea(); // There is no old data only when first rendering or switching from
    // stream mode to normal mode, where previous elements should be removed.

    if (!this._data) {
      group.removeAll();
    }

    data.diff(oldData).add(function (newIdx) {
      if (data.hasValue(newIdx)) {
        var itemLayout = data.getItemLayout(newIdx);

        if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
          return;
        }

        var el = createNormalBox(itemLayout, newIdx, true);
        _util_graphic__WEBPACK_IMPORTED_MODULE_1__.initProps(el, {
          shape: {
            points: itemLayout.ends
          }
        }, seriesModel, newIdx);
        setBoxCommon(el, data, newIdx, isSimpleBox);
        group.add(el);
        data.setItemGraphicEl(newIdx, el);
      }
    }).update(function (newIdx, oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx); // Empty data

      if (!data.hasValue(newIdx)) {
        group.remove(el);
        return;
      }

      var itemLayout = data.getItemLayout(newIdx);

      if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
        group.remove(el);
        return;
      }

      if (!el) {
        el = createNormalBox(itemLayout, newIdx);
      } else {
        _util_graphic__WEBPACK_IMPORTED_MODULE_1__.updateProps(el, {
          shape: {
            points: itemLayout.ends
          }
        }, seriesModel, newIdx);
      }

      setBoxCommon(el, data, newIdx, isSimpleBox);
      group.add(el);
      data.setItemGraphicEl(newIdx, el);
    }).remove(function (oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && group.remove(el);
    }).execute();
    this._data = data;
  };

  CandlestickView.prototype._renderLarge = function (seriesModel) {
    this._clear();

    createLarge(seriesModel, this.group);
    var clipPath = seriesModel.get('clip', true) ? (0,_helper_createClipPathFromCoordSys__WEBPACK_IMPORTED_MODULE_2__.createClipPath)(seriesModel.coordinateSystem, false, seriesModel) : null;

    if (clipPath) {
      this.group.setClipPath(clipPath);
    } else {
      this.group.removeClipPath();
    }
  };

  CandlestickView.prototype._incrementalRenderNormal = function (params, seriesModel) {
    var data = seriesModel.getData();
    var isSimpleBox = data.getLayout('isSimpleBox');
    var dataIndex;

    while ((dataIndex = params.next()) != null) {
      var itemLayout = data.getItemLayout(dataIndex);
      var el = createNormalBox(itemLayout, dataIndex);
      setBoxCommon(el, data, dataIndex, isSimpleBox);
      el.incremental = true;
      this.group.add(el);
    }
  };

  CandlestickView.prototype._incrementalRenderLarge = function (params, seriesModel) {
    createLarge(seriesModel, this.group, true);
  };

  CandlestickView.prototype.remove = function (ecModel) {
    this._clear();
  };

  CandlestickView.prototype._clear = function () {
    this.group.removeAll();
    this._data = null;
  };

  CandlestickView.type = 'candlestick';
  return CandlestickView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_3__.default);

var NormalBoxPathShape =
/** @class */
function () {
  function NormalBoxPathShape() {}

  return NormalBoxPathShape;
}();

var NormalBoxPath =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(NormalBoxPath, _super);

  function NormalBoxPath(opts) {
    var _this = _super.call(this, opts) || this;

    _this.type = 'normalCandlestickBox';
    return _this;
  }

  NormalBoxPath.prototype.getDefaultShape = function () {
    return new NormalBoxPathShape();
  };

  NormalBoxPath.prototype.buildPath = function (ctx, shape) {
    var ends = shape.points;

    if (this.__simpleBox) {
      ctx.moveTo(ends[4][0], ends[4][1]);
      ctx.lineTo(ends[6][0], ends[6][1]);
    } else {
      ctx.moveTo(ends[0][0], ends[0][1]);
      ctx.lineTo(ends[1][0], ends[1][1]);
      ctx.lineTo(ends[2][0], ends[2][1]);
      ctx.lineTo(ends[3][0], ends[3][1]);
      ctx.closePath();
      ctx.moveTo(ends[4][0], ends[4][1]);
      ctx.lineTo(ends[5][0], ends[5][1]);
      ctx.moveTo(ends[6][0], ends[6][1]);
      ctx.lineTo(ends[7][0], ends[7][1]);
    }
  };

  return NormalBoxPath;
}(zrender_lib_graphic_Path__WEBPACK_IMPORTED_MODULE_4__.default);

function createNormalBox(itemLayout, dataIndex, isInit) {
  var ends = itemLayout.ends;
  return new NormalBoxPath({
    shape: {
      points: isInit ? transInit(ends, itemLayout) : ends
    },
    z2: 100
  });
}

function isNormalBoxClipped(clipArea, itemLayout) {
  var clipped = true;

  for (var i = 0; i < itemLayout.ends.length; i++) {
    // If any point are in the region.
    if (clipArea.contain(itemLayout.ends[i][0], itemLayout.ends[i][1])) {
      clipped = false;
      break;
    }
  }

  return clipped;
}

function setBoxCommon(el, data, dataIndex, isSimpleBox) {
  var itemModel = data.getItemModel(dataIndex);
  el.useStyle(data.getItemVisual(dataIndex, 'style'));
  el.style.strokeNoScale = true;
  el.__simpleBox = isSimpleBox;
  (0,_util_states__WEBPACK_IMPORTED_MODULE_5__.setStatesStylesFromModel)(el, itemModel);
}

function transInit(points, itemLayout) {
  return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_6__.map(points, function (point) {
    point = point.slice();
    point[1] = itemLayout.initBaseline;
    return point;
  });
}

var LargeBoxPathShape =
/** @class */
function () {
  function LargeBoxPathShape() {}

  return LargeBoxPathShape;
}();

var LargeBoxPath =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(LargeBoxPath, _super);

  function LargeBoxPath(opts) {
    var _this = _super.call(this, opts) || this;

    _this.type = 'largeCandlestickBox';
    return _this;
  }

  LargeBoxPath.prototype.getDefaultShape = function () {
    return new LargeBoxPathShape();
  };

  LargeBoxPath.prototype.buildPath = function (ctx, shape) {
    // Drawing lines is more efficient than drawing
    // a whole line or drawing rects.
    var points = shape.points;

    for (var i = 0; i < points.length;) {
      if (this.__sign === points[i++]) {
        var x = points[i++];
        ctx.moveTo(x, points[i++]);
        ctx.lineTo(x, points[i++]);
      } else {
        i += 3;
      }
    }
  };

  return LargeBoxPath;
}(zrender_lib_graphic_Path__WEBPACK_IMPORTED_MODULE_4__.default);

function createLarge(seriesModel, group, incremental) {
  var data = seriesModel.getData();
  var largePoints = data.getLayout('largePoints');
  var elP = new LargeBoxPath({
    shape: {
      points: largePoints
    },
    __sign: 1
  });
  group.add(elP);
  var elN = new LargeBoxPath({
    shape: {
      points: largePoints
    },
    __sign: -1
  });
  group.add(elN);
  setLargeStyle(1, elP, seriesModel, data);
  setLargeStyle(-1, elN, seriesModel, data);

  if (incremental) {
    elP.incremental = true;
    elN.incremental = true;
  }
}

function setLargeStyle(sign, el, seriesModel, data) {
  // TODO put in visual?
  var borderColor = seriesModel.get(['itemStyle', sign > 0 ? 'borderColor' : 'borderColor0']) || seriesModel.get(['itemStyle', sign > 0 ? 'color' : 'color0']); // Color must be excluded.
  // Because symbol provide setColor individually to set fill and stroke

  var itemStyle = seriesModel.getModel('itemStyle').getItemStyle(SKIP_PROPS);
  el.useStyle(itemStyle);
  el.style.fill = null;
  el.style.stroke = borderColor;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CandlestickView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/candlestick/candlestickLayout.js":
/*!*************************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/candlestick/candlestickLayout.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _helper_createRenderPlanner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helper/createRenderPlanner */ "./node_modules/echarts/lib/chart/helper/createRenderPlanner.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/* global Float32Array */




var LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var candlestickLayout = {
  seriesType: 'candlestick',
  plan: (0,_helper_createRenderPlanner__WEBPACK_IMPORTED_MODULE_0__.default)(),
  reset: function (seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    var data = seriesModel.getData();
    var candleWidth = calculateCandleWidth(seriesModel, data);
    var cDimIdx = 0;
    var vDimIdx = 1;
    var coordDims = ['x', 'y'];
    var cDim = data.mapDimension(coordDims[cDimIdx]);
    var vDims = data.mapDimensionsAll(coordDims[vDimIdx]);
    var openDim = vDims[0];
    var closeDim = vDims[1];
    var lowestDim = vDims[2];
    var highestDim = vDims[3];
    data.setLayout({
      candleWidth: candleWidth,
      // The value is experimented visually.
      isSimpleBox: candleWidth <= 1.3
    });

    if (cDim == null || vDims.length < 4) {
      return;
    }

    return {
      progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress
    };

    function normalProgress(params, data) {
      var dataIndex;

      while ((dataIndex = params.next()) != null) {
        var axisDimVal = data.get(cDim, dataIndex);
        var openVal = data.get(openDim, dataIndex);
        var closeVal = data.get(closeDim, dataIndex);
        var lowestVal = data.get(lowestDim, dataIndex);
        var highestVal = data.get(highestDim, dataIndex);
        var ocLow = Math.min(openVal, closeVal);
        var ocHigh = Math.max(openVal, closeVal);
        var ocLowPoint = getPoint(ocLow, axisDimVal);
        var ocHighPoint = getPoint(ocHigh, axisDimVal);
        var lowestPoint = getPoint(lowestVal, axisDimVal);
        var highestPoint = getPoint(highestVal, axisDimVal);
        var ends = [];
        addBodyEnd(ends, ocHighPoint, 0);
        addBodyEnd(ends, ocLowPoint, 1);
        ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint));
        data.setItemLayout(dataIndex, {
          sign: getSign(data, dataIndex, openVal, closeVal, closeDim),
          initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],
          ends: ends,
          brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)
        });
      }

      function getPoint(val, axisDimVal) {
        var p = [];
        p[cDimIdx] = axisDimVal;
        p[vDimIdx] = val;
        return isNaN(axisDimVal) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p);
      }

      function addBodyEnd(ends, point, start) {
        var point1 = point.slice();
        var point2 = point.slice();
        point1[cDimIdx] = (0,_util_graphic__WEBPACK_IMPORTED_MODULE_1__.subPixelOptimize)(point1[cDimIdx] + candleWidth / 2, 1, false);
        point2[cDimIdx] = (0,_util_graphic__WEBPACK_IMPORTED_MODULE_1__.subPixelOptimize)(point2[cDimIdx] - candleWidth / 2, 1, true);
        start ? ends.push(point1, point2) : ends.push(point2, point1);
      }

      function makeBrushRect(lowestVal, highestVal, axisDimVal) {
        var pmin = getPoint(lowestVal, axisDimVal);
        var pmax = getPoint(highestVal, axisDimVal);
        pmin[cDimIdx] -= candleWidth / 2;
        pmax[cDimIdx] -= candleWidth / 2;
        return {
          x: pmin[0],
          y: pmin[1],
          width: vDimIdx ? candleWidth : pmax[0] - pmin[0],
          height: vDimIdx ? pmax[1] - pmin[1] : candleWidth
        };
      }

      function subPixelOptimizePoint(point) {
        point[cDimIdx] = (0,_util_graphic__WEBPACK_IMPORTED_MODULE_1__.subPixelOptimize)(point[cDimIdx], 1);
        return point;
      }
    }

    function largeProgress(params, data) {
      // Structure: [sign, x, yhigh, ylow, sign, x, yhigh, ylow, ...]
      var points = new LargeArr(params.count * 4);
      var offset = 0;
      var point;
      var tmpIn = [];
      var tmpOut = [];
      var dataIndex;

      while ((dataIndex = params.next()) != null) {
        var axisDimVal = data.get(cDim, dataIndex);
        var openVal = data.get(openDim, dataIndex);
        var closeVal = data.get(closeDim, dataIndex);
        var lowestVal = data.get(lowestDim, dataIndex);
        var highestVal = data.get(highestDim, dataIndex);

        if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {
          points[offset++] = NaN;
          offset += 3;
          continue;
        }

        points[offset++] = getSign(data, dataIndex, openVal, closeVal, closeDim);
        tmpIn[cDimIdx] = axisDimVal;
        tmpIn[vDimIdx] = lowestVal;
        point = coordSys.dataToPoint(tmpIn, null, tmpOut);
        points[offset++] = point ? point[0] : NaN;
        points[offset++] = point ? point[1] : NaN;
        tmpIn[vDimIdx] = highestVal;
        point = coordSys.dataToPoint(tmpIn, null, tmpOut);
        points[offset++] = point ? point[1] : NaN;
      }

      data.setLayout('largePoints', points);
    }
  }
};

function getSign(data, dataIndex, openVal, closeVal, closeDim) {
  var sign;

  if (openVal > closeVal) {
    sign = -1;
  } else if (openVal < closeVal) {
    sign = 1;
  } else {
    sign = dataIndex > 0 // If close === open, compare with close of last record
    ? data.get(closeDim, dataIndex - 1) <= closeVal ? 1 : -1 : // No record of previous, set to be positive
    1;
  }

  return sign;
}

function calculateCandleWidth(seriesModel, data) {
  var baseAxis = seriesModel.getBaseAxis();
  var extent;
  var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : (extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / data.count());
  var barMaxWidth = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.parsePercent)((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.retrieve2)(seriesModel.get('barMaxWidth'), bandWidth), bandWidth);
  var barMinWidth = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.parsePercent)((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.retrieve2)(seriesModel.get('barMinWidth'), 1), bandWidth);
  var barWidth = seriesModel.get('barWidth');
  return barWidth != null ? (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.parsePercent)(barWidth, bandWidth) // Put max outer to ensure bar visible in spite of overlap.
  : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (candlestickLayout);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/candlestick/candlestickVisual.js":
/*!*************************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/candlestick/candlestickVisual.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helper_createRenderPlanner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helper/createRenderPlanner */ "./node_modules/echarts/lib/chart/helper/createRenderPlanner.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


var positiveBorderColorQuery = ['itemStyle', 'borderColor'];
var negativeBorderColorQuery = ['itemStyle', 'borderColor0'];
var positiveColorQuery = ['itemStyle', 'color'];
var negativeColorQuery = ['itemStyle', 'color0'];
var candlestickVisual = {
  seriesType: 'candlestick',
  plan: (0,_helper_createRenderPlanner__WEBPACK_IMPORTED_MODULE_0__.default)(),
  // For legend.
  performRawSeries: true,
  reset: function (seriesModel, ecModel) {
    function getColor(sign, model) {
      return model.get(sign > 0 ? positiveColorQuery : negativeColorQuery);
    }

    function getBorderColor(sign, model) {
      return model.get(sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);
    }

    var data = seriesModel.getData();
    data.setVisual('legendSymbol', 'roundRect'); // Only visible series has each data be visual encoded

    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }

    var isLargeRender = seriesModel.pipelineContext.large;
    return !isLargeRender && {
      progress: function (params, data) {
        var dataIndex;

        while ((dataIndex = params.next()) != null) {
          var itemModel = data.getItemModel(dataIndex);
          var sign = data.getItemLayout(dataIndex).sign;
          var style = itemModel.getItemStyle();
          style.fill = getColor(sign, itemModel);
          style.stroke = getBorderColor(sign, itemModel) || style.fill;
          var existsStyle = data.ensureUniqueItemVisual(dataIndex, 'style');
          (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend)(existsStyle, style);
        }
      }
    };
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (candlestickVisual);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/candlestick/install.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/candlestick/install.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _CandlestickView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CandlestickView */ "./node_modules/echarts/lib/chart/candlestick/CandlestickView.js");
/* harmony import */ var _CandlestickSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CandlestickSeries */ "./node_modules/echarts/lib/chart/candlestick/CandlestickSeries.js");
/* harmony import */ var _preprocessor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./preprocessor */ "./node_modules/echarts/lib/chart/candlestick/preprocessor.js");
/* harmony import */ var _candlestickVisual__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./candlestickVisual */ "./node_modules/echarts/lib/chart/candlestick/candlestickVisual.js");
/* harmony import */ var _candlestickLayout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./candlestickLayout */ "./node_modules/echarts/lib/chart/candlestick/candlestickLayout.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





function install(registers) {
  registers.registerChartView(_CandlestickView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerSeriesModel(_CandlestickSeries__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerPreprocessor(_preprocessor__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerVisual(_candlestickVisual__WEBPACK_IMPORTED_MODULE_3__.default);
  registers.registerLayout(_candlestickLayout__WEBPACK_IMPORTED_MODULE_4__.default);
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/candlestick/preprocessor.js":
/*!********************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/candlestick/preprocessor.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ candlestickPreprocessor)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

function candlestickPreprocessor(option) {
  if (!option || !zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(option.series)) {
    return;
  } // Translate 'k' to 'candlestick'.


  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(option.series, function (seriesItem) {
    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject(seriesItem) && seriesItem.type === 'k') {
      seriesItem.type = 'candlestick';
    }
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/custom/install.js":
/*!**********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/custom/install.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Image.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Path.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _helper_labelHelper__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../helper/labelHelper */ "./node_modules/echarts/lib/chart/helper/labelHelper.js");
/* harmony import */ var _helper_createListFromArray__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../helper/createListFromArray */ "./node_modules/echarts/lib/chart/helper/createListFromArray.js");
/* harmony import */ var _layout_barGrid__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../../layout/barGrid */ "./node_modules/echarts/lib/layout/barGrid.js");
/* harmony import */ var _data_DataDiffer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../data/DataDiffer */ "./node_modules/echarts/lib/data/DataDiffer.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _helper_createClipPathFromCoordSys__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../helper/createClipPathFromCoordSys */ "./node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js");
/* harmony import */ var _coord_cartesian_prepareCustom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../coord/cartesian/prepareCustom */ "./node_modules/echarts/lib/coord/cartesian/prepareCustom.js");
/* harmony import */ var _coord_geo_prepareCustom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../coord/geo/prepareCustom */ "./node_modules/echarts/lib/coord/geo/prepareCustom.js");
/* harmony import */ var _coord_single_prepareCustom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../coord/single/prepareCustom */ "./node_modules/echarts/lib/coord/single/prepareCustom.js");
/* harmony import */ var _coord_polar_prepareCustom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../coord/polar/prepareCustom */ "./node_modules/echarts/lib/coord/polar/prepareCustom.js");
/* harmony import */ var _coord_calendar_prepareCustom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../coord/calendar/prepareCustom */ "./node_modules/echarts/lib/coord/calendar/prepareCustom.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _util_styleCompat__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../../util/styleCompat */ "./node_modules/echarts/lib/util/styleCompat.js");
/* harmony import */ var zrender_lib_core_Transformable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/Transformable */ "./node_modules/zrender/lib/core/Transformable.js");
/* harmony import */ var zrender_lib_animation_Animator__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! zrender/lib/animation/Animator */ "./node_modules/zrender/lib/animation/Animator.js");
/* harmony import */ var _util_log__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../util/log */ "./node_modules/echarts/lib/util/log.js");
/* harmony import */ var zrender_lib_tool_morphPath__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! zrender/lib/tool/morphPath */ "./node_modules/zrender/lib/tool/morphPath.js");
/* harmony import */ var zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! zrender/lib/core/matrix */ "./node_modules/zrender/lib/core/matrix.js");
/* harmony import */ var _util_decal__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../util/decal */ "./node_modules/echarts/lib/util/decal.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

























var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();
var TRANSFORM_PROPS = {
  x: 1,
  y: 1,
  scaleX: 1,
  scaleY: 1,
  originX: 1,
  originY: 1,
  rotation: 1
};
var transformPropNamesStr = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.keys)(TRANSFORM_PROPS).join(', ');
; // Also compat with ec4, where
// `visual('color') visual('borderColor')` is supported.

var STYLE_VISUAL_TYPE = {
  color: 'fill',
  borderColor: 'stroke'
};
var NON_STYLE_VISUAL_PROPS = {
  symbol: 1,
  symbolSize: 1,
  symbolKeepAspect: 1,
  legendSymbol: 1,
  visualMeta: 1,
  liftZ: 1,
  decal: 1
};
var EMPHASIS = 'emphasis';
var NORMAL = 'normal';
var BLUR = 'blur';
var SELECT = 'select';
var STATES = [NORMAL, EMPHASIS, BLUR, SELECT];
var PATH_ITEM_STYLE = {
  normal: ['itemStyle'],
  emphasis: [EMPHASIS, 'itemStyle'],
  blur: [BLUR, 'itemStyle'],
  select: [SELECT, 'itemStyle']
};
var PATH_LABEL = {
  normal: ['label'],
  emphasis: [EMPHASIS, 'label'],
  blur: [BLUR, 'label'],
  select: [SELECT, 'label']
}; // Use prefix to avoid index to be the same as el.name,
// which will cause weird update animation.

var GROUP_DIFF_PREFIX = 'e\0\0';
var attachedTxInfoTmp = {
  normal: {},
  emphasis: {},
  blur: {},
  select: {}
};
var LEGACY_TRANSFORM_PROPS = {
  position: ['x', 'y'],
  scale: ['scaleX', 'scaleY'],
  origin: ['originX', 'originY']
};
var tmpTransformable = new zrender_lib_core_Transformable__WEBPACK_IMPORTED_MODULE_2__.default();
/**
 * To reduce total package size of each coordinate systems, the modules `prepareCustom`
 * of each coordinate systems are not required by each coordinate systems directly, but
 * required by the module `custom`.
 *
 * prepareInfoForCustomSeries {Function}: optional
 *     @return {Object} {coordSys: {...}, api: {
 *         coord: function (data, clamp) {}, // return point in global.
 *         size: function (dataSize, dataItem) {} // return size of each axis in coordSys.
 *     }}
 */

var prepareCustoms = {
  cartesian2d: _coord_cartesian_prepareCustom__WEBPACK_IMPORTED_MODULE_3__.default,
  geo: _coord_geo_prepareCustom__WEBPACK_IMPORTED_MODULE_4__.default,
  singleAxis: _coord_single_prepareCustom__WEBPACK_IMPORTED_MODULE_5__.default,
  polar: _coord_polar_prepareCustom__WEBPACK_IMPORTED_MODULE_6__.default,
  calendar: _coord_calendar_prepareCustom__WEBPACK_IMPORTED_MODULE_7__.default
};

var CustomSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_8__.__extends)(CustomSeriesModel, _super);

  function CustomSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CustomSeriesModel.type;
    return _this;
  }

  CustomSeriesModel.prototype.optionUpdated = function () {
    this.currentZLevel = this.get('zlevel', true);
    this.currentZ = this.get('z', true);
  };

  CustomSeriesModel.prototype.getInitialData = function (option, ecModel) {
    return (0,_helper_createListFromArray__WEBPACK_IMPORTED_MODULE_9__.default)(this.getSource(), this);
  };

  CustomSeriesModel.prototype.getDataParams = function (dataIndex, dataType, el) {
    var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);

    el && (params.info = inner(el).info);
    return params;
  };

  CustomSeriesModel.type = 'series.custom';
  CustomSeriesModel.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar'];
  CustomSeriesModel.defaultOption = {
    coordinateSystem: 'cartesian2d',
    zlevel: 0,
    z: 2,
    legendHoverLink: true,
    // Custom series will not clip by default.
    // Some case will use custom series to draw label
    // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
    clip: false // Cartesian coordinate system
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    // Polar coordinate system
    // polarIndex: 0,
    // Geo coordinate system
    // geoIndex: 0,

  };
  return CustomSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_10__.default);

var CustomSeriesView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_8__.__extends)(CustomSeriesView, _super);

  function CustomSeriesView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CustomSeriesView.type;
    return _this;
  }

  CustomSeriesView.prototype.render = function (customSeries, ecModel, api, payload) {
    var oldData = this._data;
    var data = customSeries.getData();
    var group = this.group;
    var renderItem = makeRenderItem(customSeries, data, ecModel, api); // By default, merge mode is applied. In most cases, custom series is
    // used in the scenario that data amount is not large but graphic elements
    // is complicated, where merge mode is probably necessary for optimization.
    // For example, reuse graphic elements and only update the transform when
    // roam or data zoom according to `actionType`.

    var transOpt = customSeries.__transientTransitionOpt; // Enable user to disable transition animation by both set
    // `from` and `to` dimension as `null`/`undefined`.

    if (transOpt && (transOpt.from == null || transOpt.to == null)) {
      oldData && oldData.each(function (oldIdx) {
        doRemoveEl(oldData.getItemGraphicEl(oldIdx), customSeries, group);
      });
      data.each(function (newIdx) {
        createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data, null);
      });
    } else {
      var morphPreparation_1 = new MorphPreparation(customSeries, transOpt);
      var diffMode = transOpt ? 'multiple' : 'oneToOne';
      new _data_DataDiffer__WEBPACK_IMPORTED_MODULE_11__.default(oldData ? oldData.getIndices() : [], data.getIndices(), createGetKey(oldData, diffMode, transOpt && transOpt.from), createGetKey(data, diffMode, transOpt && transOpt.to), null, diffMode).add(function (newIdx) {
        createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data, null);
      }).remove(function (oldIdx) {
        doRemoveEl(oldData.getItemGraphicEl(oldIdx), customSeries, group);
      }).update(function (newIdx, oldIdx) {
        morphPreparation_1.reset('oneToOne');
        var oldEl = oldData.getItemGraphicEl(oldIdx);
        morphPreparation_1.findAndAddFrom(oldEl); // PENDING:
        // if may morph, currently we alway recreate the whole el.
        // because if reuse some of the el in the group tree, the old el has to
        // be removed from the group, and consequently we can not calculate
        // the "global transition" of the old element.
        // But is there performance issue?

        if (morphPreparation_1.hasFrom()) {
          removeElementDirectly(oldEl, group);
          oldEl = null;
        }

        createOrUpdateItem(api, oldEl, newIdx, renderItem(newIdx, payload), customSeries, group, data, morphPreparation_1);
        morphPreparation_1.applyMorphing();
      }).updateManyToOne(function (newIdx, oldIndices) {
        morphPreparation_1.reset('manyToOne');

        for (var i = 0; i < oldIndices.length; i++) {
          var oldEl = oldData.getItemGraphicEl(oldIndices[i]);
          morphPreparation_1.findAndAddFrom(oldEl);
          removeElementDirectly(oldEl, group);
        }

        createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data, morphPreparation_1);
        morphPreparation_1.applyMorphing();
      }).updateOneToMany(function (newIndices, oldIdx) {
        morphPreparation_1.reset('oneToMany');
        var newLen = newIndices.length;
        var oldEl = oldData.getItemGraphicEl(oldIdx);
        morphPreparation_1.findAndAddFrom(oldEl);
        removeElementDirectly(oldEl, group);

        for (var i = 0; i < newLen; i++) {
          createOrUpdateItem(api, null, newIndices[i], renderItem(newIndices[i], payload), customSeries, group, data, morphPreparation_1);
        }

        morphPreparation_1.applyMorphing();
      }).execute();
    } // Do clipping


    var clipPath = customSeries.get('clip', true) ? (0,_helper_createClipPathFromCoordSys__WEBPACK_IMPORTED_MODULE_12__.createClipPath)(customSeries.coordinateSystem, false, customSeries) : null;

    if (clipPath) {
      group.setClipPath(clipPath);
    } else {
      group.removeClipPath();
    }

    this._data = data;
  };

  CustomSeriesView.prototype.incrementalPrepareRender = function (customSeries, ecModel, api) {
    this.group.removeAll();
    this._data = null;
  };

  CustomSeriesView.prototype.incrementalRender = function (params, customSeries, ecModel, api, payload) {
    var data = customSeries.getData();
    var renderItem = makeRenderItem(customSeries, data, ecModel, api);

    function setIncrementalAndHoverLayer(el) {
      if (!el.isGroup) {
        el.incremental = true;
        el.ensureState('emphasis').hoverLayer = true;
      }
    }

    for (var idx = params.start; idx < params.end; idx++) {
      var el = createOrUpdateItem(null, null, idx, renderItem(idx, payload), customSeries, this.group, data, null);
      el.traverse(setIncrementalAndHoverLayer);
    }
  };

  CustomSeriesView.prototype.filterForExposedEvent = function (eventType, query, targetEl, packedEvent) {
    var elementName = query.element;

    if (elementName == null || targetEl.name === elementName) {
      return true;
    } // Enable to give a name on a group made by `renderItem`, and listen
    // events that triggerd by its descendents.


    while ((targetEl = targetEl.__hostTarget || targetEl.parent) && targetEl !== this.group) {
      if (targetEl.name === elementName) {
        return true;
      }
    }

    return false;
  };

  CustomSeriesView.type = 'custom';
  return CustomSeriesView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_13__.default);

function createGetKey(data, diffMode, dimension) {
  if (!data) {
    return;
  }

  if (diffMode === 'oneToOne') {
    return function (rawIdx, dataIndex) {
      return data.getId(dataIndex);
    };
  }

  var diffByDimName = data.getDimension(dimension);
  var dimInfo = data.getDimensionInfo(diffByDimName);

  if (!dimInfo) {
    var errMsg = '';

    if (true) {
      errMsg = dimension + " is not a valid dimension.";
    }

    (0,_util_log__WEBPACK_IMPORTED_MODULE_14__.throwError)(errMsg);
  }

  var ordinalMeta = dimInfo.ordinalMeta;
  return function (rawIdx, dataIndex) {
    var key = data.get(diffByDimName, dataIndex);

    if (ordinalMeta) {
      key = ordinalMeta.categories[key];
    }

    return key == null || (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.eqNaN)(key) ? rawIdx + '' : '_ec_' + key;
  };
}

function createEl(elOption) {
  var graphicType = elOption.type;
  var el; // Those graphic elements are not shapes. They should not be
  // overwritten by users, so do them first.

  if (graphicType === 'path') {
    var shape = elOption.shape; // Using pathRect brings convenience to users sacle svg path.

    var pathRect = shape.width != null && shape.height != null ? {
      x: shape.x || 0,
      y: shape.y || 0,
      width: shape.width,
      height: shape.height
    } : null;
    var pathData = getPathData(shape); // Path is also used for icon, so layout 'center' by default.

    el = _util_graphic__WEBPACK_IMPORTED_MODULE_15__.makePath(pathData, null, pathRect, shape.layout || 'center');
    inner(el).customPathData = pathData;
  } else if (graphicType === 'image') {
    el = new _util_graphic__WEBPACK_IMPORTED_MODULE_16__.default({});
    inner(el).customImagePath = elOption.style.image;
  } else if (graphicType === 'text') {
    el = new _util_graphic__WEBPACK_IMPORTED_MODULE_17__.default({}); // inner(el).customText = (elOption.style as TextStyleProps).text;
  } else if (graphicType === 'group') {
    el = new _util_graphic__WEBPACK_IMPORTED_MODULE_18__.default();
  } else if (graphicType === 'compoundPath') {
    throw new Error('"compoundPath" is not supported yet.');
  } else {
    var Clz = _util_graphic__WEBPACK_IMPORTED_MODULE_15__.getShapeClass(graphicType);

    if (!Clz) {
      var errMsg = '';

      if (true) {
        errMsg = 'graphic type "' + graphicType + '" can not be found.';
      }

      (0,_util_log__WEBPACK_IMPORTED_MODULE_14__.throwError)(errMsg);
    }

    el = new Clz();
  }

  inner(el).customGraphicType = graphicType;
  el.name = elOption.name; // Compat ec4: the default z2 lift is 1. If changing the number,
  // some cases probably be broken: hierarchy layout along z, like circle packing,
  // where emphasis only intending to modify color/border rather than lift z2.

  el.z2EmphasisLift = 1;
  el.z2SelectLift = 1;
  return el;
}
/**
 * ----------------------------------------------------------
 * [STRATEGY_MERGE] Merge properties or erase all properties:
 *
 * Based on the fact that the existing zr element probably be reused, we now consider whether
 * merge or erase all properties to the exsiting elements.
 * That is, if a certain props is not specified in the lastest return of `renderItem`:
 * + "Merge" means that do not modify the value on the existing element.
 * + "Erase all" means that use a default value to the existing element.
 *
 * "Merge" might bring some unexpected state retaining for users and "erase all" seams to be
 * more safe. "erase all" force users to specify all of the props each time, which is recommanded
 * in most cases.
 * But "erase all" theoretically disables the chance of performance optimization (e.g., just
 * generete shape and style at the first time rather than always do that).
 * So we still use "merge" rather than "erase all". If users need "erase all", they can
 * simple always set all of the props each time.
 * Some "object-like" config like `textConfig`, `textContent`, `style` which are not needed for
 * every elment, so we replace them only when user specify them. And the that is a total replace.
 *
 * TODO: there is no hint of 'isFirst' to users. So the performance enhancement can not be
 * performed yet. Consider the case:
 * (1) setOption to "mergeChildren" with a smaller children count
 * (2) Use dataZoom to make an item disappear.
 * (3) User dataZoom to make the item display again. At that time, renderItem need to return the
 * full option rather than partial option to recreate the element.
 *
 * ----------------------------------------------
 * [STRATEGY_NULL] `hasOwnProperty` or `== null`:
 *
 * Ditinguishing "own property" probably bring little trouble to user when make el options.
 * So we  trade a {xx: null} or {xx: undefined} as "not specified" if possible rather than
 * "set them to null/undefined". In most cases, props can not be cleared. Some typicall
 * clearable props like `style`/`textConfig`/`textContent` we enable `false` to means
 * "clear". In some othere special cases that the prop is able to set as null/undefined,
 * but not suitable to use `false`, `hasOwnProperty` is checked.
 *
 * ---------------------------------------------
 * [STRATEGY_TRANSITION] The rule of transition:
 * + For props on the root level of a element:
 *      If there is no `transition` specified, tansform props will be transitioned by default,
 *      which is the same as the previous setting in echarts4 and suitable for the scenario
 *      of dataZoom change.
 *      If `transition` specified, only the specified props will be transitioned.
 * + For props in `shape` and `style`:
 *      Only props specified in `transition` will be transitioned.
 * + Break:
 *      Since ec5, do not make transition to shape by default, because it might result in
 *      performance issue (especially `points` of polygon) and do not necessary in most cases.
 *
 * @return if `isMorphTo`, return `allPropsFinal`.
 */


function updateElNormal( // Can be null/undefined
api, el, // Whether be a morph target.
isMorphTo, dataIndex, elOption, styleOpt, attachedTxInfo, seriesModel, isInit, isTextContent) {
  var transFromProps = {};
  var allPropsFinal = {};
  var elDisplayable = el.isGroup ? null : el; // If be "morph to", delay the `updateElNormal` when all of the els in
  // this data item processed. Because at that time we can get all of the
  // "morph from" and make correct separate/combine.

  !isMorphTo && prepareShapeOrExtraTransitionFrom('shape', el, null, elOption, transFromProps, isInit);
  prepareShapeOrExtraAllPropsFinal('shape', elOption, allPropsFinal);
  !isMorphTo && prepareShapeOrExtraTransitionFrom('extra', el, null, elOption, transFromProps, isInit);
  prepareShapeOrExtraAllPropsFinal('extra', elOption, allPropsFinal);
  !isMorphTo && prepareTransformTransitionFrom(el, null, elOption, transFromProps, isInit);
  prepareTransformAllPropsFinal(elOption, allPropsFinal);
  var txCfgOpt = attachedTxInfo && attachedTxInfo.normal.cfg;

  if (txCfgOpt) {
    // PENDING: whether use user object directly rather than clone?
    // TODO:5.0 textConfig transition animation?
    el.setTextConfig(txCfgOpt);
  }

  if (el.type === 'text' && styleOpt) {
    var textOptionStyle = styleOpt; // Compatible with ec4: if `textFill` or `textStroke` exists use them.

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(textOptionStyle, 'textFill') && (textOptionStyle.fill = textOptionStyle.textFill);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(textOptionStyle, 'textStroke') && (textOptionStyle.stroke = textOptionStyle.textStroke);
  }

  if (styleOpt) {
    var decalPattern = void 0;
    var decalObj = isPath(el) ? styleOpt.decal : null;

    if (api && decalObj) {
      decalObj.dirty = true;
      decalPattern = (0,_util_decal__WEBPACK_IMPORTED_MODULE_19__.createOrUpdatePatternFromDecal)(decalObj, api);
    } // Always overwrite in case user specify this prop.


    styleOpt.__decalPattern = decalPattern;
  }

  !isMorphTo && prepareStyleTransitionFrom(el, null, elOption, styleOpt, transFromProps, isInit);

  if (elDisplayable) {
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(elOption, 'invisible') && (elDisplayable.invisible = elOption.invisible);
  } // If `isMorphTo`, we should not update these props to el directly, otherwise,
  // when applying morph finally, the original prop are missing for making "animation from".


  if (!isMorphTo) {
    applyPropsFinal(el, allPropsFinal, styleOpt);
    applyTransitionFrom(el, dataIndex, elOption, seriesModel, transFromProps, isInit);
  } // Merge by default.


  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(elOption, 'silent') && (el.silent = elOption.silent);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(elOption, 'ignore') && (el.ignore = elOption.ignore);

  if (!isTextContent) {
    // `elOption.info` enables user to mount some info on
    // elements and use them in event handlers.
    // Update them only when user specified, otherwise, remain.
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(elOption, 'info') && (inner(el).info = elOption.info);
  }

  styleOpt ? el.dirty() : el.markRedraw();
  return isMorphTo ? allPropsFinal : null;
}

function applyPropsFinal(el, // Can be null/undefined
allPropsFinal, styleOpt) {
  var elDisplayable = el.isGroup ? null : el;

  if (elDisplayable && styleOpt) {
    var decalPattern = styleOpt.__decalPattern;
    var originalDecalObj = void 0;

    if (decalPattern) {
      originalDecalObj = styleOpt.decal;
      styleOpt.decal = decalPattern;
    } // PENDING: here the input style object is used directly.
    // Good for performance but bad for compatibility control.


    elDisplayable.useStyle(styleOpt);

    if (decalPattern) {
      styleOpt.decal = originalDecalObj;
    } // When style object changed, how to trade the existing animation?
    // It is probably conplicated and not needed to cover all the cases.
    // But still need consider the case:
    // (1) When using init animation on `style.opacity`, and before the animation
    //     ended users triggers an update by mousewhell. At that time the init
    //     animation should better be continued rather than terminated.
    //     So after `useStyle` called, we should change the animation target manually
    //     to continue the effect of the init animation.
    // (2) PENDING: If the previous animation targeted at a `val1`, and currently we need
    //     to update the value to `val2` and no animation declared, should be terminate
    //     the previous animation or just modify the target of the animation?
    //     Therotically That will happen not only on `style` but also on `shape` and
    //     `transfrom` props. But we haven't handle this case at present yet.
    // (3) PENDING: Is it proper to visit `animators` and `targetName`?


    var animators = elDisplayable.animators;

    for (var i = 0; i < animators.length; i++) {
      var animator = animators[i]; // targetName is the "topKey".

      if (animator.targetName === 'style') {
        animator.changeTarget(elDisplayable.style);
      }
    }
  } // Set el to the final state firstly.


  allPropsFinal && el.attr(allPropsFinal);
}

function applyTransitionFrom(el, dataIndex, elOption, seriesModel, // Can be null/undefined
transFromProps, isInit) {
  if (transFromProps) {
    // Do not use `el.updateDuringAnimation` here becuase `el.updateDuringAnimation` will
    // be called mutiple time in each animation frame. For example, if both "transform" props
    // and shape props and style props changed, it will generate three animator and called
    // one-by-one in each animation frame.
    // We use the during in `animateTo/From` params.
    var userDuring = elOption.during; // For simplicity, if during not specified, the previous during will not work any more.

    inner(el).userDuring = userDuring;
    var cfgDuringCall = userDuring ? (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind)(duringCall, {
      el: el,
      userDuring: userDuring
    }) : null;
    var cfg = {
      dataIndex: dataIndex,
      isFrom: true,
      during: cfgDuringCall
    };
    isInit ? _util_graphic__WEBPACK_IMPORTED_MODULE_15__.initProps(el, transFromProps, seriesModel, cfg) : _util_graphic__WEBPACK_IMPORTED_MODULE_15__.updateProps(el, transFromProps, seriesModel, cfg);
  }
} // See [STRATEGY_TRANSITION]


function prepareShapeOrExtraTransitionFrom(mainAttr, el, morphFromEl, elOption, transFromProps, isInit) {
  var attrOpt = elOption[mainAttr];

  if (!attrOpt) {
    return;
  }

  var elPropsInAttr = el[mainAttr];
  var transFromPropsInAttr;
  var enterFrom = attrOpt.enterFrom;

  if (isInit && enterFrom) {
    !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
    var enterFromKeys = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.keys)(enterFrom);

    for (var i = 0; i < enterFromKeys.length; i++) {
      // `enterFrom` props are not necessarily also declared in `shape`/`style`/...,
      // for example, `opacity` can only declared in `enterFrom` but not in `style`.
      var key = enterFromKeys[i]; // Do not clone, animator will perform that clone.

      transFromPropsInAttr[key] = enterFrom[key];
    }
  }

  if (!isInit && elPropsInAttr // Just ignore shape animation in morphing.
  && !(morphFromEl != null && mainAttr === 'shape')) {
    if (attrOpt.transition) {
      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
      var transitionKeys = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.normalizeToArray)(attrOpt.transition);

      for (var i = 0; i < transitionKeys.length; i++) {
        var key = transitionKeys[i];
        var elVal = elPropsInAttr[key];

        if (true) {
          checkNonStyleTansitionRefer(key, attrOpt[key], elVal);
        } // Do not clone, see `checkNonStyleTansitionRefer`.


        transFromPropsInAttr[key] = elVal;
      }
    } else if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.indexOf)(elOption.transition, mainAttr) >= 0) {
      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
      var elPropsInAttrKeys = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.keys)(elPropsInAttr);

      for (var i = 0; i < elPropsInAttrKeys.length; i++) {
        var key = elPropsInAttrKeys[i];
        var elVal = elPropsInAttr[key];

        if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {
          transFromPropsInAttr[key] = elVal;
        }
      }
    }
  }

  var leaveTo = attrOpt.leaveTo;

  if (leaveTo) {
    var leaveToProps = getOrCreateLeaveToPropsFromEl(el);
    var leaveToPropsInAttr = leaveToProps[mainAttr] || (leaveToProps[mainAttr] = {});
    var leaveToKeys = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.keys)(leaveTo);

    for (var i = 0; i < leaveToKeys.length; i++) {
      var key = leaveToKeys[i];
      leaveToPropsInAttr[key] = leaveTo[key];
    }
  }
}

function prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {
  var attrOpt = elOption[mainAttr];

  if (!attrOpt) {
    return;
  }

  var allPropsInAttr = allProps[mainAttr] = {};
  var keysInAttr = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.keys)(attrOpt);

  for (var i = 0; i < keysInAttr.length; i++) {
    var key = keysInAttr[i]; // To avoid share one object with different element, and
    // to avoid user modify the object inexpectedly, have to clone.

    allPropsInAttr[key] = (0,zrender_lib_animation_Animator__WEBPACK_IMPORTED_MODULE_20__.cloneValue)(attrOpt[key]);
  }
} // See [STRATEGY_TRANSITION].


function prepareTransformTransitionFrom(el, morphFromEl, elOption, transFromProps, isInit) {
  var enterFrom = elOption.enterFrom;

  if (isInit && enterFrom) {
    var enterFromKeys = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.keys)(enterFrom);

    for (var i = 0; i < enterFromKeys.length; i++) {
      var key = enterFromKeys[i];

      if (true) {
        checkTransformPropRefer(key, 'el.enterFrom');
      } // Do not clone, animator will perform that clone.


      transFromProps[key] = enterFrom[key];
    }
  }

  if (!isInit) {
    // If morphing, force transition all transform props.
    // otherwise might have incorrect morphing animation.
    if (morphFromEl) {
      var fromTransformable = calcOldElLocalTransformBasedOnNewElParent(morphFromEl, el);
      setTransformPropToTransitionFrom(transFromProps, 'x', fromTransformable);
      setTransformPropToTransitionFrom(transFromProps, 'y', fromTransformable);
      setTransformPropToTransitionFrom(transFromProps, 'scaleX', fromTransformable);
      setTransformPropToTransitionFrom(transFromProps, 'scaleY', fromTransformable);
      setTransformPropToTransitionFrom(transFromProps, 'originX', fromTransformable);
      setTransformPropToTransitionFrom(transFromProps, 'originY', fromTransformable);
      setTransformPropToTransitionFrom(transFromProps, 'rotation', fromTransformable);
    } else if (elOption.transition) {
      var transitionKeys = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.normalizeToArray)(elOption.transition);

      for (var i = 0; i < transitionKeys.length; i++) {
        var key = transitionKeys[i];

        if (key === 'style' || key === 'shape' || key === 'extra') {
          continue;
        }

        var elVal = el[key];

        if (true) {
          checkTransformPropRefer(key, 'el.transition');
          checkNonStyleTansitionRefer(key, elOption[key], elVal);
        } // Do not clone, see `checkNonStyleTansitionRefer`.


        transFromProps[key] = elVal;
      }
    } // This default transition see [STRATEGY_TRANSITION]
    else {
        setTransformPropToTransitionFrom(transFromProps, 'x', el);
        setTransformPropToTransitionFrom(transFromProps, 'y', el);
      }
  }

  var leaveTo = elOption.leaveTo;

  if (leaveTo) {
    var leaveToProps = getOrCreateLeaveToPropsFromEl(el);
    var leaveToKeys = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.keys)(leaveTo);

    for (var i = 0; i < leaveToKeys.length; i++) {
      var key = leaveToKeys[i];

      if (true) {
        checkTransformPropRefer(key, 'el.leaveTo');
      }

      leaveToProps[key] = leaveTo[key];
    }
  }
}

function prepareTransformAllPropsFinal(elOption, allProps) {
  setLagecyTransformProp(elOption, allProps, 'position');
  setLagecyTransformProp(elOption, allProps, 'scale');
  setLagecyTransformProp(elOption, allProps, 'origin');
  setTransformProp(elOption, allProps, 'x');
  setTransformProp(elOption, allProps, 'y');
  setTransformProp(elOption, allProps, 'scaleX');
  setTransformProp(elOption, allProps, 'scaleY');
  setTransformProp(elOption, allProps, 'originX');
  setTransformProp(elOption, allProps, 'originY');
  setTransformProp(elOption, allProps, 'rotation');
} // See [STRATEGY_TRANSITION].


function prepareStyleTransitionFrom(el, morphFromEl, elOption, styleOpt, transFromProps, isInit) {
  if (!styleOpt) {
    return;
  } // At present in "many-to-one"/"one-to-many" case, to not support "many" have
  // different styles and make style transitions. That might be a rare case.


  var fromEl = morphFromEl || el;
  var fromElStyle = fromEl.style;
  var transFromStyleProps;
  var enterFrom = styleOpt.enterFrom;

  if (isInit && enterFrom) {
    var enterFromKeys = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.keys)(enterFrom);
    !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});

    for (var i = 0; i < enterFromKeys.length; i++) {
      var key = enterFromKeys[i]; // Do not clone, animator will perform that clone.

      transFromStyleProps[key] = enterFrom[key];
    }
  }

  if (!isInit && fromElStyle) {
    if (styleOpt.transition) {
      var transitionKeys = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.normalizeToArray)(styleOpt.transition);
      !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});

      for (var i = 0; i < transitionKeys.length; i++) {
        var key = transitionKeys[i];
        var elVal = fromElStyle[key]; // Do not clone, see `checkNonStyleTansitionRefer`.

        transFromStyleProps[key] = elVal;
      }
    } else if (el.getAnimationStyleProps && (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.indexOf)(elOption.transition, 'style') >= 0) {
      var animationProps = el.getAnimationStyleProps();
      var animationStyleProps = animationProps ? animationProps.style : null;

      if (animationStyleProps) {
        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
        var styleKeys = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.keys)(styleOpt);

        for (var i = 0; i < styleKeys.length; i++) {
          var key = styleKeys[i];

          if (animationStyleProps[key]) {
            var elVal = fromElStyle[key];
            transFromStyleProps[key] = elVal;
          }
        }
      }
    }
  }

  var leaveTo = styleOpt.leaveTo;

  if (leaveTo) {
    var leaveToKeys = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.keys)(leaveTo);
    var leaveToProps = getOrCreateLeaveToPropsFromEl(el);
    var leaveToStyleProps = leaveToProps.style || (leaveToProps.style = {});

    for (var i = 0; i < leaveToKeys.length; i++) {
      var key = leaveToKeys[i];
      leaveToStyleProps[key] = leaveTo[key];
    }
  }
}
/**
 * If make "transform"(x/y/scaleX/scaleY/orient/originX/originY) transition between
 * two path elements that have different hierarchy, before we retrieve the "from" props,
 * we have to calculate the local transition of the "oldPath" based on the parent of
 * the "newPath".
 * At present, the case only happend in "morphing". Without morphing, the transform
 * transition are all between elements in the same hierarchy, where this kind of process
 * is not needed.
 *
 * [CAVEAT]:
 * This method makes sense only if: (very tricky)
 * (1) "newEl" has been added to its final parent.
 * (2) Local transform props of "newPath.parent" are not at their final value but already
 * have been at the "from value".
 *     This is currently ensured by:
 *     (2.1) "graphicUtil.animationFrom", which will set the element to the "from value"
 *     immediately.
 *     (2.2) "morph" option is not allowed to be set on Group, so all of the groups have
 *     been finished their "updateElNormal" when calling this method in morphing process.
 */


function calcOldElLocalTransformBasedOnNewElParent(oldEl, newEl) {
  if (!oldEl || oldEl === newEl || oldEl.parent === newEl.parent) {
    return oldEl;
  } // Not sure oldEl is rendered (may have "lazyUpdate"),
  // so always call `getComputedTransform`.


  var tmpM = tmpTransformable.transform || (tmpTransformable.transform = zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_21__.identity([]));
  var oldGlobalTransform = oldEl.getComputedTransform();
  oldGlobalTransform ? zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_21__.copy(tmpM, oldGlobalTransform) : zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_21__.identity(tmpM);
  var newParent = newEl.parent;

  if (newParent) {
    newParent.getComputedTransform();
  }

  tmpTransformable.originX = oldEl.originX;
  tmpTransformable.originY = oldEl.originY;
  tmpTransformable.parent = newParent;
  tmpTransformable.decomposeTransform();
  return tmpTransformable;
}

var checkNonStyleTansitionRefer;

if (true) {
  checkNonStyleTansitionRefer = function (propName, optVal, elVal) {
    if (!(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArrayLike)(optVal)) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)(optVal != null && isFinite(optVal), 'Prop `' + propName + '` must refer to a finite number or ArrayLike for transition.');
    } else {
      // Try not to copy array for performance, but if user use the same object in different
      // call of `renderItem`, it will casue animation transition fail.
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)(optVal !== elVal, 'Prop `' + propName + '` must use different Array object each time for transition.');
    }
  };
}

function isNonStyleTransitionEnabled(optVal, elVal) {
  // The same as `checkNonStyleTansitionRefer`.
  return !(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArrayLike)(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;
}

var checkTransformPropRefer;

if (true) {
  checkTransformPropRefer = function (key, usedIn) {
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(TRANSFORM_PROPS, key), 'Prop `' + key + '` is not a permitted in `' + usedIn + '`. ' + 'Only `' + (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.keys)(TRANSFORM_PROPS).join('`, `') + '` are permitted.');
  };
}

function getOrCreateLeaveToPropsFromEl(el) {
  var innerEl = inner(el);
  return innerEl.leaveToProps || (innerEl.leaveToProps = {});
} // Use it to avoid it be exposed to user.


var tmpDuringScope = {};
var customDuringAPI = {
  // Usually other props do not need to be changed in animation during.
  setTransform: function (key, val) {
    if (true) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(TRANSFORM_PROPS, key), 'Only ' + transformPropNamesStr + ' available in `setTransform`.');
    }

    tmpDuringScope.el[key] = val;
    return this;
  },
  getTransform: function (key) {
    if (true) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(TRANSFORM_PROPS, key), 'Only ' + transformPropNamesStr + ' available in `getTransform`.');
    }

    return tmpDuringScope.el[key];
  },
  setShape: function (key, val) {
    if (true) {
      assertNotReserved(key);
    }

    var shape = tmpDuringScope.el.shape || (tmpDuringScope.el.shape = {});
    shape[key] = val;
    tmpDuringScope.isShapeDirty = true;
    return this;
  },
  getShape: function (key) {
    if (true) {
      assertNotReserved(key);
    }

    var shape = tmpDuringScope.el.shape;

    if (shape) {
      return shape[key];
    }
  },
  setStyle: function (key, val) {
    if (true) {
      assertNotReserved(key);
    }

    var style = tmpDuringScope.el.style;

    if (style) {
      if (true) {
        if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.eqNaN)(val)) {
          (0,_util_log__WEBPACK_IMPORTED_MODULE_14__.warn)('style.' + key + ' must not be assigned with NaN.');
        }
      }

      style[key] = val;
      tmpDuringScope.isStyleDirty = true;
    }

    return this;
  },
  getStyle: function (key) {
    if (true) {
      assertNotReserved(key);
    }

    var style = tmpDuringScope.el.style;

    if (style) {
      return style[key];
    }
  },
  setExtra: function (key, val) {
    if (true) {
      assertNotReserved(key);
    }

    var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});
    extra[key] = val;
    return this;
  },
  getExtra: function (key) {
    if (true) {
      assertNotReserved(key);
    }

    var extra = tmpDuringScope.el.extra;

    if (extra) {
      return extra[key];
    }
  }
};

function assertNotReserved(key) {
  if (true) {
    if (key === 'transition' || key === 'enterFrom' || key === 'leaveTo') {
      throw new Error('key must not be "' + key + '"');
    }
  }
}

function duringCall() {
  // Do not provide "percent" until some requirements come.
  // Because consider thies case:
  // enterFrom: {x: 100, y: 30}, transition: 'x'.
  // And enter duration is different from update duration.
  // Thus it might be confused about the meaning of "percent" in during callback.
  var scope = this;
  var el = scope.el;

  if (!el) {
    return;
  } // If el is remove from zr by reason like legend, during still need to called,
  // becuase el will be added back to zr and the prop value should not be incorrect.


  var newstUserDuring = inner(el).userDuring;
  var scopeUserDuring = scope.userDuring; // Ensured a during is only called once in each animation frame.
  // If a during is called multiple times in one frame, maybe some users' calulation logic
  // might be wrong (not sure whether this usage exists).
  // The case of a during might be called twice can be: by default there is a animator for
  // 'x', 'y' when init. Before the init animation finished, call `setOption` to start
  // another animators for 'style'/'shape'/'extra'.

  if (newstUserDuring !== scopeUserDuring) {
    // release
    scope.el = scope.userDuring = null;
    return;
  }

  tmpDuringScope.el = el;
  tmpDuringScope.isShapeDirty = false;
  tmpDuringScope.isStyleDirty = false; // Give no `this` to user in "during" calling.

  scopeUserDuring(customDuringAPI);

  if (tmpDuringScope.isShapeDirty && el.dirtyShape) {
    el.dirtyShape();
  }

  if (tmpDuringScope.isStyleDirty && el.dirtyStyle) {
    el.dirtyStyle();
  } // markRedraw() will be called by default in during.
  // FIXME `this.markRedraw();` directly ?
  // FIXME: if in future meet the case that some prop will be both modified in `during` and `state`,
  // consider the issue that the prop might be incorrect when return to "normal" state.

}

function updateElOnState(state, el, elStateOpt, styleOpt, attachedTxInfo, isRoot, isTextContent) {
  var elDisplayable = el.isGroup ? null : el;
  var txCfgOpt = attachedTxInfo && attachedTxInfo[state].cfg; // PENDING:5.0 support customize scale change and transition animation?

  if (elDisplayable) {
    // By default support auto lift color when hover whether `emphasis` specified.
    var stateObj = elDisplayable.ensureState(state);

    if (styleOpt === false) {
      var existingEmphasisState = elDisplayable.getState(state);

      if (existingEmphasisState) {
        existingEmphasisState.style = null;
      }
    } else {
      // style is needed to enable defaut emphasis.
      stateObj.style = styleOpt || null;
    } // If `elOption.styleEmphasis` or `elOption.emphasis.style` is `false`,
    // remove hover style.
    // If `elOption.textConfig` or `elOption.emphasis.textConfig` is null/undefined, it does not
    // make sense. So for simplicity, we do not ditinguish `hasOwnProperty` and null/undefined.


    if (txCfgOpt) {
      stateObj.textConfig = txCfgOpt;
    }

    (0,_util_states__WEBPACK_IMPORTED_MODULE_22__.setDefaultStateProxy)(elDisplayable);
  }
}

function updateZ(el, elOption, seriesModel, attachedTxInfo) {
  // Group not support textContent and not support z yet.
  if (el.isGroup) {
    return;
  }

  var elDisplayable = el;
  var currentZ = seriesModel.currentZ;
  var currentZLevel = seriesModel.currentZLevel; // Always erase.

  elDisplayable.z = currentZ;
  elDisplayable.zlevel = currentZLevel; // z2 must not be null/undefined, otherwise sort error may occur.

  var optZ2 = elOption.z2;
  optZ2 != null && (elDisplayable.z2 = optZ2 || 0);

  for (var i = 0; i < STATES.length; i++) {
    updateZForEachState(elDisplayable, elOption, STATES[i]);
  }
}

function updateZForEachState(elDisplayable, elOption, state) {
  var isNormal = state === NORMAL;
  var elStateOpt = isNormal ? elOption : retrieveStateOption(elOption, state);
  var optZ2 = elStateOpt ? elStateOpt.z2 : null;
  var stateObj;

  if (optZ2 != null) {
    // Do not `ensureState` until required.
    stateObj = isNormal ? elDisplayable : elDisplayable.ensureState(state);
    stateObj.z2 = optZ2 || 0;
  }
}

function setLagecyTransformProp(elOption, targetProps, legacyName, fromTransformable // If provided, retrieve from the element.
) {
  var legacyArr = elOption[legacyName];
  var xyName = LEGACY_TRANSFORM_PROPS[legacyName];

  if (legacyArr) {
    if (fromTransformable) {
      targetProps[xyName[0]] = fromTransformable[xyName[0]];
      targetProps[xyName[1]] = fromTransformable[xyName[1]];
    } else {
      targetProps[xyName[0]] = legacyArr[0];
      targetProps[xyName[1]] = legacyArr[1];
    }
  }
}

function setTransformProp(elOption, allProps, name, fromTransformable // If provided, retrieve from the element.
) {
  if (elOption[name] != null) {
    allProps[name] = fromTransformable ? fromTransformable[name] : elOption[name];
  }
}

function setTransformPropToTransitionFrom(transitionFrom, name, fromTransformable // If provided, retrieve from the element.
) {
  if (fromTransformable) {
    transitionFrom[name] = fromTransformable[name];
  }
}

function makeRenderItem(customSeries, data, ecModel, api) {
  var renderItem = customSeries.get('renderItem');
  var coordSys = customSeries.coordinateSystem;
  var prepareResult = {};

  if (coordSys) {
    if (true) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)(renderItem, 'series.render is required.');
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)(coordSys.prepareCustoms || prepareCustoms[coordSys.type], 'This coordSys does not support custom series.');
    } // `coordSys.prepareCustoms` is used for external coord sys like bmap.


    prepareResult = coordSys.prepareCustoms ? coordSys.prepareCustoms(coordSys) : prepareCustoms[coordSys.type](coordSys);
  }

  var userAPI = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults)({
    getWidth: api.getWidth,
    getHeight: api.getHeight,
    getZr: api.getZr,
    getDevicePixelRatio: api.getDevicePixelRatio,
    value: value,
    style: style,
    ordinalRawValue: ordinalRawValue,
    styleEmphasis: styleEmphasis,
    visual: visual,
    barLayout: barLayout,
    currentSeriesIndices: currentSeriesIndices,
    font: font
  }, prepareResult.api || {});
  var userParams = {
    // The life cycle of context: current round of rendering.
    // The global life cycle is probably not necessary, because
    // user can store global status by themselves.
    context: {},
    seriesId: customSeries.id,
    seriesName: customSeries.name,
    seriesIndex: customSeries.seriesIndex,
    coordSys: prepareResult.coordSys,
    dataInsideLength: data.count(),
    encode: wrapEncodeDef(customSeries.getData())
  }; // If someday intending to refactor them to a class, should consider do not
  // break change: currently these attribute member are encapsulated in a closure
  // so that do not need to force user to call these method with a scope.
  // Do not support call `api` asynchronously without dataIndexInside input.

  var currDataIndexInside;
  var currItemModel;
  var currItemStyleModels = {};
  var currLabelModels = {};
  var seriesItemStyleModels = {};
  var seriesLabelModels = {};

  for (var i = 0; i < STATES.length; i++) {
    var stateName = STATES[i];
    seriesItemStyleModels[stateName] = customSeries.getModel(PATH_ITEM_STYLE[stateName]);
    seriesLabelModels[stateName] = customSeries.getModel(PATH_LABEL[stateName]);
  }

  function getItemModel(dataIndexInside) {
    return dataIndexInside === currDataIndexInside ? currItemModel || (currItemModel = data.getItemModel(dataIndexInside)) : data.getItemModel(dataIndexInside);
  }

  function getItemStyleModel(dataIndexInside, state) {
    return !data.hasItemOption ? seriesItemStyleModels[state] : dataIndexInside === currDataIndexInside ? currItemStyleModels[state] || (currItemStyleModels[state] = getItemModel(dataIndexInside).getModel(PATH_ITEM_STYLE[state])) : getItemModel(dataIndexInside).getModel(PATH_ITEM_STYLE[state]);
  }

  function getLabelModel(dataIndexInside, state) {
    return !data.hasItemOption ? seriesLabelModels[state] : dataIndexInside === currDataIndexInside ? currLabelModels[state] || (currLabelModels[state] = getItemModel(dataIndexInside).getModel(PATH_LABEL[state])) : getItemModel(dataIndexInside).getModel(PATH_LABEL[state]);
  }

  return function (dataIndexInside, payload) {
    currDataIndexInside = dataIndexInside;
    currItemModel = null;
    currItemStyleModels = {};
    currLabelModels = {};
    return renderItem && renderItem((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults)({
      dataIndexInside: dataIndexInside,
      dataIndex: data.getRawIndex(dataIndexInside),
      // Can be used for optimization when zoom or roam.
      actionType: payload ? payload.type : null
    }, userParams), userAPI);
  };
  /**
   * @public
   * @param dim by default 0.
   * @param dataIndexInside by default `currDataIndexInside`.
   */

  function value(dim, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    return data.get(data.getDimension(dim || 0), dataIndexInside);
  }
  /**
   * @public
   * @param dim by default 0.
   * @param dataIndexInside by default `currDataIndexInside`.
   */


  function ordinalRawValue(dim, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    var dimInfo = data.getDimensionInfo(dim || 0);

    if (!dimInfo) {
      return;
    }

    var val = data.get(dimInfo.name, dataIndexInside);
    var ordinalMeta = dimInfo && dimInfo.ordinalMeta;
    return ordinalMeta ? ordinalMeta.categories[val] : val;
  }
  /**
   * @deprecated The orgininal intention of `api.style` is enable to set itemStyle
   * like other series. But it not necessary and not easy to give a strict definition
   * of what it return. And since echarts5 it needs to be make compat work. So
   * deprecates it since echarts5.
   *
   * By default, `visual` is applied to style (to support visualMap).
   * `visual.color` is applied at `fill`. If user want apply visual.color on `stroke`,
   * it can be implemented as:
   * `api.style({stroke: api.visual('color'), fill: null})`;
   *
   * [Compat]: since ec5, RectText has been separated from its hosts el.
   * so `api.style()` will only return the style from `itemStyle` but not handle `label`
   * any more. But `series.label` config is never published in doc.
   * We still compat it in `api.style()`. But not encourage to use it and will still not
   * to pulish it to doc.
   * @public
   * @param dataIndexInside by default `currDataIndexInside`.
   */


  function style(userProps, dataIndexInside) {
    if (true) {
      (0,_util_styleCompat__WEBPACK_IMPORTED_MODULE_23__.warnDeprecated)('api.style', 'Please write literal style directly instead.');
    }

    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    var style = data.getItemVisual(dataIndexInside, 'style');
    var visualColor = style && style.fill;
    var opacity = style && style.opacity;
    var itemStyle = getItemStyleModel(dataIndexInside, NORMAL).getItemStyle();
    visualColor != null && (itemStyle.fill = visualColor);
    opacity != null && (itemStyle.opacity = opacity);
    var opt = {
      inheritColor: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isString)(visualColor) ? visualColor : '#000'
    };
    var labelModel = getLabelModel(dataIndexInside, NORMAL); // Now that the feture of "auto adjust text fill/stroke" has been migrated to zrender
    // since ec5, we should set `isAttached` as `false` here and make compat in
    // `convertToEC4StyleForCustomSerise`.

    var textStyle = _label_labelStyle__WEBPACK_IMPORTED_MODULE_24__.createTextStyle(labelModel, null, opt, false, true);
    textStyle.text = labelModel.getShallow('show') ? (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(customSeries.getFormattedLabel(dataIndexInside, NORMAL), (0,_helper_labelHelper__WEBPACK_IMPORTED_MODULE_25__.getDefaultLabel)(data, dataIndexInside)) : null;
    var textConfig = _label_labelStyle__WEBPACK_IMPORTED_MODULE_24__.createTextConfig(labelModel, opt, false);
    preFetchFromExtra(userProps, itemStyle);
    itemStyle = (0,_util_styleCompat__WEBPACK_IMPORTED_MODULE_23__.convertToEC4StyleForCustomSerise)(itemStyle, textStyle, textConfig);
    userProps && applyUserPropsAfter(itemStyle, userProps);
    itemStyle.legacy = true;
    return itemStyle;
  }
  /**
   * @deprecated The reason see `api.style()`
   * @public
   * @param dataIndexInside by default `currDataIndexInside`.
   */


  function styleEmphasis(userProps, dataIndexInside) {
    if (true) {
      (0,_util_styleCompat__WEBPACK_IMPORTED_MODULE_23__.warnDeprecated)('api.styleEmphasis', 'Please write literal style directly instead.');
    }

    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    var itemStyle = getItemStyleModel(dataIndexInside, EMPHASIS).getItemStyle();
    var labelModel = getLabelModel(dataIndexInside, EMPHASIS);
    var textStyle = _label_labelStyle__WEBPACK_IMPORTED_MODULE_24__.createTextStyle(labelModel, null, null, true, true);
    textStyle.text = labelModel.getShallow('show') ? (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.retrieve3)(customSeries.getFormattedLabel(dataIndexInside, EMPHASIS), customSeries.getFormattedLabel(dataIndexInside, NORMAL), (0,_helper_labelHelper__WEBPACK_IMPORTED_MODULE_25__.getDefaultLabel)(data, dataIndexInside)) : null;
    var textConfig = _label_labelStyle__WEBPACK_IMPORTED_MODULE_24__.createTextConfig(labelModel, null, true);
    preFetchFromExtra(userProps, itemStyle);
    itemStyle = (0,_util_styleCompat__WEBPACK_IMPORTED_MODULE_23__.convertToEC4StyleForCustomSerise)(itemStyle, textStyle, textConfig);
    userProps && applyUserPropsAfter(itemStyle, userProps);
    itemStyle.legacy = true;
    return itemStyle;
  }

  function applyUserPropsAfter(itemStyle, extra) {
    for (var key in extra) {
      if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(extra, key)) {
        itemStyle[key] = extra[key];
      }
    }
  }

  function preFetchFromExtra(extra, itemStyle) {
    // A trick to retrieve those props firstly, which are used to
    // apply auto inside fill/stroke in `convertToEC4StyleForCustomSerise`.
    // (It's not reasonable but only for a degree of compat)
    if (extra) {
      extra.textFill && (itemStyle.textFill = extra.textFill);
      extra.textPosition && (itemStyle.textPosition = extra.textPosition);
    }
  }
  /**
   * @public
   * @param dataIndexInside by default `currDataIndexInside`.
   */


  function visual(visualType, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);

    if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(STYLE_VISUAL_TYPE, visualType)) {
      var style_1 = data.getItemVisual(dataIndexInside, 'style');
      return style_1 ? style_1[STYLE_VISUAL_TYPE[visualType]] : null;
    } // Only support these visuals. Other visual might be inner tricky
    // for performance (like `style`), do not expose to users.


    if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(NON_STYLE_VISUAL_PROPS, visualType)) {
      return data.getItemVisual(dataIndexInside, visualType);
    }
  }
  /**
   * @public
   * @return If not support, return undefined.
   */


  function barLayout(opt) {
    if (coordSys.type === 'cartesian2d') {
      var baseAxis = coordSys.getBaseAxis();
      return (0,_layout_barGrid__WEBPACK_IMPORTED_MODULE_26__.getLayoutOnAxis)((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults)({
        axis: baseAxis
      }, opt));
    }
  }
  /**
   * @public
   */


  function currentSeriesIndices() {
    return ecModel.getCurrentSeriesIndices();
  }
  /**
   * @public
   * @return font string
   */


  function font(opt) {
    return _label_labelStyle__WEBPACK_IMPORTED_MODULE_24__.getFont(opt, ecModel);
  }
}

function wrapEncodeDef(data) {
  var encodeDef = {};
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(data.dimensions, function (dimName, dataDimIndex) {
    var dimInfo = data.getDimensionInfo(dimName);

    if (!dimInfo.isExtraCoord) {
      var coordDim = dimInfo.coordDim;
      var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];
      dataDims[dimInfo.coordDimIndex] = dataDimIndex;
    }
  });
  return encodeDef;
}

function createOrUpdateItem(api, el, dataIndex, elOption, seriesModel, group, data, morphPreparation) {
  // [Rule]
  // If `renderItem` returns `null`/`undefined`/`false`, remove the previous el if existing.
  //     (It seems that violate the "merge" principle, but most of users probably intuitively
  //     regard "return;" as "show nothing element whatever", so make a exception to meet the
  //     most cases.)
  // The rule or "merge" see [STRATEGY_MERGE].
  // If `elOption` is `null`/`undefined`/`false` (when `renderItem` returns nothing).
  if (!elOption) {
    removeElementDirectly(el, group);
    return;
  }

  el = doCreateOrUpdateEl(api, el, dataIndex, elOption, seriesModel, group, true, morphPreparation);
  el && data.setItemGraphicEl(dataIndex, el);
  (0,_util_states__WEBPACK_IMPORTED_MODULE_22__.enableHoverEmphasis)(el, elOption.focus, elOption.blurScope);
  return el;
}

function doCreateOrUpdateEl(api, el, dataIndex, elOption, seriesModel, group, isRoot, morphPreparation) {
  if (true) {
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)(elOption, 'should not have an null/undefined element setting');
  }

  var toBeReplacedIdx = -1;

  if (el && doesElNeedRecreate(el, elOption) // || (
  //     // PENDING: even in one-to-one mapping case, if el is marked as morph,
  //     // do not sure whether the el will be mapped to another el with different
  //     // hierarchy in Group tree. So always recreate el rather than reuse the el.
  //     morphPreparation && morphPreparation.isOneToOneFrom(el)
  // )
  ) {
    // Should keep at the original index, otherwise "merge by index" will be incorrect.
    toBeReplacedIdx = group.childrenRef().indexOf(el);
    el = null;
  }

  var elIsNewCreated = !el;

  if (!el) {
    el = createEl(elOption);
  } else {
    // FIMXE:NEXT unified clearState?
    // If in some case the performance issue arised, consider
    // do not clearState but update cached normal state directly.
    el.clearStates();
  }

  var canMorph = inner(el).canMorph = elOption.morph && isPath(el);
  var thisElIsMorphTo = canMorph && morphPreparation && morphPreparation.hasFrom(); // Use update animation when morph is enabled.

  var isInit = elIsNewCreated && !thisElIsMorphTo;
  attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null;
  attachedTxInfoTmp.isLegacy = false;
  doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfoTmp);
  doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit);
  var pendingAllPropsFinal = updateElNormal(api, el, thisElIsMorphTo, dataIndex, elOption, elOption.style, attachedTxInfoTmp, seriesModel, isInit, false);

  if (thisElIsMorphTo) {
    morphPreparation.addTo(el, elOption, dataIndex, pendingAllPropsFinal);
  }

  for (var i = 0; i < STATES.length; i++) {
    var stateName = STATES[i];

    if (stateName !== NORMAL) {
      var otherStateOpt = retrieveStateOption(elOption, stateName);
      var otherStyleOpt = retrieveStyleOptionOnState(elOption, otherStateOpt, stateName);
      updateElOnState(stateName, el, otherStateOpt, otherStyleOpt, attachedTxInfoTmp, isRoot, false);
    }
  }

  updateZ(el, elOption, seriesModel, attachedTxInfoTmp);

  if (elOption.type === 'group') {
    mergeChildren(api, el, dataIndex, elOption, seriesModel, morphPreparation);
  }

  if (toBeReplacedIdx >= 0) {
    group.replaceAt(el, toBeReplacedIdx);
  } else {
    group.add(el);
  }

  return el;
} // `el` must not be null/undefined.


function doesElNeedRecreate(el, elOption) {
  var elInner = inner(el);
  var elOptionType = elOption.type;
  var elOptionShape = elOption.shape;
  var elOptionStyle = elOption.style;
  return (// If `elOptionType` is `null`, follow the merge principle.
    elOptionType != null && elOptionType !== elInner.customGraphicType || elOptionType === 'path' && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== elInner.customPathData || elOptionType === 'image' && (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(elOptionStyle, 'image') && elOptionStyle.image !== elInner.customImagePath // // FIXME test and remove this restriction?
    // || (elOptionType === 'text'
    //     && hasOwn(elOptionStyle, 'text')
    //     && (elOptionStyle as TextStyleProps).text !== elInner.customText
    // )

  );
}

function doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit) {
  // Based on the "merge" principle, if no clipPath provided,
  // do nothing. The exists clip will be totally removed only if
  // `el.clipPath` is `false`. Otherwise it will be merged/replaced.
  var clipPathOpt = elOption.clipPath;

  if (clipPathOpt === false) {
    if (el && el.getClipPath()) {
      el.removeClipPath();
    }
  } else if (clipPathOpt) {
    var clipPath = el.getClipPath();

    if (clipPath && doesElNeedRecreate(clipPath, clipPathOpt)) {
      clipPath = null;
    }

    if (!clipPath) {
      clipPath = createEl(clipPathOpt);

      if (true) {
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)(clipPath instanceof _util_graphic__WEBPACK_IMPORTED_MODULE_27__.default, 'Only any type of `path` can be used in `clipPath`, rather than ' + clipPath.type + '.');
      }

      el.setClipPath(clipPath);
    }

    updateElNormal(null, clipPath, null, dataIndex, clipPathOpt, null, null, seriesModel, isInit, false);
  } // If not define `clipPath` in option, do nothing unnecessary.

}

function doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfo) {
  // group do not support textContent temporarily untill necessary.
  if (el.isGroup) {
    return;
  } // Normal must be called before emphasis, for `isLegacy` detection.


  processTxInfo(elOption, null, attachedTxInfo);
  processTxInfo(elOption, EMPHASIS, attachedTxInfo); // If `elOption.textConfig` or `elOption.textContent` is null/undefined, it does not make sence.
  // So for simplicity, if "elOption hasOwnProperty of them but be null/undefined", we do not
  // trade them as set to null to el.
  // Especially:
  // `elOption.textContent: false` means remove textContent.
  // `elOption.textContent.emphasis.style: false` means remove the style from emphasis state.

  var txConOptNormal = attachedTxInfo.normal.conOpt;
  var txConOptEmphasis = attachedTxInfo.emphasis.conOpt;
  var txConOptBlur = attachedTxInfo.blur.conOpt;
  var txConOptSelect = attachedTxInfo.select.conOpt;

  if (txConOptNormal != null || txConOptEmphasis != null || txConOptSelect != null || txConOptBlur != null) {
    var textContent = el.getTextContent();

    if (txConOptNormal === false) {
      textContent && el.removeTextContent();
    } else {
      txConOptNormal = attachedTxInfo.normal.conOpt = txConOptNormal || {
        type: 'text'
      };

      if (!textContent) {
        textContent = createEl(txConOptNormal);
        el.setTextContent(textContent);
      } else {
        // If in some case the performance issue arised, consider
        // do not clearState but update cached normal state directly.
        textContent.clearStates();
      }

      var txConStlOptNormal = txConOptNormal && txConOptNormal.style;
      updateElNormal(null, textContent, null, dataIndex, txConOptNormal, txConStlOptNormal, null, seriesModel, isInit, true);

      for (var i = 0; i < STATES.length; i++) {
        var stateName = STATES[i];

        if (stateName !== NORMAL) {
          var txConOptOtherState = attachedTxInfo[stateName].conOpt;
          updateElOnState(stateName, textContent, txConOptOtherState, retrieveStyleOptionOnState(txConOptNormal, txConOptOtherState, stateName), null, false, true);
        }
      }

      txConStlOptNormal ? textContent.dirty() : textContent.markRedraw();
    }
  }
}

function processTxInfo(elOption, state, attachedTxInfo) {
  var stateOpt = !state ? elOption : retrieveStateOption(elOption, state);
  var styleOpt = !state ? elOption.style : retrieveStyleOptionOnState(elOption, stateOpt, EMPHASIS);
  var elType = elOption.type;
  var txCfg = stateOpt ? stateOpt.textConfig : null;
  var txConOptNormal = elOption.textContent;
  var txConOpt = !txConOptNormal ? null : !state ? txConOptNormal : retrieveStateOption(txConOptNormal, state);

  if (styleOpt && ( // Because emphasis style has little info to detect legacy,
  // if normal is legacy, emphasis is trade as legacy.
  attachedTxInfo.isLegacy || (0,_util_styleCompat__WEBPACK_IMPORTED_MODULE_23__.isEC4CompatibleStyle)(styleOpt, elType, !!txCfg, !!txConOpt))) {
    attachedTxInfo.isLegacy = true;
    var convertResult = (0,_util_styleCompat__WEBPACK_IMPORTED_MODULE_23__.convertFromEC4CompatibleStyle)(styleOpt, elType, !state); // Explicitly specified `textConfig` and `textContent` has higher priority than
    // the ones generated by legacy style. Otherwise if users use them and `api.style`
    // at the same time, they not both work and hardly to known why.

    if (!txCfg && convertResult.textConfig) {
      txCfg = convertResult.textConfig;
    }

    if (!txConOpt && convertResult.textContent) {
      txConOpt = convertResult.textContent;
    }
  }

  if (!state && txConOpt) {
    var txConOptNormal_1 = txConOpt; // `textContent: {type: 'text'}`, the "type" is easy to be missing. So we tolerate it.

    !txConOptNormal_1.type && (txConOptNormal_1.type = 'text');

    if (true) {
      // Do not tolerate incorret type for forward compat.
      txConOptNormal_1.type !== 'text' && (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)(txConOptNormal_1.type === 'text', 'textContent.type must be "text"');
    }
  }

  var info = !state ? attachedTxInfo.normal : attachedTxInfo[state];
  info.cfg = txCfg;
  info.conOpt = txConOpt;
}

function retrieveStateOption(elOption, state) {
  return !state ? elOption : elOption ? elOption[state] : null;
}

function retrieveStyleOptionOnState(stateOptionNormal, stateOption, state) {
  var style = stateOption && stateOption.style;

  if (style == null && state === EMPHASIS && stateOptionNormal) {
    style = stateOptionNormal.styleEmphasis;
  }

  return style;
} // Usage:
// (1) By default, `elOption.$mergeChildren` is `'byIndex'`, which indicates that
//     the existing children will not be removed, and enables the feature that
//     update some of the props of some of the children simply by construct
//     the returned children of `renderItem` like:
//     `var children = group.children = []; children[3] = {opacity: 0.5};`
// (2) If `elOption.$mergeChildren` is `'byName'`, add/update/remove children
//     by child.name. But that might be lower performance.
// (3) If `elOption.$mergeChildren` is `false`, the existing children will be
//     replaced totally.
// (4) If `!elOption.children`, following the "merge" principle, nothing will happen.
//
// For implementation simpleness, do not provide a direct way to remove sinlge
// child (otherwise the total indicies of the children array have to be modified).
// User can remove a single child by set its `ignore` as `true`.


function mergeChildren(api, el, dataIndex, elOption, seriesModel, morphPreparation) {
  var newChildren = elOption.children;
  var newLen = newChildren ? newChildren.length : 0;
  var mergeChildren = elOption.$mergeChildren; // `diffChildrenByName` has been deprecated.

  var byName = mergeChildren === 'byName' || elOption.diffChildrenByName;
  var notMerge = mergeChildren === false; // For better performance on roam update, only enter if necessary.

  if (!newLen && !byName && !notMerge) {
    return;
  }

  if (byName) {
    diffGroupChildren({
      api: api,
      oldChildren: el.children() || [],
      newChildren: newChildren || [],
      dataIndex: dataIndex,
      seriesModel: seriesModel,
      group: el,
      morphPreparation: morphPreparation
    });
    return;
  }

  notMerge && el.removeAll(); // Mapping children of a group simply by index, which
  // might be better performance.

  var index = 0;

  for (; index < newLen; index++) {
    newChildren[index] && doCreateOrUpdateEl(api, el.childAt(index), dataIndex, newChildren[index], seriesModel, el, false, morphPreparation);
  }

  for (var i = el.childCount() - 1; i >= index; i--) {
    // Do not supprot leave elements that are not mentioned in the latest
    // `renderItem` return. Otherwise users may not have a clear and simple
    // concept that how to contorl all of the elements.
    doRemoveEl(el.childAt(i), seriesModel, el);
  }
}

function diffGroupChildren(context) {
  new _data_DataDiffer__WEBPACK_IMPORTED_MODULE_11__.default(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
}

function getKey(item, idx) {
  var name = item && item.name;
  return name != null ? name : GROUP_DIFF_PREFIX + idx;
}

function processAddUpdate(newIndex, oldIndex) {
  var context = this.context;
  var childOption = newIndex != null ? context.newChildren[newIndex] : null;
  var child = oldIndex != null ? context.oldChildren[oldIndex] : null;
  doCreateOrUpdateEl(context.api, child, context.dataIndex, childOption, context.seriesModel, context.group, false, context.morphPreparation);
}

function processRemove(oldIndex) {
  var context = this.context;
  var child = context.oldChildren[oldIndex];
  doRemoveEl(child, context.seriesModel, context.group);
}

function doRemoveEl(el, seriesModel, group) {
  if (el) {
    var leaveToProps = inner(el).leaveToProps;
    leaveToProps ? _util_graphic__WEBPACK_IMPORTED_MODULE_15__.updateProps(el, leaveToProps, seriesModel, {
      cb: function () {
        group.remove(el);
      }
    }) : group.remove(el);
  }
}
/**
 * @return SVG Path data.
 */


function getPathData(shape) {
  // "d" follows the SVG convention.
  return shape && (shape.pathData || shape.d);
}

function hasOwnPathData(shape) {
  return shape && ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(shape, 'pathData') || (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(shape, 'd'));
}

function isPath(el) {
  return el && el instanceof _util_graphic__WEBPACK_IMPORTED_MODULE_27__.default;
}

function removeElementDirectly(el, group) {
  el && group.remove(el);
}
/**
 * Any morph-potential el should added by `morphPreparation.addTo(el)`.
 * And they may apply morph or not when `morphPreparation.applyMorphing()`.
 * But at least, all of the "to" elements will apply all of the updates
 * as `doCreateOrUpdateItem` did.
 */


var MorphPreparation =
/** @class */
function () {
  function MorphPreparation(seriesModel, transOpt) {
    this._fromList = [];
    this._toList = [];
    this._toElOptionList = [];
    this._allPropsFinalList = [];
    this._toDataIndices = []; // Key: `toDataIndex`, not `toIdx`

    this._morphConfigList = [];
    this._seriesModel = seriesModel;
    this._transOpt = transOpt;
  }

  MorphPreparation.prototype.hasFrom = function () {
    return !!this._fromList.length;
  }; // isOneToOneFrom(el: Element): boolean {
  //     if (el && inner(el).canMorph) {
  //         const fromList = this._fromList;
  //         for (let i = 0; i < fromList.length; i++) {
  //             if (fromList[i] === el) {
  //                 return true;
  //             }
  //         }
  //     }
  // }


  MorphPreparation.prototype.findAndAddFrom = function (el) {
    if (!el) {
      return;
    }

    if (inner(el).canMorph) {
      this._fromList.push(el);
    }

    if (el.isGroup) {
      var children = el.childrenRef();

      for (var i = 0; i < children.length; i++) {
        this.findAndAddFrom(children[i]);
      }
    }
  };

  MorphPreparation.prototype.addTo = function (path, elOption, dataIndex, allPropsFinal) {
    if (path) {
      this._toList.push(path);

      this._toElOptionList.push(elOption);

      this._toDataIndices.push(dataIndex);

      this._allPropsFinalList.push(allPropsFinal);
    }
  };

  MorphPreparation.prototype.applyMorphing = function () {
    // [MORPHING_LOGIC_HINT]
    // Pay attention to the order:
    // (A) Apply `allPropsFinal` and `styleOption` to "to".
    //     (Then "to" becomes to the final state.)
    // (B) Apply `morphPath`/`combine`/`separate`.
    //     (Based on the current state of "from" and the final state of "to".)
    //     (Then we may get "from.subList" or "to.subList".)
    // (C) Copy the related props from "from" to "from.subList", from "to" to "to.subList".
    // (D) Collect `transitionFromProps` for "to" and "to.subList"
    //     (Based on "from" or "from.subList".)
    // (E) Apply `transitionFromProps` to "to" and "to.subList"
    //     (It might change the prop values to the first frame value.)
    // Case_I:
    //     If (D) should be after (C), we use sequence: A - B - C - D - E
    // Case_II:
    //     If (A) should be after (D), we use sequence: D - A - B - C - E
    // [MORPHING_LOGIC_HINT]
    // zrender `morphPath`/`combine`/`separate` only manages the shape animation.
    // Other props (like transfrom, style transition) will handled in echarts).
    // [MORPHING_LOGIC_HINT]
    // Make sure `applyPropsFinal` always be called for "to".
    var type = this._type;
    var fromList = this._fromList;
    var toList = this._toList;
    var toListLen = toList.length;
    var fromListLen = fromList.length;

    if (!fromListLen || !toListLen) {
      return;
    }

    if (type === 'oneToOne') {
      // In one-to-one case, we by default apply a simple rule:
      // map "from" and "to" one by one.
      // For this case: old_data_item_el and new_data_item_el
      // has the same hierarchy of group tree but only some path type changed.
      for (var toIdx = 0; toIdx < toListLen; toIdx++) {
        this._oneToOneForSingleTo(toIdx, toIdx);
      }
    } else if (type === 'manyToOne') {
      // A rough strategy: if there are more than one "to", we simply divide "fromList" equally.
      var fromSingleSegLen = Math.max(1, Math.floor(fromListLen / toListLen));

      for (var toIdx = 0, fromIdxStart = 0; toIdx < toListLen; toIdx++, fromIdxStart += fromSingleSegLen) {
        var fromCount = toIdx + 1 >= toListLen ? fromListLen - fromIdxStart : fromSingleSegLen;

        this._manyToOneForSingleTo(toIdx, fromIdxStart >= fromListLen ? null : fromIdxStart, fromCount);
      }
    } else if (type === 'oneToMany') {
      // A rough strategy: if there are more than one "from", we simply divide "toList" equally.
      var toSingleSegLen = Math.max(1, Math.floor(toListLen / fromListLen));

      for (var toIdxStart = 0, fromIdx = 0; toIdxStart < toListLen; toIdxStart += toSingleSegLen, fromIdx++) {
        var toCount = toIdxStart + toSingleSegLen >= toListLen ? toListLen - toIdxStart : toSingleSegLen;

        this._oneToManyForSingleFrom(toIdxStart, toCount, fromIdx >= fromListLen ? null : fromIdx);
      }
    }
  };

  MorphPreparation.prototype._oneToOneForSingleTo = function ( // "to" must NOT be null/undefined.
  toIdx, // May `fromIdx >= this._fromList.length`
  fromIdx) {
    var to = this._toList[toIdx];
    var toElOption = this._toElOptionList[toIdx];
    var toDataIndex = this._toDataIndices[toIdx];
    var allPropsFinal = this._allPropsFinalList[toIdx];
    var from = this._fromList[fromIdx];

    var elAnimationConfig = this._getOrCreateMorphConfig(toDataIndex);

    var morphDuration = elAnimationConfig.duration;

    if (from && (0,zrender_lib_tool_morphPath__WEBPACK_IMPORTED_MODULE_28__.isCombiningPath)(from)) {
      applyPropsFinal(to, allPropsFinal, toElOption.style);

      if (morphDuration) {
        var combineResult = (0,zrender_lib_tool_morphPath__WEBPACK_IMPORTED_MODULE_28__.combine)([from], to, elAnimationConfig, copyPropsWhenDivided);

        this._processResultIndividuals(combineResult, toIdx, null);
      } // The target el will not be displayed and transition from multiple path.
      // transition on the target el does not make sense.

    } else {
      var morphFrom = morphDuration // from === to usually happen in scenarios where internal update like
      // "dataZoom", "legendToggle" happen. If from is not in any morphing,
      // we do not need to call `morphPath`.
      && from && (from !== to || (0,zrender_lib_tool_morphPath__WEBPACK_IMPORTED_MODULE_28__.isInAnyMorphing)(from)) ? from : null; // See [Case_II] above.
      // In this case, there is probably `from === to`. And the `transitionFromProps` collecting
      // does not depends on morphing. So we collect `transitionFromProps` first.

      var transFromProps = {};
      prepareShapeOrExtraTransitionFrom('shape', to, morphFrom, toElOption, transFromProps, false);
      prepareShapeOrExtraTransitionFrom('extra', to, morphFrom, toElOption, transFromProps, false);
      prepareTransformTransitionFrom(to, morphFrom, toElOption, transFromProps, false);
      prepareStyleTransitionFrom(to, morphFrom, toElOption, toElOption.style, transFromProps, false);
      applyPropsFinal(to, allPropsFinal, toElOption.style);

      if (morphFrom) {
        (0,zrender_lib_tool_morphPath__WEBPACK_IMPORTED_MODULE_28__.morphPath)(morphFrom, to, elAnimationConfig);
      }

      applyTransitionFrom(to, toDataIndex, toElOption, this._seriesModel, transFromProps, false);
    }
  };

  MorphPreparation.prototype._manyToOneForSingleTo = function ( // "to" must NOT be null/undefined.
  toIdx, // May be null.
  fromIdxStart, fromCount) {
    var to = this._toList[toIdx];
    var toElOption = this._toElOptionList[toIdx];
    var allPropsFinal = this._allPropsFinalList[toIdx];
    applyPropsFinal(to, allPropsFinal, toElOption.style);

    var elAnimationConfig = this._getOrCreateMorphConfig(this._toDataIndices[toIdx]);

    if (elAnimationConfig.duration && fromIdxStart != null) {
      var combineFromList = [];

      for (var fromIdx = fromIdxStart; fromIdx < fromCount; fromIdx++) {
        combineFromList.push(this._fromList[fromIdx]);
      }

      var combineResult = (0,zrender_lib_tool_morphPath__WEBPACK_IMPORTED_MODULE_28__.combine)(combineFromList, to, elAnimationConfig, copyPropsWhenDivided);

      this._processResultIndividuals(combineResult, toIdx, null);
    }
  };

  MorphPreparation.prototype._oneToManyForSingleFrom = function ( // "to" must NOT be null/undefined.
  toIdxStart, toCount, // May be null
  fromIdx) {
    var from = fromIdx == null ? null : this._fromList[fromIdx];
    var toList = this._toList;
    var separateToList = [];

    for (var toIdx = toIdxStart; toIdx < toCount; toIdx++) {
      var to = toList[toIdx];
      applyPropsFinal(to, this._allPropsFinalList[toIdx], this._toElOptionList[toIdx].style);
      separateToList.push(to);
    }

    var elAnimationConfig = this._getOrCreateMorphConfig(this._toDataIndices[toIdxStart]);

    if (elAnimationConfig.duration && from) {
      var separateResult = (0,zrender_lib_tool_morphPath__WEBPACK_IMPORTED_MODULE_28__.separate)(from, separateToList, elAnimationConfig, copyPropsWhenDivided);

      this._processResultIndividuals(separateResult, toIdxStart, toCount);
    }
  };

  MorphPreparation.prototype._processResultIndividuals = function (combineSeparateResult, toIdxStart, toCount) {
    var isSeparate = toCount != null;

    for (var i = 0; i < combineSeparateResult.count; i++) {
      var fromIndividual = combineSeparateResult.fromIndividuals[i];
      var toIndividual = combineSeparateResult.toIndividuals[i]; // Here it's a trick:
      // For "combine" case, all of the `toIndividuals` map to the same `toIdx`.
      // For "separate" case, the `toIndividuals` map to some certain segment of `_toList` accurately.

      var toIdx = toIdxStart + (isSeparate ? i : 0);
      var toElOption = this._toElOptionList[toIdx];
      var dataIndex = this._toDataIndices[toIdx];
      var transFromProps = {};
      prepareTransformTransitionFrom(toIndividual, fromIndividual, toElOption, transFromProps, false);
      prepareStyleTransitionFrom(toIndividual, fromIndividual, toElOption, toElOption.style, transFromProps, false);
      applyTransitionFrom(toIndividual, dataIndex, toElOption, this._seriesModel, transFromProps, false);
    }
  };

  MorphPreparation.prototype._getOrCreateMorphConfig = function (dataIndex) {
    var morphConfigList = this._morphConfigList;
    var config = morphConfigList[dataIndex];

    if (config) {
      return config;
    }

    var duration;
    var easing;
    var delay;
    var seriesModel = this._seriesModel;
    var transOpt = this._transOpt;

    if (seriesModel.isAnimationEnabled()) {
      // PENDING: refactor? this is the same logic as `src/util/graphic.ts#animateOrSetProps`.
      var animationPayload = void 0;

      if (seriesModel && seriesModel.ecModel) {
        var updatePayload = seriesModel.ecModel.getUpdatePayload();
        animationPayload = updatePayload && updatePayload.animation;
      }

      if (animationPayload) {
        duration = animationPayload.duration || 0;
        easing = animationPayload.easing || 'cubicOut';
        delay = animationPayload.delay || 0;
      } else {
        easing = seriesModel.get('animationEasingUpdate');
        var delayOption = seriesModel.get('animationDelayUpdate');
        delay = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(delayOption) ? delayOption(dataIndex) : delayOption;
        var durationOption = seriesModel.get('animationDurationUpdate');
        duration = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(durationOption) ? durationOption(dataIndex) : durationOption;
      }
    }

    config = {
      duration: duration || 0,
      delay: delay,
      easing: easing,
      dividingMethod: transOpt ? transOpt.dividingMethod : null
    };
    morphConfigList[dataIndex] = config;
    return config;
  };

  MorphPreparation.prototype.reset = function (type) {
    // `this._morphConfigList` can be kept. It only related to `dataIndex`.
    this._type = type;
    this._fromList.length = this._toList.length = this._toElOptionList.length = this._allPropsFinalList.length = this._toDataIndices.length = 0;
  };

  return MorphPreparation;
}();

function copyPropsWhenDivided(srcPath, tarPath, willClone) {
  // Do not copy transform props.
  // Sub paths are transfrom based on their host path.
  // tarPath.x = srcPath.x;
  // tarPath.y = srcPath.y;
  // tarPath.scaleX = srcPath.scaleX;
  // tarPath.scaleY = srcPath.scaleY;
  // tarPath.originX = srcPath.originX;
  // tarPath.originY = srcPath.originY;
  // If just carry the style, will not be modifed, so do not copy.
  tarPath.style = willClone ? (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone)(srcPath.style) : srcPath.style;
  tarPath.zlevel = srcPath.zlevel;
  tarPath.z = srcPath.z;
  tarPath.z2 = srcPath.z2;
}

function install(registers) {
  registers.registerChartView(CustomSeriesView);
  registers.registerSeriesModel(CustomSeriesModel);
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/effectScatter/EffectScatterSeries.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/effectScatter/EffectScatterSeries.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _helper_createListFromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/createListFromArray */ "./node_modules/echarts/lib/chart/helper/createListFromArray.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var EffectScatterSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(EffectScatterSeriesModel, _super);

  function EffectScatterSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = EffectScatterSeriesModel.type;
    _this.hasSymbolVisual = true;
    return _this;
  }

  EffectScatterSeriesModel.prototype.getInitialData = function (option, ecModel) {
    return (0,_helper_createListFromArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.getSource(), this, {
      useEncodeDefaulter: true
    });
  };

  EffectScatterSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {
    return selectors.point(data.getItemLayout(dataIndex));
  };

  EffectScatterSeriesModel.type = 'series.effectScatter';
  EffectScatterSeriesModel.dependencies = ['grid', 'polar'];
  EffectScatterSeriesModel.defaultOption = {
    coordinateSystem: 'cartesian2d',
    zlevel: 0,
    z: 2,
    legendHoverLink: true,
    effectType: 'ripple',
    progressive: 0,
    // When to show the effect, option: 'render'|'emphasis'
    showEffectOn: 'render',
    // Ripple effect config
    rippleEffect: {
      period: 4,
      // Scale of ripple
      scale: 2.5,
      // Brush type can be fill or stroke
      brushType: 'fill'
    },
    // Cartesian coordinate system
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    // Polar coordinate system
    // polarIndex: 0,
    // Geo coordinate system
    // geoIndex: 0,
    // symbol: null,        // 图形类型
    symbolSize: 10 // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
    // symbolRotate: null,  // 图形旋转控制
    // itemStyle: {
    //     opacity: 1
    // }

  };
  return EffectScatterSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_2__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EffectScatterSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/effectScatter/EffectScatterView.js":
/*!***************************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/effectScatter/EffectScatterView.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _helper_SymbolDraw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/SymbolDraw */ "./node_modules/echarts/lib/chart/helper/SymbolDraw.js");
/* harmony import */ var _helper_EffectSymbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helper/EffectSymbol */ "./node_modules/echarts/lib/chart/helper/EffectSymbol.js");
/* harmony import */ var zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/matrix */ "./node_modules/zrender/lib/core/matrix.js");
/* harmony import */ var _layout_points__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../layout/points */ "./node_modules/echarts/lib/layout/points.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







var EffectScatterView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(EffectScatterView, _super);

  function EffectScatterView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = EffectScatterView.type;
    return _this;
  }

  EffectScatterView.prototype.init = function () {
    this._symbolDraw = new _helper_SymbolDraw__WEBPACK_IMPORTED_MODULE_1__.default(_helper_EffectSymbol__WEBPACK_IMPORTED_MODULE_2__.default);
  };

  EffectScatterView.prototype.render = function (seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var effectSymbolDraw = this._symbolDraw;
    effectSymbolDraw.updateData(data);
    this.group.add(effectSymbolDraw.group);
  };

  EffectScatterView.prototype.updateTransform = function (seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    this.group.dirty();
    var res = (0,_layout_points__WEBPACK_IMPORTED_MODULE_3__.default)('').reset(seriesModel, ecModel, api);

    if (res.progress) {
      res.progress({
        start: 0,
        end: data.count(),
        count: data.count()
      }, data);
    }

    this._symbolDraw.updateLayout();
  };

  EffectScatterView.prototype._updateGroupTransform = function (seriesModel) {
    var coordSys = seriesModel.coordinateSystem;

    if (coordSys && coordSys.getRoamTransform) {
      this.group.transform = zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_4__.clone(coordSys.getRoamTransform());
      this.group.decomposeTransform();
    }
  };

  EffectScatterView.prototype.remove = function (ecModel, api) {
    this._symbolDraw && this._symbolDraw.remove(true);
  };

  EffectScatterView.type = 'effectScatter';
  return EffectScatterView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_5__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EffectScatterView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/effectScatter/install.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/effectScatter/install.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _EffectScatterView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EffectScatterView */ "./node_modules/echarts/lib/chart/effectScatter/EffectScatterView.js");
/* harmony import */ var _EffectScatterSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EffectScatterSeries */ "./node_modules/echarts/lib/chart/effectScatter/EffectScatterSeries.js");
/* harmony import */ var _layout_points__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../layout/points */ "./node_modules/echarts/lib/layout/points.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function install(registers) {
  registers.registerChartView(_EffectScatterView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerSeriesModel(_EffectScatterSeries__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerLayout((0,_layout_points__WEBPACK_IMPORTED_MODULE_2__.default)('effectScatter'));
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/funnel/FunnelSeries.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/funnel/FunnelSeries.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _helper_createListSimply__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helper/createListSimply */ "./node_modules/echarts/lib/chart/helper/createListSimply.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _data_helper_sourceHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../data/helper/sourceHelper */ "./node_modules/echarts/lib/data/helper/sourceHelper.js");
/* harmony import */ var _visual_LegendVisualProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../visual/LegendVisualProvider */ "./node_modules/echarts/lib/visual/LegendVisualProvider.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








var FunnelSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(FunnelSeriesModel, _super);

  function FunnelSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = FunnelSeriesModel.type;
    _this.useColorPaletteOnData = true;
    return _this;
  }

  FunnelSeriesModel.prototype.init = function (option) {
    _super.prototype.init.apply(this, arguments); // Enable legend selection for each data item
    // Use a function instead of direct access because data reference may changed


    this.legendVisualProvider = new _visual_LegendVisualProvider__WEBPACK_IMPORTED_MODULE_1__.default(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind(this.getData, this), zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind(this.getRawData, this)); // Extend labelLine emphasis

    this._defaultLabelLine(option);
  };

  FunnelSeriesModel.prototype.getInitialData = function (option, ecModel) {
    return (0,_helper_createListSimply__WEBPACK_IMPORTED_MODULE_3__.default)(this, {
      coordDimensions: ['value'],
      encodeDefaulter: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.curry(_data_helper_sourceHelper__WEBPACK_IMPORTED_MODULE_4__.makeSeriesEncodeForNameBased, this)
    });
  };

  FunnelSeriesModel.prototype._defaultLabelLine = function (option) {
    // Extend labelLine emphasis
    (0,_util_model__WEBPACK_IMPORTED_MODULE_5__.defaultEmphasis)(option, 'labelLine', ['show']);
    var labelLineNormalOpt = option.labelLine;
    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`

    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
  }; // Overwrite


  FunnelSeriesModel.prototype.getDataParams = function (dataIndex) {
    var data = this.getData();

    var params = _super.prototype.getDataParams.call(this, dataIndex);

    var valueDim = data.mapDimension('value');
    var sum = data.getSum(valueDim); // Percent is 0 if sum is 0

    params.percent = !sum ? 0 : +(data.get(valueDim, dataIndex) / sum * 100).toFixed(2);
    params.$vars.push('percent');
    return params;
  };

  FunnelSeriesModel.type = 'series.funnel';
  FunnelSeriesModel.defaultOption = {
    zlevel: 0,
    z: 2,
    legendHoverLink: true,
    left: 80,
    top: 60,
    right: 80,
    bottom: 60,
    // width: {totalWidth} - left - right,
    // height: {totalHeight} - top - bottom,
    // 默认取数据最小最大值
    // min: 0,
    // max: 100,
    minSize: '0%',
    maxSize: '100%',
    sort: 'descending',
    orient: 'vertical',
    gap: 0,
    funnelAlign: 'center',
    label: {
      show: true,
      position: 'outer' // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调

    },
    labelLine: {
      show: true,
      length: 20,
      lineStyle: {
        // color: 各异,
        width: 1
      }
    },
    itemStyle: {
      // color: 各异,
      borderColor: '#fff',
      borderWidth: 1
    },
    emphasis: {
      label: {
        show: true
      }
    },
    select: {
      itemStyle: {
        borderColor: '#212121'
      }
    }
  };
  return FunnelSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_6__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FunnelSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/funnel/FunnelView.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/funnel/FunnelView.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polyline.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/core/Point.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polygon.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _label_labelGuideHelper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../label/labelGuideHelper */ "./node_modules/echarts/lib/label/labelGuideHelper.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var opacityAccessPath = ['itemStyle', 'opacity'];
/**
 * Piece of pie including Sector, Label, LabelLine
 */

var FunnelPiece =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(FunnelPiece, _super);

  function FunnelPiece(data, idx) {
    var _this = _super.call(this) || this;

    var polygon = _this;
    var labelLine = new _util_graphic__WEBPACK_IMPORTED_MODULE_1__.default();
    var text = new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default();
    polygon.setTextContent(text);

    _this.setTextGuideLine(labelLine);

    _this.updateData(data, idx, true);

    return _this;
  }

  FunnelPiece.prototype.updateData = function (data, idx, firstCreate) {
    var polygon = this;
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout = data.getItemLayout(idx);
    var emphasisModel = itemModel.getModel('emphasis');
    var opacity = itemModel.get(opacityAccessPath);
    opacity = opacity == null ? 1 : opacity; // Update common style

    polygon.useStyle(data.getItemVisual(idx, 'style'));
    polygon.style.lineJoin = 'round';

    if (firstCreate) {
      polygon.setShape({
        points: layout.points
      });
      polygon.style.opacity = 0;
      _util_graphic__WEBPACK_IMPORTED_MODULE_3__.initProps(polygon, {
        style: {
          opacity: opacity
        }
      }, seriesModel, idx);
    } else {
      _util_graphic__WEBPACK_IMPORTED_MODULE_3__.updateProps(polygon, {
        style: {
          opacity: opacity
        },
        shape: {
          points: layout.points
        }
      }, seriesModel, idx);
    }

    (0,_util_states__WEBPACK_IMPORTED_MODULE_4__.setStatesStylesFromModel)(polygon, itemModel);

    this._updateLabel(data, idx);

    (0,_util_states__WEBPACK_IMPORTED_MODULE_4__.enableHoverEmphasis)(this, emphasisModel.get('focus'), emphasisModel.get('blurScope'));
  };

  FunnelPiece.prototype._updateLabel = function (data, idx) {
    var polygon = this;
    var labelLine = this.getTextGuideLine();
    var labelText = polygon.getTextContent();
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout = data.getItemLayout(idx);
    var labelLayout = layout.label;
    var style = data.getItemVisual(idx, 'style');
    var visualColor = style.fill;
    (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_5__.setLabelStyle)( // position will not be used in setLabelStyle
    labelText, (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_5__.getLabelStatesModels)(itemModel), {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      defaultOpacity: style.opacity,
      defaultText: data.getName(idx)
    }, {
      normal: {
        align: labelLayout.textAlign,
        verticalAlign: labelLayout.verticalAlign
      }
    });
    polygon.setTextConfig({
      local: true,
      inside: !!labelLayout.inside,
      insideStroke: visualColor,
      // insideFill: 'auto',
      outsideFill: visualColor
    });
    var linePoints = labelLayout.linePoints;
    labelLine.setShape({
      points: linePoints
    });
    polygon.textGuideLineConfig = {
      anchor: linePoints ? new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default(linePoints[0][0], linePoints[0][1]) : null
    }; // Make sure update style on labelText after setLabelStyle.
    // Because setLabelStyle will replace a new style on it.

    _util_graphic__WEBPACK_IMPORTED_MODULE_3__.updateProps(labelText, {
      style: {
        x: labelLayout.x,
        y: labelLayout.y
      }
    }, seriesModel, idx);
    labelText.attr({
      rotation: labelLayout.rotation,
      originX: labelLayout.x,
      originY: labelLayout.y,
      z2: 10
    });
    (0,_label_labelGuideHelper__WEBPACK_IMPORTED_MODULE_7__.setLabelLineStyle)(polygon, (0,_label_labelGuideHelper__WEBPACK_IMPORTED_MODULE_7__.getLabelLineStatesModels)(itemModel), {
      // Default use item visual color
      stroke: visualColor
    });
  };

  return FunnelPiece;
}(_util_graphic__WEBPACK_IMPORTED_MODULE_8__.default);

var FunnelView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(FunnelView, _super);

  function FunnelView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = FunnelView.type;
    _this.ignoreLabelLineUpdate = true;
    return _this;
  }

  FunnelView.prototype.render = function (seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var oldData = this._data;
    var group = this.group;
    data.diff(oldData).add(function (idx) {
      var funnelPiece = new FunnelPiece(data, idx);
      data.setItemGraphicEl(idx, funnelPiece);
      group.add(funnelPiece);
    }).update(function (newIdx, oldIdx) {
      var piece = oldData.getItemGraphicEl(oldIdx);
      piece.updateData(data, newIdx);
      group.add(piece);
      data.setItemGraphicEl(newIdx, piece);
    }).remove(function (idx) {
      var piece = oldData.getItemGraphicEl(idx);
      _util_graphic__WEBPACK_IMPORTED_MODULE_3__.removeElementWithFadeOut(piece, seriesModel, idx);
    }).execute();
    this._data = data;
  };

  FunnelView.prototype.remove = function () {
    this.group.removeAll();
    this._data = null;
  };

  FunnelView.prototype.dispose = function () {};

  FunnelView.type = 'funnel';
  return FunnelView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_9__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FunnelView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/funnel/funnelLayout.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/funnel/funnelLayout.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ funnelLayout)
/* harmony export */ });
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function getViewRect(seriesModel, api) {
  return _util_layout__WEBPACK_IMPORTED_MODULE_0__.getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}

function getSortedIndices(data, sort) {
  var valueDim = data.mapDimension('value');
  var valueArr = data.mapArray(valueDim, function (val) {
    return val;
  });
  var indices = [];
  var isAscending = sort === 'ascending';

  for (var i = 0, len = data.count(); i < len; i++) {
    indices[i] = i;
  } // Add custom sortable function & none sortable opetion by "options.sort"


  if (typeof sort === 'function') {
    indices.sort(sort);
  } else if (sort !== 'none') {
    indices.sort(function (a, b) {
      return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];
    });
  }

  return indices;
}

function labelLayout(data) {
  var seriesModel = data.hostModel;
  var orient = seriesModel.get('orient');
  data.each(function (idx) {
    var itemModel = data.getItemModel(idx);
    var labelModel = itemModel.getModel('label');
    var labelPosition = labelModel.get('position');
    var labelLineModel = itemModel.getModel('labelLine');
    var layout = data.getItemLayout(idx);
    var points = layout.points;
    var isLabelInside = labelPosition === 'inner' || labelPosition === 'inside' || labelPosition === 'center' || labelPosition === 'insideLeft' || labelPosition === 'insideRight';
    var textAlign;
    var textX;
    var textY;
    var linePoints;

    if (isLabelInside) {
      if (labelPosition === 'insideLeft') {
        textX = (points[0][0] + points[3][0]) / 2 + 5;
        textY = (points[0][1] + points[3][1]) / 2;
        textAlign = 'left';
      } else if (labelPosition === 'insideRight') {
        textX = (points[1][0] + points[2][0]) / 2 - 5;
        textY = (points[1][1] + points[2][1]) / 2;
        textAlign = 'right';
      } else {
        textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;
        textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;
        textAlign = 'center';
      }

      linePoints = [[textX, textY], [textX, textY]];
    } else {
      var x1 = void 0;
      var y1 = void 0;
      var x2 = void 0;
      var y2 = void 0;
      var labelLineLen = labelLineModel.get('length');

      if (true) {
        if (orient === 'vertical' && ['top', 'bottom'].indexOf(labelPosition) > -1) {
          labelPosition = 'left';
          console.warn('Position error: Funnel chart on vertical orient dose not support top and bottom.');
        }

        if (orient === 'horizontal' && ['left', 'right'].indexOf(labelPosition) > -1) {
          labelPosition = 'bottom';
          console.warn('Position error: Funnel chart on horizontal orient dose not support left and right.');
        }
      }

      if (labelPosition === 'left') {
        // Left side
        x1 = (points[3][0] + points[0][0]) / 2;
        y1 = (points[3][1] + points[0][1]) / 2;
        x2 = x1 - labelLineLen;
        textX = x2 - 5;
        textAlign = 'right';
      } else if (labelPosition === 'right') {
        // Right side
        x1 = (points[1][0] + points[2][0]) / 2;
        y1 = (points[1][1] + points[2][1]) / 2;
        x2 = x1 + labelLineLen;
        textX = x2 + 5;
        textAlign = 'left';
      } else if (labelPosition === 'top') {
        // Top side
        x1 = (points[3][0] + points[0][0]) / 2;
        y1 = (points[3][1] + points[0][1]) / 2;
        y2 = y1 - labelLineLen;
        textY = y2 - 5;
        textAlign = 'center';
      } else if (labelPosition === 'bottom') {
        // Bottom side
        x1 = (points[1][0] + points[2][0]) / 2;
        y1 = (points[1][1] + points[2][1]) / 2;
        y2 = y1 + labelLineLen;
        textY = y2 + 5;
        textAlign = 'center';
      } else if (labelPosition === 'rightTop') {
        // RightTop side
        x1 = orient === 'horizontal' ? points[3][0] : points[1][0];
        y1 = orient === 'horizontal' ? points[3][1] : points[1][1];

        if (orient === 'horizontal') {
          y2 = y1 - labelLineLen;
          textY = y2 - 5;
          textAlign = 'center';
        } else {
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = 'top';
        }
      } else if (labelPosition === 'rightBottom') {
        // RightBottom side
        x1 = points[2][0];
        y1 = points[2][1];

        if (orient === 'horizontal') {
          y2 = y1 + labelLineLen;
          textY = y2 + 5;
          textAlign = 'center';
        } else {
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = 'bottom';
        }
      } else if (labelPosition === 'leftTop') {
        // LeftTop side
        x1 = points[0][0];
        y1 = orient === 'horizontal' ? points[0][1] : points[1][1];

        if (orient === 'horizontal') {
          y2 = y1 - labelLineLen;
          textY = y2 - 5;
          textAlign = 'center';
        } else {
          x2 = x1 - labelLineLen;
          textX = x2 - 5;
          textAlign = 'right';
        }
      } else if (labelPosition === 'leftBottom') {
        // LeftBottom side
        x1 = orient === 'horizontal' ? points[1][0] : points[3][0];
        y1 = orient === 'horizontal' ? points[1][1] : points[2][1];

        if (orient === 'horizontal') {
          y2 = y1 + labelLineLen;
          textY = y2 + 5;
          textAlign = 'center';
        } else {
          x2 = x1 - labelLineLen;
          textX = x2 - 5;
          textAlign = 'right';
        }
      } else {
        // Right side or Bottom side
        x1 = (points[1][0] + points[2][0]) / 2;
        y1 = (points[1][1] + points[2][1]) / 2;

        if (orient === 'horizontal') {
          y2 = y1 + labelLineLen;
          textY = y2 + 5;
          textAlign = 'center';
        } else {
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = 'left';
        }
      }

      if (orient === 'horizontal') {
        x2 = x1;
        textX = x2;
      } else {
        y2 = y1;
        textY = y2;
      }

      linePoints = [[x1, y1], [x2, y2]];
    }

    layout.label = {
      linePoints: linePoints,
      x: textX,
      y: textY,
      verticalAlign: 'middle',
      textAlign: textAlign,
      inside: isLabelInside
    };
  });
}

function funnelLayout(ecModel, api) {
  ecModel.eachSeriesByType('funnel', function (seriesModel) {
    var data = seriesModel.getData();
    var valueDim = data.mapDimension('value');
    var sort = seriesModel.get('sort');
    var viewRect = getViewRect(seriesModel, api);
    var orient = seriesModel.get('orient');
    var viewWidth = viewRect.width;
    var viewHeight = viewRect.height;
    var indices = getSortedIndices(data, sort);
    var x = viewRect.x;
    var y = viewRect.y;
    var sizeExtent = orient === 'horizontal' ? [(0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(seriesModel.get('minSize'), viewHeight), (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(seriesModel.get('maxSize'), viewHeight)] : [(0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(seriesModel.get('minSize'), viewWidth), (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(seriesModel.get('maxSize'), viewWidth)];
    var dataExtent = data.getDataExtent(valueDim);
    var min = seriesModel.get('min');
    var max = seriesModel.get('max');

    if (min == null) {
      min = Math.min(dataExtent[0], 0);
    }

    if (max == null) {
      max = dataExtent[1];
    }

    var funnelAlign = seriesModel.get('funnelAlign');
    var gap = seriesModel.get('gap');
    var viewSize = orient === 'horizontal' ? viewWidth : viewHeight;
    var itemSize = (viewSize - gap * (data.count() - 1)) / data.count();

    var getLinePoints = function (idx, offset) {
      // End point index is data.count() and we assign it 0
      if (orient === 'horizontal') {
        var val_1 = data.get(valueDim, idx) || 0;
        var itemHeight = (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.linearMap)(val_1, [min, max], sizeExtent, true);
        var y0 = void 0;

        switch (funnelAlign) {
          case 'top':
            y0 = y;
            break;

          case 'center':
            y0 = y + (viewHeight - itemHeight) / 2;
            break;

          case 'bottom':
            y0 = y + (viewHeight - itemHeight);
            break;
        }

        return [[offset, y0], [offset, y0 + itemHeight]];
      }

      var val = data.get(valueDim, idx) || 0;
      var itemWidth = (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.linearMap)(val, [min, max], sizeExtent, true);
      var x0;

      switch (funnelAlign) {
        case 'left':
          x0 = x;
          break;

        case 'center':
          x0 = x + (viewWidth - itemWidth) / 2;
          break;

        case 'right':
          x0 = x + viewWidth - itemWidth;
          break;
      }

      return [[x0, offset], [x0 + itemWidth, offset]];
    };

    if (sort === 'ascending') {
      // From bottom to top
      itemSize = -itemSize;
      gap = -gap;

      if (orient === 'horizontal') {
        x += viewWidth;
      } else {
        y += viewHeight;
      }

      indices = indices.reverse();
    }

    for (var i = 0; i < indices.length; i++) {
      var idx = indices[i];
      var nextIdx = indices[i + 1];
      var itemModel = data.getItemModel(idx);

      if (orient === 'horizontal') {
        var width = itemModel.get(['itemStyle', 'width']);

        if (width == null) {
          width = itemSize;
        } else {
          width = (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(width, viewWidth);

          if (sort === 'ascending') {
            width = -width;
          }
        }

        var start = getLinePoints(idx, x);
        var end = getLinePoints(nextIdx, x + width);
        x += width + gap;
        data.setItemLayout(idx, {
          points: start.concat(end.slice().reverse())
        });
      } else {
        var height = itemModel.get(['itemStyle', 'height']);

        if (height == null) {
          height = itemSize;
        } else {
          height = (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(height, viewHeight);

          if (sort === 'ascending') {
            height = -height;
          }
        }

        var start = getLinePoints(idx, y);
        var end = getLinePoints(nextIdx, y + height);
        y += height + gap;
        data.setItemLayout(idx, {
          points: start.concat(end.slice().reverse())
        });
      }
    }

    labelLayout(data);
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/funnel/install.js":
/*!**********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/funnel/install.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _FunnelView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FunnelView */ "./node_modules/echarts/lib/chart/funnel/FunnelView.js");
/* harmony import */ var _FunnelSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FunnelSeries */ "./node_modules/echarts/lib/chart/funnel/FunnelSeries.js");
/* harmony import */ var _funnelLayout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./funnelLayout */ "./node_modules/echarts/lib/chart/funnel/funnelLayout.js");
/* harmony import */ var _processor_dataFilter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../processor/dataFilter */ "./node_modules/echarts/lib/processor/dataFilter.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




function install(registers) {
  registers.registerChartView(_FunnelView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerSeriesModel(_FunnelSeries__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerLayout(_funnelLayout__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerProcessor((0,_processor_dataFilter__WEBPACK_IMPORTED_MODULE_3__.default)('funnel'));
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/gauge/GaugeSeries.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/gauge/GaugeSeries.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _helper_createListSimply__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/createListSimply */ "./node_modules/echarts/lib/chart/helper/createListSimply.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var GaugeSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(GaugeSeriesModel, _super);

  function GaugeSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = GaugeSeriesModel.type;
    _this.visualStyleAccessPath = 'itemStyle';
    _this.useColorPaletteOnData = true;
    return _this;
  }

  GaugeSeriesModel.prototype.getInitialData = function (option, ecModel) {
    return (0,_helper_createListSimply__WEBPACK_IMPORTED_MODULE_1__.default)(this, ['value']);
  };

  GaugeSeriesModel.type = 'series.gauge';
  GaugeSeriesModel.defaultOption = {
    zlevel: 0,
    z: 2,
    // 默认全局居中
    center: ['50%', '50%'],
    legendHoverLink: true,
    radius: '75%',
    startAngle: 225,
    endAngle: -45,
    clockwise: true,
    // 最小值
    min: 0,
    // 最大值
    max: 100,
    // 分割段数，默认为10
    splitNumber: 10,
    // 坐标轴线
    axisLine: {
      // 默认显示，属性show控制显示与否
      show: true,
      roundCap: false,
      lineStyle: {
        color: [[1, '#E6EBF8']],
        width: 10
      }
    },
    // 坐标轴线
    progress: {
      // 默认显示，属性show控制显示与否
      show: false,
      overlap: true,
      width: 10,
      roundCap: false,
      clip: true
    },
    // 分隔线
    splitLine: {
      // 默认显示，属性show控制显示与否
      show: true,
      // 属性length控制线长
      length: 10,
      distance: 10,
      // 属性lineStyle（详见lineStyle）控制线条样式
      lineStyle: {
        color: '#63677A',
        width: 3,
        type: 'solid'
      }
    },
    // 坐标轴小标记
    axisTick: {
      // 属性show控制显示与否，默认不显示
      show: true,
      // 每份split细分多少段
      splitNumber: 5,
      // 属性length控制线长
      length: 6,
      distance: 10,
      // 属性lineStyle控制线条样式
      lineStyle: {
        color: '#63677A',
        width: 1,
        type: 'solid'
      }
    },
    axisLabel: {
      show: true,
      distance: 15,
      // formatter: null,
      color: '#464646',
      fontSize: 12
    },
    pointer: {
      icon: null,
      offsetCenter: [0, 0],
      show: true,
      length: '60%',
      width: 6,
      keepAspect: false
    },
    anchor: {
      show: false,
      showAbove: false,
      size: 6,
      icon: 'circle',
      offsetCenter: [0, 0],
      keepAspect: false,
      itemStyle: {
        color: '#fff',
        borderWidth: 0,
        borderColor: '#5470c6'
      }
    },
    title: {
      show: true,
      // x, y，单位px
      offsetCenter: [0, '20%'],
      // 其余属性默认使用全局文本样式，详见TEXTSTYLE
      color: '#464646',
      fontSize: 16,
      valueAnimation: false
    },
    detail: {
      show: true,
      backgroundColor: 'rgba(0,0,0,0)',
      borderWidth: 0,
      borderColor: '#ccc',
      width: 100,
      height: null,
      padding: [5, 10],
      // x, y，单位px
      offsetCenter: [0, '40%'],
      // formatter: null,
      // 其余属性默认使用全局文本样式，详见TEXTSTYLE
      color: '#464646',
      fontSize: 30,
      fontWeight: 'bold',
      lineHeight: 30,
      valueAnimation: false
    }
  };
  return GaugeSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_2__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GaugeSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/gauge/GaugeView.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/gauge/GaugeView.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _PointerPath__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PointerPath */ "./node_modules/echarts/lib/chart/gauge/PointerPath.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Sector.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Line.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _util_shape_sausage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/shape/sausage */ "./node_modules/echarts/lib/util/shape/sausage.js");
/* harmony import */ var _util_symbol__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/symbol */ "./node_modules/echarts/lib/util/symbol.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/










function parsePosition(seriesModel, api) {
  var center = seriesModel.get('center');
  var width = api.getWidth();
  var height = api.getHeight();
  var size = Math.min(width, height);
  var cx = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(center[0], api.getWidth());
  var cy = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(center[1], api.getHeight());
  var r = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(seriesModel.get('radius'), size / 2);
  return {
    cx: cx,
    cy: cy,
    r: r
  };
}

function formatLabel(value, labelFormatter) {
  var label = value == null ? '' : value + '';

  if (labelFormatter) {
    if (typeof labelFormatter === 'string') {
      label = labelFormatter.replace('{value}', label);
    } else if (typeof labelFormatter === 'function') {
      label = labelFormatter(value);
    }
  }

  return label;
}

var PI2 = Math.PI * 2;

var GaugeView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(GaugeView, _super);

  function GaugeView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = GaugeView.type;
    return _this;
  }

  GaugeView.prototype.render = function (seriesModel, ecModel, api) {
    this.group.removeAll();
    var colorList = seriesModel.get(['axisLine', 'lineStyle', 'color']);
    var posInfo = parsePosition(seriesModel, api);

    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);

    this._data = seriesModel.getData();
  };

  GaugeView.prototype.dispose = function () {};

  GaugeView.prototype._renderMain = function (seriesModel, ecModel, api, colorList, posInfo) {
    var group = this.group;
    var clockwise = seriesModel.get('clockwise');
    var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;
    var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;
    var axisLineModel = seriesModel.getModel('axisLine');
    var roundCap = axisLineModel.get('roundCap');
    var MainPath = roundCap ? _util_shape_sausage__WEBPACK_IMPORTED_MODULE_2__.default : _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default;
    var showAxis = axisLineModel.get('show');
    var lineStyleModel = axisLineModel.getModel('lineStyle');
    var axisLineWidth = lineStyleModel.get('width');
    var angleRangeSpan = !((endAngle - startAngle) % PI2) && endAngle !== startAngle ? PI2 : (endAngle - startAngle) % PI2;
    var prevEndAngle = startAngle;

    for (var i = 0; showAxis && i < colorList.length; i++) {
      // Clamp
      var percent = Math.min(Math.max(colorList[i][0], 0), 1);
      endAngle = startAngle + angleRangeSpan * percent;
      var sector = new MainPath({
        shape: {
          startAngle: prevEndAngle,
          endAngle: endAngle,
          cx: posInfo.cx,
          cy: posInfo.cy,
          clockwise: clockwise,
          r0: posInfo.r - axisLineWidth,
          r: posInfo.r
        },
        silent: true
      });
      sector.setStyle({
        fill: colorList[i][1]
      });
      sector.setStyle(lineStyleModel.getLineStyle( // Because we use sector to simulate arc
      // so the properties for stroking are useless
      ['color', 'width']));
      group.add(sector);
      prevEndAngle = endAngle;
    }

    var getColor = function (percent) {
      // Less than 0
      if (percent <= 0) {
        return colorList[0][1];
      }

      var i;

      for (i = 0; i < colorList.length; i++) {
        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {
          return colorList[i][1];
        }
      } // More than 1


      return colorList[i - 1][1];
    };

    if (!clockwise) {
      var tmp = startAngle;
      startAngle = endAngle;
      endAngle = tmp;
    }

    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);

    this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo);

    this._renderAnchor(seriesModel, posInfo);

    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
  };

  GaugeView.prototype._renderTicks = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
    var group = this.group;
    var cx = posInfo.cx;
    var cy = posInfo.cy;
    var r = posInfo.r;
    var minVal = +seriesModel.get('min');
    var maxVal = +seriesModel.get('max');
    var splitLineModel = seriesModel.getModel('splitLine');
    var tickModel = seriesModel.getModel('axisTick');
    var labelModel = seriesModel.getModel('axisLabel');
    var splitNumber = seriesModel.get('splitNumber');
    var subSplitNumber = tickModel.get('splitNumber');
    var splitLineLen = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(splitLineModel.get('length'), r);
    var tickLen = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(tickModel.get('length'), r);
    var angle = startAngle;
    var step = (endAngle - startAngle) / splitNumber;
    var subStep = step / subSplitNumber;
    var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();
    var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();
    var splitLineDistance = splitLineModel.get('distance');
    var unitX;
    var unitY;

    for (var i = 0; i <= splitNumber; i++) {
      unitX = Math.cos(angle);
      unitY = Math.sin(angle); // Split line

      if (splitLineModel.get('show')) {
        var distance = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;
        var splitLine = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default({
          shape: {
            x1: unitX * (r - distance) + cx,
            y1: unitY * (r - distance) + cy,
            x2: unitX * (r - splitLineLen - distance) + cx,
            y2: unitY * (r - splitLineLen - distance) + cy
          },
          style: splitLineStyle,
          silent: true
        });

        if (splitLineStyle.stroke === 'auto') {
          splitLine.setStyle({
            stroke: getColor(i / splitNumber)
          });
        }

        group.add(splitLine);
      } // Label


      if (labelModel.get('show')) {
        var distance = labelModel.get('distance') + splitLineDistance;
        var label = formatLabel((0,_util_number__WEBPACK_IMPORTED_MODULE_0__.round)(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));
        var autoColor = getColor(i / splitNumber);
        group.add(new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default({
          style: (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_6__.createTextStyle)(labelModel, {
            text: label,
            x: unitX * (r - splitLineLen - distance) + cx,
            y: unitY * (r - splitLineLen - distance) + cy,
            verticalAlign: unitY < -0.8 ? 'top' : unitY > 0.8 ? 'bottom' : 'middle',
            align: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'
          }, {
            inheritColor: autoColor
          }),
          silent: true
        }));
      } // Axis tick


      if (tickModel.get('show') && i !== splitNumber) {
        var distance = tickModel.get('distance');
        distance = distance ? distance + axisLineWidth : axisLineWidth;

        for (var j = 0; j <= subSplitNumber; j++) {
          unitX = Math.cos(angle);
          unitY = Math.sin(angle);
          var tickLine = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default({
            shape: {
              x1: unitX * (r - distance) + cx,
              y1: unitY * (r - distance) + cy,
              x2: unitX * (r - tickLen - distance) + cx,
              y2: unitY * (r - tickLen - distance) + cy
            },
            silent: true,
            style: tickLineStyle
          });

          if (tickLineStyle.stroke === 'auto') {
            tickLine.setStyle({
              stroke: getColor((i + j / subSplitNumber) / splitNumber)
            });
          }

          group.add(tickLine);
          angle += subStep;
        }

        angle -= subStep;
      } else {
        angle += step;
      }
    }
  };

  GaugeView.prototype._renderPointer = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
    var group = this.group;
    var oldData = this._data;
    var oldProgressData = this._progressEls;
    var progressList = [];
    var showPointer = seriesModel.get(['pointer', 'show']);
    var progressModel = seriesModel.getModel('progress');
    var showProgress = progressModel.get('show');
    var data = seriesModel.getData();
    var valueDim = data.mapDimension('value');
    var minVal = +seriesModel.get('min');
    var maxVal = +seriesModel.get('max');
    var valueExtent = [minVal, maxVal];
    var angleExtent = [startAngle, endAngle];

    function createPointer(idx, angle) {
      var itemModel = data.getItemModel(idx);
      var pointerModel = itemModel.getModel('pointer');
      var pointerWidth = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(pointerModel.get('width'), posInfo.r);
      var pointerLength = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(pointerModel.get('length'), posInfo.r);
      var pointerStr = seriesModel.get(['pointer', 'icon']);
      var pointerOffset = pointerModel.get('offsetCenter');
      var pointerOffsetX = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(pointerOffset[0], posInfo.r);
      var pointerOffsetY = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(pointerOffset[1], posInfo.r);
      var pointerKeepAspect = pointerModel.get('keepAspect');
      var pointer; // not exist icon type will be set 'rect'

      if (pointerStr) {
        pointer = (0,_util_symbol__WEBPACK_IMPORTED_MODULE_7__.createSymbol)(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);
      } else {
        pointer = new _PointerPath__WEBPACK_IMPORTED_MODULE_8__.default({
          shape: {
            angle: -Math.PI / 2,
            width: pointerWidth,
            r: pointerLength,
            x: pointerOffsetX,
            y: pointerOffsetY
          }
        });
      }

      pointer.rotation = -(angle + Math.PI / 2);
      pointer.x = posInfo.cx;
      pointer.y = posInfo.cy;
      return pointer;
    }

    function createProgress(idx, endAngle) {
      var roundCap = progressModel.get('roundCap');
      var ProgressPath = roundCap ? _util_shape_sausage__WEBPACK_IMPORTED_MODULE_2__.default : _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default;
      var isOverlap = progressModel.get('overlap');
      var progressWidth = isOverlap ? progressModel.get('width') : axisLineWidth / data.count();
      var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;
      var r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;
      var progress = new ProgressPath({
        shape: {
          startAngle: startAngle,
          endAngle: endAngle,
          cx: posInfo.cx,
          cy: posInfo.cy,
          clockwise: clockwise,
          r0: r0,
          r: r
        }
      });
      isOverlap && (progress.z2 = maxVal - data.get(valueDim, idx) % maxVal);
      return progress;
    }

    if (showProgress || showPointer) {
      data.diff(oldData).add(function (idx) {
        if (showPointer) {
          var pointer = createPointer(idx, startAngle);
          _util_graphic__WEBPACK_IMPORTED_MODULE_9__.initProps(pointer, {
            rotation: -((0,_util_number__WEBPACK_IMPORTED_MODULE_0__.linearMap)(data.get(valueDim, idx), valueExtent, angleExtent, true) + Math.PI / 2)
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(idx, pointer);
        }

        if (showProgress) {
          var progress = createProgress(idx, startAngle);
          var isClip = progressModel.get('clip');
          _util_graphic__WEBPACK_IMPORTED_MODULE_9__.initProps(progress, {
            shape: {
              endAngle: (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.linearMap)(data.get(valueDim, idx), valueExtent, angleExtent, isClip)
            }
          }, seriesModel);
          group.add(progress);
          progressList[idx] = progress;
        }
      }).update(function (newIdx, oldIdx) {
        if (showPointer) {
          var previousPointer = oldData.getItemGraphicEl(oldIdx);
          var previousRotate = previousPointer ? previousPointer.rotation : startAngle;
          var pointer = createPointer(newIdx, previousRotate);
          pointer.rotation = previousRotate;
          _util_graphic__WEBPACK_IMPORTED_MODULE_9__.updateProps(pointer, {
            rotation: -((0,_util_number__WEBPACK_IMPORTED_MODULE_0__.linearMap)(data.get(valueDim, newIdx), valueExtent, angleExtent, true) + Math.PI / 2)
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(newIdx, pointer);
        }

        if (showProgress) {
          var previousProgress = oldProgressData[oldIdx];
          var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;
          var progress = createProgress(newIdx, previousEndAngle);
          var isClip = progressModel.get('clip');
          _util_graphic__WEBPACK_IMPORTED_MODULE_9__.updateProps(progress, {
            shape: {
              endAngle: (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.linearMap)(data.get(valueDim, newIdx), valueExtent, angleExtent, isClip)
            }
          }, seriesModel);
          group.add(progress);
          progressList[newIdx] = progress;
        }
      }).execute();
      data.each(function (idx) {
        var itemModel = data.getItemModel(idx);
        var emphasisModel = itemModel.getModel('emphasis');

        if (showPointer) {
          var pointer = data.getItemGraphicEl(idx);
          pointer.useStyle(data.getItemVisual(idx, 'style'));
          pointer.setStyle(itemModel.getModel(['pointer', 'itemStyle']).getItemStyle());

          if (pointer.style.fill === 'auto') {
            pointer.setStyle('fill', getColor((0,_util_number__WEBPACK_IMPORTED_MODULE_0__.linearMap)(data.get(valueDim, idx), valueExtent, [0, 1], true)));
          }

          pointer.z2EmphasisLift = 0;
          (0,_util_states__WEBPACK_IMPORTED_MODULE_10__.setStatesStylesFromModel)(pointer, itemModel);
          (0,_util_states__WEBPACK_IMPORTED_MODULE_10__.enableHoverEmphasis)(pointer, emphasisModel.get('focus'), emphasisModel.get('blurScope'));
        }

        if (showProgress) {
          var progress = progressList[idx];
          progress.useStyle(data.getItemVisual(idx, 'style'));
          progress.setStyle(itemModel.getModel(['progress', 'itemStyle']).getItemStyle());
          progress.z2EmphasisLift = 0;
          (0,_util_states__WEBPACK_IMPORTED_MODULE_10__.setStatesStylesFromModel)(progress, itemModel);
          (0,_util_states__WEBPACK_IMPORTED_MODULE_10__.enableHoverEmphasis)(progress, emphasisModel.get('focus'), emphasisModel.get('blurScope'));
        }
      });
      this._progressEls = progressList;
    }
  };

  GaugeView.prototype._renderAnchor = function (seriesModel, posInfo) {
    var anchorModel = seriesModel.getModel('anchor');
    var showAnchor = anchorModel.get('show');

    if (showAnchor) {
      var anchorSize = anchorModel.get('size');
      var anchorType = anchorModel.get('icon');
      var offsetCenter = anchorModel.get('offsetCenter');
      var anchorKeepAspect = anchorModel.get('keepAspect');
      var anchor = (0,_util_symbol__WEBPACK_IMPORTED_MODULE_7__.createSymbol)(anchorType, posInfo.cx - anchorSize / 2 + (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);
      anchor.z2 = anchorModel.get('showAbove') ? 1 : 0;
      anchor.setStyle(anchorModel.getModel('itemStyle').getItemStyle());
      this.group.add(anchor);
    }
  };

  GaugeView.prototype._renderTitleAndDetail = function (seriesModel, ecModel, api, getColor, posInfo) {
    var _this = this;

    var data = seriesModel.getData();
    var valueDim = data.mapDimension('value');
    var minVal = +seriesModel.get('min');
    var maxVal = +seriesModel.get('max');
    var contentGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_11__.default();
    var newTitleEls = [];
    var newDetailEls = [];
    var hasAnimation = seriesModel.isAnimationEnabled();
    data.diff(this._data).add(function (idx) {
      newTitleEls[idx] = new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default({
        silent: true
      });
      newDetailEls[idx] = new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default({
        silent: true
      });
    }).update(function (idx, oldIdx) {
      newTitleEls[idx] = _this._titleEls[oldIdx];
      newDetailEls[idx] = _this._detailEls[oldIdx];
    }).execute();
    data.each(function (idx) {
      var itemModel = data.getItemModel(idx);
      var value = data.get(valueDim, idx);
      var itemGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_11__.default();
      var autoColor = getColor((0,_util_number__WEBPACK_IMPORTED_MODULE_0__.linearMap)(value, [minVal, maxVal], [0, 1], true));
      var itemTitleModel = itemModel.getModel('title');

      if (itemTitleModel.get('show')) {
        var titleOffsetCenter = itemTitleModel.get('offsetCenter');
        var titleX = posInfo.cx + (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(titleOffsetCenter[0], posInfo.r);
        var titleY = posInfo.cy + (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(titleOffsetCenter[1], posInfo.r);
        var labelEl = newTitleEls[idx];
        labelEl.attr({
          style: (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_6__.createTextStyle)(itemTitleModel, {
            x: titleX,
            y: titleY,
            text: data.getName(idx),
            align: 'center',
            verticalAlign: 'middle'
          }, {
            inheritColor: autoColor
          })
        });
        itemGroup.add(labelEl);
      }

      var itemDetailModel = itemModel.getModel('detail');

      if (itemDetailModel.get('show')) {
        var detailOffsetCenter = itemDetailModel.get('offsetCenter');
        var detailX = posInfo.cx + (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(detailOffsetCenter[0], posInfo.r);
        var detailY = posInfo.cy + (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(detailOffsetCenter[1], posInfo.r);
        var width = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(itemDetailModel.get('width'), posInfo.r);
        var height = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(itemDetailModel.get('height'), posInfo.r);
        var detailColor = seriesModel.get(['progress', 'show']) ? data.getItemVisual(idx, 'style').fill : autoColor;
        var labelEl = newDetailEls[idx];
        var formatter_1 = itemDetailModel.get('formatter');
        labelEl.attr({
          style: (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_6__.createTextStyle)(itemDetailModel, {
            x: detailX,
            y: detailY,
            text: formatLabel(value, formatter_1),
            width: isNaN(width) ? null : width,
            height: isNaN(height) ? null : height,
            align: 'center',
            verticalAlign: 'middle'
          }, {
            inheritColor: detailColor
          })
        });
        (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_6__.setLabelValueAnimation)(labelEl, {
          normal: itemDetailModel
        }, value, function (value) {
          return formatLabel(value, formatter_1);
        });
        hasAnimation && (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_6__.animateLabelValue)(labelEl, idx, data, seriesModel, {
          getFormattedLabel: function (labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {
            return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter_1);
          }
        });
        itemGroup.add(labelEl);
      }

      contentGroup.add(itemGroup);
    });
    this.group.add(contentGroup);
    this._titleEls = newTitleEls;
    this._detailEls = newDetailEls;
  };

  GaugeView.type = 'gauge';
  return GaugeView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_12__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GaugeView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/gauge/PointerPath.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/gauge/PointerPath.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_graphic_Path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/graphic/Path */ "./node_modules/zrender/lib/graphic/Path.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var PointerShape =
/** @class */
function () {
  function PointerShape() {
    this.angle = 0;
    this.width = 10;
    this.r = 10;
    this.x = 0;
    this.y = 0;
  }

  return PointerShape;
}();

var PointerPath =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(PointerPath, _super);

  function PointerPath(opts) {
    var _this = _super.call(this, opts) || this;

    _this.type = 'pointer';
    return _this;
  }

  PointerPath.prototype.getDefaultShape = function () {
    return new PointerShape();
  };

  PointerPath.prototype.buildPath = function (ctx, shape) {
    var mathCos = Math.cos;
    var mathSin = Math.sin;
    var r = shape.r;
    var width = shape.width;
    var angle = shape.angle;
    var x = shape.x - mathCos(angle) * width * (width >= r / 3 ? 1 : 2);
    var y = shape.y - mathSin(angle) * width * (width >= r / 3 ? 1 : 2);
    angle = shape.angle - Math.PI / 2;
    ctx.moveTo(x, y);
    ctx.lineTo(shape.x + mathCos(angle) * width, shape.y + mathSin(angle) * width);
    ctx.lineTo(shape.x + mathCos(shape.angle) * r, shape.y + mathSin(shape.angle) * r);
    ctx.lineTo(shape.x - mathCos(angle) * width, shape.y - mathSin(angle) * width);
    ctx.lineTo(x, y);
  };

  return PointerPath;
}(zrender_lib_graphic_Path__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PointerPath);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/gauge/install.js":
/*!*********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/gauge/install.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _GaugeView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GaugeView */ "./node_modules/echarts/lib/chart/gauge/GaugeView.js");
/* harmony import */ var _GaugeSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GaugeSeries */ "./node_modules/echarts/lib/chart/gauge/GaugeSeries.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function install(registers) {
  registers.registerChartView(_GaugeView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerSeriesModel(_GaugeSeries__WEBPACK_IMPORTED_MODULE_1__.default);
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/graph/GraphSeries.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/graph/GraphSeries.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _data_List__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../data/List */ "./node_modules/echarts/lib/data/List.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../model/Model */ "./node_modules/echarts/lib/model/Model.js");
/* harmony import */ var _helper_createGraphFromNodeEdge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helper/createGraphFromNodeEdge */ "./node_modules/echarts/lib/chart/helper/createGraphFromNodeEdge.js");
/* harmony import */ var _visual_LegendVisualProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../visual/LegendVisualProvider */ "./node_modules/echarts/lib/visual/LegendVisualProvider.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var _component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../component/tooltip/tooltipMarkup */ "./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js");
/* harmony import */ var _component_tooltip_seriesFormatTooltip__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../component/tooltip/seriesFormatTooltip */ "./node_modules/echarts/lib/component/tooltip/seriesFormatTooltip.js");
/* harmony import */ var _helper_multipleGraphEdgeHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helper/multipleGraphEdgeHelper */ "./node_modules/echarts/lib/chart/helper/multipleGraphEdgeHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/












var GraphSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(GraphSeriesModel, _super);

  function GraphSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = GraphSeriesModel.type;
    _this.hasSymbolVisual = true;
    return _this;
  }

  GraphSeriesModel.prototype.init = function (option) {
    _super.prototype.init.apply(this, arguments);

    var self = this;

    function getCategoriesData() {
      return self._categoriesData;
    } // Provide data for legend select


    this.legendVisualProvider = new _visual_LegendVisualProvider__WEBPACK_IMPORTED_MODULE_1__.default(getCategoriesData, getCategoriesData);
    this.fillDataTextStyle(option.edges || option.links);

    this._updateCategoriesData();
  };

  GraphSeriesModel.prototype.mergeOption = function (option) {
    _super.prototype.mergeOption.apply(this, arguments);

    this.fillDataTextStyle(option.edges || option.links);

    this._updateCategoriesData();
  };

  GraphSeriesModel.prototype.mergeDefaultAndTheme = function (option) {
    _super.prototype.mergeDefaultAndTheme.apply(this, arguments);

    (0,_util_model__WEBPACK_IMPORTED_MODULE_2__.defaultEmphasis)(option, 'edgeLabel', ['show']);
  };

  GraphSeriesModel.prototype.getInitialData = function (option, ecModel) {
    var edges = option.edges || option.links || [];
    var nodes = option.data || option.nodes || [];
    var self = this;

    if (nodes && edges) {
      // auto curveness
      (0,_helper_multipleGraphEdgeHelper__WEBPACK_IMPORTED_MODULE_3__.initCurvenessList)(this);
      var graph = (0,_helper_createGraphFromNodeEdge__WEBPACK_IMPORTED_MODULE_4__.default)(nodes, edges, this, true, beforeLink);
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.each(graph.edges, function (edge) {
        (0,_helper_multipleGraphEdgeHelper__WEBPACK_IMPORTED_MODULE_3__.createEdgeMapForCurveness)(edge.node1, edge.node2, this, edge.dataIndex);
      }, this);
      return graph.data;
    }

    function beforeLink(nodeData, edgeData) {
      // Overwrite nodeData.getItemModel to
      nodeData.wrapMethod('getItemModel', function (model) {
        var categoriesModels = self._categoriesModels;
        var categoryIdx = model.getShallow('category');
        var categoryModel = categoriesModels[categoryIdx];

        if (categoryModel) {
          categoryModel.parentModel = model.parentModel;
          model.parentModel = categoryModel;
        }

        return model;
      }); // TODO Inherit resolveParentPath by default in Model#getModel?

      var oldGetModel = _model_Model__WEBPACK_IMPORTED_MODULE_6__.default.prototype.getModel;

      function newGetModel(path, parentModel) {
        var model = oldGetModel.call(this, path, parentModel);
        model.resolveParentPath = resolveParentPath;
        return model;
      }

      edgeData.wrapMethod('getItemModel', function (model) {
        model.resolveParentPath = resolveParentPath;
        model.getModel = newGetModel;
        return model;
      });

      function resolveParentPath(pathArr) {
        if (pathArr && (pathArr[0] === 'label' || pathArr[1] === 'label')) {
          var newPathArr = pathArr.slice();

          if (pathArr[0] === 'label') {
            newPathArr[0] = 'edgeLabel';
          } else if (pathArr[1] === 'label') {
            newPathArr[1] = 'edgeLabel';
          }

          return newPathArr;
        }

        return pathArr;
      }
    }
  };

  GraphSeriesModel.prototype.getGraph = function () {
    return this.getData().graph;
  };

  GraphSeriesModel.prototype.getEdgeData = function () {
    return this.getGraph().edgeData;
  };

  GraphSeriesModel.prototype.getCategoriesData = function () {
    return this._categoriesData;
  };

  GraphSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
    if (dataType === 'edge') {
      var nodeData = this.getData();
      var params = this.getDataParams(dataIndex, dataType);
      var edge = nodeData.graph.getEdgeByIndex(dataIndex);
      var sourceName = nodeData.getName(edge.node1.dataIndex);
      var targetName = nodeData.getName(edge.node2.dataIndex);
      var nameArr = [];
      sourceName != null && nameArr.push(sourceName);
      targetName != null && nameArr.push(targetName);
      return (0,_component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_7__.createTooltipMarkup)('nameValue', {
        name: nameArr.join(' > '),
        value: params.value,
        noValue: params.value == null
      });
    } // dataType === 'node' or empty


    var nodeMarkup = (0,_component_tooltip_seriesFormatTooltip__WEBPACK_IMPORTED_MODULE_8__.defaultSeriesFormatTooltip)({
      series: this,
      dataIndex: dataIndex,
      multipleSeries: multipleSeries
    });
    return nodeMarkup;
  };

  GraphSeriesModel.prototype._updateCategoriesData = function () {
    var categories = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.map(this.option.categories || [], function (category) {
      // Data must has value
      return category.value != null ? category : zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.extend({
        value: 0
      }, category);
    });
    var categoriesData = new _data_List__WEBPACK_IMPORTED_MODULE_9__.default(['value'], this);
    categoriesData.initData(categories);
    this._categoriesData = categoriesData;
    this._categoriesModels = categoriesData.mapArray(function (idx) {
      return categoriesData.getItemModel(idx);
    });
  };

  GraphSeriesModel.prototype.setZoom = function (zoom) {
    this.option.zoom = zoom;
  };

  GraphSeriesModel.prototype.setCenter = function (center) {
    this.option.center = center;
  };

  GraphSeriesModel.prototype.isAnimationEnabled = function () {
    return _super.prototype.isAnimationEnabled.call(this) // Not enable animation when do force layout
    && !(this.get('layout') === 'force' && this.get(['force', 'layoutAnimation']));
  };

  GraphSeriesModel.type = 'series.graph';
  GraphSeriesModel.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar'];
  GraphSeriesModel.defaultOption = {
    zlevel: 0,
    z: 2,
    coordinateSystem: 'view',
    // Default option for all coordinate systems
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    // polarIndex: 0,
    // geoIndex: 0,
    legendHoverLink: true,
    layout: null,
    // Configuration of circular layout
    circular: {
      rotateLabel: false
    },
    // Configuration of force directed layout
    force: {
      initLayout: null,
      // Node repulsion. Can be an array to represent range.
      repulsion: [0, 50],
      gravity: 0.1,
      // Initial friction
      friction: 0.6,
      // Edge length. Can be an array to represent range.
      edgeLength: 30,
      layoutAnimation: true
    },
    left: 'center',
    top: 'center',
    // right: null,
    // bottom: null,
    // width: '80%',
    // height: '80%',
    symbol: 'circle',
    symbolSize: 10,
    edgeSymbol: ['none', 'none'],
    edgeSymbolSize: 10,
    edgeLabel: {
      position: 'middle',
      distance: 5
    },
    draggable: false,
    roam: false,
    // Default on center of graph
    center: null,
    zoom: 1,
    // Symbol size scale ratio in roam
    nodeScaleRatio: 0.6,
    // cursor: null,
    // categories: [],
    // data: []
    // Or
    // nodes: []
    //
    // links: []
    // Or
    // edges: []
    label: {
      show: false,
      formatter: '{b}'
    },
    itemStyle: {},
    lineStyle: {
      color: '#aaa',
      width: 1,
      opacity: 0.5
    },
    emphasis: {
      scale: true,
      label: {
        show: true
      }
    },
    select: {
      itemStyle: {
        borderColor: '#212121'
      }
    }
  };
  return GraphSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_10__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GraphSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/graph/GraphView.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/graph/GraphView.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _helper_SymbolDraw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/SymbolDraw */ "./node_modules/echarts/lib/chart/helper/SymbolDraw.js");
/* harmony import */ var _helper_LineDraw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helper/LineDraw */ "./node_modules/echarts/lib/chart/helper/LineDraw.js");
/* harmony import */ var _component_helper_RoamController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../component/helper/RoamController */ "./node_modules/echarts/lib/component/helper/RoamController.js");
/* harmony import */ var _component_helper_roamHelper__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../component/helper/roamHelper */ "./node_modules/echarts/lib/component/helper/roamHelper.js");
/* harmony import */ var _component_helper_cursorHelper__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../component/helper/cursorHelper */ "./node_modules/echarts/lib/component/helper/cursorHelper.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _adjustEdge__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./adjustEdge */ "./node_modules/echarts/lib/chart/graph/adjustEdge.js");
/* harmony import */ var _graphHelper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./graphHelper */ "./node_modules/echarts/lib/chart/graph/graphHelper.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/













function isViewCoordSys(coordSys) {
  return coordSys.type === 'view';
}

var GraphView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(GraphView, _super);

  function GraphView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = GraphView.type;
    return _this;
  }

  GraphView.prototype.init = function (ecModel, api) {
    var symbolDraw = new _helper_SymbolDraw__WEBPACK_IMPORTED_MODULE_1__.default();
    var lineDraw = new _helper_LineDraw__WEBPACK_IMPORTED_MODULE_2__.default();
    var group = this.group;
    this._controller = new _component_helper_RoamController__WEBPACK_IMPORTED_MODULE_3__.default(api.getZr());
    this._controllerHost = {
      target: group
    };
    group.add(symbolDraw.group);
    group.add(lineDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineDraw = lineDraw;
    this._firstRender = true;
  };

  GraphView.prototype.render = function (seriesModel, ecModel, api) {
    var _this = this;

    var coordSys = seriesModel.coordinateSystem;
    this._model = seriesModel;
    var symbolDraw = this._symbolDraw;
    var lineDraw = this._lineDraw;
    var group = this.group;

    if (isViewCoordSys(coordSys)) {
      var groupNewProp = {
        x: coordSys.x,
        y: coordSys.y,
        scaleX: coordSys.scaleX,
        scaleY: coordSys.scaleY
      };

      if (this._firstRender) {
        group.attr(groupNewProp);
      } else {
        _util_graphic__WEBPACK_IMPORTED_MODULE_4__.updateProps(group, groupNewProp, seriesModel);
      }
    } // Fix edge contact point with node


    (0,_adjustEdge__WEBPACK_IMPORTED_MODULE_5__.default)(seriesModel.getGraph(), (0,_graphHelper__WEBPACK_IMPORTED_MODULE_6__.getNodeGlobalScale)(seriesModel));
    var data = seriesModel.getData();
    symbolDraw.updateData(data);
    var edgeData = seriesModel.getEdgeData(); // TODO: TYPE

    lineDraw.updateData(edgeData);

    this._updateNodeAndLinkScale();

    this._updateController(seriesModel, ecModel, api);

    clearTimeout(this._layoutTimeout);
    var forceLayout = seriesModel.forceLayout;
    var layoutAnimation = seriesModel.get(['force', 'layoutAnimation']);

    if (forceLayout) {
      this._startForceLayoutIteration(forceLayout, layoutAnimation);
    }

    data.graph.eachNode(function (node) {
      var idx = node.dataIndex;
      var el = node.getGraphicEl();
      var itemModel = node.getModel(); // Update draggable

      el.off('drag').off('dragend');
      var draggable = itemModel.get('draggable');

      if (draggable) {
        el.on('drag', function () {
          if (forceLayout) {
            forceLayout.warmUp();
            !_this._layouting && _this._startForceLayoutIteration(forceLayout, layoutAnimation);
            forceLayout.setFixed(idx); // Write position back to layout

            data.setItemLayout(idx, [el.x, el.y]);
          }
        }).on('dragend', function () {
          if (forceLayout) {
            forceLayout.setUnfixed(idx);
          }
        });
      }

      el.setDraggable(draggable && !!forceLayout);
      var focus = itemModel.get(['emphasis', 'focus']);

      if (focus === 'adjacency') {
        (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_7__.getECData)(el).focus = node.getAdjacentDataIndices();
      }
    });
    data.graph.eachEdge(function (edge) {
      var el = edge.getGraphicEl();
      var focus = edge.getModel().get(['emphasis', 'focus']);

      if (focus === 'adjacency') {
        (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_7__.getECData)(el).focus = {
          edge: [edge.dataIndex],
          node: [edge.node1.dataIndex, edge.node2.dataIndex]
        };
      }
    });
    var circularRotateLabel = seriesModel.get('layout') === 'circular' && seriesModel.get(['circular', 'rotateLabel']);
    var cx = data.getLayout('cx');
    var cy = data.getLayout('cy');
    data.eachItemGraphicEl(function (el, idx) {
      var itemModel = data.getItemModel(idx);
      var labelRotate = itemModel.get(['label', 'rotate']) || 0;
      var symbolPath = el.getSymbolPath();

      if (circularRotateLabel) {
        var pos = data.getItemLayout(idx);
        var rad = Math.atan2(pos[1] - cy, pos[0] - cx);

        if (rad < 0) {
          rad = Math.PI * 2 + rad;
        }

        var isLeft = pos[0] < cx;

        if (isLeft) {
          rad = rad - Math.PI;
        }

        var textPosition = isLeft ? 'left' : 'right';
        symbolPath.setTextConfig({
          rotation: -rad,
          position: textPosition,
          origin: 'center'
        });
        var emphasisState = symbolPath.ensureState('emphasis');
        zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_8__.extend(emphasisState.textConfig || (emphasisState.textConfig = {}), {
          position: textPosition
        });
      } else {
        symbolPath.setTextConfig({
          rotation: labelRotate *= Math.PI / 180
        });
      }
    });
    this._firstRender = false;
  };

  GraphView.prototype.dispose = function () {
    this._controller && this._controller.dispose();
    this._controllerHost = null;
  };

  GraphView.prototype._startForceLayoutIteration = function (forceLayout, layoutAnimation) {
    var self = this;

    (function step() {
      forceLayout.step(function (stopped) {
        self.updateLayout(self._model);
        (self._layouting = !stopped) && (layoutAnimation ? self._layoutTimeout = setTimeout(step, 16) : step());
      });
    })();
  };

  GraphView.prototype._updateController = function (seriesModel, ecModel, api) {
    var _this = this;

    var controller = this._controller;
    var controllerHost = this._controllerHost;
    var group = this.group;
    controller.setPointerChecker(function (e, x, y) {
      var rect = group.getBoundingRect();
      rect.applyTransform(group.transform);
      return rect.contain(x, y) && !(0,_component_helper_cursorHelper__WEBPACK_IMPORTED_MODULE_9__.onIrrelevantElement)(e, api, seriesModel);
    });

    if (!isViewCoordSys(seriesModel.coordinateSystem)) {
      controller.disable();
      return;
    }

    controller.enable(seriesModel.get('roam'));
    controllerHost.zoomLimit = seriesModel.get('scaleLimit');
    controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
    controller.off('pan').off('zoom').on('pan', function (e) {
      _component_helper_roamHelper__WEBPACK_IMPORTED_MODULE_10__.updateViewOnPan(controllerHost, e.dx, e.dy);
      api.dispatchAction({
        seriesId: seriesModel.id,
        type: 'graphRoam',
        dx: e.dx,
        dy: e.dy
      });
    }).on('zoom', function (e) {
      _component_helper_roamHelper__WEBPACK_IMPORTED_MODULE_10__.updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);
      api.dispatchAction({
        seriesId: seriesModel.id,
        type: 'graphRoam',
        zoom: e.scale,
        originX: e.originX,
        originY: e.originY
      });

      _this._updateNodeAndLinkScale();

      (0,_adjustEdge__WEBPACK_IMPORTED_MODULE_5__.default)(seriesModel.getGraph(), (0,_graphHelper__WEBPACK_IMPORTED_MODULE_6__.getNodeGlobalScale)(seriesModel));

      _this._lineDraw.updateLayout(); // Only update label layout on zoom


      api.updateLabelLayout();
    });
  };

  GraphView.prototype._updateNodeAndLinkScale = function () {
    var seriesModel = this._model;
    var data = seriesModel.getData();
    var nodeScale = (0,_graphHelper__WEBPACK_IMPORTED_MODULE_6__.getNodeGlobalScale)(seriesModel);
    data.eachItemGraphicEl(function (el, idx) {
      el.setSymbolScale(nodeScale);
    });
  };

  GraphView.prototype.updateLayout = function (seriesModel) {
    (0,_adjustEdge__WEBPACK_IMPORTED_MODULE_5__.default)(seriesModel.getGraph(), (0,_graphHelper__WEBPACK_IMPORTED_MODULE_6__.getNodeGlobalScale)(seriesModel));

    this._symbolDraw.updateLayout();

    this._lineDraw.updateLayout();
  };

  GraphView.prototype.remove = function (ecModel, api) {
    this._symbolDraw && this._symbolDraw.remove();
    this._lineDraw && this._lineDraw.remove();
  };

  GraphView.type = 'graph';
  return GraphView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_11__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GraphView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/graph/adjustEdge.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/graph/adjustEdge.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ adjustEdge)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_curve__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/curve */ "./node_modules/zrender/lib/core/curve.js");
/* harmony import */ var zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/vector */ "./node_modules/zrender/lib/core/vector.js");
/* harmony import */ var _graphHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./graphHelper */ "./node_modules/echarts/lib/chart/graph/graphHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var v1 = [];
var v2 = [];
var v3 = [];
var quadraticAt = zrender_lib_core_curve__WEBPACK_IMPORTED_MODULE_0__.quadraticAt;
var v2DistSquare = zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.distSquare;
var mathAbs = Math.abs;

function intersectCurveCircle(curvePoints, center, radius) {
  var p0 = curvePoints[0];
  var p1 = curvePoints[1];
  var p2 = curvePoints[2];
  var d = Infinity;
  var t;
  var radiusSquare = radius * radius;
  var interval = 0.1;

  for (var _t = 0.1; _t <= 0.9; _t += 0.1) {
    v1[0] = quadraticAt(p0[0], p1[0], p2[0], _t);
    v1[1] = quadraticAt(p0[1], p1[1], p2[1], _t);
    var diff = mathAbs(v2DistSquare(v1, center) - radiusSquare);

    if (diff < d) {
      d = diff;
      t = _t;
    }
  } // Assume the segment is monotone，Find root through Bisection method
  // At most 32 iteration


  for (var i = 0; i < 32; i++) {
    // let prev = t - interval;
    var next = t + interval; // v1[0] = quadraticAt(p0[0], p1[0], p2[0], prev);
    // v1[1] = quadraticAt(p0[1], p1[1], p2[1], prev);

    v2[0] = quadraticAt(p0[0], p1[0], p2[0], t);
    v2[1] = quadraticAt(p0[1], p1[1], p2[1], t);
    v3[0] = quadraticAt(p0[0], p1[0], p2[0], next);
    v3[1] = quadraticAt(p0[1], p1[1], p2[1], next);
    var diff = v2DistSquare(v2, center) - radiusSquare;

    if (mathAbs(diff) < 1e-2) {
      break;
    } // let prevDiff = v2DistSquare(v1, center) - radiusSquare;


    var nextDiff = v2DistSquare(v3, center) - radiusSquare;
    interval /= 2;

    if (diff < 0) {
      if (nextDiff >= 0) {
        t = t + interval;
      } else {
        t = t - interval;
      }
    } else {
      if (nextDiff >= 0) {
        t = t - interval;
      } else {
        t = t + interval;
      }
    }
  }

  return t;
} // Adjust edge to avoid


function adjustEdge(graph, scale) {
  var tmp0 = [];
  var quadraticSubdivide = zrender_lib_core_curve__WEBPACK_IMPORTED_MODULE_0__.quadraticSubdivide;
  var pts = [[], [], []];
  var pts2 = [[], []];
  var v = [];
  scale /= 2;
  graph.eachEdge(function (edge, idx) {
    var linePoints = edge.getLayout();
    var fromSymbol = edge.getVisual('fromSymbol');
    var toSymbol = edge.getVisual('toSymbol');

    if (!linePoints.__original) {
      linePoints.__original = [zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.clone(linePoints[0]), zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.clone(linePoints[1])];

      if (linePoints[2]) {
        linePoints.__original.push(zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.clone(linePoints[2]));
      }
    }

    var originalPoints = linePoints.__original; // Quadratic curve

    if (linePoints[2] != null) {
      zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.copy(pts[0], originalPoints[0]);
      zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.copy(pts[1], originalPoints[2]);
      zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.copy(pts[2], originalPoints[1]);

      if (fromSymbol && fromSymbol !== 'none') {
        var symbolSize = (0,_graphHelper__WEBPACK_IMPORTED_MODULE_2__.getSymbolSize)(edge.node1);
        var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale); // Subdivide and get the second

        quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
        pts[0][0] = tmp0[3];
        pts[1][0] = tmp0[4];
        quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
        pts[0][1] = tmp0[3];
        pts[1][1] = tmp0[4];
      }

      if (toSymbol && toSymbol !== 'none') {
        var symbolSize = (0,_graphHelper__WEBPACK_IMPORTED_MODULE_2__.getSymbolSize)(edge.node2);
        var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale); // Subdivide and get the first

        quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
        pts[1][0] = tmp0[1];
        pts[2][0] = tmp0[2];
        quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
        pts[1][1] = tmp0[1];
        pts[2][1] = tmp0[2];
      } // Copy back to layout


      zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.copy(linePoints[0], pts[0]);
      zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.copy(linePoints[1], pts[2]);
      zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.copy(linePoints[2], pts[1]);
    } // Line
    else {
        zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.copy(pts2[0], originalPoints[0]);
        zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.copy(pts2[1], originalPoints[1]);
        zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.sub(v, pts2[1], pts2[0]);
        zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.normalize(v, v);

        if (fromSymbol && fromSymbol !== 'none') {
          var symbolSize = (0,_graphHelper__WEBPACK_IMPORTED_MODULE_2__.getSymbolSize)(edge.node1);
          zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale);
        }

        if (toSymbol && toSymbol !== 'none') {
          var symbolSize = (0,_graphHelper__WEBPACK_IMPORTED_MODULE_2__.getSymbolSize)(edge.node2);
          zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale);
        }

        zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.copy(linePoints[0], pts2[0]);
        zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_1__.copy(linePoints[1], pts2[1]);
      }
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/graph/categoryFilter.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/graph/categoryFilter.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ categoryFilter)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function categoryFilter(ecModel) {
  var legendModels = ecModel.findComponents({
    mainType: 'legend'
  });

  if (!legendModels || !legendModels.length) {
    return;
  }

  ecModel.eachSeriesByType('graph', function (graphSeries) {
    var categoriesData = graphSeries.getCategoriesData();
    var graph = graphSeries.getGraph();
    var data = graph.data;
    var categoryNames = categoriesData.mapArray(categoriesData.getName);
    data.filterSelf(function (idx) {
      var model = data.getItemModel(idx);
      var category = model.getShallow('category');

      if (category != null) {
        if (typeof category === 'number') {
          category = categoryNames[category];
        } // If in any legend component the status is not selected.


        for (var i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(category)) {
            return false;
          }
        }
      }

      return true;
    });
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/graph/categoryVisual.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/graph/categoryVisual.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ categoryVisual)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

function categoryVisual(ecModel) {
  var paletteScope = {};
  ecModel.eachSeriesByType('graph', function (seriesModel) {
    var categoriesData = seriesModel.getCategoriesData();
    var data = seriesModel.getData();
    var categoryNameIdxMap = {};
    categoriesData.each(function (idx) {
      var name = categoriesData.getName(idx); // Add prefix to avoid conflict with Object.prototype.

      categoryNameIdxMap['ec-' + name] = idx;
      var itemModel = categoriesData.getItemModel(idx);
      var style = itemModel.getModel('itemStyle').getItemStyle();

      if (!style.fill) {
        // Get color from palette.
        style.fill = seriesModel.getColorFromPalette(name, paletteScope);
      }

      categoriesData.setItemVisual(idx, 'style', style);
      var symbolVisualList = ['symbol', 'symbolSize', 'symbolKeepAspect'];

      for (var i = 0; i < symbolVisualList.length; i++) {
        var symbolVisual = itemModel.getShallow(symbolVisualList[i], true);

        if (symbolVisual != null) {
          categoriesData.setItemVisual(idx, symbolVisualList[i], symbolVisual);
        }
      }
    }); // Assign category color to visual

    if (categoriesData.count()) {
      data.each(function (idx) {
        var model = data.getItemModel(idx);
        var categoryIdx = model.getShallow('category');

        if (categoryIdx != null) {
          if (typeof categoryIdx === 'string') {
            categoryIdx = categoryNameIdxMap['ec-' + categoryIdx];
          }

          var categoryStyle = categoriesData.getItemVisual(categoryIdx, 'style');
          var style = data.ensureUniqueItemVisual(idx, 'style');
          (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.extend)(style, categoryStyle);
          var visualList = ['symbol', 'symbolSize', 'symbolKeepAspect'];

          for (var i = 0; i < visualList.length; i++) {
            data.setItemVisual(idx, visualList[i], categoriesData.getItemVisual(categoryIdx, visualList[i]));
          }
        }
      });
    }
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/graph/circularLayout.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/graph/circularLayout.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ graphCircularLayout)
/* harmony export */ });
/* harmony import */ var _circularLayoutHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./circularLayoutHelper */ "./node_modules/echarts/lib/chart/graph/circularLayoutHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

function graphCircularLayout(ecModel) {
  ecModel.eachSeriesByType('graph', function (seriesModel) {
    if (seriesModel.get('layout') === 'circular') {
      (0,_circularLayoutHelper__WEBPACK_IMPORTED_MODULE_0__.circularLayout)(seriesModel, 'symbolSize');
    }
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/graph/circularLayoutHelper.js":
/*!**********************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/graph/circularLayoutHelper.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "circularLayout": () => (/* binding */ circularLayout)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/vector */ "./node_modules/zrender/lib/core/vector.js");
/* harmony import */ var _graphHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./graphHelper */ "./node_modules/echarts/lib/chart/graph/graphHelper.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _helper_multipleGraphEdgeHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/multipleGraphEdgeHelper */ "./node_modules/echarts/lib/chart/helper/multipleGraphEdgeHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var PI = Math.PI;
var _symbolRadiansHalf = [];
/**
 * `basedOn` can be:
 * 'value':
 *     This layout is not accurate and have same bad case. For example,
 *     if the min value is very smaller than the max value, the nodes
 *     with the min value probably overlap even though there is enough
 *     space to layout them. So we only use this approach in the as the
 *     init layout of the force layout.
 *     FIXME
 *     Probably we do not need this method any more but use
 *     `basedOn: 'symbolSize'` in force layout if
 *     delay its init operations to GraphView.
 * 'symbolSize':
 *     This approach work only if all of the symbol size calculated.
 *     That is, the progressive rendering is not applied to graph.
 *     FIXME
 *     If progressive rendering is applied to graph some day,
 *     probably we have to use `basedOn: 'value'`.
 */

function circularLayout(seriesModel, basedOn) {
  var coordSys = seriesModel.coordinateSystem;

  if (coordSys && coordSys.type !== 'view') {
    return;
  }

  var rect = coordSys.getBoundingRect();
  var nodeData = seriesModel.getData();
  var graph = nodeData.graph;
  var cx = rect.width / 2 + rect.x;
  var cy = rect.height / 2 + rect.y;
  var r = Math.min(rect.width, rect.height) / 2;
  var count = nodeData.count();
  nodeData.setLayout({
    cx: cx,
    cy: cy
  });

  if (!count) {
    return;
  }

  _layoutNodesBasedOn[basedOn](seriesModel, graph, nodeData, r, cx, cy, count);

  graph.eachEdge(function (edge, index) {
    var curveness = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.retrieve3(edge.getModel().get(['lineStyle', 'curveness']), (0,_helper_multipleGraphEdgeHelper__WEBPACK_IMPORTED_MODULE_1__.getCurvenessForEdge)(edge, seriesModel, index), 0);
    var p1 = zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_2__.clone(edge.node1.getLayout());
    var p2 = zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_2__.clone(edge.node2.getLayout());
    var cp1;
    var x12 = (p1[0] + p2[0]) / 2;
    var y12 = (p1[1] + p2[1]) / 2;

    if (+curveness) {
      curveness *= 3;
      cp1 = [cx * curveness + x12 * (1 - curveness), cy * curveness + y12 * (1 - curveness)];
    }

    edge.setLayout([p1, p2, cp1]);
  });
}
var _layoutNodesBasedOn = {
  value: function (seriesModel, graph, nodeData, r, cx, cy, count) {
    var angle = 0;
    var sum = nodeData.getSum('value');
    var unitAngle = Math.PI * 2 / (sum || count);
    graph.eachNode(function (node) {
      var value = node.getValue('value');
      var radianHalf = unitAngle * (sum ? value : 1) / 2;
      angle += radianHalf;
      node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
      angle += radianHalf;
    });
  },
  symbolSize: function (seriesModel, graph, nodeData, r, cx, cy, count) {
    var sumRadian = 0;
    _symbolRadiansHalf.length = count;
    var nodeScale = (0,_graphHelper__WEBPACK_IMPORTED_MODULE_3__.getNodeGlobalScale)(seriesModel);
    graph.eachNode(function (node) {
      var symbolSize = (0,_graphHelper__WEBPACK_IMPORTED_MODULE_3__.getSymbolSize)(node); // Normally this case will not happen, but we still add
      // some the defensive code (2px is an arbitrary value).

      isNaN(symbolSize) && (symbolSize = 2);
      symbolSize < 0 && (symbolSize = 0);
      symbolSize *= nodeScale;
      var symbolRadianHalf = Math.asin(symbolSize / 2 / r); // when `symbolSize / 2` is bigger than `r`.

      isNaN(symbolRadianHalf) && (symbolRadianHalf = PI / 2);
      _symbolRadiansHalf[node.dataIndex] = symbolRadianHalf;
      sumRadian += symbolRadianHalf * 2;
    });
    var halfRemainRadian = (2 * PI - sumRadian) / count / 2;
    var angle = 0;
    graph.eachNode(function (node) {
      var radianHalf = halfRemainRadian + _symbolRadiansHalf[node.dataIndex];
      angle += radianHalf;
      node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
      angle += radianHalf;
    });
  }
};

/***/ }),

/***/ "./node_modules/echarts/lib/chart/graph/createView.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/graph/createView.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createViewCoordSys)
/* harmony export */ });
/* harmony import */ var _coord_View__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../coord/View */ "./node_modules/echarts/lib/coord/View.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var zrender_lib_core_bbox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/bbox */ "./node_modules/zrender/lib/core/bbox.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// FIXME Where to create the simple view coordinate system





function getViewRect(seriesModel, api, aspect) {
  var option = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.extend)(seriesModel.getBoxLayoutParams(), {
    aspect: aspect
  });
  return (0,_util_layout__WEBPACK_IMPORTED_MODULE_1__.getLayoutRect)(option, {
    width: api.getWidth(),
    height: api.getHeight()
  });
}

function createViewCoordSys(ecModel, api) {
  var viewList = [];
  ecModel.eachSeriesByType('graph', function (seriesModel) {
    var coordSysType = seriesModel.get('coordinateSystem');

    if (!coordSysType || coordSysType === 'view') {
      var data_1 = seriesModel.getData();
      var positions = data_1.mapArray(function (idx) {
        var itemModel = data_1.getItemModel(idx);
        return [+itemModel.get('x'), +itemModel.get('y')];
      });
      var min = [];
      var max = [];
      zrender_lib_core_bbox__WEBPACK_IMPORTED_MODULE_2__.fromPoints(positions, min, max); // If width or height is 0

      if (max[0] - min[0] === 0) {
        max[0] += 1;
        min[0] -= 1;
      }

      if (max[1] - min[1] === 0) {
        max[1] += 1;
        min[1] -= 1;
      }

      var aspect = (max[0] - min[0]) / (max[1] - min[1]); // FIXME If get view rect after data processed?

      var viewRect = getViewRect(seriesModel, api, aspect); // Position may be NaN, use view rect instead

      if (isNaN(aspect)) {
        min = [viewRect.x, viewRect.y];
        max = [viewRect.x + viewRect.width, viewRect.y + viewRect.height];
      }

      var bbWidth = max[0] - min[0];
      var bbHeight = max[1] - min[1];
      var viewWidth = viewRect.width;
      var viewHeight = viewRect.height;
      var viewCoordSys = seriesModel.coordinateSystem = new _coord_View__WEBPACK_IMPORTED_MODULE_3__.default();
      viewCoordSys.zoomLimit = seriesModel.get('scaleLimit');
      viewCoordSys.setBoundingRect(min[0], min[1], bbWidth, bbHeight);
      viewCoordSys.setViewRect(viewRect.x, viewRect.y, viewWidth, viewHeight); // Update roam info

      viewCoordSys.setCenter(seriesModel.get('center'));
      viewCoordSys.setZoom(seriesModel.get('zoom'));
      viewList.push(viewCoordSys);
    }
  });
  return viewList;
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/graph/edgeVisual.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/graph/edgeVisual.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ graphEdgeVisual)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function normalize(a) {
  if (!(a instanceof Array)) {
    a = [a, a];
  }

  return a;
}

function graphEdgeVisual(ecModel) {
  ecModel.eachSeriesByType('graph', function (seriesModel) {
    var graph = seriesModel.getGraph();
    var edgeData = seriesModel.getEdgeData();
    var symbolType = normalize(seriesModel.get('edgeSymbol'));
    var symbolSize = normalize(seriesModel.get('edgeSymbolSize')); // const colorQuery = ['lineStyle', 'color'] as const;
    // const opacityQuery = ['lineStyle', 'opacity'] as const;

    edgeData.setVisual('fromSymbol', symbolType && symbolType[0]);
    edgeData.setVisual('toSymbol', symbolType && symbolType[1]);
    edgeData.setVisual('fromSymbolSize', symbolSize && symbolSize[0]);
    edgeData.setVisual('toSymbolSize', symbolSize && symbolSize[1]);
    edgeData.setVisual('style', seriesModel.getModel('lineStyle').getLineStyle());
    edgeData.each(function (idx) {
      var itemModel = edgeData.getItemModel(idx);
      var edge = graph.getEdgeByIndex(idx);
      var symbolType = normalize(itemModel.getShallow('symbol', true));
      var symbolSize = normalize(itemModel.getShallow('symbolSize', true)); // Edge visual must after node visual

      var style = itemModel.getModel('lineStyle').getLineStyle();
      var existsStyle = edgeData.ensureUniqueItemVisual(idx, 'style');
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.extend)(existsStyle, style);

      switch (existsStyle.stroke) {
        case 'source':
          {
            var nodeStyle = edge.node1.getVisual('style');
            existsStyle.stroke = nodeStyle && nodeStyle.fill;
            break;
          }

        case 'target':
          {
            var nodeStyle = edge.node2.getVisual('style');
            existsStyle.stroke = nodeStyle && nodeStyle.fill;
            break;
          }
      }

      symbolType[0] && edge.setVisual('fromSymbol', symbolType[0]);
      symbolType[1] && edge.setVisual('toSymbol', symbolType[1]);
      symbolSize[0] && edge.setVisual('fromSymbolSize', symbolSize[0]);
      symbolSize[1] && edge.setVisual('toSymbolSize', symbolSize[1]);
    });
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/graph/forceHelper.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/graph/forceHelper.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "forceLayout": () => (/* binding */ forceLayout)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/vector */ "./node_modules/zrender/lib/core/vector.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/*
* A third-party license is embeded for some of the code in this file:
* Some formulas were originally copied from "d3.js" with some
* modifications made for this project.
* (See more details in the comment of the method "step" below.)
* The use of the source code of this file is also subject to the terms
* and consitions of the license of "d3.js" (BSD-3Clause, see
* </licenses/LICENSE-d3>).
*/

var scaleAndAdd = zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.scaleAndAdd; // function adjacentNode(n, e) {
//     return e.n1 === n ? e.n2 : e.n1;
// }

function forceLayout(inNodes, inEdges, opts) {
  var nodes = inNodes;
  var edges = inEdges;
  var rect = opts.rect;
  var width = rect.width;
  var height = rect.height;
  var center = [rect.x + width / 2, rect.y + height / 2]; // let scale = opts.scale || 1;

  var gravity = opts.gravity == null ? 0.1 : opts.gravity; // for (let i = 0; i < edges.length; i++) {
  //     let e = edges[i];
  //     let n1 = e.n1;
  //     let n2 = e.n2;
  //     n1.edges = n1.edges || [];
  //     n2.edges = n2.edges || [];
  //     n1.edges.push(e);
  //     n2.edges.push(e);
  // }
  // Init position

  for (var i = 0; i < nodes.length; i++) {
    var n = nodes[i];

    if (!n.p) {
      n.p = zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.create(width * (Math.random() - 0.5) + center[0], height * (Math.random() - 0.5) + center[1]);
    }

    n.pp = zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.clone(n.p);
    n.edges = null;
  } // Formula in 'Graph Drawing by Force-directed Placement'
  // let k = scale * Math.sqrt(width * height / nodes.length);
  // let k2 = k * k;


  var initialFriction = opts.friction == null ? 0.6 : opts.friction;
  var friction = initialFriction;
  var beforeStepCallback;
  var afterStepCallback;
  return {
    warmUp: function () {
      friction = initialFriction * 0.8;
    },
    setFixed: function (idx) {
      nodes[idx].fixed = true;
    },
    setUnfixed: function (idx) {
      nodes[idx].fixed = false;
    },

    /**
     * Before step hook
     */
    beforeStep: function (cb) {
      beforeStepCallback = cb;
    },

    /**
     * After step hook
     */
    afterStep: function (cb) {
      afterStepCallback = cb;
    },

    /**
     * Some formulas were originally copied from "d3.js"
     * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
     * with some modifications made for this project.
     * See the license statement at the head of this file.
     */
    step: function (cb) {
      beforeStepCallback && beforeStepCallback(nodes, edges);
      var v12 = [];
      var nLen = nodes.length;

      for (var i = 0; i < edges.length; i++) {
        var e = edges[i];

        if (e.ignoreForceLayout) {
          continue;
        }

        var n1 = e.n1;
        var n2 = e.n2;
        zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.sub(v12, n2.p, n1.p);
        var d = zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.len(v12) - e.d;
        var w = n2.w / (n1.w + n2.w);

        if (isNaN(w)) {
          w = 0;
        }

        zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.normalize(v12, v12);
        !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);
        !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);
      } // Gravity


      for (var i = 0; i < nLen; i++) {
        var n = nodes[i];

        if (!n.fixed) {
          zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.sub(v12, center, n.p); // let d = vec2.len(v12);
          // vec2.scale(v12, v12, 1 / d);
          // let gravityFactor = gravity;

          scaleAndAdd(n.p, n.p, v12, gravity * friction);
        }
      } // Repulsive
      // PENDING


      for (var i = 0; i < nLen; i++) {
        var n1 = nodes[i];

        for (var j = i + 1; j < nLen; j++) {
          var n2 = nodes[j];
          zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.sub(v12, n2.p, n1.p);
          var d = zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.len(v12);

          if (d === 0) {
            // Random repulse
            zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.set(v12, Math.random() - 0.5, Math.random() - 0.5);
            d = 1;
          }

          var repFact = (n1.rep + n2.rep) / d / d;
          !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);
          !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);
        }
      }

      var v = [];

      for (var i = 0; i < nLen; i++) {
        var n = nodes[i];

        if (!n.fixed) {
          zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.sub(v, n.p, n.pp);
          scaleAndAdd(n.p, n.p, v, friction);
          zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.copy(n.pp, n.p);
        }
      }

      friction = friction * 0.992;
      var finished = friction < 0.01;
      afterStepCallback && afterStepCallback(nodes, edges, finished);
      cb && cb(finished);
    }
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/graph/forceLayout.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/graph/forceLayout.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ graphForceLayout)
/* harmony export */ });
/* harmony import */ var _forceHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./forceHelper */ "./node_modules/echarts/lib/chart/graph/forceHelper.js");
/* harmony import */ var _simpleLayoutHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simpleLayoutHelper */ "./node_modules/echarts/lib/chart/graph/simpleLayoutHelper.js");
/* harmony import */ var _circularLayoutHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./circularLayoutHelper */ "./node_modules/echarts/lib/chart/graph/circularLayoutHelper.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zrender/lib/core/vector */ "./node_modules/zrender/lib/core/vector.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _helper_multipleGraphEdgeHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helper/multipleGraphEdgeHelper */ "./node_modules/echarts/lib/chart/helper/multipleGraphEdgeHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







function graphForceLayout(ecModel) {
  ecModel.eachSeriesByType('graph', function (graphSeries) {
    var coordSys = graphSeries.coordinateSystem;

    if (coordSys && coordSys.type !== 'view') {
      return;
    }

    if (graphSeries.get('layout') === 'force') {
      var preservedPoints_1 = graphSeries.preservedPoints || {};
      var graph_1 = graphSeries.getGraph();
      var nodeData_1 = graph_1.data;
      var edgeData = graph_1.edgeData;
      var forceModel = graphSeries.getModel('force');
      var initLayout = forceModel.get('initLayout');

      if (graphSeries.preservedPoints) {
        nodeData_1.each(function (idx) {
          var id = nodeData_1.getId(idx);
          nodeData_1.setItemLayout(idx, preservedPoints_1[id] || [NaN, NaN]);
        });
      } else if (!initLayout || initLayout === 'none') {
        (0,_simpleLayoutHelper__WEBPACK_IMPORTED_MODULE_0__.simpleLayout)(graphSeries);
      } else if (initLayout === 'circular') {
        (0,_circularLayoutHelper__WEBPACK_IMPORTED_MODULE_1__.circularLayout)(graphSeries, 'value');
      }

      var nodeDataExtent_1 = nodeData_1.getDataExtent('value');
      var edgeDataExtent_1 = edgeData.getDataExtent('value'); // let edgeDataExtent = edgeData.getDataExtent('value');

      var repulsion = forceModel.get('repulsion');
      var edgeLength = forceModel.get('edgeLength');
      var repulsionArr_1 = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.isArray(repulsion) ? repulsion : [repulsion, repulsion];
      var edgeLengthArr_1 = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.isArray(edgeLength) ? edgeLength : [edgeLength, edgeLength]; // Larger value has smaller length

      edgeLengthArr_1 = [edgeLengthArr_1[1], edgeLengthArr_1[0]];
      var nodes_1 = nodeData_1.mapArray('value', function (value, idx) {
        var point = nodeData_1.getItemLayout(idx);
        var rep = (0,_util_number__WEBPACK_IMPORTED_MODULE_3__.linearMap)(value, nodeDataExtent_1, repulsionArr_1);

        if (isNaN(rep)) {
          rep = (repulsionArr_1[0] + repulsionArr_1[1]) / 2;
        }

        return {
          w: rep,
          rep: rep,
          fixed: nodeData_1.getItemModel(idx).get('fixed'),
          p: !point || isNaN(point[0]) || isNaN(point[1]) ? null : point
        };
      });
      var edges = edgeData.mapArray('value', function (value, idx) {
        var edge = graph_1.getEdgeByIndex(idx);
        var d = (0,_util_number__WEBPACK_IMPORTED_MODULE_3__.linearMap)(value, edgeDataExtent_1, edgeLengthArr_1);

        if (isNaN(d)) {
          d = (edgeLengthArr_1[0] + edgeLengthArr_1[1]) / 2;
        }

        var edgeModel = edge.getModel();
        var curveness = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.retrieve3(edge.getModel().get(['lineStyle', 'curveness']), -(0,_helper_multipleGraphEdgeHelper__WEBPACK_IMPORTED_MODULE_4__.getCurvenessForEdge)(edge, graphSeries, idx, true), 0);
        return {
          n1: nodes_1[edge.node1.dataIndex],
          n2: nodes_1[edge.node2.dataIndex],
          d: d,
          curveness: curveness,
          ignoreForceLayout: edgeModel.get('ignoreForceLayout')
        };
      }); // let coordSys = graphSeries.coordinateSystem;

      var rect = coordSys.getBoundingRect();
      var forceInstance = (0,_forceHelper__WEBPACK_IMPORTED_MODULE_5__.forceLayout)(nodes_1, edges, {
        rect: rect,
        gravity: forceModel.get('gravity'),
        friction: forceModel.get('friction')
      });
      forceInstance.beforeStep(function (nodes, edges) {
        for (var i = 0, l = nodes.length; i < l; i++) {
          if (nodes[i].fixed) {
            // Write back to layout instance
            zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_6__.copy(nodes[i].p, graph_1.getNodeByIndex(i).getLayout());
          }
        }
      });
      forceInstance.afterStep(function (nodes, edges, stopped) {
        for (var i = 0, l = nodes.length; i < l; i++) {
          if (!nodes[i].fixed) {
            graph_1.getNodeByIndex(i).setLayout(nodes[i].p);
          }

          preservedPoints_1[nodeData_1.getId(i)] = nodes[i].p;
        }

        for (var i = 0, l = edges.length; i < l; i++) {
          var e = edges[i];
          var edge = graph_1.getEdgeByIndex(i);
          var p1 = e.n1.p;
          var p2 = e.n2.p;
          var points = edge.getLayout();
          points = points ? points.slice() : [];
          points[0] = points[0] || [];
          points[1] = points[1] || [];
          zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_6__.copy(points[0], p1);
          zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_6__.copy(points[1], p2);

          if (+e.curveness) {
            points[2] = [(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e.curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e.curveness];
          }

          edge.setLayout(points);
        }
      });
      graphSeries.forceLayout = forceInstance;
      graphSeries.preservedPoints = preservedPoints_1; // Step to get the layout

      forceInstance.step();
    } else {
      // Remove prev injected forceLayout instance
      graphSeries.forceLayout = null;
    }
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/graph/graphHelper.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/graph/graphHelper.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getNodeGlobalScale": () => (/* binding */ getNodeGlobalScale),
/* harmony export */   "getSymbolSize": () => (/* binding */ getSymbolSize)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function getNodeGlobalScale(seriesModel) {
  var coordSys = seriesModel.coordinateSystem;

  if (coordSys.type !== 'view') {
    return 1;
  }

  var nodeScaleRatio = seriesModel.option.nodeScaleRatio;
  var groupZoom = coordSys.scaleX; // Scale node when zoom changes

  var roamZoom = coordSys.getZoom();
  var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
  return nodeScale / groupZoom;
}
function getSymbolSize(node) {
  var symbolSize = node.getVisual('symbolSize');

  if (symbolSize instanceof Array) {
    symbolSize = (symbolSize[0] + symbolSize[1]) / 2;
  }

  return +symbolSize;
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/graph/install.js":
/*!*********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/graph/install.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _categoryFilter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./categoryFilter */ "./node_modules/echarts/lib/chart/graph/categoryFilter.js");
/* harmony import */ var _categoryVisual__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./categoryVisual */ "./node_modules/echarts/lib/chart/graph/categoryVisual.js");
/* harmony import */ var _edgeVisual__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./edgeVisual */ "./node_modules/echarts/lib/chart/graph/edgeVisual.js");
/* harmony import */ var _simpleLayout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./simpleLayout */ "./node_modules/echarts/lib/chart/graph/simpleLayout.js");
/* harmony import */ var _circularLayout__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./circularLayout */ "./node_modules/echarts/lib/chart/graph/circularLayout.js");
/* harmony import */ var _forceLayout__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./forceLayout */ "./node_modules/echarts/lib/chart/graph/forceLayout.js");
/* harmony import */ var _createView__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./createView */ "./node_modules/echarts/lib/chart/graph/createView.js");
/* harmony import */ var _coord_View__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../coord/View */ "./node_modules/echarts/lib/coord/View.js");
/* harmony import */ var _GraphView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GraphView */ "./node_modules/echarts/lib/chart/graph/GraphView.js");
/* harmony import */ var _GraphSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GraphSeries */ "./node_modules/echarts/lib/chart/graph/GraphSeries.js");
/* harmony import */ var _action_roamHelper__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../action/roamHelper */ "./node_modules/echarts/lib/action/roamHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/











var actionInfo = {
  type: 'graphRoam',
  event: 'graphRoam',
  update: 'none'
};
function install(registers) {
  registers.registerChartView(_GraphView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerSeriesModel(_GraphSeries__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerProcessor(_categoryFilter__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerVisual(_categoryVisual__WEBPACK_IMPORTED_MODULE_3__.default);
  registers.registerVisual(_edgeVisual__WEBPACK_IMPORTED_MODULE_4__.default);
  registers.registerLayout(_simpleLayout__WEBPACK_IMPORTED_MODULE_5__.default);
  registers.registerLayout(registers.PRIORITY.VISUAL.POST_CHART_LAYOUT, _circularLayout__WEBPACK_IMPORTED_MODULE_6__.default);
  registers.registerLayout(_forceLayout__WEBPACK_IMPORTED_MODULE_7__.default);
  registers.registerCoordinateSystem('graphView', {
    dimensions: _coord_View__WEBPACK_IMPORTED_MODULE_8__.default.dimensions,
    create: _createView__WEBPACK_IMPORTED_MODULE_9__.default
  }); // Register legacy focus actions

  registers.registerAction({
    type: 'focusNodeAdjacency',
    event: 'focusNodeAdjacency',
    update: 'series:focusNodeAdjacency'
  }, function () {});
  registers.registerAction({
    type: 'unfocusNodeAdjacency',
    event: 'unfocusNodeAdjacency',
    update: 'series:unfocusNodeAdjacency'
  }, function () {}); // Register roam action.

  registers.registerAction(actionInfo, function (payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'series',
      query: payload
    }, function (seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var res = (0,_action_roamHelper__WEBPACK_IMPORTED_MODULE_10__.updateCenterAndZoom)(coordSys, payload);
      seriesModel.setCenter && seriesModel.setCenter(res.center);
      seriesModel.setZoom && seriesModel.setZoom(res.zoom);
    });
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/graph/simpleLayout.js":
/*!**************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/graph/simpleLayout.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ graphSimpleLayout)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _simpleLayoutHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simpleLayoutHelper */ "./node_modules/echarts/lib/chart/graph/simpleLayoutHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function graphSimpleLayout(ecModel, api) {
  ecModel.eachSeriesByType('graph', function (seriesModel) {
    var layout = seriesModel.get('layout');
    var coordSys = seriesModel.coordinateSystem;

    if (coordSys && coordSys.type !== 'view') {
      var data_1 = seriesModel.getData();
      var dimensions_1 = [];
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(coordSys.dimensions, function (coordDim) {
        dimensions_1 = dimensions_1.concat(data_1.mapDimensionsAll(coordDim));
      });

      for (var dataIndex = 0; dataIndex < data_1.count(); dataIndex++) {
        var value = [];
        var hasValue = false;

        for (var i = 0; i < dimensions_1.length; i++) {
          var val = data_1.get(dimensions_1[i], dataIndex);

          if (!isNaN(val)) {
            hasValue = true;
          }

          value.push(val);
        }

        if (hasValue) {
          data_1.setItemLayout(dataIndex, coordSys.dataToPoint(value));
        } else {
          // Also {Array.<number>}, not undefined to avoid if...else... statement
          data_1.setItemLayout(dataIndex, [NaN, NaN]);
        }
      }

      (0,_simpleLayoutHelper__WEBPACK_IMPORTED_MODULE_1__.simpleLayoutEdge)(data_1.graph, seriesModel);
    } else if (!layout || layout === 'none') {
      (0,_simpleLayoutHelper__WEBPACK_IMPORTED_MODULE_1__.simpleLayout)(seriesModel);
    }
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/graph/simpleLayoutHelper.js":
/*!********************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/graph/simpleLayoutHelper.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "simpleLayout": () => (/* binding */ simpleLayout),
/* harmony export */   "simpleLayoutEdge": () => (/* binding */ simpleLayoutEdge)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/vector */ "./node_modules/zrender/lib/core/vector.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _helper_multipleGraphEdgeHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/multipleGraphEdgeHelper */ "./node_modules/echarts/lib/chart/helper/multipleGraphEdgeHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function simpleLayout(seriesModel) {
  var coordSys = seriesModel.coordinateSystem;

  if (coordSys && coordSys.type !== 'view') {
    return;
  }

  var graph = seriesModel.getGraph();
  graph.eachNode(function (node) {
    var model = node.getModel();
    node.setLayout([+model.get('x'), +model.get('y')]);
  });
  simpleLayoutEdge(graph, seriesModel);
}
function simpleLayoutEdge(graph, seriesModel) {
  graph.eachEdge(function (edge, index) {
    var curveness = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.retrieve3(edge.getModel().get(['lineStyle', 'curveness']), -(0,_helper_multipleGraphEdgeHelper__WEBPACK_IMPORTED_MODULE_1__.getCurvenessForEdge)(edge, seriesModel, index, true), 0);
    var p1 = zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_2__.clone(edge.node1.getLayout());
    var p2 = zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_2__.clone(edge.node2.getLayout());
    var points = [p1, p2];

    if (+curveness) {
      points.push([(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness]);
    }

    edge.setLayout(points);
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/heatmap/HeatmapLayer.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/heatmap/HeatmapLayer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/* global Uint8ClampedArray */

var GRADIENT_LEVELS = 256;

var HeatmapLayer =
/** @class */
function () {
  function HeatmapLayer() {
    this.blurSize = 30;
    this.pointSize = 20;
    this.maxOpacity = 1;
    this.minOpacity = 0;
    this._gradientPixels = {
      inRange: null,
      outOfRange: null
    };
    var canvas = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.createCanvas();
    this.canvas = canvas;
  }
  /**
   * Renders Heatmap and returns the rendered canvas
   * @param data array of data, each has x, y, value
   * @param width canvas width
   * @param height canvas height
   */


  HeatmapLayer.prototype.update = function (data, width, height, normalize, colorFunc, isInRange) {
    var brush = this._getBrush();

    var gradientInRange = this._getGradient(colorFunc, 'inRange');

    var gradientOutOfRange = this._getGradient(colorFunc, 'outOfRange');

    var r = this.pointSize + this.blurSize;
    var canvas = this.canvas;
    var ctx = canvas.getContext('2d');
    var len = data.length;
    canvas.width = width;
    canvas.height = height;

    for (var i = 0; i < len; ++i) {
      var p = data[i];
      var x = p[0];
      var y = p[1];
      var value = p[2]; // calculate alpha using value

      var alpha = normalize(value); // draw with the circle brush with alpha

      ctx.globalAlpha = alpha;
      ctx.drawImage(brush, x - r, y - r);
    }

    if (!canvas.width || !canvas.height) {
      // Avoid "Uncaught DOMException: Failed to execute 'getImageData' on
      // 'CanvasRenderingContext2D': The source height is 0."
      return canvas;
    } // colorize the canvas using alpha value and set with gradient


    var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    var pixels = imageData.data;
    var offset = 0;
    var pixelLen = pixels.length;
    var minOpacity = this.minOpacity;
    var maxOpacity = this.maxOpacity;
    var diffOpacity = maxOpacity - minOpacity;

    while (offset < pixelLen) {
      var alpha = pixels[offset + 3] / 256;
      var gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4; // Simple optimize to ignore the empty data

      if (alpha > 0) {
        var gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange; // Any alpha > 0 will be mapped to [minOpacity, maxOpacity]

        alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);
        pixels[offset++] = gradient[gradientOffset];
        pixels[offset++] = gradient[gradientOffset + 1];
        pixels[offset++] = gradient[gradientOffset + 2];
        pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;
      } else {
        offset += 4;
      }
    }

    ctx.putImageData(imageData, 0, 0);
    return canvas;
  };
  /**
   * get canvas of a black circle brush used for canvas to draw later
   */


  HeatmapLayer.prototype._getBrush = function () {
    var brushCanvas = this._brushCanvas || (this._brushCanvas = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.createCanvas()); // set brush size

    var r = this.pointSize + this.blurSize;
    var d = r * 2;
    brushCanvas.width = d;
    brushCanvas.height = d;
    var ctx = brushCanvas.getContext('2d');
    ctx.clearRect(0, 0, d, d); // in order to render shadow without the distinct circle,
    // draw the distinct circle in an invisible place,
    // and use shadowOffset to draw shadow in the center of the canvas

    ctx.shadowOffsetX = d;
    ctx.shadowBlur = this.blurSize; // draw the shadow in black, and use alpha and shadow blur to generate
    // color in color map

    ctx.shadowColor = '#000'; // draw circle in the left to the canvas

    ctx.beginPath();
    ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
    return brushCanvas;
  };
  /**
   * get gradient color map
   * @private
   */


  HeatmapLayer.prototype._getGradient = function (colorFunc, state) {
    var gradientPixels = this._gradientPixels;
    var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));
    var color = [0, 0, 0, 0];
    var off = 0;

    for (var i = 0; i < 256; i++) {
      colorFunc[state](i / 255, true, color);
      pixelsSingleState[off++] = color[0];
      pixelsSingleState[off++] = color[1];
      pixelsSingleState[off++] = color[2];
      pixelsSingleState[off++] = color[3];
    }

    return pixelsSingleState;
  };

  return HeatmapLayer;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HeatmapLayer);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/heatmap/HeatmapSeries.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/heatmap/HeatmapSeries.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var _helper_createListFromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/createListFromArray */ "./node_modules/echarts/lib/chart/helper/createListFromArray.js");
/* harmony import */ var _core_CoordinateSystem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/CoordinateSystem */ "./node_modules/echarts/lib/core/CoordinateSystem.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var HeatmapSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(HeatmapSeriesModel, _super);

  function HeatmapSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = HeatmapSeriesModel.type;
    return _this;
  }

  HeatmapSeriesModel.prototype.getInitialData = function (option, ecModel) {
    return (0,_helper_createListFromArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.getSource(), this, {
      generateCoord: 'value'
    });
  };

  HeatmapSeriesModel.prototype.preventIncremental = function () {
    var coordSysCreator = _core_CoordinateSystem__WEBPACK_IMPORTED_MODULE_2__.default.get(this.get('coordinateSystem'));

    if (coordSysCreator && coordSysCreator.dimensions) {
      return coordSysCreator.dimensions[0] === 'lng' && coordSysCreator.dimensions[1] === 'lat';
    }
  };

  HeatmapSeriesModel.type = 'series.heatmap';
  HeatmapSeriesModel.dependencies = ['grid', 'geo', 'calendar'];
  HeatmapSeriesModel.defaultOption = {
    coordinateSystem: 'cartesian2d',
    zlevel: 0,
    z: 2,
    // Cartesian coordinate system
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    // Geo coordinate system
    geoIndex: 0,
    blurSize: 30,
    pointSize: 20,
    maxOpacity: 1,
    minOpacity: 0,
    select: {
      itemStyle: {
        borderColor: '#212121'
      }
    }
  };
  return HeatmapSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_3__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HeatmapSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/heatmap/HeatmapView.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/heatmap/HeatmapView.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Image.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _HeatmapLayer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./HeatmapLayer */ "./node_modules/echarts/lib/chart/heatmap/HeatmapLayer.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _coord_CoordinateSystem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../coord/CoordinateSystem */ "./node_modules/echarts/lib/coord/CoordinateSystem.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/









function getIsInPiecewiseRange(dataExtent, pieceList, selected) {
  var dataSpan = dataExtent[1] - dataExtent[0];
  pieceList = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map(pieceList, function (piece) {
    return {
      interval: [(piece.interval[0] - dataExtent[0]) / dataSpan, (piece.interval[1] - dataExtent[0]) / dataSpan]
    };
  });
  var len = pieceList.length;
  var lastIndex = 0;
  return function (val) {
    var i; // Try to find in the location of the last found

    for (i = lastIndex; i < len; i++) {
      var interval = pieceList[i].interval;

      if (interval[0] <= val && val <= interval[1]) {
        lastIndex = i;
        break;
      }
    }

    if (i === len) {
      // Not found, back interation
      for (i = lastIndex - 1; i >= 0; i--) {
        var interval = pieceList[i].interval;

        if (interval[0] <= val && val <= interval[1]) {
          lastIndex = i;
          break;
        }
      }
    }

    return i >= 0 && i < len && selected[i];
  };
}

function getIsInContinuousRange(dataExtent, range) {
  var dataSpan = dataExtent[1] - dataExtent[0];
  range = [(range[0] - dataExtent[0]) / dataSpan, (range[1] - dataExtent[0]) / dataSpan];
  return function (val) {
    return val >= range[0] && val <= range[1];
  };
}

function isGeoCoordSys(coordSys) {
  var dimensions = coordSys.dimensions; // Not use coorSys.type === 'geo' because coordSys maybe extended

  return dimensions[0] === 'lng' && dimensions[1] === 'lat';
}

var HeatmapView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(HeatmapView, _super);

  function HeatmapView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = HeatmapView.type;
    return _this;
  }

  HeatmapView.prototype.render = function (seriesModel, ecModel, api) {
    var visualMapOfThisSeries;
    ecModel.eachComponent('visualMap', function (visualMap) {
      visualMap.eachTargetSeries(function (targetSeries) {
        if (targetSeries === seriesModel) {
          visualMapOfThisSeries = visualMap;
        }
      });
    });

    if (true) {
      if (!visualMapOfThisSeries) {
        throw new Error('Heatmap must use with visualMap');
      }
    }

    this.group.removeAll();
    this._incrementalDisplayable = null;
    var coordSys = seriesModel.coordinateSystem;

    if (coordSys.type === 'cartesian2d' || coordSys.type === 'calendar') {
      this._renderOnCartesianAndCalendar(seriesModel, api, 0, seriesModel.getData().count());
    } else if (isGeoCoordSys(coordSys)) {
      this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api);
    }
  };

  HeatmapView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {
    this.group.removeAll();
  };

  HeatmapView.prototype.incrementalRender = function (params, seriesModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;

    if (coordSys) {
      // geo does not support incremental rendering?
      if (isGeoCoordSys(coordSys)) {
        this.render(seriesModel, ecModel, api);
      } else {
        this._renderOnCartesianAndCalendar(seriesModel, api, params.start, params.end, true);
      }
    }
  };

  HeatmapView.prototype._renderOnCartesianAndCalendar = function (seriesModel, api, start, end, incremental) {
    var coordSys = seriesModel.coordinateSystem;
    var width;
    var height;
    var xAxisExtent;
    var yAxisExtent;

    if ((0,_coord_CoordinateSystem__WEBPACK_IMPORTED_MODULE_2__.isCoordinateSystemType)(coordSys, 'cartesian2d')) {
      var xAxis = coordSys.getAxis('x');
      var yAxis = coordSys.getAxis('y');

      if (true) {
        if (!(xAxis.type === 'category' && yAxis.type === 'category')) {
          throw new Error('Heatmap on cartesian must have two category axes');
        }

        if (!(xAxis.onBand && yAxis.onBand)) {
          throw new Error('Heatmap on cartesian must have two axes with boundaryGap true');
        }
      }

      width = xAxis.getBandWidth();
      height = yAxis.getBandWidth();
      xAxisExtent = xAxis.scale.getExtent();
      yAxisExtent = yAxis.scale.getExtent();
    }

    var group = this.group;
    var data = seriesModel.getData();
    var emphasisStyle = seriesModel.getModel(['emphasis', 'itemStyle']).getItemStyle();
    var blurStyle = seriesModel.getModel(['blur', 'itemStyle']).getItemStyle();
    var selectStyle = seriesModel.getModel(['select', 'itemStyle']).getItemStyle();
    var labelStatesModels = (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_3__.getLabelStatesModels)(seriesModel);
    var focus = seriesModel.get(['emphasis', 'focus']);
    var blurScope = seriesModel.get(['emphasis', 'blurScope']);
    var dataDims = (0,_coord_CoordinateSystem__WEBPACK_IMPORTED_MODULE_2__.isCoordinateSystemType)(coordSys, 'cartesian2d') ? [data.mapDimension('x'), data.mapDimension('y'), data.mapDimension('value')] : [data.mapDimension('time'), data.mapDimension('value')];

    for (var idx = start; idx < end; idx++) {
      var rect = void 0;
      var style = data.getItemVisual(idx, 'style');

      if ((0,_coord_CoordinateSystem__WEBPACK_IMPORTED_MODULE_2__.isCoordinateSystemType)(coordSys, 'cartesian2d')) {
        var dataDimX = data.get(dataDims[0], idx);
        var dataDimY = data.get(dataDims[1], idx); // Ignore empty data and out of extent data

        if (isNaN(data.get(dataDims[2], idx)) || dataDimX < xAxisExtent[0] || dataDimX > xAxisExtent[1] || dataDimY < yAxisExtent[0] || dataDimY > yAxisExtent[1]) {
          continue;
        }

        var point = coordSys.dataToPoint([dataDimX, dataDimY]);
        rect = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default({
          shape: {
            x: Math.floor(Math.round(point[0]) - width / 2),
            y: Math.floor(Math.round(point[1]) - height / 2),
            width: Math.ceil(width),
            height: Math.ceil(height)
          },
          style: style
        });
      } else {
        // Ignore empty data
        if (isNaN(data.get(dataDims[1], idx))) {
          continue;
        }

        rect = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default({
          z2: 1,
          shape: coordSys.dataToRect([data.get(dataDims[0], idx)]).contentShape,
          style: style
        });
      }

      var itemModel = data.getItemModel(idx); // Optimization for large datset

      if (data.hasItemOption) {
        var emphasisModel = itemModel.getModel('emphasis');
        emphasisStyle = emphasisModel.getModel('itemStyle').getItemStyle();
        blurStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle();
        selectStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle();
        focus = emphasisModel.get('focus');
        blurScope = emphasisModel.get('blurScope');
        labelStatesModels = (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_3__.getLabelStatesModels)(itemModel);
      }

      var rawValue = seriesModel.getRawValue(idx);
      var defaultText = '-';

      if (rawValue && rawValue[2] != null) {
        defaultText = rawValue[2] + '';
      }

      (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_3__.setLabelStyle)(rect, labelStatesModels, {
        labelFetcher: seriesModel,
        labelDataIndex: idx,
        defaultOpacity: style.opacity,
        defaultText: defaultText
      });
      rect.ensureState('emphasis').style = emphasisStyle;
      rect.ensureState('blur').style = blurStyle;
      rect.ensureState('select').style = selectStyle;
      (0,_util_states__WEBPACK_IMPORTED_MODULE_5__.enableHoverEmphasis)(rect, focus, blurScope);
      rect.incremental = incremental; // PENDING

      if (incremental) {
        // Rect must use hover layer if it's incremental.
        rect.states.emphasis.hoverLayer = true;
      }

      group.add(rect);
      data.setItemGraphicEl(idx, rect);
    }
  };

  HeatmapView.prototype._renderOnGeo = function (geo, seriesModel, visualMapModel, api) {
    var inRangeVisuals = visualMapModel.targetVisuals.inRange;
    var outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange; // if (!visualMapping) {
    //     throw new Error('Data range must have color visuals');
    // }

    var data = seriesModel.getData();
    var hmLayer = this._hmLayer || this._hmLayer || new _HeatmapLayer__WEBPACK_IMPORTED_MODULE_6__.default();
    hmLayer.blurSize = seriesModel.get('blurSize');
    hmLayer.pointSize = seriesModel.get('pointSize');
    hmLayer.minOpacity = seriesModel.get('minOpacity');
    hmLayer.maxOpacity = seriesModel.get('maxOpacity');
    var rect = geo.getViewRect().clone();
    var roamTransform = geo.getRoamTransform();
    rect.applyTransform(roamTransform); // Clamp on viewport

    var x = Math.max(rect.x, 0);
    var y = Math.max(rect.y, 0);
    var x2 = Math.min(rect.width + rect.x, api.getWidth());
    var y2 = Math.min(rect.height + rect.y, api.getHeight());
    var width = x2 - x;
    var height = y2 - y;
    var dims = [data.mapDimension('lng'), data.mapDimension('lat'), data.mapDimension('value')];
    var points = data.mapArray(dims, function (lng, lat, value) {
      var pt = geo.dataToPoint([lng, lat]);
      pt[0] -= x;
      pt[1] -= y;
      pt.push(value);
      return pt;
    });
    var dataExtent = visualMapModel.getExtent();
    var isInRange = visualMapModel.type === 'visualMap.continuous' ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);
    hmLayer.update(points, width, height, inRangeVisuals.color.getNormalizer(), {
      inRange: inRangeVisuals.color.getColorMapper(),
      outOfRange: outOfRangeVisuals.color.getColorMapper()
    }, isInRange);
    var img = new _util_graphic__WEBPACK_IMPORTED_MODULE_7__.default({
      style: {
        width: width,
        height: height,
        x: x,
        y: y,
        image: hmLayer.canvas
      },
      silent: true
    });
    this.group.add(img);
  };

  HeatmapView.type = 'heatmap';
  return HeatmapView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_8__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HeatmapView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/heatmap/install.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/heatmap/install.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _HeatmapView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HeatmapView */ "./node_modules/echarts/lib/chart/heatmap/HeatmapView.js");
/* harmony import */ var _HeatmapSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HeatmapSeries */ "./node_modules/echarts/lib/chart/heatmap/HeatmapSeries.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function install(registers) {
  registers.registerChartView(_HeatmapView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerSeriesModel(_HeatmapSeries__WEBPACK_IMPORTED_MODULE_1__.default);
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/EffectLine.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/EffectLine.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _Line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Line */ "./node_modules/echarts/lib/chart/helper/Line.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/symbol */ "./node_modules/echarts/lib/util/symbol.js");
/* harmony import */ var zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/vector */ "./node_modules/zrender/lib/core/vector.js");
/* harmony import */ var zrender_lib_core_curve__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/core/curve */ "./node_modules/zrender/lib/core/curve.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Provide effect for line
 */








var EffectLine =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(EffectLine, _super);

  function EffectLine(lineData, idx, seriesScope) {
    var _this = _super.call(this) || this;

    _this.add(_this.createLine(lineData, idx, seriesScope));

    _this._updateEffectSymbol(lineData, idx);

    return _this;
  }

  EffectLine.prototype.createLine = function (lineData, idx, seriesScope) {
    return new _Line__WEBPACK_IMPORTED_MODULE_1__.default(lineData, idx, seriesScope);
  };

  EffectLine.prototype._updateEffectSymbol = function (lineData, idx) {
    var itemModel = lineData.getItemModel(idx);
    var effectModel = itemModel.getModel('effect');
    var size = effectModel.get('symbolSize');
    var symbolType = effectModel.get('symbol');

    if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.isArray(size)) {
      size = [size, size];
    }

    var lineStyle = lineData.getItemVisual(idx, 'style');
    var color = effectModel.get('color') || lineStyle && lineStyle.stroke;
    var symbol = this.childAt(1);

    if (this._symbolType !== symbolType) {
      // Remove previous
      this.remove(symbol);
      symbol = (0,_util_symbol__WEBPACK_IMPORTED_MODULE_3__.createSymbol)(symbolType, -0.5, -0.5, 1, 1, color);
      symbol.z2 = 100;
      symbol.culling = true;
      this.add(symbol);
    } // Symbol may be removed if loop is false


    if (!symbol) {
      return;
    } // Shadow color is same with color in default


    symbol.setStyle('shadowColor', color);
    symbol.setStyle(effectModel.getItemStyle(['color']));
    symbol.scaleX = size[0];
    symbol.scaleY = size[1];
    symbol.setColor(color);
    this._symbolType = symbolType;
    this._symbolScale = size;

    this._updateEffectAnimation(lineData, effectModel, idx);
  };

  EffectLine.prototype._updateEffectAnimation = function (lineData, effectModel, idx) {
    var symbol = this.childAt(1);

    if (!symbol) {
      return;
    }

    var self = this;
    var points = lineData.getItemLayout(idx);
    var period = effectModel.get('period') * 1000;
    var loop = effectModel.get('loop');
    var constantSpeed = effectModel.get('constantSpeed');
    var delayExpr = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.retrieve(effectModel.get('delay'), function (idx) {
      return idx / lineData.count() * period / 3;
    }); // Ignore when updating

    symbol.ignore = true;

    this._updateAnimationPoints(symbol, points);

    if (constantSpeed > 0) {
      period = this._getLineLength(symbol) / constantSpeed * 1000;
    }

    if (period !== this._period || loop !== this._loop) {
      symbol.stopAnimation();

      if (period > 0) {
        var delayNum = void 0;

        if (typeof delayExpr === 'function') {
          delayNum = delayExpr(idx);
        } else {
          delayNum = delayExpr;
        }

        if (symbol.__t > 0) {
          delayNum = -period * symbol.__t;
        }

        symbol.__t = 0;
        var animator = symbol.animate('', loop).when(period, {
          __t: 1
        }).delay(delayNum).during(function () {
          self._updateSymbolPosition(symbol);
        });

        if (!loop) {
          animator.done(function () {
            self.remove(symbol);
          });
        }

        animator.start();
      }
    }

    this._period = period;
    this._loop = loop;
  };

  EffectLine.prototype._getLineLength = function (symbol) {
    // Not so accurate
    return zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_4__.dist(symbol.__p1, symbol.__cp1) + zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_4__.dist(symbol.__cp1, symbol.__p2);
  };

  EffectLine.prototype._updateAnimationPoints = function (symbol, points) {
    symbol.__p1 = points[0];
    symbol.__p2 = points[1];
    symbol.__cp1 = points[2] || [(points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2];
  };

  EffectLine.prototype.updateData = function (lineData, idx, seriesScope) {
    this.childAt(0).updateData(lineData, idx, seriesScope);

    this._updateEffectSymbol(lineData, idx);
  };

  EffectLine.prototype._updateSymbolPosition = function (symbol) {
    var p1 = symbol.__p1;
    var p2 = symbol.__p2;
    var cp1 = symbol.__cp1;
    var t = symbol.__t;
    var pos = [symbol.x, symbol.y];
    var lastPos = pos.slice();
    var quadraticAt = zrender_lib_core_curve__WEBPACK_IMPORTED_MODULE_5__.quadraticAt;
    var quadraticDerivativeAt = zrender_lib_core_curve__WEBPACK_IMPORTED_MODULE_5__.quadraticDerivativeAt;
    pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);
    pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t); // Tangent

    var tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);
    var ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
    symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2; // enable continuity trail for 'line', 'rect', 'roundRect' symbolType

    if (this._symbolType === 'line' || this._symbolType === 'rect' || this._symbolType === 'roundRect') {
      if (symbol.__lastT !== undefined && symbol.__lastT < symbol.__t) {
        symbol.scaleY = zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_4__.dist(lastPos, pos) * 1.05; // make sure the last segment render within endPoint

        if (t === 1) {
          pos[0] = lastPos[0] + (pos[0] - lastPos[0]) / 2;
          pos[1] = lastPos[1] + (pos[1] - lastPos[1]) / 2;
        }
      } else if (symbol.__lastT === 1) {
        // After first loop, symbol.__t does NOT start with 0, so connect p1 to pos directly.
        symbol.scaleY = 2 * zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_4__.dist(p1, pos);
      } else {
        symbol.scaleY = this._symbolScale[1];
      }
    }

    symbol.__lastT = symbol.__t;
    symbol.ignore = false;
    symbol.x = pos[0];
    symbol.y = pos[1];
  };

  EffectLine.prototype.updateLayout = function (lineData, idx) {
    this.childAt(0).updateLayout(lineData, idx);
    var effectModel = lineData.getItemModel(idx).getModel('effect');

    this._updateEffectAnimation(lineData, effectModel, idx);
  };

  return EffectLine;
}(_util_graphic__WEBPACK_IMPORTED_MODULE_6__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EffectLine);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/EffectPolyline.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/EffectPolyline.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Polyline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Polyline */ "./node_modules/echarts/lib/chart/helper/Polyline.js");
/* harmony import */ var _EffectLine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EffectLine */ "./node_modules/echarts/lib/chart/helper/EffectLine.js");
/* harmony import */ var zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/vector */ "./node_modules/zrender/lib/core/vector.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var EffectPolyline =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(EffectPolyline, _super);

  function EffectPolyline() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this._lastFrame = 0;
    _this._lastFramePercent = 0;
    return _this;
  } // Override


  EffectPolyline.prototype.createLine = function (lineData, idx, seriesScope) {
    return new _Polyline__WEBPACK_IMPORTED_MODULE_1__.default(lineData, idx, seriesScope);
  };

  ; // Override

  EffectPolyline.prototype._updateAnimationPoints = function (symbol, points) {
    this._points = points;
    var accLenArr = [0];
    var len = 0;

    for (var i = 1; i < points.length; i++) {
      var p1 = points[i - 1];
      var p2 = points[i];
      len += zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_2__.dist(p1, p2);
      accLenArr.push(len);
    }

    if (len === 0) {
      this._length = 0;
      return;
    }

    for (var i = 0; i < accLenArr.length; i++) {
      accLenArr[i] /= len;
    }

    this._offsets = accLenArr;
    this._length = len;
  };

  ; // Override

  EffectPolyline.prototype._getLineLength = function () {
    return this._length;
  };

  ; // Override

  EffectPolyline.prototype._updateSymbolPosition = function (symbol) {
    var t = symbol.__t;
    var points = this._points;
    var offsets = this._offsets;
    var len = points.length;

    if (!offsets) {
      // Has length 0
      return;
    }

    var lastFrame = this._lastFrame;
    var frame;

    if (t < this._lastFramePercent) {
      // Start from the next frame
      // PENDING start from lastFrame ?
      var start = Math.min(lastFrame + 1, len - 1);

      for (frame = start; frame >= 0; frame--) {
        if (offsets[frame] <= t) {
          break;
        }
      } // PENDING really need to do this ?


      frame = Math.min(frame, len - 2);
    } else {
      for (frame = lastFrame; frame < len; frame++) {
        if (offsets[frame] > t) {
          break;
        }
      }

      frame = Math.min(frame - 1, len - 2);
    }

    var p = (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame]);
    var p0 = points[frame];
    var p1 = points[frame + 1];
    symbol.x = p0[0] * (1 - p) + p * p1[0];
    symbol.y = p0[1] * (1 - p) + p * p1[1];
    var tx = p1[0] - p0[0];
    var ty = p1[1] - p0[1];
    symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
    this._lastFrame = frame;
    this._lastFramePercent = t;
    symbol.ignore = false;
  };

  ;
  return EffectPolyline;
}(_EffectLine__WEBPACK_IMPORTED_MODULE_3__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EffectPolyline);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/EffectSymbol.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/EffectSymbol.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_symbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/symbol */ "./node_modules/echarts/lib/util/symbol.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _Symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Symbol */ "./node_modules/echarts/lib/chart/helper/Symbol.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







var EFFECT_RIPPLE_NUMBER = 3;

function normalizeSymbolSize(symbolSize) {
  if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(symbolSize)) {
    symbolSize = [+symbolSize, +symbolSize];
  }

  return symbolSize;
}

function updateRipplePath(rippleGroup, effectCfg) {
  var color = effectCfg.rippleEffectColor || effectCfg.color;
  rippleGroup.eachChild(function (ripplePath) {
    ripplePath.attr({
      z: effectCfg.z,
      zlevel: effectCfg.zlevel,
      style: {
        stroke: effectCfg.brushType === 'stroke' ? color : null,
        fill: effectCfg.brushType === 'fill' ? color : null
      }
    });
  });
}

var EffectSymbol =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(EffectSymbol, _super);

  function EffectSymbol(data, idx) {
    var _this = _super.call(this) || this;

    var symbol = new _Symbol__WEBPACK_IMPORTED_MODULE_2__.default(data, idx);
    var rippleGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default();

    _this.add(symbol);

    _this.add(rippleGroup);

    _this.updateData(data, idx);

    return _this;
  }

  EffectSymbol.prototype.stopEffectAnimation = function () {
    this.childAt(1).removeAll();
  };

  EffectSymbol.prototype.startEffectAnimation = function (effectCfg) {
    var symbolType = effectCfg.symbolType;
    var color = effectCfg.color;
    var rippleGroup = this.childAt(1);

    for (var i = 0; i < EFFECT_RIPPLE_NUMBER; i++) {
      // If width/height are set too small (e.g., set to 1) on ios10
      // and macOS Sierra, a circle stroke become a rect, no matter what
      // the scale is set. So we set width/height as 2. See #4136.
      var ripplePath = (0,_util_symbol__WEBPACK_IMPORTED_MODULE_4__.createSymbol)(symbolType, -1, -1, 2, 2, color);
      ripplePath.attr({
        style: {
          strokeNoScale: true
        },
        z2: 99,
        silent: true,
        scaleX: 0.5,
        scaleY: 0.5
      });
      var delay = -i / EFFECT_RIPPLE_NUMBER * effectCfg.period + effectCfg.effectOffset; // TODO Configurable effectCfg.period

      ripplePath.animate('', true).when(effectCfg.period, {
        scale: [effectCfg.rippleScale / 2, effectCfg.rippleScale / 2]
      }).delay(delay).start();
      ripplePath.animateStyle(true).when(effectCfg.period, {
        opacity: 0
      }).delay(delay).start();
      rippleGroup.add(ripplePath);
    }

    updateRipplePath(rippleGroup, effectCfg);
  };
  /**
   * Update effect symbol
   */


  EffectSymbol.prototype.updateEffectAnimation = function (effectCfg) {
    var oldEffectCfg = this._effectCfg;
    var rippleGroup = this.childAt(1); // Must reinitialize effect if following configuration changed

    var DIFFICULT_PROPS = ['symbolType', 'period', 'rippleScale'];

    for (var i = 0; i < DIFFICULT_PROPS.length; i++) {
      var propName = DIFFICULT_PROPS[i];

      if (oldEffectCfg[propName] !== effectCfg[propName]) {
        this.stopEffectAnimation();
        this.startEffectAnimation(effectCfg);
        return;
      }
    }

    updateRipplePath(rippleGroup, effectCfg);
  };
  /**
   * Highlight symbol
   */


  EffectSymbol.prototype.highlight = function () {
    (0,_util_states__WEBPACK_IMPORTED_MODULE_5__.enterEmphasis)(this);
  };
  /**
   * Downplay symbol
   */


  EffectSymbol.prototype.downplay = function () {
    (0,_util_states__WEBPACK_IMPORTED_MODULE_5__.leaveEmphasis)(this);
  };
  /**
   * Update symbol properties
   */


  EffectSymbol.prototype.updateData = function (data, idx) {
    var _this = this;

    var seriesModel = data.hostModel;
    this.childAt(0).updateData(data, idx);
    var rippleGroup = this.childAt(1);
    var itemModel = data.getItemModel(idx);
    var symbolType = data.getItemVisual(idx, 'symbol');
    var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));
    var symbolStyle = data.getItemVisual(idx, 'style');
    var color = symbolStyle && symbolStyle.fill;
    rippleGroup.setScale(symbolSize);
    rippleGroup.traverse(function (ripplePath) {
      ripplePath.setStyle('fill', color);
    });
    var symbolOffset = itemModel.getShallow('symbolOffset');

    if (symbolOffset) {
      rippleGroup.x = (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.parsePercent)(symbolOffset[0], symbolSize[0]);
      rippleGroup.y = (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.parsePercent)(symbolOffset[1], symbolSize[1]);
    }

    var symbolRotate = data.getItemVisual(idx, 'symbolRotate');
    rippleGroup.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
    var effectCfg = {};
    effectCfg.showEffectOn = seriesModel.get('showEffectOn');
    effectCfg.rippleScale = itemModel.get(['rippleEffect', 'scale']);
    effectCfg.brushType = itemModel.get(['rippleEffect', 'brushType']);
    effectCfg.period = itemModel.get(['rippleEffect', 'period']) * 1000;
    effectCfg.effectOffset = idx / data.count();
    effectCfg.z = seriesModel.getShallow('z') || 0;
    effectCfg.zlevel = seriesModel.getShallow('zlevel') || 0;
    effectCfg.symbolType = symbolType;
    effectCfg.color = color;
    effectCfg.rippleEffectColor = itemModel.get(['rippleEffect', 'color']);
    this.off('mouseover').off('mouseout').off('emphasis').off('normal');

    if (effectCfg.showEffectOn === 'render') {
      this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg);
      this._effectCfg = effectCfg;
    } else {
      // Not keep old effect config
      this._effectCfg = null;
      this.stopEffectAnimation();

      this.onHoverStateChange = function (toState) {
        if (toState === 'emphasis') {
          if (effectCfg.showEffectOn !== 'render') {
            _this.startEffectAnimation(effectCfg);
          }
        } else if (toState === 'normal') {
          if (effectCfg.showEffectOn !== 'render') {
            _this.stopEffectAnimation();
          }
        }
      };
    }

    this._effectCfg = effectCfg;
    (0,_util_states__WEBPACK_IMPORTED_MODULE_5__.enableHoverEmphasis)(this);
  };

  ;

  EffectSymbol.prototype.fadeOut = function (cb) {
    this.off('mouseover').off('mouseout');
    cb && cb();
  };

  ;
  return EffectSymbol;
}(_util_graphic__WEBPACK_IMPORTED_MODULE_3__.default);

zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.inherits(EffectSymbol, _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EffectSymbol);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/LargeLineDraw.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/LargeLineDraw.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Path.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var zrender_lib_graphic_IncrementalDisplayable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/graphic/IncrementalDisplayable */ "./node_modules/zrender/lib/graphic/IncrementalDisplayable.js");
/* harmony import */ var zrender_lib_contain_line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/contain/line */ "./node_modules/zrender/lib/contain/line.js");
/* harmony import */ var zrender_lib_contain_quadratic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/contain/quadratic */ "./node_modules/zrender/lib/contain/quadratic.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
 // TODO Batch by color







var LargeLinesPathShape =
/** @class */
function () {
  function LargeLinesPathShape() {
    this.polyline = false;
    this.curveness = 0;
    this.segs = [];
  }

  return LargeLinesPathShape;
}();

var LargeLinesPath =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(LargeLinesPath, _super);

  function LargeLinesPath(opts) {
    return _super.call(this, opts) || this;
  }

  LargeLinesPath.prototype.getDefaultStyle = function () {
    return {
      stroke: '#000',
      fill: null
    };
  };

  LargeLinesPath.prototype.getDefaultShape = function () {
    return new LargeLinesPathShape();
  };

  LargeLinesPath.prototype.buildPath = function (ctx, shape) {
    var segs = shape.segs;
    var curveness = shape.curveness;

    if (shape.polyline) {
      for (var i = 0; i < segs.length;) {
        var count = segs[i++];

        if (count > 0) {
          ctx.moveTo(segs[i++], segs[i++]);

          for (var k = 1; k < count; k++) {
            ctx.lineTo(segs[i++], segs[i++]);
          }
        }
      }
    } else {
      for (var i = 0; i < segs.length;) {
        var x0 = segs[i++];
        var y0 = segs[i++];
        var x1 = segs[i++];
        var y1 = segs[i++];
        ctx.moveTo(x0, y0);

        if (curveness > 0) {
          var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
          var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
          ctx.quadraticCurveTo(x2, y2, x1, y1);
        } else {
          ctx.lineTo(x1, y1);
        }
      }
    }
  };

  LargeLinesPath.prototype.findDataIndex = function (x, y) {
    var shape = this.shape;
    var segs = shape.segs;
    var curveness = shape.curveness;
    var lineWidth = this.style.lineWidth;

    if (shape.polyline) {
      var dataIndex = 0;

      for (var i = 0; i < segs.length;) {
        var count = segs[i++];

        if (count > 0) {
          var x0 = segs[i++];
          var y0 = segs[i++];

          for (var k = 1; k < count; k++) {
            var x1 = segs[i++];
            var y1 = segs[i++];

            if (zrender_lib_contain_line__WEBPACK_IMPORTED_MODULE_1__.containStroke(x0, y0, x1, y1, lineWidth, x, y)) {
              return dataIndex;
            }
          }
        }

        dataIndex++;
      }
    } else {
      var dataIndex = 0;

      for (var i = 0; i < segs.length;) {
        var x0 = segs[i++];
        var y0 = segs[i++];
        var x1 = segs[i++];
        var y1 = segs[i++];

        if (curveness > 0) {
          var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
          var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;

          if (zrender_lib_contain_quadratic__WEBPACK_IMPORTED_MODULE_2__.containStroke(x0, y0, x2, y2, x1, y1, lineWidth, x, y)) {
            return dataIndex;
          }
        } else {
          if (zrender_lib_contain_line__WEBPACK_IMPORTED_MODULE_1__.containStroke(x0, y0, x1, y1, lineWidth, x, y)) {
            return dataIndex;
          }
        }

        dataIndex++;
      }
    }

    return -1;
  };

  return LargeLinesPath;
}(_util_graphic__WEBPACK_IMPORTED_MODULE_3__.default);

var LargeLineDraw =
/** @class */
function () {
  function LargeLineDraw() {
    this.group = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default();
  }

  LargeLineDraw.prototype.isPersistent = function () {
    return !this._incremental;
  };

  ;
  /**
   * Update symbols draw by new data
   */

  LargeLineDraw.prototype.updateData = function (data) {
    this.group.removeAll();
    var lineEl = new LargeLinesPath({
      rectHover: true,
      cursor: 'default'
    });
    lineEl.setShape({
      segs: data.getLayout('linesPoints')
    });

    this._setCommon(lineEl, data); // Add back


    this.group.add(lineEl);
    this._incremental = null;
  };

  ;
  /**
   * @override
   */

  LargeLineDraw.prototype.incrementalPrepareUpdate = function (data) {
    this.group.removeAll();

    this._clearIncremental();

    if (data.count() > 5e5) {
      if (!this._incremental) {
        this._incremental = new zrender_lib_graphic_IncrementalDisplayable__WEBPACK_IMPORTED_MODULE_5__.default({
          silent: true
        });
      }

      this.group.add(this._incremental);
    } else {
      this._incremental = null;
    }
  };

  ;
  /**
   * @override
   */

  LargeLineDraw.prototype.incrementalUpdate = function (taskParams, data) {
    var lineEl = new LargeLinesPath();
    lineEl.setShape({
      segs: data.getLayout('linesPoints')
    });

    this._setCommon(lineEl, data, !!this._incremental);

    if (!this._incremental) {
      lineEl.rectHover = true;
      lineEl.cursor = 'default';
      lineEl.__startIndex = taskParams.start;
      this.group.add(lineEl);
    } else {
      this._incremental.addDisplayable(lineEl, true);
    }
  };

  ;
  /**
   * @override
   */

  LargeLineDraw.prototype.remove = function () {
    this._clearIncremental();

    this._incremental = null;
    this.group.removeAll();
  };

  ;

  LargeLineDraw.prototype._setCommon = function (lineEl, data, isIncremental) {
    var hostModel = data.hostModel;
    lineEl.setShape({
      polyline: hostModel.get('polyline'),
      curveness: hostModel.get(['lineStyle', 'curveness'])
    });
    lineEl.useStyle(hostModel.getModel('lineStyle').getLineStyle());
    lineEl.style.strokeNoScale = true;
    var style = data.getVisual('style');

    if (style && style.stroke) {
      lineEl.setStyle('stroke', style.stroke);
    }

    lineEl.setStyle('fill', null);

    if (!isIncremental) {
      var ecData_1 = (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_6__.getECData)(lineEl); // Enable tooltip
      // PENDING May have performance issue when path is extremely large

      ecData_1.seriesIndex = hostModel.seriesIndex;
      lineEl.on('mousemove', function (e) {
        ecData_1.dataIndex = null;
        var dataIndex = lineEl.findDataIndex(e.offsetX, e.offsetY);

        if (dataIndex > 0) {
          // Provide dataIndex for tooltip
          ecData_1.dataIndex = dataIndex + lineEl.__startIndex;
        }
      });
    }
  };

  ;

  LargeLineDraw.prototype._clearIncremental = function () {
    var incremental = this._incremental;

    if (incremental) {
      incremental.clearDisplaybles();
    }
  };

  ;
  return LargeLineDraw;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LargeLineDraw);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/LargeSymbolDraw.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/LargeSymbolDraw.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Path.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_symbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/symbol */ "./node_modules/echarts/lib/util/symbol.js");
/* harmony import */ var zrender_lib_graphic_IncrementalDisplayable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/graphic/IncrementalDisplayable */ "./node_modules/zrender/lib/graphic/IncrementalDisplayable.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/* global Float32Array */
// TODO Batch by color





var BOOST_SIZE_THRESHOLD = 4;

var LargeSymbolPathShape =
/** @class */
function () {
  function LargeSymbolPathShape() {}

  return LargeSymbolPathShape;
}();

var LargeSymbolPath =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(LargeSymbolPath, _super);

  function LargeSymbolPath(opts) {
    return _super.call(this, opts) || this;
  }

  LargeSymbolPath.prototype.getDefaultShape = function () {
    return new LargeSymbolPathShape();
  };

  LargeSymbolPath.prototype.buildPath = function (path, shape) {
    var points = shape.points;
    var size = shape.size;
    var symbolProxy = this.symbolProxy;
    var symbolProxyShape = symbolProxy.shape;
    var ctx = path.getContext ? path.getContext() : path;
    var canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD; // Do draw in afterBrush.

    if (canBoost) {
      this._ctx = ctx;
      return;
    }

    this._ctx = null;

    for (var i = 0; i < points.length;) {
      var x = points[i++];
      var y = points[i++];

      if (isNaN(x) || isNaN(y)) {
        continue;
      }

      if (this.softClipShape && !this.softClipShape.contain(x, y)) {
        continue;
      }

      symbolProxyShape.x = x - size[0] / 2;
      symbolProxyShape.y = y - size[1] / 2;
      symbolProxyShape.width = size[0];
      symbolProxyShape.height = size[1];
      symbolProxy.buildPath(path, symbolProxyShape, true);
    }
  };

  LargeSymbolPath.prototype.afterBrush = function () {
    var shape = this.shape;
    var points = shape.points;
    var size = shape.size;
    var ctx = this._ctx;

    if (!ctx) {
      return;
    } // PENDING If style or other canvas status changed?


    for (var i = 0; i < points.length;) {
      var x = points[i++];
      var y = points[i++];

      if (isNaN(x) || isNaN(y)) {
        continue;
      }

      if (this.softClipShape && !this.softClipShape.contain(x, y)) {
        continue;
      } // fillRect is faster than building a rect path and draw.
      // And it support light globalCompositeOperation.


      ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);
    }
  };

  LargeSymbolPath.prototype.findDataIndex = function (x, y) {
    // TODO ???
    // Consider transform
    var shape = this.shape;
    var points = shape.points;
    var size = shape.size;
    var w = Math.max(size[0], 4);
    var h = Math.max(size[1], 4); // Not consider transform
    // Treat each element as a rect
    // top down traverse

    for (var idx = points.length / 2 - 1; idx >= 0; idx--) {
      var i = idx * 2;
      var x0 = points[i] - w / 2;
      var y0 = points[i + 1] - h / 2;

      if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {
        return idx;
      }
    }

    return -1;
  };

  return LargeSymbolPath;
}(_util_graphic__WEBPACK_IMPORTED_MODULE_1__.default);

var LargeSymbolDraw =
/** @class */
function () {
  function LargeSymbolDraw() {
    this.group = new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default();
  }

  LargeSymbolDraw.prototype.isPersistent = function () {
    return !this._incremental;
  };

  ;
  /**
   * Update symbols draw by new data
   */

  LargeSymbolDraw.prototype.updateData = function (data, opt) {
    this.group.removeAll();
    var symbolEl = new LargeSymbolPath({
      rectHover: true,
      cursor: 'default'
    });
    symbolEl.setShape({
      points: data.getLayout('points')
    });

    this._setCommon(symbolEl, data, false, opt);

    this.group.add(symbolEl);
    this._incremental = null;
  };

  LargeSymbolDraw.prototype.updateLayout = function (data) {
    if (this._incremental) {
      return;
    }

    var points = data.getLayout('points');
    this.group.eachChild(function (child) {
      if (child.startIndex != null) {
        var len = (child.endIndex - child.startIndex) * 2;
        var byteOffset = child.startIndex * 4 * 2;
        points = new Float32Array(points.buffer, byteOffset, len);
      }

      child.setShape('points', points);
    });
  };

  LargeSymbolDraw.prototype.incrementalPrepareUpdate = function (data) {
    this.group.removeAll();

    this._clearIncremental(); // Only use incremental displayables when data amount is larger than 2 million.
    // PENDING Incremental data?


    if (data.count() > 2e6) {
      if (!this._incremental) {
        this._incremental = new zrender_lib_graphic_IncrementalDisplayable__WEBPACK_IMPORTED_MODULE_3__.default({
          silent: true
        });
      }

      this.group.add(this._incremental);
    } else {
      this._incremental = null;
    }
  };

  LargeSymbolDraw.prototype.incrementalUpdate = function (taskParams, data, opt) {
    var symbolEl;

    if (this._incremental) {
      symbolEl = new LargeSymbolPath();

      this._incremental.addDisplayable(symbolEl, true);
    } else {
      symbolEl = new LargeSymbolPath({
        rectHover: true,
        cursor: 'default',
        startIndex: taskParams.start,
        endIndex: taskParams.end
      });
      symbolEl.incremental = true;
      this.group.add(symbolEl);
    }

    symbolEl.setShape({
      points: data.getLayout('points')
    });

    this._setCommon(symbolEl, data, !!this._incremental, opt);
  };

  LargeSymbolDraw.prototype._setCommon = function (symbolEl, data, isIncremental, opt) {
    var hostModel = data.hostModel;
    opt = opt || {};
    var size = data.getVisual('symbolSize');
    symbolEl.setShape('size', size instanceof Array ? size : [size, size]);
    symbolEl.softClipShape = opt.clipShape || null; // Create symbolProxy to build path for each data

    symbolEl.symbolProxy = (0,_util_symbol__WEBPACK_IMPORTED_MODULE_4__.createSymbol)(data.getVisual('symbol'), 0, 0, 0, 0); // Use symbolProxy setColor method

    symbolEl.setColor = symbolEl.symbolProxy.setColor;
    var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;
    symbolEl.useStyle( // Draw shadow when doing fillRect is extremely slow.
    hostModel.getModel('itemStyle').getItemStyle(extrudeShadow ? ['color', 'shadowBlur', 'shadowColor'] : ['color']));
    var globalStyle = data.getVisual('style');
    var visualColor = globalStyle && globalStyle.fill;

    if (visualColor) {
      symbolEl.setColor(visualColor);
    }

    if (!isIncremental) {
      var ecData_1 = (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_5__.getECData)(symbolEl); // Enable tooltip
      // PENDING May have performance issue when path is extremely large

      ecData_1.seriesIndex = hostModel.seriesIndex;
      symbolEl.on('mousemove', function (e) {
        ecData_1.dataIndex = null;
        var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);

        if (dataIndex >= 0) {
          // Provide dataIndex for tooltip
          ecData_1.dataIndex = dataIndex + (symbolEl.startIndex || 0);
        }
      });
    }
  };

  LargeSymbolDraw.prototype.remove = function () {
    this._clearIncremental();

    this._incremental = null;
    this.group.removeAll();
  };

  LargeSymbolDraw.prototype._clearIncremental = function () {
    var incremental = this._incremental;

    if (incremental) {
      incremental.clearDisplaybles();
    }
  };

  return LargeSymbolDraw;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LargeSymbolDraw);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/Polyline.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/Polyline.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polyline.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var Polyline =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Polyline, _super);

  function Polyline(lineData, idx, seriesScope) {
    var _this = _super.call(this) || this;

    _this._createPolyline(lineData, idx, seriesScope);

    return _this;
  }

  Polyline.prototype._createPolyline = function (lineData, idx, seriesScope) {
    // let seriesModel = lineData.hostModel;
    var points = lineData.getItemLayout(idx);
    var line = new _util_graphic__WEBPACK_IMPORTED_MODULE_1__.default({
      shape: {
        points: points
      }
    });
    this.add(line);

    this._updateCommonStl(lineData, idx, seriesScope);
  };

  ;

  Polyline.prototype.updateData = function (lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line = this.childAt(0);
    var target = {
      shape: {
        points: lineData.getItemLayout(idx)
      }
    };
    _util_graphic__WEBPACK_IMPORTED_MODULE_2__.updateProps(line, target, seriesModel, idx);

    this._updateCommonStl(lineData, idx, seriesScope);
  };

  ;

  Polyline.prototype._updateCommonStl = function (lineData, idx, seriesScope) {
    var line = this.childAt(0);
    var itemModel = lineData.getItemModel(idx);
    var hoverLineStyle = seriesScope && seriesScope.emphasisLineStyle;

    if (!seriesScope || lineData.hasItemOption) {
      hoverLineStyle = itemModel.getModel(['emphasis', 'lineStyle']).getLineStyle();
    }

    line.useStyle(lineData.getItemVisual(idx, 'style'));
    line.style.fill = null;
    line.style.strokeNoScale = true;
    var lineEmphasisState = line.ensureState('emphasis');
    lineEmphasisState.style = hoverLineStyle;
    (0,_util_states__WEBPACK_IMPORTED_MODULE_3__.enableHoverEmphasis)(this);
  };

  ;

  Polyline.prototype.updateLayout = function (lineData, idx) {
    var polyline = this.childAt(0);
    polyline.setShape('points', lineData.getItemLayout(idx));
  };

  ;
  return Polyline;
}(_util_graphic__WEBPACK_IMPORTED_MODULE_4__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Polyline);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGridClipPath": () => (/* binding */ createGridClipPath),
/* harmony export */   "createPolarClipPath": () => (/* binding */ createPolarClipPath),
/* harmony export */   "createClipPath": () => (/* binding */ createClipPath)
/* harmony export */ });
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Sector.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {
  var rect = cartesian.getArea();
  var x = rect.x;
  var y = rect.y;
  var width = rect.width;
  var height = rect.height;
  var lineWidth = seriesModel.get(['lineStyle', 'width']) || 2; // Expand the clip path a bit to avoid the border is clipped and looks thinner

  x -= lineWidth / 2;
  y -= lineWidth / 2;
  width += lineWidth;
  height += lineWidth; // fix: https://github.com/apache/incubator-echarts/issues/11369

  x = Math.floor(x);
  width = Math.round(width);
  var clipPath = new _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default({
    shape: {
      x: x,
      y: y,
      width: width,
      height: height
    }
  });

  if (hasAnimation) {
    var baseAxis = cartesian.getBaseAxis();
    var isHorizontal = baseAxis.isHorizontal();
    var isAxisInversed = baseAxis.inverse;

    if (isHorizontal) {
      if (isAxisInversed) {
        clipPath.shape.x += width;
      }

      clipPath.shape.width = 0;
    } else {
      if (!isAxisInversed) {
        clipPath.shape.y += height;
      }

      clipPath.shape.height = 0;
    }

    var duringCb = typeof during === 'function' ? function (percent) {
      during(percent, clipPath);
    } : null;
    _util_graphic__WEBPACK_IMPORTED_MODULE_1__.initProps(clipPath, {
      shape: {
        width: width,
        height: height,
        x: x,
        y: y
      }
    }, seriesModel, null, done, duringCb);
  }

  return clipPath;
}

function createPolarClipPath(polar, hasAnimation, seriesModel) {
  var sectorArea = polar.getArea(); // Avoid float number rounding error for symbol on the edge of axis extent.

  var r0 = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.round)(sectorArea.r0, 1);
  var r = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.round)(sectorArea.r, 1);
  var clipPath = new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default({
    shape: {
      cx: (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.round)(polar.cx, 1),
      cy: (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.round)(polar.cy, 1),
      r0: r0,
      r: r,
      startAngle: sectorArea.startAngle,
      endAngle: sectorArea.endAngle,
      clockwise: sectorArea.clockwise
    }
  });

  if (hasAnimation) {
    var isRadial = polar.getBaseAxis().dim === 'angle';

    if (isRadial) {
      clipPath.shape.endAngle = sectorArea.startAngle;
    } else {
      clipPath.shape.r = r0;
    }

    _util_graphic__WEBPACK_IMPORTED_MODULE_1__.initProps(clipPath, {
      shape: {
        endAngle: sectorArea.endAngle,
        r: r
      }
    }, seriesModel);
  }

  return clipPath;
}

function createClipPath(coordSys, hasAnimation, seriesModel, done, during) {
  if (!coordSys) {
    return null;
  } else if (coordSys.type === 'polar') {
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  } else if (coordSys.type === 'cartesian2d') {
    return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);
  }

  return null;
}



/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/createGraphFromNodeEdge.js":
/*!**************************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/createGraphFromNodeEdge.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createGraphFromNodeEdge)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _data_List__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../data/List */ "./node_modules/echarts/lib/data/List.js");
/* harmony import */ var _data_Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/Graph */ "./node_modules/echarts/lib/data/Graph.js");
/* harmony import */ var _data_helper_linkList__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../data/helper/linkList */ "./node_modules/echarts/lib/data/helper/linkList.js");
/* harmony import */ var _data_helper_createDimensions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../data/helper/createDimensions */ "./node_modules/echarts/lib/data/helper/createDimensions.js");
/* harmony import */ var _core_CoordinateSystem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/CoordinateSystem */ "./node_modules/echarts/lib/core/CoordinateSystem.js");
/* harmony import */ var _createListFromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createListFromArray */ "./node_modules/echarts/lib/chart/helper/createListFromArray.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








function createGraphFromNodeEdge(nodes, edges, seriesModel, directed, beforeLink) {
  // ??? TODO
  // support dataset?
  var graph = new _data_Graph__WEBPACK_IMPORTED_MODULE_0__.default(directed);

  for (var i = 0; i < nodes.length; i++) {
    graph.addNode(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.retrieve( // Id, name, dataIndex
    nodes[i].id, nodes[i].name, i), i);
  }

  var linkNameList = [];
  var validEdges = [];
  var linkCount = 0;

  for (var i = 0; i < edges.length; i++) {
    var link = edges[i];
    var source = link.source;
    var target = link.target; // addEdge may fail when source or target not exists

    if (graph.addEdge(source, target, linkCount)) {
      validEdges.push(link);
      linkNameList.push(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.retrieve((0,_util_model__WEBPACK_IMPORTED_MODULE_2__.convertOptionIdName)(link.id, null), source + ' > ' + target));
      linkCount++;
    }
  }

  var coordSys = seriesModel.get('coordinateSystem');
  var nodeData;

  if (coordSys === 'cartesian2d' || coordSys === 'polar') {
    nodeData = (0,_createListFromArray__WEBPACK_IMPORTED_MODULE_3__.default)(nodes, seriesModel);
  } else {
    var coordSysCtor = _core_CoordinateSystem__WEBPACK_IMPORTED_MODULE_4__.default.get(coordSys);
    var coordDimensions = coordSysCtor ? coordSysCtor.dimensions || [] : []; // FIXME: Some geo do not need `value` dimenson, whereas `calendar` needs
    // `value` dimension, but graph need `value` dimension. It's better to
    // uniform this behavior.

    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.indexOf(coordDimensions, 'value') < 0) {
      coordDimensions.concat(['value']);
    }

    var dimensionNames = (0,_data_helper_createDimensions__WEBPACK_IMPORTED_MODULE_5__.default)(nodes, {
      coordDimensions: coordDimensions
    });
    nodeData = new _data_List__WEBPACK_IMPORTED_MODULE_6__.default(dimensionNames, seriesModel);
    nodeData.initData(nodes);
  }

  var edgeData = new _data_List__WEBPACK_IMPORTED_MODULE_6__.default(['value'], seriesModel);
  edgeData.initData(validEdges, linkNameList);
  beforeLink && beforeLink(nodeData, edgeData);
  (0,_data_helper_linkList__WEBPACK_IMPORTED_MODULE_7__.default)({
    mainData: nodeData,
    struct: graph,
    structAttr: 'graph',
    datas: {
      node: nodeData,
      edge: edgeData
    },
    datasAttr: {
      node: 'data',
      edge: 'edgeData'
    }
  }); // Update dataIndex of nodes and edges because invalid edge may be removed

  graph.update();
  return graph;
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/createListSimply.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/createListSimply.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createListSimply)
/* harmony export */ });
/* harmony import */ var _data_helper_createDimensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/helper/createDimensions */ "./node_modules/echarts/lib/data/helper/createDimensions.js");
/* harmony import */ var _data_List__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/List */ "./node_modules/echarts/lib/data/List.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



/**
 * [Usage]:
 * (1)
 * createListSimply(seriesModel, ['value']);
 * (2)
 * createListSimply(seriesModel, {
 *     coordDimensions: ['value'],
 *     dimensionsCount: 5
 * });
 */

function createListSimply(seriesModel, opt, nameList) {
  opt = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(opt) && {
    coordDimensions: opt
  } || (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, opt);
  var source = seriesModel.getSource();
  var dimensionsInfo = (0,_data_helper_createDimensions__WEBPACK_IMPORTED_MODULE_1__.default)(source, opt);
  var list = new _data_List__WEBPACK_IMPORTED_MODULE_2__.default(dimensionsInfo, seriesModel);
  list.initData(source, nameList);
  return list;
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/enableAriaDecalForTree.js":
/*!*************************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/enableAriaDecalForTree.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ enableAriaDecalForTree)
/* harmony export */ });
/* harmony import */ var _model_mixin_palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/mixin/palette */ "./node_modules/echarts/lib/model/mixin/palette.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

function enableAriaDecalForTree(seriesModel) {
  var data = seriesModel.getData();
  var tree = data.tree;
  var decalPaletteScope = {};
  tree.eachNode(function (node) {
    // Use decal of level 1 node
    var current = node;

    while (current && current.depth > 1) {
      current = current.parentNode;
    }

    var decal = (0,_model_mixin_palette__WEBPACK_IMPORTED_MODULE_0__.getDecalFromPalette)(seriesModel.ecModel, current.name || current.dataIndex + '', decalPaletteScope);
    node.setVisual('decal', decal);
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/multipleGraphEdgeHelper.js":
/*!**************************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/multipleGraphEdgeHelper.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initCurvenessList": () => (/* binding */ initCurvenessList),
/* harmony export */   "createEdgeMapForCurveness": () => (/* binding */ createEdgeMapForCurveness),
/* harmony export */   "getCurvenessForEdge": () => (/* binding */ getCurvenessForEdge)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// @ts-nocheck

var KEY_DELIMITER = '-->';
/**
 * params handler
 * @param {module:echarts/model/SeriesModel} seriesModel
 * @returns {*}
 */

var getAutoCurvenessParams = function (seriesModel) {
  return seriesModel.get('autoCurveness') || null;
};
/**
 * Generate a list of edge curvatures, 20 is the default
 * @param {module:echarts/model/SeriesModel} seriesModel
 * @param {number} appendLength
 * @return  20 => [0, -0.2, 0.2, -0.4, 0.4, -0.6, 0.6, -0.8, 0.8, -1, 1, -1.2, 1.2, -1.4, 1.4, -1.6, 1.6, -1.8, 1.8, -2]
 */


var createCurveness = function (seriesModel, appendLength) {
  var autoCurvenessParmas = getAutoCurvenessParams(seriesModel);
  var length = 20;
  var curvenessList = []; // handler the function set

  if (typeof autoCurvenessParmas === 'number') {
    length = autoCurvenessParmas;
  } else if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(autoCurvenessParmas)) {
    seriesModel.__curvenessList = autoCurvenessParmas;
    return;
  } // append length


  if (appendLength > length) {
    length = appendLength;
  } // make sure the length is even


  var len = length % 2 ? length + 2 : length + 3;
  curvenessList = [];

  for (var i = 0; i < len; i++) {
    curvenessList.push((i % 2 ? i + 1 : i) / 10 * (i % 2 ? -1 : 1));
  }

  seriesModel.__curvenessList = curvenessList;
};
/**
 * Create different cache key data in the positive and negative directions, in order to set the curvature later
 * @param {number|string|module:echarts/data/Graph.Node} n1
 * @param {number|string|module:echarts/data/Graph.Node} n2
 * @param {module:echarts/model/SeriesModel} seriesModel
 * @returns {string} key
 */


var getKeyOfEdges = function (n1, n2, seriesModel) {
  var source = [n1.id, n1.dataIndex].join('.');
  var target = [n2.id, n2.dataIndex].join('.');
  return [seriesModel.uid, source, target].join(KEY_DELIMITER);
};
/**
 * get opposite key
 * @param {string} key
 * @returns {string}
 */


var getOppositeKey = function (key) {
  var keys = key.split(KEY_DELIMITER);
  return [keys[0], keys[2], keys[1]].join(KEY_DELIMITER);
};
/**
 * get edgeMap with key
 * @param edge
 * @param {module:echarts/model/SeriesModel} seriesModel
 */


var getEdgeFromMap = function (edge, seriesModel) {
  var key = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
  return seriesModel.__edgeMap[key];
};
/**
 * calculate all cases total length
 * @param edge
 * @param seriesModel
 * @returns {number}
 */


var getTotalLengthBetweenNodes = function (edge, seriesModel) {
  var len = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node1, edge.node2, seriesModel), seriesModel);
  var lenV = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node2, edge.node1, seriesModel), seriesModel);
  return len + lenV;
};
/**
 *
 * @param key
 */


var getEdgeMapLengthWithKey = function (key, seriesModel) {
  var edgeMap = seriesModel.__edgeMap;
  return edgeMap[key] ? edgeMap[key].length : 0;
};
/**
 * Count the number of edges between the same two points, used to obtain the curvature table and the parity of the edge
 * @see /graph/GraphSeries.js@getInitialData
 * @param {module:echarts/model/SeriesModel} seriesModel
 */


function initCurvenessList(seriesModel) {
  if (!getAutoCurvenessParams(seriesModel)) {
    return;
  }

  seriesModel.__curvenessList = [];
  seriesModel.__edgeMap = {}; // calc the array of curveness List

  createCurveness(seriesModel);
}
/**
 * set edgeMap with key
 * @param {number|string|module:echarts/data/Graph.Node} n1
 * @param {number|string|module:echarts/data/Graph.Node} n2
 * @param {module:echarts/model/SeriesModel} seriesModel
 * @param {number} index
 */

function createEdgeMapForCurveness(n1, n2, seriesModel, index) {
  if (!getAutoCurvenessParams(seriesModel)) {
    return;
  }

  var key = getKeyOfEdges(n1, n2, seriesModel);
  var edgeMap = seriesModel.__edgeMap;
  var oppositeEdges = edgeMap[getOppositeKey(key)]; // set direction

  if (edgeMap[key] && !oppositeEdges) {
    edgeMap[key].isForward = true;
  } else if (oppositeEdges && edgeMap[key]) {
    oppositeEdges.isForward = true;
    edgeMap[key].isForward = false;
  }

  edgeMap[key] = edgeMap[key] || [];
  edgeMap[key].push(index);
}
/**
 * get curvature for edge
 * @param edge
 * @param {module:echarts/model/SeriesModel} seriesModel
 * @param index
 */

function getCurvenessForEdge(edge, seriesModel, index, needReverse) {
  var autoCurvenessParams = getAutoCurvenessParams(seriesModel);
  var isArrayParam = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(autoCurvenessParams);

  if (!autoCurvenessParams) {
    return null;
  }

  var edgeArray = getEdgeFromMap(edge, seriesModel);

  if (!edgeArray) {
    return null;
  }

  var edgeIndex = -1;

  for (var i = 0; i < edgeArray.length; i++) {
    if (edgeArray[i] === index) {
      edgeIndex = i;
      break;
    }
  } // if totalLen is Longer createCurveness


  var totalLen = getTotalLengthBetweenNodes(edge, seriesModel);
  createCurveness(seriesModel, totalLen);
  edge.lineStyle = edge.lineStyle || {}; // if is opposite edge, must set curvenss to opposite number

  var curKey = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
  var curvenessList = seriesModel.__curvenessList; // if pass array no need parity

  var parityCorrection = isArrayParam ? 0 : totalLen % 2 ? 0 : 1;

  if (!edgeArray.isForward) {
    // the opposite edge show outside
    var oppositeKey = getOppositeKey(curKey);
    var len = getEdgeMapLengthWithKey(oppositeKey, seriesModel);
    var resValue = curvenessList[edgeIndex + len + parityCorrection]; // isNeedReverse, simple, force type need reverse the curveness in the junction of the forword and the opposite

    if (needReverse) {
      // set as array may make the parity handle with the len of opposite
      if (isArrayParam) {
        if (autoCurvenessParams && autoCurvenessParams[0] === 0) {
          return (len + parityCorrection) % 2 ? resValue : -resValue;
        } else {
          return ((len % 2 ? 0 : 1) + parityCorrection) % 2 ? resValue : -resValue;
        }
      } else {
        return (len + parityCorrection) % 2 ? resValue : -resValue;
      }
    } else {
      return curvenessList[edgeIndex + len + parityCorrection];
    }
  } else {
    return curvenessList[parityCorrection + edgeIndex];
  }
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/pieHelper.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/pieHelper.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSectorCornerRadius": () => (/* binding */ getSectorCornerRadius)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_contain_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/contain/text */ "./node_modules/zrender/lib/contain/text.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function getSectorCornerRadius(model, shape) {
  var cornerRadius = model.get('borderRadius');

  if (cornerRadius == null) {
    return null;
  }

  if (!(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(cornerRadius)) {
    cornerRadius = [cornerRadius, cornerRadius];
  }

  return {
    innerCornerRadius: (0,zrender_lib_contain_text__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(cornerRadius[0], shape.r0),
    cornerRadius: (0,zrender_lib_contain_text__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(cornerRadius[1], shape.r)
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/treeHelper.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/treeHelper.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "retrieveTargetInfo": () => (/* binding */ retrieveTargetInfo),
/* harmony export */   "getPathToRoot": () => (/* binding */ getPathToRoot),
/* harmony export */   "aboveViewRoot": () => (/* binding */ aboveViewRoot),
/* harmony export */   "wrapTreePathInfo": () => (/* binding */ wrapTreePathInfo)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

function retrieveTargetInfo(payload, validPayloadTypes, seriesModel) {
  if (payload && zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.indexOf(validPayloadTypes, payload.type) >= 0) {
    var root = seriesModel.getData().tree.root;
    var targetNode = payload.targetNode;

    if (typeof targetNode === 'string') {
      targetNode = root.getNodeById(targetNode);
    }

    if (targetNode && root.contains(targetNode)) {
      return {
        node: targetNode
      };
    }

    var targetNodeId = payload.targetNodeId;

    if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {
      return {
        node: targetNode
      };
    }
  }
} // Not includes the given node at the last item.

function getPathToRoot(node) {
  var path = [];

  while (node) {
    node = node.parentNode;
    node && path.push(node);
  }

  return path.reverse();
}
function aboveViewRoot(viewRoot, node) {
  var viewPath = getPathToRoot(viewRoot);
  return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.indexOf(viewPath, node) >= 0;
} // From root to the input node (the input node will be included).

function wrapTreePathInfo(node, seriesModel) {
  var treePathInfo = [];

  while (node) {
    var nodeDataIndex = node.dataIndex;
    treePathInfo.push({
      name: node.name,
      dataIndex: nodeDataIndex,
      value: seriesModel.getRawValue(nodeDataIndex)
    });
    node = node.parentNode;
  }

  treePathInfo.reverse();
  return treePathInfo;
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/whiskerBoxCommon.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/whiskerBoxCommon.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WhiskerBoxCommonMixin": () => (/* binding */ WhiskerBoxCommonMixin)
/* harmony export */ });
/* harmony import */ var _helper_createListSimply__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helper/createListSimply */ "./node_modules/echarts/lib/chart/helper/createListSimply.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _data_helper_dimensionHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/helper/dimensionHelper */ "./node_modules/echarts/lib/data/helper/dimensionHelper.js");
/* harmony import */ var _data_helper_sourceHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/helper/sourceHelper */ "./node_modules/echarts/lib/data/helper/sourceHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var WhiskerBoxCommonMixin =
/** @class */
function () {
  function WhiskerBoxCommonMixin() {}
  /**
   * @override
   */


  WhiskerBoxCommonMixin.prototype.getInitialData = function (option, ecModel) {
    // When both types of xAxis and yAxis are 'value', layout is
    // needed to be specified by user. Otherwise, layout can be
    // judged by which axis is category.
    var ordinalMeta;
    var xAxisModel = ecModel.getComponent('xAxis', this.get('xAxisIndex'));
    var yAxisModel = ecModel.getComponent('yAxis', this.get('yAxisIndex'));
    var xAxisType = xAxisModel.get('type');
    var yAxisType = yAxisModel.get('type');
    var addOrdinal; // FIXME
    // Consider time axis.

    if (xAxisType === 'category') {
      option.layout = 'horizontal';
      ordinalMeta = xAxisModel.getOrdinalMeta();
      addOrdinal = true;
    } else if (yAxisType === 'category') {
      option.layout = 'vertical';
      ordinalMeta = yAxisModel.getOrdinalMeta();
      addOrdinal = true;
    } else {
      option.layout = option.layout || 'horizontal';
    }

    var coordDims = ['x', 'y'];
    var baseAxisDimIndex = option.layout === 'horizontal' ? 0 : 1;
    var baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];
    var otherAxisDim = coordDims[1 - baseAxisDimIndex];
    var axisModels = [xAxisModel, yAxisModel];
    var baseAxisType = axisModels[baseAxisDimIndex].get('type');
    var otherAxisType = axisModels[1 - baseAxisDimIndex].get('type');
    var data = option.data; // ??? FIXME make a stage to perform data transfrom.
    // MUST create a new data, consider setOption({}) again.

    if (data && addOrdinal) {
      var newOptionData_1 = [];
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(data, function (item, index) {
        var newItem;

        if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(item)) {
          newItem = item.slice();
          item.unshift(index);
        } else if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(item.value)) {
          newItem = item.value.slice();
          item.value.unshift(index);
        } else {
          newItem = item;
        }

        newOptionData_1.push(newItem);
      });
      option.data = newOptionData_1;
    }

    var defaultValueDimensions = this.defaultValueDimensions;
    var coordDimensions = [{
      name: baseAxisDim,
      type: (0,_data_helper_dimensionHelper__WEBPACK_IMPORTED_MODULE_1__.getDimensionTypeByAxis)(baseAxisType),
      ordinalMeta: ordinalMeta,
      otherDims: {
        tooltip: false,
        itemName: 0
      },
      dimsDef: ['base']
    }, {
      name: otherAxisDim,
      type: (0,_data_helper_dimensionHelper__WEBPACK_IMPORTED_MODULE_1__.getDimensionTypeByAxis)(otherAxisType),
      dimsDef: defaultValueDimensions.slice()
    }];
    return (0,_helper_createListSimply__WEBPACK_IMPORTED_MODULE_2__.default)(this, {
      coordDimensions: coordDimensions,
      dimensionsCount: defaultValueDimensions.length + 1,
      encodeDefaulter: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.curry(_data_helper_sourceHelper__WEBPACK_IMPORTED_MODULE_3__.makeSeriesEncodeForAxisCoordSys, coordDimensions, this)
    });
  };
  /**
   * If horizontal, base axis is x, otherwise y.
   * @override
   */


  WhiskerBoxCommonMixin.prototype.getBaseAxis = function () {
    var dim = this._baseAxisDim;
    return this.ecModel.getComponent(dim + 'Axis', this.get(dim + 'AxisIndex')).axis;
  };

  return WhiskerBoxCommonMixin;
}();

;


/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/LineSeries.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/line/LineSeries.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _helper_createListFromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/createListFromArray */ "./node_modules/echarts/lib/chart/helper/createListFromArray.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var LineSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(LineSeriesModel, _super);

  function LineSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = LineSeriesModel.type;
    _this.hasSymbolVisual = true;
    _this.legendSymbol = 'line';
    return _this;
  }

  LineSeriesModel.prototype.getInitialData = function (option) {
    if (true) {
      var coordSys = option.coordinateSystem;

      if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {
        throw new Error('Line not support coordinateSystem besides cartesian and polar');
      }
    }

    return (0,_helper_createListFromArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.getSource(), this, {
      useEncodeDefaulter: true
    });
  };

  LineSeriesModel.type = 'series.line';
  LineSeriesModel.dependencies = ['grid', 'polar'];
  LineSeriesModel.defaultOption = {
    zlevel: 0,
    z: 3,
    coordinateSystem: 'cartesian2d',
    legendHoverLink: true,
    clip: true,
    label: {
      position: 'top'
    },
    endLabel: {
      show: false,
      valueAnimation: true,
      distance: 8
    },
    lineStyle: {
      width: 2,
      type: 'solid'
    },
    emphasis: {
      scale: true,
      lineStyle: {
        width: 'bolder'
      }
    },
    // areaStyle: {
    // origin of areaStyle. Valid values:
    // `'auto'/null/undefined`: from axisLine to data
    // `'start'`: from min to data
    // `'end'`: from data to max
    // origin: 'auto'
    // },
    // false, 'start', 'end', 'middle'
    step: false,
    // Disabled if step is true
    smooth: false,
    smoothMonotone: null,
    symbol: 'emptyCircle',
    symbolSize: 4,
    symbolRotate: null,
    showSymbol: true,
    // `false`: follow the label interval strategy.
    // `true`: show all symbols.
    // `'auto'`: If possible, show all symbols, otherwise
    //           follow the label interval strategy.
    showAllSymbol: 'auto',
    // Whether to connect break point.
    connectNulls: false,
    // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
    sampling: 'none',
    animationEasing: 'linear',
    // Disable progressive
    progressive: 0,
    hoverLayerThreshold: Infinity
  };
  return LineSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_2__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LineSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/LineView.js":
/*!*********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/line/LineView.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _helper_SymbolDraw__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../helper/SymbolDraw */ "./node_modules/echarts/lib/chart/helper/SymbolDraw.js");
/* harmony import */ var _helper_Symbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helper/Symbol */ "./node_modules/echarts/lib/chart/helper/Symbol.js");
/* harmony import */ var _lineAnimationDiff__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./lineAnimationDiff */ "./node_modules/echarts/lib/chart/line/lineAnimationDiff.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/LinearGradient.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _poly__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./poly */ "./node_modules/echarts/lib/chart/line/poly.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ "./node_modules/echarts/lib/chart/line/helper.js");
/* harmony import */ var _helper_createClipPathFromCoordSys__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helper/createClipPathFromCoordSys */ "./node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js");
/* harmony import */ var _coord_CoordinateSystem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../coord/CoordinateSystem */ "./node_modules/echarts/lib/coord/CoordinateSystem.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _helper_labelHelper__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../helper/labelHelper */ "./node_modules/echarts/lib/chart/helper/labelHelper.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _util_vendor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/vendor */ "./node_modules/echarts/lib/util/vendor.js");
/* harmony import */ var _util_format__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/format */ "./node_modules/echarts/lib/util/format.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
 // FIXME step not support polar



















function isPointsSame(points1, points2) {
  if (points1.length !== points2.length) {
    return;
  }

  for (var i = 0; i < points1.length; i++) {
    if (points1[i] !== points2[i]) {
      return;
    }
  }

  return true;
}

function bboxFromPoints(points) {
  var minX = Infinity;
  var minY = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;

  for (var i = 0; i < points.length;) {
    var x = points[i++];
    var y = points[i++];

    if (!isNaN(x)) {
      minX = Math.min(x, minX);
      maxX = Math.max(x, maxX);
    }

    if (!isNaN(y)) {
      minY = Math.min(y, minY);
      maxY = Math.max(y, maxY);
    }
  }

  return [[minX, minY], [maxX, maxY]];
}

function getBoundingDiff(points1, points2) {
  var _a = bboxFromPoints(points1),
      min1 = _a[0],
      max1 = _a[1];

  var _b = bboxFromPoints(points2),
      min2 = _b[0],
      max2 = _b[1]; // Get a max value from each corner of two boundings.


  return Math.max(Math.abs(min1[0] - min2[0]), Math.abs(min1[1] - min2[1]), Math.abs(max1[0] - max2[0]), Math.abs(max1[1] - max2[1]));
}

function getSmooth(smooth) {
  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;
}

function getStackedOnPoints(coordSys, data, dataCoordInfo) {
  if (!dataCoordInfo.valueDim) {
    return [];
  }

  var len = data.count();
  var points = (0,_util_vendor__WEBPACK_IMPORTED_MODULE_0__.createFloat32Array)(len * 2);

  for (var idx = 0; idx < len; idx++) {
    var pt = (0,_helper__WEBPACK_IMPORTED_MODULE_1__.getStackedOnPoint)(dataCoordInfo, coordSys, data, idx);
    points[idx * 2] = pt[0];
    points[idx * 2 + 1] = pt[1];
  }

  return points;
}

function turnPointsIntoStep(points, coordSys, stepTurnAt) {
  var baseAxis = coordSys.getBaseAxis();
  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;
  var stepPoints = [];
  var i = 0;
  var stepPt = [];
  var pt = [];
  var nextPt = [];

  for (; i < points.length - 2; i += 2) {
    nextPt[0] = points[i + 2];
    nextPt[1] = points[i + 3];
    pt[0] = points[i];
    pt[1] = points[i + 1];
    stepPoints.push(pt[0], pt[1]);

    switch (stepTurnAt) {
      case 'end':
        stepPt[baseIndex] = nextPt[baseIndex];
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        break;

      case 'middle':
        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
        var stepPt2 = [];
        stepPt[baseIndex] = stepPt2[baseIndex] = middle;
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        stepPoints.push(stepPt2[0], stepPt2[1]);
        break;

      default:
        // default is start
        stepPt[baseIndex] = pt[baseIndex];
        stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
    }
  } // Last points


  stepPoints.push(points[i++], points[i++]);
  return stepPoints;
}

function getVisualGradient(data, coordSys) {
  var visualMetaList = data.getVisual('visualMeta');

  if (!visualMetaList || !visualMetaList.length || !data.count()) {
    // When data.count() is 0, gradient range can not be calculated.
    return;
  }

  if (coordSys.type !== 'cartesian2d') {
    if (true) {
      console.warn('Visual map on line style is only supported on cartesian2d.');
    }

    return;
  }

  var coordDim;
  var visualMeta;

  for (var i = visualMetaList.length - 1; i >= 0; i--) {
    var dimIndex = visualMetaList[i].dimension;
    var dimName = data.dimensions[dimIndex];
    var dimInfo = data.getDimensionInfo(dimName);
    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y

    if (coordDim === 'x' || coordDim === 'y') {
      visualMeta = visualMetaList[i];
      break;
    }
  }

  if (!visualMeta) {
    if (true) {
      console.warn('Visual map on line style only support x or y dimension.');
    }

    return;
  } // If the area to be rendered is bigger than area defined by LinearGradient,
  // the canvas spec prescribes that the color of the first stop and the last
  // stop should be used. But if two stops are added at offset 0, in effect
  // browsers use the color of the second stop to render area outside
  // LinearGradient. So we can only infinitesimally extend area defined in
  // LinearGradient to render `outerColors`.


  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.

  var colorStops = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.map(visualMeta.stops, function (stop) {
    return {
      offset: 0,
      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
      color: stop.color
    };
  });
  var stopLen = colorStops.length;
  var outerColors = visualMeta.outerColors.slice();

  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
    colorStops.reverse();
    outerColors.reverse();
  }

  var tinyExtent = 10; // Arbitrary value: 10px

  var minCoord = colorStops[0].coord - tinyExtent;
  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;
  var coordSpan = maxCoord - minCoord;

  if (coordSpan < 1e-3) {
    return 'transparent';
  }

  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each(colorStops, function (stop) {
    stop.offset = (stop.coord - minCoord) / coordSpan;
  });
  colorStops.push({
    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,
    color: outerColors[1] || 'transparent'
  });
  colorStops.unshift({
    offset: stopLen ? colorStops[0].offset : 0.5,
    color: outerColors[0] || 'transparent'
  }); // zrUtil.each(colorStops, function (colorStop) {
  //     // Make sure each offset has rounded px to avoid not sharp edge
  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);
  // });

  var gradient = new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 0, 0, colorStops, true);
  gradient[coordDim] = minCoord;
  gradient[coordDim + '2'] = maxCoord;
  return gradient;
}

function getIsIgnoreFunc(seriesModel, data, coordSys) {
  var showAllSymbol = seriesModel.get('showAllSymbol');
  var isAuto = showAllSymbol === 'auto';

  if (showAllSymbol && !isAuto) {
    return;
  }

  var categoryAxis = coordSys.getAxesByScale('ordinal')[0];

  if (!categoryAxis) {
    return;
  } // Note that category label interval strategy might bring some weird effect
  // in some scenario: users may wonder why some of the symbols are not
  // displayed. So we show all symbols as possible as we can.


  if (isAuto // Simplify the logic, do not determine label overlap here.
  && canShowAllSymbolForCategory(categoryAxis, data)) {
    return;
  } // Otherwise follow the label interval strategy on category axis.


  var categoryDataDim = data.mapDimension(categoryAxis.dim);
  var labelMap = {};
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each(categoryAxis.getViewLabels(), function (labelItem) {
    var ordinalNumber = categoryAxis.scale.getRawOrdinalNumber(labelItem.tickValue);
    labelMap[ordinalNumber] = 1;
  });
  return function (dataIndex) {
    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
  };
}

function canShowAllSymbolForCategory(categoryAxis, data) {
  // In mose cases, line is monotonous on category axis, and the label size
  // is close with each other. So we check the symbol size and some of the
  // label size alone with the category axis to estimate whether all symbol
  // can be shown without overlap.
  var axisExtent = categoryAxis.getExtent();
  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();
  isNaN(availSize) && (availSize = 0); // 0/0 is NaN.
  // Sampling some points, max 5.

  var dataLen = data.count();
  var step = Math.max(1, Math.round(dataLen / 5));

  for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
    if (_helper_Symbol__WEBPACK_IMPORTED_MODULE_4__.default.getSymbolSize(data, dataIndex // Only for cartesian, where `isHorizontal` exists.
    )[categoryAxis.isHorizontal() ? 1 : 0] // Empirical number
    * 1.5 > availSize) {
      return false;
    }
  }

  return true;
}

function isPointNull(x, y) {
  return isNaN(x) || isNaN(y);
}

function getLastIndexNotNull(points) {
  var len = points.length / 2;

  for (; len > 0; len--) {
    if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {
      break;
    }
  }

  return len - 1;
}

function getPointAtIndex(points, idx) {
  return [points[idx * 2], points[idx * 2 + 1]];
}

function getIndexRange(points, xOrY, dim) {
  var len = points.length / 2;
  var dimIdx = dim === 'x' ? 0 : 1;
  var a;
  var b;
  var prevIndex = 0;
  var nextIndex = -1;

  for (var i = 0; i < len; i++) {
    b = points[i * 2 + dimIdx];

    if (isNaN(b) || isNaN(points[i * 2 + 1 - dimIdx])) {
      continue;
    }

    if (i === 0) {
      a = b;
      continue;
    }

    if (a <= xOrY && b >= xOrY || a >= xOrY && b <= xOrY) {
      nextIndex = i;
      break;
    }

    prevIndex = i;
    a = b;
  }

  return {
    range: [prevIndex, nextIndex],
    t: (xOrY - a) / (b - a)
  };
}

function createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {
  if ((0,_coord_CoordinateSystem__WEBPACK_IMPORTED_MODULE_5__.isCoordinateSystemType)(coordSys, 'cartesian2d')) {
    var endLabelModel_1 = seriesModel.getModel('endLabel');
    var showEndLabel = endLabelModel_1.get('show');
    var valueAnimation_1 = endLabelModel_1.get('valueAnimation');
    var data_1 = seriesModel.getData();
    var labelAnimationRecord_1 = {
      lastFrameIndex: 0
    };
    var during = showEndLabel ? function (percent, clipRect) {
      lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys);
    } : null;
    var isHorizontal = coordSys.getBaseAxis().isHorizontal();
    var clipPath = (0,_helper_createClipPathFromCoordSys__WEBPACK_IMPORTED_MODULE_6__.createGridClipPath)(coordSys, hasAnimation, seriesModel, function () {
      var endLabel = lineView._endLabel;

      if (endLabel && hasAnimation) {
        if (labelAnimationRecord_1.originalX != null) {
          endLabel.attr({
            x: labelAnimationRecord_1.originalX,
            y: labelAnimationRecord_1.originalY
          });
        }
      }
    }, during); // Expand clip shape to avoid clipping when line value exceeds axis

    if (!seriesModel.get('clip', true)) {
      var rectShape = clipPath.shape;
      var expandSize = Math.max(rectShape.width, rectShape.height);

      if (isHorizontal) {
        rectShape.y -= expandSize;
        rectShape.height += expandSize * 2;
      } else {
        rectShape.x -= expandSize;
        rectShape.width += expandSize * 2;
      }
    } // Set to the final frame. To make sure label layout is right.


    if (during) {
      during(1, clipPath);
    }

    return clipPath;
  } else {
    if (true) {
      if (seriesModel.get(['endLabel', 'show'])) {
        console.warn('endLabel is not supported for lines in polar systems.');
      }
    }

    return (0,_helper_createClipPathFromCoordSys__WEBPACK_IMPORTED_MODULE_6__.createPolarClipPath)(coordSys, hasAnimation, seriesModel);
  }
}

function getEndLabelStateSpecified(endLabelModel, coordSys) {
  var baseAxis = coordSys.getBaseAxis();
  var isHorizontal = baseAxis.isHorizontal();
  var isBaseInversed = baseAxis.inverse;
  var align = isHorizontal ? isBaseInversed ? 'right' : 'left' : 'center';
  var verticalAlign = isHorizontal ? 'middle' : isBaseInversed ? 'top' : 'bottom';
  return {
    normal: {
      align: endLabelModel.get('align') || align,
      verticalAlign: endLabelModel.get('verticalAlign') || verticalAlign
    }
  };
}

var LineView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_7__.__extends)(LineView, _super);

  function LineView() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  LineView.prototype.init = function () {
    var lineGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_8__.default();
    var symbolDraw = new _helper_SymbolDraw__WEBPACK_IMPORTED_MODULE_9__.default();
    this.group.add(symbolDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineGroup = lineGroup;
  };

  LineView.prototype.render = function (seriesModel, ecModel, api) {
    var _this = this;

    var coordSys = seriesModel.coordinateSystem;
    var group = this.group;
    var data = seriesModel.getData();
    var lineStyleModel = seriesModel.getModel('lineStyle');
    var areaStyleModel = seriesModel.getModel('areaStyle');
    var points = data.getLayout('points') || [];
    var isCoordSysPolar = coordSys.type === 'polar';
    var prevCoordSys = this._coordSys;
    var symbolDraw = this._symbolDraw;
    var polyline = this._polyline;
    var polygon = this._polygon;
    var lineGroup = this._lineGroup;
    var hasAnimation = seriesModel.get('animation');
    var isAreaChart = !areaStyleModel.isEmpty();
    var valueOrigin = areaStyleModel.get('origin');
    var dataCoordInfo = (0,_helper__WEBPACK_IMPORTED_MODULE_1__.prepareDataCoordInfo)(coordSys, data, valueOrigin);
    var stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);
    var showSymbol = seriesModel.get('showSymbol');
    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys); // Remove temporary symbols

    var oldData = this._data;
    oldData && oldData.eachItemGraphicEl(function (el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    }); // Remove previous created symbols if showSymbol changed to false

    if (!showSymbol) {
      symbolDraw.remove();
    }

    group.add(lineGroup); // FIXME step not support polar

    var step = !isCoordSysPolar ? seriesModel.get('step') : false;
    var clipShapeForSymbol;

    if (coordSys && coordSys.getArea && seriesModel.get('clip', true)) {
      clipShapeForSymbol = coordSys.getArea(); // Avoid float number rounding error for symbol on the edge of axis extent.
      // See #7913 and `test/dataZoom-clip.html`.

      if (clipShapeForSymbol.width != null) {
        clipShapeForSymbol.x -= 0.1;
        clipShapeForSymbol.y -= 0.1;
        clipShapeForSymbol.width += 0.2;
        clipShapeForSymbol.height += 0.2;
      } else if (clipShapeForSymbol.r0) {
        clipShapeForSymbol.r0 -= 0.5;
        clipShapeForSymbol.r += 0.5;
      }
    }

    this._clipShapeForSymbol = clipShapeForSymbol;
    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('style')[data.getVisual('drawType')]; // Initialization animation or coordinate system changed

    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint: function (idx) {
          return [points[idx * 2], points[idx * 2 + 1]];
        }
      });
      hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);

      if (step) {
        // TODO If stacked series is not step
        points = turnPointsIntoStep(points, coordSys, step);

        if (stackedOnPoints) {
          stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
        }
      }

      polyline = this._newPolyline(points);

      if (isAreaChart) {
        polygon = this._newPolygon(points, stackedOnPoints);
      } // NOTE: Must update _endLabel before setClipPath.


      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, (0,_util_format__WEBPACK_IMPORTED_MODULE_10__.convertToColorString)(visualColor));
      }

      lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
    } else {
      if (isAreaChart && !polygon) {
        // If areaStyle is added
        polygon = this._newPolygon(points, stackedOnPoints);
      } else if (polygon && !isAreaChart) {
        // If areaStyle is removed
        lineGroup.remove(polygon);
        polygon = this._polygon = null;
      } // NOTE: Must update _endLabel before setClipPath.


      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, (0,_util_format__WEBPACK_IMPORTED_MODULE_10__.convertToColorString)(visualColor));
      } // Update clipPath


      lineGroup.setClipPath(createLineClipPath(this, coordSys, false, seriesModel)); // Always update, or it is wrong in the case turning on legend
      // because points are not changed

      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint: function (idx) {
          return [points[idx * 2], points[idx * 2 + 1]];
        }
      }); // In the case data zoom triggerred refreshing frequently
      // Data may not change if line has a category axis. So it should animate nothing

      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {
        if (hasAnimation) {
          this._doUpdateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);
        } else {
          // Not do it in update with animation
          if (step) {
            // TODO If stacked series is not step
            points = turnPointsIntoStep(points, coordSys, step);

            if (stackedOnPoints) {
              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
            }
          }

          polyline.setShape({
            points: points
          });
          polygon && polygon.setShape({
            points: points,
            stackedOnPoints: stackedOnPoints
          });
        }
      }
    }

    var focus = seriesModel.get(['emphasis', 'focus']);
    var blurScope = seriesModel.get(['emphasis', 'blurScope']);
    polyline.useStyle(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.defaults( // Use color in lineStyle first
    lineStyleModel.getLineStyle(), {
      fill: 'none',
      stroke: visualColor,
      lineJoin: 'bevel'
    }));
    (0,_util_states__WEBPACK_IMPORTED_MODULE_11__.setStatesStylesFromModel)(polyline, seriesModel, 'lineStyle');

    if (polyline.style.lineWidth > 0 && seriesModel.get(['emphasis', 'lineStyle', 'width']) === 'bolder') {
      var emphasisLineStyle = polyline.getState('emphasis').style;
      emphasisLineStyle.lineWidth = polyline.style.lineWidth + 1;
    } // Needs seriesIndex for focus


    (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_12__.getECData)(polyline).seriesIndex = seriesModel.seriesIndex;
    (0,_util_states__WEBPACK_IMPORTED_MODULE_11__.enableHoverEmphasis)(polyline, focus, blurScope);
    var smooth = getSmooth(seriesModel.get('smooth'));
    var smoothMonotone = seriesModel.get('smoothMonotone');
    var connectNulls = seriesModel.get('connectNulls');
    polyline.setShape({
      smooth: smooth,
      smoothMonotone: smoothMonotone,
      connectNulls: connectNulls
    });

    if (polygon) {
      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');
      var stackedOnSmooth = 0;
      polygon.useStyle(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.defaults(areaStyleModel.getAreaStyle(), {
        fill: visualColor,
        opacity: 0.7,
        lineJoin: 'bevel',
        decal: data.getVisual('style').decal
      }));

      if (stackedOnSeries) {
        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));
      }

      polygon.setShape({
        smooth: smooth,
        stackedOnSmooth: stackedOnSmooth,
        smoothMonotone: smoothMonotone,
        connectNulls: connectNulls
      });
      (0,_util_states__WEBPACK_IMPORTED_MODULE_11__.setStatesStylesFromModel)(polygon, seriesModel, 'areaStyle'); // Needs seriesIndex for focus

      (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_12__.getECData)(polygon).seriesIndex = seriesModel.seriesIndex;
      (0,_util_states__WEBPACK_IMPORTED_MODULE_11__.enableHoverEmphasis)(polygon, focus, blurScope);
    }

    var changePolyState = function (toState) {
      _this._changePolyState(toState);
    };

    data.eachItemGraphicEl(function (el) {
      // Switch polyline / polygon state if element changed its state.
      el && (el.onHoverStateChange = changePolyState);
    });
    this._polyline.onHoverStateChange = changePolyState;
    this._data = data; // Save the coordinate system for transition animation when data changed

    this._coordSys = coordSys;
    this._stackedOnPoints = stackedOnPoints;
    this._points = points;
    this._step = step;
    this._valueOrigin = valueOrigin;
  };

  LineView.prototype.dispose = function () {};

  LineView.prototype.highlight = function (seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = _util_model__WEBPACK_IMPORTED_MODULE_13__.queryDataIndex(data, payload);

    this._changePolyState('emphasis');

    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
      var points = data.getLayout('points');
      var symbol = data.getItemGraphicEl(dataIndex);

      if (!symbol) {
        // Create a temporary symbol if it is not exists
        var x = points[dataIndex * 2];
        var y = points[dataIndex * 2 + 1];

        if (isNaN(x) || isNaN(y)) {
          // Null data
          return;
        } // fix #11360: should't draw symbol outside clipShapeForSymbol


        if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x, y)) {
          return;
        }

        symbol = new _helper_Symbol__WEBPACK_IMPORTED_MODULE_4__.default(data, dataIndex);
        symbol.x = x;
        symbol.y = y;
        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));
        symbol.__temp = true;
        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation

        symbol.stopSymbolAnimation(true);
        this.group.add(symbol);
      }

      symbol.highlight();
    } else {
      // Highlight whole series
      _view_Chart__WEBPACK_IMPORTED_MODULE_14__.default.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
    }
  };

  LineView.prototype.downplay = function (seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = _util_model__WEBPACK_IMPORTED_MODULE_13__.queryDataIndex(data, payload);

    this._changePolyState('normal');

    if (dataIndex != null && dataIndex >= 0) {
      var symbol = data.getItemGraphicEl(dataIndex);

      if (symbol) {
        if (symbol.__temp) {
          data.setItemGraphicEl(dataIndex, null);
          this.group.remove(symbol);
        } else {
          symbol.downplay();
        }
      }
    } else {
      // FIXME
      // can not downplay completely.
      // Downplay whole series
      _view_Chart__WEBPACK_IMPORTED_MODULE_14__.default.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
    }
  };

  LineView.prototype._changePolyState = function (toState) {
    var polygon = this._polygon;
    (0,_util_states__WEBPACK_IMPORTED_MODULE_11__.setStatesFlag)(this._polyline, toState);
    polygon && (0,_util_states__WEBPACK_IMPORTED_MODULE_11__.setStatesFlag)(polygon, toState);
  };

  LineView.prototype._newPolyline = function (points) {
    var polyline = this._polyline; // Remove previous created polyline

    if (polyline) {
      this._lineGroup.remove(polyline);
    }

    polyline = new _poly__WEBPACK_IMPORTED_MODULE_15__.ECPolyline({
      shape: {
        points: points
      },
      segmentIgnoreThreshold: 2,
      z2: 10
    });

    this._lineGroup.add(polyline);

    this._polyline = polyline;
    return polyline;
  };

  LineView.prototype._newPolygon = function (points, stackedOnPoints) {
    var polygon = this._polygon; // Remove previous created polygon

    if (polygon) {
      this._lineGroup.remove(polygon);
    }

    polygon = new _poly__WEBPACK_IMPORTED_MODULE_15__.ECPolygon({
      shape: {
        points: points,
        stackedOnPoints: stackedOnPoints
      },
      segmentIgnoreThreshold: 2
    });

    this._lineGroup.add(polygon);

    this._polygon = polygon;
    return polygon;
  };

  LineView.prototype._initSymbolLabelAnimation = function (data, coordSys, clipShape) {
    var isHorizontalOrRadial;
    var isCoordSysPolar;
    var baseAxis = coordSys.getBaseAxis();
    var isAxisInverse = baseAxis.inverse;

    if (coordSys.type === 'cartesian2d') {
      isHorizontalOrRadial = baseAxis.isHorizontal();
      isCoordSysPolar = false;
    } else if (coordSys.type === 'polar') {
      isHorizontalOrRadial = baseAxis.dim === 'angle';
      isCoordSysPolar = true;
    }

    var seriesModel = data.hostModel;
    var seriesDuration = seriesModel.get('animationDuration');

    if (typeof seriesDuration === 'function') {
      seriesDuration = seriesDuration(null);
    }

    var seriesDalay = seriesModel.get('animationDelay') || 0;
    var seriesDalayValue = typeof seriesDalay === 'function' ? seriesDalay(null) : seriesDalay;
    data.eachItemGraphicEl(function (symbol, idx) {
      var el = symbol;

      if (el) {
        var point = [symbol.x, symbol.y];
        var start = void 0;
        var end = void 0;
        var current = void 0;

        if (isCoordSysPolar) {
          var polarClip = clipShape;
          var coord = coordSys.pointToCoord(point);

          if (isHorizontalOrRadial) {
            start = polarClip.startAngle;
            end = polarClip.endAngle;
            current = -coord[1] / 180 * Math.PI;
          } else {
            start = polarClip.r0;
            end = polarClip.r;
            current = coord[0];
          }
        } else {
          var gridClip = clipShape;

          if (isHorizontalOrRadial) {
            start = gridClip.x;
            end = gridClip.x + gridClip.width;
            current = symbol.x;
          } else {
            start = gridClip.y + gridClip.height;
            end = gridClip.y;
            current = symbol.y;
          }
        }

        var ratio = end === start ? 0 : (current - start) / (end - start);

        if (isAxisInverse) {
          ratio = 1 - ratio;
        }

        var delay = typeof seriesDalay === 'function' ? seriesDalay(idx) : seriesDuration * ratio + seriesDalayValue;
        var symbolPath = el.getSymbolPath();
        var text = symbolPath.getTextContent();
        el.attr({
          scaleX: 0,
          scaleY: 0
        });
        el.animateTo({
          scaleX: 1,
          scaleY: 1
        }, {
          duration: 200,
          delay: delay
        });

        if (text) {
          text.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: delay
          });
        }

        symbolPath.disableLabelAnimation = true;
      }
    });
  };

  LineView.prototype._initOrUpdateEndLabel = function (seriesModel, coordSys, inheritColor) {
    var endLabelModel = seriesModel.getModel('endLabel');

    if (endLabelModel.get('show')) {
      var data_2 = seriesModel.getData();
      var polyline = this._polyline;
      var endLabel = this._endLabel;

      if (!endLabel) {
        endLabel = this._endLabel = new _util_graphic__WEBPACK_IMPORTED_MODULE_16__.default({
          z2: 200 // should be higher than item symbol

        });
        endLabel.ignoreClip = true;
        polyline.setTextContent(this._endLabel);
        polyline.disableLabelAnimation = true;
      } // Find last non-NaN data to display data


      var dataIndex = getLastIndexNotNull(data_2.getLayout('points'));

      if (dataIndex >= 0) {
        (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_17__.setLabelStyle)(polyline, (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_17__.getLabelStatesModels)(seriesModel, 'endLabel'), {
          inheritColor: inheritColor,
          labelFetcher: seriesModel,
          labelDataIndex: dataIndex,
          defaultText: function (dataIndex, opt, interpolatedValue) {
            return interpolatedValue != null ? (0,_helper_labelHelper__WEBPACK_IMPORTED_MODULE_18__.getDefaultInterpolatedLabel)(data_2, interpolatedValue) : (0,_helper_labelHelper__WEBPACK_IMPORTED_MODULE_18__.getDefaultLabel)(data_2, dataIndex);
          },
          enableTextSetter: true
        }, getEndLabelStateSpecified(endLabelModel, coordSys));
        polyline.textConfig.position = null;
      }
    } else if (this._endLabel) {
      this._polyline.removeTextContent();

      this._endLabel = null;
    }
  };

  LineView.prototype._endLabelOnDuring = function (percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {
    var endLabel = this._endLabel;
    var polyline = this._polyline;

    if (endLabel) {
      // NOTE: Don't remove percent < 1. percent === 1 means the first frame during render.
      // The label is not prepared at this time.
      if (percent < 1 && animationRecord.originalX == null) {
        animationRecord.originalX = endLabel.x;
        animationRecord.originalY = endLabel.y;
      }

      var points = data.getLayout('points');
      var seriesModel = data.hostModel;
      var connectNulls = seriesModel.get('connectNulls');
      var precision = endLabelModel.get('precision');
      var distance = endLabelModel.get('distance') || 0;
      var baseAxis = coordSys.getBaseAxis();
      var isHorizontal = baseAxis.isHorizontal();
      var isBaseInversed = baseAxis.inverse;
      var clipShape = clipRect.shape;
      var xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;
      var distanceX = (isHorizontal ? distance : 0) * (isBaseInversed ? -1 : 1);
      var distanceY = (isHorizontal ? 0 : -distance) * (isBaseInversed ? -1 : 1);
      var dim = isHorizontal ? 'x' : 'y';
      var dataIndexRange = getIndexRange(points, xOrY, dim);
      var indices = dataIndexRange.range;
      var diff = indices[1] - indices[0];
      var value = void 0;

      if (diff >= 1) {
        // diff > 1 && connectNulls, which is on the null data.
        if (diff > 1 && !connectNulls) {
          var pt = getPointAtIndex(points, indices[0]);
          endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          valueAnimation && (value = seriesModel.getRawValue(indices[0]));
        } else {
          var pt = polyline.getPointOn(xOrY, dim);
          pt && endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          var startValue = seriesModel.getRawValue(indices[0]);
          var endValue = seriesModel.getRawValue(indices[1]);
          valueAnimation && (value = _util_model__WEBPACK_IMPORTED_MODULE_13__.interpolateRawValues(data, precision, startValue, endValue, dataIndexRange.t));
        }

        animationRecord.lastFrameIndex = indices[0];
      } else {
        // If diff <= 0, which is the range is not found(Include NaN)
        // Choose the first point or last point.
        var idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;
        var pt = getPointAtIndex(points, idx);
        valueAnimation && (value = seriesModel.getRawValue(idx));
        endLabel.attr({
          x: pt[0] + distanceX,
          y: pt[1] + distanceY
        });
      }

      if (valueAnimation) {
        (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_17__.labelInner)(endLabel).setLabelText(value);
      }
    }
  };
  /**
   * @private
   */
  // FIXME Two value axis


  LineView.prototype._doUpdateAnimation = function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {
    var polyline = this._polyline;
    var polygon = this._polygon;
    var seriesModel = data.hostModel;
    var diff = (0,_lineAnimationDiff__WEBPACK_IMPORTED_MODULE_19__.default)(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);
    var current = diff.current;
    var stackedOnCurrent = diff.stackedOnCurrent;
    var next = diff.next;
    var stackedOnNext = diff.stackedOnNext;

    if (step) {
      // TODO If stacked series is not step
      current = turnPointsIntoStep(diff.current, coordSys, step);
      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);
      next = turnPointsIntoStep(diff.next, coordSys, step);
      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);
    } // Don't apply animation if diff is large.
    // For better result and avoid memory explosion problems like
    // https://github.com/apache/incubator-echarts/issues/12229


    if (getBoundingDiff(current, next) > 3000 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3000) {
      polyline.setShape({
        points: next
      });

      if (polygon) {
        polygon.setShape({
          points: next,
          stackedOnPoints: stackedOnNext
        });
      }

      return;
    }

    polyline.shape.__points = diff.current;
    polyline.shape.points = current;
    var target = {
      shape: {
        points: next
      }
    }; // Also animate the original points.
    // If points reference is changed when turning into step line.

    if (diff.current !== current) {
      target.shape.__points = diff.next;
    } // Stop previous animation.


    polyline.stopAnimation();
    _util_graphic__WEBPACK_IMPORTED_MODULE_20__.updateProps(polyline, target, seriesModel);

    if (polygon) {
      polygon.setShape({
        // Reuse the points with polyline.
        points: current,
        stackedOnPoints: stackedOnCurrent
      });
      polygon.stopAnimation();
      _util_graphic__WEBPACK_IMPORTED_MODULE_20__.updateProps(polygon, {
        shape: {
          stackedOnPoints: stackedOnNext
        }
      }, seriesModel); // If use attr directly in updateProps.

      if (polyline.shape.points !== polygon.shape.points) {
        polygon.shape.points = polyline.shape.points;
      }
    }

    var updatedDataInfo = [];
    var diffStatus = diff.status;

    for (var i = 0; i < diffStatus.length; i++) {
      var cmd = diffStatus[i].cmd;

      if (cmd === '=') {
        var el = data.getItemGraphicEl(diffStatus[i].idx1);

        if (el) {
          updatedDataInfo.push({
            el: el,
            ptIdx: i // Index of points

          });
        }
      }
    }

    if (polyline.animators && polyline.animators.length) {
      polyline.animators[0].during(function () {
        polygon && polygon.dirtyShape();
        var points = polyline.shape.__points;

        for (var i = 0; i < updatedDataInfo.length; i++) {
          var el = updatedDataInfo[i].el;
          var offset = updatedDataInfo[i].ptIdx * 2;
          el.x = points[offset];
          el.y = points[offset + 1];
          el.markRedraw();
        }
      });
    }
  };

  LineView.prototype.remove = function (ecModel) {
    var group = this.group;
    var oldData = this._data;

    this._lineGroup.removeAll();

    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting


    oldData && oldData.eachItemGraphicEl(function (el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
  };

  LineView.type = 'line';
  return LineView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_14__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LineView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/helper.js":
/*!*******************************************************!*\
  !*** ./node_modules/echarts/lib/chart/line/helper.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "prepareDataCoordInfo": () => (/* binding */ prepareDataCoordInfo),
/* harmony export */   "getStackedOnPoint": () => (/* binding */ getStackedOnPoint)
/* harmony export */ });
/* harmony import */ var _data_helper_dataStackHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/helper/dataStackHelper */ "./node_modules/echarts/lib/data/helper/dataStackHelper.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function prepareDataCoordInfo(coordSys, data, valueOrigin) {
  var baseAxis = coordSys.getBaseAxis();
  var valueAxis = coordSys.getOtherAxis(baseAxis);
  var valueStart = getValueStart(valueAxis, valueOrigin);
  var baseAxisDim = baseAxis.dim;
  var valueAxisDim = valueAxis.dim;
  var valueDim = data.mapDimension(valueAxisDim);
  var baseDim = data.mapDimension(baseAxisDim);
  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;
  var dims = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map)(coordSys.dimensions, function (coordDim) {
    return data.mapDimension(coordDim);
  });
  var stacked = false;
  var stackResultDim = data.getCalculationInfo('stackResultDimension');

  if ((0,_data_helper_dataStackHelper__WEBPACK_IMPORTED_MODULE_1__.isDimensionStacked)(data, dims[0]
  /*, dims[1]*/
  )) {
    // jshint ignore:line
    stacked = true;
    dims[0] = stackResultDim;
  }

  if ((0,_data_helper_dataStackHelper__WEBPACK_IMPORTED_MODULE_1__.isDimensionStacked)(data, dims[1]
  /*, dims[0]*/
  )) {
    // jshint ignore:line
    stacked = true;
    dims[1] = stackResultDim;
  }

  return {
    dataDimsForPoint: dims,
    valueStart: valueStart,
    valueAxisDim: valueAxisDim,
    baseAxisDim: baseAxisDim,
    stacked: !!stacked,
    valueDim: valueDim,
    baseDim: baseDim,
    baseDataOffset: baseDataOffset,
    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')
  };
}

function getValueStart(valueAxis, valueOrigin) {
  var valueStart = 0;
  var extent = valueAxis.scale.getExtent();

  if (valueOrigin === 'start') {
    valueStart = extent[0];
  } else if (valueOrigin === 'end') {
    valueStart = extent[1];
  } // auto
  else {
      // Both positive
      if (extent[0] > 0) {
        valueStart = extent[0];
      } // Both negative
      else if (extent[1] < 0) {
          valueStart = extent[1];
        } // If is one positive, and one negative, onZero shall be true

    }

  return valueStart;
}

function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
  var value = NaN;

  if (dataCoordInfo.stacked) {
    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);
  }

  if (isNaN(value)) {
    value = dataCoordInfo.valueStart;
  }

  var baseDataOffset = dataCoordInfo.baseDataOffset;
  var stackedData = [];
  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
  stackedData[1 - baseDataOffset] = value;
  return coordSys.dataToPoint(stackedData);
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/install.js":
/*!********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/line/install.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _LineSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LineSeries */ "./node_modules/echarts/lib/chart/line/LineSeries.js");
/* harmony import */ var _LineView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineView */ "./node_modules/echarts/lib/chart/line/LineView.js");
/* harmony import */ var _layout_points__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../layout/points */ "./node_modules/echarts/lib/layout/points.js");
/* harmony import */ var _processor_dataSample__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../processor/dataSample */ "./node_modules/echarts/lib/processor/dataSample.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

 // In case developer forget to include grid component



function install(registers) {
  registers.registerChartView(_LineView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerSeriesModel(_LineSeries__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerLayout((0,_layout_points__WEBPACK_IMPORTED_MODULE_2__.default)('line', true)); // Down sample after filter

  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, (0,_processor_dataSample__WEBPACK_IMPORTED_MODULE_3__.default)('line'));
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/lineAnimationDiff.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/line/lineAnimationDiff.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ lineAnimationDiff)
/* harmony export */ });
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helper */ "./node_modules/echarts/lib/chart/line/helper.js");
/* harmony import */ var _util_vendor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/vendor */ "./node_modules/echarts/lib/util/vendor.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function diffData(oldData, newData) {
  var diffResult = [];
  newData.diff(oldData).add(function (idx) {
    diffResult.push({
      cmd: '+',
      idx: idx
    });
  }).update(function (newIdx, oldIdx) {
    diffResult.push({
      cmd: '=',
      idx: oldIdx,
      idx1: newIdx
    });
  }).remove(function (idx) {
    diffResult.push({
      cmd: '-',
      idx: idx
    });
  }).execute();
  return diffResult;
}

function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
  var diff = diffData(oldData, newData); // let newIdList = newData.mapArray(newData.getId);
  // let oldIdList = oldData.mapArray(oldData.getId);
  // convertToIntId(newIdList, oldIdList);
  // // FIXME One data ?
  // diff = arrayDiff(oldIdList, newIdList);

  var currPoints = [];
  var nextPoints = []; // Points for stacking base line

  var currStackedPoints = [];
  var nextStackedPoints = [];
  var status = [];
  var sortedIndices = [];
  var rawIndices = [];
  var newDataOldCoordInfo = (0,_helper__WEBPACK_IMPORTED_MODULE_0__.prepareDataCoordInfo)(oldCoordSys, newData, oldValueOrigin);
  var oldDataNewCoordInfo = (0,_helper__WEBPACK_IMPORTED_MODULE_0__.prepareDataCoordInfo)(newCoordSys, oldData, newValueOrigin);
  var oldPoints = oldData.getLayout('points') || [];
  var newPoints = newData.getLayout('points') || [];

  for (var i = 0; i < diff.length; i++) {
    var diffItem = diff[i];
    var pointAdded = true;
    var oldIdx2 = void 0;
    var newIdx2 = void 0; // FIXME, animation is not so perfect when dataZoom window moves fast
    // Which is in case remvoing or add more than one data in the tail or head

    switch (diffItem.cmd) {
      case '=':
        oldIdx2 = diffItem.idx * 2;
        newIdx2 = diffItem.idx1 * 2;
        var currentX = oldPoints[oldIdx2];
        var currentY = oldPoints[oldIdx2 + 1];
        var nextX = newPoints[newIdx2];
        var nextY = newPoints[newIdx2 + 1]; // If previous data is NaN, use next point directly

        if (isNaN(currentX) || isNaN(currentY)) {
          currentX = nextX;
          currentY = nextY;
        }

        currPoints.push(currentX, currentY);
        nextPoints.push(nextX, nextY);
        currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(diffItem.idx1));
        break;

      case '+':
        var newIdx = diffItem.idx;
        var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;
        var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);
        newIdx2 = newIdx * 2;
        currPoints.push(oldPt[0], oldPt[1]);
        nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);
        var stackedOnPoint = (0,_helper__WEBPACK_IMPORTED_MODULE_0__.getStackedOnPoint)(newDataOldCoordInfo, oldCoordSys, newData, newIdx);
        currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(newIdx));
        break;

      case '-':
        var oldIdx = diffItem.idx;
        var rawIndex = oldData.getRawIndex(oldIdx);
        var oldDataDimsForPoint = oldDataNewCoordInfo.dataDimsForPoint;
        oldIdx2 = oldIdx * 2; // Data is replaced. In the case of dynamic data queue
        // FIXME FIXME FIXME

        if (rawIndex !== oldIdx) {
          var newPt = newCoordSys.dataToPoint([oldData.get(oldDataDimsForPoint[0], oldIdx), oldData.get(oldDataDimsForPoint[1], oldIdx)]);
          var newStackedOnPt = (0,_helper__WEBPACK_IMPORTED_MODULE_0__.getStackedOnPoint)(oldDataNewCoordInfo, newCoordSys, oldData, oldIdx);
          currPoints.push(oldPoints[oldIdx2], oldPoints[oldIdx2 + 1]);
          nextPoints.push(newPt[0], newPt[1]);
          currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
          nextStackedPoints.push(newStackedOnPt[0], newStackedOnPt[1]);
          rawIndices.push(rawIndex);
        } else {
          pointAdded = false;
        }

    } // Original indices


    if (pointAdded) {
      status.push(diffItem);
      sortedIndices.push(sortedIndices.length);
    }
  } // Diff result may be crossed if all items are changed
  // Sort by data index


  sortedIndices.sort(function (a, b) {
    return rawIndices[a] - rawIndices[b];
  });
  var len = currPoints.length;
  var sortedCurrPoints = (0,_util_vendor__WEBPACK_IMPORTED_MODULE_1__.createFloat32Array)(len);
  var sortedNextPoints = (0,_util_vendor__WEBPACK_IMPORTED_MODULE_1__.createFloat32Array)(len);
  var sortedCurrStackedPoints = (0,_util_vendor__WEBPACK_IMPORTED_MODULE_1__.createFloat32Array)(len);
  var sortedNextStackedPoints = (0,_util_vendor__WEBPACK_IMPORTED_MODULE_1__.createFloat32Array)(len);
  var sortedStatus = [];

  for (var i = 0; i < sortedIndices.length; i++) {
    var idx = sortedIndices[i];
    var i2 = i * 2;
    var idx2 = idx * 2;
    sortedCurrPoints[i2] = currPoints[idx2];
    sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1];
    sortedNextPoints[i2] = nextPoints[idx2];
    sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1];
    sortedCurrStackedPoints[i2] = currStackedPoints[idx2];
    sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1];
    sortedNextStackedPoints[i2] = nextStackedPoints[idx2];
    sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1];
    sortedStatus[i] = status[idx];
  }

  return {
    current: sortedCurrPoints,
    next: sortedNextPoints,
    stackedOnCurrent: sortedCurrStackedPoints,
    stackedOnNext: sortedNextStackedPoints,
    status: sortedStatus
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/line/poly.js":
/*!*****************************************************!*\
  !*** ./node_modules/echarts/lib/chart/line/poly.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ECPolyline": () => (/* binding */ ECPolyline),
/* harmony export */   "ECPolygon": () => (/* binding */ ECPolygon)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_graphic_Path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/graphic/Path */ "./node_modules/zrender/lib/graphic/Path.js");
/* harmony import */ var zrender_lib_core_PathProxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/PathProxy */ "./node_modules/zrender/lib/core/PathProxy.js");
/* harmony import */ var zrender_lib_core_curve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/curve */ "./node_modules/zrender/lib/core/curve.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
 // Poly path support NaN point




var mathMin = Math.min;
var mathMax = Math.max;

function isPointNull(x, y) {
  return isNaN(x) || isNaN(y);
}
/**
 * Draw smoothed line in non-monotone, in may cause undesired curve in extreme
 * situations. This should be used when points are non-monotone neither in x or
 * y dimension.
 */


function drawSegment(ctx, points, start, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {
  var prevX;
  var prevY;
  var cpx0;
  var cpy0;
  var cpx1;
  var cpy1;
  var idx = start;
  var k = 0;

  for (; k < segLen; k++) {
    var x = points[idx * 2];
    var y = points[idx * 2 + 1];

    if (idx >= allLen || idx < 0) {
      break;
    }

    if (isPointNull(x, y)) {
      if (connectNulls) {
        idx += dir;
        continue;
      }

      break;
    }

    if (idx === start) {
      ctx[dir > 0 ? 'moveTo' : 'lineTo'](x, y);
      cpx0 = x;
      cpy0 = y;
    } else {
      var dx = x - prevX;
      var dy = y - prevY; // Ignore tiny segment.

      if (dx * dx + dy * dy < 0.5) {
        idx += dir;
        continue;
      }

      if (smooth > 0) {
        var nextIdx = idx + dir;
        var nextX = points[nextIdx * 2];
        var nextY = points[nextIdx * 2 + 1];
        var tmpK = k + 1;

        if (connectNulls) {
          // Find next point not null
          while (isPointNull(nextX, nextY) && tmpK < segLen) {
            tmpK++;
            nextIdx += dir;
            nextX = points[nextIdx * 2];
            nextY = points[nextIdx * 2 + 1];
          }
        }

        var ratioNextSeg = 0.5;
        var vx = 0;
        var vy = 0;
        var nextCpx0 = void 0;
        var nextCpy0 = void 0; // Is last point

        if (tmpK >= segLen || isPointNull(nextX, nextY)) {
          cpx1 = x;
          cpy1 = y;
        } else {
          vx = nextX - prevX;
          vy = nextY - prevY;
          var dx0 = x - prevX;
          var dx1 = nextX - x;
          var dy0 = y - prevY;
          var dy1 = nextY - y;
          var lenPrevSeg = void 0;
          var lenNextSeg = void 0;

          if (smoothMonotone === 'x') {
            lenPrevSeg = Math.abs(dx0);
            lenNextSeg = Math.abs(dx1);
            cpx1 = x - lenPrevSeg * smooth;
            cpy1 = y;
            nextCpx0 = x + lenPrevSeg * smooth;
            nextCpy0 = y;
          } else if (smoothMonotone === 'y') {
            lenPrevSeg = Math.abs(dy0);
            lenNextSeg = Math.abs(dy1);
            cpx1 = x;
            cpy1 = y - lenPrevSeg * smooth;
            nextCpx0 = x;
            nextCpy0 = y + lenPrevSeg * smooth;
          } else {
            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);
            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1); // Use ratio of seg length

            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
            cpx1 = x - vx * smooth * (1 - ratioNextSeg);
            cpy1 = y - vy * smooth * (1 - ratioNextSeg); // cp0 of next segment

            nextCpx0 = x + vx * smooth * ratioNextSeg;
            nextCpy0 = y + vy * smooth * ratioNextSeg; // Smooth constraint between point and next point.
            // Avoid exceeding extreme after smoothing.

            nextCpx0 = mathMin(nextCpx0, mathMax(nextX, x));
            nextCpy0 = mathMin(nextCpy0, mathMax(nextY, y));
            nextCpx0 = mathMax(nextCpx0, mathMin(nextX, x));
            nextCpy0 = mathMax(nextCpy0, mathMin(nextY, y)); // Reclaculate cp1 based on the adjusted cp0 of next seg.

            vx = nextCpx0 - x;
            vy = nextCpy0 - y;
            cpx1 = x - vx * lenPrevSeg / lenNextSeg;
            cpy1 = y - vy * lenPrevSeg / lenNextSeg; // Smooth constraint between point and prev point.
            // Avoid exceeding extreme after smoothing.

            cpx1 = mathMin(cpx1, mathMax(prevX, x));
            cpy1 = mathMin(cpy1, mathMax(prevY, y));
            cpx1 = mathMax(cpx1, mathMin(prevX, x));
            cpy1 = mathMax(cpy1, mathMin(prevY, y)); // Adjust next cp0 again.

            vx = x - cpx1;
            vy = y - cpy1;
            nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;
            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;
          }
        }

        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);
        cpx0 = nextCpx0;
        cpy0 = nextCpy0;
      } else {
        ctx.lineTo(x, y);
      }
    }

    prevX = x;
    prevY = y;
    idx += dir;
  }

  return k;
}

var ECPolylineShape =
/** @class */
function () {
  function ECPolylineShape() {
    this.smooth = 0;
    this.smoothConstraint = true;
  }

  return ECPolylineShape;
}();

var ECPolyline =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ECPolyline, _super);

  function ECPolyline(opts) {
    var _this = _super.call(this, opts) || this;

    _this.type = 'ec-polyline';
    return _this;
  }

  ECPolyline.prototype.getDefaultStyle = function () {
    return {
      stroke: '#000',
      fill: null
    };
  };

  ECPolyline.prototype.getDefaultShape = function () {
    return new ECPolylineShape();
  };

  ECPolyline.prototype.buildPath = function (ctx, shape) {
    var points = shape.points;
    var i = 0;
    var len = points.length / 2; // const result = getBoundingBox(points, shape.smoothConstraint);

    if (shape.connectNulls) {
      // Must remove first and last null values avoid draw error in polygon
      for (; len > 0; len--) {
        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {
          break;
        }
      }

      for (; i < len; i++) {
        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {
          break;
        }
      }
    }

    while (i < len) {
      i += drawSegment(ctx, points, i, len, len, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
    }
  };

  ECPolyline.prototype.getPointOn = function (xOrY, dim) {
    if (!this.path) {
      this.createPathProxy();
      this.buildPath(this.path, this.shape);
    }

    var path = this.path;
    var data = path.data;
    var CMD = zrender_lib_core_PathProxy__WEBPACK_IMPORTED_MODULE_1__.default.CMD;
    var x0;
    var y0;
    var isDimX = dim === 'x';
    var roots = [];

    for (var i = 0; i < data.length;) {
      var cmd = data[i++];
      var x = void 0;
      var y = void 0;
      var x2 = void 0;
      var y2 = void 0;
      var x3 = void 0;
      var y3 = void 0;
      var t = void 0;

      switch (cmd) {
        case CMD.M:
          x0 = data[i++];
          y0 = data[i++];
          break;

        case CMD.L:
          x = data[i++];
          y = data[i++];
          t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);

          if (t <= 1 && t >= 0) {
            var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;
            return isDimX ? [xOrY, val] : [val, xOrY];
          }

          x0 = x;
          y0 = y;
          break;

        case CMD.C:
          x = data[i++];
          y = data[i++];
          x2 = data[i++];
          y2 = data[i++];
          x3 = data[i++];
          y3 = data[i++];
          var nRoot = isDimX ? (0,zrender_lib_core_curve__WEBPACK_IMPORTED_MODULE_2__.cubicRootAt)(x0, x, x2, x3, xOrY, roots) : (0,zrender_lib_core_curve__WEBPACK_IMPORTED_MODULE_2__.cubicRootAt)(y0, y, y2, y3, xOrY, roots);

          if (nRoot > 0) {
            for (var i_1 = 0; i_1 < nRoot; i_1++) {
              var t_1 = roots[i_1];

              if (t_1 <= 1 && t_1 >= 0) {
                var val = isDimX ? (0,zrender_lib_core_curve__WEBPACK_IMPORTED_MODULE_2__.cubicAt)(y0, y, y2, y3, t_1) : (0,zrender_lib_core_curve__WEBPACK_IMPORTED_MODULE_2__.cubicAt)(x0, x, x2, x3, t_1);
                return isDimX ? [xOrY, val] : [val, xOrY];
              }
            }
          }

          x0 = x3;
          y0 = y3;
          break;
      }
    }
  };

  return ECPolyline;
}(zrender_lib_graphic_Path__WEBPACK_IMPORTED_MODULE_3__.default);



var ECPolygonShape =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ECPolygonShape, _super);

  function ECPolygonShape() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return ECPolygonShape;
}(ECPolylineShape);

var ECPolygon =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ECPolygon, _super);

  function ECPolygon(opts) {
    var _this = _super.call(this, opts) || this;

    _this.type = 'ec-polygon';
    return _this;
  }

  ECPolygon.prototype.getDefaultShape = function () {
    return new ECPolygonShape();
  };

  ECPolygon.prototype.buildPath = function (ctx, shape) {
    var points = shape.points;
    var stackedOnPoints = shape.stackedOnPoints;
    var i = 0;
    var len = points.length / 2;
    var smoothMonotone = shape.smoothMonotone;

    if (shape.connectNulls) {
      // Must remove first and last null values avoid draw error in polygon
      for (; len > 0; len--) {
        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {
          break;
        }
      }

      for (; i < len; i++) {
        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {
          break;
        }
      }
    }

    while (i < len) {
      var k = drawSegment(ctx, points, i, len, len, 1, shape.smooth, smoothMonotone, shape.connectNulls);
      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
      i += k + 1;
      ctx.closePath();
    }
  };

  return ECPolygon;
}(zrender_lib_graphic_Path__WEBPACK_IMPORTED_MODULE_3__.default);



/***/ }),

/***/ "./node_modules/echarts/lib/chart/lines/LinesSeries.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/lines/LinesSeries.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var _data_List__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/List */ "./node_modules/echarts/lib/data/List.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _core_CoordinateSystem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/CoordinateSystem */ "./node_modules/echarts/lib/core/CoordinateSystem.js");
/* harmony import */ var _component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../component/tooltip/tooltipMarkup */ "./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/* global Uint32Array, Float64Array, Float32Array */






var Uint32Arr = typeof Uint32Array === 'undefined' ? Array : Uint32Array;
var Float64Arr = typeof Float64Array === 'undefined' ? Array : Float64Array;

function compatEc2(seriesOpt) {
  var data = seriesOpt.data;

  if (data && data[0] && data[0][0] && data[0][0].coord) {
    if (true) {
      console.warn('Lines data configuration has been changed to' + ' { coords:[[1,2],[2,3]] }');
    }

    seriesOpt.data = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map)(data, function (itemOpt) {
      var coords = [itemOpt[0].coord, itemOpt[1].coord];
      var target = {
        coords: coords
      };

      if (itemOpt[0].name) {
        target.fromName = itemOpt[0].name;
      }

      if (itemOpt[1].name) {
        target.toName = itemOpt[1].name;
      }

      return (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.mergeAll)([target, itemOpt[0], itemOpt[1]]);
    });
  }
}

var LinesSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(LinesSeriesModel, _super);

  function LinesSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = LinesSeriesModel.type;
    _this.visualStyleAccessPath = 'lineStyle';
    _this.visualDrawType = 'stroke';
    return _this;
  }

  LinesSeriesModel.prototype.init = function (option) {
    // The input data may be null/undefined.
    option.data = option.data || []; // Not using preprocessor because mergeOption may not have series.type

    compatEc2(option);

    var result = this._processFlatCoordsArray(option.data);

    this._flatCoords = result.flatCoords;
    this._flatCoordsOffset = result.flatCoordsOffset;

    if (result.flatCoords) {
      option.data = new Float32Array(result.count);
    }

    _super.prototype.init.apply(this, arguments);
  };

  LinesSeriesModel.prototype.mergeOption = function (option) {
    compatEc2(option);

    if (option.data) {
      // Only update when have option data to merge.
      var result = this._processFlatCoordsArray(option.data);

      this._flatCoords = result.flatCoords;
      this._flatCoordsOffset = result.flatCoordsOffset;

      if (result.flatCoords) {
        option.data = new Float32Array(result.count);
      }
    }

    _super.prototype.mergeOption.apply(this, arguments);
  };

  LinesSeriesModel.prototype.appendData = function (params) {
    var result = this._processFlatCoordsArray(params.data);

    if (result.flatCoords) {
      if (!this._flatCoords) {
        this._flatCoords = result.flatCoords;
        this._flatCoordsOffset = result.flatCoordsOffset;
      } else {
        this._flatCoords = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.concatArray)(this._flatCoords, result.flatCoords);
        this._flatCoordsOffset = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.concatArray)(this._flatCoordsOffset, result.flatCoordsOffset);
      }

      params.data = new Float32Array(result.count);
    }

    this.getRawData().appendData(params.data);
  };

  LinesSeriesModel.prototype._getCoordsFromItemModel = function (idx) {
    var itemModel = this.getData().getItemModel(idx);
    var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow('coords');

    if (true) {
      if (!(coords instanceof Array && coords.length > 0 && coords[0] instanceof Array)) {
        throw new Error('Invalid coords ' + JSON.stringify(coords) + '. Lines must have 2d coords array in data item.');
      }
    }

    return coords;
  };

  LinesSeriesModel.prototype.getLineCoordsCount = function (idx) {
    if (this._flatCoordsOffset) {
      return this._flatCoordsOffset[idx * 2 + 1];
    } else {
      return this._getCoordsFromItemModel(idx).length;
    }
  };

  LinesSeriesModel.prototype.getLineCoords = function (idx, out) {
    if (this._flatCoordsOffset) {
      var offset = this._flatCoordsOffset[idx * 2];
      var len = this._flatCoordsOffset[idx * 2 + 1];

      for (var i = 0; i < len; i++) {
        out[i] = out[i] || [];
        out[i][0] = this._flatCoords[offset + i * 2];
        out[i][1] = this._flatCoords[offset + i * 2 + 1];
      }

      return len;
    } else {
      var coords = this._getCoordsFromItemModel(idx);

      for (var i = 0; i < coords.length; i++) {
        out[i] = out[i] || [];
        out[i][0] = coords[i][0];
        out[i][1] = coords[i][1];
      }

      return coords.length;
    }
  };

  LinesSeriesModel.prototype._processFlatCoordsArray = function (data) {
    var startOffset = 0;

    if (this._flatCoords) {
      startOffset = this._flatCoords.length;
    } // Stored as a typed array. In format
    // Points Count(2) | x | y | x | y | Points Count(3) | x |  y | x | y | x | y |


    if (typeof data[0] === 'number') {
      var len = data.length; // Store offset and len of each segment

      var coordsOffsetAndLenStorage = new Uint32Arr(len);
      var coordsStorage = new Float64Arr(len);
      var coordsCursor = 0;
      var offsetCursor = 0;
      var dataCount = 0;

      for (var i = 0; i < len;) {
        dataCount++;
        var count = data[i++]; // Offset

        coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset; // Len

        coordsOffsetAndLenStorage[offsetCursor++] = count;

        for (var k = 0; k < count; k++) {
          var x = data[i++];
          var y = data[i++];
          coordsStorage[coordsCursor++] = x;
          coordsStorage[coordsCursor++] = y;

          if (i > len) {
            if (true) {
              throw new Error('Invalid data format.');
            }
          }
        }
      }

      return {
        flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
        flatCoords: coordsStorage,
        count: dataCount
      };
    }

    return {
      flatCoordsOffset: null,
      flatCoords: null,
      count: data.length
    };
  };

  LinesSeriesModel.prototype.getInitialData = function (option, ecModel) {
    if (true) {
      var CoordSys = _core_CoordinateSystem__WEBPACK_IMPORTED_MODULE_2__.default.get(option.coordinateSystem);

      if (!CoordSys) {
        throw new Error('Unkown coordinate system ' + option.coordinateSystem);
      }
    }

    var lineData = new _data_List__WEBPACK_IMPORTED_MODULE_3__.default(['value'], this);
    lineData.hasItemOption = false;
    lineData.initData(option.data, [], function (dataItem, dimName, dataIndex, dimIndex) {
      // dataItem is simply coords
      if (dataItem instanceof Array) {
        return NaN;
      } else {
        lineData.hasItemOption = true;
        var value = dataItem.value;

        if (value != null) {
          return value instanceof Array ? value[dimIndex] : value;
        }
      }
    });
    return lineData;
  };

  LinesSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var itemModel = data.getItemModel(dataIndex);
    var name = itemModel.get('name');

    if (name) {
      return name;
    }

    var fromName = itemModel.get('fromName');
    var toName = itemModel.get('toName');
    var nameArr = [];
    fromName != null && nameArr.push(fromName);
    toName != null && nameArr.push(toName);
    return (0,_component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_4__.createTooltipMarkup)('nameValue', {
      name: nameArr.join(' > ')
    });
  };

  LinesSeriesModel.prototype.preventIncremental = function () {
    return !!this.get(['effect', 'show']);
  };

  LinesSeriesModel.prototype.getProgressive = function () {
    var progressive = this.option.progressive;

    if (progressive == null) {
      return this.option.large ? 1e4 : this.get('progressive');
    }

    return progressive;
  };

  LinesSeriesModel.prototype.getProgressiveThreshold = function () {
    var progressiveThreshold = this.option.progressiveThreshold;

    if (progressiveThreshold == null) {
      return this.option.large ? 2e4 : this.get('progressiveThreshold');
    }

    return progressiveThreshold;
  };

  LinesSeriesModel.type = 'series.lines';
  LinesSeriesModel.dependencies = ['grid', 'polar', 'geo', 'calendar'];
  LinesSeriesModel.defaultOption = {
    coordinateSystem: 'geo',
    zlevel: 0,
    z: 2,
    legendHoverLink: true,
    // Cartesian coordinate system
    xAxisIndex: 0,
    yAxisIndex: 0,
    symbol: ['none', 'none'],
    symbolSize: [10, 10],
    // Geo coordinate system
    geoIndex: 0,
    effect: {
      show: false,
      period: 4,
      constantSpeed: 0,
      symbol: 'circle',
      symbolSize: 3,
      loop: true,
      trailLength: 0.2
    },
    large: false,
    // Available when large is true
    largeThreshold: 2000,
    polyline: false,
    clip: true,
    label: {
      show: false,
      position: 'end' // distance: 5,
      // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调

    },
    lineStyle: {
      opacity: 0.5
    }
  };
  return LinesSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_5__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LinesSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/lines/LinesView.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/lines/LinesView.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _helper_LineDraw__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helper/LineDraw */ "./node_modules/echarts/lib/chart/helper/LineDraw.js");
/* harmony import */ var _helper_EffectLine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helper/EffectLine */ "./node_modules/echarts/lib/chart/helper/EffectLine.js");
/* harmony import */ var _helper_Line__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helper/Line */ "./node_modules/echarts/lib/chart/helper/Line.js");
/* harmony import */ var _helper_Polyline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helper/Polyline */ "./node_modules/echarts/lib/chart/helper/Polyline.js");
/* harmony import */ var _helper_EffectPolyline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helper/EffectPolyline */ "./node_modules/echarts/lib/chart/helper/EffectPolyline.js");
/* harmony import */ var _helper_LargeLineDraw__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helper/LargeLineDraw */ "./node_modules/echarts/lib/chart/helper/LargeLineDraw.js");
/* harmony import */ var _linesLayout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linesLayout */ "./node_modules/echarts/lib/chart/lines/linesLayout.js");
/* harmony import */ var _helper_createClipPathFromCoordSys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/createClipPathFromCoordSys */ "./node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/











var LinesView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(LinesView, _super);

  function LinesView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = LinesView.type;
    return _this;
  }

  LinesView.prototype.render = function (seriesModel, ecModel, api) {
    var data = seriesModel.getData();

    var lineDraw = this._updateLineDraw(data, seriesModel);

    var zlevel = seriesModel.get('zlevel');
    var trailLength = seriesModel.get(['effect', 'trailLength']);
    var zr = api.getZr(); // Avoid the drag cause ghost shadow
    // FIXME Better way ?
    // SVG doesn't support

    var isSvg = zr.painter.getType() === 'svg';

    if (!isSvg) {
      zr.painter.getLayer(zlevel).clear(true);
    } // Config layer with motion blur


    if (this._lastZlevel != null && !isSvg) {
      zr.configLayer(this._lastZlevel, {
        motionBlur: false
      });
    }

    if (this._showEffect(seriesModel) && trailLength) {
      if (true) {
        var notInIndividual_1 = false;
        ecModel.eachSeries(function (otherSeriesModel) {
          if (otherSeriesModel !== seriesModel && otherSeriesModel.get('zlevel') === zlevel) {
            notInIndividual_1 = true;
          }
        });
        notInIndividual_1 && console.warn('Lines with trail effect should have an individual zlevel');
      }

      if (!isSvg) {
        zr.configLayer(zlevel, {
          motionBlur: true,
          lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)
        });
      }
    }

    lineDraw.updateData(data);
    var clipPath = seriesModel.get('clip', true) && (0,_helper_createClipPathFromCoordSys__WEBPACK_IMPORTED_MODULE_1__.createClipPath)(seriesModel.coordinateSystem, false, seriesModel);

    if (clipPath) {
      this.group.setClipPath(clipPath);
    } else {
      this.group.removeClipPath();
    }

    this._lastZlevel = zlevel;
    this._finished = true;
  };

  LinesView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {
    var data = seriesModel.getData();

    var lineDraw = this._updateLineDraw(data, seriesModel);

    lineDraw.incrementalPrepareUpdate(data);

    this._clearLayer(api);

    this._finished = false;
  };

  LinesView.prototype.incrementalRender = function (taskParams, seriesModel, ecModel) {
    this._lineDraw.incrementalUpdate(taskParams, seriesModel.getData());

    this._finished = taskParams.end === seriesModel.getData().count();
  };

  LinesView.prototype.updateTransform = function (seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var pipelineContext = seriesModel.pipelineContext;

    if (!this._finished || pipelineContext.large || pipelineContext.progressiveRender) {
      // TODO Don't have to do update in large mode. Only do it when there are millions of data.
      return {
        update: true
      };
    } else {
      // TODO Use same logic with ScatterView.
      // Manually update layout
      var res = _linesLayout__WEBPACK_IMPORTED_MODULE_2__.default.reset(seriesModel, ecModel, api);

      if (res.progress) {
        res.progress({
          start: 0,
          end: data.count(),
          count: data.count()
        }, data);
      } // Not in large mode


      this._lineDraw.updateLayout();

      this._clearLayer(api);
    }
  };

  LinesView.prototype._updateLineDraw = function (data, seriesModel) {
    var lineDraw = this._lineDraw;

    var hasEffect = this._showEffect(seriesModel);

    var isPolyline = !!seriesModel.get('polyline');
    var pipelineContext = seriesModel.pipelineContext;
    var isLargeDraw = pipelineContext.large;

    if (true) {
      if (hasEffect && isLargeDraw) {
        console.warn('Large lines not support effect');
      }
    }

    if (!lineDraw || hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLargeDraw !== this._isLargeDraw) {
      if (lineDraw) {
        lineDraw.remove();
      }

      lineDraw = this._lineDraw = isLargeDraw ? new _helper_LargeLineDraw__WEBPACK_IMPORTED_MODULE_3__.default() : new _helper_LineDraw__WEBPACK_IMPORTED_MODULE_4__.default(isPolyline ? hasEffect ? _helper_EffectPolyline__WEBPACK_IMPORTED_MODULE_5__.default : _helper_Polyline__WEBPACK_IMPORTED_MODULE_6__.default : hasEffect ? _helper_EffectLine__WEBPACK_IMPORTED_MODULE_7__.default : _helper_Line__WEBPACK_IMPORTED_MODULE_8__.default);
      this._hasEffet = hasEffect;
      this._isPolyline = isPolyline;
      this._isLargeDraw = isLargeDraw;
      this.group.removeAll();
    }

    this.group.add(lineDraw.group);
    return lineDraw;
  };

  LinesView.prototype._showEffect = function (seriesModel) {
    return !!seriesModel.get(['effect', 'show']);
  };

  LinesView.prototype._clearLayer = function (api) {
    // Not use motion when dragging or zooming
    var zr = api.getZr();
    var isSvg = zr.painter.getType() === 'svg';

    if (!isSvg && this._lastZlevel != null) {
      zr.painter.getLayer(this._lastZlevel).clear(true);
    }
  };

  LinesView.prototype.remove = function (ecModel, api) {
    this._lineDraw && this._lineDraw.remove();
    this._lineDraw = null; // Clear motion when lineDraw is removed

    this._clearLayer(api);
  };

  LinesView.type = 'lines';
  return LinesView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_9__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LinesView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/lines/install.js":
/*!*********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/lines/install.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _LinesView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LinesView */ "./node_modules/echarts/lib/chart/lines/LinesView.js");
/* harmony import */ var _LinesSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LinesSeries */ "./node_modules/echarts/lib/chart/lines/LinesSeries.js");
/* harmony import */ var _linesLayout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linesLayout */ "./node_modules/echarts/lib/chart/lines/linesLayout.js");
/* harmony import */ var _linesVisual__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./linesVisual */ "./node_modules/echarts/lib/chart/lines/linesVisual.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




function install(registers) {
  registers.registerChartView(_LinesView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerSeriesModel(_LinesSeries__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerLayout(_linesLayout__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerVisual(_linesVisual__WEBPACK_IMPORTED_MODULE_3__.default);
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/lines/linesLayout.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/lines/linesLayout.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helper_createRenderPlanner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helper/createRenderPlanner */ "./node_modules/echarts/lib/chart/helper/createRenderPlanner.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/* global Float32Array */

var linesLayout = {
  seriesType: 'lines',
  plan: (0,_helper_createRenderPlanner__WEBPACK_IMPORTED_MODULE_0__.default)(),
  reset: function (seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    var isPolyline = seriesModel.get('polyline');
    var isLarge = seriesModel.pipelineContext.large;
    return {
      progress: function (params, lineData) {
        var lineCoords = [];

        if (isLarge) {
          var points = void 0;
          var segCount = params.end - params.start;

          if (isPolyline) {
            var totalCoordsCount = 0;

            for (var i = params.start; i < params.end; i++) {
              totalCoordsCount += seriesModel.getLineCoordsCount(i);
            }

            points = new Float32Array(segCount + totalCoordsCount * 2);
          } else {
            points = new Float32Array(segCount * 4);
          }

          var offset = 0;
          var pt = [];

          for (var i = params.start; i < params.end; i++) {
            var len = seriesModel.getLineCoords(i, lineCoords);

            if (isPolyline) {
              points[offset++] = len;
            }

            for (var k = 0; k < len; k++) {
              pt = coordSys.dataToPoint(lineCoords[k], false, pt);
              points[offset++] = pt[0];
              points[offset++] = pt[1];
            }
          }

          lineData.setLayout('linesPoints', points);
        } else {
          for (var i = params.start; i < params.end; i++) {
            var itemModel = lineData.getItemModel(i);
            var len = seriesModel.getLineCoords(i, lineCoords);
            var pts = [];

            if (isPolyline) {
              for (var j = 0; j < len; j++) {
                pts.push(coordSys.dataToPoint(lineCoords[j]));
              }
            } else {
              pts[0] = coordSys.dataToPoint(lineCoords[0]);
              pts[1] = coordSys.dataToPoint(lineCoords[1]);
              var curveness = itemModel.get(['lineStyle', 'curveness']);

              if (+curveness) {
                pts[2] = [(pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness, (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness];
              }
            }

            lineData.setItemLayout(i, pts);
          }
        }
      }
    };
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (linesLayout);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/lines/linesVisual.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/lines/linesVisual.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function normalize(a) {
  if (!(a instanceof Array)) {
    a = [a, a];
  }

  return a;
}

var linesVisual = {
  seriesType: 'lines',
  reset: function (seriesModel) {
    var symbolType = normalize(seriesModel.get('symbol'));
    var symbolSize = normalize(seriesModel.get('symbolSize'));
    var data = seriesModel.getData();
    data.setVisual('fromSymbol', symbolType && symbolType[0]);
    data.setVisual('toSymbol', symbolType && symbolType[1]);
    data.setVisual('fromSymbolSize', symbolSize && symbolSize[0]);
    data.setVisual('toSymbolSize', symbolSize && symbolSize[1]);

    function dataEach(data, idx) {
      var itemModel = data.getItemModel(idx);
      var symbolType = normalize(itemModel.getShallow('symbol', true));
      var symbolSize = normalize(itemModel.getShallow('symbolSize', true));
      symbolType[0] && data.setItemVisual(idx, 'fromSymbol', symbolType[0]);
      symbolType[1] && data.setItemVisual(idx, 'toSymbol', symbolType[1]);
      symbolSize[0] && data.setItemVisual(idx, 'fromSymbolSize', symbolSize[0]);
      symbolSize[1] && data.setItemVisual(idx, 'toSymbolSize', symbolSize[1]);
    }

    return {
      dataEach: data.hasItemOption ? dataEach : null
    };
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (linesVisual);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/map/MapSeries.js":
/*!*********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/map/MapSeries.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _helper_createListSimply__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/createListSimply */ "./node_modules/echarts/lib/chart/helper/createListSimply.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var _coord_geo_geoSourceManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../coord/geo/geoSourceManager */ "./node_modules/echarts/lib/coord/geo/geoSourceManager.js");
/* harmony import */ var _data_helper_sourceHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/helper/sourceHelper */ "./node_modules/echarts/lib/data/helper/sourceHelper.js");
/* harmony import */ var _component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../component/tooltip/tooltipMarkup */ "./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








var MapSeries =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(MapSeries, _super);

  function MapSeries() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = MapSeries.type; // Only first map series of same mapType will drawMap.

    _this.needsDrawMap = false; // Group of all map series with same mapType

    _this.seriesGroup = [];

    _this.getTooltipPosition = function (dataIndex) {
      if (dataIndex != null) {
        var name_1 = this.getData().getName(dataIndex);
        var geo = this.coordinateSystem;
        var region = geo.getRegion(name_1);
        return region && geo.dataToPoint(region.center);
      }
    };

    return _this;
  }

  MapSeries.prototype.getInitialData = function (option) {
    var data = (0,_helper_createListSimply__WEBPACK_IMPORTED_MODULE_1__.default)(this, {
      coordDimensions: ['value'],
      encodeDefaulter: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.curry(_data_helper_sourceHelper__WEBPACK_IMPORTED_MODULE_3__.makeSeriesEncodeForNameBased, this)
    });
    var dataNameMap = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.createHashMap();
    var toAppendNames = [];

    for (var i = 0, len = data.count(); i < len; i++) {
      var name_2 = data.getName(i);
      dataNameMap.set(name_2, true);
    }

    var geoSource = _coord_geo_geoSourceManager__WEBPACK_IMPORTED_MODULE_4__.default.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each(geoSource.regions, function (region) {
      var name = region.name;

      if (!dataNameMap.get(name)) {
        toAppendNames.push(name);
      }
    }); // Complete data with missing regions. The consequent processes (like visual
    // map and render) can not be performed without a "full data". For example,
    // find `dataIndex` by name.

    data.appendValues([], toAppendNames);
    return data;
  };
  /**
   * If no host geo model, return null, which means using a
   * inner exclusive geo model.
   */


  MapSeries.prototype.getHostGeoModel = function () {
    var geoIndex = this.option.geoIndex;
    return geoIndex != null ? this.ecModel.getComponent('geo', geoIndex) : null;
  };

  MapSeries.prototype.getMapType = function () {
    return (this.getHostGeoModel() || this).option.map;
  }; // _fillOption(option, mapName) {
  // Shallow clone
  // option = zrUtil.extend({}, option);
  // option.data = geoCreator.getFilledRegions(option.data, mapName, option.nameMap);
  // return option;
  // }


  MapSeries.prototype.getRawValue = function (dataIndex) {
    // Use value stored in data instead because it is calculated from multiple series
    // FIXME Provide all value of multiple series ?
    var data = this.getData();
    return data.get(data.mapDimension('value'), dataIndex);
  };
  /**
   * Get model of region
   */


  MapSeries.prototype.getRegionModel = function (regionName) {
    var data = this.getData();
    return data.getItemModel(data.indexOfName(regionName));
  };
  /**
   * Map tooltip formatter
   */


  MapSeries.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
    // FIXME orignalData and data is a bit confusing
    var data = this.getData();
    var value = this.getRawValue(dataIndex);
    var name = data.getName(dataIndex);
    var seriesGroup = this.seriesGroup;
    var seriesNames = [];

    for (var i = 0; i < seriesGroup.length; i++) {
      var otherIndex = seriesGroup[i].originalData.indexOfName(name);
      var valueDim = data.mapDimension('value');

      if (!isNaN(seriesGroup[i].originalData.get(valueDim, otherIndex))) {
        seriesNames.push(seriesGroup[i].name);
      }
    }

    return (0,_component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_5__.createTooltipMarkup)('section', {
      header: seriesNames.join(', '),
      noHeader: !seriesNames.length,
      blocks: [(0,_component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_5__.createTooltipMarkup)('nameValue', {
        name: name,
        value: value
      })]
    });
  };

  MapSeries.prototype.setZoom = function (zoom) {
    this.option.zoom = zoom;
  };

  MapSeries.prototype.setCenter = function (center) {
    this.option.center = center;
  };

  MapSeries.type = 'series.map';
  MapSeries.dependencies = ['geo'];
  MapSeries.layoutMode = 'box';
  MapSeries.defaultOption = {
    // 一级层叠
    zlevel: 0,
    // 二级层叠
    z: 2,
    coordinateSystem: 'geo',
    // map should be explicitly specified since ec3.
    map: '',
    // If `geoIndex` is not specified, a exclusive geo will be
    // created. Otherwise use the specified geo component, and
    // `map` and `mapType` are ignored.
    // geoIndex: 0,
    // 'center' | 'left' | 'right' | 'x%' | {number}
    left: 'center',
    // 'center' | 'top' | 'bottom' | 'x%' | {number}
    top: 'center',
    // right
    // bottom
    // width:
    // height
    // Aspect is width / height. Inited to be geoJson bbox aspect
    // This parameter is used for scale this aspect
    aspectScale: 0.75,
    ///// Layout with center and size
    // If you wan't to put map in a fixed size box with right aspect ratio
    // This two properties may more conveninet
    // layoutCenter: [50%, 50%]
    // layoutSize: 100
    showLegendSymbol: true,
    // Define left-top, right-bottom coords to control view
    // For example, [ [180, 90], [-180, -90] ],
    // higher priority than center and zoom
    boundingCoords: null,
    // Default on center of map
    center: null,
    zoom: 1,
    scaleLimit: null,
    selectedMode: true,
    label: {
      show: false,
      color: '#000'
    },
    // scaleLimit: null,
    itemStyle: {
      borderWidth: 0.5,
      borderColor: '#444',
      areaColor: '#eee'
    },
    emphasis: {
      label: {
        show: true,
        color: 'rgb(100,0,0)'
      },
      itemStyle: {
        areaColor: 'rgba(255,215,0,0.8)'
      }
    },
    select: {
      label: {
        show: true,
        color: 'rgb(100,0,0)'
      },
      itemStyle: {
        color: 'rgba(255,215,0,0.8)'
      }
    },
    nameProperty: 'name'
  };
  return MapSeries;
}(_model_Series__WEBPACK_IMPORTED_MODULE_6__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapSeries);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/map/MapView.js":
/*!*******************************************************!*\
  !*** ./node_modules/echarts/lib/chart/map/MapView.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Circle.js");
/* harmony import */ var _component_helper_MapDraw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../component/helper/MapDraw */ "./node_modules/echarts/lib/component/helper/MapDraw.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






;

var MapView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(MapView, _super);

  function MapView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = MapView.type;
    return _this;
  }

  MapView.prototype.render = function (mapModel, ecModel, api, payload) {
    // Not render if it is an toggleSelect action from self
    if (payload && payload.type === 'mapToggleSelect' && payload.from === this.uid) {
      return;
    }

    var group = this.group;
    group.removeAll();

    if (mapModel.getHostGeoModel()) {
      return;
    } // Not update map if it is an roam action from self


    if (!(payload && payload.type === 'geoRoam' && payload.componentType === 'series' && payload.seriesId === mapModel.id)) {
      if (mapModel.needsDrawMap) {
        var mapDraw = this._mapDraw || new _component_helper_MapDraw__WEBPACK_IMPORTED_MODULE_1__.default(api);
        group.add(mapDraw.group);
        mapDraw.draw(mapModel, ecModel, api, this, payload);
        this._mapDraw = mapDraw;
      } else {
        // Remove drawed map
        this._mapDraw && this._mapDraw.remove();
        this._mapDraw = null;
      }
    } else {
      var mapDraw = this._mapDraw;
      mapDraw && group.add(mapDraw.group);
    }

    mapModel.get('showLegendSymbol') && ecModel.getComponent('legend') && this._renderSymbols(mapModel, ecModel, api);
  };

  MapView.prototype.remove = function () {
    this._mapDraw && this._mapDraw.remove();
    this._mapDraw = null;
    this.group.removeAll();
  };

  MapView.prototype.dispose = function () {
    this._mapDraw && this._mapDraw.remove();
    this._mapDraw = null;
  };

  MapView.prototype._renderSymbols = function (mapModel, ecModel, api) {
    var originalData = mapModel.originalData;
    var group = this.group;
    originalData.each(originalData.mapDimension('value'), function (value, originalDataIndex) {
      if (isNaN(value)) {
        return;
      }

      var layout = originalData.getItemLayout(originalDataIndex);

      if (!layout || !layout.point) {
        // Not exists in map
        return;
      }

      var point = layout.point;
      var offset = layout.offset;
      var circle = new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default({
        style: {
          // Because the special of map draw.
          // Which needs statistic of multiple series and draw on one map.
          // And each series also need a symbol with legend color
          //
          // Layout and visual are put one the different data
          // TODO
          fill: mapModel.getData().getVisual('style').fill
        },
        shape: {
          cx: point[0] + offset * 9,
          cy: point[1],
          r: 3
        },
        silent: true,
        // Do not overlap the first series, on which labels are displayed.
        z2: 8 + (!offset ? _util_states__WEBPACK_IMPORTED_MODULE_3__.Z2_EMPHASIS_LIFT + 1 : 0)
      }); // Only the series that has the first value on the same region is in charge of rendering the label.
      // But consider the case:
      // series: [
      //     {id: 'X', type: 'map', map: 'm', {data: [{name: 'A', value: 11}, {name: 'B', {value: 22}]},
      //     {id: 'Y', type: 'map', map: 'm', {data: [{name: 'A', value: 21}, {name: 'C', {value: 33}]}
      // ]
      // The offset `0` of item `A` is at series `X`, but of item `C` is at series `Y`.
      // For backward compatibility, we follow the rule that render label `A` by the
      // settings on series `X` but render label `C` by the settings on series `Y`.

      if (!offset) {
        var fullData = mapModel.mainSeries.getData();
        var name_1 = originalData.getName(originalDataIndex);
        var fullIndex_1 = fullData.indexOfName(name_1);
        var itemModel = originalData.getItemModel(originalDataIndex);
        var labelModel = itemModel.getModel('label');
        var regionGroup = fullData.getItemGraphicEl(fullIndex_1); // `getFormattedLabel` needs to use `getData` inside. Here
        // `mapModel.getData()` is shallow cloned from `mainSeries.getData()`.
        // FIXME
        // If this is not the `mainSeries`, the item model (like label formatter)
        // set on original data item will never get. But it has been working
        // like that from the begining, and this scenario is rarely encountered.
        // So it won't be fixed until have to.

        (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_4__.setLabelStyle)(circle, (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_4__.getLabelStatesModels)(itemModel), {
          labelFetcher: {
            getFormattedLabel: function (idx, state) {
              return mapModel.getFormattedLabel(fullIndex_1, state);
            }
          }
        });
        circle.disableLabelAnimation = true;

        if (!labelModel.get('position')) {
          circle.setTextConfig({
            position: 'bottom'
          });
        }

        regionGroup.onHoverStateChange = function (toState) {
          circle.useState(toState);
        };
      }

      group.add(circle);
    });
  };

  MapView.type = 'map';
  return MapView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_5__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/map/install.js":
/*!*******************************************************!*\
  !*** ./node_modules/echarts/lib/chart/map/install.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extension */ "./node_modules/echarts/lib/extension.js");
/* harmony import */ var _MapView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MapView */ "./node_modules/echarts/lib/chart/map/MapView.js");
/* harmony import */ var _MapSeries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MapSeries */ "./node_modules/echarts/lib/chart/map/MapSeries.js");
/* harmony import */ var _mapDataStatistic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mapDataStatistic */ "./node_modules/echarts/lib/chart/map/mapDataStatistic.js");
/* harmony import */ var _mapSymbolLayout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mapSymbolLayout */ "./node_modules/echarts/lib/chart/map/mapSymbolLayout.js");
/* harmony import */ var _legacy_dataSelectAction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../legacy/dataSelectAction */ "./node_modules/echarts/lib/legacy/dataSelectAction.js");
/* harmony import */ var _component_geo_install__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../component/geo/install */ "./node_modules/echarts/lib/component/geo/install.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







function install(registers) {
  (0,_extension__WEBPACK_IMPORTED_MODULE_0__.use)(_component_geo_install__WEBPACK_IMPORTED_MODULE_1__.install);
  registers.registerChartView(_MapView__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerSeriesModel(_MapSeries__WEBPACK_IMPORTED_MODULE_3__.default);
  registers.registerLayout(_mapSymbolLayout__WEBPACK_IMPORTED_MODULE_4__.default);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, _mapDataStatistic__WEBPACK_IMPORTED_MODULE_5__.default);
  (0,_legacy_dataSelectAction__WEBPACK_IMPORTED_MODULE_6__.createLegacyDataSelectAction)('map', registers.registerAction);
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/map/mapDataStatistic.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/map/mapDataStatistic.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mapDataStatistic)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
 // FIXME 公用？

function dataStatistics(datas, statisticType) {
  var dataNameMap = {};
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(datas, function (data) {
    data.each(data.mapDimension('value'), function (value, idx) {
      // Add prefix to avoid conflict with Object.prototype.
      var mapKey = 'ec-' + data.getName(idx);
      dataNameMap[mapKey] = dataNameMap[mapKey] || [];

      if (!isNaN(value)) {
        dataNameMap[mapKey].push(value);
      }
    });
  });
  return datas[0].map(datas[0].mapDimension('value'), function (value, idx) {
    var mapKey = 'ec-' + datas[0].getName(idx);
    var sum = 0;
    var min = Infinity;
    var max = -Infinity;
    var len = dataNameMap[mapKey].length;

    for (var i = 0; i < len; i++) {
      min = Math.min(min, dataNameMap[mapKey][i]);
      max = Math.max(max, dataNameMap[mapKey][i]);
      sum += dataNameMap[mapKey][i];
    }

    var result;

    if (statisticType === 'min') {
      result = min;
    } else if (statisticType === 'max') {
      result = max;
    } else if (statisticType === 'average') {
      result = sum / len;
    } else {
      result = sum;
    }

    return len === 0 ? NaN : result;
  });
}

function mapDataStatistic(ecModel) {
  var seriesGroups = {};
  ecModel.eachSeriesByType('map', function (seriesModel) {
    var hostGeoModel = seriesModel.getHostGeoModel();
    var key = hostGeoModel ? 'o' + hostGeoModel.id : 'i' + seriesModel.getMapType();
    (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel);
  });
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(seriesGroups, function (seriesList, key) {
    var data = dataStatistics(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map(seriesList, function (seriesModel) {
      return seriesModel.getData();
    }), seriesList[0].get('mapValueCalculation'));

    for (var i = 0; i < seriesList.length; i++) {
      seriesList[i].originalData = seriesList[i].getData();
    } // FIXME Put where?


    for (var i = 0; i < seriesList.length; i++) {
      seriesList[i].seriesGroup = seriesList;
      seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel();
      seriesList[i].setData(data.cloneShallow());
      seriesList[i].mainSeries = seriesList[0];
    }
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/map/mapSymbolLayout.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/map/mapSymbolLayout.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mapSymbolLayout)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

function mapSymbolLayout(ecModel) {
  var processedMapType = {};
  ecModel.eachSeriesByType('map', function (mapSeries) {
    var mapType = mapSeries.getMapType();

    if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {
      return;
    }

    var mapSymbolOffsets = {};
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(mapSeries.seriesGroup, function (subMapSeries) {
      var geo = subMapSeries.coordinateSystem;
      var data = subMapSeries.originalData;

      if (subMapSeries.get('showLegendSymbol') && ecModel.getComponent('legend')) {
        data.each(data.mapDimension('value'), function (value, idx) {
          var name = data.getName(idx);
          var region = geo.getRegion(name); // If input series.data is [11, 22, '-'/null/undefined, 44],
          // it will be filled with NaN: [11, 22, NaN, 44] and NaN will
          // not be drawn. So here must validate if value is NaN.

          if (!region || isNaN(value)) {
            return;
          }

          var offset = mapSymbolOffsets[name] || 0;
          var point = geo.dataToPoint(region.center);
          mapSymbolOffsets[name] = offset + 1;
          data.setItemLayout(idx, {
            point: point,
            offset: offset
          });
        });
      }
    }); // Show label of those region not has legendSymbol(which is offset 0)

    var data = mapSeries.getData();
    data.each(function (idx) {
      var name = data.getName(idx);
      var layout = data.getItemLayout(idx) || {};
      layout.showLabel = !mapSymbolOffsets[name];
      data.setItemLayout(idx, layout);
    });
    processedMapType[mapType] = true;
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/parallel/ParallelSeries.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/parallel/ParallelSeries.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var _helper_createListFromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/createListFromArray */ "./node_modules/echarts/lib/chart/helper/createListFromArray.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var ParallelSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ParallelSeriesModel, _super);

  function ParallelSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ParallelSeriesModel.type;
    _this.visualStyleAccessPath = 'lineStyle';
    _this.visualDrawType = 'stroke';
    return _this;
  }

  ParallelSeriesModel.prototype.getInitialData = function (option, ecModel) {
    return (0,_helper_createListFromArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.getSource(), this, {
      useEncodeDefaulter: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(makeDefaultEncode, null, this)
    });
  };
  /**
   * User can get data raw indices on 'axisAreaSelected' event received.
   *
   * @return Raw indices
   */


  ParallelSeriesModel.prototype.getRawIndicesByActiveState = function (activeState) {
    var coordSys = this.coordinateSystem;
    var data = this.getData();
    var indices = [];
    coordSys.eachActiveState(data, function (theActiveState, dataIndex) {
      if (activeState === theActiveState) {
        indices.push(data.getRawIndex(dataIndex));
      }
    });
    return indices;
  };

  ParallelSeriesModel.type = 'series.parallel';
  ParallelSeriesModel.dependencies = ['parallel'];
  ParallelSeriesModel.defaultOption = {
    zlevel: 0,
    z: 2,
    coordinateSystem: 'parallel',
    parallelIndex: 0,
    label: {
      show: false
    },
    inactiveOpacity: 0.05,
    activeOpacity: 1,
    lineStyle: {
      width: 1,
      opacity: 0.45,
      type: 'solid'
    },
    emphasis: {
      label: {
        show: false
      }
    },
    progressive: 500,
    smooth: false,
    animationEasing: 'linear'
  };
  return ParallelSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_3__.default);

function makeDefaultEncode(seriesModel) {
  // The mapping of parallelAxis dimension to data dimension can
  // be specified in parallelAxis.option.dim. For example, if
  // parallelAxis.option.dim is 'dim3', it mapping to the third
  // dimension of data. But `data.encode` has higher priority.
  // Moreover, parallelModel.dimension should not be regarded as data
  // dimensions. Consider dimensions = ['dim4', 'dim2', 'dim6'];
  var parallelModel = seriesModel.ecModel.getComponent('parallel', seriesModel.get('parallelIndex'));

  if (!parallelModel) {
    return;
  }

  var encodeDefine = {};
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(parallelModel.dimensions, function (axisDim) {
    var dataDimIndex = convertDimNameToNumber(axisDim);
    encodeDefine[axisDim] = dataDimIndex;
  });
  return encodeDefine;
}

function convertDimNameToNumber(dimName) {
  return +dimName.replace('dim', '');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ParallelSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/parallel/ParallelView.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/parallel/ParallelView.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polyline.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var DEFAULT_SMOOTH = 0.3;

var ParallelView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ParallelView, _super);

  function ParallelView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ParallelView.type;
    _this._dataGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_1__.default();
    _this._initialized = false;
    return _this;
  }

  ParallelView.prototype.init = function () {
    this.group.add(this._dataGroup);
  };
  /**
   * @override
   */


  ParallelView.prototype.render = function (seriesModel, ecModel, api, payload) {
    var dataGroup = this._dataGroup;
    var data = seriesModel.getData();
    var oldData = this._data;
    var coordSys = seriesModel.coordinateSystem;
    var dimensions = coordSys.dimensions;
    var seriesScope = makeSeriesScope(seriesModel);
    data.diff(oldData).add(add).update(update).remove(remove).execute();

    function add(newDataIndex) {
      var line = addEl(data, dataGroup, newDataIndex, dimensions, coordSys);
      updateElCommon(line, data, newDataIndex, seriesScope);
    }

    function update(newDataIndex, oldDataIndex) {
      var line = oldData.getItemGraphicEl(oldDataIndex);
      var points = createLinePoints(data, newDataIndex, dimensions, coordSys);
      data.setItemGraphicEl(newDataIndex, line);
      _util_graphic__WEBPACK_IMPORTED_MODULE_2__.updateProps(line, {
        shape: {
          points: points
        }
      }, seriesModel, newDataIndex);
      updateElCommon(line, data, newDataIndex, seriesScope);
    }

    function remove(oldDataIndex) {
      var line = oldData.getItemGraphicEl(oldDataIndex);
      dataGroup.remove(line);
    } // First create


    if (!this._initialized) {
      this._initialized = true;
      var clipPath = createGridClipShape(coordSys, seriesModel, function () {
        // Callback will be invoked immediately if there is no animation
        setTimeout(function () {
          dataGroup.removeClipPath();
        });
      });
      dataGroup.setClipPath(clipPath);
    }

    this._data = data;
  };

  ParallelView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {
    this._initialized = true;
    this._data = null;

    this._dataGroup.removeAll();
  };

  ParallelView.prototype.incrementalRender = function (taskParams, seriesModel, ecModel) {
    var data = seriesModel.getData();
    var coordSys = seriesModel.coordinateSystem;
    var dimensions = coordSys.dimensions;
    var seriesScope = makeSeriesScope(seriesModel);

    for (var dataIndex = taskParams.start; dataIndex < taskParams.end; dataIndex++) {
      var line = addEl(data, this._dataGroup, dataIndex, dimensions, coordSys);
      line.incremental = true;
      updateElCommon(line, data, dataIndex, seriesScope);
    }
  };

  ParallelView.prototype.remove = function () {
    this._dataGroup && this._dataGroup.removeAll();
    this._data = null;
  };

  ParallelView.type = 'parallel';
  return ParallelView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_3__.default);

function createGridClipShape(coordSys, seriesModel, cb) {
  var parallelModel = coordSys.model;
  var rect = coordSys.getRect();
  var rectEl = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default({
    shape: {
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    }
  });
  var dim = parallelModel.get('layout') === 'horizontal' ? 'width' : 'height';
  rectEl.setShape(dim, 0);
  _util_graphic__WEBPACK_IMPORTED_MODULE_2__.initProps(rectEl, {
    shape: {
      width: rect.width,
      height: rect.height
    }
  }, seriesModel, cb);
  return rectEl;
}

function createLinePoints(data, dataIndex, dimensions, coordSys) {
  var points = [];

  for (var i = 0; i < dimensions.length; i++) {
    var dimName = dimensions[i];
    var value = data.get(data.mapDimension(dimName), dataIndex);

    if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {
      points.push(coordSys.dataToPoint(value, dimName));
    }
  }

  return points;
}

function addEl(data, dataGroup, dataIndex, dimensions, coordSys) {
  var points = createLinePoints(data, dataIndex, dimensions, coordSys);
  var line = new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default({
    shape: {
      points: points
    },
    // silent: true,
    z2: 10
  });
  dataGroup.add(line);
  data.setItemGraphicEl(dataIndex, line);
  return line;
}

function makeSeriesScope(seriesModel) {
  var smooth = seriesModel.get('smooth', true);
  smooth === true && (smooth = DEFAULT_SMOOTH);
  smooth = (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.numericToNumber)(smooth);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_7__.eqNaN)(smooth) && (smooth = 0);
  return {
    smooth: smooth
  };
}

function updateElCommon(el, data, dataIndex, seriesScope) {
  el.useStyle(data.getItemVisual(dataIndex, 'style'));
  el.style.fill = null;
  el.setShape('smooth', seriesScope.smooth);
  var itemModel = data.getItemModel(dataIndex);
  var emphasisModel = itemModel.getModel('emphasis');
  (0,_util_states__WEBPACK_IMPORTED_MODULE_8__.setStatesStylesFromModel)(el, itemModel, 'lineStyle');
  (0,_util_states__WEBPACK_IMPORTED_MODULE_8__.enableHoverEmphasis)(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'));
} // function simpleDiff(oldData, newData, dimensions) {
//     let oldLen;
//     if (!oldData
//         || !oldData.__plProgressive
//         || (oldLen = oldData.count()) !== newData.count()
//     ) {
//         return true;
//     }
//     let dimLen = dimensions.length;
//     for (let i = 0; i < oldLen; i++) {
//         for (let j = 0; j < dimLen; j++) {
//             if (oldData.get(dimensions[j], i) !== newData.get(dimensions[j], i)) {
//                 return true;
//             }
//         }
//     }
//     return false;
// }
// FIXME put in common util?


function isEmptyValue(val, axisType) {
  return axisType === 'category' ? val == null : val == null || isNaN(val); // axisType === 'value'
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ParallelView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/parallel/install.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/parallel/install.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extension */ "./node_modules/echarts/lib/extension.js");
/* harmony import */ var _ParallelView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ParallelView */ "./node_modules/echarts/lib/chart/parallel/ParallelView.js");
/* harmony import */ var _ParallelSeries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ParallelSeries */ "./node_modules/echarts/lib/chart/parallel/ParallelSeries.js");
/* harmony import */ var _parallelVisual__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parallelVisual */ "./node_modules/echarts/lib/chart/parallel/parallelVisual.js");
/* harmony import */ var _component_parallel_install__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../component/parallel/install */ "./node_modules/echarts/lib/component/parallel/install.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





function install(registers) {
  (0,_extension__WEBPACK_IMPORTED_MODULE_0__.use)(_component_parallel_install__WEBPACK_IMPORTED_MODULE_1__.install);
  registers.registerChartView(_ParallelView__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerSeriesModel(_ParallelSeries__WEBPACK_IMPORTED_MODULE_3__.default);
  registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, _parallelVisual__WEBPACK_IMPORTED_MODULE_4__.default);
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/parallel/parallelVisual.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/parallel/parallelVisual.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var opacityAccessPath = ['lineStyle', 'opacity'];
var parallelVisual = {
  seriesType: 'parallel',
  reset: function (seriesModel, ecModel) {
    var coordSys = seriesModel.coordinateSystem;
    var opacityMap = {
      normal: seriesModel.get(['lineStyle', 'opacity']),
      active: seriesModel.get('activeOpacity'),
      inactive: seriesModel.get('inactiveOpacity')
    };
    return {
      progress: function (params, data) {
        coordSys.eachActiveState(data, function (activeState, dataIndex) {
          var opacity = opacityMap[activeState];

          if (activeState === 'normal' && data.hasItemOption) {
            var itemOpacity = data.getItemModel(dataIndex).get(opacityAccessPath, true);
            itemOpacity != null && (opacity = itemOpacity);
          }

          var existsStyle = data.ensureUniqueItemVisual(dataIndex, 'style');
          existsStyle.opacity = opacity;
        }, params.start, params.end);
      }
    };
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parallelVisual);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/pie/PieSeries.js":
/*!*********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/pie/PieSeries.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _helper_createListSimply__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helper/createListSimply */ "./node_modules/echarts/lib/chart/helper/createListSimply.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _data_helper_sourceHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../data/helper/sourceHelper */ "./node_modules/echarts/lib/data/helper/sourceHelper.js");
/* harmony import */ var _visual_LegendVisualProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../visual/LegendVisualProvider */ "./node_modules/echarts/lib/visual/LegendVisualProvider.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/









var PieSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(PieSeriesModel, _super);

  function PieSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.useColorPaletteOnData = true;
    return _this;
  }
  /**
   * @overwrite
   */


  PieSeriesModel.prototype.init = function (option) {
    _super.prototype.init.apply(this, arguments); // Enable legend selection for each data item
    // Use a function instead of direct access because data reference may changed


    this.legendVisualProvider = new _visual_LegendVisualProvider__WEBPACK_IMPORTED_MODULE_1__.default(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind(this.getData, this), zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind(this.getRawData, this));

    this._defaultLabelLine(option);
  };
  /**
   * @overwrite
   */


  PieSeriesModel.prototype.mergeOption = function () {
    _super.prototype.mergeOption.apply(this, arguments);
  };
  /**
   * @overwrite
   */


  PieSeriesModel.prototype.getInitialData = function () {
    return (0,_helper_createListSimply__WEBPACK_IMPORTED_MODULE_3__.default)(this, {
      coordDimensions: ['value'],
      encodeDefaulter: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.curry(_data_helper_sourceHelper__WEBPACK_IMPORTED_MODULE_4__.makeSeriesEncodeForNameBased, this)
    });
  };
  /**
   * @overwrite
   */


  PieSeriesModel.prototype.getDataParams = function (dataIndex) {
    var data = this.getData();

    var params = _super.prototype.getDataParams.call(this, dataIndex); // FIXME toFixed?


    var valueList = [];
    data.each(data.mapDimension('value'), function (value) {
      valueList.push(value);
    });
    params.percent = (0,_util_number__WEBPACK_IMPORTED_MODULE_5__.getPercentWithPrecision)(valueList, dataIndex, data.hostModel.get('percentPrecision'));
    params.$vars.push('percent');
    return params;
  };

  PieSeriesModel.prototype._defaultLabelLine = function (option) {
    // Extend labelLine emphasis
    _util_model__WEBPACK_IMPORTED_MODULE_6__.defaultEmphasis(option, 'labelLine', ['show']);
    var labelLineNormalOpt = option.labelLine;
    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`

    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
  };

  PieSeriesModel.type = 'series.pie';
  PieSeriesModel.defaultOption = {
    zlevel: 0,
    z: 2,
    legendHoverLink: true,
    // 默认全局居中
    center: ['50%', '50%'],
    radius: [0, '75%'],
    // 默认顺时针
    clockwise: true,
    startAngle: 90,
    // 最小角度改为0
    minAngle: 0,
    // If the angle of a sector less than `minShowLabelAngle`,
    // the label will not be displayed.
    minShowLabelAngle: 0,
    // 选中时扇区偏移量
    selectedOffset: 10,
    // 选择模式，默认关闭，可选single，multiple
    // selectedMode: false,
    // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
    // roseType: null,
    percentPrecision: 2,
    // If still show when all data zero.
    stillShowZeroSum: true,
    // cursor: null,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    width: null,
    height: null,
    label: {
      // color: 'inherit',
      // If rotate around circle
      rotate: 0,
      show: true,
      overflow: 'truncate',
      // 'outer', 'inside', 'center'
      position: 'outer',
      // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
      alignTo: 'none',
      // Closest distance between label and chart edge.
      // Works only position is 'outer' and alignTo is 'edge'.
      edgeDistance: '25%',
      // Works only position is 'outer' and alignTo is not 'edge'.
      bleedMargin: 10,
      // Distance between text and label line.
      distanceToLabelLine: 5 // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      // 默认使用全局文本样式，详见TEXTSTYLE
      // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数

    },
    // Enabled when label.normal.position is 'outer'
    labelLine: {
      show: true,
      // 引导线两段中的第一段长度
      length: 15,
      // 引导线两段中的第二段长度
      length2: 15,
      smooth: false,
      minTurnAngle: 90,
      maxSurfaceAngle: 90,
      lineStyle: {
        // color: 各异,
        width: 1,
        type: 'solid'
      }
    },
    itemStyle: {
      borderWidth: 1
    },
    labelLayout: {
      // Hide the overlapped label.
      hideOverlap: true
    },
    emphasis: {
      scale: true,
      scaleSize: 5
    },
    // If use strategy to avoid label overlapping
    avoidLabelOverlap: true,
    // Animation type. Valid values: expansion, scale
    animationType: 'expansion',
    animationDuration: 1000,
    // Animation type when update. Valid values: transition, expansion
    animationTypeUpdate: 'transition',
    animationEasingUpdate: 'cubicInOut',
    animationDurationUpdate: 500,
    animationEasing: 'cubicInOut'
  };
  return PieSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_7__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PieSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/pie/PieView.js":
/*!*******************************************************!*\
  !*** ./node_modules/echarts/lib/chart/pie/PieView.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polyline.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Sector.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _labelLayout__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./labelLayout */ "./node_modules/echarts/lib/chart/pie/labelLayout.js");
/* harmony import */ var _label_labelGuideHelper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../label/labelGuideHelper */ "./node_modules/echarts/lib/label/labelGuideHelper.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _helper_pieHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helper/pieHelper */ "./node_modules/echarts/lib/chart/helper/pieHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/









/**
 * Piece of pie including Sector, Label, LabelLine
 */

var PiePiece =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(PiePiece, _super);

  function PiePiece(data, idx, startAngle) {
    var _this = _super.call(this) || this;

    _this.z2 = 2;
    var polyline = new _util_graphic__WEBPACK_IMPORTED_MODULE_1__.default();
    var text = new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default();

    _this.setTextGuideLine(polyline);

    _this.setTextContent(text);

    _this.updateData(data, idx, startAngle, true);

    return _this;
  }

  PiePiece.prototype.updateData = function (data, idx, startAngle, firstCreate) {
    var sector = this;
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var emphasisModel = itemModel.getModel('emphasis');
    var layout = data.getItemLayout(idx);
    var sectorShape = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.extend)((0,_helper_pieHelper__WEBPACK_IMPORTED_MODULE_4__.getSectorCornerRadius)(itemModel.getModel('itemStyle'), layout) || {}, layout);

    if (firstCreate) {
      sector.setShape(sectorShape);
      var animationType = seriesModel.getShallow('animationType');

      if (animationType === 'scale') {
        sector.shape.r = layout.r0;
        _util_graphic__WEBPACK_IMPORTED_MODULE_5__.initProps(sector, {
          shape: {
            r: layout.r
          }
        }, seriesModel, idx);
      } // Expansion
      else {
          if (startAngle != null) {
            sector.setShape({
              startAngle: startAngle,
              endAngle: startAngle
            });
            _util_graphic__WEBPACK_IMPORTED_MODULE_5__.initProps(sector, {
              shape: {
                startAngle: layout.startAngle,
                endAngle: layout.endAngle
              }
            }, seriesModel, idx);
          } else {
            sector.shape.endAngle = layout.startAngle;
            _util_graphic__WEBPACK_IMPORTED_MODULE_5__.updateProps(sector, {
              shape: {
                endAngle: layout.endAngle
              }
            }, seriesModel, idx);
          }
        }
    } else {
      // Transition animation from the old shape
      _util_graphic__WEBPACK_IMPORTED_MODULE_5__.updateProps(sector, {
        shape: sectorShape
      }, seriesModel, idx);
    }

    sector.useStyle(data.getItemVisual(idx, 'style'));
    (0,_util_states__WEBPACK_IMPORTED_MODULE_6__.setStatesStylesFromModel)(sector, itemModel);
    var midAngle = (layout.startAngle + layout.endAngle) / 2;
    var offset = seriesModel.get('selectedOffset');
    var dx = Math.cos(midAngle) * offset;
    var dy = Math.sin(midAngle) * offset;
    var cursorStyle = itemModel.getShallow('cursor');
    cursorStyle && sector.attr('cursor', cursorStyle);

    this._updateLabel(seriesModel, data, idx);

    sector.ensureState('emphasis').shape = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({
      r: layout.r + (emphasisModel.get('scale') ? emphasisModel.get('scaleSize') || 0 : 0)
    }, (0,_helper_pieHelper__WEBPACK_IMPORTED_MODULE_4__.getSectorCornerRadius)(emphasisModel.getModel('itemStyle'), layout));
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.extend)(sector.ensureState('select'), {
      x: dx,
      y: dy,
      shape: (0,_helper_pieHelper__WEBPACK_IMPORTED_MODULE_4__.getSectorCornerRadius)(itemModel.getModel(['select', 'itemStyle']), layout)
    });
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.extend)(sector.ensureState('blur'), {
      shape: (0,_helper_pieHelper__WEBPACK_IMPORTED_MODULE_4__.getSectorCornerRadius)(itemModel.getModel(['blur', 'itemStyle']), layout)
    });
    var labelLine = sector.getTextGuideLine();
    var labelText = sector.getTextContent();
    labelLine && (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.extend)(labelLine.ensureState('select'), {
      x: dx,
      y: dy
    }); // TODO: needs dx, dy in zrender?

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.extend)(labelText.ensureState('select'), {
      x: dx,
      y: dy
    });
    (0,_util_states__WEBPACK_IMPORTED_MODULE_6__.enableHoverEmphasis)(this, emphasisModel.get('focus'), emphasisModel.get('blurScope'));
  };

  PiePiece.prototype._updateLabel = function (seriesModel, data, idx) {
    var _a;

    var sector = this;
    var itemModel = data.getItemModel(idx);
    var labelLineModel = itemModel.getModel('labelLine');
    var style = data.getItemVisual(idx, 'style');
    var visualColor = style && style.fill;
    var visualOpacity = style && style.opacity;
    (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_7__.setLabelStyle)(sector, (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_7__.getLabelStatesModels)(itemModel), {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      inheritColor: visualColor,
      defaultOpacity: visualOpacity,
      defaultText: seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx)
    });
    var labelText = sector.getTextContent(); // Set textConfig on sector.

    sector.setTextConfig({
      // reset position, rotation
      position: null,
      rotation: null
    }); // Make sure update style on labelText after setLabelStyle.
    // Because setLabelStyle will replace a new style on it.

    labelText.attr({
      z2: 10
    });
    var labelPosition = seriesModel.get(['label', 'position']);

    if (labelPosition !== 'outside' && labelPosition !== 'outer') {
      (_a = sector.getTextGuideLine()) === null || _a === void 0 ? void 0 : _a.hide();
      return;
    } // Default use item visual color


    (0,_label_labelGuideHelper__WEBPACK_IMPORTED_MODULE_8__.setLabelLineStyle)(this, (0,_label_labelGuideHelper__WEBPACK_IMPORTED_MODULE_8__.getLabelLineStatesModels)(itemModel), {
      stroke: visualColor,
      opacity: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.retrieve3)(labelLineModel.get(['lineStyle', 'opacity']), visualOpacity, 1)
    });
  };

  return PiePiece;
}(_util_graphic__WEBPACK_IMPORTED_MODULE_9__.default); // Pie view


var PieView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(PieView, _super);

  function PieView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.ignoreLabelLineUpdate = true;
    return _this;
  }

  PieView.prototype.init = function () {
    var sectorGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_10__.default();
    this._sectorGroup = sectorGroup;
  };

  PieView.prototype.render = function (seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var oldData = this._data;
    var group = this.group;
    var startAngle; // First render

    if (!oldData && data.count() > 0) {
      var shape = data.getItemLayout(0);

      for (var s = 1; isNaN(shape && shape.startAngle) && s < data.count(); ++s) {
        shape = data.getItemLayout(s);
      }

      if (shape) {
        startAngle = shape.startAngle;
      }
    }

    data.diff(oldData).add(function (idx) {
      var piePiece = new PiePiece(data, idx, startAngle);
      data.setItemGraphicEl(idx, piePiece);
      group.add(piePiece);
    }).update(function (newIdx, oldIdx) {
      var piePiece = oldData.getItemGraphicEl(oldIdx);
      piePiece.updateData(data, newIdx, startAngle);
      piePiece.off('click');
      group.add(piePiece);
      data.setItemGraphicEl(newIdx, piePiece);
    }).remove(function (idx) {
      var piePiece = oldData.getItemGraphicEl(idx);
      _util_graphic__WEBPACK_IMPORTED_MODULE_5__.removeElementWithFadeOut(piePiece, seriesModel, idx);
    }).execute();
    (0,_labelLayout__WEBPACK_IMPORTED_MODULE_11__.default)(seriesModel); // Always use initial animation.

    if (seriesModel.get('animationTypeUpdate') !== 'expansion') {
      this._data = data;
    }
  };

  PieView.prototype.dispose = function () {};

  PieView.prototype.containPoint = function (point, seriesModel) {
    var data = seriesModel.getData();
    var itemLayout = data.getItemLayout(0);

    if (itemLayout) {
      var dx = point[0] - itemLayout.cx;
      var dy = point[1] - itemLayout.cy;
      var radius = Math.sqrt(dx * dx + dy * dy);
      return radius <= itemLayout.r && radius >= itemLayout.r0;
    }
  };

  PieView.type = 'pie';
  return PieView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_12__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PieView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/pie/install.js":
/*!*******************************************************!*\
  !*** ./node_modules/echarts/lib/chart/pie/install.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _legacy_dataSelectAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../legacy/dataSelectAction */ "./node_modules/echarts/lib/legacy/dataSelectAction.js");
/* harmony import */ var _pie_pieLayout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../pie/pieLayout */ "./node_modules/echarts/lib/chart/pie/pieLayout.js");
/* harmony import */ var _processor_dataFilter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../processor/dataFilter */ "./node_modules/echarts/lib/processor/dataFilter.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _PieView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PieView */ "./node_modules/echarts/lib/chart/pie/PieView.js");
/* harmony import */ var _PieSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PieSeries */ "./node_modules/echarts/lib/chart/pie/PieSeries.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






function install(registers) {
  registers.registerChartView(_PieView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerSeriesModel(_PieSeries__WEBPACK_IMPORTED_MODULE_1__.default);
  (0,_legacy_dataSelectAction__WEBPACK_IMPORTED_MODULE_2__.createLegacyDataSelectAction)('pie', registers.registerAction);
  registers.registerLayout((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.curry)(_pie_pieLayout__WEBPACK_IMPORTED_MODULE_4__.default, 'pie'));
  registers.registerProcessor((0,_processor_dataFilter__WEBPACK_IMPORTED_MODULE_5__.default)('pie'));
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/pie/labelLayout.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/pie/labelLayout.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pieLabelLayout)
/* harmony export */ });
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/core/Point.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _label_labelGuideHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../label/labelGuideHelper */ "./node_modules/echarts/lib/label/labelGuideHelper.js");
/* harmony import */ var _label_labelLayoutHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../label/labelLayoutHelper */ "./node_modules/echarts/lib/label/labelLayoutHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// FIXME emphasis label position is not same with normal label position





var RADIAN = Math.PI / 180;

function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
  if (list.length < 2) {
    return;
  }

  ;

  function recalculateXOnSemiToAlignOnEllipseCurve(semi) {
    var rB = semi.rB;
    var rB2 = rB * rB;

    for (var i = 0; i < semi.list.length; i++) {
      var item = semi.list[i];
      var dy = Math.abs(item.label.y - cy); // horizontal r is always same with original r because x is not changed.

      var rA = r + item.len;
      var rA2 = rA * rA; // Use ellipse implicit function to calculate x

      var dx = Math.sqrt((1 - Math.abs(dy * dy / rB2)) * rA2);
      item.label.x = cx + (dx + item.len2) * dir;
    }
  } // Adjust X based on the shifted y. Make tight labels aligned on an ellipse curve.


  function recalculateX(items) {
    // Extremes of
    var topSemi = {
      list: [],
      maxY: 0
    };
    var bottomSemi = {
      list: [],
      maxY: 0
    };

    for (var i = 0; i < items.length; i++) {
      if (items[i].labelAlignTo !== 'none') {
        continue;
      }

      var item = items[i];
      var semi = item.label.y > cy ? bottomSemi : topSemi;
      var dy = Math.abs(item.label.y - cy);

      if (dy > semi.maxY) {
        var dx = item.label.x - cx - item.len2 * dir; // horizontal r is always same with original r because x is not changed.

        var rA = r + item.len; // Canculate rB based on the topest / bottemest label.

        var rB = Math.abs(dx) < rA ? Math.sqrt(dy * dy / (1 - dx * dx / rA / rA)) : rA;
        semi.rB = rB;
        semi.maxY = dy;
      }

      semi.list.push(item);
    }

    recalculateXOnSemiToAlignOnEllipseCurve(topSemi);
    recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);
  }

  var len = list.length;

  for (var i = 0; i < len; i++) {
    if (list[i].position === 'outer' && list[i].labelAlignTo === 'labelLine') {
      var dx = list[i].label.x - farthestX;
      list[i].linePoints[1][0] += dx;
      list[i].label.x = farthestX;
    }
  }

  if ((0,_label_labelLayoutHelper__WEBPACK_IMPORTED_MODULE_0__.shiftLayoutOnY)(list, viewTop, viewTop + viewHeight)) {
    recalculateX(list);
  }
}

function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
  var leftList = [];
  var rightList = [];
  var leftmostX = Number.MAX_VALUE;
  var rightmostX = -Number.MAX_VALUE;

  for (var i = 0; i < labelLayoutList.length; i++) {
    var label = labelLayoutList[i].label;

    if (isPositionCenter(labelLayoutList[i])) {
      continue;
    }

    if (label.x < cx) {
      leftmostX = Math.min(leftmostX, label.x);
      leftList.push(labelLayoutList[i]);
    } else {
      rightmostX = Math.max(rightmostX, label.x);
      rightList.push(labelLayoutList[i]);
    }
  }

  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);

  for (var i = 0; i < labelLayoutList.length; i++) {
    var layout = labelLayoutList[i];
    var label = layout.label;

    if (isPositionCenter(layout)) {
      continue;
    }

    var linePoints = layout.linePoints;

    if (linePoints) {
      var isAlignToEdge = layout.labelAlignTo === 'edge';
      var realTextWidth = layout.rect.width;
      var targetTextWidth = void 0;

      if (isAlignToEdge) {
        if (label.x < cx) {
          targetTextWidth = linePoints[2][0] - layout.labelDistance - viewLeft - layout.edgeDistance;
        } else {
          targetTextWidth = viewLeft + viewWidth - layout.edgeDistance - linePoints[2][0] - layout.labelDistance;
        }
      } else {
        if (label.x < cx) {
          targetTextWidth = label.x - viewLeft - layout.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - label.x - layout.bleedMargin;
        }
      }

      if (targetTextWidth < layout.rect.width) {
        // TODOTODO
        // layout.text = textContain.truncateText(layout.text, targetTextWidth, layout.font);
        layout.label.style.width = targetTextWidth;

        if (layout.labelAlignTo === 'edge') {
          realTextWidth = targetTextWidth; // realTextWidth = textContain.getWidth(layout.text, layout.font);
        }
      }

      var dist = linePoints[1][0] - linePoints[2][0];

      if (isAlignToEdge) {
        if (label.x < cx) {
          linePoints[2][0] = viewLeft + layout.edgeDistance + realTextWidth + layout.labelDistance;
        } else {
          linePoints[2][0] = viewLeft + viewWidth - layout.edgeDistance - realTextWidth - layout.labelDistance;
        }
      } else {
        if (label.x < cx) {
          linePoints[2][0] = label.x + layout.labelDistance;
        } else {
          linePoints[2][0] = label.x - layout.labelDistance;
        }

        linePoints[1][0] = linePoints[2][0] + dist;
      }

      linePoints[1][1] = linePoints[2][1] = label.y;
    }
  }
}

function isPositionCenter(sectorShape) {
  // Not change x for center label
  return sectorShape.position === 'center';
}

function pieLabelLayout(seriesModel) {
  var data = seriesModel.getData();
  var labelLayoutList = [];
  var cx;
  var cy;
  var hasLabelRotate = false;
  var minShowLabelRadian = (seriesModel.get('minShowLabelAngle') || 0) * RADIAN;
  var viewRect = data.getLayout('viewRect');
  var r = data.getLayout('r');
  var viewWidth = viewRect.width;
  var viewLeft = viewRect.x;
  var viewTop = viewRect.y;
  var viewHeight = viewRect.height;

  function setNotShow(el) {
    el.ignore = true;
  }

  function isLabelShown(label) {
    if (!label.ignore) {
      return true;
    }

    for (var key in label.states) {
      if (label.states[key].ignore === false) {
        return true;
      }
    }

    return false;
  }

  data.each(function (idx) {
    var sector = data.getItemGraphicEl(idx);
    var sectorShape = sector.shape;
    var label = sector.getTextContent();
    var labelLine = sector.getTextGuideLine();
    var itemModel = data.getItemModel(idx);
    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis

    var labelPosition = labelModel.get('position') || itemModel.get(['emphasis', 'label', 'position']);
    var labelDistance = labelModel.get('distanceToLabelLine');
    var labelAlignTo = labelModel.get('alignTo');
    var edgeDistance = (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(labelModel.get('edgeDistance'), viewWidth);
    var bleedMargin = labelModel.get('bleedMargin');
    var labelLineModel = itemModel.getModel('labelLine');
    var labelLineLen = labelLineModel.get('length');
    labelLineLen = (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(labelLineLen, viewWidth);
    var labelLineLen2 = labelLineModel.get('length2');
    labelLineLen2 = (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(labelLineLen2, viewWidth);

    if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(label.states, setNotShow);
      label.ignore = true;
      return;
    }

    if (!isLabelShown(label)) {
      return;
    }

    var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;
    var nx = Math.cos(midAngle);
    var ny = Math.sin(midAngle);
    var textX;
    var textY;
    var linePoints;
    var textAlign;
    cx = sectorShape.cx;
    cy = sectorShape.cy;
    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';

    if (labelPosition === 'center') {
      textX = sectorShape.cx;
      textY = sectorShape.cy;
      textAlign = 'center';
    } else {
      var x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;
      var y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;
      textX = x1 + nx * 3;
      textY = y1 + ny * 3;

      if (!isLabelInside) {
        // For roseType
        var x2 = x1 + nx * (labelLineLen + r - sectorShape.r);
        var y2 = y1 + ny * (labelLineLen + r - sectorShape.r);
        var x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;
        var y3 = y2;

        if (labelAlignTo === 'edge') {
          // Adjust textX because text align of edge is opposite
          textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;
        } else {
          textX = x3 + (nx < 0 ? -labelDistance : labelDistance);
        }

        textY = y3;
        linePoints = [[x1, y1], [x2, y2], [x3, y3]];
      }

      textAlign = isLabelInside ? 'center' : labelAlignTo === 'edge' ? nx > 0 ? 'right' : 'left' : nx > 0 ? 'left' : 'right';
    }

    var labelRotate;
    var rotate = labelModel.get('rotate');

    if (typeof rotate === 'number') {
      labelRotate = rotate * (Math.PI / 180);
    } else {
      labelRotate = rotate ? nx < 0 ? -midAngle + Math.PI : -midAngle : 0;
    }

    hasLabelRotate = !!labelRotate;
    label.x = textX;
    label.y = textY;
    label.rotation = labelRotate;
    label.setStyle({
      verticalAlign: 'middle'
    }); // Not sectorShape the inside label

    if (!isLabelInside) {
      var textRect = label.getBoundingRect().clone();
      textRect.applyTransform(label.getComputedTransform()); // Text has a default 1px stroke. Exclude this.

      var margin = (label.style.margin || 0) + 2.1;
      textRect.y -= margin / 2;
      textRect.height += margin;
      labelLayoutList.push({
        label: label,
        labelLine: labelLine,
        position: labelPosition,
        len: labelLineLen,
        len2: labelLineLen2,
        minTurnAngle: labelLineModel.get('minTurnAngle'),
        maxSurfaceAngle: labelLineModel.get('maxSurfaceAngle'),
        surfaceNormal: new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default(nx, ny),
        linePoints: linePoints,
        textAlign: textAlign,
        labelDistance: labelDistance,
        labelAlignTo: labelAlignTo,
        edgeDistance: edgeDistance,
        bleedMargin: bleedMargin,
        rect: textRect
      });
    } else {
      label.setStyle({
        align: textAlign
      });
      var selectState = label.states.select;

      if (selectState) {
        selectState.x += label.x;
        selectState.y += label.y;
      }
    }

    sector.setTextConfig({
      inside: isLabelInside
    });
  });

  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {
    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);
  }

  for (var i = 0; i < labelLayoutList.length; i++) {
    var layout = labelLayoutList[i];
    var label = layout.label;
    var labelLine = layout.labelLine;
    var notShowLabel = isNaN(label.x) || isNaN(label.y);

    if (label) {
      label.setStyle({
        align: layout.textAlign
      });

      if (notShowLabel) {
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(label.states, setNotShow);
        label.ignore = true;
      }

      var selectState = label.states.select;

      if (selectState) {
        selectState.x += label.x;
        selectState.y += label.y;
      }
    }

    if (labelLine) {
      var linePoints = layout.linePoints;

      if (notShowLabel || !linePoints) {
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(labelLine.states, setNotShow);
        labelLine.ignore = true;
      } else {
        (0,_label_labelGuideHelper__WEBPACK_IMPORTED_MODULE_4__.limitTurnAngle)(linePoints, layout.minTurnAngle);
        (0,_label_labelGuideHelper__WEBPACK_IMPORTED_MODULE_4__.limitSurfaceAngle)(linePoints, layout.surfaceNormal, layout.maxSurfaceAngle);
        labelLine.setShape({
          points: linePoints
        }); // Set the anchor to the midpoint of sector

        label.__hostTarget.textGuideLineConfig = {
          anchor: new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default(linePoints[0][0], linePoints[0][1])
        };
      }
    }
  }
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/pie/pieLayout.js":
/*!*********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/pie/pieLayout.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pieLayout)
/* harmony export */ });
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var PI2 = Math.PI * 2;
var RADIAN = Math.PI / 180;

function getViewRect(seriesModel, api) {
  return _util_layout__WEBPACK_IMPORTED_MODULE_0__.getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}

function pieLayout(seriesType, ecModel, api) {
  ecModel.eachSeriesByType(seriesType, function (seriesModel) {
    var data = seriesModel.getData();
    var valueDim = data.mapDimension('value');
    var viewRect = getViewRect(seriesModel, api);
    var center = seriesModel.get('center');
    var radius = seriesModel.get('radius');

    if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(radius)) {
      radius = [0, radius];
    }

    if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(center)) {
      center = [center, center];
    }

    var width = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.parsePercent)(viewRect.width, api.getWidth());
    var height = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.parsePercent)(viewRect.height, api.getHeight());
    var size = Math.min(width, height);
    var cx = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.parsePercent)(center[0], width) + viewRect.x;
    var cy = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.parsePercent)(center[1], height) + viewRect.y;
    var r0 = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.parsePercent)(radius[0], size / 2);
    var r = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.parsePercent)(radius[1], size / 2);
    var startAngle = -seriesModel.get('startAngle') * RADIAN;
    var minAngle = seriesModel.get('minAngle') * RADIAN;
    var validDataCount = 0;
    data.each(valueDim, function (value) {
      !isNaN(value) && validDataCount++;
    });
    var sum = data.getSum(valueDim); // Sum may be 0

    var unitRadian = Math.PI / (sum || validDataCount) * 2;
    var clockwise = seriesModel.get('clockwise');
    var roseType = seriesModel.get('roseType');
    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]

    var extent = data.getDataExtent(valueDim);
    extent[0] = 0; // In the case some sector angle is smaller than minAngle

    var restAngle = PI2;
    var valueSumLargerThanMinAngle = 0;
    var currentAngle = startAngle;
    var dir = clockwise ? 1 : -1;
    data.setLayout({
      viewRect: viewRect,
      r: r
    });
    data.each(valueDim, function (value, idx) {
      var angle;

      if (isNaN(value)) {
        data.setItemLayout(idx, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise: clockwise,
          cx: cx,
          cy: cy,
          r0: r0,
          r: roseType ? NaN : r
        });
        return;
      } // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？


      if (roseType !== 'area') {
        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
      } else {
        angle = PI2 / validDataCount;
      }

      if (angle < minAngle) {
        angle = minAngle;
        restAngle -= minAngle;
      } else {
        valueSumLargerThanMinAngle += value;
      }

      var endAngle = currentAngle + dir * angle;
      data.setItemLayout(idx, {
        angle: angle,
        startAngle: currentAngle,
        endAngle: endAngle,
        clockwise: clockwise,
        cx: cx,
        cy: cy,
        r0: r0,
        r: roseType ? (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.linearMap)(value, extent, [r0, r]) : r
      });
      currentAngle = endAngle;
    }); // Some sector is constrained by minAngle
    // Rest sectors needs recalculate angle

    if (restAngle < PI2 && validDataCount) {
      // Average the angle if rest angle is not enough after all angles is
      // Constrained by minAngle
      if (restAngle <= 1e-3) {
        var angle_1 = PI2 / validDataCount;
        data.each(valueDim, function (value, idx) {
          if (!isNaN(value)) {
            var layout_1 = data.getItemLayout(idx);
            layout_1.angle = angle_1;
            layout_1.startAngle = startAngle + dir * idx * angle_1;
            layout_1.endAngle = startAngle + dir * (idx + 1) * angle_1;
          }
        });
      } else {
        unitRadian = restAngle / valueSumLargerThanMinAngle;
        currentAngle = startAngle;
        data.each(valueDim, function (value, idx) {
          if (!isNaN(value)) {
            var layout_2 = data.getItemLayout(idx);
            var angle = layout_2.angle === minAngle ? minAngle : value * unitRadian;
            layout_2.startAngle = currentAngle;
            layout_2.endAngle = currentAngle + dir * angle;
            currentAngle += dir * angle;
          }
        });
      }
    }
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/radar/RadarSeries.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/radar/RadarSeries.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var _helper_createListSimply__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helper/createListSimply */ "./node_modules/echarts/lib/chart/helper/createListSimply.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _visual_LegendVisualProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../visual/LegendVisualProvider */ "./node_modules/echarts/lib/visual/LegendVisualProvider.js");
/* harmony import */ var _component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../component/tooltip/tooltipMarkup */ "./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







var RadarSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(RadarSeriesModel, _super);

  function RadarSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = RadarSeriesModel.type;
    _this.useColorPaletteOnData = true;
    _this.hasSymbolVisual = true;
    return _this;
  } // Overwrite


  RadarSeriesModel.prototype.init = function (option) {
    _super.prototype.init.apply(this, arguments); // Enable legend selection for each data item
    // Use a function instead of direct access because data reference may changed


    this.legendVisualProvider = new _visual_LegendVisualProvider__WEBPACK_IMPORTED_MODULE_1__.default(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind(this.getData, this), zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind(this.getRawData, this));
  };

  RadarSeriesModel.prototype.getInitialData = function (option, ecModel) {
    return (0,_helper_createListSimply__WEBPACK_IMPORTED_MODULE_3__.default)(this, {
      generateCoord: 'indicator_',
      generateCoordCount: Infinity
    });
  };

  RadarSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var coordSys = this.coordinateSystem;
    var indicatorAxes = coordSys.getIndicatorAxes();
    var name = this.getData().getName(dataIndex);
    var nameToDisplay = name === '' ? this.name : name;
    var markerColor = (0,_component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_4__.retrieveVisualColorForTooltipMarker)(this, dataIndex);
    return (0,_component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_4__.createTooltipMarkup)('section', {
      header: nameToDisplay,
      sortBlocks: true,
      blocks: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.map(indicatorAxes, function (axis) {
        var val = data.get(data.mapDimension(axis.dim), dataIndex);
        return (0,_component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_4__.createTooltipMarkup)('nameValue', {
          markerType: 'subItem',
          markerColor: markerColor,
          name: axis.name,
          value: val,
          sortParam: val
        });
      })
    });
  };

  RadarSeriesModel.prototype.getTooltipPosition = function (dataIndex) {
    if (dataIndex != null) {
      var data_1 = this.getData();
      var coordSys = this.coordinateSystem;
      var values = data_1.getValues(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.map(coordSys.dimensions, function (dim) {
        return data_1.mapDimension(dim);
      }), dataIndex);

      for (var i = 0, len = values.length; i < len; i++) {
        if (!isNaN(values[i])) {
          var indicatorAxes = coordSys.getIndicatorAxes();
          return coordSys.coordToPoint(indicatorAxes[i].dataToCoord(values[i]), i);
        }
      }
    }
  };

  RadarSeriesModel.type = 'series.radar';
  RadarSeriesModel.dependencies = ['radar'];
  RadarSeriesModel.defaultOption = {
    zlevel: 0,
    z: 2,
    coordinateSystem: 'radar',
    legendHoverLink: true,
    radarIndex: 0,
    lineStyle: {
      width: 2,
      type: 'solid'
    },
    label: {
      position: 'top'
    },
    // areaStyle: {
    // },
    // itemStyle: {}
    symbol: 'emptyCircle',
    symbolSize: 4 // symbolRotate: null

  };
  return RadarSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_5__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadarSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/radar/RadarView.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/radar/RadarView.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polygon.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polyline.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/symbol */ "./node_modules/echarts/lib/util/symbol.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var zrender_lib_graphic_Image__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! zrender/lib/graphic/Image */ "./node_modules/zrender/lib/graphic/Image.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/









function normalizeSymbolSize(symbolSize) {
  if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(symbolSize)) {
    symbolSize = [+symbolSize, +symbolSize];
  }

  return symbolSize;
}

var RadarView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(RadarView, _super);

  function RadarView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = RadarView.type;
    return _this;
  }

  RadarView.prototype.render = function (seriesModel, ecModel, api) {
    var polar = seriesModel.coordinateSystem;
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;

    function createSymbol(data, idx) {
      var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';

      if (symbolType === 'none') {
        return;
      }

      var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));
      var symbolPath = _util_symbol__WEBPACK_IMPORTED_MODULE_2__.createSymbol(symbolType, -1, -1, 2, 2);
      var symbolRotate = data.getItemVisual(idx, 'symbolRotate') || 0;
      symbolPath.attr({
        style: {
          strokeNoScale: true
        },
        z2: 100,
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2,
        rotation: symbolRotate * Math.PI / 180 || 0
      });
      return symbolPath;
    }

    function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {
      // Simply rerender all
      symbolGroup.removeAll();

      for (var i = 0; i < newPoints.length - 1; i++) {
        var symbolPath = createSymbol(data, idx);

        if (symbolPath) {
          symbolPath.__dimIdx = i;

          if (oldPoints[i]) {
            symbolPath.setPosition(oldPoints[i]);
            _util_graphic__WEBPACK_IMPORTED_MODULE_3__[isInit ? 'initProps' : 'updateProps'](symbolPath, {
              x: newPoints[i][0],
              y: newPoints[i][1]
            }, seriesModel, idx);
          } else {
            symbolPath.setPosition(newPoints[i]);
          }

          symbolGroup.add(symbolPath);
        }
      }
    }

    function getInitialPoints(points) {
      return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map(points, function (pt) {
        return [polar.cx, polar.cy];
      });
    }

    data.diff(oldData).add(function (idx) {
      var points = data.getItemLayout(idx);

      if (!points) {
        return;
      }

      var polygon = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default();
      var polyline = new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default();
      var target = {
        shape: {
          points: points
        }
      };
      polygon.shape.points = getInitialPoints(points);
      polyline.shape.points = getInitialPoints(points);
      _util_graphic__WEBPACK_IMPORTED_MODULE_3__.initProps(polygon, target, seriesModel, idx);
      _util_graphic__WEBPACK_IMPORTED_MODULE_3__.initProps(polyline, target, seriesModel, idx);
      var itemGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default();
      var symbolGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default();
      itemGroup.add(polyline);
      itemGroup.add(polygon);
      itemGroup.add(symbolGroup);
      updateSymbols(polyline.shape.points, points, symbolGroup, data, idx, true);
      data.setItemGraphicEl(idx, itemGroup);
    }).update(function (newIdx, oldIdx) {
      var itemGroup = oldData.getItemGraphicEl(oldIdx);
      var polyline = itemGroup.childAt(0);
      var polygon = itemGroup.childAt(1);
      var symbolGroup = itemGroup.childAt(2);
      var target = {
        shape: {
          points: data.getItemLayout(newIdx)
        }
      };

      if (!target.shape.points) {
        return;
      }

      updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
      _util_graphic__WEBPACK_IMPORTED_MODULE_3__.updateProps(polyline, target, seriesModel);
      _util_graphic__WEBPACK_IMPORTED_MODULE_3__.updateProps(polygon, target, seriesModel);
      data.setItemGraphicEl(newIdx, itemGroup);
    }).remove(function (idx) {
      group.remove(oldData.getItemGraphicEl(idx));
    }).execute();
    data.eachItemGraphicEl(function (itemGroup, idx) {
      var itemModel = data.getItemModel(idx);
      var polyline = itemGroup.childAt(0);
      var polygon = itemGroup.childAt(1);
      var symbolGroup = itemGroup.childAt(2); // Radar uses the visual encoded from itemStyle.

      var itemStyle = data.getItemVisual(idx, 'style');
      var color = itemStyle.fill;
      group.add(itemGroup);
      polyline.useStyle(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.defaults(itemModel.getModel('lineStyle').getLineStyle(), {
        fill: 'none',
        stroke: color
      }));
      (0,_util_states__WEBPACK_IMPORTED_MODULE_7__.setStatesStylesFromModel)(polyline, itemModel, 'lineStyle');
      (0,_util_states__WEBPACK_IMPORTED_MODULE_7__.setStatesStylesFromModel)(polygon, itemModel, 'areaStyle');
      var areaStyleModel = itemModel.getModel('areaStyle');
      var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
      polygon.ignore = polygonIgnore;
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(['emphasis', 'select', 'blur'], function (stateName) {
        var stateModel = itemModel.getModel([stateName, 'areaStyle']);
        var stateIgnore = stateModel.isEmpty() && stateModel.parentModel.isEmpty(); // Won't be ignore if normal state is not ignore.

        polygon.ensureState(stateName).ignore = stateIgnore && polygonIgnore;
      });
      polygon.useStyle(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.defaults(areaStyleModel.getAreaStyle(), {
        fill: color,
        opacity: 0.7,
        decal: itemStyle.decal
      }));
      var emphasisModel = itemModel.getModel('emphasis');
      var itemHoverStyle = emphasisModel.getModel('itemStyle').getItemStyle();
      symbolGroup.eachChild(function (symbolPath) {
        if (symbolPath instanceof zrender_lib_graphic_Image__WEBPACK_IMPORTED_MODULE_8__.default) {
          var pathStyle = symbolPath.style;
          symbolPath.useStyle(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.extend({
            // TODO other properties like x, y ?
            image: pathStyle.image,
            x: pathStyle.x,
            y: pathStyle.y,
            width: pathStyle.width,
            height: pathStyle.height
          }, itemStyle));
        } else {
          symbolPath.useStyle(itemStyle);
          symbolPath.setColor(color);
        }

        var pathEmphasisState = symbolPath.ensureState('emphasis');
        pathEmphasisState.style = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.clone(itemHoverStyle);
        var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);
        (defaultText == null || isNaN(defaultText)) && (defaultText = '');
        (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_9__.setLabelStyle)(symbolPath, (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_9__.getLabelStatesModels)(itemModel), {
          labelFetcher: data.hostModel,
          labelDataIndex: idx,
          labelDimIndex: symbolPath.__dimIdx,
          defaultText: defaultText,
          inheritColor: color,
          defaultOpacity: itemStyle.opacity
        });
      });
      (0,_util_states__WEBPACK_IMPORTED_MODULE_7__.enableHoverEmphasis)(itemGroup, emphasisModel.get('focus'), emphasisModel.get('blurScope'));
    });
    this._data = data;
  };

  RadarView.prototype.remove = function () {
    this.group.removeAll();
    this._data = null;
  };

  RadarView.type = 'radar';
  return RadarView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_10__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadarView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/radar/backwardCompat.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/radar/backwardCompat.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ radarBackwardCompat)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// @ts-nocheck
// Backward compat for radar chart in 2

function radarBackwardCompat(option) {
  var polarOptArr = option.polar;

  if (polarOptArr) {
    if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(polarOptArr)) {
      polarOptArr = [polarOptArr];
    }

    var polarNotRadar_1 = [];
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(polarOptArr, function (polarOpt, idx) {
      if (polarOpt.indicator) {
        if (polarOpt.type && !polarOpt.shape) {
          polarOpt.shape = polarOpt.type;
        }

        option.radar = option.radar || [];

        if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(option.radar)) {
          option.radar = [option.radar];
        }

        option.radar.push(polarOpt);
      } else {
        polarNotRadar_1.push(polarOpt);
      }
    });
    option.polar = polarNotRadar_1;
  }

  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(option.series, function (seriesOpt) {
    if (seriesOpt && seriesOpt.type === 'radar' && seriesOpt.polarIndex) {
      seriesOpt.radarIndex = seriesOpt.polarIndex;
    }
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/radar/install.js":
/*!*********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/radar/install.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extension */ "./node_modules/echarts/lib/extension.js");
/* harmony import */ var _radar_radarLayout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../radar/radarLayout */ "./node_modules/echarts/lib/chart/radar/radarLayout.js");
/* harmony import */ var _processor_dataFilter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../processor/dataFilter */ "./node_modules/echarts/lib/processor/dataFilter.js");
/* harmony import */ var _radar_backwardCompat__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../radar/backwardCompat */ "./node_modules/echarts/lib/chart/radar/backwardCompat.js");
/* harmony import */ var _RadarView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RadarView */ "./node_modules/echarts/lib/chart/radar/RadarView.js");
/* harmony import */ var _RadarSeries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RadarSeries */ "./node_modules/echarts/lib/chart/radar/RadarSeries.js");
/* harmony import */ var _component_radar_install__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../component/radar/install */ "./node_modules/echarts/lib/component/radar/install.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







function install(registers) {
  (0,_extension__WEBPACK_IMPORTED_MODULE_0__.use)(_component_radar_install__WEBPACK_IMPORTED_MODULE_1__.install);
  registers.registerChartView(_RadarView__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerSeriesModel(_RadarSeries__WEBPACK_IMPORTED_MODULE_3__.default);
  registers.registerLayout(_radar_radarLayout__WEBPACK_IMPORTED_MODULE_4__.default);
  registers.registerProcessor((0,_processor_dataFilter__WEBPACK_IMPORTED_MODULE_5__.default)('radar'));
  registers.registerPreprocessor(_radar_backwardCompat__WEBPACK_IMPORTED_MODULE_6__.default);
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/radar/radarLayout.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/radar/radarLayout.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ radarLayout)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

function radarLayout(ecModel) {
  ecModel.eachSeriesByType('radar', function (seriesModel) {
    var data = seriesModel.getData();
    var points = [];
    var coordSys = seriesModel.coordinateSystem;

    if (!coordSys) {
      return;
    }

    var axes = coordSys.getIndicatorAxes();
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(axes, function (axis, axisIndex) {
      data.each(data.mapDimension(axes[axisIndex].dim), function (val, dataIndex) {
        points[dataIndex] = points[dataIndex] || [];
        var point = coordSys.dataToPoint(val, axisIndex);
        points[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys);
      });
    }); // Close polygon

    data.each(function (idx) {
      // TODO
      // Is it appropriate to connect to the next data when some data is missing?
      // Or, should trade it like `connectNull` in line chart?
      var firstPoint = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.find(points[idx], function (point) {
        return isValidPoint(point);
      }) || getValueMissingPoint(coordSys); // Copy the first actual point to the end of the array

      points[idx].push(firstPoint.slice());
      data.setItemLayout(idx, points[idx]);
    });
  });
}

function isValidPoint(point) {
  return !isNaN(point[0]) && !isNaN(point[1]);
}

function getValueMissingPoint(coordSys) {
  // It is error-prone to input [NaN, NaN] into polygon, polygon.
  // (probably cause problem when refreshing or animating)
  return [coordSys.cx, coordSys.cy];
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/sankey/SankeySeries.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/sankey/SankeySeries.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var _helper_createGraphFromNodeEdge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helper/createGraphFromNodeEdge */ "./node_modules/echarts/lib/chart/helper/createGraphFromNodeEdge.js");
/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/Model */ "./node_modules/echarts/lib/model/Model.js");
/* harmony import */ var _component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../component/tooltip/tooltipMarkup */ "./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var SankeySeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SankeySeriesModel, _super);

  function SankeySeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = SankeySeriesModel.type;
    return _this;
  }
  /**
   * Init a graph data structure from data in option series
   *
   * @param  {Object} option  the object used to config echarts view
   * @return {module:echarts/data/List} storage initial data
   */


  SankeySeriesModel.prototype.getInitialData = function (option, ecModel) {
    var links = option.edges || option.links;
    var nodes = option.data || option.nodes;
    var levels = option.levels;
    this.levelModels = [];
    var levelModels = this.levelModels;

    for (var i = 0; i < levels.length; i++) {
      if (levels[i].depth != null && levels[i].depth >= 0) {
        levelModels[levels[i].depth] = new _model_Model__WEBPACK_IMPORTED_MODULE_1__.default(levels[i], this, ecModel);
      } else {
        if (true) {
          throw new Error('levels[i].depth is mandatory and should be natural number');
        }
      }
    }

    if (nodes && links) {
      var graph = (0,_helper_createGraphFromNodeEdge__WEBPACK_IMPORTED_MODULE_2__.default)(nodes, links, this, true, beforeLink);
      return graph.data;
    }

    function beforeLink(nodeData, edgeData) {
      nodeData.wrapMethod('getItemModel', function (model, idx) {
        var seriesModel = model.parentModel;
        var layout = seriesModel.getData().getItemLayout(idx);

        if (layout) {
          var nodeDepth = layout.depth;
          var levelModel = seriesModel.levelModels[nodeDepth];

          if (levelModel) {
            model.parentModel = levelModel;
          }
        }

        return model;
      });
      edgeData.wrapMethod('getItemModel', function (model, idx) {
        var seriesModel = model.parentModel;
        var edge = seriesModel.getGraph().getEdgeByIndex(idx);
        var layout = edge.node1.getLayout();

        if (layout) {
          var depth = layout.depth;
          var levelModel = seriesModel.levelModels[depth];

          if (levelModel) {
            model.parentModel = levelModel;
          }
        }

        return model;
      });
    }
  };

  SankeySeriesModel.prototype.setNodePosition = function (dataIndex, localPosition) {
    var dataItem = this.option.data[dataIndex];
    dataItem.localX = localPosition[0];
    dataItem.localY = localPosition[1];
  };
  /**
   * Return the graphic data structure
   *
   * @return graphic data structure
   */


  SankeySeriesModel.prototype.getGraph = function () {
    return this.getData().graph;
  };
  /**
   * Get edge data of graphic data structure
   *
   * @return data structure of list
   */


  SankeySeriesModel.prototype.getEdgeData = function () {
    return this.getGraph().edgeData;
  };

  SankeySeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
    function noValue(val) {
      return isNaN(val) || val == null;
    } // dataType === 'node' or empty do not show tooltip by default


    if (dataType === 'edge') {
      var params = this.getDataParams(dataIndex, dataType);
      var rawDataOpt = params.data;
      var edgeValue = params.value;
      var edgeName = rawDataOpt.source + ' -- ' + rawDataOpt.target;
      return (0,_component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_3__.createTooltipMarkup)('nameValue', {
        name: edgeName,
        value: edgeValue,
        noValue: noValue(edgeValue)
      });
    } // dataType === 'node'
    else {
        var node = this.getGraph().getNodeByIndex(dataIndex);
        var value = node.getLayout().value;
        var name_1 = this.getDataParams(dataIndex, dataType).data.name;
        return (0,_component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_3__.createTooltipMarkup)('nameValue', {
          name: name_1 != null ? name_1 + '' : null,
          value: value,
          noValue: noValue(value)
        });
      }
  };

  SankeySeriesModel.prototype.optionUpdated = function () {
    var option = this.option;
  }; // Override Series.getDataParams()


  SankeySeriesModel.prototype.getDataParams = function (dataIndex, dataType) {
    var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);

    if (params.value == null && dataType === 'node') {
      var node = this.getGraph().getNodeByIndex(dataIndex);
      var nodeValue = node.getLayout().value;
      params.value = nodeValue;
    }

    return params;
  };

  SankeySeriesModel.type = 'series.sankey';
  SankeySeriesModel.defaultOption = {
    zlevel: 0,
    z: 2,
    coordinateSystem: 'view',
    left: '5%',
    top: '5%',
    right: '20%',
    bottom: '5%',
    orient: 'horizontal',
    nodeWidth: 20,
    nodeGap: 8,
    draggable: true,
    layoutIterations: 32,
    label: {
      show: true,
      position: 'right',
      fontSize: 12
    },
    levels: [],
    nodeAlign: 'justify',
    lineStyle: {
      color: '#314656',
      opacity: 0.2,
      curveness: 0.5
    },
    emphasis: {
      label: {
        show: true
      },
      lineStyle: {
        opacity: 0.5
      }
    },
    select: {
      itemStyle: {
        borderColor: '#212121'
      }
    },
    animationEasing: 'linear',
    animationDuration: 1000
  };
  return SankeySeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_4__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SankeySeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/sankey/SankeyView.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/sankey/SankeyView.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Path.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/LinearGradient.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







var SankeyPathShape =
/** @class */
function () {
  function SankeyPathShape() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.cpx1 = 0;
    this.cpy1 = 0;
    this.cpx2 = 0;
    this.cpy2 = 0;
    this.extent = 0;
  }

  return SankeyPathShape;
}();

var SankeyPath =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SankeyPath, _super);

  function SankeyPath(opts) {
    return _super.call(this, opts) || this;
  }

  SankeyPath.prototype.getDefaultShape = function () {
    return new SankeyPathShape();
  };

  SankeyPath.prototype.buildPath = function (ctx, shape) {
    var extent = shape.extent;
    ctx.moveTo(shape.x1, shape.y1);
    ctx.bezierCurveTo(shape.cpx1, shape.cpy1, shape.cpx2, shape.cpy2, shape.x2, shape.y2);

    if (shape.orient === 'vertical') {
      ctx.lineTo(shape.x2 + extent, shape.y2);
      ctx.bezierCurveTo(shape.cpx2 + extent, shape.cpy2, shape.cpx1 + extent, shape.cpy1, shape.x1 + extent, shape.y1);
    } else {
      ctx.lineTo(shape.x2, shape.y2 + extent);
      ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + extent, shape.cpx1, shape.cpy1 + extent, shape.x1, shape.y1 + extent);
    }

    ctx.closePath();
  };

  SankeyPath.prototype.highlight = function () {
    (0,_util_states__WEBPACK_IMPORTED_MODULE_1__.enterEmphasis)(this);
  };

  SankeyPath.prototype.downplay = function () {
    (0,_util_states__WEBPACK_IMPORTED_MODULE_1__.leaveEmphasis)(this);
  };

  return SankeyPath;
}(_util_graphic__WEBPACK_IMPORTED_MODULE_2__.default);

var SankeyView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SankeyView, _super);

  function SankeyView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = SankeyView.type;
    _this._focusAdjacencyDisabled = false;
    return _this;
  }

  SankeyView.prototype.render = function (seriesModel, ecModel, api) {
    var sankeyView = this;
    var graph = seriesModel.getGraph();
    var group = this.group;
    var layoutInfo = seriesModel.layoutInfo; // view width

    var width = layoutInfo.width; // view height

    var height = layoutInfo.height;
    var nodeData = seriesModel.getData();
    var edgeData = seriesModel.getData('edge');
    var orient = seriesModel.get('orient');
    this._model = seriesModel;
    group.removeAll();
    group.x = layoutInfo.x;
    group.y = layoutInfo.y; // generate a bezire Curve for each edge

    graph.eachEdge(function (edge) {
      var curve = new SankeyPath();
      var ecData = (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_3__.getECData)(curve);
      ecData.dataIndex = edge.dataIndex;
      ecData.seriesIndex = seriesModel.seriesIndex;
      ecData.dataType = 'edge';
      var edgeModel = edge.getModel();
      var lineStyleModel = edgeModel.getModel('lineStyle');
      var curvature = lineStyleModel.get('curveness');
      var n1Layout = edge.node1.getLayout();
      var node1Model = edge.node1.getModel();
      var dragX1 = node1Model.get('localX');
      var dragY1 = node1Model.get('localY');
      var n2Layout = edge.node2.getLayout();
      var node2Model = edge.node2.getModel();
      var dragX2 = node2Model.get('localX');
      var dragY2 = node2Model.get('localY');
      var edgeLayout = edge.getLayout();
      var x1;
      var y1;
      var x2;
      var y2;
      var cpx1;
      var cpy1;
      var cpx2;
      var cpy2;
      curve.shape.extent = Math.max(1, edgeLayout.dy);
      curve.shape.orient = orient;

      if (orient === 'vertical') {
        x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + edgeLayout.sy;
        y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + n1Layout.dy;
        x2 = (dragX2 != null ? dragX2 * width : n2Layout.x) + edgeLayout.ty;
        y2 = dragY2 != null ? dragY2 * height : n2Layout.y;
        cpx1 = x1;
        cpy1 = y1 * (1 - curvature) + y2 * curvature;
        cpx2 = x2;
        cpy2 = y1 * curvature + y2 * (1 - curvature);
      } else {
        x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + n1Layout.dx;
        y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + edgeLayout.sy;
        x2 = dragX2 != null ? dragX2 * width : n2Layout.x;
        y2 = (dragY2 != null ? dragY2 * height : n2Layout.y) + edgeLayout.ty;
        cpx1 = x1 * (1 - curvature) + x2 * curvature;
        cpy1 = y1;
        cpx2 = x1 * curvature + x2 * (1 - curvature);
        cpy2 = y2;
      }

      curve.setShape({
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        cpx1: cpx1,
        cpy1: cpy1,
        cpx2: cpx2,
        cpy2: cpy2
      });
      curve.useStyle(lineStyleModel.getItemStyle()); // Special color, use source node color or target node color

      switch (curve.style.fill) {
        case 'source':
          curve.style.fill = edge.node1.getVisual('color');
          curve.style.decal = edge.node1.getVisual('style').decal;
          break;

        case 'target':
          curve.style.fill = edge.node2.getVisual('color');
          curve.style.decal = edge.node2.getVisual('style').decal;
          break;

        case 'gradient':
          var sourceColor = edge.node1.getVisual('color');
          var targetColor = edge.node2.getVisual('color');

          if (typeof sourceColor === 'string' && typeof targetColor === 'string') {
            curve.style.fill = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default(0, 0, 1, 0, [{
              color: sourceColor,
              offset: 0
            }, {
              color: targetColor,
              offset: 1
            }]);
          }

      }

      var emphasisModel = edgeModel.getModel('emphasis');
      (0,_util_states__WEBPACK_IMPORTED_MODULE_1__.setStatesStylesFromModel)(curve, edgeModel, 'lineStyle', function (model) {
        return model.getItemStyle();
      });
      group.add(curve);
      edgeData.setItemGraphicEl(edge.dataIndex, curve);
      var focus = emphasisModel.get('focus');
      (0,_util_states__WEBPACK_IMPORTED_MODULE_1__.enableHoverEmphasis)(curve, focus === 'adjacency' ? edge.getAdjacentDataIndices() : focus, emphasisModel.get('blurScope'));
      (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_3__.getECData)(curve).dataType = 'edge';
    }); // Generate a rect for each node

    graph.eachNode(function (node) {
      var layout = node.getLayout();
      var itemModel = node.getModel();
      var dragX = itemModel.get('localX');
      var dragY = itemModel.get('localY');
      var emphasisModel = itemModel.getModel('emphasis');
      var rect = new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default({
        shape: {
          x: dragX != null ? dragX * width : layout.x,
          y: dragY != null ? dragY * height : layout.y,
          width: layout.dx,
          height: layout.dy
        },
        style: itemModel.getModel('itemStyle').getItemStyle()
      });
      (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_6__.setLabelStyle)(rect, (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_6__.getLabelStatesModels)(itemModel), {
        labelFetcher: seriesModel,
        labelDataIndex: node.dataIndex,
        defaultText: node.id
      });
      rect.disableLabelAnimation = true;
      rect.setStyle('fill', node.getVisual('color'));
      rect.setStyle('decal', node.getVisual('style').decal);
      (0,_util_states__WEBPACK_IMPORTED_MODULE_1__.setStatesStylesFromModel)(rect, itemModel);
      group.add(rect);
      nodeData.setItemGraphicEl(node.dataIndex, rect);
      (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_3__.getECData)(rect).dataType = 'node';
      var focus = emphasisModel.get('focus');
      (0,_util_states__WEBPACK_IMPORTED_MODULE_1__.enableHoverEmphasis)(rect, focus === 'adjacency' ? node.getAdjacentDataIndices() : focus, emphasisModel.get('blurScope'));
    });
    nodeData.eachItemGraphicEl(function (el, dataIndex) {
      var itemModel = nodeData.getItemModel(dataIndex);

      if (itemModel.get('draggable')) {
        el.drift = function (dx, dy) {
          sankeyView._focusAdjacencyDisabled = true;
          this.shape.x += dx;
          this.shape.y += dy;
          this.dirty();
          api.dispatchAction({
            type: 'dragNode',
            seriesId: seriesModel.id,
            dataIndex: nodeData.getRawIndex(dataIndex),
            localX: this.shape.x / width,
            localY: this.shape.y / height
          });
        };

        el.ondragend = function () {
          sankeyView._focusAdjacencyDisabled = false;
        };

        el.draggable = true;
        el.cursor = 'move';
      }
    });

    if (!this._data && seriesModel.isAnimationEnabled()) {
      group.setClipPath(createGridClipShape(group.getBoundingRect(), seriesModel, function () {
        group.removeClipPath();
      }));
    }

    this._data = seriesModel.getData();
  };

  SankeyView.prototype.dispose = function () {};

  SankeyView.type = 'sankey';
  return SankeyView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_7__.default); // Add animation to the view


function createGridClipShape(rect, seriesModel, cb) {
  var rectEl = new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default({
    shape: {
      x: rect.x - 10,
      y: rect.y - 10,
      width: 0,
      height: rect.height + 20
    }
  });
  _util_graphic__WEBPACK_IMPORTED_MODULE_8__.initProps(rectEl, {
    shape: {
      width: rect.width + 20
    }
  }, seriesModel, cb);
  return rectEl;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SankeyView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/sankey/install.js":
/*!**********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/sankey/install.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _SankeyView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SankeyView */ "./node_modules/echarts/lib/chart/sankey/SankeyView.js");
/* harmony import */ var _SankeySeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SankeySeries */ "./node_modules/echarts/lib/chart/sankey/SankeySeries.js");
/* harmony import */ var _sankeyLayout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sankeyLayout */ "./node_modules/echarts/lib/chart/sankey/sankeyLayout.js");
/* harmony import */ var _sankeyVisual__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sankeyVisual */ "./node_modules/echarts/lib/chart/sankey/sankeyVisual.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




function install(registers) {
  registers.registerChartView(_SankeyView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerSeriesModel(_SankeySeries__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerLayout(_sankeyLayout__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerVisual(_sankeyVisual__WEBPACK_IMPORTED_MODULE_3__.default);
  registers.registerAction({
    type: 'dragNode',
    event: 'dragnode',
    // here can only use 'update' now, other value is not support in echarts.
    update: 'update'
  }, function (payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'series',
      subType: 'sankey',
      query: payload
    }, function (seriesModel) {
      seriesModel.setNodePosition(payload.dataIndex, [payload.localX, payload.localY]);
    });
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/sankey/sankeyLayout.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/sankey/sankeyLayout.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sankeyLayout)
/* harmony export */ });
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function sankeyLayout(ecModel, api) {
  ecModel.eachSeriesByType('sankey', function (seriesModel) {
    var nodeWidth = seriesModel.get('nodeWidth');
    var nodeGap = seriesModel.get('nodeGap');
    var layoutInfo = getViewRect(seriesModel, api);
    seriesModel.layoutInfo = layoutInfo;
    var width = layoutInfo.width;
    var height = layoutInfo.height;
    var graph = seriesModel.getGraph();
    var nodes = graph.nodes;
    var edges = graph.edges;
    computeNodeValues(nodes);
    var filteredNodes = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.filter(nodes, function (node) {
      return node.getLayout().value === 0;
    });
    var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get('layoutIterations');
    var orient = seriesModel.get('orient');
    var nodeAlign = seriesModel.get('nodeAlign');
    layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign);
  });
}
/**
 * Get the layout position of the whole view
 */

function getViewRect(seriesModel, api) {
  return _util_layout__WEBPACK_IMPORTED_MODULE_1__.getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}

function layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {
  computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);
  computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);
  computeEdgeDepths(nodes, orient);
}
/**
 * Compute the value of each node by summing the associated edge's value
 */


function computeNodeValues(nodes) {
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodes, function (node) {
    var value1 = sum(node.outEdges, getEdgeValue);
    var value2 = sum(node.inEdges, getEdgeValue);
    var nodeRawValue = node.getValue() || 0;
    var value = Math.max(value1, value2, nodeRawValue);
    node.setLayout({
      value: value
    }, true);
  });
}
/**
 * Compute the x-position for each node.
 *
 * Here we use Kahn algorithm to detect cycle when we traverse
 * the node to computer the initial x position.
 */


function computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {
  // Used to mark whether the edge is deleted. if it is deleted,
  // the value is 0, otherwise it is 1.
  var remainEdges = []; // Storage each node's indegree.

  var indegreeArr = []; //Used to storage the node with indegree is equal to 0.

  var zeroIndegrees = [];
  var nextTargetNode = [];
  var x = 0; // let kx = 0;

  for (var i = 0; i < edges.length; i++) {
    remainEdges[i] = 1;
  }

  for (var i = 0; i < nodes.length; i++) {
    indegreeArr[i] = nodes[i].inEdges.length;

    if (indegreeArr[i] === 0) {
      zeroIndegrees.push(nodes[i]);
    }
  }

  var maxNodeDepth = -1; // Traversing nodes using topological sorting to calculate the
  // horizontal(if orient === 'horizontal') or vertical(if orient === 'vertical')
  // position of the nodes.

  while (zeroIndegrees.length) {
    for (var idx = 0; idx < zeroIndegrees.length; idx++) {
      var node = zeroIndegrees[idx];
      var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
      var isItemDepth = item.depth != null && item.depth >= 0;

      if (isItemDepth && item.depth > maxNodeDepth) {
        maxNodeDepth = item.depth;
      }

      node.setLayout({
        depth: isItemDepth ? item.depth : x
      }, true);
      orient === 'vertical' ? node.setLayout({
        dy: nodeWidth
      }, true) : node.setLayout({
        dx: nodeWidth
      }, true);

      for (var edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {
        var edge = node.outEdges[edgeIdx];
        var indexEdge = edges.indexOf(edge);
        remainEdges[indexEdge] = 0;
        var targetNode = edge.node2;
        var nodeIndex = nodes.indexOf(targetNode);

        if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {
          nextTargetNode.push(targetNode);
        }
      }
    }

    ++x;
    zeroIndegrees = nextTargetNode;
    nextTargetNode = [];
  }

  for (var i = 0; i < remainEdges.length; i++) {
    if (remainEdges[i] === 1) {
      throw new Error('Sankey is a DAG, the original data has cycle!');
    }
  }

  var maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;

  if (nodeAlign && nodeAlign !== 'left') {
    adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);
  }

  var kx = orient === 'vertical' ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth;
  scaleNodeBreadths(nodes, kx, orient);
}

function isNodeDepth(node) {
  var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
  return item.depth != null && item.depth >= 0;
}

function adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {
  if (nodeAlign === 'right') {
    var nextSourceNode = [];
    var remainNodes = nodes;
    var nodeHeight = 0;

    while (remainNodes.length) {
      for (var i = 0; i < remainNodes.length; i++) {
        var node = remainNodes[i];
        node.setLayout({
          skNodeHeight: nodeHeight
        }, true);

        for (var j = 0; j < node.inEdges.length; j++) {
          var edge = node.inEdges[j];

          if (nextSourceNode.indexOf(edge.node1) < 0) {
            nextSourceNode.push(edge.node1);
          }
        }
      }

      remainNodes = nextSourceNode;
      nextSourceNode = [];
      ++nodeHeight;
    }

    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodes, function (node) {
      if (!isNodeDepth(node)) {
        node.setLayout({
          depth: Math.max(0, maxDepth - node.getLayout().skNodeHeight)
        }, true);
      }
    });
  } else if (nodeAlign === 'justify') {
    moveSinksRight(nodes, maxDepth);
  }
}
/**
 * All the node without outEgdes are assigned maximum x-position and
 *     be aligned in the last column.
 *
 * @param nodes.  node of sankey view.
 * @param maxDepth.  use to assign to node without outEdges as x-position.
 */


function moveSinksRight(nodes, maxDepth) {
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodes, function (node) {
    if (!isNodeDepth(node) && !node.outEdges.length) {
      node.setLayout({
        depth: maxDepth
      }, true);
    }
  });
}
/**
 * Scale node x-position to the width
 *
 * @param nodes  node of sankey view
 * @param kx   multiple used to scale nodes
 */


function scaleNodeBreadths(nodes, kx, orient) {
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodes, function (node) {
    var nodeDepth = node.getLayout().depth * kx;
    orient === 'vertical' ? node.setLayout({
      y: nodeDepth
    }, true) : node.setLayout({
      x: nodeDepth
    }, true);
  });
}
/**
 * Using Gauss-Seidel iterations method to compute the node depth(y-position)
 *
 * @param nodes  node of sankey view
 * @param edges  edge of sankey view
 * @param height  the whole height of the area to draw the view
 * @param nodeGap  the vertical distance between two nodes
 *     in the same column.
 * @param iterations  the number of iterations for the algorithm
 */


function computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {
  var nodesByBreadth = prepareNodesByBreadth(nodes, orient);
  initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);
  resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);

  for (var alpha = 1; iterations > 0; iterations--) {
    // 0.99 is a experience parameter, ensure that each iterations of
    // changes as small as possible.
    alpha *= 0.99;
    relaxRightToLeft(nodesByBreadth, alpha, orient);
    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
    relaxLeftToRight(nodesByBreadth, alpha, orient);
    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
  }
}

function prepareNodesByBreadth(nodes, orient) {
  var nodesByBreadth = [];
  var keyAttr = orient === 'vertical' ? 'y' : 'x';
  var groupResult = (0,_util_model__WEBPACK_IMPORTED_MODULE_2__.groupData)(nodes, function (node) {
    return node.getLayout()[keyAttr];
  });
  groupResult.keys.sort(function (a, b) {
    return a - b;
  });
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(groupResult.keys, function (key) {
    nodesByBreadth.push(groupResult.buckets.get(key));
  });
  return nodesByBreadth;
}
/**
 * Compute the original y-position for each node
 */


function initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {
  var minKy = Infinity;
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodesByBreadth, function (nodes) {
    var n = nodes.length;
    var sum = 0;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodes, function (node) {
      sum += node.getLayout().value;
    });
    var ky = orient === 'vertical' ? (width - (n - 1) * nodeGap) / sum : (height - (n - 1) * nodeGap) / sum;

    if (ky < minKy) {
      minKy = ky;
    }
  });
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodesByBreadth, function (nodes) {
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodes, function (node, i) {
      var nodeDy = node.getLayout().value * minKy;

      if (orient === 'vertical') {
        node.setLayout({
          x: i
        }, true);
        node.setLayout({
          dx: nodeDy
        }, true);
      } else {
        node.setLayout({
          y: i
        }, true);
        node.setLayout({
          dy: nodeDy
        }, true);
      }
    });
  });
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(edges, function (edge) {
    var edgeDy = +edge.getValue() * minKy;
    edge.setLayout({
      dy: edgeDy
    }, true);
  });
}
/**
 * Resolve the collision of initialized depth (y-position)
 */


function resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {
  var keyAttr = orient === 'vertical' ? 'x' : 'y';
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodesByBreadth, function (nodes) {
    nodes.sort(function (a, b) {
      return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];
    });
    var nodeX;
    var node;
    var dy;
    var y0 = 0;
    var n = nodes.length;
    var nodeDyAttr = orient === 'vertical' ? 'dx' : 'dy';

    for (var i = 0; i < n; i++) {
      node = nodes[i];
      dy = y0 - node.getLayout()[keyAttr];

      if (dy > 0) {
        nodeX = node.getLayout()[keyAttr] + dy;
        orient === 'vertical' ? node.setLayout({
          x: nodeX
        }, true) : node.setLayout({
          y: nodeX
        }, true);
      }

      y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;
    }

    var viewWidth = orient === 'vertical' ? width : height; // If the bottommost node goes outside the bounds, push it back up

    dy = y0 - nodeGap - viewWidth;

    if (dy > 0) {
      nodeX = node.getLayout()[keyAttr] - dy;
      orient === 'vertical' ? node.setLayout({
        x: nodeX
      }, true) : node.setLayout({
        y: nodeX
      }, true);
      y0 = nodeX;

      for (var i = n - 2; i >= 0; --i) {
        node = nodes[i];
        dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;

        if (dy > 0) {
          nodeX = node.getLayout()[keyAttr] - dy;
          orient === 'vertical' ? node.setLayout({
            x: nodeX
          }, true) : node.setLayout({
            y: nodeX
          }, true);
        }

        y0 = node.getLayout()[keyAttr];
      }
    }
  });
}
/**
 * Change the y-position of the nodes, except most the right side nodes
 * @param nodesByBreadth
 * @param alpha  parameter used to adjust the nodes y-position
 */


function relaxRightToLeft(nodesByBreadth, alpha, orient) {
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodesByBreadth.slice().reverse(), function (nodes) {
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodes, function (node) {
      if (node.outEdges.length) {
        var y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue);

        if (isNaN(y)) {
          var len = node.outEdges.length;
          y = len ? sum(node.outEdges, centerTarget, orient) / len : 0;
        }

        if (orient === 'vertical') {
          var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;
          node.setLayout({
            x: nodeX
          }, true);
        } else {
          var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;
          node.setLayout({
            y: nodeY
          }, true);
        }
      }
    });
  });
}

function weightedTarget(edge, orient) {
  return center(edge.node2, orient) * edge.getValue();
}

function centerTarget(edge, orient) {
  return center(edge.node2, orient);
}

function weightedSource(edge, orient) {
  return center(edge.node1, orient) * edge.getValue();
}

function centerSource(edge, orient) {
  return center(edge.node1, orient);
}

function center(node, orient) {
  return orient === 'vertical' ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;
}

function getEdgeValue(edge) {
  return edge.getValue();
}

function sum(array, cb, orient) {
  var sum = 0;
  var len = array.length;
  var i = -1;

  while (++i < len) {
    var value = +cb(array[i], orient);

    if (!isNaN(value)) {
      sum += value;
    }
  }

  return sum;
}
/**
 * Change the y-position of the nodes, except most the left side nodes
 */


function relaxLeftToRight(nodesByBreadth, alpha, orient) {
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodesByBreadth, function (nodes) {
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodes, function (node) {
      if (node.inEdges.length) {
        var y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue);

        if (isNaN(y)) {
          var len = node.inEdges.length;
          y = len ? sum(node.inEdges, centerSource, orient) / len : 0;
        }

        if (orient === 'vertical') {
          var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;
          node.setLayout({
            x: nodeX
          }, true);
        } else {
          var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;
          node.setLayout({
            y: nodeY
          }, true);
        }
      }
    });
  });
}
/**
 * Compute the depth(y-position) of each edge
 */


function computeEdgeDepths(nodes, orient) {
  var keyAttr = orient === 'vertical' ? 'x' : 'y';
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodes, function (node) {
    node.outEdges.sort(function (a, b) {
      return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];
    });
    node.inEdges.sort(function (a, b) {
      return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];
    });
  });
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodes, function (node) {
    var sy = 0;
    var ty = 0;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(node.outEdges, function (edge) {
      edge.setLayout({
        sy: sy
      }, true);
      sy += edge.getLayout().dy;
    });
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(node.inEdges, function (edge) {
      edge.setLayout({
        ty: ty
      }, true);
      ty += edge.getLayout().dy;
    });
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/sankey/sankeyVisual.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/sankey/sankeyVisual.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sankeyVisual)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../visual/VisualMapping */ "./node_modules/echarts/lib/visual/VisualMapping.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function sankeyVisual(ecModel) {
  ecModel.eachSeriesByType('sankey', function (seriesModel) {
    var graph = seriesModel.getGraph();
    var nodes = graph.nodes;

    if (nodes.length) {
      var minValue_1 = Infinity;
      var maxValue_1 = -Infinity;
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodes, function (node) {
        var nodeValue = node.getLayout().value;

        if (nodeValue < minValue_1) {
          minValue_1 = nodeValue;
        }

        if (nodeValue > maxValue_1) {
          maxValue_1 = nodeValue;
        }
      });
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(nodes, function (node) {
        var mapping = new _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_1__.default({
          type: 'color',
          mappingMethod: 'linear',
          dataExtent: [minValue_1, maxValue_1],
          visual: seriesModel.get('color')
        });
        var mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);
        var customColor = node.getModel().get(['itemStyle', 'color']);

        if (customColor != null) {
          node.setVisual('color', customColor);
          node.setVisual('style', {
            fill: customColor
          });
        } else {
          node.setVisual('color', mapValueToColor);
          node.setVisual('style', {
            fill: mapValueToColor
          });
        }
      });
    }
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/scatter/ScatterSeries.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/scatter/ScatterSeries.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _helper_createListFromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/createListFromArray */ "./node_modules/echarts/lib/chart/helper/createListFromArray.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var ScatterSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ScatterSeriesModel, _super);

  function ScatterSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ScatterSeriesModel.type;
    _this.hasSymbolVisual = true;
    return _this;
  }

  ScatterSeriesModel.prototype.getInitialData = function (option, ecModel) {
    return (0,_helper_createListFromArray__WEBPACK_IMPORTED_MODULE_1__.default)(this.getSource(), this, {
      useEncodeDefaulter: true
    });
  };

  ScatterSeriesModel.prototype.getProgressive = function () {
    var progressive = this.option.progressive;

    if (progressive == null) {
      // PENDING
      return this.option.large ? 5e3 : this.get('progressive');
    }

    return progressive;
  };

  ScatterSeriesModel.prototype.getProgressiveThreshold = function () {
    var progressiveThreshold = this.option.progressiveThreshold;

    if (progressiveThreshold == null) {
      // PENDING
      return this.option.large ? 1e4 : this.get('progressiveThreshold');
    }

    return progressiveThreshold;
  };

  ScatterSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {
    return selectors.point(data.getItemLayout(dataIndex));
  };

  ScatterSeriesModel.type = 'series.scatter';
  ScatterSeriesModel.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar'];
  ScatterSeriesModel.defaultOption = {
    coordinateSystem: 'cartesian2d',
    zlevel: 0,
    z: 2,
    legendHoverLink: true,
    symbolSize: 10,
    // symbolRotate: null,  // 图形旋转控制
    large: false,
    // Available when large is true
    largeThreshold: 2000,
    // cursor: null,
    itemStyle: {
      opacity: 0.8 // color: 各异

    },
    emphasis: {
      scale: true
    },
    // If clip the overflow graphics
    // Works on cartesian / polar series
    clip: true,
    select: {
      itemStyle: {
        borderColor: '#212121'
      }
    } // progressive: null

  };
  return ScatterSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_2__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ScatterSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/scatter/ScatterView.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/scatter/ScatterView.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _helper_SymbolDraw__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helper/SymbolDraw */ "./node_modules/echarts/lib/chart/helper/SymbolDraw.js");
/* harmony import */ var _helper_LargeSymbolDraw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helper/LargeSymbolDraw */ "./node_modules/echarts/lib/chart/helper/LargeSymbolDraw.js");
/* harmony import */ var _layout_points__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layout/points */ "./node_modules/echarts/lib/layout/points.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var ScatterView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ScatterView, _super);

  function ScatterView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ScatterView.type;
    return _this;
  }

  ScatterView.prototype.render = function (seriesModel, ecModel, api) {
    var data = seriesModel.getData();

    var symbolDraw = this._updateSymbolDraw(data, seriesModel);

    symbolDraw.updateData(data, {
      // TODO
      // If this parameter should be a shape or a bounding volume
      // shape will be more general.
      // But bounding volume like bounding rect will be much faster in the contain calculation
      clipShape: this._getClipShape(seriesModel)
    });
    this._finished = true;
  };

  ScatterView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {
    var data = seriesModel.getData();

    var symbolDraw = this._updateSymbolDraw(data, seriesModel);

    symbolDraw.incrementalPrepareUpdate(data);
    this._finished = false;
  };

  ScatterView.prototype.incrementalRender = function (taskParams, seriesModel, ecModel) {
    this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), {
      clipShape: this._getClipShape(seriesModel)
    });

    this._finished = taskParams.end === seriesModel.getData().count();
  };

  ScatterView.prototype.updateTransform = function (seriesModel, ecModel, api) {
    var data = seriesModel.getData(); // Must mark group dirty and make sure the incremental layer will be cleared
    // PENDING

    this.group.dirty();

    if (!this._finished || data.count() > 1e4 || !this._symbolDraw.isPersistent()) {
      return {
        update: true
      };
    } else {
      var res = (0,_layout_points__WEBPACK_IMPORTED_MODULE_1__.default)('').reset(seriesModel, ecModel, api);

      if (res.progress) {
        res.progress({
          start: 0,
          end: data.count(),
          count: data.count()
        }, data);
      }

      this._symbolDraw.updateLayout(data);
    }
  };

  ScatterView.prototype._getClipShape = function (seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    var clipArea = coordSys && coordSys.getArea && coordSys.getArea();
    return seriesModel.get('clip', true) ? clipArea : null;
  };

  ScatterView.prototype._updateSymbolDraw = function (data, seriesModel) {
    var symbolDraw = this._symbolDraw;
    var pipelineContext = seriesModel.pipelineContext;
    var isLargeDraw = pipelineContext.large;

    if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {
      symbolDraw && symbolDraw.remove();
      symbolDraw = this._symbolDraw = isLargeDraw ? new _helper_LargeSymbolDraw__WEBPACK_IMPORTED_MODULE_2__.default() : new _helper_SymbolDraw__WEBPACK_IMPORTED_MODULE_3__.default();
      this._isLargeDraw = isLargeDraw;
      this.group.removeAll();
    }

    this.group.add(symbolDraw.group);
    return symbolDraw;
  };

  ScatterView.prototype.remove = function (ecModel, api) {
    this._symbolDraw && this._symbolDraw.remove(true);
    this._symbolDraw = null;
  };

  ScatterView.prototype.dispose = function () {};

  ScatterView.type = 'scatter';
  return ScatterView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_4__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ScatterView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/scatter/install.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/scatter/install.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extension */ "./node_modules/echarts/lib/extension.js");
/* harmony import */ var _ScatterSeries__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ScatterSeries */ "./node_modules/echarts/lib/chart/scatter/ScatterSeries.js");
/* harmony import */ var _ScatterView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ScatterView */ "./node_modules/echarts/lib/chart/scatter/ScatterView.js");
/* harmony import */ var _component_grid_installSimple__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../component/grid/installSimple */ "./node_modules/echarts/lib/component/grid/installSimple.js");
/* harmony import */ var _layout_points__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../layout/points */ "./node_modules/echarts/lib/layout/points.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





function install(registers) {
  // In case developer forget to include grid component
  (0,_extension__WEBPACK_IMPORTED_MODULE_0__.use)(_component_grid_installSimple__WEBPACK_IMPORTED_MODULE_1__.install);
  registers.registerSeriesModel(_ScatterSeries__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerChartView(_ScatterView__WEBPACK_IMPORTED_MODULE_3__.default);
  registers.registerLayout((0,_layout_points__WEBPACK_IMPORTED_MODULE_4__.default)('scatter'));
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/sunburst/SunburstPiece.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/sunburst/SunburstPiece.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Sector.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _helper_pieHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helper/pieHelper */ "./node_modules/echarts/lib/chart/helper/pieHelper.js");
/* harmony import */ var _util_decal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/decal */ "./node_modules/echarts/lib/util/decal.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








var DEFAULT_SECTOR_Z = 2;
var DEFAULT_TEXT_Z = 4;
/**
 * Sunburstce of Sunburst including Sector, Label, LabelLine
 */

var SunburstPiece =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SunburstPiece, _super);

  function SunburstPiece(node, seriesModel, ecModel, api) {
    var _this = _super.call(this) || this;

    _this.z2 = DEFAULT_SECTOR_Z;
    _this.textConfig = {
      inside: true
    };
    (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_1__.getECData)(_this).seriesIndex = seriesModel.seriesIndex;
    var text = new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default({
      z2: DEFAULT_TEXT_Z,
      silent: node.getModel().get(['label', 'silent'])
    });

    _this.setTextContent(text);

    _this.updateData(true, node, seriesModel, ecModel, api);

    return _this;
  }

  SunburstPiece.prototype.updateData = function (firstCreate, node, // state: 'emphasis' | 'normal' | 'highlight' | 'downplay',
  seriesModel, ecModel, api) {
    this.node = node;
    node.piece = this;
    seriesModel = seriesModel || this._seriesModel;
    ecModel = ecModel || this._ecModel;
    var sector = this;
    (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_1__.getECData)(sector).dataIndex = node.dataIndex;
    var itemModel = node.getModel();
    var emphasisModel = itemModel.getModel('emphasis');
    var layout = node.getLayout();
    var sectorShape = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.extend({}, layout);
    sectorShape.label = null;
    var normalStyle = node.getVisual('style');
    normalStyle.lineJoin = 'bevel';
    var decal = node.getVisual('decal');

    if (decal) {
      normalStyle.decal = (0,_util_decal__WEBPACK_IMPORTED_MODULE_4__.createOrUpdatePatternFromDecal)(decal, api);
    }

    var cornerRadius = (0,_helper_pieHelper__WEBPACK_IMPORTED_MODULE_5__.getSectorCornerRadius)(itemModel.getModel('itemStyle'), sectorShape);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.extend(sectorShape, cornerRadius);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.each(_util_states__WEBPACK_IMPORTED_MODULE_6__.SPECIAL_STATES, function (stateName) {
      var state = sector.ensureState(stateName);
      var itemStyleModel = itemModel.getModel([stateName, 'itemStyle']);
      state.style = itemStyleModel.getItemStyle(); // border radius

      var cornerRadius = (0,_helper_pieHelper__WEBPACK_IMPORTED_MODULE_5__.getSectorCornerRadius)(itemStyleModel, sectorShape);

      if (cornerRadius) {
        state.shape = cornerRadius;
      }
    });

    if (firstCreate) {
      sector.setShape(sectorShape);
      sector.shape.r = layout.r0;
      _util_graphic__WEBPACK_IMPORTED_MODULE_7__.updateProps(sector, {
        shape: {
          r: layout.r
        }
      }, seriesModel, node.dataIndex);
    } else {
      // Disable animation for gradient since no interpolation method
      // is supported for gradient
      _util_graphic__WEBPACK_IMPORTED_MODULE_7__.updateProps(sector, {
        shape: sectorShape
      }, seriesModel);
    }

    sector.useStyle(normalStyle);

    this._updateLabel(seriesModel);

    var cursorStyle = itemModel.getShallow('cursor');
    cursorStyle && sector.attr('cursor', cursorStyle);
    this._seriesModel = seriesModel || this._seriesModel;
    this._ecModel = ecModel || this._ecModel;
    var focus = emphasisModel.get('focus');
    var focusDataIndices = focus === 'ancestor' ? node.getAncestorsIndices() : focus === 'descendant' ? node.getDescendantIndices() : null;
    (0,_util_states__WEBPACK_IMPORTED_MODULE_6__.enableHoverEmphasis)(this, focusDataIndices || focus, emphasisModel.get('blurScope'));
  };

  SunburstPiece.prototype._updateLabel = function (seriesModel) {
    var _this = this;

    var itemModel = this.node.getModel();
    var normalLabelModel = itemModel.getModel('label');
    var layout = this.node.getLayout();
    var angle = layout.endAngle - layout.startAngle;
    var midAngle = (layout.startAngle + layout.endAngle) / 2;
    var dx = Math.cos(midAngle);
    var dy = Math.sin(midAngle);
    var sector = this;
    var label = sector.getTextContent();
    var dataIndex = this.node.dataIndex;
    var labelMinAngle = normalLabelModel.get('minAngle') / 180 * Math.PI;
    var isNormalShown = normalLabelModel.get('show') && !(labelMinAngle != null && Math.abs(angle) < labelMinAngle);
    label.ignore = !isNormalShown; // TODO use setLabelStyle

    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.each(_util_states__WEBPACK_IMPORTED_MODULE_6__.DISPLAY_STATES, function (stateName) {
      var labelStateModel = stateName === 'normal' ? itemModel.getModel('label') : itemModel.getModel([stateName, 'label']);
      var isNormal = stateName === 'normal';
      var state = isNormal ? label : label.ensureState(stateName);
      var text = seriesModel.getFormattedLabel(dataIndex, stateName);

      if (isNormal) {
        text = text || _this.node.name;
      }

      state.style = (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_8__.createTextStyle)(labelStateModel, {}, null, stateName !== 'normal', true);

      if (text) {
        state.style.text = text;
      } // Not displaying text when angle is too small


      var isShown = labelStateModel.get('show');

      if (isShown != null && !isNormal) {
        state.ignore = !isShown;
      }

      var labelPosition = getLabelAttr(labelStateModel, 'position');
      var sectorState = isNormal ? sector : sector.states[stateName];
      var labelColor = sectorState.style.fill;
      sectorState.textConfig = {
        outsideFill: labelStateModel.get('color') === 'inherit' ? labelColor : null,
        inside: labelPosition !== 'outside'
      };
      var r;
      var labelPadding = getLabelAttr(labelStateModel, 'distance') || 0;
      var textAlign = getLabelAttr(labelStateModel, 'align');

      if (labelPosition === 'outside') {
        r = layout.r + labelPadding;
        textAlign = midAngle > Math.PI / 2 ? 'right' : 'left';
      } else {
        if (!textAlign || textAlign === 'center') {
          r = (layout.r + layout.r0) / 2;
          textAlign = 'center';
        } else if (textAlign === 'left') {
          r = layout.r0 + labelPadding;

          if (midAngle > Math.PI / 2) {
            textAlign = 'right';
          }
        } else if (textAlign === 'right') {
          r = layout.r - labelPadding;

          if (midAngle > Math.PI / 2) {
            textAlign = 'left';
          }
        }
      }

      state.style.align = textAlign;
      state.style.verticalAlign = getLabelAttr(labelStateModel, 'verticalAlign') || 'middle';
      state.x = r * dx + layout.cx;
      state.y = r * dy + layout.cy;
      var rotateType = getLabelAttr(labelStateModel, 'rotate');
      var rotate = 0;

      if (rotateType === 'radial') {
        rotate = -midAngle;

        if (rotate < -Math.PI / 2) {
          rotate += Math.PI;
        }
      } else if (rotateType === 'tangential') {
        rotate = Math.PI / 2 - midAngle;

        if (rotate > Math.PI / 2) {
          rotate -= Math.PI;
        } else if (rotate < -Math.PI / 2) {
          rotate += Math.PI;
        }
      } else if (typeof rotateType === 'number') {
        rotate = rotateType * Math.PI / 180;
      }

      state.rotation = rotate;
    });

    function getLabelAttr(model, name) {
      var stateAttr = model.get(name);

      if (stateAttr == null) {
        return normalLabelModel.get(name);
      }

      return stateAttr;
    }

    label.dirtyStyle();
  };

  return SunburstPiece;
}(_util_graphic__WEBPACK_IMPORTED_MODULE_9__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SunburstPiece);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/sunburst/SunburstSeries.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/sunburst/SunburstSeries.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var _data_Tree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/Tree */ "./node_modules/echarts/lib/data/Tree.js");
/* harmony import */ var _helper_treeHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helper/treeHelper */ "./node_modules/echarts/lib/chart/helper/treeHelper.js");
/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/Model */ "./node_modules/echarts/lib/model/Model.js");
/* harmony import */ var _helper_enableAriaDecalForTree__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helper/enableAriaDecalForTree */ "./node_modules/echarts/lib/chart/helper/enableAriaDecalForTree.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








var SunburstSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SunburstSeriesModel, _super);

  function SunburstSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = SunburstSeriesModel.type;
    _this.ignoreStyleOnData = true;
    return _this;
  }

  SunburstSeriesModel.prototype.getInitialData = function (option, ecModel) {
    // Create a virtual root.
    var root = {
      name: option.name,
      children: option.data
    };
    completeTreeValue(root);
    var levelModels = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map(option.levels || [], function (levelDefine) {
      return new _model_Model__WEBPACK_IMPORTED_MODULE_2__.default(levelDefine, this, ecModel);
    }, this); // Make sure always a new tree is created when setOption,
    // in TreemapView, we check whether oldTree === newTree
    // to choose mappings approach among old shapes and new shapes.

    var tree = _data_Tree__WEBPACK_IMPORTED_MODULE_3__.default.createTree(root, this, beforeLink);

    function beforeLink(nodeData) {
      nodeData.wrapMethod('getItemModel', function (model, idx) {
        var node = tree.getNodeByDataIndex(idx);
        var levelModel = levelModels[node.depth];
        levelModel && (model.parentModel = levelModel);
        return model;
      });
    }

    return tree.data;
  };

  SunburstSeriesModel.prototype.optionUpdated = function () {
    this.resetViewRoot();
  };
  /*
   * @override
   */


  SunburstSeriesModel.prototype.getDataParams = function (dataIndex) {
    var params = _super.prototype.getDataParams.apply(this, arguments);

    var node = this.getData().tree.getNodeByDataIndex(dataIndex);
    params.treePathInfo = (0,_helper_treeHelper__WEBPACK_IMPORTED_MODULE_4__.wrapTreePathInfo)(node, this);
    return params;
  };

  SunburstSeriesModel.prototype.getViewRoot = function () {
    return this._viewRoot;
  };

  SunburstSeriesModel.prototype.resetViewRoot = function (viewRoot) {
    viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
    var root = this.getRawData().tree.root;

    if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
      this._viewRoot = root;
    }
  };

  SunburstSeriesModel.prototype.enableAriaDecal = function () {
    (0,_helper_enableAriaDecalForTree__WEBPACK_IMPORTED_MODULE_5__.default)(this);
  };

  SunburstSeriesModel.type = 'series.sunburst';
  SunburstSeriesModel.defaultOption = {
    zlevel: 0,
    z: 2,
    // 默认全局居中
    center: ['50%', '50%'],
    radius: [0, '75%'],
    // 默认顺时针
    clockwise: true,
    startAngle: 90,
    // 最小角度改为0
    minAngle: 0,
    // If still show when all data zero.
    stillShowZeroSum: true,
    // 'rootToNode', 'link', or false
    nodeClick: 'rootToNode',
    renderLabelForZeroData: false,
    label: {
      // could be: 'radial', 'tangential', or 'none'
      rotate: 'radial',
      show: true,
      opacity: 1,
      // 'left' is for inner side of inside, and 'right' is for outter
      // side for inside
      align: 'center',
      position: 'inside',
      distance: 5,
      silent: true
    },
    itemStyle: {
      borderWidth: 1,
      borderColor: 'white',
      borderType: 'solid',
      shadowBlur: 0,
      shadowColor: 'rgba(0, 0, 0, 0.2)',
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      opacity: 1
    },
    emphasis: {
      focus: 'descendant'
    },
    blur: {
      itemStyle: {
        opacity: 0.2
      },
      label: {
        opacity: 0.1
      }
    },
    // Animation type canbe expansion, scale
    animationType: 'expansion',
    animationDuration: 1000,
    animationDurationUpdate: 500,
    data: [],
    levels: [],

    /**
     * Sort order.
     *
     * Valid values: 'desc', 'asc', null, or callback function.
     * 'desc' and 'asc' for descend and ascendant order;
     * null for not sorting;
     * example of callback function:
     * function(nodeA, nodeB) {
     *     return nodeA.getValue() - nodeB.getValue();
     * }
     */
    sort: 'desc'
  };
  return SunburstSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_6__.default);

function completeTreeValue(dataNode) {
  // Postorder travel tree.
  // If value of none-leaf node is not set,
  // calculate it by suming up the value of all children.
  var sum = 0;
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(dataNode.children, function (child) {
    completeTreeValue(child);
    var childValue = child.value; // TODO First value of array must be a number

    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(childValue) && (childValue = childValue[0]);
    sum += childValue;
  });
  var thisValue = dataNode.value;

  if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(thisValue)) {
    thisValue = thisValue[0];
  }

  if (thisValue == null || isNaN(thisValue)) {
    thisValue = sum;
  } // Value should not less than 0.


  if (thisValue < 0) {
    thisValue = 0;
  }

  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SunburstSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/sunburst/SunburstView.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/sunburst/SunburstView.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var _SunburstPiece__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SunburstPiece */ "./node_modules/echarts/lib/chart/sunburst/SunburstPiece.js");
/* harmony import */ var _data_DataDiffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/DataDiffer */ "./node_modules/echarts/lib/data/DataDiffer.js");
/* harmony import */ var _sunburstAction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sunburstAction */ "./node_modules/echarts/lib/chart/sunburst/sunburstAction.js");
/* harmony import */ var _util_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/format */ "./node_modules/echarts/lib/util/format.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








var SunburstView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SunburstView, _super);

  function SunburstView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = SunburstView.type;
    return _this;
  }

  SunburstView.prototype.render = function (seriesModel, ecModel, api, // @ts-ignore
  payload) {
    var self = this;
    this.seriesModel = seriesModel;
    this.api = api;
    this.ecModel = ecModel;
    var data = seriesModel.getData();
    var virtualRoot = data.tree.root;
    var newRoot = seriesModel.getViewRoot();
    var group = this.group;
    var renderLabelForZeroData = seriesModel.get('renderLabelForZeroData');
    var newChildren = [];
    newRoot.eachNode(function (node) {
      newChildren.push(node);
    });
    var oldChildren = this._oldChildren || [];
    dualTravel(newChildren, oldChildren);
    renderRollUp(virtualRoot, newRoot);

    this._initEvents();

    this._oldChildren = newChildren;

    function dualTravel(newChildren, oldChildren) {
      if (newChildren.length === 0 && oldChildren.length === 0) {
        return;
      }

      new _data_DataDiffer__WEBPACK_IMPORTED_MODULE_1__.default(oldChildren, newChildren, getKey, getKey).add(processNode).update(processNode).remove(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.curry(processNode, null)).execute();

      function getKey(node) {
        return node.getId();
      }

      function processNode(newIdx, oldIdx) {
        var newNode = newIdx == null ? null : newChildren[newIdx];
        var oldNode = oldIdx == null ? null : oldChildren[oldIdx];
        doRenderNode(newNode, oldNode);
      }
    }

    function doRenderNode(newNode, oldNode) {
      if (!renderLabelForZeroData && newNode && !newNode.getValue()) {
        // Not render data with value 0
        newNode = null;
      }

      if (newNode !== virtualRoot && oldNode !== virtualRoot) {
        if (oldNode && oldNode.piece) {
          if (newNode) {
            // Update
            oldNode.piece.updateData(false, newNode, seriesModel, ecModel, api); // For tooltip

            data.setItemGraphicEl(newNode.dataIndex, oldNode.piece);
          } else {
            // Remove
            removeNode(oldNode);
          }
        } else if (newNode) {
          // Add
          var piece = new _SunburstPiece__WEBPACK_IMPORTED_MODULE_3__.default(newNode, seriesModel, ecModel, api);
          group.add(piece); // For tooltip

          data.setItemGraphicEl(newNode.dataIndex, piece);
        }
      }
    }

    function removeNode(node) {
      if (!node) {
        return;
      }

      if (node.piece) {
        group.remove(node.piece);
        node.piece = null;
      }
    }

    function renderRollUp(virtualRoot, viewRoot) {
      if (viewRoot.depth > 0) {
        // Render
        if (self.virtualPiece) {
          // Update
          self.virtualPiece.updateData(false, virtualRoot, seriesModel, ecModel, api);
        } else {
          // Add
          self.virtualPiece = new _SunburstPiece__WEBPACK_IMPORTED_MODULE_3__.default(virtualRoot, seriesModel, ecModel, api);
          group.add(self.virtualPiece);
        } // TODO event scope


        viewRoot.piece.off('click');
        self.virtualPiece.on('click', function (e) {
          self._rootToNode(viewRoot.parentNode);
        });
      } else if (self.virtualPiece) {
        // Remove
        group.remove(self.virtualPiece);
        self.virtualPiece = null;
      }
    }
  };
  /**
   * @private
   */


  SunburstView.prototype._initEvents = function () {
    var _this = this;

    this.group.off('click');
    this.group.on('click', function (e) {
      var targetFound = false;

      var viewRoot = _this.seriesModel.getViewRoot();

      viewRoot.eachNode(function (node) {
        if (!targetFound && node.piece && node.piece === e.target) {
          var nodeClick = node.getModel().get('nodeClick');

          if (nodeClick === 'rootToNode') {
            _this._rootToNode(node);
          } else if (nodeClick === 'link') {
            var itemModel = node.getModel();
            var link = itemModel.get('link');

            if (link) {
              var linkTarget = itemModel.get('target', true) || '_blank';
              (0,_util_format__WEBPACK_IMPORTED_MODULE_4__.windowOpen)(link, linkTarget);
            }
          }

          targetFound = true;
        }
      });
    });
  };
  /**
   * @private
   */


  SunburstView.prototype._rootToNode = function (node) {
    if (node !== this.seriesModel.getViewRoot()) {
      this.api.dispatchAction({
        type: _sunburstAction__WEBPACK_IMPORTED_MODULE_5__.ROOT_TO_NODE_ACTION,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: node
      });
    }
  };
  /**
   * @implement
   */


  SunburstView.prototype.containPoint = function (point, seriesModel) {
    var treeRoot = seriesModel.getData();
    var itemLayout = treeRoot.getItemLayout(0);

    if (itemLayout) {
      var dx = point[0] - itemLayout.cx;
      var dy = point[1] - itemLayout.cy;
      var radius = Math.sqrt(dx * dx + dy * dy);
      return radius <= itemLayout.r && radius >= itemLayout.r0;
    }
  };

  SunburstView.type = 'sunburst';
  return SunburstView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_6__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SunburstView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/sunburst/install.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/sunburst/install.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _SunburstView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SunburstView */ "./node_modules/echarts/lib/chart/sunburst/SunburstView.js");
/* harmony import */ var _SunburstSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SunburstSeries */ "./node_modules/echarts/lib/chart/sunburst/SunburstSeries.js");
/* harmony import */ var _sunburstLayout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sunburstLayout */ "./node_modules/echarts/lib/chart/sunburst/sunburstLayout.js");
/* harmony import */ var _sunburstVisual__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sunburstVisual */ "./node_modules/echarts/lib/chart/sunburst/sunburstVisual.js");
/* harmony import */ var _processor_dataFilter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../processor/dataFilter */ "./node_modules/echarts/lib/processor/dataFilter.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _sunburstAction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sunburstAction */ "./node_modules/echarts/lib/chart/sunburst/sunburstAction.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







function install(registers) {
  registers.registerChartView(_SunburstView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerSeriesModel(_SunburstSeries__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerLayout((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.curry)(_sunburstLayout__WEBPACK_IMPORTED_MODULE_3__.default, 'sunburst'));
  registers.registerProcessor((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.curry)(_processor_dataFilter__WEBPACK_IMPORTED_MODULE_4__.default, 'sunburst'));
  registers.registerVisual(_sunburstVisual__WEBPACK_IMPORTED_MODULE_5__.default);
  (0,_sunburstAction__WEBPACK_IMPORTED_MODULE_6__.installSunburstAction)(registers);
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/sunburst/sunburstAction.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/sunburst/sunburstAction.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ROOT_TO_NODE_ACTION": () => (/* binding */ ROOT_TO_NODE_ACTION),
/* harmony export */   "installSunburstAction": () => (/* binding */ installSunburstAction)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/log */ "./node_modules/echarts/lib/util/log.js");
/* harmony import */ var _helper_treeHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helper/treeHelper */ "./node_modules/echarts/lib/chart/helper/treeHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var ROOT_TO_NODE_ACTION = 'sunburstRootToNode';
var HIGHLIGHT_ACTION = 'sunburstHighlight';
var UNHIGHLIGHT_ACTION = 'sunburstUnhighlight';
function installSunburstAction(registers) {
  registers.registerAction({
    type: ROOT_TO_NODE_ACTION,
    update: 'updateView'
  }, function (payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'series',
      subType: 'sunburst',
      query: payload
    }, handleRootToNode);

    function handleRootToNode(model, index) {
      var targetInfo = (0,_helper_treeHelper__WEBPACK_IMPORTED_MODULE_0__.retrieveTargetInfo)(payload, [ROOT_TO_NODE_ACTION], model);

      if (targetInfo) {
        var originViewRoot = model.getViewRoot();

        if (originViewRoot) {
          payload.direction = (0,_helper_treeHelper__WEBPACK_IMPORTED_MODULE_0__.aboveViewRoot)(originViewRoot, targetInfo.node) ? 'rollUp' : 'drillDown';
        }

        model.resetViewRoot(targetInfo.node);
      }
    }
  });
  registers.registerAction({
    type: HIGHLIGHT_ACTION,
    update: 'none'
  }, function (payload, ecModel, api) {
    // Clone
    payload = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, payload);
    ecModel.eachComponent({
      mainType: 'series',
      subType: 'sunburst',
      query: payload
    }, handleHighlight);

    function handleHighlight(model) {
      var targetInfo = (0,_helper_treeHelper__WEBPACK_IMPORTED_MODULE_0__.retrieveTargetInfo)(payload, [HIGHLIGHT_ACTION], model);

      if (targetInfo) {
        payload.dataIndex = targetInfo.node.dataIndex;
      }
    }

    if (true) {
      (0,_util_log__WEBPACK_IMPORTED_MODULE_2__.deprecateReplaceLog)('highlight', 'sunburstHighlight');
    } // Fast forward action


    api.dispatchAction((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend)(payload, {
      type: 'highlight'
    }));
  });
  registers.registerAction({
    type: UNHIGHLIGHT_ACTION,
    update: 'updateView'
  }, function (payload, ecModel, api) {
    payload = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, payload);

    if (true) {
      (0,_util_log__WEBPACK_IMPORTED_MODULE_2__.deprecateReplaceLog)('downplay', 'sunburstUnhighlight');
    }

    api.dispatchAction((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend)(payload, {
      type: 'downplay'
    }));
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/sunburst/sunburstLayout.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/sunburst/sunburstLayout.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sunburstLayout)
/* harmony export */ });
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

 // let PI2 = Math.PI * 2;

var RADIAN = Math.PI / 180;
function sunburstLayout(seriesType, ecModel, api) {
  ecModel.eachSeriesByType(seriesType, function (seriesModel) {
    var center = seriesModel.get('center');
    var radius = seriesModel.get('radius');

    if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(radius)) {
      radius = [0, radius];
    }

    if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(center)) {
      center = [center, center];
    }

    var width = api.getWidth();
    var height = api.getHeight();
    var size = Math.min(width, height);
    var cx = (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(center[0], width);
    var cy = (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(center[1], height);
    var r0 = (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(radius[0], size / 2);
    var r = (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(radius[1], size / 2);
    var startAngle = -seriesModel.get('startAngle') * RADIAN;
    var minAngle = seriesModel.get('minAngle') * RADIAN;
    var virtualRoot = seriesModel.getData().tree.root;
    var treeRoot = seriesModel.getViewRoot();
    var rootDepth = treeRoot.depth;
    var sort = seriesModel.get('sort');

    if (sort != null) {
      initChildren(treeRoot, sort);
    }

    var validDataCount = 0;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(treeRoot.children, function (child) {
      !isNaN(child.getValue()) && validDataCount++;
    });
    var sum = treeRoot.getValue(); // Sum may be 0

    var unitRadian = Math.PI / (sum || validDataCount) * 2;
    var renderRollupNode = treeRoot.depth > 0;
    var levels = treeRoot.height - (renderRollupNode ? -1 : 1);
    var rPerLevel = (r - r0) / (levels || 1);
    var clockwise = seriesModel.get('clockwise');
    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // In the case some sector angle is smaller than minAngle
    // let restAngle = PI2;
    // let valueSumLargerThanMinAngle = 0;

    var dir = clockwise ? 1 : -1;
    /**
     * Render a tree
     * @return increased angle
     */

    var renderNode = function (node, startAngle) {
      if (!node) {
        return;
      }

      var endAngle = startAngle; // Render self

      if (node !== virtualRoot) {
        // Tree node is virtual, so it doesn't need to be drawn
        var value = node.getValue();
        var angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;

        if (angle < minAngle) {
          angle = minAngle; // restAngle -= minAngle;
        } // else {
        //     valueSumLargerThanMinAngle += value;
        // }


        endAngle = startAngle + dir * angle;
        var depth = node.depth - rootDepth - (renderRollupNode ? -1 : 1);
        var rStart = r0 + rPerLevel * depth;
        var rEnd = r0 + rPerLevel * (depth + 1);
        var itemModel = node.getModel(); // @ts-ignore. TODO this is not provided to developer yet. Rename it.

        if (itemModel.get('r0') != null) {
          // @ts-ignore
          rStart = (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(itemModel.get('r0'), size / 2);
        } // @ts-ignore


        if (itemModel.get('r') != null) {
          // @ts-ignore
          rEnd = (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(itemModel.get('r'), size / 2);
        }

        node.setLayout({
          angle: angle,
          startAngle: startAngle,
          endAngle: endAngle,
          clockwise: clockwise,
          cx: cx,
          cy: cy,
          r0: rStart,
          r: rEnd
        });
      } // Render children


      if (node.children && node.children.length) {
        // currentAngle = startAngle;
        var siblingAngle_1 = 0;
        zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(node.children, function (node) {
          siblingAngle_1 += renderNode(node, startAngle + siblingAngle_1);
        });
      }

      return endAngle - startAngle;
    }; // Virtual root node for roll up


    if (renderRollupNode) {
      var rStart = r0;
      var rEnd = r0 + rPerLevel;
      var angle = Math.PI * 2;
      virtualRoot.setLayout({
        angle: angle,
        startAngle: startAngle,
        endAngle: startAngle + angle,
        clockwise: clockwise,
        cx: cx,
        cy: cy,
        r0: rStart,
        r: rEnd
      });
    }

    renderNode(treeRoot, startAngle);
  });
}
/**
 * Init node children by order and update visual
 */

function initChildren(node, sortOrder) {
  var children = node.children || [];
  node.children = sort(children, sortOrder); // Init children recursively

  if (children.length) {
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(node.children, function (child) {
      initChildren(child, sortOrder);
    });
  }
}
/**
 * Sort children nodes
 *
 * @param {TreeNode[]}               children children of node to be sorted
 * @param {string | function | null} sort sort method
 *                                   See SunburstSeries.js for details.
 */


function sort(children, sortOrder) {
  if (typeof sortOrder === 'function') {
    var sortTargets = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map(children, function (child, idx) {
      var value = child.getValue();
      return {
        params: {
          depth: child.depth,
          height: child.height,
          dataIndex: child.dataIndex,
          getValue: function () {
            return value;
          }
        },
        index: idx
      };
    });
    sortTargets.sort(function (a, b) {
      return sortOrder(a.params, b.params);
    });
    return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map(sortTargets, function (target) {
      return children[target.index];
    });
  } else {
    var isAsc_1 = sortOrder === 'asc';
    return children.sort(function (a, b) {
      var diff = (a.getValue() - b.getValue()) * (isAsc_1 ? 1 : -1);
      return diff === 0 ? (a.dataIndex - b.dataIndex) * (isAsc_1 ? -1 : 1) : diff;
    });
  }
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/sunburst/sunburstVisual.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/sunburst/sunburstVisual.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sunburstVisual)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/tool/color */ "./node_modules/zrender/lib/tool/color.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function sunburstVisual(ecModel) {
  var paletteScope = {}; // Default color strategy

  function pickColor(node, seriesModel, treeHeight) {
    // Choose color from palette based on the first level.
    var current = node;

    while (current && current.depth > 1) {
      current = current.parentNode;
    }

    var color = seriesModel.getColorFromPalette(current.name || current.dataIndex + '', paletteScope);

    if (node.depth > 1 && typeof color === 'string') {
      // Lighter on the deeper level.
      color = (0,zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_0__.lift)(color, (node.depth - 1) / (treeHeight - 1) * 0.5);
    }

    return color;
  }

  ecModel.eachSeriesByType('sunburst', function (seriesModel) {
    var data = seriesModel.getData();
    var tree = data.tree;
    tree.eachNode(function (node) {
      var model = node.getModel();
      var style = model.getModel('itemStyle').getItemStyle();

      if (!style.fill) {
        style.fill = pickColor(node, seriesModel, tree.root.height);
      }

      var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, 'style');
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend)(existsStyle, style);
    });
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/themeRiver/ThemeRiverSeries.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/themeRiver/ThemeRiverSeries.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var _data_helper_createDimensions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../data/helper/createDimensions */ "./node_modules/echarts/lib/data/helper/createDimensions.js");
/* harmony import */ var _data_helper_dimensionHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../data/helper/dimensionHelper */ "./node_modules/echarts/lib/data/helper/dimensionHelper.js");
/* harmony import */ var _data_List__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../data/List */ "./node_modules/echarts/lib/data/List.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _visual_LegendVisualProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../visual/LegendVisualProvider */ "./node_modules/echarts/lib/visual/LegendVisualProvider.js");
/* harmony import */ var _component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../component/tooltip/tooltipMarkup */ "./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/









var DATA_NAME_INDEX = 2;

var ThemeRiverSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ThemeRiverSeriesModel, _super);

  function ThemeRiverSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ThemeRiverSeriesModel.type;
    _this.useColorPaletteOnData = true;
    return _this;
  }
  /**
   * @override
   */


  ThemeRiverSeriesModel.prototype.init = function (option) {
    // eslint-disable-next-line
    _super.prototype.init.apply(this, arguments); // Put this function here is for the sake of consistency of code style.
    // Enable legend selection for each data item
    // Use a function instead of direct access because data reference may changed


    this.legendVisualProvider = new _visual_LegendVisualProvider__WEBPACK_IMPORTED_MODULE_1__.default(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind(this.getData, this), zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind(this.getRawData, this));
  };
  /**
   * If there is no value of a certain point in the time for some event,set it value to 0.
   *
   * @param {Array} data  initial data in the option
   * @return {Array}
   */


  ThemeRiverSeriesModel.prototype.fixData = function (data) {
    var rawDataLength = data.length;
    /**
     * Make sure every layer data get the same keys.
     * The value index tells which layer has visited.
     * {
     *  2014/01/01: -1
     * }
     */

    var timeValueKeys = {}; // grouped data by name

    var groupResult = (0,_util_model__WEBPACK_IMPORTED_MODULE_3__.groupData)(data, function (item) {
      if (!timeValueKeys.hasOwnProperty(item[0] + '')) {
        timeValueKeys[item[0] + ''] = -1;
      }

      return item[2];
    });
    var layerData = [];
    groupResult.buckets.each(function (items, key) {
      layerData.push({
        name: key,
        dataList: items
      });
    });
    var layerNum = layerData.length;

    for (var k = 0; k < layerNum; ++k) {
      var name_1 = layerData[k].name;

      for (var j = 0; j < layerData[k].dataList.length; ++j) {
        var timeValue = layerData[k].dataList[j][0] + '';
        timeValueKeys[timeValue] = k;
      }

      for (var timeValue in timeValueKeys) {
        if (timeValueKeys.hasOwnProperty(timeValue) && timeValueKeys[timeValue] !== k) {
          timeValueKeys[timeValue] = k;
          data[rawDataLength] = [timeValue, 0, name_1];
          rawDataLength++;
        }
      }
    }

    return data;
  };
  /**
   * @override
   * @param  option  the initial option that user gived
   * @param  ecModel  the model object for themeRiver option
   */


  ThemeRiverSeriesModel.prototype.getInitialData = function (option, ecModel) {
    var singleAxisModel = this.getReferringComponents('singleAxis', _util_model__WEBPACK_IMPORTED_MODULE_3__.SINGLE_REFERRING).models[0];
    var axisType = singleAxisModel.get('type'); // filter the data item with the value of label is undefined

    var filterData = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.filter(option.data, function (dataItem) {
      return dataItem[2] !== undefined;
    }); // ??? TODO design a stage to transfer data for themeRiver and lines?

    var data = this.fixData(filterData || []);
    var nameList = [];
    var nameMap = this.nameMap = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.createHashMap();
    var count = 0;

    for (var i = 0; i < data.length; ++i) {
      nameList.push(data[i][DATA_NAME_INDEX]);

      if (!nameMap.get(data[i][DATA_NAME_INDEX])) {
        nameMap.set(data[i][DATA_NAME_INDEX], count);
        count++;
      }
    }

    var dimensionsInfo = (0,_data_helper_createDimensions__WEBPACK_IMPORTED_MODULE_4__.default)(data, {
      coordDimensions: ['single'],
      dimensionsDefine: [{
        name: 'time',
        type: (0,_data_helper_dimensionHelper__WEBPACK_IMPORTED_MODULE_5__.getDimensionTypeByAxis)(axisType)
      }, {
        name: 'value',
        type: 'float'
      }, {
        name: 'name',
        type: 'ordinal'
      }],
      encodeDefine: {
        single: 0,
        value: 1,
        itemName: 2
      }
    });
    var list = new _data_List__WEBPACK_IMPORTED_MODULE_6__.default(dimensionsInfo, this);
    list.initData(data);
    return list;
  };
  /**
   * The raw data is divided into multiple layers and each layer
   *     has same name.
   */


  ThemeRiverSeriesModel.prototype.getLayerSeries = function () {
    var data = this.getData();
    var lenCount = data.count();
    var indexArr = [];

    for (var i = 0; i < lenCount; ++i) {
      indexArr[i] = i;
    }

    var timeDim = data.mapDimension('single'); // data group by name

    var groupResult = (0,_util_model__WEBPACK_IMPORTED_MODULE_3__.groupData)(indexArr, function (index) {
      return data.get('name', index);
    });
    var layerSeries = [];
    groupResult.buckets.each(function (items, key) {
      items.sort(function (index1, index2) {
        return data.get(timeDim, index1) - data.get(timeDim, index2);
      });
      layerSeries.push({
        name: key,
        indices: items
      });
    });
    return layerSeries;
  };
  /**
   * Get data indices for show tooltip content
   */


  ThemeRiverSeriesModel.prototype.getAxisTooltipData = function (dim, value, baseAxis) {
    if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.isArray(dim)) {
      dim = dim ? [dim] : [];
    }

    var data = this.getData();
    var layerSeries = this.getLayerSeries();
    var indices = [];
    var layerNum = layerSeries.length;
    var nestestValue;

    for (var i = 0; i < layerNum; ++i) {
      var minDist = Number.MAX_VALUE;
      var nearestIdx = -1;
      var pointNum = layerSeries[i].indices.length;

      for (var j = 0; j < pointNum; ++j) {
        var theValue = data.get(dim[0], layerSeries[i].indices[j]);
        var dist = Math.abs(theValue - value);

        if (dist <= minDist) {
          nestestValue = theValue;
          minDist = dist;
          nearestIdx = layerSeries[i].indices[j];
        }
      }

      indices.push(nearestIdx);
    }

    return {
      dataIndices: indices,
      nestestValue: nestestValue
    };
  };

  ThemeRiverSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var name = data.getName(dataIndex);
    var value = data.get(data.mapDimension('value'), dataIndex);
    return (0,_component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_7__.createTooltipMarkup)('nameValue', {
      name: name,
      value: value
    });
  };

  ThemeRiverSeriesModel.type = 'series.themeRiver';
  ThemeRiverSeriesModel.dependencies = ['singleAxis'];
  ThemeRiverSeriesModel.defaultOption = {
    zlevel: 0,
    z: 2,
    coordinateSystem: 'singleAxis',
    // gap in axis's orthogonal orientation
    boundaryGap: ['10%', '10%'],
    // legendHoverLink: true,
    singleAxisIndex: 0,
    animationEasing: 'linear',
    label: {
      margin: 4,
      show: true,
      position: 'left',
      fontSize: 11
    },
    emphasis: {
      label: {
        show: true
      }
    }
  };
  return ThemeRiverSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_8__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ThemeRiverSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/themeRiver/ThemeRiverView.js":
/*!*********************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/themeRiver/ThemeRiverView.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _line_poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../line/poly */ "./node_modules/echarts/lib/chart/line/poly.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _data_DataDiffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/DataDiffer */ "./node_modules/echarts/lib/data/DataDiffer.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/









var ThemeRiverView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ThemeRiverView, _super);

  function ThemeRiverView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ThemeRiverView.type;
    _this._layers = [];
    return _this;
  }

  ThemeRiverView.prototype.render = function (seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var self = this;
    var group = this.group;
    var layersSeries = seriesModel.getLayerSeries();
    var layoutInfo = data.getLayout('layoutInfo');
    var rect = layoutInfo.rect;
    var boundaryGap = layoutInfo.boundaryGap;
    group.x = 0;
    group.y = rect.y + boundaryGap[0];

    function keyGetter(item) {
      return item.name;
    }

    var dataDiffer = new _data_DataDiffer__WEBPACK_IMPORTED_MODULE_1__.default(this._layersSeries || [], layersSeries, keyGetter, keyGetter);
    var newLayersGroups = [];
    dataDiffer.add((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(process, this, 'add')).update((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(process, this, 'update')).remove((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(process, this, 'remove')).execute();

    function process(status, idx, oldIdx) {
      var oldLayersGroups = self._layers;

      if (status === 'remove') {
        group.remove(oldLayersGroups[idx]);
        return;
      }

      var points0 = [];
      var points1 = [];
      var style;
      var indices = layersSeries[idx].indices;
      var j = 0;

      for (; j < indices.length; j++) {
        var layout = data.getItemLayout(indices[j]);
        var x = layout.x;
        var y0 = layout.y0;
        var y = layout.y;
        points0.push(x, y0);
        points1.push(x, y0 + y);
        style = data.getItemVisual(indices[j], 'style');
      }

      var polygon;
      var textLayout = data.getItemLayout(indices[0]);
      var labelModel = seriesModel.getModel('label');
      var margin = labelModel.get('margin');
      var emphasisModel = seriesModel.getModel('emphasis');

      if (status === 'add') {
        var layerGroup = newLayersGroups[idx] = new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default();
        polygon = new _line_poly__WEBPACK_IMPORTED_MODULE_4__.ECPolygon({
          shape: {
            points: points0,
            stackedOnPoints: points1,
            smooth: 0.4,
            stackedOnSmooth: 0.4,
            smoothConstraint: false
          },
          z2: 0
        });
        layerGroup.add(polygon);
        group.add(layerGroup);

        if (seriesModel.isAnimationEnabled()) {
          polygon.setClipPath(createGridClipShape(polygon.getBoundingRect(), seriesModel, function () {
            polygon.removeClipPath();
          }));
        }
      } else {
        var layerGroup = oldLayersGroups[oldIdx];
        polygon = layerGroup.childAt(0);
        group.add(layerGroup);
        newLayersGroups[idx] = layerGroup;
        _util_graphic__WEBPACK_IMPORTED_MODULE_5__.updateProps(polygon, {
          shape: {
            points: points0,
            stackedOnPoints: points1
          }
        }, seriesModel);
      }

      (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_6__.setLabelStyle)(polygon, (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_6__.getLabelStatesModels)(seriesModel), {
        labelDataIndex: indices[j - 1],
        defaultText: data.getName(indices[j - 1]),
        inheritColor: style.fill
      }, {
        normal: {
          verticalAlign: 'middle' // align: 'right'

        }
      });
      polygon.setTextConfig({
        position: null,
        local: true
      });
      var labelEl = polygon.getTextContent(); // TODO More label position options.

      if (labelEl) {
        labelEl.x = textLayout.x - margin;
        labelEl.y = textLayout.y0 + textLayout.y / 2;
      }

      polygon.useStyle(style);
      data.setItemGraphicEl(idx, polygon);
      (0,_util_states__WEBPACK_IMPORTED_MODULE_7__.setStatesStylesFromModel)(polygon, seriesModel);
      (0,_util_states__WEBPACK_IMPORTED_MODULE_7__.enableHoverEmphasis)(polygon, emphasisModel.get('focus'), emphasisModel.get('blurScope'));
    }

    this._layersSeries = layersSeries;
    this._layers = newLayersGroups;
  };

  ThemeRiverView.type = 'themeRiver';
  return ThemeRiverView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_8__.default);

; // add animation to the view

function createGridClipShape(rect, seriesModel, cb) {
  var rectEl = new _util_graphic__WEBPACK_IMPORTED_MODULE_9__.default({
    shape: {
      x: rect.x - 10,
      y: rect.y - 10,
      width: 0,
      height: rect.height + 20
    }
  });
  _util_graphic__WEBPACK_IMPORTED_MODULE_5__.initProps(rectEl, {
    shape: {
      x: rect.x - 50,
      width: rect.width + 100,
      height: rect.height + 20
    }
  }, seriesModel, cb);
  return rectEl;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ThemeRiverView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/themeRiver/install.js":
/*!**************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/themeRiver/install.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _ThemeRiverView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ThemeRiverView */ "./node_modules/echarts/lib/chart/themeRiver/ThemeRiverView.js");
/* harmony import */ var _ThemeRiverSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ThemeRiverSeries */ "./node_modules/echarts/lib/chart/themeRiver/ThemeRiverSeries.js");
/* harmony import */ var _themeRiverLayout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./themeRiverLayout */ "./node_modules/echarts/lib/chart/themeRiver/themeRiverLayout.js");
/* harmony import */ var _processor_dataFilter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../processor/dataFilter */ "./node_modules/echarts/lib/processor/dataFilter.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */





function install(registers) {
  registers.registerChartView(_ThemeRiverView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerSeriesModel(_ThemeRiverSeries__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerLayout(_themeRiverLayout__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerProcessor((0,_processor_dataFilter__WEBPACK_IMPORTED_MODULE_3__.default)('themeRiver'));
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/themeRiver/themeRiverLayout.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/themeRiver/themeRiverLayout.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ themeRiverLayout)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function themeRiverLayout(ecModel, api) {
  ecModel.eachSeriesByType('themeRiver', function (seriesModel) {
    var data = seriesModel.getData();
    var single = seriesModel.coordinateSystem;
    var layoutInfo = {}; // use the axis boundingRect for view

    var rect = single.getRect();
    layoutInfo.rect = rect;
    var boundaryGap = seriesModel.get('boundaryGap');
    var axis = single.getAxis();
    layoutInfo.boundaryGap = boundaryGap;

    if (axis.orient === 'horizontal') {
      boundaryGap[0] = _util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent(boundaryGap[0], rect.height);
      boundaryGap[1] = _util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent(boundaryGap[1], rect.height);
      var height = rect.height - boundaryGap[0] - boundaryGap[1];
      doThemeRiverLayout(data, seriesModel, height);
    } else {
      boundaryGap[0] = _util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent(boundaryGap[0], rect.width);
      boundaryGap[1] = _util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent(boundaryGap[1], rect.width);
      var width = rect.width - boundaryGap[0] - boundaryGap[1];
      doThemeRiverLayout(data, seriesModel, width);
    }

    data.setLayout('layoutInfo', layoutInfo);
  });
}
/**
 * The layout information about themeriver
 *
 * @param data  data in the series
 * @param seriesModel  the model object of themeRiver series
 * @param height  value used to compute every series height
 */

function doThemeRiverLayout(data, seriesModel, height) {
  if (!data.count()) {
    return;
  }

  var coordSys = seriesModel.coordinateSystem; // the data in each layer are organized into a series.

  var layerSeries = seriesModel.getLayerSeries(); // the points in each layer.

  var timeDim = data.mapDimension('single');
  var valueDim = data.mapDimension('value');
  var layerPoints = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map(layerSeries, function (singleLayer) {
    return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map(singleLayer.indices, function (idx) {
      var pt = coordSys.dataToPoint(data.get(timeDim, idx));
      pt[1] = data.get(valueDim, idx);
      return pt;
    });
  });
  var base = computeBaseline(layerPoints);
  var baseLine = base.y0;
  var ky = height / base.max; // set layout information for each item.

  var n = layerSeries.length;
  var m = layerSeries[0].indices.length;
  var baseY0;

  for (var j = 0; j < m; ++j) {
    baseY0 = baseLine[j] * ky;
    data.setItemLayout(layerSeries[0].indices[j], {
      layerIndex: 0,
      x: layerPoints[0][j][0],
      y0: baseY0,
      y: layerPoints[0][j][1] * ky
    });

    for (var i = 1; i < n; ++i) {
      baseY0 += layerPoints[i - 1][j][1] * ky;
      data.setItemLayout(layerSeries[i].indices[j], {
        layerIndex: i,
        x: layerPoints[i][j][0],
        y0: baseY0,
        y: layerPoints[i][j][1] * ky
      });
    }
  }
}
/**
 * Compute the baseLine of the rawdata
 * Inspired by Lee Byron's paper Stacked Graphs - Geometry & Aesthetics
 *
 * @param  data  the points in each layer
 */


function computeBaseline(data) {
  var layerNum = data.length;
  var pointNum = data[0].length;
  var sums = [];
  var y0 = [];
  var max = 0;

  for (var i = 0; i < pointNum; ++i) {
    var temp = 0;

    for (var j = 0; j < layerNum; ++j) {
      temp += data[j][i][1];
    }

    if (temp > max) {
      max = temp;
    }

    sums.push(temp);
  }

  for (var k = 0; k < pointNum; ++k) {
    y0[k] = (max - sums[k]) / 2;
  }

  max = 0;

  for (var l = 0; l < pointNum; ++l) {
    var sum = sums[l] + y0[l];

    if (sum > max) {
      max = sum;
    }
  }

  return {
    y0: y0,
    max: max
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/tree/TreeSeries.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/tree/TreeSeries.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var _data_Tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/Tree */ "./node_modules/echarts/lib/data/Tree.js");
/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/Model */ "./node_modules/echarts/lib/model/Model.js");
/* harmony import */ var _component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../component/tooltip/tooltipMarkup */ "./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var TreeSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(TreeSeriesModel, _super);

  function TreeSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.hasSymbolVisual = true; // Do it self.

    _this.ignoreStyleOnData = true;
    return _this;
  }
  /**
   * Init a tree data structure from data in option series
   * @param  option  the object used to config echarts view
   * @return storage initial data
   */


  TreeSeriesModel.prototype.getInitialData = function (option) {
    //create an virtual root
    var root = {
      name: option.name,
      children: option.data
    };
    var leaves = option.leaves || {};
    var leavesModel = new _model_Model__WEBPACK_IMPORTED_MODULE_1__.default(leaves, this, this.ecModel);
    var tree = _data_Tree__WEBPACK_IMPORTED_MODULE_2__.default.createTree(root, this, beforeLink);

    function beforeLink(nodeData) {
      nodeData.wrapMethod('getItemModel', function (model, idx) {
        var node = tree.getNodeByDataIndex(idx);

        if (!node.children.length || !node.isExpand) {
          model.parentModel = leavesModel;
        }

        return model;
      });
    }

    var treeDepth = 0;
    tree.eachNode('preorder', function (node) {
      if (node.depth > treeDepth) {
        treeDepth = node.depth;
      }
    });
    var expandAndCollapse = option.expandAndCollapse;
    var expandTreeDepth = expandAndCollapse && option.initialTreeDepth >= 0 ? option.initialTreeDepth : treeDepth;
    tree.root.eachNode('preorder', function (node) {
      var item = node.hostTree.data.getRawDataItem(node.dataIndex); // Add item.collapsed != null, because users can collapse node original in the series.data.

      node.isExpand = item && item.collapsed != null ? !item.collapsed : node.depth <= expandTreeDepth;
    });
    return tree.data;
  };
  /**
   * Make the configuration 'orient' backward compatibly, with 'horizontal = LR', 'vertical = TB'.
   * @returns {string} orient
   */


  TreeSeriesModel.prototype.getOrient = function () {
    var orient = this.get('orient');

    if (orient === 'horizontal') {
      orient = 'LR';
    } else if (orient === 'vertical') {
      orient = 'TB';
    }

    return orient;
  };

  TreeSeriesModel.prototype.setZoom = function (zoom) {
    this.option.zoom = zoom;
  };

  TreeSeriesModel.prototype.setCenter = function (center) {
    this.option.center = center;
  };

  TreeSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
    var tree = this.getData().tree;
    var realRoot = tree.root.children[0];
    var node = tree.getNodeByDataIndex(dataIndex);
    var value = node.getValue();
    var name = node.name;

    while (node && node !== realRoot) {
      name = node.parentNode.name + '.' + name;
      node = node.parentNode;
    }

    return (0,_component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_3__.createTooltipMarkup)('nameValue', {
      name: name,
      value: value,
      noValue: isNaN(value) || value == null
    });
  };

  TreeSeriesModel.type = 'series.tree'; // can support the position parameters 'left', 'top','right','bottom', 'width',
  // 'height' in the setOption() with 'merge' mode normal.

  TreeSeriesModel.layoutMode = 'box';
  TreeSeriesModel.defaultOption = {
    zlevel: 0,
    z: 2,
    coordinateSystem: 'view',
    // the position of the whole view
    left: '12%',
    top: '12%',
    right: '12%',
    bottom: '12%',
    // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
    layout: 'orthogonal',
    // value can be 'polyline'
    edgeShape: 'curve',
    edgeForkPosition: '50%',
    // true | false | 'move' | 'scale', see module:component/helper/RoamController.
    roam: false,
    // Symbol size scale ratio in roam
    nodeScaleRatio: 0.4,
    // Default on center of graph
    center: null,
    zoom: 1,
    orient: 'LR',
    symbol: 'emptyCircle',
    symbolSize: 7,
    expandAndCollapse: true,
    initialTreeDepth: 2,
    lineStyle: {
      color: '#ccc',
      width: 1.5,
      curveness: 0.5
    },
    itemStyle: {
      color: 'lightsteelblue',
      borderColor: '#c23531',
      borderWidth: 1.5
    },
    label: {
      show: true
    },
    animationEasing: 'linear',
    animationDuration: 700,
    animationDurationUpdate: 500
  };
  return TreeSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_4__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TreeSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/tree/TreeView.js":
/*!*********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/tree/TreeView.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/BezierCurve.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _helper_Symbol__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../helper/Symbol */ "./node_modules/echarts/lib/chart/helper/Symbol.js");
/* harmony import */ var _layoutHelper__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./layoutHelper */ "./node_modules/echarts/lib/chart/tree/layoutHelper.js");
/* harmony import */ var zrender_lib_core_bbox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/core/bbox */ "./node_modules/zrender/lib/core/bbox.js");
/* harmony import */ var _coord_View__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../coord/View */ "./node_modules/echarts/lib/coord/View.js");
/* harmony import */ var _component_helper_roamHelper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../component/helper/roamHelper */ "./node_modules/echarts/lib/component/helper/roamHelper.js");
/* harmony import */ var _component_helper_RoamController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../component/helper/RoamController */ "./node_modules/echarts/lib/component/helper/RoamController.js");
/* harmony import */ var _component_helper_cursorHelper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../component/helper/cursorHelper */ "./node_modules/echarts/lib/component/helper/cursorHelper.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var zrender_lib_graphic_Path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/graphic/Path */ "./node_modules/zrender/lib/graphic/Path.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
















var TreeEdgeShape =
/** @class */
function () {
  function TreeEdgeShape() {
    this.parentPoint = [];
    this.childPoints = [];
  }

  return TreeEdgeShape;
}();

var TreePath =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(TreePath, _super);

  function TreePath(opts) {
    return _super.call(this, opts) || this;
  }

  TreePath.prototype.getDefaultStyle = function () {
    return {
      stroke: '#000',
      fill: null
    };
  };

  TreePath.prototype.getDefaultShape = function () {
    return new TreeEdgeShape();
  };

  TreePath.prototype.buildPath = function (ctx, shape) {
    var childPoints = shape.childPoints;
    var childLen = childPoints.length;
    var parentPoint = shape.parentPoint;
    var firstChildPos = childPoints[0];
    var lastChildPos = childPoints[childLen - 1];

    if (childLen === 1) {
      ctx.moveTo(parentPoint[0], parentPoint[1]);
      ctx.lineTo(firstChildPos[0], firstChildPos[1]);
      return;
    }

    var orient = shape.orient;
    var forkDim = orient === 'TB' || orient === 'BT' ? 0 : 1;
    var otherDim = 1 - forkDim;
    var forkPosition = (0,_util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent)(shape.forkPosition, 1);
    var tmpPoint = [];
    tmpPoint[forkDim] = parentPoint[forkDim];
    tmpPoint[otherDim] = parentPoint[otherDim] + (lastChildPos[otherDim] - parentPoint[otherDim]) * forkPosition;
    ctx.moveTo(parentPoint[0], parentPoint[1]);
    ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    ctx.moveTo(firstChildPos[0], firstChildPos[1]);
    tmpPoint[forkDim] = firstChildPos[forkDim];
    ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    tmpPoint[forkDim] = lastChildPos[forkDim];
    ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    ctx.lineTo(lastChildPos[0], lastChildPos[1]);

    for (var i = 1; i < childLen - 1; i++) {
      var point = childPoints[i];
      ctx.moveTo(point[0], point[1]);
      tmpPoint[forkDim] = point[forkDim];
      ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    }
  };

  return TreePath;
}(zrender_lib_graphic_Path__WEBPACK_IMPORTED_MODULE_2__.default);

var TreeView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(TreeView, _super);

  function TreeView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = TreeView.type;
    _this._mainGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default();
    return _this;
  }

  TreeView.prototype.init = function (ecModel, api) {
    this._controller = new _component_helper_RoamController__WEBPACK_IMPORTED_MODULE_4__.default(api.getZr());
    this._controllerHost = {
      target: this.group
    };
    this.group.add(this._mainGroup);
  };

  TreeView.prototype.render = function (seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var layoutInfo = seriesModel.layoutInfo;
    var group = this._mainGroup;
    var layout = seriesModel.get('layout');

    if (layout === 'radial') {
      group.x = layoutInfo.x + layoutInfo.width / 2;
      group.y = layoutInfo.y + layoutInfo.height / 2;
    } else {
      group.x = layoutInfo.x;
      group.y = layoutInfo.y;
    }

    this._updateViewCoordSys(seriesModel);

    this._updateController(seriesModel, ecModel, api);

    var oldData = this._data;
    data.diff(oldData).add(function (newIdx) {
      if (symbolNeedsDraw(data, newIdx)) {
        // Create node and edge
        updateNode(data, newIdx, null, group, seriesModel);
      }
    }).update(function (newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);

      if (!symbolNeedsDraw(data, newIdx)) {
        symbolEl && removeNode(oldData, oldIdx, symbolEl, group, seriesModel);
        return;
      } // Update node and edge


      updateNode(data, newIdx, symbolEl, group, seriesModel);
    }).remove(function (oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx); // When remove a collapsed node of subtree, since the collapsed
      // node haven't been initialized with a symbol element,
      // you can't found it's symbol element through index.
      // so if we want to remove the symbol element we should insure
      // that the symbol element is not null.

      if (symbolEl) {
        removeNode(oldData, oldIdx, symbolEl, group, seriesModel);
      }
    }).execute();
    this._nodeScaleRatio = seriesModel.get('nodeScaleRatio');

    this._updateNodeAndLinkScale(seriesModel);

    if (seriesModel.get('expandAndCollapse') === true) {
      data.eachItemGraphicEl(function (el, dataIndex) {
        el.off('click').on('click', function () {
          api.dispatchAction({
            type: 'treeExpandAndCollapse',
            seriesId: seriesModel.id,
            dataIndex: dataIndex
          });
        });
      });
    }

    this._data = data;
  };

  TreeView.prototype._updateViewCoordSys = function (seriesModel) {
    var data = seriesModel.getData();
    var points = [];
    data.each(function (idx) {
      var layout = data.getItemLayout(idx);

      if (layout && !isNaN(layout.x) && !isNaN(layout.y)) {
        points.push([+layout.x, +layout.y]);
      }
    });
    var min = [];
    var max = [];
    zrender_lib_core_bbox__WEBPACK_IMPORTED_MODULE_5__.fromPoints(points, min, max); // If don't Store min max when collapse the root node after roam,
    // the root node will disappear.

    var oldMin = this._min;
    var oldMax = this._max; // If width or height is 0

    if (max[0] - min[0] === 0) {
      min[0] = oldMin ? oldMin[0] : min[0] - 1;
      max[0] = oldMax ? oldMax[0] : max[0] + 1;
    }

    if (max[1] - min[1] === 0) {
      min[1] = oldMin ? oldMin[1] : min[1] - 1;
      max[1] = oldMax ? oldMax[1] : max[1] + 1;
    }

    var viewCoordSys = seriesModel.coordinateSystem = new _coord_View__WEBPACK_IMPORTED_MODULE_6__.default();
    viewCoordSys.zoomLimit = seriesModel.get('scaleLimit');
    viewCoordSys.setBoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
    viewCoordSys.setCenter(seriesModel.get('center'));
    viewCoordSys.setZoom(seriesModel.get('zoom')); // Here we use viewCoordSys just for computing the 'position' and 'scale' of the group

    this.group.attr({
      x: viewCoordSys.x,
      y: viewCoordSys.y,
      scaleX: viewCoordSys.scaleX,
      scaleY: viewCoordSys.scaleY
    });
    this._min = min;
    this._max = max;
  };

  TreeView.prototype._updateController = function (seriesModel, ecModel, api) {
    var _this = this;

    var controller = this._controller;
    var controllerHost = this._controllerHost;
    var group = this.group;
    controller.setPointerChecker(function (e, x, y) {
      var rect = group.getBoundingRect();
      rect.applyTransform(group.transform);
      return rect.contain(x, y) && !(0,_component_helper_cursorHelper__WEBPACK_IMPORTED_MODULE_7__.onIrrelevantElement)(e, api, seriesModel);
    });
    controller.enable(seriesModel.get('roam'));
    controllerHost.zoomLimit = seriesModel.get('scaleLimit');
    controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
    controller.off('pan').off('zoom').on('pan', function (e) {
      _component_helper_roamHelper__WEBPACK_IMPORTED_MODULE_8__.updateViewOnPan(controllerHost, e.dx, e.dy);
      api.dispatchAction({
        seriesId: seriesModel.id,
        type: 'treeRoam',
        dx: e.dx,
        dy: e.dy
      });
    }).on('zoom', function (e) {
      _component_helper_roamHelper__WEBPACK_IMPORTED_MODULE_8__.updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);
      api.dispatchAction({
        seriesId: seriesModel.id,
        type: 'treeRoam',
        zoom: e.scale,
        originX: e.originX,
        originY: e.originY
      });

      _this._updateNodeAndLinkScale(seriesModel); // Only update label layout on zoom


      api.updateLabelLayout();
    });
  };

  TreeView.prototype._updateNodeAndLinkScale = function (seriesModel) {
    var data = seriesModel.getData();

    var nodeScale = this._getNodeGlobalScale(seriesModel);

    data.eachItemGraphicEl(function (el, idx) {
      el.setSymbolScale(nodeScale);
    });
  };

  TreeView.prototype._getNodeGlobalScale = function (seriesModel) {
    var coordSys = seriesModel.coordinateSystem;

    if (coordSys.type !== 'view') {
      return 1;
    }

    var nodeScaleRatio = this._nodeScaleRatio;
    var groupZoom = coordSys.scaleX || 1; // Scale node when zoom changes

    var roamZoom = coordSys.getZoom();
    var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
    return nodeScale / groupZoom;
  };

  TreeView.prototype.dispose = function () {
    this._controller && this._controller.dispose();
    this._controllerHost = null;
  };

  TreeView.prototype.remove = function () {
    this._mainGroup.removeAll();

    this._data = null;
  };

  TreeView.type = 'tree';
  return TreeView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_9__.default);

function symbolNeedsDraw(data, dataIndex) {
  var layout = data.getItemLayout(dataIndex);
  return layout && !isNaN(layout.x) && !isNaN(layout.y);
}

function updateNode(data, dataIndex, symbolEl, group, seriesModel) {
  var isInit = !symbolEl;
  var node = data.tree.getNodeByDataIndex(dataIndex);
  var itemModel = node.getModel();
  var visualColor = node.getVisual('style').fill;
  var symbolInnerColor = node.isExpand === false && node.children.length !== 0 ? visualColor : '#fff';
  var virtualRoot = data.tree.root;
  var source = node.parentNode === virtualRoot ? node : node.parentNode || node;
  var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
  var sourceLayout = source.getLayout();
  var sourceOldLayout = sourceSymbolEl ? {
    x: sourceSymbolEl.__oldX,
    y: sourceSymbolEl.__oldY,
    rawX: sourceSymbolEl.__radialOldRawX,
    rawY: sourceSymbolEl.__radialOldRawY
  } : sourceLayout;
  var targetLayout = node.getLayout();

  if (isInit) {
    symbolEl = new _helper_Symbol__WEBPACK_IMPORTED_MODULE_10__.default(data, dataIndex, null, {
      symbolInnerColor: symbolInnerColor,
      useNameLabel: true
    });
    symbolEl.x = sourceOldLayout.x;
    symbolEl.y = sourceOldLayout.y;
  } else {
    symbolEl.updateData(data, dataIndex, null, {
      symbolInnerColor: symbolInnerColor,
      useNameLabel: true
    });
  }

  symbolEl.__radialOldRawX = symbolEl.__radialRawX;
  symbolEl.__radialOldRawY = symbolEl.__radialRawY;
  symbolEl.__radialRawX = targetLayout.rawX;
  symbolEl.__radialRawY = targetLayout.rawY;
  group.add(symbolEl);
  data.setItemGraphicEl(dataIndex, symbolEl);
  symbolEl.__oldX = symbolEl.x;
  symbolEl.__oldY = symbolEl.y;
  _util_graphic__WEBPACK_IMPORTED_MODULE_11__.updateProps(symbolEl, {
    x: targetLayout.x,
    y: targetLayout.y
  }, seriesModel);
  var symbolPath = symbolEl.getSymbolPath();

  if (seriesModel.get('layout') === 'radial') {
    var realRoot = virtualRoot.children[0];
    var rootLayout = realRoot.getLayout();
    var length_1 = realRoot.children.length;
    var rad = void 0;
    var isLeft = void 0;

    if (targetLayout.x === rootLayout.x && node.isExpand === true) {
      var center = {
        x: (realRoot.children[0].getLayout().x + realRoot.children[length_1 - 1].getLayout().x) / 2,
        y: (realRoot.children[0].getLayout().y + realRoot.children[length_1 - 1].getLayout().y) / 2
      };
      rad = Math.atan2(center.y - rootLayout.y, center.x - rootLayout.x);

      if (rad < 0) {
        rad = Math.PI * 2 + rad;
      }

      isLeft = center.x < rootLayout.x;

      if (isLeft) {
        rad = rad - Math.PI;
      }
    } else {
      rad = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x);

      if (rad < 0) {
        rad = Math.PI * 2 + rad;
      }

      if (node.children.length === 0 || node.children.length !== 0 && node.isExpand === false) {
        isLeft = targetLayout.x < rootLayout.x;

        if (isLeft) {
          rad = rad - Math.PI;
        }
      } else {
        isLeft = targetLayout.x > rootLayout.x;

        if (!isLeft) {
          rad = rad - Math.PI;
        }
      }
    }

    var textPosition = isLeft ? 'left' : 'right';
    var normalLabelModel = itemModel.getModel('label');
    var rotate = normalLabelModel.get('rotate');
    var labelRotateRadian = rotate * (Math.PI / 180);
    var textContent = symbolPath.getTextContent();

    if (textContent) {
      symbolPath.setTextConfig({
        position: normalLabelModel.get('position') || textPosition,
        rotation: rotate == null ? -rad : labelRotateRadian,
        origin: 'center'
      });
      textContent.setStyle('verticalAlign', 'middle');
    }
  } // Handle status


  var focus = itemModel.get(['emphasis', 'focus']);
  var focusDataIndices = focus === 'ancestor' ? node.getAncestorsIndices() : focus === 'descendant' ? node.getDescendantIndices() : null;

  if (focusDataIndices) {
    // Modify the focus to data indices.
    (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_12__.getECData)(symbolEl).focus = focusDataIndices;
  }

  drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group);

  if (symbolEl.__edge) {
    symbolEl.onHoverStateChange = function (toState) {
      if (toState !== 'blur') {
        // NOTE: Ensure the parent elements will been blurred firstly.
        // According to the return of getAncestorsIndices and getDescendantIndices
        // TODO: A bit tricky.
        var parentEl = node.parentNode && data.getItemGraphicEl(node.parentNode.dataIndex);

        if (!(parentEl && parentEl.hoverState === _util_states__WEBPACK_IMPORTED_MODULE_13__.HOVER_STATE_BLUR)) {
          (0,_util_states__WEBPACK_IMPORTED_MODULE_13__.setStatesFlag)(symbolEl.__edge, toState);
        }
      }
    };
  }
}

function drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group) {
  var itemModel = node.getModel();
  var edgeShape = seriesModel.get('edgeShape');
  var layout = seriesModel.get('layout');
  var orient = seriesModel.getOrient();
  var curvature = seriesModel.get(['lineStyle', 'curveness']);
  var edgeForkPosition = seriesModel.get('edgeForkPosition');
  var lineStyle = itemModel.getModel('lineStyle').getLineStyle();
  var edge = symbolEl.__edge;

  if (edgeShape === 'curve') {
    if (node.parentNode && node.parentNode !== virtualRoot) {
      if (!edge) {
        edge = symbolEl.__edge = new _util_graphic__WEBPACK_IMPORTED_MODULE_14__.default({
          shape: getEdgeShape(layout, orient, curvature, sourceOldLayout, sourceOldLayout)
        });
      }

      _util_graphic__WEBPACK_IMPORTED_MODULE_11__.updateProps(edge, {
        shape: getEdgeShape(layout, orient, curvature, sourceLayout, targetLayout)
      }, seriesModel);
    }
  } else if (edgeShape === 'polyline') {
    if (layout === 'orthogonal') {
      if (node !== virtualRoot && node.children && node.children.length !== 0 && node.isExpand === true) {
        var children = node.children;
        var childPoints = [];

        for (var i = 0; i < children.length; i++) {
          var childLayout = children[i].getLayout();
          childPoints.push([childLayout.x, childLayout.y]);
        }

        if (!edge) {
          edge = symbolEl.__edge = new TreePath({
            shape: {
              parentPoint: [targetLayout.x, targetLayout.y],
              childPoints: [[targetLayout.x, targetLayout.y]],
              orient: orient,
              forkPosition: edgeForkPosition
            }
          });
        }

        _util_graphic__WEBPACK_IMPORTED_MODULE_11__.updateProps(edge, {
          shape: {
            parentPoint: [targetLayout.x, targetLayout.y],
            childPoints: childPoints
          }
        }, seriesModel);
      }
    } else {
      if (true) {
        throw new Error('The polyline edgeShape can only be used in orthogonal layout');
      }
    }
  }

  if (edge) {
    edge.useStyle(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_15__.defaults({
      strokeNoScale: true,
      fill: null
    }, lineStyle));
    (0,_util_states__WEBPACK_IMPORTED_MODULE_13__.setStatesStylesFromModel)(edge, itemModel, 'lineStyle');
    (0,_util_states__WEBPACK_IMPORTED_MODULE_13__.setDefaultStateProxy)(edge);
    group.add(edge);
  }
}

function removeNode(data, dataIndex, symbolEl, group, seriesModel) {
  var node = data.tree.getNodeByDataIndex(dataIndex);
  var virtualRoot = data.tree.root;
  var source = node.parentNode === virtualRoot ? node : node.parentNode || node; // let edgeShape = seriesScope.edgeShape;

  var sourceLayout;

  while (sourceLayout = source.getLayout(), sourceLayout == null) {
    source = source.parentNode === virtualRoot ? source : source.parentNode || source;
  } // Use same duration and easing with update to have more consistent animation.


  var removeAnimationOpt = {
    duration: seriesModel.get('animationDurationUpdate'),
    easing: seriesModel.get('animationEasingUpdate')
  };
  _util_graphic__WEBPACK_IMPORTED_MODULE_11__.removeElement(symbolEl, {
    x: sourceLayout.x + 1,
    y: sourceLayout.y + 1
  }, seriesModel, {
    cb: function () {
      group.remove(symbolEl);
      data.setItemGraphicEl(dataIndex, null);
    },
    removeOpt: removeAnimationOpt
  });
  symbolEl.fadeOut(null, {
    fadeLabel: true,
    animation: removeAnimationOpt
  });
  var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
  var sourceEdge = sourceSymbolEl.__edge; // 1. when expand the sub tree, delete the children node should delete the edge of
  // the source at the same time. because the polyline edge shape is only owned by the source.
  // 2.when the node is the only children of the source, delete the node should delete the edge of
  // the source at the same time. the same reason as above.

  var edge = symbolEl.__edge || (source.isExpand === false || source.children.length === 1 ? sourceEdge : undefined);
  var edgeShape = seriesModel.get('edgeShape');
  var layoutOpt = seriesModel.get('layout');
  var orient = seriesModel.get('orient');
  var curvature = seriesModel.get(['lineStyle', 'curveness']);

  if (edge) {
    if (edgeShape === 'curve') {
      _util_graphic__WEBPACK_IMPORTED_MODULE_11__.removeElement(edge, {
        shape: getEdgeShape(layoutOpt, orient, curvature, sourceLayout, sourceLayout),
        style: {
          opacity: 0
        }
      }, seriesModel, {
        cb: function () {
          group.remove(edge);
        },
        removeOpt: removeAnimationOpt
      });
    } else if (edgeShape === 'polyline' && seriesModel.get('layout') === 'orthogonal') {
      _util_graphic__WEBPACK_IMPORTED_MODULE_11__.removeElement(edge, {
        shape: {
          parentPoint: [sourceLayout.x, sourceLayout.y],
          childPoints: [[sourceLayout.x, sourceLayout.y]]
        },
        style: {
          opacity: 0
        }
      }, seriesModel, {
        cb: function () {
          group.remove(edge);
        },
        removeOpt: removeAnimationOpt
      });
    }
  }
}

function getEdgeShape(layoutOpt, orient, curvature, sourceLayout, targetLayout) {
  var cpx1;
  var cpy1;
  var cpx2;
  var cpy2;
  var x1;
  var x2;
  var y1;
  var y2;

  if (layoutOpt === 'radial') {
    x1 = sourceLayout.rawX;
    y1 = sourceLayout.rawY;
    x2 = targetLayout.rawX;
    y2 = targetLayout.rawY;
    var radialCoor1 = (0,_layoutHelper__WEBPACK_IMPORTED_MODULE_16__.radialCoordinate)(x1, y1);
    var radialCoor2 = (0,_layoutHelper__WEBPACK_IMPORTED_MODULE_16__.radialCoordinate)(x1, y1 + (y2 - y1) * curvature);
    var radialCoor3 = (0,_layoutHelper__WEBPACK_IMPORTED_MODULE_16__.radialCoordinate)(x2, y2 + (y1 - y2) * curvature);
    var radialCoor4 = (0,_layoutHelper__WEBPACK_IMPORTED_MODULE_16__.radialCoordinate)(x2, y2);
    return {
      x1: radialCoor1.x || 0,
      y1: radialCoor1.y || 0,
      x2: radialCoor4.x || 0,
      y2: radialCoor4.y || 0,
      cpx1: radialCoor2.x || 0,
      cpy1: radialCoor2.y || 0,
      cpx2: radialCoor3.x || 0,
      cpy2: radialCoor3.y || 0
    };
  } else {
    x1 = sourceLayout.x;
    y1 = sourceLayout.y;
    x2 = targetLayout.x;
    y2 = targetLayout.y;

    if (orient === 'LR' || orient === 'RL') {
      cpx1 = x1 + (x2 - x1) * curvature;
      cpy1 = y1;
      cpx2 = x2 + (x1 - x2) * curvature;
      cpy2 = y2;
    }

    if (orient === 'TB' || orient === 'BT') {
      cpx1 = x1;
      cpy1 = y1 + (y2 - y1) * curvature;
      cpx2 = x2;
      cpy2 = y2 + (y1 - y2) * curvature;
    }
  }

  return {
    x1: x1,
    y1: y1,
    x2: x2,
    y2: y2,
    cpx1: cpx1,
    cpy1: cpy1,
    cpx2: cpx2,
    cpy2: cpy2
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TreeView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/tree/install.js":
/*!********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/tree/install.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _TreeView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TreeView */ "./node_modules/echarts/lib/chart/tree/TreeView.js");
/* harmony import */ var _TreeSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TreeSeries */ "./node_modules/echarts/lib/chart/tree/TreeSeries.js");
/* harmony import */ var _treeLayout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./treeLayout */ "./node_modules/echarts/lib/chart/tree/treeLayout.js");
/* harmony import */ var _treeVisual__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./treeVisual */ "./node_modules/echarts/lib/chart/tree/treeVisual.js");
/* harmony import */ var _treeAction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./treeAction */ "./node_modules/echarts/lib/chart/tree/treeAction.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





function install(registers) {
  registers.registerChartView(_TreeView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerSeriesModel(_TreeSeries__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerLayout(_treeLayout__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerVisual(_treeVisual__WEBPACK_IMPORTED_MODULE_3__.default);
  (0,_treeAction__WEBPACK_IMPORTED_MODULE_4__.installTreeAction)(registers);
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/tree/layoutHelper.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/tree/layoutHelper.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "init": () => (/* binding */ init),
/* harmony export */   "firstWalk": () => (/* binding */ firstWalk),
/* harmony export */   "secondWalk": () => (/* binding */ secondWalk),
/* harmony export */   "separation": () => (/* binding */ separation),
/* harmony export */   "radialCoordinate": () => (/* binding */ radialCoordinate),
/* harmony export */   "getViewRect": () => (/* binding */ getViewRect)
/* harmony export */ });
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/*
* A third-party license is embeded for some of the code in this file:
* The tree layoutHelper implementation was originally copied from
* "d3.js"(https://github.com/d3/d3-hierarchy) with
* some modifications made for this project.
* (see more details in the comment of the specific method below.)
* The use of the source code of this file is also subject to the terms
* and consitions of the licence of "d3.js" (BSD-3Clause, see
* </licenses/LICENSE-d3>).
*/

/**
 * @file The layout algorithm of node-link tree diagrams. Here we using Reingold-Tilford algorithm to drawing
 *       the tree.
 */

/**
 * Initialize all computational message for following algorithm.
 */

function init(inRoot) {
  var root = inRoot;
  root.hierNode = {
    defaultAncestor: null,
    ancestor: root,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  };
  var nodes = [root];
  var node;
  var children;

  while (node = nodes.pop()) {
    // jshint ignore:line
    children = node.children;

    if (node.isExpand && children.length) {
      var n = children.length;

      for (var i = n - 1; i >= 0; i--) {
        var child = children[i];
        child.hierNode = {
          defaultAncestor: null,
          ancestor: child,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i: i,
          thread: null
        };
        nodes.push(child);
      }
    }
  }
}
/**
 * The implementation of this function was originally copied from "d3.js"
 * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
 * with some modifications made for this program.
 * See the license statement at the head of this file.
 *
 * Computes a preliminary x coordinate for node. Before that, this function is
 * applied recursively to the children of node, as well as the function
 * apportion(). After spacing out the children by calling executeShifts(), the
 * node is placed to the midpoint of its outermost children.
 */

function firstWalk(node, separation) {
  var children = node.isExpand ? node.children : [];
  var siblings = node.parentNode.children;
  var subtreeW = node.hierNode.i ? siblings[node.hierNode.i - 1] : null;

  if (children.length) {
    executeShifts(node);
    var midPoint = (children[0].hierNode.prelim + children[children.length - 1].hierNode.prelim) / 2;

    if (subtreeW) {
      node.hierNode.prelim = subtreeW.hierNode.prelim + separation(node, subtreeW);
      node.hierNode.modifier = node.hierNode.prelim - midPoint;
    } else {
      node.hierNode.prelim = midPoint;
    }
  } else if (subtreeW) {
    node.hierNode.prelim = subtreeW.hierNode.prelim + separation(node, subtreeW);
  }

  node.parentNode.hierNode.defaultAncestor = apportion(node, subtreeW, node.parentNode.hierNode.defaultAncestor || siblings[0], separation);
}
/**
 * The implementation of this function was originally copied from "d3.js"
 * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
 * with some modifications made for this program.
 * See the license statement at the head of this file.
 *
 * Computes all real x-coordinates by summing up the modifiers recursively.
 */

function secondWalk(node) {
  var nodeX = node.hierNode.prelim + node.parentNode.hierNode.modifier;
  node.setLayout({
    x: nodeX
  }, true);
  node.hierNode.modifier += node.parentNode.hierNode.modifier;
}
function separation(cb) {
  return arguments.length ? cb : defaultSeparation;
}
/**
 * Transform the common coordinate to radial coordinate.
 */

function radialCoordinate(rad, r) {
  rad -= Math.PI / 2;
  return {
    x: r * Math.cos(rad),
    y: r * Math.sin(rad)
  };
}
/**
 * Get the layout position of the whole view.
 */

function getViewRect(seriesModel, api) {
  return _util_layout__WEBPACK_IMPORTED_MODULE_0__.getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}
/**
 * All other shifts, applied to the smaller subtrees between w- and w+, are
 * performed by this function.
 *
 * The implementation of this function was originally copied from "d3.js"
 * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
 * with some modifications made for this program.
 * See the license statement at the head of this file.
 */

function executeShifts(node) {
  var children = node.children;
  var n = children.length;
  var shift = 0;
  var change = 0;

  while (--n >= 0) {
    var child = children[n];
    child.hierNode.prelim += shift;
    child.hierNode.modifier += shift;
    change += child.hierNode.change;
    shift += child.hierNode.shift + change;
  }
}
/**
 * The implementation of this function was originally copied from "d3.js"
 * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
 * with some modifications made for this program.
 * See the license statement at the head of this file.
 *
 * The core of the algorithm. Here, a new subtree is combined with the
 * previous subtrees. Threads are used to traverse the inside and outside
 * contours of the left and right subtree up to the highest common level.
 * Whenever two nodes of the inside contours conflict, we compute the left
 * one of the greatest uncommon ancestors using the function nextAncestor()
 * and call moveSubtree() to shift the subtree and prepare the shifts of
 * smaller subtrees. Finally, we add a new thread (if necessary).
 */


function apportion(subtreeV, subtreeW, ancestor, separation) {
  if (subtreeW) {
    var nodeOutRight = subtreeV;
    var nodeInRight = subtreeV;
    var nodeOutLeft = nodeInRight.parentNode.children[0];
    var nodeInLeft = subtreeW;
    var sumOutRight = nodeOutRight.hierNode.modifier;
    var sumInRight = nodeInRight.hierNode.modifier;
    var sumOutLeft = nodeOutLeft.hierNode.modifier;
    var sumInLeft = nodeInLeft.hierNode.modifier;

    while (nodeInLeft = nextRight(nodeInLeft), nodeInRight = nextLeft(nodeInRight), nodeInLeft && nodeInRight) {
      nodeOutRight = nextRight(nodeOutRight);
      nodeOutLeft = nextLeft(nodeOutLeft);
      nodeOutRight.hierNode.ancestor = subtreeV;
      var shift = nodeInLeft.hierNode.prelim + sumInLeft - nodeInRight.hierNode.prelim - sumInRight + separation(nodeInLeft, nodeInRight);

      if (shift > 0) {
        moveSubtree(nextAncestor(nodeInLeft, subtreeV, ancestor), subtreeV, shift);
        sumInRight += shift;
        sumOutRight += shift;
      }

      sumInLeft += nodeInLeft.hierNode.modifier;
      sumInRight += nodeInRight.hierNode.modifier;
      sumOutRight += nodeOutRight.hierNode.modifier;
      sumOutLeft += nodeOutLeft.hierNode.modifier;
    }

    if (nodeInLeft && !nextRight(nodeOutRight)) {
      nodeOutRight.hierNode.thread = nodeInLeft;
      nodeOutRight.hierNode.modifier += sumInLeft - sumOutRight;
    }

    if (nodeInRight && !nextLeft(nodeOutLeft)) {
      nodeOutLeft.hierNode.thread = nodeInRight;
      nodeOutLeft.hierNode.modifier += sumInRight - sumOutLeft;
      ancestor = subtreeV;
    }
  }

  return ancestor;
}
/**
 * This function is used to traverse the right contour of a subtree.
 * It returns the rightmost child of node or the thread of node. The function
 * returns null if and only if node is on the highest depth of its subtree.
 */


function nextRight(node) {
  var children = node.children;
  return children.length && node.isExpand ? children[children.length - 1] : node.hierNode.thread;
}
/**
 * This function is used to traverse the left contour of a subtree (or a subforest).
 * It returns the leftmost child of node or the thread of node. The function
 * returns null if and only if node is on the highest depth of its subtree.
 */


function nextLeft(node) {
  var children = node.children;
  return children.length && node.isExpand ? children[0] : node.hierNode.thread;
}
/**
 * If nodeInLeft’s ancestor is a sibling of node, returns nodeInLeft’s ancestor.
 * Otherwise, returns the specified ancestor.
 */


function nextAncestor(nodeInLeft, node, ancestor) {
  return nodeInLeft.hierNode.ancestor.parentNode === node.parentNode ? nodeInLeft.hierNode.ancestor : ancestor;
}
/**
 * The implementation of this function was originally copied from "d3.js"
 * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
 * with some modifications made for this program.
 * See the license statement at the head of this file.
 *
 * Shifts the current subtree rooted at wr.
 * This is done by increasing prelim(w+) and modifier(w+) by shift.
 */


function moveSubtree(wl, wr, shift) {
  var change = shift / (wr.hierNode.i - wl.hierNode.i);
  wr.hierNode.change -= change;
  wr.hierNode.shift += shift;
  wr.hierNode.modifier += shift;
  wr.hierNode.prelim += shift;
  wl.hierNode.change += change;
}
/**
 * The implementation of this function was originally copied from "d3.js"
 * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
 * with some modifications made for this program.
 * See the license statement at the head of this file.
 */


function defaultSeparation(node1, node2) {
  return node1.parentNode === node2.parentNode ? 1 : 2;
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/tree/traversalHelper.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/tree/traversalHelper.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "eachAfter": () => (/* binding */ eachAfter),
/* harmony export */   "eachBefore": () => (/* binding */ eachBefore)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Traverse the tree from bottom to top and do something
 */
function eachAfter(root, callback, separation) {
  var nodes = [root];
  var next = [];
  var node;

  while (node = nodes.pop()) {
    // jshint ignore:line
    next.push(node);

    if (node.isExpand) {
      var children = node.children;

      if (children.length) {
        for (var i = 0; i < children.length; i++) {
          nodes.push(children[i]);
        }
      }
    }
  }

  while (node = next.pop()) {
    // jshint ignore:line
    callback(node, separation);
  }
}
/**
 * Traverse the tree from top to bottom and do something
 */


function eachBefore(root, callback) {
  var nodes = [root];
  var node;

  while (node = nodes.pop()) {
    // jshint ignore:line
    callback(node);

    if (node.isExpand) {
      var children = node.children;

      if (children.length) {
        for (var i = children.length - 1; i >= 0; i--) {
          nodes.push(children[i]);
        }
      }
    }
  }
}



/***/ }),

/***/ "./node_modules/echarts/lib/chart/tree/treeAction.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/tree/treeAction.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "installTreeAction": () => (/* binding */ installTreeAction)
/* harmony export */ });
/* harmony import */ var _action_roamHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../action/roamHelper */ "./node_modules/echarts/lib/action/roamHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

function installTreeAction(registers) {
  registers.registerAction({
    type: 'treeExpandAndCollapse',
    event: 'treeExpandAndCollapse',
    update: 'update'
  }, function (payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'series',
      subType: 'tree',
      query: payload
    }, function (seriesModel) {
      var dataIndex = payload.dataIndex;
      var tree = seriesModel.getData().tree;
      var node = tree.getNodeByDataIndex(dataIndex);
      node.isExpand = !node.isExpand;
    });
  });
  registers.registerAction({
    type: 'treeRoam',
    event: 'treeRoam',
    // Here we set 'none' instead of 'update', because roam action
    // just need to update the transform matrix without having to recalculate
    // the layout. So don't need to go through the whole update process, such
    // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
    update: 'none'
  }, function (payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'series',
      subType: 'tree',
      query: payload
    }, function (seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var res = (0,_action_roamHelper__WEBPACK_IMPORTED_MODULE_0__.updateCenterAndZoom)(coordSys, payload);
      seriesModel.setCenter && seriesModel.setCenter(res.center);
      seriesModel.setZoom && seriesModel.setZoom(res.zoom);
    });
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/tree/treeLayout.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/tree/treeLayout.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ treeLayout)
/* harmony export */ });
/* harmony import */ var _traversalHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./traversalHelper */ "./node_modules/echarts/lib/chart/tree/traversalHelper.js");
/* harmony import */ var _layoutHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layoutHelper */ "./node_modules/echarts/lib/chart/tree/layoutHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function treeLayout(ecModel, api) {
  ecModel.eachSeriesByType('tree', function (seriesModel) {
    commonLayout(seriesModel, api);
  });
}

function commonLayout(seriesModel, api) {
  var layoutInfo = (0,_layoutHelper__WEBPACK_IMPORTED_MODULE_0__.getViewRect)(seriesModel, api);
  seriesModel.layoutInfo = layoutInfo;
  var layout = seriesModel.get('layout');
  var width = 0;
  var height = 0;
  var separation = null;

  if (layout === 'radial') {
    width = 2 * Math.PI;
    height = Math.min(layoutInfo.height, layoutInfo.width) / 2;
    separation = (0,_layoutHelper__WEBPACK_IMPORTED_MODULE_0__.separation)(function (node1, node2) {
      return (node1.parentNode === node2.parentNode ? 1 : 2) / node1.depth;
    });
  } else {
    width = layoutInfo.width;
    height = layoutInfo.height;
    separation = (0,_layoutHelper__WEBPACK_IMPORTED_MODULE_0__.separation)();
  }

  var virtualRoot = seriesModel.getData().tree.root;
  var realRoot = virtualRoot.children[0];

  if (realRoot) {
    (0,_layoutHelper__WEBPACK_IMPORTED_MODULE_0__.init)(virtualRoot);
    (0,_traversalHelper__WEBPACK_IMPORTED_MODULE_1__.eachAfter)(realRoot, _layoutHelper__WEBPACK_IMPORTED_MODULE_0__.firstWalk, separation);
    virtualRoot.hierNode.modifier = -realRoot.hierNode.prelim;
    (0,_traversalHelper__WEBPACK_IMPORTED_MODULE_1__.eachBefore)(realRoot, _layoutHelper__WEBPACK_IMPORTED_MODULE_0__.secondWalk);
    var left_1 = realRoot;
    var right_1 = realRoot;
    var bottom_1 = realRoot;
    (0,_traversalHelper__WEBPACK_IMPORTED_MODULE_1__.eachBefore)(realRoot, function (node) {
      var x = node.getLayout().x;

      if (x < left_1.getLayout().x) {
        left_1 = node;
      }

      if (x > right_1.getLayout().x) {
        right_1 = node;
      }

      if (node.depth > bottom_1.depth) {
        bottom_1 = node;
      }
    });
    var delta = left_1 === right_1 ? 1 : separation(left_1, right_1) / 2;
    var tx_1 = delta - left_1.getLayout().x;
    var kx_1 = 0;
    var ky_1 = 0;
    var coorX_1 = 0;
    var coorY_1 = 0;

    if (layout === 'radial') {
      kx_1 = width / (right_1.getLayout().x + delta + tx_1); // here we use (node.depth - 1), bucause the real root's depth is 1

      ky_1 = height / (bottom_1.depth - 1 || 1);
      (0,_traversalHelper__WEBPACK_IMPORTED_MODULE_1__.eachBefore)(realRoot, function (node) {
        coorX_1 = (node.getLayout().x + tx_1) * kx_1;
        coorY_1 = (node.depth - 1) * ky_1;
        var finalCoor = (0,_layoutHelper__WEBPACK_IMPORTED_MODULE_0__.radialCoordinate)(coorX_1, coorY_1);
        node.setLayout({
          x: finalCoor.x,
          y: finalCoor.y,
          rawX: coorX_1,
          rawY: coorY_1
        }, true);
      });
    } else {
      var orient_1 = seriesModel.getOrient();

      if (orient_1 === 'RL' || orient_1 === 'LR') {
        ky_1 = height / (right_1.getLayout().x + delta + tx_1);
        kx_1 = width / (bottom_1.depth - 1 || 1);
        (0,_traversalHelper__WEBPACK_IMPORTED_MODULE_1__.eachBefore)(realRoot, function (node) {
          coorY_1 = (node.getLayout().x + tx_1) * ky_1;
          coorX_1 = orient_1 === 'LR' ? (node.depth - 1) * kx_1 : width - (node.depth - 1) * kx_1;
          node.setLayout({
            x: coorX_1,
            y: coorY_1
          }, true);
        });
      } else if (orient_1 === 'TB' || orient_1 === 'BT') {
        kx_1 = width / (right_1.getLayout().x + delta + tx_1);
        ky_1 = height / (bottom_1.depth - 1 || 1);
        (0,_traversalHelper__WEBPACK_IMPORTED_MODULE_1__.eachBefore)(realRoot, function (node) {
          coorX_1 = (node.getLayout().x + tx_1) * kx_1;
          coorY_1 = orient_1 === 'TB' ? (node.depth - 1) * ky_1 : height - (node.depth - 1) * ky_1;
          node.setLayout({
            x: coorX_1,
            y: coorY_1
          }, true);
        });
      }
    }
  }
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/tree/treeVisual.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/tree/treeVisual.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ treeVisual)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

function treeVisual(ecModel) {
  ecModel.eachSeriesByType('tree', function (seriesModel) {
    var data = seriesModel.getData();
    var tree = data.tree;
    tree.eachNode(function (node) {
      var model = node.getModel(); // TODO Optimize

      var style = model.getModel('itemStyle').getItemStyle();
      var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, 'style');
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.extend)(existsStyle, style);
    });
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/treemap/Breadcrumb.js":
/*!**************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/treemap/Breadcrumb.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polygon.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _helper_treeHelper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helper/treeHelper */ "./node_modules/echarts/lib/chart/helper/treeHelper.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var TEXT_PADDING = 8;
var ITEM_GAP = 8;
var ARRAY_LENGTH = 5;

var Breadcrumb =
/** @class */
function () {
  function Breadcrumb(containerGroup) {
    this.group = new _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default();
    containerGroup.add(this.group);
  }

  Breadcrumb.prototype.render = function (seriesModel, api, targetNode, onSelect) {
    var model = seriesModel.getModel('breadcrumb');
    var thisGroup = this.group;
    thisGroup.removeAll();

    if (!model.get('show') || !targetNode) {
      return;
    }

    var normalStyleModel = model.getModel('itemStyle'); // let emphasisStyleModel = model.getModel('emphasis.itemStyle');

    var textStyleModel = normalStyleModel.getModel('textStyle');
    var layoutParam = {
      pos: {
        left: model.get('left'),
        right: model.get('right'),
        top: model.get('top'),
        bottom: model.get('bottom')
      },
      box: {
        width: api.getWidth(),
        height: api.getHeight()
      },
      emptyItemWidth: model.get('emptyItemWidth'),
      totalWidth: 0,
      renderList: []
    };

    this._prepare(targetNode, layoutParam, textStyleModel);

    this._renderContent(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect);

    _util_layout__WEBPACK_IMPORTED_MODULE_1__.positionElement(thisGroup, layoutParam.pos, layoutParam.box);
  };
  /**
   * Prepare render list and total width
   * @private
   */


  Breadcrumb.prototype._prepare = function (targetNode, layoutParam, textStyleModel) {
    for (var node = targetNode; node; node = node.parentNode) {
      var text = (0,_util_model__WEBPACK_IMPORTED_MODULE_2__.convertOptionIdName)(node.getModel().get('name'), '');
      var textRect = textStyleModel.getTextRect(text);
      var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);
      layoutParam.totalWidth += itemWidth + ITEM_GAP;
      layoutParam.renderList.push({
        node: node,
        text: text,
        width: itemWidth
      });
    }
  };
  /**
   * @private
   */


  Breadcrumb.prototype._renderContent = function (seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect) {
    // Start rendering.
    var lastX = 0;
    var emptyItemWidth = layoutParam.emptyItemWidth;
    var height = seriesModel.get(['breadcrumb', 'height']);
    var availableSize = _util_layout__WEBPACK_IMPORTED_MODULE_1__.getAvailableSize(layoutParam.pos, layoutParam.box);
    var totalWidth = layoutParam.totalWidth;
    var renderList = layoutParam.renderList;

    for (var i = renderList.length - 1; i >= 0; i--) {
      var item = renderList[i];
      var itemNode = item.node;
      var itemWidth = item.width;
      var text = item.text; // Hdie text and shorten width if necessary.

      if (totalWidth > availableSize.width) {
        totalWidth -= itemWidth - emptyItemWidth;
        itemWidth = emptyItemWidth;
        text = null;
      }

      var el = new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default({
        shape: {
          points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)
        },
        style: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.defaults)(normalStyleModel.getItemStyle(), {
          lineJoin: 'bevel'
        }),
        textContent: new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default({
          style: {
            text: text,
            fill: textStyleModel.getTextColor(),
            font: textStyleModel.getFont()
          }
        }),
        textConfig: {
          position: 'inside'
        },
        z: 10,
        onclick: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.curry)(onSelect, itemNode)
      });
      el.disableLabelAnimation = true;
      this.group.add(el);
      packEventData(el, seriesModel, itemNode);
      lastX += itemWidth + ITEM_GAP;
    }
  };

  Breadcrumb.prototype.remove = function () {
    this.group.removeAll();
  };

  return Breadcrumb;
}();

function makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {
  var points = [[head ? x : x - ARRAY_LENGTH, y], [x + itemWidth, y], [x + itemWidth, y + itemHeight], [head ? x : x - ARRAY_LENGTH, y + itemHeight]];
  !tail && points.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);
  !head && points.push([x, y + itemHeight / 2]);
  return points;
} // Package custom mouse event.


function packEventData(el, seriesModel, itemNode) {
  (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_6__.getECData)(el).eventData = {
    componentType: 'series',
    componentSubType: 'treemap',
    componentIndex: seriesModel.componentIndex,
    seriesIndex: seriesModel.componentIndex,
    seriesName: seriesModel.name,
    seriesType: 'treemap',
    selfType: 'breadcrumb',
    nodeData: {
      dataIndex: itemNode && itemNode.dataIndex,
      name: itemNode && itemNode.name
    },
    treePathInfo: itemNode && (0,_helper_treeHelper__WEBPACK_IMPORTED_MODULE_7__.wrapTreePathInfo)(itemNode, seriesModel)
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Breadcrumb);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/treemap/TreemapSeries.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/treemap/TreemapSeries.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _model_Series__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../model/Series */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var _data_Tree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/Tree */ "./node_modules/echarts/lib/data/Tree.js");
/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/Model */ "./node_modules/echarts/lib/model/Model.js");
/* harmony import */ var _helper_treeHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helper/treeHelper */ "./node_modules/echarts/lib/chart/helper/treeHelper.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../component/tooltip/tooltipMarkup */ "./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js");
/* harmony import */ var _helper_enableAriaDecalForTree__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helper/enableAriaDecalForTree */ "./node_modules/echarts/lib/chart/helper/enableAriaDecalForTree.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/










var TreemapSeriesModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(TreemapSeriesModel, _super);

  function TreemapSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = TreemapSeriesModel.type;
    _this.preventUsingHoverLayer = true;
    return _this;
  }
  /**
   * @override
   */


  TreemapSeriesModel.prototype.getInitialData = function (option, ecModel) {
    // Create a virtual root.
    var root = {
      name: option.name,
      children: option.data
    };
    completeTreeValue(root);
    var levels = option.levels || []; // Used in "visual priority" in `treemapVisual.js`.
    // This way is a little tricky, must satisfy the precondition:
    //   1. There is no `treeNode.getModel('itemStyle.xxx')` used.
    //   2. The `Model.prototype.getModel()` will not use any clone-like way.

    var designatedVisualItemStyle = this.designatedVisualItemStyle = {};
    var designatedVisualModel = new _model_Model__WEBPACK_IMPORTED_MODULE_1__.default({
      itemStyle: designatedVisualItemStyle
    }, this, ecModel);
    levels = option.levels = setDefault(levels, ecModel);
    var levelModels = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.map(levels || [], function (levelDefine) {
      return new _model_Model__WEBPACK_IMPORTED_MODULE_1__.default(levelDefine, designatedVisualModel, ecModel);
    }, this); // Make sure always a new tree is created when setOption,
    // in TreemapView, we check whether oldTree === newTree
    // to choose mappings approach among old shapes and new shapes.

    var tree = _data_Tree__WEBPACK_IMPORTED_MODULE_3__.default.createTree(root, this, beforeLink);

    function beforeLink(nodeData) {
      nodeData.wrapMethod('getItemModel', function (model, idx) {
        var node = tree.getNodeByDataIndex(idx);
        var levelModel = levelModels[node.depth]; // If no levelModel, we also need `designatedVisualModel`.

        model.parentModel = levelModel || designatedVisualModel;
        return model;
      });
    }

    return tree.data;
  };

  TreemapSeriesModel.prototype.optionUpdated = function () {
    this.resetViewRoot();
  };
  /**
   * @override
   * @param {number} dataIndex
   * @param {boolean} [mutipleSeries=false]
   */


  TreemapSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var value = this.getRawValue(dataIndex);
    var name = data.getName(dataIndex);
    return (0,_component_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_4__.createTooltipMarkup)('nameValue', {
      name: name,
      value: value
    });
  };
  /**
   * Add tree path to tooltip param
   *
   * @override
   * @param {number} dataIndex
   * @return {Object}
   */


  TreemapSeriesModel.prototype.getDataParams = function (dataIndex) {
    var params = _super.prototype.getDataParams.apply(this, arguments);

    var node = this.getData().tree.getNodeByDataIndex(dataIndex);
    params.treePathInfo = (0,_helper_treeHelper__WEBPACK_IMPORTED_MODULE_5__.wrapTreePathInfo)(node, this);
    return params;
  };
  /**
   * @public
   * @param {Object} layoutInfo {
   *                                x: containerGroup x
   *                                y: containerGroup y
   *                                width: containerGroup width
   *                                height: containerGroup height
   *                            }
   */


  TreemapSeriesModel.prototype.setLayoutInfo = function (layoutInfo) {
    /**
     * @readOnly
     * @type {Object}
     */
    this.layoutInfo = this.layoutInfo || {};
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.extend(this.layoutInfo, layoutInfo);
  };
  /**
   * @param  {string} id
   * @return {number} index
   */


  TreemapSeriesModel.prototype.mapIdToIndex = function (id) {
    // A feature is implemented:
    // index is monotone increasing with the sequence of
    // input id at the first time.
    // This feature can make sure that each data item and its
    // mapped color have the same index between data list and
    // color list at the beginning, which is useful for user
    // to adjust data-color mapping.

    /**
     * @private
     * @type {Object}
     */
    var idIndexMap = this._idIndexMap;

    if (!idIndexMap) {
      idIndexMap = this._idIndexMap = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.createHashMap();
      /**
       * @private
       * @type {number}
       */

      this._idIndexMapCount = 0;
    }

    var index = idIndexMap.get(id);

    if (index == null) {
      idIndexMap.set(id, index = this._idIndexMapCount++);
    }

    return index;
  };

  TreemapSeriesModel.prototype.getViewRoot = function () {
    return this._viewRoot;
  };

  TreemapSeriesModel.prototype.resetViewRoot = function (viewRoot) {
    viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
    var root = this.getRawData().tree.root;

    if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
      this._viewRoot = root;
    }
  };

  TreemapSeriesModel.prototype.enableAriaDecal = function () {
    (0,_helper_enableAriaDecalForTree__WEBPACK_IMPORTED_MODULE_6__.default)(this);
  };

  TreemapSeriesModel.type = 'series.treemap';
  TreemapSeriesModel.layoutMode = 'box';
  TreemapSeriesModel.defaultOption = {
    // Disable progressive rendering
    progressive: 0,
    // size: ['80%', '80%'],            // deprecated, compatible with ec2.
    left: 'center',
    top: 'middle',
    width: '80%',
    height: '80%',
    sort: true,
    clipWindow: 'origin',
    squareRatio: 0.5 * (1 + Math.sqrt(5)),
    leafDepth: null,
    drillDownIcon: '▶',
    // to align specialized icon. ▷▶❒❐▼✚
    zoomToNodeRatio: 0.32 * 0.32,
    roam: true,
    nodeClick: 'zoomToNode',
    animation: true,
    animationDurationUpdate: 900,
    animationEasing: 'quinticInOut',
    breadcrumb: {
      show: true,
      height: 22,
      left: 'center',
      top: 'bottom',
      // right
      // bottom
      emptyItemWidth: 25,
      itemStyle: {
        color: 'rgba(0,0,0,0.7)',
        textStyle: {
          color: '#fff'
        }
      }
    },
    label: {
      show: true,
      // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
      distance: 0,
      padding: 5,
      position: 'inside',
      // formatter: null,
      color: '#fff',
      overflow: 'truncate' // align
      // verticalAlign

    },
    upperLabel: {
      show: false,
      position: [0, '50%'],
      height: 20,
      // formatter: null,
      // color: '#fff',
      overflow: 'truncate',
      // align: null,
      verticalAlign: 'middle'
    },
    itemStyle: {
      color: null,
      colorAlpha: null,
      colorSaturation: null,
      borderWidth: 0,
      gapWidth: 0,
      borderColor: '#fff',
      borderColorSaturation: null // If specified, borderColor will be ineffective, and the
      // border color is evaluated by color of current node and
      // borderColorSaturation.

    },
    emphasis: {
      upperLabel: {
        show: true,
        position: [0, '50%'],
        ellipsis: true,
        verticalAlign: 'middle'
      }
    },
    visualDimension: 0,
    visualMin: null,
    visualMax: null,
    color: [],
    // level[n].color (if necessary).
    // + Specify color list of each level. level[0].color would be global
    // color list if not specified. (see method `setDefault`).
    // + But set as a empty array to forbid fetch color from global palette
    // when using nodeModel.get('color'), otherwise nodes on deep level
    // will always has color palette set and are not able to inherit color
    // from parent node.
    // + TreemapSeries.color can not be set as 'none', otherwise effect
    // legend color fetching (see seriesColor.js).
    colorAlpha: null,
    colorSaturation: null,
    colorMappingBy: 'index',
    visibleMin: 10,
    // be rendered. Only works when sort is 'asc' or 'desc'.
    childrenVisibleMin: null,
    // grandchildren will not show.
    // Why grandchildren? If not grandchildren but children,
    // some siblings show children and some not,
    // the appearance may be mess and not consistent,
    levels: [] // Each item: {
    //     visibleMin, itemStyle, visualDimension, label
    // }
    // data: {
    //      value: [],
    //      children: [],
    //      link: 'http://xxx.xxx.xxx',
    //      target: 'blank' or 'self'
    // }

  };
  return TreemapSeriesModel;
}(_model_Series__WEBPACK_IMPORTED_MODULE_7__.default);
/**
 * @param {Object} dataNode
 */


function completeTreeValue(dataNode) {
  // Postorder travel tree.
  // If value of none-leaf node is not set,
  // calculate it by suming up the value of all children.
  var sum = 0;
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each(dataNode.children, function (child) {
    completeTreeValue(child);
    var childValue = child.value;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.isArray(childValue) && (childValue = childValue[0]);
    sum += childValue;
  });
  var thisValue = dataNode.value;

  if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.isArray(thisValue)) {
    thisValue = thisValue[0];
  }

  if (thisValue == null || isNaN(thisValue)) {
    thisValue = sum;
  } // Value should not less than 0.


  if (thisValue < 0) {
    thisValue = 0;
  }

  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
}
/**
 * set default to level configuration
 */


function setDefault(levels, ecModel) {
  var globalColorList = (0,_util_model__WEBPACK_IMPORTED_MODULE_8__.normalizeToArray)(ecModel.get('color'));
  var globalDecalList = (0,_util_model__WEBPACK_IMPORTED_MODULE_8__.normalizeToArray)(ecModel.get(['aria', 'decal', 'decals']));

  if (!globalColorList) {
    return;
  }

  levels = levels || [];
  var hasColorDefine;
  var hasDecalDefine;
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each(levels, function (levelDefine) {
    var model = new _model_Model__WEBPACK_IMPORTED_MODULE_1__.default(levelDefine);
    var modelColor = model.get('color');
    var modelDecal = model.get('decal');

    if (model.get(['itemStyle', 'color']) || modelColor && modelColor !== 'none') {
      hasColorDefine = true;
    }

    if (model.get(['itemStyle', 'decal']) || modelDecal && modelDecal !== 'none') {
      hasDecalDefine = true;
    }
  });
  var level0 = levels[0] || (levels[0] = {});

  if (!hasColorDefine) {
    level0.color = globalColorList.slice();
  }

  if (!hasDecalDefine && globalDecalList) {
    level0.decal = globalDecalList.slice();
  }

  return levels;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TreemapSeriesModel);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/treemap/TreemapView.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/treemap/TreemapView.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _data_DataDiffer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../data/DataDiffer */ "./node_modules/echarts/lib/data/DataDiffer.js");
/* harmony import */ var _helper_treeHelper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helper/treeHelper */ "./node_modules/echarts/lib/chart/helper/treeHelper.js");
/* harmony import */ var _Breadcrumb__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Breadcrumb */ "./node_modules/echarts/lib/chart/treemap/Breadcrumb.js");
/* harmony import */ var _component_helper_RoamController__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../component/helper/RoamController */ "./node_modules/echarts/lib/component/helper/RoamController.js");
/* harmony import */ var zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! zrender/lib/core/BoundingRect */ "./node_modules/zrender/lib/core/BoundingRect.js");
/* harmony import */ var zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! zrender/lib/core/matrix */ "./node_modules/zrender/lib/core/matrix.js");
/* harmony import */ var _util_animation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/animation */ "./node_modules/echarts/lib/util/animation.js");
/* harmony import */ var _model_mixin_makeStyleMapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/mixin/makeStyleMapper */ "./node_modules/echarts/lib/model/mixin/makeStyleMapper.js");
/* harmony import */ var _view_Chart__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../view/Chart */ "./node_modules/echarts/lib/view/Chart.js");
/* harmony import */ var zrender_lib_graphic_Displayable__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! zrender/lib/graphic/Displayable */ "./node_modules/zrender/lib/graphic/Displayable.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _util_format__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../util/format */ "./node_modules/echarts/lib/util/format.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


















var Group = _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default;
var Rect = _util_graphic__WEBPACK_IMPORTED_MODULE_1__.default;
var DRAG_THRESHOLD = 3;
var PATH_LABEL_NOAMAL = 'label';
var PATH_UPPERLABEL_NORMAL = 'upperLabel';
var Z_BASE = 10; // Should bigger than every z.

var Z_BG = 1;
var Z_CONTENT = 2;
var getStateItemStyle = (0,_model_mixin_makeStyleMapper__WEBPACK_IMPORTED_MODULE_2__.default)([['fill', 'color'], // `borderColor` and `borderWidth` has been occupied,
// so use `stroke` to indicate the stroke of the rect.
['stroke', 'strokeColor'], ['lineWidth', 'strokeWidth'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'] // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
// So do not transfer decal directly.
]);

var getItemStyleNormal = function (model) {
  // Normal style props should include emphasis style props.
  var itemStyle = getStateItemStyle(model); // Clear styles set by emphasis.

  itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;
  return itemStyle;
};

var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_3__.makeInner)();

var TreemapView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__extends)(TreemapView, _super);

  function TreemapView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = TreemapView.type;
    _this._state = 'ready';
    _this._storage = createStorage();
    return _this;
  }
  /**
   * @override
   */


  TreemapView.prototype.render = function (seriesModel, ecModel, api, payload) {
    var models = ecModel.findComponents({
      mainType: 'series',
      subType: 'treemap',
      query: payload
    });

    if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.indexOf)(models, seriesModel) < 0) {
      return;
    }

    this.seriesModel = seriesModel;
    this.api = api;
    this.ecModel = ecModel;
    var types = ['treemapZoomToNode', 'treemapRootToNode'];
    var targetInfo = _helper_treeHelper__WEBPACK_IMPORTED_MODULE_6__.retrieveTargetInfo(payload, types, seriesModel);
    var payloadType = payload && payload.type;
    var layoutInfo = seriesModel.layoutInfo;
    var isInit = !this._oldTree;
    var thisStorage = this._storage; // Mark new root when action is treemapRootToNode.

    var reRoot = payloadType === 'treemapRootToNode' && targetInfo && thisStorage ? {
      rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
      direction: payload.direction
    } : null;

    var containerGroup = this._giveContainerGroup(layoutInfo);

    var renderResult = this._doRender(containerGroup, seriesModel, reRoot);

    !isInit && (!payloadType || payloadType === 'treemapZoomToNode' || payloadType === 'treemapRootToNode') ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();

    this._resetController(api);

    this._renderBreadcrumb(seriesModel, api, targetInfo);
  };

  TreemapView.prototype._giveContainerGroup = function (layoutInfo) {
    var containerGroup = this._containerGroup;

    if (!containerGroup) {
      // FIXME
      // 加一层containerGroup是为了clip，但是现在clip功能并没有实现。
      containerGroup = this._containerGroup = new Group();

      this._initEvents(containerGroup);

      this.group.add(containerGroup);
    }

    containerGroup.x = layoutInfo.x;
    containerGroup.y = layoutInfo.y;
    return containerGroup;
  };

  TreemapView.prototype._doRender = function (containerGroup, seriesModel, reRoot) {
    var thisTree = seriesModel.getData().tree;
    var oldTree = this._oldTree; // Clear last shape records.

    var lastsForAnimation = createStorage();
    var thisStorage = createStorage();
    var oldStorage = this._storage;
    var willInvisibleEls = [];

    function doRenderNode(thisNode, oldNode, parentGroup, depth) {
      return renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth);
    } // Notice: when thisTree and oldTree are the same tree (see list.cloneShallow),
    // the oldTree is actually losted, so we can not find all of the old graphic
    // elements from tree. So we use this stragegy: make element storage, move
    // from old storage to new storage, clear old storage.


    dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0); // Process all removing.

    var willDeleteEls = clearStorage(oldStorage);
    this._oldTree = thisTree;
    this._storage = thisStorage;
    return {
      lastsForAnimation: lastsForAnimation,
      willDeleteEls: willDeleteEls,
      renderFinally: renderFinally
    };

    function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {
      // When 'render' is triggered by action,
      // 'this' and 'old' may be the same tree,
      // we use rawIndex in that case.
      if (sameTree) {
        oldViewChildren = thisViewChildren;
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.each)(thisViewChildren, function (child, index) {
          !child.isRemoved() && processNode(index, index);
        });
      } // Diff hierarchically (diff only in each subtree, but not whole).
      // because, consistency of view is important.
      else {
          new _data_DataDiffer__WEBPACK_IMPORTED_MODULE_7__.default(oldViewChildren, thisViewChildren, getKey, getKey).add(processNode).update(processNode).remove((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.curry)(processNode, null)).execute();
        }

      function getKey(node) {
        // Identify by name or raw index.
        return node.getId();
      }

      function processNode(newIndex, oldIndex) {
        var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;
        var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;
        var group = doRenderNode(thisNode, oldNode, parentGroup, depth);
        group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);
      }
    }

    function clearStorage(storage) {
      var willDeleteEls = createStorage();
      storage && (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.each)(storage, function (store, storageName) {
        var delEls = willDeleteEls[storageName];
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.each)(store, function (el) {
          el && (delEls.push(el), inner(el).willDelete = true);
        });
      });
      return willDeleteEls;
    }

    function renderFinally() {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.each)(willDeleteEls, function (els) {
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.each)(els, function (el) {
          el.parent && el.parent.remove(el);
        });
      });
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.each)(willInvisibleEls, function (el) {
        el.invisible = true; // Setting invisible is for optimizing, so no need to set dirty,
        // just mark as invisible.

        el.dirty();
      });
    }
  };

  TreemapView.prototype._doAnimation = function (containerGroup, renderResult, seriesModel, reRoot) {
    if (!seriesModel.get('animation')) {
      return;
    }

    var durationOption = seriesModel.get('animationDurationUpdate');
    var easingOption = seriesModel.get('animationEasing'); // TODO: do not support function until necessary.

    var duration = ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.isFunction)(durationOption) ? 0 : durationOption) || 0;
    var easing = ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.isFunction)(easingOption) ? null : easingOption) || 'cubicOut';
    var animationWrap = _util_animation__WEBPACK_IMPORTED_MODULE_8__.createWrap(); // Make delete animations.

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.each)(renderResult.willDeleteEls, function (store, storageName) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.each)(store, function (el, rawIndex) {
        if (el.invisible) {
          return;
        }

        var parent = el.parent; // Always has parent, and parent is nodeGroup.

        var target;
        var innerStore = inner(parent);

        if (reRoot && reRoot.direction === 'drillDown') {
          target = parent === reRoot.rootNodeGroup // This is the content element of view root.
          // Only `content` will enter this branch, because
          // `background` and `nodeGroup` will not be deleted.
          ? {
            shape: {
              x: 0,
              y: 0,
              width: innerStore.nodeWidth,
              height: innerStore.nodeHeight
            },
            style: {
              opacity: 0
            }
          } // Others.
          : {
            style: {
              opacity: 0
            }
          };
        } else {
          var targetX = 0;
          var targetY = 0;

          if (!innerStore.willDelete) {
            // Let node animate to right-bottom corner, cooperating with fadeout,
            // which is appropriate for user understanding.
            // Divided by 2 for reRoot rolling up effect.
            targetX = innerStore.nodeWidth / 2;
            targetY = innerStore.nodeHeight / 2;
          }

          target = storageName === 'nodeGroup' ? {
            x: targetX,
            y: targetY,
            style: {
              opacity: 0
            }
          } : {
            shape: {
              x: targetX,
              y: targetY,
              width: 0,
              height: 0
            },
            style: {
              opacity: 0
            }
          };
        } // TODO: do not support delay until necessary.


        target && animationWrap.add(el, target, duration, 0, easing);
      });
    }); // Make other animations

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.each)(this._storage, function (store, storageName) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.each)(store, function (el, rawIndex) {
        var last = renderResult.lastsForAnimation[storageName][rawIndex];
        var target = {};

        if (!last) {
          return;
        }

        if (el instanceof _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default) {
          if (last.oldX != null) {
            target.x = el.x;
            target.y = el.y;
            el.x = last.oldX;
            el.y = last.oldY;
          }
        } else {
          if (last.oldShape) {
            target.shape = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.extend)({}, el.shape);
            el.setShape(last.oldShape);
          }

          if (last.fadein) {
            el.setStyle('opacity', 0);
            target.style = {
              opacity: 1
            };
          } // When animation is stopped for succedent animation starting,
          // el.style.opacity might not be 1
          else if (el.style.opacity !== 1) {
              target.style = {
                opacity: 1
              };
            }
        }

        animationWrap.add(el, target, duration, 0, easing);
      });
    }, this);
    this._state = 'animating';
    animationWrap.finished((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.bind)(function () {
      this._state = 'ready';
      renderResult.renderFinally();
    }, this)).start();
  };

  TreemapView.prototype._resetController = function (api) {
    var controller = this._controller; // Init controller.

    if (!controller) {
      controller = this._controller = new _component_helper_RoamController__WEBPACK_IMPORTED_MODULE_9__.default(api.getZr());
      controller.enable(this.seriesModel.get('roam'));
      controller.on('pan', (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.bind)(this._onPan, this));
      controller.on('zoom', (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.bind)(this._onZoom, this));
    }

    var rect = new zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_10__.default(0, 0, api.getWidth(), api.getHeight());
    controller.setPointerChecker(function (e, x, y) {
      return rect.contain(x, y);
    });
  };

  TreemapView.prototype._clearController = function () {
    var controller = this._controller;

    if (controller) {
      controller.dispose();
      controller = null;
    }
  };

  TreemapView.prototype._onPan = function (e) {
    if (this._state !== 'animating' && (Math.abs(e.dx) > DRAG_THRESHOLD || Math.abs(e.dy) > DRAG_THRESHOLD)) {
      // These param must not be cached.
      var root = this.seriesModel.getData().tree.root;

      if (!root) {
        return;
      }

      var rootLayout = root.getLayout();

      if (!rootLayout) {
        return;
      }

      this.api.dispatchAction({
        type: 'treemapMove',
        from: this.uid,
        seriesId: this.seriesModel.id,
        rootRect: {
          x: rootLayout.x + e.dx,
          y: rootLayout.y + e.dy,
          width: rootLayout.width,
          height: rootLayout.height
        }
      });
    }
  };

  TreemapView.prototype._onZoom = function (e) {
    var mouseX = e.originX;
    var mouseY = e.originY;

    if (this._state !== 'animating') {
      // These param must not be cached.
      var root = this.seriesModel.getData().tree.root;

      if (!root) {
        return;
      }

      var rootLayout = root.getLayout();

      if (!rootLayout) {
        return;
      }

      var rect = new zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_10__.default(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);
      var layoutInfo = this.seriesModel.layoutInfo; // Transform mouse coord from global to containerGroup.

      mouseX -= layoutInfo.x;
      mouseY -= layoutInfo.y; // Scale root bounding rect.

      var m = zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_11__.create();
      zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_11__.translate(m, m, [-mouseX, -mouseY]);
      zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_11__.scale(m, m, [e.scale, e.scale]);
      zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_11__.translate(m, m, [mouseX, mouseY]);
      rect.applyTransform(m);
      this.api.dispatchAction({
        type: 'treemapRender',
        from: this.uid,
        seriesId: this.seriesModel.id,
        rootRect: {
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        }
      });
    }
  };

  TreemapView.prototype._initEvents = function (containerGroup) {
    var _this = this;

    containerGroup.on('click', function (e) {
      if (_this._state !== 'ready') {
        return;
      }

      var nodeClick = _this.seriesModel.get('nodeClick', true);

      if (!nodeClick) {
        return;
      }

      var targetInfo = _this.findTarget(e.offsetX, e.offsetY);

      if (!targetInfo) {
        return;
      }

      var node = targetInfo.node;

      if (node.getLayout().isLeafRoot) {
        _this._rootToNode(targetInfo);
      } else {
        if (nodeClick === 'zoomToNode') {
          _this._zoomToNode(targetInfo);
        } else if (nodeClick === 'link') {
          var itemModel = node.hostTree.data.getItemModel(node.dataIndex);
          var link = itemModel.get('link', true);
          var linkTarget = itemModel.get('target', true) || 'blank';
          link && (0,_util_format__WEBPACK_IMPORTED_MODULE_12__.windowOpen)(link, linkTarget);
        }
      }
    }, this);
  };

  TreemapView.prototype._renderBreadcrumb = function (seriesModel, api, targetInfo) {
    var _this = this;

    if (!targetInfo) {
      targetInfo = seriesModel.get('leafDepth', true) != null ? {
        node: seriesModel.getViewRoot()
      } // FIXME
      // better way?
      // Find breadcrumb tail on center of containerGroup.
      : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);

      if (!targetInfo) {
        targetInfo = {
          node: seriesModel.getData().tree.root
        };
      }
    }

    (this._breadcrumb || (this._breadcrumb = new _Breadcrumb__WEBPACK_IMPORTED_MODULE_13__.default(this.group))).render(seriesModel, api, targetInfo.node, function (node) {
      if (_this._state !== 'animating') {
        _helper_treeHelper__WEBPACK_IMPORTED_MODULE_6__.aboveViewRoot(seriesModel.getViewRoot(), node) ? _this._rootToNode({
          node: node
        }) : _this._zoomToNode({
          node: node
        });
      }
    });
  };
  /**
   * @override
   */


  TreemapView.prototype.remove = function () {
    this._clearController();

    this._containerGroup && this._containerGroup.removeAll();
    this._storage = createStorage();
    this._state = 'ready';
    this._breadcrumb && this._breadcrumb.remove();
  };

  TreemapView.prototype.dispose = function () {
    this._clearController();
  };

  TreemapView.prototype._zoomToNode = function (targetInfo) {
    this.api.dispatchAction({
      type: 'treemapZoomToNode',
      from: this.uid,
      seriesId: this.seriesModel.id,
      targetNode: targetInfo.node
    });
  };

  TreemapView.prototype._rootToNode = function (targetInfo) {
    this.api.dispatchAction({
      type: 'treemapRootToNode',
      from: this.uid,
      seriesId: this.seriesModel.id,
      targetNode: targetInfo.node
    });
  };
  /**
   * @public
   * @param {number} x Global coord x.
   * @param {number} y Global coord y.
   * @return {Object} info If not found, return undefined;
   * @return {number} info.node Target node.
   * @return {number} info.offsetX x refer to target node.
   * @return {number} info.offsetY y refer to target node.
   */


  TreemapView.prototype.findTarget = function (x, y) {
    var targetInfo;
    var viewRoot = this.seriesModel.getViewRoot();
    viewRoot.eachNode({
      attr: 'viewChildren',
      order: 'preorder'
    }, function (node) {
      var bgEl = this._storage.background[node.getRawIndex()]; // If invisible, there might be no element.


      if (bgEl) {
        var point = bgEl.transformCoordToLocal(x, y);
        var shape = bgEl.shape; // For performance consideration, dont use 'getBoundingRect'.

        if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {
          targetInfo = {
            node: node,
            offsetX: point[0],
            offsetY: point[1]
          };
        } else {
          return false; // Suppress visit subtree.
        }
      }
    }, this);
    return targetInfo;
  };

  TreemapView.type = 'treemap';
  return TreemapView;
}(_view_Chart__WEBPACK_IMPORTED_MODULE_14__.default);
/**
 * @inner
 */


function createStorage() {
  return {
    nodeGroup: [],
    background: [],
    content: []
  };
}
/**
 * @inner
 * @return Return undefined means do not travel further.
 */


function renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {
  // Whether under viewRoot.
  if (!thisNode) {
    // Deleting nodes will be performed finally. This method just find
    // element from old storage, or create new element, set them to new
    // storage, and set styles.
    return;
  } // -------------------------------------------------------------------
  // Start of closure variables available in "Procedures in renderNode".


  var thisLayout = thisNode.getLayout();
  var data = seriesModel.getData();
  var nodeModel = thisNode.getModel(); // Only for enabling highlight/downplay. Clear firstly.
  // Because some node will not be rendered.

  data.setItemGraphicEl(thisNode.dataIndex, null);

  if (!thisLayout || !thisLayout.isInView) {
    return;
  }

  var thisWidth = thisLayout.width;
  var thisHeight = thisLayout.height;
  var borderWidth = thisLayout.borderWidth;
  var thisInvisible = thisLayout.invisible;
  var thisRawIndex = thisNode.getRawIndex();
  var oldRawIndex = oldNode && oldNode.getRawIndex();
  var thisViewChildren = thisNode.viewChildren;
  var upperHeight = thisLayout.upperHeight;
  var isParent = thisViewChildren && thisViewChildren.length;
  var itemStyleNormalModel = nodeModel.getModel('itemStyle');
  var itemStyleEmphasisModel = nodeModel.getModel(['emphasis', 'itemStyle']);
  var itemStyleBlurModel = nodeModel.getModel(['blur', 'itemStyle']);
  var itemStyleSelectModel = nodeModel.getModel(['select', 'itemStyle']);
  var borderRadius = itemStyleNormalModel.get('borderRadius') || 0; // End of closure ariables available in "Procedures in renderNode".
  // -----------------------------------------------------------------
  // Node group

  var group = giveGraphic('nodeGroup', Group);

  if (!group) {
    return;
  }

  parentGroup.add(group); // x,y are not set when el is above view root.

  group.x = thisLayout.x || 0;
  group.y = thisLayout.y || 0;
  group.markRedraw();
  inner(group).nodeWidth = thisWidth;
  inner(group).nodeHeight = thisHeight;

  if (thisLayout.isAboveViewRoot) {
    return group;
  } // Background


  var bg = giveGraphic('background', Rect, depth, Z_BG);
  bg && renderBackground(group, bg, isParent && thisLayout.upperLabelHeight);
  var focus = nodeModel.get(['emphasis', 'focus']);
  var blurScope = nodeModel.get(['emphasis', 'blurScope']);
  var focusDataIndices = focus === 'ancestor' ? thisNode.getAncestorsIndices() : focus === 'descendant' ? thisNode.getDescendantIndices() : null; // No children, render content.

  if (isParent) {
    // Because of the implementation about "traverse" in graphic hover style, we
    // can not set hover listener on the "group" of non-leaf node. Otherwise the
    // hover event from the descendents will be listenered.
    if ((0,_util_states__WEBPACK_IMPORTED_MODULE_15__.isHighDownDispatcher)(group)) {
      (0,_util_states__WEBPACK_IMPORTED_MODULE_15__.setAsHighDownDispatcher)(group, false);
    }

    if (bg) {
      (0,_util_states__WEBPACK_IMPORTED_MODULE_15__.setAsHighDownDispatcher)(bg, true); // Only for enabling highlight/downplay.

      data.setItemGraphicEl(thisNode.dataIndex, bg);
      (0,_util_states__WEBPACK_IMPORTED_MODULE_15__.enableHoverFocus)(bg, focusDataIndices || focus, blurScope);
    }
  } else {
    var content = giveGraphic('content', Rect, depth, Z_CONTENT);
    content && renderContent(group, content);

    if (bg && (0,_util_states__WEBPACK_IMPORTED_MODULE_15__.isHighDownDispatcher)(bg)) {
      (0,_util_states__WEBPACK_IMPORTED_MODULE_15__.setAsHighDownDispatcher)(bg, false);
    }

    (0,_util_states__WEBPACK_IMPORTED_MODULE_15__.setAsHighDownDispatcher)(group, true); // Only for enabling highlight/downplay.

    data.setItemGraphicEl(thisNode.dataIndex, group);
    (0,_util_states__WEBPACK_IMPORTED_MODULE_15__.enableHoverFocus)(group, focusDataIndices || focus, blurScope);
  }

  return group; // ----------------------------
  // | Procedures in renderNode |
  // ----------------------------

  function renderBackground(group, bg, useUpperLabel) {
    var ecData = (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_16__.getECData)(bg); // For tooltip.

    ecData.dataIndex = thisNode.dataIndex;
    ecData.seriesIndex = seriesModel.seriesIndex;
    bg.setShape({
      x: 0,
      y: 0,
      width: thisWidth,
      height: thisHeight,
      r: borderRadius
    });

    if (thisInvisible) {
      // If invisible, do not set visual, otherwise the element will
      // change immediately before animation. We think it is OK to
      // remain its origin color when moving out of the view window.
      processInvisible(bg);
    } else {
      bg.invisible = false;
      var style = thisNode.getVisual('style');
      var visualBorderColor = style.stroke;
      var normalStyle = getItemStyleNormal(itemStyleNormalModel);
      normalStyle.fill = visualBorderColor;
      var emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);
      emphasisStyle.fill = itemStyleEmphasisModel.get('borderColor');
      var blurStyle = getStateItemStyle(itemStyleBlurModel);
      blurStyle.fill = itemStyleBlurModel.get('borderColor');
      var selectStyle = getStateItemStyle(itemStyleSelectModel);
      selectStyle.fill = itemStyleSelectModel.get('borderColor');

      if (useUpperLabel) {
        var upperLabelWidth = thisWidth - 2 * borderWidth;
        prepareText(bg, visualBorderColor, upperLabelWidth, upperHeight, style.opacity, {
          x: borderWidth,
          y: 0,
          width: upperLabelWidth,
          height: upperHeight
        });
      } // For old bg.
      else {
          bg.removeTextContent();
        }

      bg.setStyle(normalStyle);
      bg.ensureState('emphasis').style = emphasisStyle;
      bg.ensureState('blur').style = blurStyle;
      bg.ensureState('select').style = selectStyle;
      (0,_util_states__WEBPACK_IMPORTED_MODULE_15__.setDefaultStateProxy)(bg);
    }

    group.add(bg);
  }

  function renderContent(group, content) {
    var ecData = (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_16__.getECData)(content); // For tooltip.

    ecData.dataIndex = thisNode.dataIndex;
    ecData.seriesIndex = seriesModel.seriesIndex;
    var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);
    var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);
    content.culling = true;
    content.setShape({
      x: borderWidth,
      y: borderWidth,
      width: contentWidth,
      height: contentHeight,
      r: borderRadius
    });

    if (thisInvisible) {
      // If invisible, do not set visual, otherwise the element will
      // change immediately before animation. We think it is OK to
      // remain its origin color when moving out of the view window.
      processInvisible(content);
    } else {
      content.invisible = false;
      var nodeStyle = thisNode.getVisual('style');
      var visualColor = nodeStyle.fill;
      var normalStyle = getItemStyleNormal(itemStyleNormalModel);
      normalStyle.fill = visualColor;
      normalStyle.decal = nodeStyle.decal;
      var emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);
      var blurStyle = getStateItemStyle(itemStyleBlurModel);
      var selectStyle = getStateItemStyle(itemStyleSelectModel);
      prepareText(content, visualColor, contentWidth, nodeStyle.opacity, contentHeight);
      content.setStyle(normalStyle);
      content.ensureState('emphasis').style = emphasisStyle;
      content.ensureState('blur').style = blurStyle;
      content.ensureState('select').style = selectStyle;
      (0,_util_states__WEBPACK_IMPORTED_MODULE_15__.setDefaultStateProxy)(content);
    }

    group.add(content);
  }

  function processInvisible(element) {
    // Delay invisible setting utill animation finished,
    // avoid element vanish suddenly before animation.
    !element.invisible && willInvisibleEls.push(element);
  }

  function prepareText(rectEl, visualColor, visualOpacity, width, height, upperLabelRect) {
    var normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);
    var text = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.retrieve)(seriesModel.getFormattedLabel(thisNode.dataIndex, 'normal', null, null, normalLabelModel.get('formatter')), (0,_util_model__WEBPACK_IMPORTED_MODULE_3__.convertOptionIdName)(nodeModel.get('name'), null));

    if (!upperLabelRect && thisLayout.isLeafRoot) {
      var iconChar = seriesModel.get('drillDownIcon', true);
      text = iconChar ? iconChar + ' ' + text : text;
    }

    var isShow = normalLabelModel.getShallow('show');
    (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_17__.setLabelStyle)(rectEl, (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_17__.getLabelStatesModels)(nodeModel, upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), {
      defaultText: isShow ? text : null,
      inheritColor: visualColor,
      defaultOpacity: visualOpacity,
      labelFetcher: seriesModel,
      labelDataIndex: thisNode.dataIndex
    });
    var textEl = rectEl.getTextContent();
    var textStyle = textEl.style;
    var textPadding = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.normalizeCssArray)(textStyle.padding || 0);

    if (upperLabelRect) {
      rectEl.setTextConfig({
        layoutRect: upperLabelRect
      });
      textEl.disableLabelLayout = true;
    }

    textEl.beforeUpdate = function () {
      var width = Math.max((upperLabelRect ? upperLabelRect.width : rectEl.shape.width) - textPadding[1] - textPadding[3], 0);
      var height = Math.max((upperLabelRect ? upperLabelRect.height : rectEl.shape.height) - textPadding[0] - textPadding[2], 0);

      if (textStyle.width !== width || textStyle.height !== height) {
        textEl.setStyle({
          width: width,
          height: height
        });
      }
    };

    textStyle.truncateMinChar = 2;
    textStyle.lineOverflow = 'truncate';
    addDrillDownIcon(textStyle, upperLabelRect, thisLayout);
    var textEmphasisState = textEl.getState('emphasis');
    addDrillDownIcon(textEmphasisState ? textEmphasisState.style : null, upperLabelRect, thisLayout);
  }

  function addDrillDownIcon(style, upperLabelRect, thisLayout) {
    var text = style ? style.text : null;

    if (!upperLabelRect && thisLayout.isLeafRoot && text != null) {
      var iconChar = seriesModel.get('drillDownIcon', true);
      style.text = iconChar ? iconChar + ' ' + text : text;
    }
  }

  function giveGraphic(storageName, Ctor, depth, z) {
    var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];
    var lasts = lastsForAnimation[storageName];

    if (element) {
      // Remove from oldStorage
      oldStorage[storageName][oldRawIndex] = null;
      prepareAnimationWhenHasOld(lasts, element);
    } // If invisible and no old element, do not create new element (for optimizing).
    else if (!thisInvisible) {
        element = new Ctor();

        if (element instanceof zrender_lib_graphic_Displayable__WEBPACK_IMPORTED_MODULE_18__.default) {
          element.z = calculateZ(depth, z);
        }

        prepareAnimationWhenNoOld(lasts, element);
      } // Set to thisStorage


    return thisStorage[storageName][thisRawIndex] = element;
  }

  function prepareAnimationWhenHasOld(lasts, element) {
    var lastCfg = lasts[thisRawIndex] = {};

    if (element instanceof Group) {
      lastCfg.oldX = element.x;
      lastCfg.oldY = element.y;
    } else {
      lastCfg.oldShape = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.extend)({}, element.shape);
    }
  } // If a element is new, we need to find the animation start point carefully,
  // otherwise it will looks strange when 'zoomToNode'.


  function prepareAnimationWhenNoOld(lasts, element) {
    var lastCfg = lasts[thisRawIndex] = {};
    var parentNode = thisNode.parentNode;
    var isGroup = element instanceof _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default;

    if (parentNode && (!reRoot || reRoot.direction === 'drillDown')) {
      var parentOldX = 0;
      var parentOldY = 0; // New nodes appear from right-bottom corner in 'zoomToNode' animation.
      // For convenience, get old bounding rect from background.

      var parentOldBg = lastsForAnimation.background[parentNode.getRawIndex()];

      if (!reRoot && parentOldBg && parentOldBg.oldShape) {
        parentOldX = parentOldBg.oldShape.width;
        parentOldY = parentOldBg.oldShape.height;
      } // When no parent old shape found, its parent is new too,
      // so we can just use {x:0, y:0}.


      if (isGroup) {
        lastCfg.oldX = 0;
        lastCfg.oldY = parentOldY;
      } else {
        lastCfg.oldShape = {
          x: parentOldX,
          y: parentOldY,
          width: 0,
          height: 0
        };
      }
    } // Fade in, user can be aware that these nodes are new.


    lastCfg.fadein = !isGroup;
  }
} // We can not set all backgroud with the same z, Because the behaviour of
// drill down and roll up differ background creation sequence from tree
// hierarchy sequence, which cause that lowser background element overlap
// upper ones. So we calculate z based on depth.
// Moreover, we try to shrink down z interval to [0, 1] to avoid that
// treemap with large z overlaps other components.


function calculateZ(depth, zInLevel) {
  var zb = depth * Z_BASE + zInLevel;
  return (zb - 1) / zb;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TreemapView);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/treemap/install.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/treemap/install.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _treemapAction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./treemapAction */ "./node_modules/echarts/lib/chart/treemap/treemapAction.js");
/* harmony import */ var _TreemapSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TreemapSeries */ "./node_modules/echarts/lib/chart/treemap/TreemapSeries.js");
/* harmony import */ var _TreemapView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TreemapView */ "./node_modules/echarts/lib/chart/treemap/TreemapView.js");
/* harmony import */ var _treemapVisual__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./treemapVisual */ "./node_modules/echarts/lib/chart/treemap/treemapVisual.js");
/* harmony import */ var _treemapLayout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./treemapLayout */ "./node_modules/echarts/lib/chart/treemap/treemapLayout.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





function install(registers) {
  registers.registerSeriesModel(_TreemapSeries__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerChartView(_TreemapView__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerVisual(_treemapVisual__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerLayout(_treemapLayout__WEBPACK_IMPORTED_MODULE_3__.default);
  (0,_treemapAction__WEBPACK_IMPORTED_MODULE_4__.installTreemapAction)(registers);
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/treemap/treemapAction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/treemap/treemapAction.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "installTreemapAction": () => (/* binding */ installTreemapAction)
/* harmony export */ });
/* harmony import */ var _helper_treeHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helper/treeHelper */ "./node_modules/echarts/lib/chart/helper/treeHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


var noop = function () {};

var actionTypes = ['treemapZoomToNode', 'treemapRender', 'treemapMove'];
function installTreemapAction(registers) {
  for (var i = 0; i < actionTypes.length; i++) {
    registers.registerAction({
      type: actionTypes[i],
      update: 'updateView'
    }, noop);
  }

  registers.registerAction({
    type: 'treemapRootToNode',
    update: 'updateView'
  }, function (payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'series',
      subType: 'treemap',
      query: payload
    }, handleRootToNode);

    function handleRootToNode(model, index) {
      var types = ['treemapZoomToNode', 'treemapRootToNode'];
      var targetInfo = _helper_treeHelper__WEBPACK_IMPORTED_MODULE_0__.retrieveTargetInfo(payload, types, model);

      if (targetInfo) {
        var originViewRoot = model.getViewRoot();

        if (originViewRoot) {
          payload.direction = _helper_treeHelper__WEBPACK_IMPORTED_MODULE_0__.aboveViewRoot(originViewRoot, targetInfo.node) ? 'rollUp' : 'drillDown';
        }

        model.resetViewRoot(targetInfo.node);
      }
    }
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/treemap/treemapLayout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/treemap/treemapLayout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/BoundingRect */ "./node_modules/zrender/lib/core/BoundingRect.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _helper_treeHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helper/treeHelper */ "./node_modules/echarts/lib/chart/helper/treeHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/*
* A third-party license is embeded for some of the code in this file:
* The treemap layout implementation was originally copied from
* "d3.js" with some modifications made for this project.
* (See more details in the comment of the method "squarify" below.)
* The use of the source code of this file is also subject to the terms
* and consitions of the license of "d3.js" (BSD-3Clause, see
* </licenses/LICENSE-d3>).
*/





var mathMax = Math.max;
var mathMin = Math.min;
var retrieveValue = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.retrieve;
var each = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each;
var PATH_BORDER_WIDTH = ['itemStyle', 'borderWidth'];
var PATH_GAP_WIDTH = ['itemStyle', 'gapWidth'];
var PATH_UPPER_LABEL_SHOW = ['upperLabel', 'show'];
var PATH_UPPER_LABEL_HEIGHT = ['upperLabel', 'height'];
;
/**
 * @public
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  seriesType: 'treemap',
  reset: function (seriesModel, ecModel, api, payload) {
    // Layout result in each node:
    // {x, y, width, height, area, borderWidth}
    var ecWidth = api.getWidth();
    var ecHeight = api.getHeight();
    var seriesOption = seriesModel.option;
    var layoutInfo = _util_layout__WEBPACK_IMPORTED_MODULE_1__.getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
    var size = seriesOption.size || []; // Compatible with ec2.

    var containerWidth = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.parsePercent)(retrieveValue(layoutInfo.width, size[0]), ecWidth);
    var containerHeight = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.parsePercent)(retrieveValue(layoutInfo.height, size[1]), ecHeight); // Fetch payload info.

    var payloadType = payload && payload.type;
    var types = ['treemapZoomToNode', 'treemapRootToNode'];
    var targetInfo = _helper_treeHelper__WEBPACK_IMPORTED_MODULE_3__.retrieveTargetInfo(payload, types, seriesModel);
    var rootRect = payloadType === 'treemapRender' || payloadType === 'treemapMove' ? payload.rootRect : null;
    var viewRoot = seriesModel.getViewRoot();
    var viewAbovePath = _helper_treeHelper__WEBPACK_IMPORTED_MODULE_3__.getPathToRoot(viewRoot);

    if (payloadType !== 'treemapMove') {
      var rootSize = payloadType === 'treemapZoomToNode' ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];
      var sort_1 = seriesOption.sort;

      if (sort_1 && sort_1 !== 'asc' && sort_1 !== 'desc') {
        // Default to be desc order.
        sort_1 = 'desc';
      }

      var options = {
        squareRatio: seriesOption.squareRatio,
        sort: sort_1,
        leafDepth: seriesOption.leafDepth
      }; // layout should be cleared because using updateView but not update.

      viewRoot.hostTree.clearLayouts(); // TODO
      // optimize: if out of view clip, do not layout.
      // But take care that if do not render node out of view clip,
      // how to calculate start po

      var viewRootLayout_1 = {
        x: 0,
        y: 0,
        width: rootSize[0],
        height: rootSize[1],
        area: rootSize[0] * rootSize[1]
      };
      viewRoot.setLayout(viewRootLayout_1);
      squarify(viewRoot, options, false, 0); // Supplement layout.

      viewRootLayout_1 = viewRoot.getLayout();
      each(viewAbovePath, function (node, index) {
        var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();
        node.setLayout(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.extend({
          dataExtent: [childValue, childValue],
          borderWidth: 0,
          upperHeight: 0
        }, viewRootLayout_1));
      });
    }

    var treeRoot = seriesModel.getData().tree.root;
    treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);
    seriesModel.setLayoutInfo(layoutInfo); // FIXME
    // 现在没有clip功能，暂时取ec高宽。

    prunning(treeRoot, // Transform to base element coordinate system.
    new zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_4__.default(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), viewAbovePath, viewRoot, 0);
  }
});
/**
 * Layout treemap with squarify algorithm.
 * The original presentation of this algorithm
 * was made by Mark Bruls, Kees Huizing, and Jarke J. van Wijk
 * <https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf>.
 * The implementation of this algorithm was originally copied from "d3.js"
 * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/layout/treemap.js>
 * with some modifications made for this program.
 * See the license statement at the head of this file.
 *
 * @protected
 * @param {module:echarts/data/Tree~TreeNode} node
 * @param {Object} options
 * @param {string} options.sort 'asc' or 'desc'
 * @param {number} options.squareRatio
 * @param {boolean} hideChildren
 * @param {number} depth
 */

function squarify(node, options, hideChildren, depth) {
  var width;
  var height;

  if (node.isRemoved()) {
    return;
  }

  var thisLayout = node.getLayout();
  width = thisLayout.width;
  height = thisLayout.height; // Considering border and gap

  var nodeModel = node.getModel();
  var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);
  var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;
  var upperLabelHeight = getUpperLabelHeight(nodeModel);
  var upperHeight = Math.max(borderWidth, upperLabelHeight);
  var layoutOffset = borderWidth - halfGapWidth;
  var layoutOffsetUpper = upperHeight - halfGapWidth;
  node.setLayout({
    borderWidth: borderWidth,
    upperHeight: upperHeight,
    upperLabelHeight: upperLabelHeight
  }, true);
  width = mathMax(width - 2 * layoutOffset, 0);
  height = mathMax(height - layoutOffset - layoutOffsetUpper, 0);
  var totalArea = width * height;
  var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);

  if (!viewChildren.length) {
    return;
  }

  var rect = {
    x: layoutOffset,
    y: layoutOffsetUpper,
    width: width,
    height: height
  };
  var rowFixedLength = mathMin(width, height);
  var best = Infinity; // the best row score so far

  var row = [];
  row.area = 0;

  for (var i = 0, len = viewChildren.length; i < len;) {
    var child = viewChildren[i];
    row.push(child);
    row.area += child.getLayout().area;
    var score = worst(row, rowFixedLength, options.squareRatio); // continue with this orientation

    if (score <= best) {
      i++;
      best = score;
    } // abort, and try a different orientation
    else {
        row.area -= row.pop().getLayout().area;
        position(row, rowFixedLength, rect, halfGapWidth, false);
        rowFixedLength = mathMin(rect.width, rect.height);
        row.length = row.area = 0;
        best = Infinity;
      }
  }

  if (row.length) {
    position(row, rowFixedLength, rect, halfGapWidth, true);
  }

  if (!hideChildren) {
    var childrenVisibleMin = nodeModel.get('childrenVisibleMin');

    if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {
      hideChildren = true;
    }
  }

  for (var i = 0, len = viewChildren.length; i < len; i++) {
    squarify(viewChildren[i], options, hideChildren, depth + 1);
  }
}
/**
 * Set area to each child, and calculate data extent for visual coding.
 */


function initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {
  var viewChildren = node.children || [];
  var orderBy = options.sort;
  orderBy !== 'asc' && orderBy !== 'desc' && (orderBy = null);
  var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth; // leafDepth has higher priority.

  if (hideChildren && !overLeafDepth) {
    return node.viewChildren = [];
  } // Sort children, order by desc.


  viewChildren = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.filter(viewChildren, function (child) {
    return !child.isRemoved();
  });
  sort(viewChildren, orderBy);
  var info = statistic(nodeModel, viewChildren, orderBy);

  if (info.sum === 0) {
    return node.viewChildren = [];
  }

  info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);

  if (info.sum === 0) {
    return node.viewChildren = [];
  } // Set area to each child.


  for (var i = 0, len = viewChildren.length; i < len; i++) {
    var area = viewChildren[i].getValue() / info.sum * totalArea; // Do not use setLayout({...}, true), because it is needed to clear last layout.

    viewChildren[i].setLayout({
      area: area
    });
  }

  if (overLeafDepth) {
    viewChildren.length && node.setLayout({
      isLeafRoot: true
    }, true);
    viewChildren.length = 0;
  }

  node.viewChildren = viewChildren;
  node.setLayout({
    dataExtent: info.dataExtent
  }, true);
  return viewChildren;
}
/**
 * Consider 'visibleMin'. Modify viewChildren and get new sum.
 */


function filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {
  // visibleMin is not supported yet when no option.sort.
  if (!orderBy) {
    return sum;
  }

  var visibleMin = nodeModel.get('visibleMin');
  var len = orderedChildren.length;
  var deletePoint = len; // Always travel from little value to big value.

  for (var i = len - 1; i >= 0; i--) {
    var value = orderedChildren[orderBy === 'asc' ? len - i - 1 : i].getValue();

    if (value / sum * totalArea < visibleMin) {
      deletePoint = i;
      sum -= value;
    }
  }

  orderBy === 'asc' ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint);
  return sum;
}
/**
 * Sort
 */


function sort(viewChildren, orderBy) {
  if (orderBy) {
    viewChildren.sort(function (a, b) {
      var diff = orderBy === 'asc' ? a.getValue() - b.getValue() : b.getValue() - a.getValue();
      return diff === 0 ? orderBy === 'asc' ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;
    });
  }

  return viewChildren;
}
/**
 * Statistic
 */


function statistic(nodeModel, children, orderBy) {
  // Calculate sum.
  var sum = 0;

  for (var i = 0, len = children.length; i < len; i++) {
    sum += children[i].getValue();
  } // Statistic data extent for latter visual coding.
  // Notice: data extent should be calculate based on raw children
  // but not filtered view children, otherwise visual mapping will not
  // be stable when zoom (where children is filtered by visibleMin).


  var dimension = nodeModel.get('visualDimension');
  var dataExtent; // The same as area dimension.

  if (!children || !children.length) {
    dataExtent = [NaN, NaN];
  } else if (dimension === 'value' && orderBy) {
    dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];
    orderBy === 'asc' && dataExtent.reverse();
  } // Other dimension.
  else {
      dataExtent = [Infinity, -Infinity];
      each(children, function (child) {
        var value = child.getValue(dimension);
        value < dataExtent[0] && (dataExtent[0] = value);
        value > dataExtent[1] && (dataExtent[1] = value);
      });
    }

  return {
    sum: sum,
    dataExtent: dataExtent
  };
}
/**
 * Computes the score for the specified row,
 * as the worst aspect ratio.
 */


function worst(row, rowFixedLength, ratio) {
  var areaMax = 0;
  var areaMin = Infinity;

  for (var i = 0, area = void 0, len = row.length; i < len; i++) {
    area = row[i].getLayout().area;

    if (area) {
      area < areaMin && (areaMin = area);
      area > areaMax && (areaMax = area);
    }
  }

  var squareArea = row.area * row.area;
  var f = rowFixedLength * rowFixedLength * ratio;
  return squareArea ? mathMax(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;
}
/**
 * Positions the specified row of nodes. Modifies `rect`.
 */


function position(row, rowFixedLength, rect, halfGapWidth, flush) {
  // When rowFixedLength === rect.width,
  // it is horizontal subdivision,
  // rowFixedLength is the width of the subdivision,
  // rowOtherLength is the height of the subdivision,
  // and nodes will be positioned from left to right.
  // wh[idx0WhenH] means: when horizontal,
  //      wh[idx0WhenH] => wh[0] => 'width'.
  //      xy[idx1WhenH] => xy[1] => 'y'.
  var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;
  var idx1WhenH = 1 - idx0WhenH;
  var xy = ['x', 'y'];
  var wh = ['width', 'height'];
  var last = rect[xy[idx0WhenH]];
  var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;

  if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {
    rowOtherLength = rect[wh[idx1WhenH]]; // over+underflow
  }

  for (var i = 0, rowLen = row.length; i < rowLen; i++) {
    var node = row[i];
    var nodeLayout = {};
    var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;
    var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax(rowOtherLength - 2 * halfGapWidth, 0); // We use Math.max/min to avoid negative width/height when considering gap width.

    var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;
    var modWH = i === rowLen - 1 || remain < step ? remain : step;
    var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax(modWH - 2 * halfGapWidth, 0);
    nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin(halfGapWidth, wh1 / 2);
    nodeLayout[xy[idx0WhenH]] = last + mathMin(halfGapWidth, wh0 / 2);
    last += modWH;
    node.setLayout(nodeLayout, true);
  }

  rect[xy[idx1WhenH]] += rowOtherLength;
  rect[wh[idx1WhenH]] -= rowOtherLength;
} // Return [containerWidth, containerHeight] as default.


function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
  // If targetInfo.node exists, we zoom to the node,
  // so estimate whold width and heigth by target node.
  var currNode = (targetInfo || {}).node;
  var defaultSize = [containerWidth, containerHeight];

  if (!currNode || currNode === viewRoot) {
    return defaultSize;
  }

  var parent;
  var viewArea = containerWidth * containerHeight;
  var area = viewArea * seriesModel.option.zoomToNodeRatio;

  while (parent = currNode.parentNode) {
    // jshint ignore:line
    var sum = 0;
    var siblings = parent.children;

    for (var i = 0, len = siblings.length; i < len; i++) {
      sum += siblings[i].getValue();
    }

    var currNodeValue = currNode.getValue();

    if (currNodeValue === 0) {
      return defaultSize;
    }

    area *= sum / currNodeValue; // Considering border, suppose aspect ratio is 1.

    var parentModel = parent.getModel();
    var borderWidth = parentModel.get(PATH_BORDER_WIDTH);
    var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel));
    area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);
    area > _util_number__WEBPACK_IMPORTED_MODULE_2__.MAX_SAFE_INTEGER && (area = _util_number__WEBPACK_IMPORTED_MODULE_2__.MAX_SAFE_INTEGER);
    currNode = parent;
  }

  area < viewArea && (area = viewArea);
  var scale = Math.pow(area / viewArea, 0.5);
  return [containerWidth * scale, containerHeight * scale];
} // Root postion base on coord of containerGroup


function calculateRootPosition(layoutInfo, rootRect, targetInfo) {
  if (rootRect) {
    return {
      x: rootRect.x,
      y: rootRect.y
    };
  }

  var defaultPosition = {
    x: 0,
    y: 0
  };

  if (!targetInfo) {
    return defaultPosition;
  } // If targetInfo is fetched by 'retrieveTargetInfo',
  // old tree and new tree are the same tree,
  // so the node still exists and we can visit it.


  var targetNode = targetInfo.node;
  var layout = targetNode.getLayout();

  if (!layout) {
    return defaultPosition;
  } // Transform coord from local to container.


  var targetCenter = [layout.width / 2, layout.height / 2];
  var node = targetNode;

  while (node) {
    var nodeLayout = node.getLayout();
    targetCenter[0] += nodeLayout.x;
    targetCenter[1] += nodeLayout.y;
    node = node.parentNode;
  }

  return {
    x: layoutInfo.width / 2 - targetCenter[0],
    y: layoutInfo.height / 2 - targetCenter[1]
  };
} // Mark nodes visible for prunning when visual coding and rendering.
// Prunning depends on layout and root position, so we have to do it after layout.


function prunning(node, clipRect, viewAbovePath, viewRoot, depth) {
  var nodeLayout = node.getLayout();
  var nodeInViewAbovePath = viewAbovePath[depth];
  var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;

  if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {
    return;
  }

  node.setLayout({
    // isInView means: viewRoot sub tree + viewAbovePath
    isInView: true,
    // invisible only means: outside view clip so that the node can not
    // see but still layout for animation preparation but not render.
    invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),
    isAboveViewRoot: isAboveViewRoot
  }, true); // Transform to child coordinate.

  var childClipRect = new zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_4__.default(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);
  each(node.viewChildren || [], function (child) {
    prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);
  });
}

function getUpperLabelHeight(model) {
  return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/treemap/treemapVisual.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/treemap/treemapVisual.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../visual/VisualMapping */ "./node_modules/echarts/lib/visual/VisualMapping.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/tool/color */ "./node_modules/zrender/lib/tool/color.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var ITEM_STYLE_NORMAL = 'itemStyle';
var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  seriesType: 'treemap',
  reset: function (seriesModel) {
    var tree = seriesModel.getData().tree;
    var root = tree.root;

    if (root.isRemoved()) {
      return;
    }

    travelTree(root, // Visual should calculate from tree root but not view root.
    {}, seriesModel.getViewRoot().getAncestors(), seriesModel);
  }
});

function travelTree(node, designatedVisual, viewRootAncestors, seriesModel) {
  var nodeModel = node.getModel();
  var nodeLayout = node.getLayout();
  var data = node.hostTree.data; // Optimize

  if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {
    return;
  }

  var nodeItemStyleModel = nodeModel.getModel(ITEM_STYLE_NORMAL);
  var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel);
  var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, 'style'); // calculate border color

  var borderColor = nodeItemStyleModel.get('borderColor');
  var borderColorSaturation = nodeItemStyleModel.get('borderColorSaturation');
  var thisNodeColor;

  if (borderColorSaturation != null) {
    // For performance, do not always execute 'calculateColor'.
    thisNodeColor = calculateColor(visuals);
    borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);
  }

  existsStyle.stroke = borderColor;
  var viewChildren = node.viewChildren;

  if (!viewChildren || !viewChildren.length) {
    thisNodeColor = calculateColor(visuals); // Apply visual to this node.

    existsStyle.fill = thisNodeColor;
  } else {
    var mapping_1 = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren); // Designate visual to children.

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(viewChildren, function (child, index) {
      // If higher than viewRoot, only ancestors of viewRoot is needed to visit.
      if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {
        var childVisual = mapVisual(nodeModel, visuals, child, index, mapping_1, seriesModel);
        travelTree(child, childVisual, viewRootAncestors, seriesModel);
      }
    });
  }
}

function buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel) {
  var visuals = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, designatedVisual);
  var designatedVisualItemStyle = seriesModel.designatedVisualItemStyle;
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(['color', 'colorAlpha', 'colorSaturation'], function (visualName) {
    // Priority: thisNode > thisLevel > parentNodeDesignated > seriesModel
    designatedVisualItemStyle[visualName] = designatedVisual[visualName];
    var val = nodeItemStyleModel.get(visualName);
    designatedVisualItemStyle[visualName] = null;
    val != null && (visuals[visualName] = val);
  });
  return visuals;
}

function calculateColor(visuals) {
  var color = getValueVisualDefine(visuals, 'color');

  if (color) {
    var colorAlpha = getValueVisualDefine(visuals, 'colorAlpha');
    var colorSaturation = getValueVisualDefine(visuals, 'colorSaturation');

    if (colorSaturation) {
      color = (0,zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_2__.modifyHSL)(color, null, null, colorSaturation);
    }

    if (colorAlpha) {
      color = (0,zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_2__.modifyAlpha)(color, colorAlpha);
    }

    return color;
  }
}

function calculateBorderColor(borderColorSaturation, thisNodeColor) {
  return thisNodeColor != null // Can only be string
  ? (0,zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_2__.modifyHSL)(thisNodeColor, null, null, borderColorSaturation) : null;
}

function getValueVisualDefine(visuals, name) {
  var value = visuals[name];

  if (value != null && value !== 'none') {
    return value;
  }
}

function buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {
  if (!viewChildren || !viewChildren.length) {
    return;
  }

  var rangeVisual = getRangeVisual(nodeModel, 'color') || visuals.color != null && visuals.color !== 'none' && (getRangeVisual(nodeModel, 'colorAlpha') || getRangeVisual(nodeModel, 'colorSaturation'));

  if (!rangeVisual) {
    return;
  }

  var visualMin = nodeModel.get('visualMin');
  var visualMax = nodeModel.get('visualMax');
  var dataExtent = nodeLayout.dataExtent.slice();
  visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);
  visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);
  var colorMappingBy = nodeModel.get('colorMappingBy');
  var opt = {
    type: rangeVisual.name,
    dataExtent: dataExtent,
    visual: rangeVisual.range
  };

  if (opt.type === 'color' && (colorMappingBy === 'index' || colorMappingBy === 'id')) {
    opt.mappingMethod = 'category';
    opt.loop = true; // categories is ordinal, so do not set opt.categories.
  } else {
    opt.mappingMethod = 'linear';
  }

  var mapping = new _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_3__.default(opt);
  inner(mapping).drColorMappingBy = colorMappingBy;
  return mapping;
} // Notice: If we dont have the attribute 'colorRange', but only use
// attribute 'color' to represent both concepts of 'colorRange' and 'color',
// (It means 'colorRange' when 'color' is Array, means 'color' when not array),
// this problem will be encountered:
// If a level-1 node dont have children, and its siblings has children,
// and colorRange is set on level-1, then the node can not be colored.
// So we separate 'colorRange' and 'color' to different attributes.


function getRangeVisual(nodeModel, name) {
  // 'colorRange', 'colorARange', 'colorSRange'.
  // If not exsits on this node, fetch from levels and series.
  var range = nodeModel.get(name);
  return (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(range) && range.length ? {
    name: name,
    range: range
  } : null;
}

function mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {
  var childVisuals = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, visuals);

  if (mapping) {
    // Only support color, colorAlpha, colorSaturation.
    var mappingType = mapping.type;
    var colorMappingBy = mappingType === 'color' && inner(mapping).drColorMappingBy;
    var value = colorMappingBy === 'index' ? index : colorMappingBy === 'id' ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get('visualDimension'));
    childVisuals[mappingType] = mapping.mapValueToVisual(value);
  }

  return childVisuals;
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/calendar/prepareCustom.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/calendar/prepareCustom.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ calendarPrepareCustom)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function calendarPrepareCustom(coordSys) {
  var rect = coordSys.getRect();
  var rangeInfo = coordSys.getRangeInfo();
  return {
    coordSys: {
      type: 'calendar',
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height,
      cellWidth: coordSys.getCellWidth(),
      cellHeight: coordSys.getCellHeight(),
      rangeInfo: {
        start: rangeInfo.start,
        end: rangeInfo.end,
        weeks: rangeInfo.weeks,
        dayCount: rangeInfo.allDay
      }
    },
    api: {
      coord: function (data, clamp) {
        return coordSys.dataToPoint(data, clamp);
      }
    }
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/prepareCustom.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/cartesian/prepareCustom.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ cartesianPrepareCustom)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function dataToCoordSize(dataSize, dataItem) {
  // dataItem is necessary in log axis.
  dataItem = dataItem || [0, 0];
  return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map(['x', 'y'], function (dim, dimIdx) {
    var axis = this.getAxis(dim);
    var val = dataItem[dimIdx];
    var halfSize = dataSize[dimIdx] / 2;
    return axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
  }, this);
}

function cartesianPrepareCustom(coordSys) {
  var rect = coordSys.master.getRect();
  return {
    coordSys: {
      // The name exposed to user is always 'cartesian2d' but not 'grid'.
      type: 'cartesian2d',
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    api: {
      coord: function (data) {
        // do not provide "out" param
        return coordSys.dataToPoint(data);
      },
      size: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.bind(dataToCoordSize, coordSys)
    }
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/geo/prepareCustom.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/geo/prepareCustom.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ geoPrepareCustom)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function dataToCoordSize(dataSize, dataItem) {
  dataItem = dataItem || [0, 0];
  return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map([0, 1], function (dimIdx) {
    var val = dataItem[dimIdx];
    var halfSize = dataSize[dimIdx] / 2;
    var p1 = [];
    var p2 = [];
    p1[dimIdx] = val - halfSize;
    p2[dimIdx] = val + halfSize;
    p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];
    return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);
  }, this);
}

function geoPrepareCustom(coordSys) {
  var rect = coordSys.getBoundingRect();
  return {
    coordSys: {
      type: 'geo',
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height,
      zoom: coordSys.getZoom()
    },
    api: {
      coord: function (data) {
        // do not provide "out" and noRoam param,
        // Compatible with this usage:
        // echarts.util.map(item.points, api.coord)
        return coordSys.dataToPoint(data);
      },
      size: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.bind(dataToCoordSize, coordSys)
    }
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/polar/prepareCustom.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/polar/prepareCustom.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ polarPrepareCustom)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
 // import AngleAxis from './AngleAxis';

function dataToCoordSize(dataSize, dataItem) {
  // dataItem is necessary in log axis.
  dataItem = dataItem || [0, 0];
  return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map(['Radius', 'Angle'], function (dim, dimIdx) {
    var getterName = 'get' + dim + 'Axis'; // TODO: TYPE Check Angle Axis

    var axis = this[getterName]();
    var val = dataItem[dimIdx];
    var halfSize = dataSize[dimIdx] / 2;
    var result = axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));

    if (dim === 'Angle') {
      result = result * Math.PI / 180;
    }

    return result;
  }, this);
}

function polarPrepareCustom(coordSys) {
  var radiusAxis = coordSys.getRadiusAxis();
  var angleAxis = coordSys.getAngleAxis();
  var radius = radiusAxis.getExtent();
  radius[0] > radius[1] && radius.reverse();
  return {
    coordSys: {
      type: 'polar',
      cx: coordSys.cx,
      cy: coordSys.cy,
      r: radius[1],
      r0: radius[0]
    },
    api: {
      coord: function (data) {
        var radius = radiusAxis.dataToRadius(data[0]);
        var angle = angleAxis.dataToAngle(data[1]);
        var coord = coordSys.coordToPoint([radius, angle]);
        coord.push(radius, angle * Math.PI / 180);
        return coord;
      },
      size: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.bind(dataToCoordSize, coordSys)
    }
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/single/prepareCustom.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/single/prepareCustom.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ singlePrepareCustom)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function dataToCoordSize(dataSize, dataItem) {
  // dataItem is necessary in log axis.
  var axis = this.getAxis();
  var val = dataItem instanceof Array ? dataItem[0] : dataItem;
  var halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;
  return axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
}

function singlePrepareCustom(coordSys) {
  var rect = coordSys.getRect();
  return {
    coordSys: {
      type: 'singleAxis',
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    api: {
      coord: function (val) {
        // do not provide "out" param
        return coordSys.dataToPoint(val);
      },
      size: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.bind)(dataToCoordSize, coordSys)
    }
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/data/Graph.js":
/*!************************************************!*\
  !*** ./node_modules/echarts/lib/data/Graph.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "GraphNode": () => (/* binding */ GraphNode),
/* harmony export */   "GraphEdge": () => (/* binding */ GraphEdge)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
 // id may be function name of Object, add a prefix to avoid this problem.

function generateNodeKey(id) {
  return '_EC_' + id;
}

var Graph =
/** @class */
function () {
  function Graph(directed) {
    this.type = 'graph';
    this.nodes = [];
    this.edges = [];
    this._nodesMap = {};
    /**
     * @type {Object.<string, module:echarts/data/Graph.Edge>}
     * @private
     */

    this._edgesMap = {};
    this._directed = directed || false;
  }
  /**
   * If is directed graph
   */


  Graph.prototype.isDirected = function () {
    return this._directed;
  };

  ;
  /**
   * Add a new node
   */

  Graph.prototype.addNode = function (id, dataIndex) {
    id = id == null ? '' + dataIndex : '' + id;
    var nodesMap = this._nodesMap;

    if (nodesMap[generateNodeKey(id)]) {
      if (true) {
        console.error('Graph nodes have duplicate name or id');
      }

      return;
    }

    var node = new GraphNode(id, dataIndex);
    node.hostGraph = this;
    this.nodes.push(node);
    nodesMap[generateNodeKey(id)] = node;
    return node;
  };

  ;
  /**
   * Get node by data index
   */

  Graph.prototype.getNodeByIndex = function (dataIndex) {
    var rawIdx = this.data.getRawIndex(dataIndex);
    return this.nodes[rawIdx];
  };

  ;
  /**
   * Get node by id
   */

  Graph.prototype.getNodeById = function (id) {
    return this._nodesMap[generateNodeKey(id)];
  };

  ;
  /**
   * Add a new edge
   */

  Graph.prototype.addEdge = function (n1, n2, dataIndex) {
    var nodesMap = this._nodesMap;
    var edgesMap = this._edgesMap; // PNEDING

    if (typeof n1 === 'number') {
      n1 = this.nodes[n1];
    }

    if (typeof n2 === 'number') {
      n2 = this.nodes[n2];
    }

    if (!(n1 instanceof GraphNode)) {
      n1 = nodesMap[generateNodeKey(n1)];
    }

    if (!(n2 instanceof GraphNode)) {
      n2 = nodesMap[generateNodeKey(n2)];
    }

    if (!n1 || !n2) {
      return;
    }

    var key = n1.id + '-' + n2.id;
    var edge = new GraphEdge(n1, n2, dataIndex);
    edge.hostGraph = this;

    if (this._directed) {
      n1.outEdges.push(edge);
      n2.inEdges.push(edge);
    }

    n1.edges.push(edge);

    if (n1 !== n2) {
      n2.edges.push(edge);
    }

    this.edges.push(edge);
    edgesMap[key] = edge;
    return edge;
  };

  ;
  /**
   * Get edge by data index
   */

  Graph.prototype.getEdgeByIndex = function (dataIndex) {
    var rawIdx = this.edgeData.getRawIndex(dataIndex);
    return this.edges[rawIdx];
  };

  ;
  /**
   * Get edge by two linked nodes
   */

  Graph.prototype.getEdge = function (n1, n2) {
    if (n1 instanceof GraphNode) {
      n1 = n1.id;
    }

    if (n2 instanceof GraphNode) {
      n2 = n2.id;
    }

    var edgesMap = this._edgesMap;

    if (this._directed) {
      return edgesMap[n1 + '-' + n2];
    } else {
      return edgesMap[n1 + '-' + n2] || edgesMap[n2 + '-' + n1];
    }
  };

  ;
  /**
   * Iterate all nodes
   */

  Graph.prototype.eachNode = function (cb, context) {
    var nodes = this.nodes;
    var len = nodes.length;

    for (var i = 0; i < len; i++) {
      if (nodes[i].dataIndex >= 0) {
        cb.call(context, nodes[i], i);
      }
    }
  };

  ;
  /**
   * Iterate all edges
   */

  Graph.prototype.eachEdge = function (cb, context) {
    var edges = this.edges;
    var len = edges.length;

    for (var i = 0; i < len; i++) {
      if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {
        cb.call(context, edges[i], i);
      }
    }
  };

  ;
  /**
   * Breadth first traverse
   * Return true to stop traversing
   */

  Graph.prototype.breadthFirstTraverse = function (cb, startNode, direction, context) {
    if (!(startNode instanceof GraphNode)) {
      startNode = this._nodesMap[generateNodeKey(startNode)];
    }

    if (!startNode) {
      return;
    }

    var edgeType = direction === 'out' ? 'outEdges' : direction === 'in' ? 'inEdges' : 'edges';

    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].__visited = false;
    }

    if (cb.call(context, startNode, null)) {
      return;
    }

    var queue = [startNode];

    while (queue.length) {
      var currentNode = queue.shift();
      var edges = currentNode[edgeType];

      for (var i = 0; i < edges.length; i++) {
        var e = edges[i];
        var otherNode = e.node1 === currentNode ? e.node2 : e.node1;

        if (!otherNode.__visited) {
          if (cb.call(context, otherNode, currentNode)) {
            // Stop traversing
            return;
          }

          queue.push(otherNode);
          otherNode.__visited = true;
        }
      }
    }
  };

  ; // TODO
  // depthFirstTraverse(
  //     cb, startNode, direction, context
  // ) {
  // };
  // Filter update

  Graph.prototype.update = function () {
    var data = this.data;
    var edgeData = this.edgeData;
    var nodes = this.nodes;
    var edges = this.edges;

    for (var i = 0, len = nodes.length; i < len; i++) {
      nodes[i].dataIndex = -1;
    }

    for (var i = 0, len = data.count(); i < len; i++) {
      nodes[data.getRawIndex(i)].dataIndex = i;
    }

    edgeData.filterSelf(function (idx) {
      var edge = edges[edgeData.getRawIndex(idx)];
      return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;
    }); // Update edge

    for (var i = 0, len = edges.length; i < len; i++) {
      edges[i].dataIndex = -1;
    }

    for (var i = 0, len = edgeData.count(); i < len; i++) {
      edges[edgeData.getRawIndex(i)].dataIndex = i;
    }
  };

  ;
  /**
   * @return {module:echarts/data/Graph}
   */

  Graph.prototype.clone = function () {
    var graph = new Graph(this._directed);
    var nodes = this.nodes;
    var edges = this.edges;

    for (var i = 0; i < nodes.length; i++) {
      graph.addNode(nodes[i].id, nodes[i].dataIndex);
    }

    for (var i = 0; i < edges.length; i++) {
      var e = edges[i];
      graph.addEdge(e.node1.id, e.node2.id, e.dataIndex);
    }

    return graph;
  };

  ;
  return Graph;
}();

var GraphNode =
/** @class */
function () {
  function GraphNode(id, dataIndex) {
    this.inEdges = [];
    this.outEdges = [];
    this.edges = [];
    this.dataIndex = -1;
    this.id = id == null ? '' : id;
    this.dataIndex = dataIndex == null ? -1 : dataIndex;
  }
  /**
   * @return {number}
   */


  GraphNode.prototype.degree = function () {
    return this.edges.length;
  };
  /**
   * @return {number}
   */


  GraphNode.prototype.inDegree = function () {
    return this.inEdges.length;
  };
  /**
  * @return {number}
  */


  GraphNode.prototype.outDegree = function () {
    return this.outEdges.length;
  };

  GraphNode.prototype.getModel = function (path) {
    if (this.dataIndex < 0) {
      return;
    }

    var graph = this.hostGraph;
    var itemModel = graph.data.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  };

  GraphNode.prototype.getAdjacentDataIndices = function () {
    var dataIndices = {
      edge: [],
      node: []
    };

    for (var i = 0; i < this.edges.length; i++) {
      var adjacentEdge = this.edges[i];

      if (adjacentEdge.dataIndex < 0) {
        continue;
      }

      dataIndices.edge.push(adjacentEdge.dataIndex);
      dataIndices.node.push(adjacentEdge.node1.dataIndex, adjacentEdge.node2.dataIndex);
    }

    return dataIndices;
  };

  return GraphNode;
}();

var GraphEdge =
/** @class */
function () {
  function GraphEdge(n1, n2, dataIndex) {
    this.dataIndex = -1;
    this.node1 = n1;
    this.node2 = n2;
    this.dataIndex = dataIndex == null ? -1 : dataIndex;
  }

  GraphEdge.prototype.getModel = function (path) {
    if (this.dataIndex < 0) {
      return;
    }

    var graph = this.hostGraph;
    var itemModel = graph.edgeData.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  };

  GraphEdge.prototype.getAdjacentDataIndices = function () {
    return {
      edge: [this.dataIndex],
      node: [this.node1.dataIndex, this.node2.dataIndex]
    };
  };

  return GraphEdge;
}();

function createGraphDataProxyMixin(hostName, dataName) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function (dimension) {
      var data = this[hostName][dataName];
      return data.get(data.getDimension(dimension || 'value'), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function (key, value) {
      this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);
    },
    getVisual: function (key) {
      return this[hostName][dataName].getItemVisual(this.dataIndex, key);
    },
    setLayout: function (layout, merge) {
      this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge);
    },
    getLayout: function () {
      return this[hostName][dataName].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function () {
      return this[hostName][dataName].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function () {
      return this[hostName][dataName].getRawIndex(this.dataIndex);
    }
  };
}

;
;
;
zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.mixin(GraphNode, createGraphDataProxyMixin('hostGraph', 'data'));
zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.mixin(GraphEdge, createGraphDataProxyMixin('hostGraph', 'edgeData'));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Graph);


/***/ }),

/***/ "./node_modules/echarts/lib/data/Tree.js":
/*!***********************************************!*\
  !*** ./node_modules/echarts/lib/data/Tree.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TreeNode": () => (/* binding */ TreeNode),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _helper_linkList__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helper/linkList */ "./node_modules/echarts/lib/data/helper/linkList.js");
/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./List */ "./node_modules/echarts/lib/data/List.js");
/* harmony import */ var _helper_createDimensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helper/createDimensions */ "./node_modules/echarts/lib/data/helper/createDimensions.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Tree data structure
 */






var TreeNode =
/** @class */
function () {
  function TreeNode(name, hostTree) {
    this.depth = 0;
    this.height = 0;
    /**
     * Reference to list item.
     * Do not persistent dataIndex outside,
     * besause it may be changed by list.
     * If dataIndex -1,
     * this node is logical deleted (filtered) in list.
     */

    this.dataIndex = -1;
    this.children = [];
    this.viewChildren = [];
    this.isExpand = false;
    this.name = name || '';
    this.hostTree = hostTree;
  }
  /**
   * The node is removed.
   */


  TreeNode.prototype.isRemoved = function () {
    return this.dataIndex < 0;
  };

  TreeNode.prototype.eachNode = function (options, cb, context) {
    if (typeof options === 'function') {
      context = cb;
      cb = options;
      options = null;
    }

    options = options || {};

    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isString(options)) {
      options = {
        order: options
      };
    }

    var order = options.order || 'preorder';
    var children = this[options.attr || 'children'];
    var suppressVisitSub;
    order === 'preorder' && (suppressVisitSub = cb.call(context, this));

    for (var i = 0; !suppressVisitSub && i < children.length; i++) {
      children[i].eachNode(options, cb, context);
    }

    order === 'postorder' && cb.call(context, this);
  };
  /**
   * Update depth and height of this subtree.
   */


  TreeNode.prototype.updateDepthAndHeight = function (depth) {
    var height = 0;
    this.depth = depth;

    for (var i = 0; i < this.children.length; i++) {
      var child = this.children[i];
      child.updateDepthAndHeight(depth + 1);

      if (child.height > height) {
        height = child.height;
      }
    }

    this.height = height + 1;
  };

  TreeNode.prototype.getNodeById = function (id) {
    if (this.getId() === id) {
      return this;
    }

    for (var i = 0, children = this.children, len = children.length; i < len; i++) {
      var res = children[i].getNodeById(id);

      if (res) {
        return res;
      }
    }
  };

  TreeNode.prototype.contains = function (node) {
    if (node === this) {
      return true;
    }

    for (var i = 0, children = this.children, len = children.length; i < len; i++) {
      var res = children[i].contains(node);

      if (res) {
        return res;
      }
    }
  };
  /**
   * @param includeSelf Default false.
   * @return order: [root, child, grandchild, ...]
   */


  TreeNode.prototype.getAncestors = function (includeSelf) {
    var ancestors = [];
    var node = includeSelf ? this : this.parentNode;

    while (node) {
      ancestors.push(node);
      node = node.parentNode;
    }

    ancestors.reverse();
    return ancestors;
  };

  TreeNode.prototype.getAncestorsIndices = function () {
    var indices = [];
    var currNode = this;

    while (currNode) {
      indices.push(currNode.dataIndex);
      currNode = currNode.parentNode;
    }

    indices.reverse();
    return indices;
  };

  TreeNode.prototype.getDescendantIndices = function () {
    var indices = [];
    this.eachNode(function (childNode) {
      indices.push(childNode.dataIndex);
    });
    return indices;
  };

  TreeNode.prototype.getValue = function (dimension) {
    var data = this.hostTree.data;
    return data.get(data.getDimension(dimension || 'value'), this.dataIndex);
  };

  TreeNode.prototype.setLayout = function (layout, merge) {
    this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);
  };
  /**
   * @return {Object} layout
   */


  TreeNode.prototype.getLayout = function () {
    return this.hostTree.data.getItemLayout(this.dataIndex);
  }; // @depcrecated
  // getModel<T = unknown, S extends keyof T = keyof T>(path: S): Model<T[S]>


  TreeNode.prototype.getModel = function (path) {
    if (this.dataIndex < 0) {
      return;
    }

    var hostTree = this.hostTree;
    var itemModel = hostTree.data.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  }; // TODO: TYPE More specific model


  TreeNode.prototype.getLevelModel = function () {
    return (this.hostTree.levelModels || [])[this.depth];
  };

  TreeNode.prototype.setVisual = function (key, value) {
    this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);
  };
  /**
   * Get item visual
   */


  TreeNode.prototype.getVisual = function (key) {
    return this.hostTree.data.getItemVisual(this.dataIndex, key);
  };

  TreeNode.prototype.getRawIndex = function () {
    return this.hostTree.data.getRawIndex(this.dataIndex);
  };

  TreeNode.prototype.getId = function () {
    return this.hostTree.data.getId(this.dataIndex);
  };
  /**
   * if this is an ancestor of another node
   *
   * @param node another node
   * @return if is ancestor
   */


  TreeNode.prototype.isAncestorOf = function (node) {
    var parent = node.parentNode;

    while (parent) {
      if (parent === this) {
        return true;
      }

      parent = parent.parentNode;
    }

    return false;
  };
  /**
   * if this is an descendant of another node
   *
   * @param node another node
   * @return if is descendant
   */


  TreeNode.prototype.isDescendantOf = function (node) {
    return node !== this && node.isAncestorOf(this);
  };

  return TreeNode;
}();


;

var Tree =
/** @class */
function () {
  function Tree(hostModel) {
    this.type = 'tree';
    this._nodes = [];
    this.hostModel = hostModel;
  }

  Tree.prototype.eachNode = function (options, cb, context) {
    this.root.eachNode(options, cb, context);
  };

  Tree.prototype.getNodeByDataIndex = function (dataIndex) {
    var rawIndex = this.data.getRawIndex(dataIndex);
    return this._nodes[rawIndex];
  };

  Tree.prototype.getNodeById = function (name) {
    return this.root.getNodeById(name);
  };
  /**
   * Update item available by list,
   * when list has been performed options like 'filterSelf' or 'map'.
   */


  Tree.prototype.update = function () {
    var data = this.data;
    var nodes = this._nodes;

    for (var i = 0, len = nodes.length; i < len; i++) {
      nodes[i].dataIndex = -1;
    }

    for (var i = 0, len = data.count(); i < len; i++) {
      nodes[data.getRawIndex(i)].dataIndex = i;
    }
  };
  /**
   * Clear all layouts
   */


  Tree.prototype.clearLayouts = function () {
    this.data.clearItemLayouts();
  };
  /**
   * data node format:
   * {
   *     name: ...
   *     value: ...
   *     children: [
   *         {
   *             name: ...
   *             value: ...
   *             children: ...
   *         },
   *         ...
   *     ]
   * }
   */


  Tree.createTree = function (dataRoot, hostModel, beforeLink) {
    var tree = new Tree(hostModel);
    var listData = [];
    var dimMax = 1;
    buildHierarchy(dataRoot);

    function buildHierarchy(dataNode, parentNode) {
      var value = dataNode.value;
      dimMax = Math.max(dimMax, zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(value) ? value.length : 1);
      listData.push(dataNode);
      var node = new TreeNode((0,_util_model__WEBPACK_IMPORTED_MODULE_1__.convertOptionIdName)(dataNode.name, ''), tree);
      parentNode ? addChild(node, parentNode) : tree.root = node;

      tree._nodes.push(node);

      var children = dataNode.children;

      if (children) {
        for (var i = 0; i < children.length; i++) {
          buildHierarchy(children[i], node);
        }
      }
    }

    tree.root.updateDepthAndHeight(0);
    var dimensionsInfo = (0,_helper_createDimensions__WEBPACK_IMPORTED_MODULE_2__.default)(listData, {
      coordDimensions: ['value'],
      dimensionsCount: dimMax
    });
    var list = new _List__WEBPACK_IMPORTED_MODULE_3__.default(dimensionsInfo, hostModel);
    list.initData(listData);
    beforeLink && beforeLink(list);
    (0,_helper_linkList__WEBPACK_IMPORTED_MODULE_4__.default)({
      mainData: list,
      struct: tree,
      structAttr: 'tree'
    });
    tree.update();
    return tree;
  };

  return Tree;
}();
/**
 * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,
 * so this function is not ready and not necessary to be public.
 */


function addChild(child, node) {
  var children = node.children;

  if (child.parentNode === node) {
    return;
  }

  children.push(child);
  child.parentNode = node;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tree);

/***/ }),

/***/ "./node_modules/echarts/lib/data/helper/linkList.js":
/*!**********************************************************!*\
  !*** ./node_modules/echarts/lib/data/helper/linkList.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Link lists and struct (graph or tree)
 */


var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();

function linkList(opt) {
  var mainData = opt.mainData;
  var datas = opt.datas;

  if (!datas) {
    datas = {
      main: mainData
    };
    opt.datasAttr = {
      main: 'data'
    };
  }

  opt.datas = opt.mainData = null;
  linkAll(mainData, datas, opt); // Porxy data original methods.

  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(datas, function (data) {
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(mainData.TRANSFERABLE_METHODS, function (methodName) {
      data.wrapMethod(methodName, (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry)(transferInjection, opt));
    });
  }); // Beyond transfer, additional features should be added to `cloneShallow`.

  mainData.wrapMethod('cloneShallow', (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry)(cloneShallowInjection, opt)); // Only mainData trigger change, because struct.update may trigger
  // another changable methods, which may bring about dead lock.

  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(mainData.CHANGABLE_METHODS, function (methodName) {
    mainData.wrapMethod(methodName, (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry)(changeInjection, opt));
  }); // Make sure datas contains mainData.

  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)(datas[mainData.dataType] === mainData);
}

function transferInjection(opt, res) {
  if (isMainData(this)) {
    // Transfer datas to new main data.
    var datas = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, inner(this).datas);
    datas[this.dataType] = res;
    linkAll(res, datas, opt);
  } else {
    // Modify the reference in main data to point newData.
    linkSingle(res, this.dataType, inner(this).mainData, opt);
  }

  return res;
}

function changeInjection(opt, res) {
  opt.struct && opt.struct.update();
  return res;
}

function cloneShallowInjection(opt, res) {
  // cloneShallow, which brings about some fragilities, may be inappropriate
  // to be exposed as an API. So for implementation simplicity we can make
  // the restriction that cloneShallow of not-mainData should not be invoked
  // outside, but only be invoked here.
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(inner(res).datas, function (data, dataType) {
    data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);
  });
  return res;
}
/**
 * Supplement method to List.
 *
 * @public
 * @param [dataType] If not specified, return mainData.
 */


function getLinkedData(dataType) {
  var mainData = inner(this).mainData;
  return dataType == null || mainData == null ? mainData : inner(mainData).datas[dataType];
}
/**
 * Get list of all linked data
 */


function getLinkedDataAll() {
  var mainData = inner(this).mainData;
  return mainData == null ? [{
    data: mainData
  }] : (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map)((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.keys)(inner(mainData).datas), function (type) {
    return {
      type: type,
      data: inner(mainData).datas[type]
    };
  });
}

function isMainData(data) {
  return inner(data).mainData === data;
}

function linkAll(mainData, datas, opt) {
  inner(mainData).datas = {};
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(datas, function (data, dataType) {
    linkSingle(data, dataType, mainData, opt);
  });
}

function linkSingle(data, dataType, mainData, opt) {
  inner(mainData).datas[dataType] = data;
  inner(data).mainData = mainData;
  data.dataType = dataType;

  if (opt.struct) {
    data[opt.structAttr] = opt.struct;
    opt.struct[opt.datasAttr[dataType]] = data;
  } // Supplement method.


  data.getLinkedData = getLinkedData;
  data.getLinkedDataAll = getLinkedDataAll;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (linkList);

/***/ }),

/***/ "./node_modules/echarts/lib/export/charts.js":
/*!***************************************************!*\
  !*** ./node_modules/echarts/lib/export/charts.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LineChart": () => (/* reexport safe */ _chart_line_install__WEBPACK_IMPORTED_MODULE_0__.install),
/* harmony export */   "BarChart": () => (/* reexport safe */ _chart_bar_install__WEBPACK_IMPORTED_MODULE_1__.install),
/* harmony export */   "PieChart": () => (/* reexport safe */ _chart_pie_install__WEBPACK_IMPORTED_MODULE_2__.install),
/* harmony export */   "ScatterChart": () => (/* reexport safe */ _chart_scatter_install__WEBPACK_IMPORTED_MODULE_3__.install),
/* harmony export */   "RadarChart": () => (/* reexport safe */ _chart_radar_install__WEBPACK_IMPORTED_MODULE_4__.install),
/* harmony export */   "MapChart": () => (/* reexport safe */ _chart_map_install__WEBPACK_IMPORTED_MODULE_5__.install),
/* harmony export */   "TreeChart": () => (/* reexport safe */ _chart_tree_install__WEBPACK_IMPORTED_MODULE_6__.install),
/* harmony export */   "TreemapChart": () => (/* reexport safe */ _chart_treemap_install__WEBPACK_IMPORTED_MODULE_7__.install),
/* harmony export */   "GraphChart": () => (/* reexport safe */ _chart_graph_install__WEBPACK_IMPORTED_MODULE_8__.install),
/* harmony export */   "GaugeChart": () => (/* reexport safe */ _chart_gauge_install__WEBPACK_IMPORTED_MODULE_9__.install),
/* harmony export */   "FunnelChart": () => (/* reexport safe */ _chart_funnel_install__WEBPACK_IMPORTED_MODULE_10__.install),
/* harmony export */   "ParallelChart": () => (/* reexport safe */ _chart_parallel_install__WEBPACK_IMPORTED_MODULE_11__.install),
/* harmony export */   "SankeyChart": () => (/* reexport safe */ _chart_sankey_install__WEBPACK_IMPORTED_MODULE_12__.install),
/* harmony export */   "BoxplotChart": () => (/* reexport safe */ _chart_boxplot_install__WEBPACK_IMPORTED_MODULE_13__.install),
/* harmony export */   "CandlestickChart": () => (/* reexport safe */ _chart_candlestick_install__WEBPACK_IMPORTED_MODULE_14__.install),
/* harmony export */   "EffectScatterChart": () => (/* reexport safe */ _chart_effectScatter_install__WEBPACK_IMPORTED_MODULE_15__.install),
/* harmony export */   "LinesChart": () => (/* reexport safe */ _chart_lines_install__WEBPACK_IMPORTED_MODULE_16__.install),
/* harmony export */   "HeatmapChart": () => (/* reexport safe */ _chart_heatmap_install__WEBPACK_IMPORTED_MODULE_17__.install),
/* harmony export */   "PictorialBarChart": () => (/* reexport safe */ _chart_bar_installPictorialBar__WEBPACK_IMPORTED_MODULE_18__.install),
/* harmony export */   "ThemeRiverChart": () => (/* reexport safe */ _chart_themeRiver_install__WEBPACK_IMPORTED_MODULE_19__.install),
/* harmony export */   "SunburstChart": () => (/* reexport safe */ _chart_sunburst_install__WEBPACK_IMPORTED_MODULE_20__.install),
/* harmony export */   "CustomChart": () => (/* reexport safe */ _chart_custom_install__WEBPACK_IMPORTED_MODULE_21__.install)
/* harmony export */ });
/* harmony import */ var _chart_line_install__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chart/line/install */ "./node_modules/echarts/lib/chart/line/install.js");
/* harmony import */ var _chart_bar_install__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../chart/bar/install */ "./node_modules/echarts/lib/chart/bar/install.js");
/* harmony import */ var _chart_pie_install__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../chart/pie/install */ "./node_modules/echarts/lib/chart/pie/install.js");
/* harmony import */ var _chart_scatter_install__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../chart/scatter/install */ "./node_modules/echarts/lib/chart/scatter/install.js");
/* harmony import */ var _chart_radar_install__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../chart/radar/install */ "./node_modules/echarts/lib/chart/radar/install.js");
/* harmony import */ var _chart_map_install__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../chart/map/install */ "./node_modules/echarts/lib/chart/map/install.js");
/* harmony import */ var _chart_tree_install__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../chart/tree/install */ "./node_modules/echarts/lib/chart/tree/install.js");
/* harmony import */ var _chart_treemap_install__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../chart/treemap/install */ "./node_modules/echarts/lib/chart/treemap/install.js");
/* harmony import */ var _chart_graph_install__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../chart/graph/install */ "./node_modules/echarts/lib/chart/graph/install.js");
/* harmony import */ var _chart_gauge_install__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../chart/gauge/install */ "./node_modules/echarts/lib/chart/gauge/install.js");
/* harmony import */ var _chart_funnel_install__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../chart/funnel/install */ "./node_modules/echarts/lib/chart/funnel/install.js");
/* harmony import */ var _chart_parallel_install__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../chart/parallel/install */ "./node_modules/echarts/lib/chart/parallel/install.js");
/* harmony import */ var _chart_sankey_install__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../chart/sankey/install */ "./node_modules/echarts/lib/chart/sankey/install.js");
/* harmony import */ var _chart_boxplot_install__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../chart/boxplot/install */ "./node_modules/echarts/lib/chart/boxplot/install.js");
/* harmony import */ var _chart_candlestick_install__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../chart/candlestick/install */ "./node_modules/echarts/lib/chart/candlestick/install.js");
/* harmony import */ var _chart_effectScatter_install__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../chart/effectScatter/install */ "./node_modules/echarts/lib/chart/effectScatter/install.js");
/* harmony import */ var _chart_lines_install__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../chart/lines/install */ "./node_modules/echarts/lib/chart/lines/install.js");
/* harmony import */ var _chart_heatmap_install__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../chart/heatmap/install */ "./node_modules/echarts/lib/chart/heatmap/install.js");
/* harmony import */ var _chart_bar_installPictorialBar__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../chart/bar/installPictorialBar */ "./node_modules/echarts/lib/chart/bar/installPictorialBar.js");
/* harmony import */ var _chart_themeRiver_install__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../chart/themeRiver/install */ "./node_modules/echarts/lib/chart/themeRiver/install.js");
/* harmony import */ var _chart_sunburst_install__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../chart/sunburst/install */ "./node_modules/echarts/lib/chart/sunburst/install.js");
/* harmony import */ var _chart_custom_install__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../chart/custom/install */ "./node_modules/echarts/lib/chart/custom/install.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// In somehow. If we export like
// export * as LineChart './chart/line/install'
// The exported code will be transformed to
// import * as LineChart_1 './chart/line/install'; export {LineChart_1 as LineChart};
// Treeshaking in webpack will not work even if we configured sideEffects to false in package.json























/***/ }),

/***/ "./node_modules/echarts/lib/layout/points.js":
/*!***************************************************!*\
  !*** ./node_modules/echarts/lib/layout/points.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pointsLayout)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _chart_helper_createRenderPlanner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chart/helper/createRenderPlanner */ "./node_modules/echarts/lib/chart/helper/createRenderPlanner.js");
/* harmony import */ var _data_helper_dataStackHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/helper/dataStackHelper */ "./node_modules/echarts/lib/data/helper/dataStackHelper.js");
/* harmony import */ var _util_vendor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/vendor */ "./node_modules/echarts/lib/util/vendor.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/* global Float32Array */




function pointsLayout(seriesType, forceStoreInTypedArray) {
  return {
    seriesType: seriesType,
    plan: (0,_chart_helper_createRenderPlanner__WEBPACK_IMPORTED_MODULE_0__.default)(),
    reset: function (seriesModel) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      var pipelineContext = seriesModel.pipelineContext;
      var useTypedArray = forceStoreInTypedArray || pipelineContext.large;

      if (!coordSys) {
        return;
      }

      var dims = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map)(coordSys.dimensions, function (dim) {
        return data.mapDimension(dim);
      }).slice(0, 2);
      var dimLen = dims.length;
      var stackResultDim = data.getCalculationInfo('stackResultDimension');

      if ((0,_data_helper_dataStackHelper__WEBPACK_IMPORTED_MODULE_2__.isDimensionStacked)(data, dims[0]
      /*, dims[1]*/
      )) {
        dims[0] = stackResultDim;
      }

      if ((0,_data_helper_dataStackHelper__WEBPACK_IMPORTED_MODULE_2__.isDimensionStacked)(data, dims[1]
      /*, dims[0]*/
      )) {
        dims[1] = stackResultDim;
      }

      var dimInfo0 = data.getDimensionInfo(dims[0]);
      var dimInfo1 = data.getDimensionInfo(dims[1]);
      var dimIdx0 = dimInfo0 && dimInfo0.index;
      var dimIdx1 = dimInfo1 && dimInfo1.index;
      return dimLen && {
        progress: function (params, data) {
          var segCount = params.end - params.start;
          var points = useTypedArray && (0,_util_vendor__WEBPACK_IMPORTED_MODULE_3__.createFloat32Array)(segCount * dimLen);
          var tmpIn = [];
          var tmpOut = [];

          for (var i = params.start, offset = 0; i < params.end; i++) {
            var point = void 0;

            if (dimLen === 1) {
              var x = data.getByDimIdx(dimIdx0, i); // NOTE: Make sure the second parameter is null to use default strategy.

              point = coordSys.dataToPoint(x, null, tmpOut);
            } else {
              tmpIn[0] = data.getByDimIdx(dimIdx0, i);
              tmpIn[1] = data.getByDimIdx(dimIdx1, i); // Let coordinate system to handle the NaN data.

              point = coordSys.dataToPoint(tmpIn, null, tmpOut);
            }

            if (useTypedArray) {
              points[offset++] = point[0];
              points[offset++] = point[1];
            } else {
              data.setItemLayout(i, point.slice());
            }
          }

          useTypedArray && data.setLayout('points', points);
        }
      };
    }
  };
}
;

/***/ }),

/***/ "./node_modules/echarts/lib/processor/dataFilter.js":
/*!**********************************************************!*\
  !*** ./node_modules/echarts/lib/processor/dataFilter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ dataFilter)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function dataFilter(seriesType) {
  return {
    seriesType: seriesType,
    reset: function (seriesModel, ecModel) {
      var legendModels = ecModel.findComponents({
        mainType: 'legend'
      });

      if (!legendModels || !legendModels.length) {
        return;
      }

      var data = seriesModel.getData();
      data.filterSelf(function (idx) {
        var name = data.getName(idx); // If in any legend component the status is not selected.

        for (var i = 0; i < legendModels.length; i++) {
          // @ts-ignore FIXME: LegendModel
          if (!legendModels[i].isSelected(name)) {
            return false;
          }
        }

        return true;
      });
    }
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/processor/dataSample.js":
/*!**********************************************************!*\
  !*** ./node_modules/echarts/lib/processor/dataSample.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ dataSample)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var samplers = {
  average: function (frame) {
    var sum = 0;
    var count = 0;

    for (var i = 0; i < frame.length; i++) {
      if (!isNaN(frame[i])) {
        sum += frame[i];
        count++;
      }
    } // Return NaN if count is 0


    return count === 0 ? NaN : sum / count;
  },
  sum: function (frame) {
    var sum = 0;

    for (var i = 0; i < frame.length; i++) {
      // Ignore NaN
      sum += frame[i] || 0;
    }

    return sum;
  },
  max: function (frame) {
    var max = -Infinity;

    for (var i = 0; i < frame.length; i++) {
      frame[i] > max && (max = frame[i]);
    } // NaN will cause illegal axis extent.


    return isFinite(max) ? max : NaN;
  },
  min: function (frame) {
    var min = Infinity;

    for (var i = 0; i < frame.length; i++) {
      frame[i] < min && (min = frame[i]);
    } // NaN will cause illegal axis extent.


    return isFinite(min) ? min : NaN;
  },
  // TODO
  // Median
  nearest: function (frame) {
    return frame[0];
  }
};

var indexSampler = function (frame) {
  return Math.round(frame.length / 2);
};

function dataSample(seriesType) {
  return {
    seriesType: seriesType,
    // FIXME:TS never used, so comment it
    // modifyOutputEnd: true,
    reset: function (seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var sampling = seriesModel.get('sampling');
      var coordSys = seriesModel.coordinateSystem;
      var count = data.count(); // Only cartesian2d support down sampling. Disable it when there is few data.

      if (count > 10 && coordSys.type === 'cartesian2d' && sampling) {
        var baseAxis = coordSys.getBaseAxis();
        var valueAxis = coordSys.getOtherAxis(baseAxis);
        var extent = baseAxis.getExtent();
        var dpr = api.getDevicePixelRatio(); // Coordinste system has been resized

        var size = Math.abs(extent[1] - extent[0]) * (dpr || 1);
        var rate = Math.round(count / size);

        if (rate > 1) {
          if (sampling === 'lttb') {
            seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis.dim), 1 / rate));
          }

          var sampler = void 0;

          if (typeof sampling === 'string') {
            sampler = samplers[sampling];
          } else if (typeof sampling === 'function') {
            sampler = sampling;
          }

          if (sampler) {
            // Only support sample the first dim mapped from value axis.
            seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));
          }
        }
      }
    }
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/util/animation.js":
/*!****************************************************!*\
  !*** ./node_modules/echarts/lib/util/animation.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createWrap": () => (/* binding */ createWrap)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Animate multiple elements with a single done-callback.
 *
 * @example
 *  animation
 *      .createWrap()
 *      .add(el1, {x: 10, y: 10})
 *      .add(el2, {shape: {width: 500}, style: {fill: 'red'}}, 400)
 *      .done(function () { // done })
 *      .start('cubicOut');
 */
var AnimationWrap =
/** @class */
function () {
  function AnimationWrap() {
    this._storage = [];
    this._elExistsMap = {};
  }
  /**
   * Caution: a el can only be added once, otherwise 'done'
   * might not be called. This method checks this (by el.id),
   * suppresses adding and returns false when existing el found.
   *
   * @return Whether adding succeeded.
   */


  AnimationWrap.prototype.add = function (el, target, duration, delay, easing) {
    if (this._elExistsMap[el.id]) {
      return false;
    }

    this._elExistsMap[el.id] = true;

    this._storage.push({
      el: el,
      target: target,
      duration: duration,
      delay: delay,
      easing: easing
    });

    return true;
  };
  /**
   * Only execute when animation done/aborted.
   */


  AnimationWrap.prototype.finished = function (callback) {
    this._finishedCallback = callback;
    return this;
  };
  /**
   * Will stop exist animation firstly.
   */


  AnimationWrap.prototype.start = function () {
    var _this = this;

    var count = this._storage.length;

    var checkTerminate = function () {
      count--;

      if (count <= 0) {
        // Guard.
        _this._storage.length = 0;
        _this._elExistsMap = {};
        _this._finishedCallback && _this._finishedCallback();
      }
    };

    for (var i = 0, len = this._storage.length; i < len; i++) {
      var item = this._storage[i];
      item.el.animateTo(item.target, {
        duration: item.duration,
        delay: item.delay,
        easing: item.easing,
        setToFinal: true,
        done: checkTerminate,
        aborted: checkTerminate
      });
    }

    return this;
  };

  return AnimationWrap;
}();

function createWrap() {
  return new AnimationWrap();
}

/***/ }),

/***/ "./node_modules/echarts/lib/util/shape/sausage.js":
/*!********************************************************!*\
  !*** ./node_modules/echarts/lib/util/shape/sausage.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graphic */ "./node_modules/zrender/lib/graphic/Path.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * Sausage: similar to sector, but have half circle on both sides
 */

var SausageShape =
/** @class */
function () {
  function SausageShape() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }

  return SausageShape;
}();

var SausagePath =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SausagePath, _super);

  function SausagePath(opts) {
    var _this = _super.call(this, opts) || this;

    _this.type = 'sausage';
    return _this;
  }

  SausagePath.prototype.getDefaultShape = function () {
    return new SausageShape();
  };

  SausagePath.prototype.buildPath = function (ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var r0 = Math.max(shape.r0 || 0, 0);
    var r = Math.max(shape.r, 0);
    var dr = (r - r0) * 0.5;
    var rCenter = r0 + dr;
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitStartX = Math.cos(startAngle);
    var unitStartY = Math.sin(startAngle);
    var unitEndX = Math.cos(endAngle);
    var unitEndY = Math.sin(endAngle);
    var lessThanCircle = clockwise ? endAngle - startAngle < Math.PI * 2 : startAngle - endAngle < Math.PI * 2;

    if (lessThanCircle) {
      ctx.moveTo(unitStartX * r0 + x, unitStartY * r0 + y);
      ctx.arc(unitStartX * rCenter + x, unitStartY * rCenter + y, dr, -Math.PI + startAngle, startAngle, !clockwise);
    }

    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
    ctx.moveTo(unitEndX * r + x, unitEndY * r + y);
    ctx.arc(unitEndX * rCenter + x, unitEndY * rCenter + y, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);

    if (r0 !== 0) {
      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
      ctx.moveTo(unitStartX * r0 + x, unitEndY * r0 + y);
    }

    ctx.closePath();
  };

  return SausagePath;
}(_graphic__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SausagePath);

/***/ }),

/***/ "./node_modules/echarts/lib/util/vendor.js":
/*!*************************************************!*\
  !*** ./node_modules/echarts/lib/util/vendor.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFloat32Array": () => (/* binding */ createFloat32Array)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/* global Float32Array */

var supportFloat32Array = typeof Float32Array !== 'undefined';
var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;
function createFloat32Array(arg) {
  if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(arg)) {
    // Return self directly if don't support TypedArray.
    return supportFloat32Array ? new Float32Array(arg) : arg;
  } // Else is number


  return new Float32ArrayCtor(arg);
}

/***/ }),

/***/ "./node_modules/echarts/lib/visual/LegendVisualProvider.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/visual/LegendVisualProvider.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * LegendVisualProvider is an bridge that pick encoded color from data and
 * provide to the legend component.
 */
var LegendVisualProvider =
/** @class */
function () {
  function LegendVisualProvider( // Function to get data after filtered. It stores all the encoding info
  getDataWithEncodedVisual, // Function to get raw data before filtered.
  getRawData) {
    this._getDataWithEncodedVisual = getDataWithEncodedVisual;
    this._getRawData = getRawData;
  }

  LegendVisualProvider.prototype.getAllNames = function () {
    var rawData = this._getRawData(); // We find the name from the raw data. In case it's filtered by the legend component.
    // Normally, the name can be found in rawData, but can't be found in filtered data will display as gray.


    return rawData.mapArray(rawData.getName);
  };

  LegendVisualProvider.prototype.containName = function (name) {
    var rawData = this._getRawData();

    return rawData.indexOfName(name) >= 0;
  };

  LegendVisualProvider.prototype.indexOfName = function (name) {
    // Only get data when necessary.
    // Because LegendVisualProvider constructor may be new in the stage that data is not prepared yet.
    // Invoking Series#getData immediately will throw an error.
    var dataWithEncodedVisual = this._getDataWithEncodedVisual();

    return dataWithEncodedVisual.indexOfName(name);
  };

  LegendVisualProvider.prototype.getItemVisual = function (dataIndex, key) {
    // Get encoded visual properties from final filtered data.
    var dataWithEncodedVisual = this._getDataWithEncodedVisual();

    return dataWithEncodedVisual.getItemVisual(dataIndex, key);
  };

  return LegendVisualProvider;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LegendVisualProvider);

/***/ }),

/***/ "./node_modules/zrender/lib/tool/morphPath.js":
/*!****************************************************!*\
  !*** ./node_modules/zrender/lib/tool/morphPath.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pathToBezierCurves": () => (/* binding */ pathToBezierCurves),
/* harmony export */   "alignBezierCurves": () => (/* binding */ alignBezierCurves),
/* harmony export */   "centroid": () => (/* binding */ centroid),
/* harmony export */   "morphPath": () => (/* binding */ morphPath),
/* harmony export */   "isCombiningPath": () => (/* binding */ isCombiningPath),
/* harmony export */   "isInAnyMorphing": () => (/* binding */ isInAnyMorphing),
/* harmony export */   "combine": () => (/* binding */ combine),
/* harmony export */   "separate": () => (/* binding */ separate)
/* harmony export */ });
/* harmony import */ var _core_PathProxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/PathProxy */ "./node_modules/zrender/lib/core/PathProxy.js");
/* harmony import */ var _core_curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/curve */ "./node_modules/zrender/lib/core/curve.js");
/* harmony import */ var _core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/vector */ "./node_modules/zrender/lib/core/vector.js");
/* harmony import */ var _graphic_shape_Rect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../graphic/shape/Rect */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _graphic_shape_Sector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../graphic/shape/Sector */ "./node_modules/zrender/lib/graphic/shape/Sector.js");






var CMD = _core_PathProxy__WEBPACK_IMPORTED_MODULE_0__.default.CMD;
var PI2 = Math.PI * 2;
var PROP_XY = ['x', 'y'];
var PROP_WH = ['width', 'height'];
var tmpArr = [];
function aroundEqual(a, b) {
    return Math.abs(a - b) < 1e-5;
}
function pathToBezierCurves(path) {
    var data = path.data;
    var len = path.len();
    var bezierArray = [];
    var currentSubpath;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    function createNewSubpath(x, y) {
        if (currentSubpath && currentSubpath.length > 2) {
            bezierArray.push(currentSubpath);
        }
        currentSubpath = [x, y];
    }
    function addLine(x0, y0, x1, y1) {
        if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {
            currentSubpath.push(x0, y0, x1, y1, x1, y1);
        }
    }
    function addArc(startAngle, endAngle, cx, cy, rx, ry) {
        var delta = Math.abs(endAngle - startAngle);
        var len = Math.tan(delta / 4) * 4 / 3;
        var dir = endAngle < startAngle ? -1 : 1;
        var c1 = Math.cos(startAngle);
        var s1 = Math.sin(startAngle);
        var c2 = Math.cos(endAngle);
        var s2 = Math.sin(endAngle);
        var x1 = c1 * rx + cx;
        var y1 = s1 * ry + cy;
        var x4 = c2 * rx + cx;
        var y4 = s2 * ry + cy;
        var hx = rx * len * dir;
        var hy = ry * len * dir;
        currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
    }
    var x1;
    var y1;
    var x2;
    var y2;
    for (var i = 0; i < len;) {
        var cmd = data[i++];
        var isFirst = i === 1;
        if (isFirst) {
            xi = data[i];
            yi = data[i + 1];
            x0 = xi;
            y0 = yi;
            if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {
                currentSubpath = [x0, y0];
            }
        }
        switch (cmd) {
            case CMD.M:
                xi = x0 = data[i++];
                yi = y0 = data[i++];
                createNewSubpath(x0, y0);
                break;
            case CMD.L:
                x1 = data[i++];
                y1 = data[i++];
                addLine(xi, yi, x1, y1);
                xi = x1;
                yi = y1;
                break;
            case CMD.C:
                currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);
                break;
            case CMD.Q:
                x1 = data[i++];
                y1 = data[i++];
                x2 = data[i++];
                y2 = data[i++];
                currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);
                xi = x2;
                yi = y2;
                break;
            case CMD.A:
                var cx = data[i++];
                var cy = data[i++];
                var rx = data[i++];
                var ry = data[i++];
                var startAngle = data[i++];
                var endAngle = data[i++] + startAngle;
                i += 1;
                var anticlockwise = !data[i++];
                x1 = Math.cos(startAngle) * rx + cx;
                y1 = Math.sin(startAngle) * ry + cy;
                if (isFirst) {
                    x0 = x1;
                    y0 = y1;
                    createNewSubpath(x0, y0);
                }
                else {
                    addLine(xi, yi, x1, y1);
                }
                xi = Math.cos(endAngle) * rx + cx;
                yi = Math.sin(endAngle) * ry + cy;
                var step = (anticlockwise ? -1 : 1) * Math.PI / 2;
                for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {
                    var nextAngle = anticlockwise ? Math.max(angle + step, endAngle)
                        : Math.min(angle + step, endAngle);
                    addArc(angle, nextAngle, cx, cy, rx, ry);
                }
                break;
            case CMD.R:
                x0 = xi = data[i++];
                y0 = yi = data[i++];
                x1 = x0 + data[i++];
                y1 = y0 + data[i++];
                createNewSubpath(x1, y0);
                addLine(x1, y0, x1, y1);
                addLine(x1, y1, x0, y1);
                addLine(x0, y1, x0, y0);
                addLine(x0, y0, x1, y0);
                break;
            case CMD.Z:
                currentSubpath && addLine(xi, yi, x0, y0);
                xi = x0;
                yi = y0;
                break;
        }
    }
    if (currentSubpath && currentSubpath.length > 2) {
        bezierArray.push(currentSubpath);
    }
    return bezierArray;
}
function alignSubpath(subpath1, subpath2) {
    var len1 = subpath1.length;
    var len2 = subpath2.length;
    if (len1 === len2) {
        return [subpath1, subpath2];
    }
    var shorterPath = len1 < len2 ? subpath1 : subpath2;
    var shorterLen = Math.min(len1, len2);
    var diff = Math.abs(len2 - len1) / 6;
    var shorterBezierCount = (shorterLen - 2) / 6;
    var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;
    var newSubpath = [shorterPath[0], shorterPath[1]];
    var remained = diff;
    var tmpSegX = [];
    var tmpSegY = [];
    for (var i = 2; i < shorterLen;) {
        var x0 = shorterPath[i - 2];
        var y0 = shorterPath[i - 1];
        var x1 = shorterPath[i++];
        var y1 = shorterPath[i++];
        var x2 = shorterPath[i++];
        var y2 = shorterPath[i++];
        var x3 = shorterPath[i++];
        var y3 = shorterPath[i++];
        if (remained <= 0) {
            newSubpath.push(x1, y1, x2, y2, x3, y3);
            continue;
        }
        var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;
        for (var k = 1; k <= actualSubDivCount; k++) {
            var p = k / actualSubDivCount;
            (0,_core_curve__WEBPACK_IMPORTED_MODULE_1__.cubicSubdivide)(x0, x1, x2, x3, p, tmpSegX);
            (0,_core_curve__WEBPACK_IMPORTED_MODULE_1__.cubicSubdivide)(y0, y1, y2, y3, p, tmpSegY);
            x0 = tmpSegX[3];
            y0 = tmpSegY[3];
            newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);
            x1 = tmpSegX[5];
            y1 = tmpSegY[5];
            x2 = tmpSegX[6];
            y2 = tmpSegY[6];
        }
        remained -= actualSubDivCount - 1;
    }
    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
}
function createSubpath(lastSubpathSubpath, otherSubpath) {
    var len = lastSubpathSubpath.length;
    var lastX = lastSubpathSubpath[len - 2];
    var lastY = lastSubpathSubpath[len - 1];
    var newSubpath = [];
    for (var i = 0; i < otherSubpath.length;) {
        newSubpath[i++] = lastX;
        newSubpath[i++] = lastY;
    }
    return newSubpath;
}
function alignBezierCurves(array1, array2) {
    var _a;
    var lastSubpath1;
    var lastSubpath2;
    var newArray1 = [];
    var newArray2 = [];
    for (var i = 0; i < Math.max(array1.length, array2.length); i++) {
        var subpath1 = array1[i];
        var subpath2 = array2[i];
        var newSubpath1 = void 0;
        var newSubpath2 = void 0;
        if (!subpath1) {
            newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);
            newSubpath2 = subpath2;
        }
        else if (!subpath2) {
            newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);
            newSubpath1 = subpath1;
        }
        else {
            _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];
            lastSubpath1 = newSubpath1;
            lastSubpath2 = newSubpath2;
        }
        newArray1.push(newSubpath1);
        newArray2.push(newSubpath2);
    }
    return [newArray1, newArray2];
}
function centroid(array) {
    var signedArea = 0;
    var cx = 0;
    var cy = 0;
    var len = array.length;
    for (var i = 0, j = len - 2; i < len; j = i, i += 2) {
        var x0 = array[j];
        var y0 = array[j + 1];
        var x1 = array[i];
        var y1 = array[i + 1];
        var a = x0 * y1 - x1 * y0;
        signedArea += a;
        cx += (x0 + x1) * a;
        cy += (y0 + y1) * a;
    }
    if (signedArea === 0) {
        return [array[0] || 0, array[1] || 0];
    }
    return [cx / signedArea / 3, cy / signedArea / 3, signedArea];
}
function findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
    var bezierCount = (fromSubBeziers.length - 2) / 6;
    var bestScore = Infinity;
    var bestOffset = 0;
    var len = fromSubBeziers.length;
    var len2 = len - 2;
    for (var offset = 0; offset < bezierCount; offset++) {
        var cursorOffset = offset * 6;
        var score = 0;
        for (var k = 0; k < len; k += 2) {
            var idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2 + 2);
            var x0 = fromSubBeziers[idx] - fromCp[0];
            var y0 = fromSubBeziers[idx + 1] - fromCp[1];
            var x1 = toSubBeziers[k] - toCp[0];
            var y1 = toSubBeziers[k + 1] - toCp[1];
            var dx = x1 - x0;
            var dy = y1 - y0;
            score += dx * dx + dy * dy;
        }
        if (score < bestScore) {
            bestScore = score;
            bestOffset = offset;
        }
    }
    return bestOffset;
}
function reverse(array) {
    var newArr = [];
    var len = array.length;
    for (var i = 0; i < len; i += 2) {
        newArr[i] = array[len - i - 2];
        newArr[i + 1] = array[len - i - 1];
    }
    return newArr;
}
function findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {
    var result = [];
    var fromNeedsReverse;
    for (var i = 0; i < fromArr.length; i++) {
        var fromSubpathBezier = fromArr[i];
        var toSubpathBezier = toArr[i];
        var fromCp = centroid(fromSubpathBezier);
        var toCp = centroid(toSubpathBezier);
        if (fromNeedsReverse == null) {
            fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;
        }
        var newFromSubpathBezier = [];
        var newToSubpathBezier = [];
        var bestAngle = 0;
        var bestScore = Infinity;
        var tmpArr_1 = [];
        var len = fromSubpathBezier.length;
        if (fromNeedsReverse) {
            fromSubpathBezier = reverse(fromSubpathBezier);
        }
        var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;
        var len2 = len - 2;
        for (var k = 0; k < len2; k += 2) {
            var idx = (offset + k) % len2 + 2;
            newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];
            newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
        }
        newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];
        newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];
        if (searchAngleIteration > 0) {
            var step = searchAngleRange / searchAngleIteration;
            for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {
                var sa = Math.sin(angle);
                var ca = Math.cos(angle);
                var score = 0;
                for (var k = 0; k < fromSubpathBezier.length; k += 2) {
                    var x0 = newFromSubpathBezier[k];
                    var y0 = newFromSubpathBezier[k + 1];
                    var x1 = toSubpathBezier[k] - toCp[0];
                    var y1 = toSubpathBezier[k + 1] - toCp[1];
                    var newX1 = x1 * ca - y1 * sa;
                    var newY1 = x1 * sa + y1 * ca;
                    tmpArr_1[k] = newX1;
                    tmpArr_1[k + 1] = newY1;
                    var dx = newX1 - x0;
                    var dy = newY1 - y0;
                    score += dx * dx + dy * dy;
                }
                if (score < bestScore) {
                    bestScore = score;
                    bestAngle = angle;
                    for (var m = 0; m < tmpArr_1.length; m++) {
                        newToSubpathBezier[m] = tmpArr_1[m];
                    }
                }
            }
        }
        else {
            for (var i_1 = 0; i_1 < len; i_1 += 2) {
                newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];
                newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];
            }
        }
        result.push({
            from: newFromSubpathBezier,
            to: newToSubpathBezier,
            fromCp: fromCp,
            toCp: toCp,
            rotation: -bestAngle
        });
    }
    return result;
}
function morphPath(fromPath, toPath, animationOpts) {
    var fromPathProxy;
    var toPathProxy;
    if (!fromPath || !toPath) {
        return toPath;
    }
    !fromPath.path && fromPath.createPathProxy();
    fromPathProxy = fromPath.path;
    fromPathProxy.beginPath();
    fromPath.buildPath(fromPathProxy, fromPath.shape);
    !toPath.path && toPath.createPathProxy();
    toPathProxy = toPath.path;
    toPathProxy === fromPathProxy && (toPathProxy = new _core_PathProxy__WEBPACK_IMPORTED_MODULE_0__.default(false));
    toPathProxy.beginPath();
    if (isIndividualMorphingPath(toPath)) {
        toPath.__oldBuildPath(toPathProxy, toPath.shape);
    }
    else {
        toPath.buildPath(toPathProxy, toPath.shape);
    }
    var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a[0], toBezierCurves = _a[1];
    var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);
    becomeIndividualMorphingPath(toPath, morphingData, 0);
    var oldDone = animationOpts && animationOpts.done;
    var oldAborted = animationOpts && animationOpts.aborted;
    var oldDuring = animationOpts && animationOpts.during;
    toPath.animateTo({
        __morphT: 1
    }, (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.defaults)({
        during: function (p) {
            toPath.dirtyShape();
            oldDuring && oldDuring(p);
        },
        done: function () {
            restoreIndividualMorphingPath(toPath);
            toPath.createPathProxy();
            toPath.dirtyShape();
            oldDone && oldDone();
        },
        aborted: function () {
            oldAborted && oldAborted();
        }
    }, animationOpts));
    return toPath;
}
function morphingPathBuildPath(path) {
    var morphingData = this.__morphingData;
    var t = this.__morphT;
    var onet = 1 - t;
    var newCp = [];
    for (var i = 0; i < morphingData.length; i++) {
        var item = morphingData[i];
        var from = item.from;
        var to = item.to;
        var angle = item.rotation * t;
        var fromCp = item.fromCp;
        var toCp = item.toCp;
        var sa = Math.sin(angle);
        var ca = Math.cos(angle);
        (0,_core_vector__WEBPACK_IMPORTED_MODULE_3__.lerp)(newCp, fromCp, toCp, t);
        for (var m = 0; m < from.length; m += 2) {
            var x0 = from[m];
            var y0 = from[m + 1];
            var x1 = to[m];
            var y1 = to[m + 1];
            var x = x0 * onet + x1 * t;
            var y = y0 * onet + y1 * t;
            tmpArr[m] = (x * ca - y * sa) + newCp[0];
            tmpArr[m + 1] = (x * sa + y * ca) + newCp[1];
        }
        for (var m = 0; m < from.length;) {
            if (m === 0) {
                path.moveTo(tmpArr[m++], tmpArr[m++]);
            }
            path.bezierCurveTo(tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++]);
        }
    }
}
;
function becomeIndividualMorphingPath(path, morphingData, morphT) {
    if (isIndividualMorphingPath(path)) {
        updateIndividualMorphingPath(path, morphingData, morphT);
        return;
    }
    var morphingPath = path;
    morphingPath.__oldBuildPath = morphingPath.buildPath;
    morphingPath.buildPath = morphingPathBuildPath;
    updateIndividualMorphingPath(morphingPath, morphingData, morphT);
}
function updateIndividualMorphingPath(morphingPath, morphingData, morphT) {
    morphingPath.__morphingData = morphingData;
    morphingPath.__morphT = morphT;
}
function restoreIndividualMorphingPath(path) {
    if (isIndividualMorphingPath(path)) {
        path.buildPath = path.__oldBuildPath;
        path.__oldBuildPath = path.__morphingData = null;
    }
}
function isIndividualMorphingPath(path) {
    return path.__oldBuildPath != null;
}
function isCombiningPath(path) {
    return !!path.__combiningSubList;
}
function isInAnyMorphing(path) {
    return isIndividualMorphingPath(path) || isCombiningPath(path);
}
function combine(fromPathList, toPath, animationOpts, copyPropsIfDivided) {
    var fromIndividuals = [];
    var separateCount = 0;
    for (var i = 0; i < fromPathList.length; i++) {
        var fromPath = fromPathList[i];
        if (isCombiningPath(fromPath)) {
            var fromCombiningSubList = fromPath.__combiningSubList;
            for (var j = 0; j < fromCombiningSubList.length; j++) {
                fromIndividuals.push(fromCombiningSubList[j]);
            }
            separateCount += fromCombiningSubList.length;
        }
        else {
            fromIndividuals.push(fromPath);
            separateCount++;
        }
    }
    if (!separateCount) {
        return;
    }
    var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;
    var toPathSplittedList = divideShape(toPath, separateCount, dividingMethod);
    (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.assert)(toPathSplittedList.length === separateCount);
    var oldDone = animationOpts && animationOpts.done;
    var oldAborted = animationOpts && animationOpts.aborted;
    var oldDuring = animationOpts && animationOpts.during;
    var doneCount = 0;
    var abortedCalled = false;
    var morphAnimationOpts = (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.defaults)({
        during: function (p) {
            oldDuring && oldDuring(p);
        },
        done: function () {
            doneCount++;
            if (doneCount === toPathSplittedList.length) {
                restoreCombiningPath(toPath);
                oldDone && oldDone();
            }
        },
        aborted: function () {
            if (!abortedCalled) {
                abortedCalled = true;
                oldAborted && oldAborted();
            }
        }
    }, animationOpts);
    for (var i = 0; i < separateCount; i++) {
        var from = fromIndividuals[i];
        var to = toPathSplittedList[i];
        copyPropsIfDivided && copyPropsIfDivided(toPath, to, true);
        morphPath(from, to, morphAnimationOpts);
    }
    becomeCombiningPath(toPath, toPathSplittedList);
    return {
        fromIndividuals: fromIndividuals,
        toIndividuals: toPathSplittedList,
        count: separateCount
    };
}
function becomeCombiningPath(path, combiningSubList) {
    if (isCombiningPath(path)) {
        updateCombiningPathSubList(path, combiningSubList);
        return;
    }
    var combiningPath = path;
    updateCombiningPathSubList(combiningPath, combiningSubList);
    combiningPath.__oldAddSelfToZr = path.addSelfToZr;
    combiningPath.__oldRemoveSelfFromZr = path.removeSelfFromZr;
    combiningPath.addSelfToZr = combiningAddSelfToZr;
    combiningPath.removeSelfFromZr = combiningRemoveSelfFromZr;
    combiningPath.__oldBuildPath = combiningPath.buildPath;
    combiningPath.buildPath = _core_util__WEBPACK_IMPORTED_MODULE_2__.noop;
    combiningPath.childrenRef = combiningChildrenRef;
}
function restoreCombiningPath(path) {
    if (!isCombiningPath(path)) {
        return;
    }
    var combiningPath = path;
    updateCombiningPathSubList(combiningPath, null);
    combiningPath.addSelfToZr = combiningPath.__oldAddSelfToZr;
    combiningPath.removeSelfFromZr = combiningPath.__oldRemoveSelfFromZr;
    combiningPath.buildPath = combiningPath.__oldBuildPath;
    combiningPath.childrenRef =
        combiningPath.__combiningSubList =
            combiningPath.__oldAddSelfToZr =
                combiningPath.__oldRemoveSelfFromZr =
                    combiningPath.__oldBuildPath = null;
}
function updateCombiningPathSubList(combiningPath, combiningSubList) {
    if (combiningPath.__combiningSubList !== combiningSubList) {
        combiningPathSubListAddRemoveWithZr(combiningPath, 'removeSelfFromZr');
        combiningPath.__combiningSubList = combiningSubList;
        if (combiningSubList) {
            for (var i = 0; i < combiningSubList.length; i++) {
                combiningSubList[i].parent = combiningPath;
            }
        }
        combiningPathSubListAddRemoveWithZr(combiningPath, 'addSelfToZr');
    }
}
function combiningAddSelfToZr(zr) {
    this.__oldAddSelfToZr(zr);
    combiningPathSubListAddRemoveWithZr(this, 'addSelfToZr');
}
function combiningPathSubListAddRemoveWithZr(path, method) {
    var combiningSubList = path.__combiningSubList;
    var zr = path.__zr;
    if (combiningSubList && zr) {
        for (var i = 0; i < combiningSubList.length; i++) {
            var child = combiningSubList[i];
            child[method](zr);
        }
    }
}
function combiningRemoveSelfFromZr(zr) {
    this.__oldRemoveSelfFromZr(zr);
    var combiningSubList = this.__combiningSubList;
    for (var i = 0; i < combiningSubList.length; i++) {
        var child = combiningSubList[i];
        child.removeSelfFromZr(zr);
    }
}
function combiningChildrenRef() {
    return this.__combiningSubList;
}
function separate(fromPath, toPathList, animationOpts, copyPropsIfDivided) {
    var toPathListLen = toPathList.length;
    var fromPathList;
    var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;
    var copyProps = false;
    if (isCombiningPath(fromPath)) {
        var fromCombiningSubList = fromPath.__combiningSubList;
        if (fromCombiningSubList.length === toPathListLen) {
            fromPathList = fromCombiningSubList;
        }
        else {
            fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);
            copyProps = true;
        }
    }
    else {
        fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);
        copyProps = true;
    }
    (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.assert)(fromPathList.length === toPathListLen);
    for (var i = 0; i < toPathListLen; i++) {
        if (copyProps && copyPropsIfDivided) {
            copyPropsIfDivided(fromPath, fromPathList[i], false);
        }
        morphPath(fromPathList[i], toPathList[i], animationOpts);
    }
    return {
        fromIndividuals: fromPathList,
        toIndividuals: toPathList,
        count: toPathListLen
    };
}
function divideShape(path, separateCount, dividingMethod) {
    return dividingMethod === 'duplicate'
        ? duplicateShape(path, separateCount)
        : splitShape(path, separateCount);
}
function splitShape(path, separateCount) {
    var resultPaths = [];
    if (separateCount <= 0) {
        return resultPaths;
    }
    if (separateCount === 1) {
        return duplicateShape(path, separateCount);
    }
    if (path instanceof _graphic_shape_Rect__WEBPACK_IMPORTED_MODULE_4__.default) {
        var toPathShape = path.shape;
        var splitPropIdx = toPathShape.height > toPathShape.width ? 1 : 0;
        var propWH = PROP_WH[splitPropIdx];
        var propXY = PROP_XY[splitPropIdx];
        var subWH = toPathShape[propWH] / separateCount;
        var xyCurr = toPathShape[propXY];
        for (var i = 0; i < separateCount; i++, xyCurr += subWH) {
            var subShape = {
                x: toPathShape.x,
                y: toPathShape.y,
                width: toPathShape.width,
                height: toPathShape.height
            };
            subShape[propXY] = xyCurr;
            subShape[propWH] = i < separateCount - 1
                ? subWH
                : toPathShape[propXY] + toPathShape[propWH] - xyCurr;
            var splitted = new _graphic_shape_Rect__WEBPACK_IMPORTED_MODULE_4__.default({ shape: subShape });
            resultPaths.push(splitted);
        }
    }
    else if (path instanceof _graphic_shape_Sector__WEBPACK_IMPORTED_MODULE_5__.default) {
        var toPathShape = path.shape;
        var clockwise = toPathShape.clockwise;
        var startAngle = toPathShape.startAngle;
        var endAngle = toPathShape.endAngle;
        var endAngleNormalized = normalizeRadian(startAngle, toPathShape.endAngle, clockwise);
        var step = (endAngleNormalized - startAngle) / separateCount;
        var angleCurr = startAngle;
        for (var i = 0; i < separateCount; i++, angleCurr += step) {
            var splitted = new _graphic_shape_Sector__WEBPACK_IMPORTED_MODULE_5__.default({
                shape: {
                    cx: toPathShape.cx,
                    cy: toPathShape.cy,
                    r: toPathShape.r,
                    r0: toPathShape.r0,
                    clockwise: clockwise,
                    startAngle: angleCurr,
                    endAngle: i === separateCount - 1 ? endAngle : angleCurr + step
                }
            });
            resultPaths.push(splitted);
        }
    }
    else {
        return duplicateShape(path, separateCount);
    }
    return resultPaths;
}
function duplicateShape(path, separateCount) {
    var resultPaths = [];
    if (separateCount <= 0) {
        return resultPaths;
    }
    var ctor = path.constructor;
    for (var i = 0; i < separateCount; i++) {
        var sub = new ctor({
            shape: (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.clone)(path.shape)
        });
        resultPaths.push(sub);
    }
    return resultPaths;
}
function normalizeRadian(start, end, clockwise) {
    return end + PI2 * (Math[clockwise ? 'ceil' : 'floor']((start - end) / PI2));
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvY2hhcnRzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0JhclNlcmllcy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXJWaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0Jhc2VCYXJTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvUGljdG9yaWFsQmFyU2VyaWVzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL1BpY3RvcmlhbEJhclZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvaW5zdGFsbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci9pbnN0YWxsUGljdG9yaWFsQmFyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYm94cGxvdC9Cb3hwbG90U2VyaWVzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYm94cGxvdC9Cb3hwbG90Vmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2JveHBsb3QvYm94cGxvdExheW91dC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2JveHBsb3QvYm94cGxvdFRyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2JveHBsb3QvYm94cGxvdFZpc3VhbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2JveHBsb3QvaW5zdGFsbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2JveHBsb3QvcHJlcGFyZUJveHBsb3REYXRhLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvY2FuZGxlc3RpY2svQ2FuZGxlc3RpY2tTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9jYW5kbGVzdGljay9DYW5kbGVzdGlja1ZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9jYW5kbGVzdGljay9jYW5kbGVzdGlja0xheW91dC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2NhbmRsZXN0aWNrL2NhbmRsZXN0aWNrVmlzdWFsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvY2FuZGxlc3RpY2svaW5zdGFsbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2NhbmRsZXN0aWNrL3ByZXByb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2N1c3RvbS9pbnN0YWxsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvZWZmZWN0U2NhdHRlci9FZmZlY3RTY2F0dGVyU2VyaWVzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvZWZmZWN0U2NhdHRlci9FZmZlY3RTY2F0dGVyVmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2VmZmVjdFNjYXR0ZXIvaW5zdGFsbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Z1bm5lbC9GdW5uZWxTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9mdW5uZWwvRnVubmVsVmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Z1bm5lbC9mdW5uZWxMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9mdW5uZWwvaW5zdGFsbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dhdWdlL0dhdWdlU2VyaWVzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvZ2F1Z2UvR2F1Z2VWaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvZ2F1Z2UvUG9pbnRlclBhdGguanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9nYXVnZS9pbnN0YWxsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvZ3JhcGgvR3JhcGhTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ncmFwaC9HcmFwaFZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ncmFwaC9hZGp1c3RFZGdlLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvZ3JhcGgvY2F0ZWdvcnlGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ncmFwaC9jYXRlZ29yeVZpc3VhbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dyYXBoL2NpcmN1bGFyTGF5b3V0LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvZ3JhcGgvY2lyY3VsYXJMYXlvdXRIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ncmFwaC9jcmVhdGVWaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvZ3JhcGgvZWRnZVZpc3VhbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dyYXBoL2ZvcmNlSGVscGVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvZ3JhcGgvZm9yY2VMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ncmFwaC9ncmFwaEhlbHBlci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dyYXBoL2luc3RhbGwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ncmFwaC9zaW1wbGVMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ncmFwaC9zaW1wbGVMYXlvdXRIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWF0bWFwL0hlYXRtYXBMYXllci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlYXRtYXAvSGVhdG1hcFNlcmllcy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlYXRtYXAvSGVhdG1hcFZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWF0bWFwL2luc3RhbGwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvRWZmZWN0TGluZS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9FZmZlY3RQb2x5bGluZS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9FZmZlY3RTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGFyZ2VMaW5lRHJhdy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9MYXJnZVN5bWJvbERyYXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvUG9seWxpbmUuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvY3JlYXRlQ2xpcFBhdGhGcm9tQ29vcmRTeXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvY3JlYXRlR3JhcGhGcm9tTm9kZUVkZ2UuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvY3JlYXRlTGlzdFNpbXBseS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9lbmFibGVBcmlhRGVjYWxGb3JUcmVlLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL211bHRpcGxlR3JhcGhFZGdlSGVscGVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL3BpZUhlbHBlci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci90cmVlSGVscGVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL3doaXNrZXJCb3hDb21tb24uanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL0xpbmVTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL0xpbmVWaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL2luc3RhbGwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL2xpbmVBbmltYXRpb25EaWZmLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9wb2x5LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZXMvTGluZXNTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lcy9MaW5lc1ZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lcy9pbnN0YWxsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZXMvbGluZXNMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lcy9saW5lc1Zpc3VhbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L21hcC9NYXBTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9tYXAvTWFwVmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L21hcC9pbnN0YWxsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbWFwL21hcERhdGFTdGF0aXN0aWMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9tYXAvbWFwU3ltYm9sTGF5b3V0LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvcGFyYWxsZWwvUGFyYWxsZWxTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9wYXJhbGxlbC9QYXJhbGxlbFZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9wYXJhbGxlbC9pbnN0YWxsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvcGFyYWxsZWwvcGFyYWxsZWxWaXN1YWwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9waWUvUGllU2VyaWVzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvcGllL1BpZVZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9waWUvaW5zdGFsbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3BpZS9sYWJlbExheW91dC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3BpZS9waWVMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9yYWRhci9SYWRhclNlcmllcy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3JhZGFyL1JhZGFyVmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3JhZGFyL2JhY2t3YXJkQ29tcGF0LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvcmFkYXIvaW5zdGFsbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3JhZGFyL3JhZGFyTGF5b3V0LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvc2Fua2V5L1NhbmtleVNlcmllcy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3NhbmtleS9TYW5rZXlWaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvc2Fua2V5L2luc3RhbGwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9zYW5rZXkvc2Fua2V5TGF5b3V0LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvc2Fua2V5L3NhbmtleVZpc3VhbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3NjYXR0ZXIvU2NhdHRlclNlcmllcy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3NjYXR0ZXIvU2NhdHRlclZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9zY2F0dGVyL2luc3RhbGwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9zdW5idXJzdC9TdW5idXJzdFBpZWNlLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvc3VuYnVyc3QvU3VuYnVyc3RTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9zdW5idXJzdC9TdW5idXJzdFZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9zdW5idXJzdC9pbnN0YWxsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvc3VuYnVyc3Qvc3VuYnVyc3RBY3Rpb24uanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9zdW5idXJzdC9zdW5idXJzdExheW91dC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3N1bmJ1cnN0L3N1bmJ1cnN0VmlzdWFsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvdGhlbWVSaXZlci9UaGVtZVJpdmVyU2VyaWVzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvdGhlbWVSaXZlci9UaGVtZVJpdmVyVmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3RoZW1lUml2ZXIvaW5zdGFsbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3RoZW1lUml2ZXIvdGhlbWVSaXZlckxheW91dC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3RyZWUvVHJlZVNlcmllcy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3RyZWUvVHJlZVZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC90cmVlL2luc3RhbGwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC90cmVlL2xheW91dEhlbHBlci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3RyZWUvdHJhdmVyc2FsSGVscGVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvdHJlZS90cmVlQWN0aW9uLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvdHJlZS90cmVlTGF5b3V0LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvdHJlZS90cmVlVmlzdWFsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvdHJlZW1hcC9CcmVhZGNydW1iLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvdHJlZW1hcC9UcmVlbWFwU2VyaWVzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvdHJlZW1hcC9UcmVlbWFwVmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3RyZWVtYXAvaW5zdGFsbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3RyZWVtYXAvdHJlZW1hcEFjdGlvbi5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3RyZWVtYXAvdHJlZW1hcExheW91dC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3RyZWVtYXAvdHJlZW1hcFZpc3VhbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhbGVuZGFyL3ByZXBhcmVDdXN0b20uanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vcHJlcGFyZUN1c3RvbS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2dlby9wcmVwYXJlQ3VzdG9tLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvcG9sYXIvcHJlcGFyZUN1c3RvbS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL3NpbmdsZS9wcmVwYXJlQ3VzdG9tLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9HcmFwaC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvVHJlZS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvaGVscGVyL2xpbmtMaXN0LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZXhwb3J0L2NoYXJ0cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2xheW91dC9wb2ludHMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9wcm9jZXNzb3IvZGF0YUZpbHRlci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Byb2Nlc3Nvci9kYXRhU2FtcGxlLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9hbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL3NoYXBlL3NhdXNhZ2UuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL3ZlbmRvci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Zpc3VhbC9MZWdlbmRWaXN1YWxQcm92aWRlci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvbW9ycGhQYXRoLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRDO0FBQ2dCOztBQUU1RDtBQUNBLFNBQVMsdURBQW9CO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFP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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxpRUFBZ0I7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxrREFBVzs7QUFFYixpRUFBZSxnQkFBZ0IsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3TC9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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REFBMkQ7O0FBRTNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxFQUFFLHVEQUFXO0FBQ2IsSUFBSSx1REFBVztBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsRUFBRSx1REFBVztBQUNiLElBQUksdURBQVc7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxFQUFFLHVEQUFXO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFLHVEQUFXO0FBQ2I7QUFDQTtBQUNBLElBQUksdURBQVc7QUFDZjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLElBQUksdURB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Q0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxTQUFTLHVEQUFvQjtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7Ozs7OztBQy9UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtB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QUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FB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Q29udGVudCI6WyIvKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLy8gSW4gc29tZWhvdy4gSWYgd2UgZXhwb3J0IGxpa2Vcbi8vIGV4cG9ydCAqIGFzIExpbmVDaGFydCAnLi9jaGFydC9saW5lL2luc3RhbGwnXG4vLyBUaGUgZXhwb3J0ZWQgY29kZSB3aWxsIGJlIHRyYW5zZm9ybWVkIHRvXG4vLyBpbXBvcnQgKiBhcyBMaW5lQ2hhcnRfMSAnLi9jaGFydC9saW5lL2luc3RhbGwnOyBleHBvcnQge0xpbmVDaGFydF8xIGFzIExpbmVDaGFydH07XG4vLyBUcmVlc2hha2luZyBpbiB3ZWJwYWNrIHdpbGwgbm90IHdvcmsgZXZlbiBpZiB3ZSBjb25maWd1cmVkIHNpZGVFZmZlY3RzIHRvIGZhbHNlIGluIHBhY2thZ2UuanNvblxuXG5leHBvcnQgKiBmcm9tICcuL2xpYi9leHBvcnQvY2hhcnRzJzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQmFzZUJhclNlcmllc01vZGVsIGZyb20gJy4vQmFzZUJhclNlcmllcyc7XG5pbXBvcnQgY3JlYXRlTGlzdEZyb21BcnJheSBmcm9tICcuLi9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheSc7XG5pbXBvcnQgeyBpbmhlcml0RGVmYXVsdE9wdGlvbiB9IGZyb20gJy4uLy4uL3V0aWwvY29tcG9uZW50JztcblxudmFyIEJhclNlcmllc01vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEJhclNlcmllc01vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEJhclNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IEJhclNlcmllc01vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgQmFyU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVMaXN0RnJvbUFycmF5KHRoaXMuZ2V0U291cmNlKCksIHRoaXMsIHtcbiAgICAgIHVzZUVuY29kZURlZmF1bHRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZUludmVydGVkSW5kaWNlczogISF0aGlzLmdldCgncmVhbHRpbWVTb3J0JywgdHJ1ZSkgfHwgbnVsbFxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgQmFyU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldFByb2dyZXNzaXZlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIERvIG5vdCBzdXBwb3J0IHByb2dyZXNzaXZlIGluIG5vcm1hbCBtb2RlLlxuICAgIHJldHVybiB0aGlzLmdldCgnbGFyZ2UnKSA/IHRoaXMuZ2V0KCdwcm9ncmVzc2l2ZScpIDogZmFsc2U7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBCYXJTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0UHJvZ3Jlc3NpdmVUaHJlc2hvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRG8gbm90IHN1cHBvcnQgcHJvZ3Jlc3NpdmUgaW4gbm9ybWFsIG1vZGUuXG4gICAgdmFyIHByb2dyZXNzaXZlVGhyZXNob2xkID0gdGhpcy5nZXQoJ3Byb2dyZXNzaXZlVGhyZXNob2xkJyk7XG4gICAgdmFyIGxhcmdlVGhyZXNob2xkID0gdGhpcy5nZXQoJ2xhcmdlVGhyZXNob2xkJyk7XG5cbiAgICBpZiAobGFyZ2VUaHJlc2hvbGQgPiBwcm9ncmVzc2l2ZVRocmVzaG9sZCkge1xuICAgICAgcHJvZ3Jlc3NpdmVUaHJlc2hvbGQgPSBsYXJnZVRocmVzaG9sZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3Jlc3NpdmVUaHJlc2hvbGQ7XG4gIH07XG5cbiAgQmFyU2VyaWVzTW9kZWwucHJvdG90eXBlLmJydXNoU2VsZWN0b3IgPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBkYXRhLCBzZWxlY3RvcnMpIHtcbiAgICByZXR1cm4gc2VsZWN0b3JzLnJlY3QoZGF0YS5nZXRJdGVtTGF5b3V0KGRhdGFJbmRleCkpO1xuICB9O1xuXG4gIEJhclNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLmJhcic7XG4gIEJhclNlcmllc01vZGVsLmRlcGVuZGVuY2llcyA9IFsnZ3JpZCcsICdwb2xhciddO1xuICBCYXJTZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0gaW5oZXJpdERlZmF1bHRPcHRpb24oQmFzZUJhclNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24sIHtcbiAgICAvLyBJZiBjbGlwcGVkXG4gICAgLy8gT25seSBhdmFpbGFibGUgb24gY2FydGVzaWFuMmRcbiAgICBjbGlwOiB0cnVlLFxuICAgIHJvdW5kQ2FwOiBmYWxzZSxcbiAgICBzaG93QmFja2dyb3VuZDogZmFsc2UsXG4gICAgYmFja2dyb3VuZFN0eWxlOiB7XG4gICAgICBjb2xvcjogJ3JnYmEoMTgwLCAxODAsIDE4MCwgMC4yKScsXG4gICAgICBib3JkZXJDb2xvcjogbnVsbCxcbiAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgYm9yZGVyVHlwZTogJ3NvbGlkJyxcbiAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgIHNoYWRvd0JsdXI6IDAsXG4gICAgICBzaGFkb3dDb2xvcjogbnVsbCxcbiAgICAgIHNoYWRvd09mZnNldFg6IDAsXG4gICAgICBzaGFkb3dPZmZzZXRZOiAwLFxuICAgICAgb3BhY2l0eTogMVxuICAgIH0sXG4gICAgc2VsZWN0OiB7XG4gICAgICBpdGVtU3R5bGU6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMjEyMTIxJ1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVhbHRpbWVTb3J0OiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIEJhclNlcmllc01vZGVsO1xufShCYXNlQmFyU2VyaWVzTW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBCYXJTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgUGF0aCBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL1BhdGgnO1xuaW1wb3J0IEdyb3VwIGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvR3JvdXAnO1xuaW1wb3J0IHsgZXh0ZW5kLCBkZWZhdWx0cywgZWFjaCwgbWFwIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCB7IFJlY3QsIFNlY3RvciwgdXBkYXRlUHJvcHMsIGluaXRQcm9wcywgcmVtb3ZlRWxlbWVudFdpdGhGYWRlT3V0IH0gZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZSc7XG5pbXBvcnQgeyBlbmFibGVIb3ZlckVtcGhhc2lzLCBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcyc7XG5pbXBvcnQgeyBzZXRMYWJlbFN0eWxlLCBnZXRMYWJlbFN0YXRlc01vZGVscywgc2V0TGFiZWxWYWx1ZUFuaW1hdGlvbiB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUnO1xuaW1wb3J0IHsgdGhyb3R0bGUgfSBmcm9tICcuLi8uLi91dGlsL3Rocm90dGxlJztcbmltcG9ydCB7IGNyZWF0ZUNsaXBQYXRoIH0gZnJvbSAnLi4vaGVscGVyL2NyZWF0ZUNsaXBQYXRoRnJvbUNvb3JkU3lzJztcbmltcG9ydCBTYXVzYWdlIGZyb20gJy4uLy4uL3V0aWwvc2hhcGUvc2F1c2FnZSc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ2hhcnQnO1xuaW1wb3J0IHsgaXNDb29yZGluYXRlU3lzdGVtVHlwZSB9IGZyb20gJy4uLy4uL2Nvb3JkL0Nvb3JkaW5hdGVTeXN0ZW0nO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdExhYmVsLCBnZXREZWZhdWx0SW50ZXJwb2xhdGVkTGFiZWwgfSBmcm9tICcuLi9oZWxwZXIvbGFiZWxIZWxwZXInO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uL3V0aWwvbG9nJztcbnZhciBCQVJfQk9SREVSX1dJRFRIX1FVRVJZID0gWydpdGVtU3R5bGUnLCAnYm9yZGVyV2lkdGgnXTtcbnZhciBCQVJfQk9SREVSX1JBRElVU19RVUVSWSA9IFsnaXRlbVN0eWxlJywgJ2JvcmRlclJhZGl1cyddO1xudmFyIF9ldmVudFBvcyA9IFswLCAwXTtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuXG5mdW5jdGlvbiBnZXRDbGlwQXJlYShjb29yZCwgZGF0YSkge1xuICB2YXIgY29vcmRTeXNDbGlwQXJlYSA9IGNvb3JkLmdldEFyZWEgJiYgY29vcmQuZ2V0QXJlYSgpO1xuXG4gIGlmIChpc0Nvb3JkaW5hdGVTeXN0ZW1UeXBlKGNvb3JkLCAnY2FydGVzaWFuMmQnKSkge1xuICAgIHZhciBiYXNlQXhpcyA9IGNvb3JkLmdldEJhc2VBeGlzKCk7IC8vIFdoZW4gYm91bmRhcnlHYXAgaXMgZmFsc2Ugb3IgdXNpbmcgdGltZSBheGlzLiBiYXIgbWF5IGV4Y2VlZCB0aGUgZ3JpZC5cbiAgICAvLyBXZSBzaG91bGQgbm90IGNsaXAgdGhpcyBwYXJ0LlxuICAgIC8vIFNlZSB0ZXN0L2JhcjIuaHRtbFxuXG4gICAgaWYgKGJhc2VBeGlzLnR5cGUgIT09ICdjYXRlZ29yeScgfHwgIWJhc2VBeGlzLm9uQmFuZCkge1xuICAgICAgdmFyIGV4cGFuZFdpZHRoID0gZGF0YS5nZXRMYXlvdXQoJ2JhbmRXaWR0aCcpO1xuXG4gICAgICBpZiAoYmFzZUF4aXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgY29vcmRTeXNDbGlwQXJlYS54IC09IGV4cGFuZFdpZHRoO1xuICAgICAgICBjb29yZFN5c0NsaXBBcmVhLndpZHRoICs9IGV4cGFuZFdpZHRoICogMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvb3JkU3lzQ2xpcEFyZWEueSAtPSBleHBhbmRXaWR0aDtcbiAgICAgICAgY29vcmRTeXNDbGlwQXJlYS5oZWlnaHQgKz0gZXhwYW5kV2lkdGggKiAyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb29yZFN5c0NsaXBBcmVhO1xufVxuXG52YXIgQmFyVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhCYXJWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEJhclZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBCYXJWaWV3LnR5cGU7XG4gICAgX3RoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgQmFyVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB0aGlzLl9tb2RlbCA9IHNlcmllc01vZGVsO1xuXG4gICAgdGhpcy5fcmVtb3ZlT25SZW5kZXJlZExpc3RlbmVyKGFwaSk7XG5cbiAgICB0aGlzLl91cGRhdGVEcmF3TW9kZShzZXJpZXNNb2RlbCk7XG5cbiAgICB2YXIgY29vcmRpbmF0ZVN5c3RlbVR5cGUgPSBzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKTtcblxuICAgIGlmIChjb29yZGluYXRlU3lzdGVtVHlwZSA9PT0gJ2NhcnRlc2lhbjJkJyB8fCBjb29yZGluYXRlU3lzdGVtVHlwZSA9PT0gJ3BvbGFyJykge1xuICAgICAgdGhpcy5faXNMYXJnZURyYXcgPyB0aGlzLl9yZW5kZXJMYXJnZShzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSA6IHRoaXMuX3JlbmRlck5vcm1hbChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oJ09ubHkgY2FydGVzaWFuMmQgYW5kIHBvbGFyIHN1cHBvcnRlZCBmb3IgYmFyLicpO1xuICAgIH1cbiAgfTtcblxuICBCYXJWaWV3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFByZXBhcmVSZW5kZXIgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB0aGlzLl9jbGVhcigpO1xuXG4gICAgdGhpcy5fdXBkYXRlRHJhd01vZGUoc2VyaWVzTW9kZWwpOyAvLyBpbmNyZW1lbnRhbCBhbHNvIG5lZWQgdG8gY2xpcCwgb3RoZXJ3aXNlIG1pZ2h0IGJlIG92ZXJsb3cuXG4gICAgLy8gQnV0IG11c3Qgbm90IHNldCBjbGlwIGluIGVhY2ggZnJhbWUsIG90aGVyd2lzZSBhbGwgb2YgdGhlIGNoaWxkcmVuIHdpbGwgYmUgbWFya2VkIHJlZHJhdy5cblxuXG4gICAgdGhpcy5fdXBkYXRlTGFyZ2VDbGlwKHNlcmllc01vZGVsKTtcbiAgfTtcblxuICBCYXJWaWV3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFJlbmRlciA9IGZ1bmN0aW9uIChwYXJhbXMsIHNlcmllc01vZGVsKSB7XG4gICAgLy8gRG8gbm90IHN1cHBvcnQgcHJvZ3Jlc3NpdmUgaW4gbm9ybWFsIG1vZGUuXG4gICAgdGhpcy5faW5jcmVtZW50YWxSZW5kZXJMYXJnZShwYXJhbXMsIHNlcmllc01vZGVsKTtcbiAgfTtcblxuICBCYXJWaWV3LnByb3RvdHlwZS5fdXBkYXRlRHJhd01vZGUgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgaXNMYXJnZURyYXcgPSBzZXJpZXNNb2RlbC5waXBlbGluZUNvbnRleHQubGFyZ2U7XG5cbiAgICBpZiAodGhpcy5faXNMYXJnZURyYXcgPT0gbnVsbCB8fCBpc0xhcmdlRHJhdyAhPT0gdGhpcy5faXNMYXJnZURyYXcpIHtcbiAgICAgIHRoaXMuX2lzTGFyZ2VEcmF3ID0gaXNMYXJnZURyYXc7XG5cbiAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgfVxuICB9O1xuXG4gIEJhclZpZXcucHJvdG90eXBlLl9yZW5kZXJOb3JtYWwgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBjb29yZCA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGJhc2VBeGlzID0gY29vcmQuZ2V0QmFzZUF4aXMoKTtcbiAgICB2YXIgaXNIb3Jpem9udGFsT3JSYWRpYWw7XG5cbiAgICBpZiAoY29vcmQudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgaXNIb3Jpem9udGFsT3JSYWRpYWwgPSBiYXNlQXhpcy5pc0hvcml6b250YWwoKTtcbiAgICB9IGVsc2UgaWYgKGNvb3JkLnR5cGUgPT09ICdwb2xhcicpIHtcbiAgICAgIGlzSG9yaXpvbnRhbE9yUmFkaWFsID0gYmFzZUF4aXMuZGltID09PSAnYW5nbGUnO1xuICAgIH1cblxuICAgIHZhciBhbmltYXRpb25Nb2RlbCA9IHNlcmllc01vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpID8gc2VyaWVzTW9kZWwgOiBudWxsO1xuICAgIHZhciByZWFsdGltZVNvcnRDZmcgPSBzaG91bGRSZWFsdGltZVNvcnQoc2VyaWVzTW9kZWwsIGNvb3JkKTtcblxuICAgIGlmIChyZWFsdGltZVNvcnRDZmcpIHtcbiAgICAgIHRoaXMuX2VuYWJsZVJlYWx0aW1lU29ydChyZWFsdGltZVNvcnRDZmcsIGRhdGEsIGFwaSk7XG4gICAgfVxuXG4gICAgdmFyIG5lZWRzQ2xpcCA9IHNlcmllc01vZGVsLmdldCgnY2xpcCcsIHRydWUpIHx8IHJlYWx0aW1lU29ydENmZztcbiAgICB2YXIgY29vcmRTeXNDbGlwQXJlYSA9IGdldENsaXBBcmVhKGNvb3JkLCBkYXRhKTsgLy8gSWYgdGhlcmUgaXMgY2xpcFBhdGggY3JlYXRlZCBpbiBsYXJnZSBtb2RlLiBSZW1vdmUgaXQuXG5cbiAgICBncm91cC5yZW1vdmVDbGlwUGF0aCgpOyAvLyBXZSBkb24ndCB1c2UgY2xpcFBhdGggaW4gbm9ybWFsIG1vZGUgYmVjYXVzZSB3ZSBuZWVkcyBhIHBlcmZlY3QgYW5pbWF0aW9uXG4gICAgLy8gQW5kIGRvbid0IHdhbnQgdGhlIGxhYmVsIGFyZSBjbGlwcGVkLlxuXG4gICAgdmFyIHJvdW5kQ2FwID0gc2VyaWVzTW9kZWwuZ2V0KCdyb3VuZENhcCcsIHRydWUpO1xuICAgIHZhciBkcmF3QmFja2dyb3VuZCA9IHNlcmllc01vZGVsLmdldCgnc2hvd0JhY2tncm91bmQnLCB0cnVlKTtcbiAgICB2YXIgYmFja2dyb3VuZE1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2JhY2tncm91bmRTdHlsZScpO1xuICAgIHZhciBiYXJCb3JkZXJSYWRpdXMgPSBiYWNrZ3JvdW5kTW9kZWwuZ2V0KCdib3JkZXJSYWRpdXMnKSB8fCAwO1xuICAgIHZhciBiZ0VscyA9IFtdO1xuICAgIHZhciBvbGRCZ0VscyA9IHRoaXMuX2JhY2tncm91bmRFbHM7XG4gICAgdmFyIGlzSW5pdFNvcnQgPSBwYXlsb2FkICYmIHBheWxvYWQuaXNJbml0U29ydDtcbiAgICB2YXIgaXNDaGFuZ2VPcmRlciA9IHBheWxvYWQgJiYgcGF5bG9hZC50eXBlID09PSAnY2hhbmdlQXhpc09yZGVyJztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhY2tncm91bmQoZGF0YUluZGV4KSB7XG4gICAgICB2YXIgYmdMYXlvdXQgPSBnZXRMYXlvdXRbY29vcmQudHlwZV0oZGF0YSwgZGF0YUluZGV4KTtcbiAgICAgIHZhciBiZ0VsID0gY3JlYXRlQmFja2dyb3VuZEVsKGNvb3JkLCBpc0hvcml6b250YWxPclJhZGlhbCwgYmdMYXlvdXQpO1xuICAgICAgYmdFbC51c2VTdHlsZShiYWNrZ3JvdW5kTW9kZWwuZ2V0SXRlbVN0eWxlKCkpOyAvLyBPbmx5IGNhcnRlc2lhbjJkIHN1cHBvcnQgYm9yZGVyUmFkaXVzLlxuXG4gICAgICBpZiAoY29vcmQudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICBiZ0VsLnNldFNoYXBlKCdyJywgYmFyQm9yZGVyUmFkaXVzKTtcbiAgICAgIH1cblxuICAgICAgYmdFbHNbZGF0YUluZGV4XSA9IGJnRWw7XG4gICAgICByZXR1cm4gYmdFbDtcbiAgICB9XG5cbiAgICA7XG4gICAgZGF0YS5kaWZmKG9sZERhdGEpLmFkZChmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KTtcbiAgICAgIHZhciBsYXlvdXQgPSBnZXRMYXlvdXRbY29vcmQudHlwZV0oZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwpO1xuXG4gICAgICBpZiAoZHJhd0JhY2tncm91bmQpIHtcbiAgICAgICAgY3JlYXRlQmFja2dyb3VuZChkYXRhSW5kZXgpO1xuICAgICAgfSAvLyBJZiBkYXRhWm9vbSBpbiBmaWx0ZU1vZGU6ICdlbXB0eScsIHRoZSBiYXNlVmFsdWUgY2FuIGJlIHNldCBhcyBOYU4gaW4gXCJheGlzUHJveHlcIi5cblxuXG4gICAgICBpZiAoIWRhdGEuaGFzVmFsdWUoZGF0YUluZGV4KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0NsaXBwZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKG5lZWRzQ2xpcCkge1xuICAgICAgICAvLyBDbGlwIHdpbGwgbW9kaWZ5IHRoZSBsYXlvdXQgcGFyYW1zLlxuICAgICAgICAvLyBBbmQgcmV0dXJuIGEgYm9vbGVhbiB0byBkZXRlcm1pbmUgaWYgdGhlIHNoYXBlIGFyZSBmdWxseSBjbGlwcGVkLlxuICAgICAgICBpc0NsaXBwZWQgPSBjbGlwW2Nvb3JkLnR5cGVdKGNvb3JkU3lzQ2xpcEFyZWEsIGxheW91dCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbCA9IGVsZW1lbnRDcmVhdG9yW2Nvb3JkLnR5cGVdKHNlcmllc01vZGVsLCBkYXRhLCBkYXRhSW5kZXgsIGxheW91dCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGFuaW1hdGlvbk1vZGVsLCBiYXNlQXhpcy5tb2RlbCwgZmFsc2UsIHJvdW5kQ2FwKTtcbiAgICAgIHVwZGF0ZVN0eWxlKGVsLCBkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBzZXJpZXNNb2RlbCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGNvb3JkLnR5cGUgPT09ICdwb2xhcicpO1xuXG4gICAgICBpZiAoaXNJbml0U29ydCkge1xuICAgICAgICBlbC5hdHRyKHtcbiAgICAgICAgICBzaGFwZTogbGF5b3V0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChyZWFsdGltZVNvcnRDZmcpIHtcbiAgICAgICAgdXBkYXRlUmVhbHRpbWVBbmltYXRpb24ocmVhbHRpbWVTb3J0Q2ZnLCBhbmltYXRpb25Nb2RlbCwgZWwsIGxheW91dCwgZGF0YUluZGV4LCBpc0hvcml6b250YWxPclJhZGlhbCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRQcm9wcyhlbCwge1xuICAgICAgICAgIHNoYXBlOiBsYXlvdXRcbiAgICAgICAgfSwgc2VyaWVzTW9kZWwsIGRhdGFJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIGVsKTtcbiAgICAgIGdyb3VwLmFkZChlbCk7XG4gICAgICBlbC5pZ25vcmUgPSBpc0NsaXBwZWQ7XG4gICAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChuZXdJbmRleCk7XG4gICAgICB2YXIgbGF5b3V0ID0gZ2V0TGF5b3V0W2Nvb3JkLnR5cGVdKGRhdGEsIG5ld0luZGV4LCBpdGVtTW9kZWwpO1xuXG4gICAgICBpZiAoZHJhd0JhY2tncm91bmQpIHtcbiAgICAgICAgdmFyIGJnRWwgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKG9sZEJnRWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGJnRWwgPSBjcmVhdGVCYWNrZ3JvdW5kKG9sZEluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiZ0VsID0gb2xkQmdFbHNbb2xkSW5kZXhdO1xuICAgICAgICAgIGJnRWwudXNlU3R5bGUoYmFja2dyb3VuZE1vZGVsLmdldEl0ZW1TdHlsZSgpKTsgLy8gT25seSBjYXJ0ZXNpYW4yZCBzdXBwb3J0IGJvcmRlclJhZGl1cy5cblxuICAgICAgICAgIGlmIChjb29yZC50eXBlID09PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgICAgICBiZ0VsLnNldFNoYXBlKCdyJywgYmFyQm9yZGVyUmFkaXVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBiZ0Vsc1tuZXdJbmRleF0gPSBiZ0VsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJnTGF5b3V0ID0gZ2V0TGF5b3V0W2Nvb3JkLnR5cGVdKGRhdGEsIG5ld0luZGV4KTtcbiAgICAgICAgdmFyIHNoYXBlID0gY3JlYXRlQmFja2dyb3VuZFNoYXBlKGlzSG9yaXpvbnRhbE9yUmFkaWFsLCBiZ0xheW91dCwgY29vcmQpO1xuICAgICAgICB1cGRhdGVQcm9wcyhiZ0VsLCB7XG4gICAgICAgICAgc2hhcGU6IHNoYXBlXG4gICAgICAgIH0sIGFuaW1hdGlvbk1vZGVsLCBuZXdJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJbmRleCk7XG5cbiAgICAgIGlmICghZGF0YS5oYXNWYWx1ZShuZXdJbmRleCkpIHtcbiAgICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICAgICAgZWwgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0NsaXBwZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKG5lZWRzQ2xpcCkge1xuICAgICAgICBpc0NsaXBwZWQgPSBjbGlwW2Nvb3JkLnR5cGVdKGNvb3JkU3lzQ2xpcEFyZWEsIGxheW91dCk7XG5cbiAgICAgICAgaWYgKGlzQ2xpcHBlZCkge1xuICAgICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFlbCkge1xuICAgICAgICBlbCA9IGVsZW1lbnRDcmVhdG9yW2Nvb3JkLnR5cGVdKHNlcmllc01vZGVsLCBkYXRhLCBuZXdJbmRleCwgbGF5b3V0LCBpc0hvcml6b250YWxPclJhZGlhbCwgYW5pbWF0aW9uTW9kZWwsIGJhc2VBeGlzLm1vZGVsLCAhIWVsLCByb3VuZENhcCk7XG4gICAgICB9IC8vIE5vdCBjaGFuZ2UgYW55dGhpbmcgaWYgb25seSBvcmRlciBjaGFuZ2VkLlxuICAgICAgLy8gRXNwZWNpYWxseSBub3QgY2hhbmdlIGxhYmVsLlxuXG5cbiAgICAgIGlmICghaXNDaGFuZ2VPcmRlcikge1xuICAgICAgICB1cGRhdGVTdHlsZShlbCwgZGF0YSwgbmV3SW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBzZXJpZXNNb2RlbCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGNvb3JkLnR5cGUgPT09ICdwb2xhcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNJbml0U29ydCkge1xuICAgICAgICBlbC5hdHRyKHtcbiAgICAgICAgICBzaGFwZTogbGF5b3V0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChyZWFsdGltZVNvcnRDZmcpIHtcbiAgICAgICAgdXBkYXRlUmVhbHRpbWVBbmltYXRpb24ocmVhbHRpbWVTb3J0Q2ZnLCBhbmltYXRpb25Nb2RlbCwgZWwsIGxheW91dCwgbmV3SW5kZXgsIGlzSG9yaXpvbnRhbE9yUmFkaWFsLCB0cnVlLCBpc0NoYW5nZU9yZGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZVByb3BzKGVsLCB7XG4gICAgICAgICAgc2hhcGU6IGxheW91dFxuICAgICAgICB9LCBzZXJpZXNNb2RlbCwgbmV3SW5kZXgsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SW5kZXgsIGVsKTtcbiAgICAgIGVsLmlnbm9yZSA9IGlzQ2xpcHBlZDtcbiAgICAgIGdyb3VwLmFkZChlbCk7XG4gICAgfSkucmVtb3ZlKGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgIHZhciBlbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgpO1xuICAgICAgZWwgJiYgcmVtb3ZlRWxlbWVudFdpdGhGYWRlT3V0KGVsLCBzZXJpZXNNb2RlbCwgZGF0YUluZGV4KTtcbiAgICB9KS5leGVjdXRlKCk7XG4gICAgdmFyIGJnR3JvdXAgPSB0aGlzLl9iYWNrZ3JvdW5kR3JvdXAgfHwgKHRoaXMuX2JhY2tncm91bmRHcm91cCA9IG5ldyBHcm91cCgpKTtcbiAgICBiZ0dyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiZ0Vscy5sZW5ndGg7ICsraSkge1xuICAgICAgYmdHcm91cC5hZGQoYmdFbHNbaV0pO1xuICAgIH1cblxuICAgIGdyb3VwLmFkZChiZ0dyb3VwKTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kRWxzID0gYmdFbHM7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH07XG5cbiAgQmFyVmlldy5wcm90b3R5cGUuX3JlbmRlckxhcmdlID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLl9jbGVhcigpO1xuXG4gICAgY3JlYXRlTGFyZ2Uoc2VyaWVzTW9kZWwsIHRoaXMuZ3JvdXApO1xuXG4gICAgdGhpcy5fdXBkYXRlTGFyZ2VDbGlwKHNlcmllc01vZGVsKTtcbiAgfTtcblxuICBCYXJWaWV3LnByb3RvdHlwZS5faW5jcmVtZW50YWxSZW5kZXJMYXJnZSA9IGZ1bmN0aW9uIChwYXJhbXMsIHNlcmllc01vZGVsKSB7XG4gICAgdGhpcy5fcmVtb3ZlQmFja2dyb3VuZCgpO1xuXG4gICAgY3JlYXRlTGFyZ2Uoc2VyaWVzTW9kZWwsIHRoaXMuZ3JvdXAsIHRydWUpO1xuICB9O1xuXG4gIEJhclZpZXcucHJvdG90eXBlLl91cGRhdGVMYXJnZUNsaXAgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAvLyBVc2UgY2xpcFBhdGggaW4gbGFyZ2UgbW9kZS5cbiAgICB2YXIgY2xpcFBhdGggPSBzZXJpZXNNb2RlbC5nZXQoJ2NsaXAnLCB0cnVlKSA/IGNyZWF0ZUNsaXBQYXRoKHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0sIGZhbHNlLCBzZXJpZXNNb2RlbCkgOiBudWxsO1xuXG4gICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICB0aGlzLmdyb3VwLnNldENsaXBQYXRoKGNsaXBQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ncm91cC5yZW1vdmVDbGlwUGF0aCgpO1xuICAgIH1cbiAgfTtcblxuICBCYXJWaWV3LnByb3RvdHlwZS5fZW5hYmxlUmVhbHRpbWVTb3J0ID0gZnVuY3Rpb24gKHJlYWx0aW1lU29ydENmZywgZGF0YSwgYXBpKSB7XG4gICAgdmFyIF90aGlzID0gdGhpczsgLy8gSWYgbm8gZGF0YSBpbiB0aGUgZmlyc3QgZnJhbWUsIHdhaXQgZm9yIGRhdGEgdG8gaW5pdFNvcnRcblxuXG4gICAgaWYgKCFkYXRhLmNvdW50KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYmFzZUF4aXMgPSByZWFsdGltZVNvcnRDZmcuYmFzZUF4aXM7XG5cbiAgICBpZiAodGhpcy5faXNGaXJzdEZyYW1lKSB7XG4gICAgICB0aGlzLl9kaXNwYXRjaEluaXRTb3J0KGRhdGEsIHJlYWx0aW1lU29ydENmZywgYXBpKTtcblxuICAgICAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvcmRlck1hcHBpbmdfMSA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGVsID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGlkeCk7XG5cbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgdmFyIHNoYXBlID0gZWwuc2hhcGU7IC8vIElmIGRhdGEgaXMgTmFOLCBzaGFwZS54eHggbWF5IGJlIE5hTiwgc28gdXNlIHx8IDAgaGVyZSBpbiBjYXNlXG5cbiAgICAgICAgICByZXR1cm4gKGJhc2VBeGlzLmlzSG9yaXpvbnRhbCgpIC8vIFRoZSByZXN1bHQgc2hvdWxkIGJlIGNvbnNpc3RlbnQgd2l0aCB0aGUgaW5pdGlhbCBzb3J0IGJ5IGRhdGEgdmFsdWUuXG4gICAgICAgICAgLy8gRG8gbm90IHN1cHBvcnQgdGhlIGNhc2UgdGhhdCBib3RoIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSBleGlzdC5cbiAgICAgICAgICA/IE1hdGguYWJzKHNoYXBlLmhlaWdodCkgOiBNYXRoLmFicyhzaGFwZS53aWR0aCkpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX29uUmVuZGVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl91cGRhdGVTb3J0V2l0aGluU2FtZURhdGEoZGF0YSwgb3JkZXJNYXBwaW5nXzEsIGJhc2VBeGlzLCBhcGkpO1xuICAgICAgfTtcblxuICAgICAgYXBpLmdldFpyKCkub24oJ3JlbmRlcmVkJywgdGhpcy5fb25SZW5kZXJlZCk7XG4gICAgfVxuICB9O1xuXG4gIEJhclZpZXcucHJvdG90eXBlLl9kYXRhU29ydCA9IGZ1bmN0aW9uIChkYXRhLCBiYXNlQXhpcywgb3JkZXJNYXBwaW5nKSB7XG4gICAgdmFyIGluZm8gPSBbXTtcbiAgICBkYXRhLmVhY2goZGF0YS5tYXBEaW1lbnNpb24oYmFzZUF4aXMuZGltKSwgZnVuY3Rpb24gKG9yZGluYWxOdW1iZXIsIGRhdGFJZHgpIHtcbiAgICAgIHZhciBtYXBwZWRWYWx1ZSA9IG9yZGVyTWFwcGluZyhkYXRhSWR4KTtcbiAgICAgIG1hcHBlZFZhbHVlID0gbWFwcGVkVmFsdWUgPT0gbnVsbCA/IE5hTiA6IG1hcHBlZFZhbHVlO1xuICAgICAgaW5mby5wdXNoKHtcbiAgICAgICAgZGF0YUluZGV4OiBkYXRhSWR4LFxuICAgICAgICBtYXBwZWRWYWx1ZTogbWFwcGVkVmFsdWUsXG4gICAgICAgIG9yZGluYWxOdW1iZXI6IG9yZGluYWxOdW1iZXJcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGluZm8uc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gSWYgTmFOLCBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgbWluIHZhbC5cbiAgICAgIHJldHVybiBiLm1hcHBlZFZhbHVlIC0gYS5tYXBwZWRWYWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgb3JkaW5hbE51bWJlcnM6IG1hcChpbmZvLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5vcmRpbmFsTnVtYmVyO1xuICAgICAgfSlcbiAgICB9O1xuICB9O1xuXG4gIEJhclZpZXcucHJvdG90eXBlLl9pc09yZGVyQ2hhbmdlZFdpdGhpblNhbWVEYXRhID0gZnVuY3Rpb24gKGRhdGEsIG9yZGVyTWFwcGluZywgYmFzZUF4aXMpIHtcbiAgICB2YXIgc2NhbGUgPSBiYXNlQXhpcy5zY2FsZTtcbiAgICB2YXIgb3JkaW5hbERhdGFEaW0gPSBkYXRhLm1hcERpbWVuc2lvbihiYXNlQXhpcy5kaW0pO1xuICAgIHZhciBsYXN0VmFsdWUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgZm9yICh2YXIgdGlja051bSA9IDAsIGxlbiA9IHNjYWxlLmdldE9yZGluYWxNZXRhKCkuY2F0ZWdvcmllcy5sZW5ndGg7IHRpY2tOdW0gPCBsZW47ICsrdGlja051bSkge1xuICAgICAgdmFyIHJhd0lkeCA9IGRhdGEucmF3SW5kZXhPZihvcmRpbmFsRGF0YURpbSwgc2NhbGUuZ2V0UmF3T3JkaW5hbE51bWJlcih0aWNrTnVtKSk7XG4gICAgICB2YXIgdmFsdWUgPSByYXdJZHggPCAwIC8vIElmIHNvbWUgdGljayBoYXZlIG5vIGJhciwgdGhlIHRpY2sgd2lsbCBiZSB0cmVhdGVkIGFzIG1pbi5cbiAgICAgID8gTnVtYmVyLk1JTl9WQUxVRSAvLyBQRU5ESU5HOiBpZiBkYXRhWm9vbSBvbiBiYXNlQXhpcyBleGl0cywgaXMgaXQgYSBwZXJmb3JtYW5jZSBpc3N1ZT9cbiAgICAgIDogb3JkZXJNYXBwaW5nKGRhdGEuaW5kZXhPZlJhd0luZGV4KHJhd0lkeCkpO1xuXG4gICAgICBpZiAodmFsdWUgPiBsYXN0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgLypcbiAgICogQ29uc2lkZXIgdGhlIGNhc2Ugd2hlbiBBIGFuZCBCIGNoYW5nZWQgb3JkZXIsIHdob3NlIHJlcHJlc2VudGluZ1xuICAgKiBiYXJzIGFyZSBib3RoIG91dCBvZiBzaWdodCwgd2UgZG9uJ3Qgd2lzaCB0byB0cmlnZ2VyIHJlb3JkZXIgYWN0aW9uXG4gICAqIGFzIGxvbmcgYXMgdGhlIG9yZGVyIGluIHRoZSB2aWV3IGRvZXNuJ3QgY2hhbmdlLlxuICAgKi9cblxuXG4gIEJhclZpZXcucHJvdG90eXBlLl9pc09yZGVyRGlmZmVyZW50SW5WaWV3ID0gZnVuY3Rpb24gKG9yZGVySW5mbywgYmFzZUF4aXMpIHtcbiAgICB2YXIgc2NhbGUgPSBiYXNlQXhpcy5zY2FsZTtcbiAgICB2YXIgZXh0ZW50ID0gc2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIHRpY2tOdW0gPSBNYXRoLm1heCgwLCBleHRlbnRbMF0pO1xuICAgIHZhciB0aWNrTWF4ID0gTWF0aC5taW4oZXh0ZW50WzFdLCBzY2FsZS5nZXRPcmRpbmFsTWV0YSgpLmNhdGVnb3JpZXMubGVuZ3RoIC0gMSk7XG5cbiAgICBmb3IgKDsgdGlja051bSA8PSB0aWNrTWF4OyArK3RpY2tOdW0pIHtcbiAgICAgIGlmIChvcmRlckluZm8ub3JkaW5hbE51bWJlcnNbdGlja051bV0gIT09IHNjYWxlLmdldFJhd09yZGluYWxOdW1iZXIodGlja051bSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJhclZpZXcucHJvdG90eXBlLl91cGRhdGVTb3J0V2l0aGluU2FtZURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgb3JkZXJNYXBwaW5nLCBiYXNlQXhpcywgYXBpKSB7XG4gICAgaWYgKCF0aGlzLl9pc09yZGVyQ2hhbmdlZFdpdGhpblNhbWVEYXRhKGRhdGEsIG9yZGVyTWFwcGluZywgYmFzZUF4aXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNvcnRJbmZvID0gdGhpcy5fZGF0YVNvcnQoZGF0YSwgYmFzZUF4aXMsIG9yZGVyTWFwcGluZyk7XG5cbiAgICBpZiAodGhpcy5faXNPcmRlckRpZmZlcmVudEluVmlldyhzb3J0SW5mbywgYmFzZUF4aXMpKSB7XG4gICAgICB0aGlzLl9yZW1vdmVPblJlbmRlcmVkTGlzdGVuZXIoYXBpKTtcblxuICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ2NoYW5nZUF4aXNPcmRlcicsXG4gICAgICAgIGNvbXBvbmVudFR5cGU6IGJhc2VBeGlzLmRpbSArICdBeGlzJyxcbiAgICAgICAgYXhpc0lkOiBiYXNlQXhpcy5pbmRleCxcbiAgICAgICAgc29ydEluZm86IHNvcnRJbmZvXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgQmFyVmlldy5wcm90b3R5cGUuX2Rpc3BhdGNoSW5pdFNvcnQgPSBmdW5jdGlvbiAoZGF0YSwgcmVhbHRpbWVTb3J0Q2ZnLCBhcGkpIHtcbiAgICB2YXIgYmFzZUF4aXMgPSByZWFsdGltZVNvcnRDZmcuYmFzZUF4aXM7XG5cbiAgICB2YXIgc29ydFJlc3VsdCA9IHRoaXMuX2RhdGFTb3J0KGRhdGEsIGJhc2VBeGlzLCBmdW5jdGlvbiAoZGF0YUlkeCkge1xuICAgICAgcmV0dXJuIGRhdGEuZ2V0KGRhdGEubWFwRGltZW5zaW9uKHJlYWx0aW1lU29ydENmZy5vdGhlckF4aXMuZGltKSwgZGF0YUlkeCk7XG4gICAgfSk7XG5cbiAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2NoYW5nZUF4aXNPcmRlcicsXG4gICAgICBjb21wb25lbnRUeXBlOiBiYXNlQXhpcy5kaW0gKyAnQXhpcycsXG4gICAgICBpc0luaXRTb3J0OiB0cnVlLFxuICAgICAgYXhpc0lkOiBiYXNlQXhpcy5pbmRleCxcbiAgICAgIHNvcnRJbmZvOiBzb3J0UmVzdWx0LFxuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYXhpcyBsYWJlbCBmcm9tIHRoZSBuYXR1cmFsIGluaXRpYWwgbGF5b3V0IHRvXG4gICAgICAgIC8vIHNvcnRlZCBsYXlvdXQgc2hvdWxkIGhhcyBubyBhbmltYXRpb24uXG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgQmFyVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuX2NsZWFyKHRoaXMuX21vZGVsKTtcblxuICAgIHRoaXMuX3JlbW92ZU9uUmVuZGVyZWRMaXN0ZW5lcihhcGkpO1xuICB9O1xuXG4gIEJhclZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5fcmVtb3ZlT25SZW5kZXJlZExpc3RlbmVyKGFwaSk7XG4gIH07XG5cbiAgQmFyVmlldy5wcm90b3R5cGUuX3JlbW92ZU9uUmVuZGVyZWRMaXN0ZW5lciA9IGZ1bmN0aW9uIChhcGkpIHtcbiAgICBpZiAodGhpcy5fb25SZW5kZXJlZCkge1xuICAgICAgYXBpLmdldFpyKCkub2ZmKCdyZW5kZXJlZCcsIHRoaXMuX29uUmVuZGVyZWQpO1xuICAgICAgdGhpcy5fb25SZW5kZXJlZCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIEJhclZpZXcucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgaWYgKG1vZGVsICYmIG1vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpICYmIGRhdGEgJiYgIXRoaXMuX2lzTGFyZ2VEcmF3KSB7XG4gICAgICB0aGlzLl9yZW1vdmVCYWNrZ3JvdW5kKCk7XG5cbiAgICAgIHRoaXMuX2JhY2tncm91bmRFbHMgPSBbXTtcbiAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJlbW92ZUVsZW1lbnRXaXRoRmFkZU91dChlbCwgbW9kZWwsIGdldEVDRGF0YShlbCkuZGF0YUluZGV4KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cC5yZW1vdmVBbGwoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xuICB9O1xuXG4gIEJhclZpZXcucHJvdG90eXBlLl9yZW1vdmVCYWNrZ3JvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlKHRoaXMuX2JhY2tncm91bmRHcm91cCk7XG4gICAgdGhpcy5fYmFja2dyb3VuZEdyb3VwID0gbnVsbDtcbiAgfTtcblxuICBCYXJWaWV3LnR5cGUgPSAnYmFyJztcbiAgcmV0dXJuIEJhclZpZXc7XG59KENoYXJ0Vmlldyk7XG5cbnZhciBjbGlwID0ge1xuICBjYXJ0ZXNpYW4yZDogZnVuY3Rpb24gKGNvb3JkU3lzQm91bmRpbmdSZWN0LCBsYXlvdXQpIHtcbiAgICB2YXIgc2lnbldpZHRoID0gbGF5b3V0LndpZHRoIDwgMCA/IC0xIDogMTtcbiAgICB2YXIgc2lnbkhlaWdodCA9IGxheW91dC5oZWlnaHQgPCAwID8gLTEgOiAxOyAvLyBOZWVkcyBwb3NpdGl2ZSB3aWR0aCBhbmQgaGVpZ2h0XG5cbiAgICBpZiAoc2lnbldpZHRoIDwgMCkge1xuICAgICAgbGF5b3V0LnggKz0gbGF5b3V0LndpZHRoO1xuICAgICAgbGF5b3V0LndpZHRoID0gLWxheW91dC53aWR0aDtcbiAgICB9XG5cbiAgICBpZiAoc2lnbkhlaWdodCA8IDApIHtcbiAgICAgIGxheW91dC55ICs9IGxheW91dC5oZWlnaHQ7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gLWxheW91dC5oZWlnaHQ7XG4gICAgfVxuXG4gICAgdmFyIGNvb3JkU3lzWDIgPSBjb29yZFN5c0JvdW5kaW5nUmVjdC54ICsgY29vcmRTeXNCb3VuZGluZ1JlY3Qud2lkdGg7XG4gICAgdmFyIGNvb3JkU3lzWTIgPSBjb29yZFN5c0JvdW5kaW5nUmVjdC55ICsgY29vcmRTeXNCb3VuZGluZ1JlY3QuaGVpZ2h0O1xuICAgIHZhciB4ID0gbWF0aE1heChsYXlvdXQueCwgY29vcmRTeXNCb3VuZGluZ1JlY3QueCk7XG4gICAgdmFyIHgyID0gbWF0aE1pbihsYXlvdXQueCArIGxheW91dC53aWR0aCwgY29vcmRTeXNYMik7XG4gICAgdmFyIHkgPSBtYXRoTWF4KGxheW91dC55LCBjb29yZFN5c0JvdW5kaW5nUmVjdC55KTtcbiAgICB2YXIgeTIgPSBtYXRoTWluKGxheW91dC55ICsgbGF5b3V0LmhlaWdodCwgY29vcmRTeXNZMik7XG4gICAgdmFyIHhDbGlwcGVkID0geDIgPCB4O1xuICAgIHZhciB5Q2xpcHBlZCA9IHkyIDwgeTsgLy8gV2hlbiB4Q2xpcHBlZCBvciB5Q2xpcHBlZCwgdGhlIGVsZW1lbnQgd2lsbCBiZSBtYXJrZWQgYXMgYGlnbm9yZWAuXG4gICAgLy8gQnV0IHdlIHNob3VsZCBhbHNvIHBsYWNlIHRoZSBlbGVtZW50IGF0IHRoZSBlZGdlIG9mIHRoZSBjb29yZCBzeXMgYm91bmRpbmcgcmVjdC5cbiAgICAvLyBCZWF1c2UgaWYgZGF0YSBjaGFuZ2VkIGFuZCB0aGUgYmFyIHNob3cgYWdhaW4sIGl0cyB0cmFuc2l0aW9uIGFuaW1haXRvblxuICAgIC8vIHdpbGwgYmVnaW4gYXQgdGhpcyBwbGFjZS5cblxuICAgIGxheW91dC54ID0geENsaXBwZWQgJiYgeCA+IGNvb3JkU3lzWDIgPyB4MiA6IHg7XG4gICAgbGF5b3V0LnkgPSB5Q2xpcHBlZCAmJiB5ID4gY29vcmRTeXNZMiA/IHkyIDogeTtcbiAgICBsYXlvdXQud2lkdGggPSB4Q2xpcHBlZCA/IDAgOiB4MiAtIHg7XG4gICAgbGF5b3V0LmhlaWdodCA9IHlDbGlwcGVkID8gMCA6IHkyIC0geTsgLy8gUmV2ZXJzZSBiYWNrXG5cbiAgICBpZiAoc2lnbldpZHRoIDwgMCkge1xuICAgICAgbGF5b3V0LnggKz0gbGF5b3V0LndpZHRoO1xuICAgICAgbGF5b3V0LndpZHRoID0gLWxheW91dC53aWR0aDtcbiAgICB9XG5cbiAgICBpZiAoc2lnbkhlaWdodCA8IDApIHtcbiAgICAgIGxheW91dC55ICs9IGxheW91dC5oZWlnaHQ7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gLWxheW91dC5oZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHhDbGlwcGVkIHx8IHlDbGlwcGVkO1xuICB9LFxuICBwb2xhcjogZnVuY3Rpb24gKGNvb3JkU3lzQ2xpcEFyZWEsIGxheW91dCkge1xuICAgIHZhciBzaWduUiA9IGxheW91dC5yMCA8PSBsYXlvdXQuciA/IDEgOiAtMTsgLy8gTWFrZSBzdXJlIHIgaXMgbGFyZ2VyIHRoYW4gcjBcblxuICAgIGlmIChzaWduUiA8IDApIHtcbiAgICAgIHZhciB0bXAgPSBsYXlvdXQucjtcbiAgICAgIGxheW91dC5yID0gbGF5b3V0LnIwO1xuICAgICAgbGF5b3V0LnIwID0gdG1wO1xuICAgIH1cblxuICAgIHZhciByID0gbWF0aE1pbihsYXlvdXQuciwgY29vcmRTeXNDbGlwQXJlYS5yKTtcbiAgICB2YXIgcjAgPSBtYXRoTWF4KGxheW91dC5yMCwgY29vcmRTeXNDbGlwQXJlYS5yMCk7XG4gICAgbGF5b3V0LnIgPSByO1xuICAgIGxheW91dC5yMCA9IHIwO1xuICAgIHZhciBjbGlwcGVkID0gciAtIHIwIDwgMDsgLy8gUmV2ZXJzZSBiYWNrXG5cbiAgICBpZiAoc2lnblIgPCAwKSB7XG4gICAgICB2YXIgdG1wID0gbGF5b3V0LnI7XG4gICAgICBsYXlvdXQuciA9IGxheW91dC5yMDtcbiAgICAgIGxheW91dC5yMCA9IHRtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xpcHBlZDtcbiAgfVxufTtcbnZhciBlbGVtZW50Q3JlYXRvciA9IHtcbiAgY2FydGVzaWFuMmQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZGF0YSwgbmV3SW5kZXgsIGxheW91dCwgaXNIb3Jpem9udGFsLCBhbmltYXRpb25Nb2RlbCwgYXhpc01vZGVsLCBpc1VwZGF0ZSwgcm91bmRDYXApIHtcbiAgICB2YXIgcmVjdCA9IG5ldyBSZWN0KHtcbiAgICAgIHNoYXBlOiBleHRlbmQoe30sIGxheW91dCksXG4gICAgICB6MjogMVxuICAgIH0pO1xuICAgIHJlY3QuX19kYXRhSW5kZXggPSBuZXdJbmRleDtcbiAgICByZWN0Lm5hbWUgPSAnaXRlbSc7XG5cbiAgICBpZiAoYW5pbWF0aW9uTW9kZWwpIHtcbiAgICAgIHZhciByZWN0U2hhcGUgPSByZWN0LnNoYXBlO1xuICAgICAgdmFyIGFuaW1hdGVQcm9wZXJ0eSA9IGlzSG9yaXpvbnRhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgIHJlY3RTaGFwZVthbmltYXRlUHJvcGVydHldID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjdDtcbiAgfSxcbiAgcG9sYXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZGF0YSwgbmV3SW5kZXgsIGxheW91dCwgaXNSYWRpYWwsIGFuaW1hdGlvbk1vZGVsLCBheGlzTW9kZWwsIGlzVXBkYXRlLCByb3VuZENhcCkge1xuICAgIC8vIEtlZXAgdGhlIHNhbWUgbG9naWMgd2l0aCBiYXIgaW4gY2F0ZXNpb246IHVzZSBlbmQgdmFsdWUgdG8gY29udHJvbFxuICAgIC8vIGRpcmVjdGlvbi4gTm90aWNlIHRoYXQgaWYgY2xvY2t3aXNlIGlzIHRydWUgKGJ5IGRlZmF1bHQpLCB0aGUgc2VjdG9yXG4gICAgLy8gd2lsbCBhbHdheXMgZHJhdyBjbG9ja3dpc2VseSwgbm8gbWF0dGVyIHdoZXRoZXIgZW5kQW5nbGUgaXMgZ3JlYXRlclxuICAgIC8vIG9yIGxlc3MgdGhhbiBzdGFydEFuZ2xlLlxuICAgIHZhciBjbG9ja3dpc2UgPSBsYXlvdXQuc3RhcnRBbmdsZSA8IGxheW91dC5lbmRBbmdsZTtcbiAgICB2YXIgU2hhcGVDbGFzcyA9ICFpc1JhZGlhbCAmJiByb3VuZENhcCA/IFNhdXNhZ2UgOiBTZWN0b3I7XG4gICAgdmFyIHNlY3RvciA9IG5ldyBTaGFwZUNsYXNzKHtcbiAgICAgIHNoYXBlOiBkZWZhdWx0cyh7XG4gICAgICAgIGNsb2Nrd2lzZTogY2xvY2t3aXNlXG4gICAgICB9LCBsYXlvdXQpLFxuICAgICAgejI6IDFcbiAgICB9KTtcbiAgICBzZWN0b3IubmFtZSA9ICdpdGVtJzsgLy8gQW5pbWF0aW9uXG5cbiAgICBpZiAoYW5pbWF0aW9uTW9kZWwpIHtcbiAgICAgIHZhciBzZWN0b3JTaGFwZSA9IHNlY3Rvci5zaGFwZTtcbiAgICAgIHZhciBhbmltYXRlUHJvcGVydHkgPSBpc1JhZGlhbCA/ICdyJyA6ICdlbmRBbmdsZSc7XG4gICAgICB2YXIgYW5pbWF0ZVRhcmdldCA9IHt9O1xuICAgICAgc2VjdG9yU2hhcGVbYW5pbWF0ZVByb3BlcnR5XSA9IGlzUmFkaWFsID8gMCA6IGxheW91dC5zdGFydEFuZ2xlO1xuICAgICAgYW5pbWF0ZVRhcmdldFthbmltYXRlUHJvcGVydHldID0gbGF5b3V0W2FuaW1hdGVQcm9wZXJ0eV07XG4gICAgICAoaXNVcGRhdGUgPyB1cGRhdGVQcm9wcyA6IGluaXRQcm9wcykoc2VjdG9yLCB7XG4gICAgICAgIHNoYXBlOiBhbmltYXRlVGFyZ2V0IC8vIF9fdmFsdWU6IHR5cGVvZiBkYXRhVmFsdWUgPT09ICdzdHJpbmcnID8gcGFyc2VJbnQoZGF0YVZhbHVlLCAxMCkgOiBkYXRhVmFsdWVcblxuICAgICAgfSwgYW5pbWF0aW9uTW9kZWwpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWN0b3I7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNob3VsZFJlYWx0aW1lU29ydChzZXJpZXNNb2RlbCwgY29vcmRTeXMpIHtcbiAgdmFyIHJlYWx0aW1lU29ydE9wdGlvbiA9IHNlcmllc01vZGVsLmdldCgncmVhbHRpbWVTb3J0JywgdHJ1ZSk7XG4gIHZhciBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAocmVhbHRpbWVTb3J0T3B0aW9uKSB7XG4gICAgICBpZiAoYmFzZUF4aXMudHlwZSAhPT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICB3YXJuKCdgcmVhbHRpbWVTb3J0YCB3aWxsIG5vdCB3b3JrIGJlY2F1c2UgdGhpcyBiYXIgc2VyaWVzIGlzIG5vdCBiYXNlZCBvbiBhIGNhdGVnb3J5IGF4aXMuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb29yZFN5cy50eXBlICE9PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgIHdhcm4oJ2ByZWFsdGltZVNvcnRgIHdpbGwgbm90IHdvcmsgYmVjYXVzZSB0aGlzIGJhciBzZXJpZXMgaXMgbm90IG9uIGNhcnRlc2lhbjJkLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChyZWFsdGltZVNvcnRPcHRpb24gJiYgYmFzZUF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyAmJiBjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2VBeGlzOiBiYXNlQXhpcyxcbiAgICAgIG90aGVyQXhpczogY29vcmRTeXMuZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVhbHRpbWVBbmltYXRpb24ocmVhbHRpbWVTb3J0Q2ZnLCBzZXJpZXNBbmltYXRpb25Nb2RlbCwgZWwsIGxheW91dCwgbmV3SW5kZXgsIGlzSG9yaXpvbnRhbCwgaXNVcGRhdGUsIGlzQ2hhbmdlT3JkZXIpIHtcbiAgdmFyIHNlcmllc1RhcmdldDtcbiAgdmFyIGF4aXNUYXJnZXQ7XG5cbiAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgIGF4aXNUYXJnZXQgPSB7XG4gICAgICB4OiBsYXlvdXQueCxcbiAgICAgIHdpZHRoOiBsYXlvdXQud2lkdGhcbiAgICB9O1xuICAgIHNlcmllc1RhcmdldCA9IHtcbiAgICAgIHk6IGxheW91dC55LFxuICAgICAgaGVpZ2h0OiBsYXlvdXQuaGVpZ2h0XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBheGlzVGFyZ2V0ID0ge1xuICAgICAgeTogbGF5b3V0LnksXG4gICAgICBoZWlnaHQ6IGxheW91dC5oZWlnaHRcbiAgICB9O1xuICAgIHNlcmllc1RhcmdldCA9IHtcbiAgICAgIHg6IGxheW91dC54LFxuICAgICAgd2lkdGg6IGxheW91dC53aWR0aFxuICAgIH07XG4gIH1cblxuICBpZiAoIWlzQ2hhbmdlT3JkZXIpIHtcbiAgICAvLyBLZWVwIHRoZSBvcmlnaW5hbCBncm93dGggYW5pbWF0aW9uIGlmIG9ubHkgYXhpcyBvcmRlciBjaGFuZ2VkLlxuICAgIC8vIE5vdCBzdGFydCBhIG5ldyBhbmltYXRpb24uXG4gICAgKGlzVXBkYXRlID8gdXBkYXRlUHJvcHMgOiBpbml0UHJvcHMpKGVsLCB7XG4gICAgICBzaGFwZTogc2VyaWVzVGFyZ2V0XG4gICAgfSwgc2VyaWVzQW5pbWF0aW9uTW9kZWwsIG5ld0luZGV4LCBudWxsKTtcbiAgfVxuXG4gIHZhciBheGlzQW5pbWF0aW9uTW9kZWwgPSBzZXJpZXNBbmltYXRpb25Nb2RlbCA/IHJlYWx0aW1lU29ydENmZy5iYXNlQXhpcy5tb2RlbCA6IG51bGw7XG4gIChpc1VwZGF0ZSA/IHVwZGF0ZVByb3BzIDogaW5pdFByb3BzKShlbCwge1xuICAgIHNoYXBlOiBheGlzVGFyZ2V0XG4gIH0sIGF4aXNBbmltYXRpb25Nb2RlbCwgbmV3SW5kZXgpO1xufVxuXG52YXIgZ2V0TGF5b3V0ID0ge1xuICAvLyBpdGVtTW9kZWwgaXMgb25seSB1c2VkIHRvIGdldCBib3JkZXJXaWR0aCwgd2hpY2ggaXMgbm90IG5lZWRlZFxuICAvLyB3aGVuIGNhbGN1bGF0aW5nIGJhciBiYWNrZ3JvdW5kIGxheW91dC5cbiAgY2FydGVzaWFuMmQ6IGZ1bmN0aW9uIChkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCkge1xuICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KTtcbiAgICB2YXIgZml4ZWRMaW5lV2lkdGggPSBpdGVtTW9kZWwgPyBnZXRMaW5lV2lkdGgoaXRlbU1vZGVsLCBsYXlvdXQpIDogMDsgLy8gZml4IGxheW91dCB3aXRoIGxpbmVXaWR0aFxuXG4gICAgdmFyIHNpZ25YID0gbGF5b3V0LndpZHRoID4gMCA/IDEgOiAtMTtcbiAgICB2YXIgc2lnblkgPSBsYXlvdXQuaGVpZ2h0ID4gMCA/IDEgOiAtMTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogbGF5b3V0LnggKyBzaWduWCAqIGZpeGVkTGluZVdpZHRoIC8gMixcbiAgICAgIHk6IGxheW91dC55ICsgc2lnblkgKiBmaXhlZExpbmVXaWR0aCAvIDIsXG4gICAgICB3aWR0aDogbGF5b3V0LndpZHRoIC0gc2lnblggKiBmaXhlZExpbmVXaWR0aCxcbiAgICAgIGhlaWdodDogbGF5b3V0LmhlaWdodCAtIHNpZ25ZICogZml4ZWRMaW5lV2lkdGhcbiAgICB9O1xuICB9LFxuICBwb2xhcjogZnVuY3Rpb24gKGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsKSB7XG4gICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChkYXRhSW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBjeDogbGF5b3V0LmN4LFxuICAgICAgY3k6IGxheW91dC5jeSxcbiAgICAgIHIwOiBsYXlvdXQucjAsXG4gICAgICByOiBsYXlvdXQucixcbiAgICAgIHN0YXJ0QW5nbGU6IGxheW91dC5zdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGU6IGxheW91dC5lbmRBbmdsZVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzWmVyb09uUG9sYXIobGF5b3V0KSB7XG4gIHJldHVybiBsYXlvdXQuc3RhcnRBbmdsZSAhPSBudWxsICYmIGxheW91dC5lbmRBbmdsZSAhPSBudWxsICYmIGxheW91dC5zdGFydEFuZ2xlID09PSBsYXlvdXQuZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlKGVsLCBkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBzZXJpZXNNb2RlbCwgaXNIb3Jpem9udGFsLCBpc1BvbGFyKSB7XG4gIHZhciBzdHlsZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdzdHlsZScpO1xuXG4gIGlmICghaXNQb2xhcikge1xuICAgIGVsLnNldFNoYXBlKCdyJywgaXRlbU1vZGVsLmdldChCQVJfQk9SREVSX1JBRElVU19RVUVSWSkgfHwgMCk7XG4gIH1cblxuICBlbC51c2VTdHlsZShzdHlsZSk7XG4gIHZhciBjdXJzb3JTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdjdXJzb3InKTtcbiAgY3Vyc29yU3R5bGUgJiYgZWwuYXR0cignY3Vyc29yJywgY3Vyc29yU3R5bGUpO1xuXG4gIGlmICghaXNQb2xhcikge1xuICAgIHZhciBsYWJlbFBvc2l0aW9uT3V0c2lkZSA9IGlzSG9yaXpvbnRhbCA/IGxheW91dC5oZWlnaHQgPiAwID8gJ2JvdHRvbScgOiAndG9wJyA6IGxheW91dC53aWR0aCA+IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIHZhciBsYWJlbFN0YXRlc01vZGVscyA9IGdldExhYmVsU3RhdGVzTW9kZWxzKGl0ZW1Nb2RlbCk7XG4gICAgc2V0TGFiZWxTdHlsZShlbCwgbGFiZWxTdGF0ZXNNb2RlbHMsIHtcbiAgICAgIGxhYmVsRmV0Y2hlcjogc2VyaWVzTW9kZWwsXG4gICAgICBsYWJlbERhdGFJbmRleDogZGF0YUluZGV4LFxuICAgICAgZGVmYXVsdFRleHQ6IGdldERlZmF1bHRMYWJlbChzZXJpZXNNb2RlbC5nZXREYXRhKCksIGRhdGFJbmRleCksXG4gICAgICBpbmhlcml0Q29sb3I6IHN0eWxlLmZpbGwsXG4gICAgICBkZWZhdWx0T3BhY2l0eTogc3R5bGUub3BhY2l0eSxcbiAgICAgIGRlZmF1bHRPdXRzaWRlUG9zaXRpb246IGxhYmVsUG9zaXRpb25PdXRzaWRlXG4gICAgfSk7XG4gICAgdmFyIGxhYmVsID0gZWwuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBzZXRMYWJlbFZhbHVlQW5pbWF0aW9uKGxhYmVsLCBsYWJlbFN0YXRlc01vZGVscywgc2VyaWVzTW9kZWwuZ2V0UmF3VmFsdWUoZGF0YUluZGV4KSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZ2V0RGVmYXVsdEludGVycG9sYXRlZExhYmVsKGRhdGEsIHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBlbXBoYXNpc01vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKFsnZW1waGFzaXMnXSk7XG4gIGVuYWJsZUhvdmVyRW1waGFzaXMoZWwsIGVtcGhhc2lzTW9kZWwuZ2V0KCdmb2N1cycpLCBlbXBoYXNpc01vZGVsLmdldCgnYmx1clNjb3BlJykpO1xuICBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwoZWwsIGl0ZW1Nb2RlbCk7XG5cbiAgaWYgKGlzWmVyb09uUG9sYXIobGF5b3V0KSkge1xuICAgIGVsLnN0eWxlLmZpbGwgPSAnbm9uZSc7XG4gICAgZWwuc3R5bGUuc3Ryb2tlID0gJ25vbmUnO1xuICAgIGVhY2goZWwuc3RhdGVzLCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZS5zdHlsZSkge1xuICAgICAgICBzdGF0ZS5zdHlsZS5maWxsID0gc3RhdGUuc3R5bGUuc3Ryb2tlID0gJ25vbmUnO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59IC8vIEluIGNhc2Ugd2lkdGggb3IgaGVpZ2h0IGFyZSB0b28gc21hbGwuXG5cblxuZnVuY3Rpb24gZ2V0TGluZVdpZHRoKGl0ZW1Nb2RlbCwgcmF3TGF5b3V0KSB7XG4gIHZhciBsaW5lV2lkdGggPSBpdGVtTW9kZWwuZ2V0KEJBUl9CT1JERVJfV0lEVEhfUVVFUlkpIHx8IDA7IC8vIHdpZHRoIG9yIGhlaWdodCBtYXkgYmUgTmFOIGZvciBlbXB0eSBkYXRhXG5cbiAgdmFyIHdpZHRoID0gaXNOYU4ocmF3TGF5b3V0LndpZHRoKSA/IE51bWJlci5NQVhfVkFMVUUgOiBNYXRoLmFicyhyYXdMYXlvdXQud2lkdGgpO1xuICB2YXIgaGVpZ2h0ID0gaXNOYU4ocmF3TGF5b3V0LmhlaWdodCkgPyBOdW1iZXIuTUFYX1ZBTFVFIDogTWF0aC5hYnMocmF3TGF5b3V0LmhlaWdodCk7XG4gIHJldHVybiBNYXRoLm1pbihsaW5lV2lkdGgsIHdpZHRoLCBoZWlnaHQpO1xufVxuXG52YXIgTGFnZVBhdGhTaGFwZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExhZ2VQYXRoU2hhcGUoKSB7fVxuXG4gIHJldHVybiBMYWdlUGF0aFNoYXBlO1xufSgpO1xuXG52YXIgTGFyZ2VQYXRoID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKExhcmdlUGF0aCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBMYXJnZVBhdGgob3B0cykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gJ2xhcmdlQmFyJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICA7XG5cbiAgTGFyZ2VQYXRoLnByb3RvdHlwZS5nZXREZWZhdWx0U2hhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBMYWdlUGF0aFNoYXBlKCk7XG4gIH07XG5cbiAgTGFyZ2VQYXRoLnByb3RvdHlwZS5idWlsZFBhdGggPSBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIC8vIERyYXdpbmcgbGluZXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBkcmF3aW5nXG4gICAgLy8gYSB3aG9sZSBsaW5lIG9yIGRyYXdpbmcgcmVjdHMuXG4gICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICB2YXIgc3RhcnRQb2ludCA9IHRoaXMuX19zdGFydFBvaW50O1xuICAgIHZhciBiYXNlRGltSWR4ID0gdGhpcy5fX2Jhc2VEaW1JZHg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgc3RhcnRQb2ludFtiYXNlRGltSWR4XSA9IHBvaW50c1tpICsgYmFzZURpbUlkeF07XG4gICAgICBjdHgubW92ZVRvKHN0YXJ0UG9pbnRbMF0sIHN0YXJ0UG9pbnRbMV0pO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTGFyZ2VQYXRoO1xufShQYXRoKTtcblxuZnVuY3Rpb24gY3JlYXRlTGFyZ2Uoc2VyaWVzTW9kZWwsIGdyb3VwLCBpbmNyZW1lbnRhbCkge1xuICAvLyBUT0RPIHN1cHBvcnQgcG9sYXJcbiAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gIHZhciBzdGFydFBvaW50ID0gW107XG4gIHZhciBiYXNlRGltSWR4ID0gZGF0YS5nZXRMYXlvdXQoJ3ZhbHVlQXhpc0hvcml6b250YWwnKSA/IDEgOiAwO1xuICBzdGFydFBvaW50WzEgLSBiYXNlRGltSWR4XSA9IGRhdGEuZ2V0TGF5b3V0KCd2YWx1ZUF4aXNTdGFydCcpO1xuICB2YXIgbGFyZ2VEYXRhSW5kaWNlcyA9IGRhdGEuZ2V0TGF5b3V0KCdsYXJnZURhdGFJbmRpY2VzJyk7XG4gIHZhciBiYXJXaWR0aCA9IGRhdGEuZ2V0TGF5b3V0KCdiYXJXaWR0aCcpO1xuICB2YXIgYmFja2dyb3VuZE1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2JhY2tncm91bmRTdHlsZScpO1xuICB2YXIgZHJhd0JhY2tncm91bmQgPSBzZXJpZXNNb2RlbC5nZXQoJ3Nob3dCYWNrZ3JvdW5kJywgdHJ1ZSk7XG5cbiAgaWYgKGRyYXdCYWNrZ3JvdW5kKSB7XG4gICAgdmFyIHBvaW50cyA9IGRhdGEuZ2V0TGF5b3V0KCdsYXJnZUJhY2tncm91bmRQb2ludHMnKTtcbiAgICB2YXIgYmFja2dyb3VuZFN0YXJ0UG9pbnQgPSBbXTtcbiAgICBiYWNrZ3JvdW5kU3RhcnRQb2ludFsxIC0gYmFzZURpbUlkeF0gPSBkYXRhLmdldExheW91dCgnYmFja2dyb3VuZFN0YXJ0Jyk7XG4gICAgdmFyIGJnRWwgPSBuZXcgTGFyZ2VQYXRoKHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICB9LFxuICAgICAgaW5jcmVtZW50YWw6ICEhaW5jcmVtZW50YWwsXG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICB6MjogMFxuICAgIH0pO1xuICAgIGJnRWwuX19zdGFydFBvaW50ID0gYmFja2dyb3VuZFN0YXJ0UG9pbnQ7XG4gICAgYmdFbC5fX2Jhc2VEaW1JZHggPSBiYXNlRGltSWR4O1xuICAgIGJnRWwuX19sYXJnZURhdGFJbmRpY2VzID0gbGFyZ2VEYXRhSW5kaWNlcztcbiAgICBiZ0VsLl9fYmFyV2lkdGggPSBiYXJXaWR0aDtcbiAgICBzZXRMYXJnZUJhY2tncm91bmRTdHlsZShiZ0VsLCBiYWNrZ3JvdW5kTW9kZWwsIGRhdGEpO1xuICAgIGdyb3VwLmFkZChiZ0VsKTtcbiAgfVxuXG4gIHZhciBlbCA9IG5ldyBMYXJnZVBhdGgoe1xuICAgIHNoYXBlOiB7XG4gICAgICBwb2ludHM6IGRhdGEuZ2V0TGF5b3V0KCdsYXJnZVBvaW50cycpXG4gICAgfSxcbiAgICBpbmNyZW1lbnRhbDogISFpbmNyZW1lbnRhbFxuICB9KTtcbiAgZWwuX19zdGFydFBvaW50ID0gc3RhcnRQb2ludDtcbiAgZWwuX19iYXNlRGltSWR4ID0gYmFzZURpbUlkeDtcbiAgZWwuX19sYXJnZURhdGFJbmRpY2VzID0gbGFyZ2VEYXRhSW5kaWNlcztcbiAgZWwuX19iYXJXaWR0aCA9IGJhcldpZHRoO1xuICBncm91cC5hZGQoZWwpO1xuICBzZXRMYXJnZVN0eWxlKGVsLCBzZXJpZXNNb2RlbCwgZGF0YSk7IC8vIEVuYWJsZSB0b29sdGlwIGFuZCB1c2VyIG1vdXNlL3RvdWNoIGV2ZW50IGhhbmRsZXJzLlxuXG4gIGdldEVDRGF0YShlbCkuc2VyaWVzSW5kZXggPSBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleDtcblxuICBpZiAoIXNlcmllc01vZGVsLmdldCgnc2lsZW50JykpIHtcbiAgICBlbC5vbignbW91c2Vkb3duJywgbGFyZ2VQYXRoVXBkYXRlRGF0YUluZGV4KTtcbiAgICBlbC5vbignbW91c2Vtb3ZlJywgbGFyZ2VQYXRoVXBkYXRlRGF0YUluZGV4KTtcbiAgfVxufSAvLyBVc2UgdGhyb3R0bGUgdG8gYXZvaWQgZnJlcXVlbnRseSB0cmF2ZXJzZSB0byBmaW5kIGRhdGFJbmRleC5cblxuXG52YXIgbGFyZ2VQYXRoVXBkYXRlRGF0YUluZGV4ID0gdGhyb3R0bGUoZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBsYXJnZVBhdGggPSB0aGlzO1xuICB2YXIgZGF0YUluZGV4ID0gbGFyZ2VQYXRoRmluZERhdGFJbmRleChsYXJnZVBhdGgsIGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICBnZXRFQ0RhdGEobGFyZ2VQYXRoKS5kYXRhSW5kZXggPSBkYXRhSW5kZXggPj0gMCA/IGRhdGFJbmRleCA6IG51bGw7XG59LCAzMCwgZmFsc2UpO1xuXG5mdW5jdGlvbiBsYXJnZVBhdGhGaW5kRGF0YUluZGV4KGxhcmdlUGF0aCwgeCwgeSkge1xuICB2YXIgYmFzZURpbUlkeCA9IGxhcmdlUGF0aC5fX2Jhc2VEaW1JZHg7XG4gIHZhciB2YWx1ZURpbUlkeCA9IDEgLSBiYXNlRGltSWR4O1xuICB2YXIgcG9pbnRzID0gbGFyZ2VQYXRoLnNoYXBlLnBvaW50cztcbiAgdmFyIGxhcmdlRGF0YUluZGljZXMgPSBsYXJnZVBhdGguX19sYXJnZURhdGFJbmRpY2VzO1xuICB2YXIgYmFyV2lkdGhIYWxmID0gTWF0aC5hYnMobGFyZ2VQYXRoLl9fYmFyV2lkdGggLyAyKTtcbiAgdmFyIHN0YXJ0VmFsdWVWYWwgPSBsYXJnZVBhdGguX19zdGFydFBvaW50W3ZhbHVlRGltSWR4XTtcbiAgX2V2ZW50UG9zWzBdID0geDtcbiAgX2V2ZW50UG9zWzFdID0geTtcbiAgdmFyIHBvaW50ZXJCYXNlVmFsID0gX2V2ZW50UG9zW2Jhc2VEaW1JZHhdO1xuICB2YXIgcG9pbnRlclZhbHVlVmFsID0gX2V2ZW50UG9zWzEgLSBiYXNlRGltSWR4XTtcbiAgdmFyIGJhc2VMb3dlckJvdW5kID0gcG9pbnRlckJhc2VWYWwgLSBiYXJXaWR0aEhhbGY7XG4gIHZhciBiYXNlVXBwZXJCb3VuZCA9IHBvaW50ZXJCYXNlVmFsICsgYmFyV2lkdGhIYWxmO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoIC8gMjsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGlpID0gaSAqIDI7XG4gICAgdmFyIGJhckJhc2VWYWwgPSBwb2ludHNbaWkgKyBiYXNlRGltSWR4XTtcbiAgICB2YXIgYmFyVmFsdWVWYWwgPSBwb2ludHNbaWkgKyB2YWx1ZURpbUlkeF07XG5cbiAgICBpZiAoYmFyQmFzZVZhbCA+PSBiYXNlTG93ZXJCb3VuZCAmJiBiYXJCYXNlVmFsIDw9IGJhc2VVcHBlckJvdW5kICYmIChzdGFydFZhbHVlVmFsIDw9IGJhclZhbHVlVmFsID8gcG9pbnRlclZhbHVlVmFsID49IHN0YXJ0VmFsdWVWYWwgJiYgcG9pbnRlclZhbHVlVmFsIDw9IGJhclZhbHVlVmFsIDogcG9pbnRlclZhbHVlVmFsID49IGJhclZhbHVlVmFsICYmIHBvaW50ZXJWYWx1ZVZhbCA8PSBzdGFydFZhbHVlVmFsKSkge1xuICAgICAgcmV0dXJuIGxhcmdlRGF0YUluZGljZXNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBzZXRMYXJnZVN0eWxlKGVsLCBzZXJpZXNNb2RlbCwgZGF0YSkge1xuICB2YXIgZ2xvYmFsU3R5bGUgPSBkYXRhLmdldFZpc3VhbCgnc3R5bGUnKTtcbiAgZWwudXNlU3R5bGUoZXh0ZW5kKHt9LCBnbG9iYWxTdHlsZSkpOyAvLyBVc2Ugc3Ryb2tlIGluc3RlYWQgb2YgZmlsbC5cblxuICBlbC5zdHlsZS5maWxsID0gbnVsbDtcbiAgZWwuc3R5bGUuc3Ryb2tlID0gZ2xvYmFsU3R5bGUuZmlsbDtcbiAgZWwuc3R5bGUubGluZVdpZHRoID0gZGF0YS5nZXRMYXlvdXQoJ2JhcldpZHRoJyk7XG59XG5cbmZ1bmN0aW9uIHNldExhcmdlQmFja2dyb3VuZFN0eWxlKGVsLCBiYWNrZ3JvdW5kTW9kZWwsIGRhdGEpIHtcbiAgdmFyIGJvcmRlckNvbG9yID0gYmFja2dyb3VuZE1vZGVsLmdldCgnYm9yZGVyQ29sb3InKSB8fCBiYWNrZ3JvdW5kTW9kZWwuZ2V0KCdjb2xvcicpO1xuICB2YXIgaXRlbVN0eWxlID0gYmFja2dyb3VuZE1vZGVsLmdldEl0ZW1TdHlsZSgpO1xuICBlbC51c2VTdHlsZShpdGVtU3R5bGUpO1xuICBlbC5zdHlsZS5maWxsID0gbnVsbDtcbiAgZWwuc3R5bGUuc3Ryb2tlID0gYm9yZGVyQ29sb3I7XG4gIGVsLnN0eWxlLmxpbmVXaWR0aCA9IGRhdGEuZ2V0TGF5b3V0KCdiYXJXaWR0aCcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCYWNrZ3JvdW5kU2hhcGUoaXNIb3Jpem9udGFsT3JSYWRpYWwsIGxheW91dCwgY29vcmQpIHtcbiAgaWYgKGlzQ29vcmRpbmF0ZVN5c3RlbVR5cGUoY29vcmQsICdjYXJ0ZXNpYW4yZCcpKSB7XG4gICAgdmFyIHJlY3RTaGFwZSA9IGxheW91dDtcbiAgICB2YXIgY29vcmRMYXlvdXQgPSBjb29yZC5nZXRBcmVhKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGlzSG9yaXpvbnRhbE9yUmFkaWFsID8gcmVjdFNoYXBlLnggOiBjb29yZExheW91dC54LFxuICAgICAgeTogaXNIb3Jpem9udGFsT3JSYWRpYWwgPyBjb29yZExheW91dC55IDogcmVjdFNoYXBlLnksXG4gICAgICB3aWR0aDogaXNIb3Jpem9udGFsT3JSYWRpYWwgPyByZWN0U2hhcGUud2lkdGggOiBjb29yZExheW91dC53aWR0aCxcbiAgICAgIGhlaWdodDogaXNIb3Jpem9udGFsT3JSYWRpYWwgPyBjb29yZExheW91dC5oZWlnaHQgOiByZWN0U2hhcGUuaGVpZ2h0XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29vcmRMYXlvdXQgPSBjb29yZC5nZXRBcmVhKCk7XG4gICAgdmFyIHNlY3RvclNoYXBlID0gbGF5b3V0O1xuICAgIHJldHVybiB7XG4gICAgICBjeDogY29vcmRMYXlvdXQuY3gsXG4gICAgICBjeTogY29vcmRMYXlvdXQuY3ksXG4gICAgICByMDogaXNIb3Jpem9udGFsT3JSYWRpYWwgPyBjb29yZExheW91dC5yMCA6IHNlY3RvclNoYXBlLnIwLFxuICAgICAgcjogaXNIb3Jpem9udGFsT3JSYWRpYWwgPyBjb29yZExheW91dC5yIDogc2VjdG9yU2hhcGUucixcbiAgICAgIHN0YXJ0QW5nbGU6IGlzSG9yaXpvbnRhbE9yUmFkaWFsID8gc2VjdG9yU2hhcGUuc3RhcnRBbmdsZSA6IDAsXG4gICAgICBlbmRBbmdsZTogaXNIb3Jpem9udGFsT3JSYWRpYWwgPyBzZWN0b3JTaGFwZS5lbmRBbmdsZSA6IE1hdGguUEkgKiAyXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVCYWNrZ3JvdW5kRWwoY29vcmQsIGlzSG9yaXpvbnRhbE9yUmFkaWFsLCBsYXlvdXQpIHtcbiAgdmFyIEVsZW1lbnRDbHogPSBjb29yZC50eXBlID09PSAncG9sYXInID8gU2VjdG9yIDogUmVjdDtcbiAgcmV0dXJuIG5ldyBFbGVtZW50Q2x6KHtcbiAgICBzaGFwZTogY3JlYXRlQmFja2dyb3VuZFNoYXBlKGlzSG9yaXpvbnRhbE9yUmFkaWFsLCBsYXlvdXQsIGNvb3JkKSxcbiAgICBzaWxlbnQ6IHRydWUsXG4gICAgejI6IDBcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhclZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcyc7XG5pbXBvcnQgY3JlYXRlTGlzdEZyb21BcnJheSBmcm9tICcuLi9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheSc7XG5cbnZhciBCYXNlQmFyU2VyaWVzTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQmFzZUJhclNlcmllc01vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEJhc2VCYXJTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBCYXNlQmFyU2VyaWVzTW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBCYXNlQmFyU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIHJldHVybiBjcmVhdGVMaXN0RnJvbUFycmF5KHRoaXMuZ2V0U291cmNlKCksIHRoaXMsIHtcbiAgICAgIHVzZUVuY29kZURlZmF1bHRlcjogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIEJhc2VCYXJTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0TWFya2VyUG9zaXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgY29vcmRTeXMgPSB0aGlzLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICBpZiAoY29vcmRTeXMpIHtcbiAgICAgIC8vIFBFTkRJTkcgaWYgY2xhbXAgP1xuICAgICAgdmFyIHB0ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoY29vcmRTeXMuY2xhbXBEYXRhKHZhbHVlKSk7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgdmFyIG9mZnNldCA9IGRhdGEuZ2V0TGF5b3V0KCdvZmZzZXQnKTtcbiAgICAgIHZhciBzaXplID0gZGF0YS5nZXRMYXlvdXQoJ3NpemUnKTtcbiAgICAgIHZhciBvZmZzZXRJbmRleCA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCkuaXNIb3Jpem9udGFsKCkgPyAwIDogMTtcbiAgICAgIHB0W29mZnNldEluZGV4XSArPSBvZmZzZXQgKyBzaXplIC8gMjtcbiAgICAgIHJldHVybiBwdDtcbiAgICB9XG5cbiAgICByZXR1cm4gW05hTiwgTmFOXTtcbiAgfTtcblxuICBCYXNlQmFyU2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMuX19iYXNlX2Jhcl9fJztcbiAgQmFzZUJhclNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgY29vcmRpbmF0ZVN5c3RlbTogJ2NhcnRlc2lhbjJkJyxcbiAgICBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG4gICAgLy8gc3RhY2s6IG51bGxcbiAgICAvLyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAvLyB4QXhpc0luZGV4OiAwLFxuICAgIC8vIHlBeGlzSW5kZXg6IDAsXG4gICAgYmFyTWluSGVpZ2h0OiAwLFxuICAgIGJhck1pbkFuZ2xlOiAwLFxuICAgIC8vIGN1cnNvcjogbnVsbCxcbiAgICBsYXJnZTogZmFsc2UsXG4gICAgbGFyZ2VUaHJlc2hvbGQ6IDQwMCxcbiAgICBwcm9ncmVzc2l2ZTogM2UzLFxuICAgIHByb2dyZXNzaXZlQ2h1bmtNb2RlOiAnbW9kJ1xuICB9O1xuICByZXR1cm4gQmFzZUJhclNlcmllc01vZGVsO1xufShTZXJpZXNNb2RlbCk7XG5cblNlcmllc01vZGVsLnJlZ2lzdGVyQ2xhc3MoQmFzZUJhclNlcmllc01vZGVsKTtcbmV4cG9ydCBkZWZhdWx0IEJhc2VCYXJTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQmFzZUJhclNlcmllc01vZGVsIGZyb20gJy4vQmFzZUJhclNlcmllcyc7XG5pbXBvcnQgeyBpbmhlcml0RGVmYXVsdE9wdGlvbiB9IGZyb20gJy4uLy4uL3V0aWwvY29tcG9uZW50JztcblxudmFyIFBpY3RvcmlhbEJhclNlcmllc01vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBpY3RvcmlhbEJhclNlcmllc01vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFBpY3RvcmlhbEJhclNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IFBpY3RvcmlhbEJhclNlcmllc01vZGVsLnR5cGU7XG4gICAgX3RoaXMuaGFzU3ltYm9sVmlzdWFsID0gdHJ1ZTtcbiAgICBfdGhpcy5kZWZhdWx0U3ltYm9sID0gJ3JvdW5kUmVjdCc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUGljdG9yaWFsQmFyU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIC8vIERpc2FibGUgc3RhY2suXG4gICAgb3B0aW9uLnN0YWNrID0gbnVsbDtcbiAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIFBpY3RvcmlhbEJhclNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLnBpY3RvcmlhbEJhcic7XG4gIFBpY3RvcmlhbEJhclNlcmllc01vZGVsLmRlcGVuZGVuY2llcyA9IFsnZ3JpZCddO1xuICBQaWN0b3JpYWxCYXJTZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0gaW5oZXJpdERlZmF1bHRPcHRpb24oQmFzZUJhclNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24sIHtcbiAgICBzeW1ib2w6ICdjaXJjbGUnLFxuICAgIHN5bWJvbFNpemU6IG51bGwsXG4gICAgc3ltYm9sUm90YXRlOiBudWxsLFxuICAgIHN5bWJvbFBvc2l0aW9uOiBudWxsLFxuICAgIHN5bWJvbE9mZnNldDogbnVsbCxcbiAgICBzeW1ib2xNYXJnaW46IG51bGwsXG4gICAgc3ltYm9sUmVwZWF0OiBmYWxzZSxcbiAgICBzeW1ib2xSZXBlYXREaXJlY3Rpb246ICdlbmQnLFxuICAgIHN5bWJvbENsaXA6IGZhbHNlLFxuICAgIHN5bWJvbEJvdW5kaW5nRGF0YTogbnVsbCxcbiAgICBzeW1ib2xQYXR0ZXJuU2l6ZTogNDAwLFxuICAgIGJhckdhcDogJy0xMDAlJyxcbiAgICAvLyB6IGNhbiBiZSBzZXQgaW4gZGF0YSBpdGVtLCB3aGljaCBpcyB6MiBhY3R1YWxseS5cbiAgICAvLyBEaXNhYmxlIHByb2dyZXNzaXZlXG4gICAgcHJvZ3Jlc3NpdmU6IDAsXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIC8vIEJ5IGRlZmF1bHQgcGljdG9yaWFsQmFyIGRvIG5vdCBob3ZlciBzY2FsZS4gSG92ZXIgc2NhbGUgaXMgbm90IHN1aXRhYmxlXG4gICAgICAvLyBmb3IgdGhlIGNhc2UgdGhhdCBib3RoIGhhcyBmb3JlZ3JvdW5kIGFuZCBiYWNrZ3JvdW5kLlxuICAgICAgc2NhbGU6IGZhbHNlXG4gICAgfSxcbiAgICBzZWxlY3Q6IHtcbiAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICBib3JkZXJDb2xvcjogJyMyMTIxMjEnXG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFBpY3RvcmlhbEJhclNlcmllc01vZGVsO1xufShCYXNlQmFyU2VyaWVzTW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBQaWN0b3JpYWxCYXJTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCB7IGVuYWJsZUhvdmVyRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcyc7XG5pbXBvcnQgeyBjcmVhdGVTeW1ib2wgfSBmcm9tICcuLi8uLi91dGlsL3N5bWJvbCc7XG5pbXBvcnQgeyBwYXJzZVBlcmNlbnQsIGlzTnVtZXJpYyB9IGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyJztcbmltcG9ydCBDaGFydFZpZXcgZnJvbSAnLi4vLi4vdmlldy9DaGFydCc7XG5pbXBvcnQgeyBnZXREZWZhdWx0TGFiZWwgfSBmcm9tICcuLi9oZWxwZXIvbGFiZWxIZWxwZXInO1xuaW1wb3J0IHsgc2V0TGFiZWxTdHlsZSwgZ2V0TGFiZWxTdGF0ZXNNb2RlbHMgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlJztcbmltcG9ydCBaUkltYWdlIGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlJztcbnZhciBCQVJfQk9SREVSX1dJRFRIX1FVRVJZID0gWydpdGVtU3R5bGUnLCAnYm9yZGVyV2lkdGgnXTsgLy8gaW5kZXg6ICtpc0hvcml6b250YWxcblxudmFyIExBWU9VVF9BVFRSUyA9IFt7XG4gIHh5OiAneCcsXG4gIHdoOiAnd2lkdGgnLFxuICBpbmRleDogMCxcbiAgcG9zRGVzYzogWydsZWZ0JywgJ3JpZ2h0J11cbn0sIHtcbiAgeHk6ICd5JyxcbiAgd2g6ICdoZWlnaHQnLFxuICBpbmRleDogMSxcbiAgcG9zRGVzYzogWyd0b3AnLCAnYm90dG9tJ11cbn1dO1xudmFyIHBhdGhGb3JMaW5lV2lkdGggPSBuZXcgZ3JhcGhpYy5DaXJjbGUoKTtcblxudmFyIFBpY3RvcmlhbEJhclZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUGljdG9yaWFsQmFyVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBQaWN0b3JpYWxCYXJWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IFBpY3RvcmlhbEJhclZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBQaWN0b3JpYWxCYXJWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBiYXNlQXhpcyA9IGNhcnRlc2lhbi5nZXRCYXNlQXhpcygpO1xuICAgIHZhciBpc0hvcml6b250YWwgPSBiYXNlQXhpcy5pc0hvcml6b250YWwoKTtcbiAgICB2YXIgY29vcmRTeXNSZWN0ID0gY2FydGVzaWFuLm1hc3Rlci5nZXRSZWN0KCk7XG4gICAgdmFyIG9wdCA9IHtcbiAgICAgIGVjU2l6ZToge1xuICAgICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgICB9LFxuICAgICAgc2VyaWVzTW9kZWw6IHNlcmllc01vZGVsLFxuICAgICAgY29vcmRTeXM6IGNhcnRlc2lhbixcbiAgICAgIGNvb3JkU3lzRXh0ZW50OiBbW2Nvb3JkU3lzUmVjdC54LCBjb29yZFN5c1JlY3QueCArIGNvb3JkU3lzUmVjdC53aWR0aF0sIFtjb29yZFN5c1JlY3QueSwgY29vcmRTeXNSZWN0LnkgKyBjb29yZFN5c1JlY3QuaGVpZ2h0XV0sXG4gICAgICBpc0hvcml6b250YWw6IGlzSG9yaXpvbnRhbCxcbiAgICAgIHZhbHVlRGltOiBMQVlPVVRfQVRUUlNbK2lzSG9yaXpvbnRhbF0sXG4gICAgICBjYXRlZ29yeURpbTogTEFZT1VUX0FUVFJTWzEgLSAraXNIb3Jpem9udGFsXVxuICAgIH07XG4gICAgZGF0YS5kaWZmKG9sZERhdGEpLmFkZChmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICBpZiAoIWRhdGEuaGFzVmFsdWUoZGF0YUluZGV4KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVtTW9kZWwgPSBnZXRJdGVtTW9kZWwoZGF0YSwgZGF0YUluZGV4KTtcbiAgICAgIHZhciBzeW1ib2xNZXRhID0gZ2V0U3ltYm9sTWV0YShkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgb3B0KTtcbiAgICAgIHZhciBiYXIgPSBjcmVhdGVCYXIoZGF0YSwgb3B0LCBzeW1ib2xNZXRhKTtcbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIGJhcik7XG4gICAgICBncm91cC5hZGQoYmFyKTtcbiAgICAgIHVwZGF0ZUNvbW1vbihiYXIsIG9wdCwgc3ltYm9sTWV0YSk7XG4gICAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgICAgIHZhciBiYXIgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSW5kZXgpO1xuXG4gICAgICBpZiAoIWRhdGEuaGFzVmFsdWUobmV3SW5kZXgpKSB7XG4gICAgICAgIGdyb3VwLnJlbW92ZShiYXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVtTW9kZWwgPSBnZXRJdGVtTW9kZWwoZGF0YSwgbmV3SW5kZXgpO1xuICAgICAgdmFyIHN5bWJvbE1ldGEgPSBnZXRTeW1ib2xNZXRhKGRhdGEsIG5ld0luZGV4LCBpdGVtTW9kZWwsIG9wdCk7XG4gICAgICB2YXIgcGljdG9yaWFsU2hhcGVTdHIgPSBnZXRTaGFwZVN0cihkYXRhLCBzeW1ib2xNZXRhKTtcblxuICAgICAgaWYgKGJhciAmJiBwaWN0b3JpYWxTaGFwZVN0ciAhPT0gYmFyLl9fcGljdG9yaWFsU2hhcGVTdHIpIHtcbiAgICAgICAgZ3JvdXAucmVtb3ZlKGJhcik7XG4gICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJbmRleCwgbnVsbCk7XG4gICAgICAgIGJhciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChiYXIpIHtcbiAgICAgICAgdXBkYXRlQmFyKGJhciwgb3B0LCBzeW1ib2xNZXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhciA9IGNyZWF0ZUJhcihkYXRhLCBvcHQsIHN5bWJvbE1ldGEsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SW5kZXgsIGJhcik7XG4gICAgICBiYXIuX19waWN0b3JpYWxTeW1ib2xNZXRhID0gc3ltYm9sTWV0YTsgLy8gQWRkIGJhY2tcblxuICAgICAgZ3JvdXAuYWRkKGJhcik7XG4gICAgICB1cGRhdGVDb21tb24oYmFyLCBvcHQsIHN5bWJvbE1ldGEpO1xuICAgIH0pLnJlbW92ZShmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICB2YXIgYmFyID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCk7XG4gICAgICBiYXIgJiYgcmVtb3ZlQmFyKG9sZERhdGEsIGRhdGFJbmRleCwgYmFyLl9fcGljdG9yaWFsU3ltYm9sTWV0YS5hbmltYXRpb25Nb2RlbCwgYmFyKTtcbiAgICB9KS5leGVjdXRlKCk7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXA7XG4gIH07XG5cbiAgUGljdG9yaWFsQmFyVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgaWYgKGVjTW9kZWwuZ2V0KCdhbmltYXRpb24nKSkge1xuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoYmFyKSB7XG4gICAgICAgICAgcmVtb3ZlQmFyKGRhdGEsIGdldEVDRGF0YShiYXIpLmRhdGFJbmRleCwgZWNNb2RlbCwgYmFyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIH1cbiAgfTtcblxuICBQaWN0b3JpYWxCYXJWaWV3LnR5cGUgPSAncGljdG9yaWFsQmFyJztcbiAgcmV0dXJuIFBpY3RvcmlhbEJhclZpZXc7XG59KENoYXJ0Vmlldyk7IC8vIFNldCBvciBjYWxjdWxhdGUgZGVmYXVsdCB2YWx1ZSBhYm91dCBzeW1ib2wsIGFuZCBjYWxjdWxhdGUgbGF5b3V0IGluZm8uXG5cblxuZnVuY3Rpb24gZ2V0U3ltYm9sTWV0YShkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgb3B0KSB7XG4gIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KTtcbiAgdmFyIHN5bWJvbFJlcGVhdCA9IGl0ZW1Nb2RlbC5nZXQoJ3N5bWJvbFJlcGVhdCcpO1xuICB2YXIgc3ltYm9sQ2xpcCA9IGl0ZW1Nb2RlbC5nZXQoJ3N5bWJvbENsaXAnKTtcbiAgdmFyIHN5bWJvbFBvc2l0aW9uID0gaXRlbU1vZGVsLmdldCgnc3ltYm9sUG9zaXRpb24nKSB8fCAnc3RhcnQnO1xuICB2YXIgc3ltYm9sUm90YXRlID0gaXRlbU1vZGVsLmdldCgnc3ltYm9sUm90YXRlJyk7XG4gIHZhciByb3RhdGlvbiA9IChzeW1ib2xSb3RhdGUgfHwgMCkgKiBNYXRoLlBJIC8gMTgwIHx8IDA7XG4gIHZhciBzeW1ib2xQYXR0ZXJuU2l6ZSA9IGl0ZW1Nb2RlbC5nZXQoJ3N5bWJvbFBhdHRlcm5TaXplJykgfHwgMjtcbiAgdmFyIGlzQW5pbWF0aW9uRW5hYmxlZCA9IGl0ZW1Nb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKTtcbiAgdmFyIHN5bWJvbE1ldGEgPSB7XG4gICAgZGF0YUluZGV4OiBkYXRhSW5kZXgsXG4gICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgaXRlbU1vZGVsOiBpdGVtTW9kZWwsXG4gICAgc3ltYm9sVHlwZTogZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ3N5bWJvbCcpIHx8ICdjaXJjbGUnLFxuICAgIHN0eWxlOiBkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4LCAnc3R5bGUnKSxcbiAgICBzeW1ib2xDbGlwOiBzeW1ib2xDbGlwLFxuICAgIHN5bWJvbFJlcGVhdDogc3ltYm9sUmVwZWF0LFxuICAgIHN5bWJvbFJlcGVhdERpcmVjdGlvbjogaXRlbU1vZGVsLmdldCgnc3ltYm9sUmVwZWF0RGlyZWN0aW9uJyksXG4gICAgc3ltYm9sUGF0dGVyblNpemU6IHN5bWJvbFBhdHRlcm5TaXplLFxuICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICBhbmltYXRpb25Nb2RlbDogaXNBbmltYXRpb25FbmFibGVkID8gaXRlbU1vZGVsIDogbnVsbCxcbiAgICBob3ZlclNjYWxlOiBpc0FuaW1hdGlvbkVuYWJsZWQgJiYgaXRlbU1vZGVsLmdldChbJ2VtcGhhc2lzJywgJ3NjYWxlJ10pLFxuICAgIHoyOiBpdGVtTW9kZWwuZ2V0U2hhbGxvdygneicsIHRydWUpIHx8IDBcbiAgfTtcbiAgcHJlcGFyZUJhckxlbmd0aChpdGVtTW9kZWwsIHN5bWJvbFJlcGVhdCwgbGF5b3V0LCBvcHQsIHN5bWJvbE1ldGEpO1xuICBwcmVwYXJlU3ltYm9sU2l6ZShkYXRhLCBkYXRhSW5kZXgsIGxheW91dCwgc3ltYm9sUmVwZWF0LCBzeW1ib2xDbGlwLCBzeW1ib2xNZXRhLmJvdW5kaW5nTGVuZ3RoLCBzeW1ib2xNZXRhLnB4U2lnbiwgc3ltYm9sUGF0dGVyblNpemUsIG9wdCwgc3ltYm9sTWV0YSk7XG4gIHByZXBhcmVMaW5lV2lkdGgoaXRlbU1vZGVsLCBzeW1ib2xNZXRhLnN5bWJvbFNjYWxlLCByb3RhdGlvbiwgb3B0LCBzeW1ib2xNZXRhKTtcbiAgdmFyIHN5bWJvbFNpemUgPSBzeW1ib2xNZXRhLnN5bWJvbFNpemU7XG4gIHZhciBzeW1ib2xPZmZzZXQgPSBpdGVtTW9kZWwuZ2V0KCdzeW1ib2xPZmZzZXQnKTtcblxuICBpZiAoenJVdGlsLmlzQXJyYXkoc3ltYm9sT2Zmc2V0KSkge1xuICAgIHN5bWJvbE9mZnNldCA9IFtwYXJzZVBlcmNlbnQoc3ltYm9sT2Zmc2V0WzBdLCBzeW1ib2xTaXplWzBdKSwgcGFyc2VQZXJjZW50KHN5bWJvbE9mZnNldFsxXSwgc3ltYm9sU2l6ZVsxXSldO1xuICB9XG5cbiAgcHJlcGFyZUxheW91dEluZm8oaXRlbU1vZGVsLCBzeW1ib2xTaXplLCBsYXlvdXQsIHN5bWJvbFJlcGVhdCwgc3ltYm9sQ2xpcCwgc3ltYm9sT2Zmc2V0LCBzeW1ib2xQb3NpdGlvbiwgc3ltYm9sTWV0YS52YWx1ZUxpbmVXaWR0aCwgc3ltYm9sTWV0YS5ib3VuZGluZ0xlbmd0aCwgc3ltYm9sTWV0YS5yZXBlYXRDdXRMZW5ndGgsIG9wdCwgc3ltYm9sTWV0YSk7XG4gIHJldHVybiBzeW1ib2xNZXRhO1xufSAvLyBiYXIgbGVuZ3RoIGNhbiBiZSBuZWdhdGl2ZS5cblxuXG5mdW5jdGlvbiBwcmVwYXJlQmFyTGVuZ3RoKGl0ZW1Nb2RlbCwgc3ltYm9sUmVwZWF0LCBsYXlvdXQsIG9wdCwgb3V0cHV0U3ltYm9sTWV0YSkge1xuICB2YXIgdmFsdWVEaW0gPSBvcHQudmFsdWVEaW07XG4gIHZhciBzeW1ib2xCb3VuZGluZ0RhdGEgPSBpdGVtTW9kZWwuZ2V0KCdzeW1ib2xCb3VuZGluZ0RhdGEnKTtcbiAgdmFyIHZhbHVlQXhpcyA9IG9wdC5jb29yZFN5cy5nZXRPdGhlckF4aXMob3B0LmNvb3JkU3lzLmdldEJhc2VBeGlzKCkpO1xuICB2YXIgemVyb1B4ID0gdmFsdWVBeGlzLnRvR2xvYmFsQ29vcmQodmFsdWVBeGlzLmRhdGFUb0Nvb3JkKDApKTtcbiAgdmFyIHB4U2lnbklkeCA9IDEgLSArKGxheW91dFt2YWx1ZURpbS53aF0gPD0gMCk7XG4gIHZhciBib3VuZGluZ0xlbmd0aDtcblxuICBpZiAoenJVdGlsLmlzQXJyYXkoc3ltYm9sQm91bmRpbmdEYXRhKSkge1xuICAgIHZhciBzeW1ib2xCb3VuZGluZ0V4dGVudCA9IFtjb252ZXJ0VG9Db29yZE9uQXhpcyh2YWx1ZUF4aXMsIHN5bWJvbEJvdW5kaW5nRGF0YVswXSkgLSB6ZXJvUHgsIGNvbnZlcnRUb0Nvb3JkT25BeGlzKHZhbHVlQXhpcywgc3ltYm9sQm91bmRpbmdEYXRhWzFdKSAtIHplcm9QeF07XG4gICAgc3ltYm9sQm91bmRpbmdFeHRlbnRbMV0gPCBzeW1ib2xCb3VuZGluZ0V4dGVudFswXSAmJiBzeW1ib2xCb3VuZGluZ0V4dGVudC5yZXZlcnNlKCk7XG4gICAgYm91bmRpbmdMZW5ndGggPSBzeW1ib2xCb3VuZGluZ0V4dGVudFtweFNpZ25JZHhdO1xuICB9IGVsc2UgaWYgKHN5bWJvbEJvdW5kaW5nRGF0YSAhPSBudWxsKSB7XG4gICAgYm91bmRpbmdMZW5ndGggPSBjb252ZXJ0VG9Db29yZE9uQXhpcyh2YWx1ZUF4aXMsIHN5bWJvbEJvdW5kaW5nRGF0YSkgLSB6ZXJvUHg7XG4gIH0gZWxzZSBpZiAoc3ltYm9sUmVwZWF0KSB7XG4gICAgYm91bmRpbmdMZW5ndGggPSBvcHQuY29vcmRTeXNFeHRlbnRbdmFsdWVEaW0uaW5kZXhdW3B4U2lnbklkeF0gLSB6ZXJvUHg7XG4gIH0gZWxzZSB7XG4gICAgYm91bmRpbmdMZW5ndGggPSBsYXlvdXRbdmFsdWVEaW0ud2hdO1xuICB9XG5cbiAgb3V0cHV0U3ltYm9sTWV0YS5ib3VuZGluZ0xlbmd0aCA9IGJvdW5kaW5nTGVuZ3RoO1xuXG4gIGlmIChzeW1ib2xSZXBlYXQpIHtcbiAgICBvdXRwdXRTeW1ib2xNZXRhLnJlcGVhdEN1dExlbmd0aCA9IGxheW91dFt2YWx1ZURpbS53aF07XG4gIH1cblxuICBvdXRwdXRTeW1ib2xNZXRhLnB4U2lnbiA9IGJvdW5kaW5nTGVuZ3RoID4gMCA/IDEgOiBib3VuZGluZ0xlbmd0aCA8IDAgPyAtMSA6IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb0Nvb3JkT25BeGlzKGF4aXMsIHZhbHVlKSB7XG4gIHJldHVybiBheGlzLnRvR2xvYmFsQ29vcmQoYXhpcy5kYXRhVG9Db29yZChheGlzLnNjYWxlLnBhcnNlKHZhbHVlKSkpO1xufSAvLyBTdXBwb3J0IFsnMTAwJScsICcxMDAlJ11cblxuXG5mdW5jdGlvbiBwcmVwYXJlU3ltYm9sU2l6ZShkYXRhLCBkYXRhSW5kZXgsIGxheW91dCwgc3ltYm9sUmVwZWF0LCBzeW1ib2xDbGlwLCBib3VuZGluZ0xlbmd0aCwgcHhTaWduLCBzeW1ib2xQYXR0ZXJuU2l6ZSwgb3B0LCBvdXRwdXRTeW1ib2xNZXRhKSB7XG4gIHZhciB2YWx1ZURpbSA9IG9wdC52YWx1ZURpbTtcbiAgdmFyIGNhdGVnb3J5RGltID0gb3B0LmNhdGVnb3J5RGltO1xuICB2YXIgY2F0ZWdvcnlTaXplID0gTWF0aC5hYnMobGF5b3V0W2NhdGVnb3J5RGltLndoXSk7XG4gIHZhciBzeW1ib2xTaXplID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ3N5bWJvbFNpemUnKTtcbiAgdmFyIHBhcnNlZFN5bWJvbFNpemU7XG5cbiAgaWYgKHpyVXRpbC5pc0FycmF5KHN5bWJvbFNpemUpKSB7XG4gICAgcGFyc2VkU3ltYm9sU2l6ZSA9IHN5bWJvbFNpemUuc2xpY2UoKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3ltYm9sU2l6ZSA9PSBudWxsKSB7XG4gICAgICAvLyB3aWxsIHBhcnNlIHRvIG51bWJlciBiZWxvd1xuICAgICAgcGFyc2VkU3ltYm9sU2l6ZSA9IFsnMTAwJScsICcxMDAlJ107XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZFN5bWJvbFNpemUgPSBbc3ltYm9sU2l6ZSwgc3ltYm9sU2l6ZV07XG4gICAgfVxuICB9IC8vIE5vdGU6IHBlcmNlbnRhZ2Ugc3ltYm9sU2l6ZSAobGlrZSAnMTAwJScpIGRvIG5vdCBjb25zaWRlciBsaW5lV2lkdGgsIGJlY2F1c2UgaXQgaXNcbiAgLy8gdG8gY29tcGxpY2F0ZWQgdG8gY2FsY3VsYXRlIHJlYWwgcGVyY2VudCB2YWx1ZSBpZiBjb25zaWRlcmluZyBzY2FsZWQgbGluZVdpZHRoLlxuICAvLyBTbyB0aGUgYWN0dWFsIHNpemUgd2lsbCBiaWdnZXIgdGhhbiBsYXlvdXQgc2l6ZSBpZiBsaW5lV2lkdGggaXMgYmlnZ2VyIHRoYW4gemVybyxcbiAgLy8gd2hpY2ggY2FuIGJlIHRvbGVyYXRlZCBpbiBwaWN0b3JpYWwgY2hhcnQuXG5cblxuICBwYXJzZWRTeW1ib2xTaXplW2NhdGVnb3J5RGltLmluZGV4XSA9IHBhcnNlUGVyY2VudChwYXJzZWRTeW1ib2xTaXplW2NhdGVnb3J5RGltLmluZGV4XSwgY2F0ZWdvcnlTaXplKTtcbiAgcGFyc2VkU3ltYm9sU2l6ZVt2YWx1ZURpbS5pbmRleF0gPSBwYXJzZVBlcmNlbnQocGFyc2VkU3ltYm9sU2l6ZVt2YWx1ZURpbS5pbmRleF0sIHN5bWJvbFJlcGVhdCA/IGNhdGVnb3J5U2l6ZSA6IE1hdGguYWJzKGJvdW5kaW5nTGVuZ3RoKSk7XG4gIG91dHB1dFN5bWJvbE1ldGEuc3ltYm9sU2l6ZSA9IHBhcnNlZFN5bWJvbFNpemU7IC8vIElmIHggb3IgeSBpcyBsZXNzIHRoYW4gemVybywgc2hvdyByZXZlcnNlZCBzaGFwZS5cblxuICB2YXIgc3ltYm9sU2NhbGUgPSBvdXRwdXRTeW1ib2xNZXRhLnN5bWJvbFNjYWxlID0gW3BhcnNlZFN5bWJvbFNpemVbMF0gLyBzeW1ib2xQYXR0ZXJuU2l6ZSwgcGFyc2VkU3ltYm9sU2l6ZVsxXSAvIHN5bWJvbFBhdHRlcm5TaXplXTsgLy8gRm9sbG93IGNvbnZlbnRpb24sICdyaWdodCcgYW5kICd0b3AnIGlzIHRoZSBub3JtYWwgc2NhbGUuXG5cbiAgc3ltYm9sU2NhbGVbdmFsdWVEaW0uaW5kZXhdICo9IChvcHQuaXNIb3Jpem9udGFsID8gLTEgOiAxKSAqIHB4U2lnbjtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUxpbmVXaWR0aChpdGVtTW9kZWwsIHN5bWJvbFNjYWxlLCByb3RhdGlvbiwgb3B0LCBvdXRwdXRTeW1ib2xNZXRhKSB7XG4gIC8vIEluIHN5bWJvbHMgYXJlIGRyYXduIHdpdGggc2NhbGUsIHNvIGRvIG5vdCBuZWVkIHRvIGNhcmUgYWJvdXQgdGhlIGNhc2UgdGhhdCB3aWR0aFxuICAvLyBvciBoZWlnaHQgYXJlIHRvbyBzbWFsbC4gQnV0IHN5bWJvbCB1c2Ugc3Ryb2tlTm9TY2FsZSwgd2hlcmUgYWN0dXJlIGxpbmVXaWR0aCBzaG91bGRcbiAgLy8gYmUgY2FsY3VsYXRlZC5cbiAgdmFyIHZhbHVlTGluZVdpZHRoID0gaXRlbU1vZGVsLmdldChCQVJfQk9SREVSX1dJRFRIX1FVRVJZKSB8fCAwO1xuXG4gIGlmICh2YWx1ZUxpbmVXaWR0aCkge1xuICAgIHBhdGhGb3JMaW5lV2lkdGguYXR0cih7XG4gICAgICBzY2FsZVg6IHN5bWJvbFNjYWxlWzBdLFxuICAgICAgc2NhbGVZOiBzeW1ib2xTY2FsZVsxXSxcbiAgICAgIHJvdGF0aW9uOiByb3RhdGlvblxuICAgIH0pO1xuICAgIHBhdGhGb3JMaW5lV2lkdGgudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgdmFsdWVMaW5lV2lkdGggLz0gcGF0aEZvckxpbmVXaWR0aC5nZXRMaW5lU2NhbGUoKTtcbiAgICB2YWx1ZUxpbmVXaWR0aCAqPSBzeW1ib2xTY2FsZVtvcHQudmFsdWVEaW0uaW5kZXhdO1xuICB9XG5cbiAgb3V0cHV0U3ltYm9sTWV0YS52YWx1ZUxpbmVXaWR0aCA9IHZhbHVlTGluZVdpZHRoO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlTGF5b3V0SW5mbyhpdGVtTW9kZWwsIHN5bWJvbFNpemUsIGxheW91dCwgc3ltYm9sUmVwZWF0LCBzeW1ib2xDbGlwLCBzeW1ib2xPZmZzZXQsIHN5bWJvbFBvc2l0aW9uLCB2YWx1ZUxpbmVXaWR0aCwgYm91bmRpbmdMZW5ndGgsIHJlcGVhdEN1dExlbmd0aCwgb3B0LCBvdXRwdXRTeW1ib2xNZXRhKSB7XG4gIHZhciBjYXRlZ29yeURpbSA9IG9wdC5jYXRlZ29yeURpbTtcbiAgdmFyIHZhbHVlRGltID0gb3B0LnZhbHVlRGltO1xuICB2YXIgcHhTaWduID0gb3V0cHV0U3ltYm9sTWV0YS5weFNpZ247XG4gIHZhciB1bml0TGVuZ3RoID0gTWF0aC5tYXgoc3ltYm9sU2l6ZVt2YWx1ZURpbS5pbmRleF0gKyB2YWx1ZUxpbmVXaWR0aCwgMCk7XG4gIHZhciBwYXRoTGVuID0gdW5pdExlbmd0aDsgLy8gTm90ZTogcm90YXRpb24gd2lsbCBub3QgZWZmZWN0IHRoZSBsYXlvdXQgb2Ygc3ltYm9scywgYmVjYXVzZSB1c2VyIG1heVxuICAvLyB3YW50IHN5bWJvbHMgdG8gcm90YXRlIG9uIGl0cyBjZW50ZXIsIHdoaWNoIHNob3VsZCBub3QgYmUgdHJhbnNsYXRlZFxuICAvLyB3aGVuIHJvdGF0aW5nLlxuXG4gIGlmIChzeW1ib2xSZXBlYXQpIHtcbiAgICB2YXIgYWJzQm91bmRpbmdMZW5ndGggPSBNYXRoLmFicyhib3VuZGluZ0xlbmd0aCk7XG4gICAgdmFyIHN5bWJvbE1hcmdpbiA9IHpyVXRpbC5yZXRyaWV2ZShpdGVtTW9kZWwuZ2V0KCdzeW1ib2xNYXJnaW4nKSwgJzE1JScpICsgJyc7XG4gICAgdmFyIGhhc0VuZEdhcCA9IGZhbHNlO1xuXG4gICAgaWYgKHN5bWJvbE1hcmdpbi5sYXN0SW5kZXhPZignIScpID09PSBzeW1ib2xNYXJnaW4ubGVuZ3RoIC0gMSkge1xuICAgICAgaGFzRW5kR2FwID0gdHJ1ZTtcbiAgICAgIHN5bWJvbE1hcmdpbiA9IHN5bWJvbE1hcmdpbi5zbGljZSgwLCBzeW1ib2xNYXJnaW4ubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgdmFyIHN5bWJvbE1hcmdpbk51bWVyaWMgPSBwYXJzZVBlcmNlbnQoc3ltYm9sTWFyZ2luLCBzeW1ib2xTaXplW3ZhbHVlRGltLmluZGV4XSk7XG4gICAgdmFyIHVMZW5XaXRoTWFyZ2luID0gTWF0aC5tYXgodW5pdExlbmd0aCArIHN5bWJvbE1hcmdpbk51bWVyaWMgKiAyLCAwKTsgLy8gV2hlbiBzeW1ib2wgbWFyZ2luIGlzIGxlc3MgdGhhbiAwLCBtYXJnaW4gYXQgYm90aCBlbmRzIHdpbGwgYmUgc3VidHJhY3RlZFxuICAgIC8vIHRvIGVuc3VyZSB0aGF0IGFsbCBvZiB0aGUgc3ltYm9scyB3aWxsIG5vdCBiZSBvdmVyZmxvdyB0aGUgZ2l2ZW4gYXJlYS5cblxuICAgIHZhciBlbmRGaXggPSBoYXNFbmRHYXAgPyAwIDogc3ltYm9sTWFyZ2luTnVtZXJpYyAqIDI7IC8vIEJvdGggZmluYWwgcmVwZWF0VGltZXMgYW5kIGZpbmFsIHN5bWJvbE1hcmdpbk51bWVyaWMgYXJlYSBjYWxjdWxhdGVkIGJhc2VkIG9uXG4gICAgLy8gYm91bmRpbmdMZW5ndGguXG5cbiAgICB2YXIgcmVwZWF0U3BlY2lmaWVkID0gaXNOdW1lcmljKHN5bWJvbFJlcGVhdCk7XG4gICAgdmFyIHJlcGVhdFRpbWVzID0gcmVwZWF0U3BlY2lmaWVkID8gc3ltYm9sUmVwZWF0IDogdG9JbnRUaW1lcygoYWJzQm91bmRpbmdMZW5ndGggKyBlbmRGaXgpIC8gdUxlbldpdGhNYXJnaW4pOyAvLyBBZGp1c3QgY2FsY3VsYXRlIG1hcmdpbiwgdG8gZW5zdXJlIGVhY2ggc3ltYm9sIGlzIGRpc3BsYXllZFxuICAgIC8vIGVudGlyZWx5IGluIHRoZSBnaXZlbiBsYXlvdXQgYXJlYS5cblxuICAgIHZhciBtRGlmZiA9IGFic0JvdW5kaW5nTGVuZ3RoIC0gcmVwZWF0VGltZXMgKiB1bml0TGVuZ3RoO1xuICAgIHN5bWJvbE1hcmdpbk51bWVyaWMgPSBtRGlmZiAvIDIgLyAoaGFzRW5kR2FwID8gcmVwZWF0VGltZXMgOiByZXBlYXRUaW1lcyAtIDEpO1xuICAgIHVMZW5XaXRoTWFyZ2luID0gdW5pdExlbmd0aCArIHN5bWJvbE1hcmdpbk51bWVyaWMgKiAyO1xuICAgIGVuZEZpeCA9IGhhc0VuZEdhcCA/IDAgOiBzeW1ib2xNYXJnaW5OdW1lcmljICogMjsgLy8gVXBkYXRlIHJlcGVhdFRpbWVzIHdoZW4gbm90IGFsbCBzeW1ib2wgd2lsbCBiZSBzaG93bi5cblxuICAgIGlmICghcmVwZWF0U3BlY2lmaWVkICYmIHN5bWJvbFJlcGVhdCAhPT0gJ2ZpeGVkJykge1xuICAgICAgcmVwZWF0VGltZXMgPSByZXBlYXRDdXRMZW5ndGggPyB0b0ludFRpbWVzKChNYXRoLmFicyhyZXBlYXRDdXRMZW5ndGgpICsgZW5kRml4KSAvIHVMZW5XaXRoTWFyZ2luKSA6IDA7XG4gICAgfVxuXG4gICAgcGF0aExlbiA9IHJlcGVhdFRpbWVzICogdUxlbldpdGhNYXJnaW4gLSBlbmRGaXg7XG4gICAgb3V0cHV0U3ltYm9sTWV0YS5yZXBlYXRUaW1lcyA9IHJlcGVhdFRpbWVzO1xuICAgIG91dHB1dFN5bWJvbE1ldGEuc3ltYm9sTWFyZ2luID0gc3ltYm9sTWFyZ2luTnVtZXJpYztcbiAgfVxuXG4gIHZhciBzaXplRml4ID0gcHhTaWduICogKHBhdGhMZW4gLyAyKTtcbiAgdmFyIHBhdGhQb3NpdGlvbiA9IG91dHB1dFN5bWJvbE1ldGEucGF0aFBvc2l0aW9uID0gW107XG4gIHBhdGhQb3NpdGlvbltjYXRlZ29yeURpbS5pbmRleF0gPSBsYXlvdXRbY2F0ZWdvcnlEaW0ud2hdIC8gMjtcbiAgcGF0aFBvc2l0aW9uW3ZhbHVlRGltLmluZGV4XSA9IHN5bWJvbFBvc2l0aW9uID09PSAnc3RhcnQnID8gc2l6ZUZpeCA6IHN5bWJvbFBvc2l0aW9uID09PSAnZW5kJyA/IGJvdW5kaW5nTGVuZ3RoIC0gc2l6ZUZpeCA6IGJvdW5kaW5nTGVuZ3RoIC8gMjsgLy8gJ2NlbnRlcidcblxuICBpZiAoc3ltYm9sT2Zmc2V0KSB7XG4gICAgcGF0aFBvc2l0aW9uWzBdICs9IHN5bWJvbE9mZnNldFswXTtcbiAgICBwYXRoUG9zaXRpb25bMV0gKz0gc3ltYm9sT2Zmc2V0WzFdO1xuICB9XG5cbiAgdmFyIGJ1bmRsZVBvc2l0aW9uID0gb3V0cHV0U3ltYm9sTWV0YS5idW5kbGVQb3NpdGlvbiA9IFtdO1xuICBidW5kbGVQb3NpdGlvbltjYXRlZ29yeURpbS5pbmRleF0gPSBsYXlvdXRbY2F0ZWdvcnlEaW0ueHldO1xuICBidW5kbGVQb3NpdGlvblt2YWx1ZURpbS5pbmRleF0gPSBsYXlvdXRbdmFsdWVEaW0ueHldO1xuICB2YXIgYmFyUmVjdFNoYXBlID0gb3V0cHV0U3ltYm9sTWV0YS5iYXJSZWN0U2hhcGUgPSB6clV0aWwuZXh0ZW5kKHt9LCBsYXlvdXQpO1xuICBiYXJSZWN0U2hhcGVbdmFsdWVEaW0ud2hdID0gcHhTaWduICogTWF0aC5tYXgoTWF0aC5hYnMobGF5b3V0W3ZhbHVlRGltLndoXSksIE1hdGguYWJzKHBhdGhQb3NpdGlvblt2YWx1ZURpbS5pbmRleF0gKyBzaXplRml4KSk7XG4gIGJhclJlY3RTaGFwZVtjYXRlZ29yeURpbS53aF0gPSBsYXlvdXRbY2F0ZWdvcnlEaW0ud2hdO1xuICB2YXIgY2xpcFNoYXBlID0gb3V0cHV0U3ltYm9sTWV0YS5jbGlwU2hhcGUgPSB7fTsgLy8gQ29uc2lkZXIgdGhhdCBzeW1ib2wgbWF5IGJlIG92ZXJmbG93IGxheW91dCByZWN0LlxuXG4gIGNsaXBTaGFwZVtjYXRlZ29yeURpbS54eV0gPSAtbGF5b3V0W2NhdGVnb3J5RGltLnh5XTtcbiAgY2xpcFNoYXBlW2NhdGVnb3J5RGltLndoXSA9IG9wdC5lY1NpemVbY2F0ZWdvcnlEaW0ud2hdO1xuICBjbGlwU2hhcGVbdmFsdWVEaW0ueHldID0gMDtcbiAgY2xpcFNoYXBlW3ZhbHVlRGltLndoXSA9IGxheW91dFt2YWx1ZURpbS53aF07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGgoc3ltYm9sTWV0YSkge1xuICB2YXIgc3ltYm9sUGF0dGVyblNpemUgPSBzeW1ib2xNZXRhLnN5bWJvbFBhdHRlcm5TaXplO1xuICB2YXIgcGF0aCA9IGNyZWF0ZVN5bWJvbCggLy8gQ29uc2lkZXIgdGV4dHVyZSBpbWcsIG1ha2UgYSBiaWcgc2l6ZS5cbiAgc3ltYm9sTWV0YS5zeW1ib2xUeXBlLCAtc3ltYm9sUGF0dGVyblNpemUgLyAyLCAtc3ltYm9sUGF0dGVyblNpemUgLyAyLCBzeW1ib2xQYXR0ZXJuU2l6ZSwgc3ltYm9sUGF0dGVyblNpemUpO1xuICBwYXRoLmF0dHIoe1xuICAgIGN1bGxpbmc6IHRydWVcbiAgfSk7XG4gIHBhdGgudHlwZSAhPT0gJ2ltYWdlJyAmJiBwYXRoLnNldFN0eWxlKHtcbiAgICBzdHJva2VOb1NjYWxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVSZXBlYXRTeW1ib2xzKGJhciwgb3B0LCBzeW1ib2xNZXRhLCBpc1VwZGF0ZSkge1xuICB2YXIgYnVuZGxlID0gYmFyLl9fcGljdG9yaWFsQnVuZGxlO1xuICB2YXIgc3ltYm9sU2l6ZSA9IHN5bWJvbE1ldGEuc3ltYm9sU2l6ZTtcbiAgdmFyIHZhbHVlTGluZVdpZHRoID0gc3ltYm9sTWV0YS52YWx1ZUxpbmVXaWR0aDtcbiAgdmFyIHBhdGhQb3NpdGlvbiA9IHN5bWJvbE1ldGEucGF0aFBvc2l0aW9uO1xuICB2YXIgdmFsdWVEaW0gPSBvcHQudmFsdWVEaW07XG4gIHZhciByZXBlYXRUaW1lcyA9IHN5bWJvbE1ldGEucmVwZWF0VGltZXMgfHwgMDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHVuaXQgPSBzeW1ib2xTaXplW29wdC52YWx1ZURpbS5pbmRleF0gKyB2YWx1ZUxpbmVXaWR0aCArIHN5bWJvbE1ldGEuc3ltYm9sTWFyZ2luICogMjtcbiAgZWFjaFBhdGgoYmFyLCBmdW5jdGlvbiAocGF0aCkge1xuICAgIHBhdGguX19waWN0b3JpYWxBbmltYXRpb25JbmRleCA9IGluZGV4O1xuICAgIHBhdGguX19waWN0b3JpYWxSZXBlYXRUaW1lcyA9IHJlcGVhdFRpbWVzO1xuXG4gICAgaWYgKGluZGV4IDwgcmVwZWF0VGltZXMpIHtcbiAgICAgIHVwZGF0ZUF0dHIocGF0aCwgbnVsbCwgbWFrZVRhcmdldChpbmRleCksIHN5bWJvbE1ldGEsIGlzVXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlQXR0cihwYXRoLCBudWxsLCB7XG4gICAgICAgIHNjYWxlWDogMCxcbiAgICAgICAgc2NhbGVZOiAwXG4gICAgICB9LCBzeW1ib2xNZXRhLCBpc1VwZGF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBidW5kbGUucmVtb3ZlKHBhdGgpO1xuICAgICAgfSk7XG4gICAgfSAvLyB1cGRhdGVIb3ZlckFuaW1hdGlvbihwYXRoLCBzeW1ib2xNZXRhKTtcblxuXG4gICAgaW5kZXgrKztcbiAgfSk7XG5cbiAgZm9yICg7IGluZGV4IDwgcmVwZWF0VGltZXM7IGluZGV4KyspIHtcbiAgICB2YXIgcGF0aCA9IGNyZWF0ZVBhdGgoc3ltYm9sTWV0YSk7XG4gICAgcGF0aC5fX3BpY3RvcmlhbEFuaW1hdGlvbkluZGV4ID0gaW5kZXg7XG4gICAgcGF0aC5fX3BpY3RvcmlhbFJlcGVhdFRpbWVzID0gcmVwZWF0VGltZXM7XG4gICAgYnVuZGxlLmFkZChwYXRoKTtcbiAgICB2YXIgdGFyZ2V0ID0gbWFrZVRhcmdldChpbmRleCk7XG4gICAgdXBkYXRlQXR0cihwYXRoLCB7XG4gICAgICB4OiB0YXJnZXQueCxcbiAgICAgIHk6IHRhcmdldC55LFxuICAgICAgc2NhbGVYOiAwLFxuICAgICAgc2NhbGVZOiAwXG4gICAgfSwge1xuICAgICAgc2NhbGVYOiB0YXJnZXQuc2NhbGVYLFxuICAgICAgc2NhbGVZOiB0YXJnZXQuc2NhbGVZLFxuICAgICAgcm90YXRpb246IHRhcmdldC5yb3RhdGlvblxuICAgIH0sIHN5bWJvbE1ldGEsIGlzVXBkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VUYXJnZXQoaW5kZXgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBwYXRoUG9zaXRpb24uc2xpY2UoKTsgLy8gKHN0YXJ0ICYmIHB4U2lnbiA+IDApIHx8IChlbmQgJiYgcHhTaWduIDwgMCk6IGkgPSByZXBlYXRUaW1lcyAtIGluZGV4XG4gICAgLy8gT3RoZXJ3aXNlOiBpID0gaW5kZXg7XG5cbiAgICB2YXIgcHhTaWduID0gc3ltYm9sTWV0YS5weFNpZ247XG4gICAgdmFyIGkgPSBpbmRleDtcblxuICAgIGlmIChzeW1ib2xNZXRhLnN5bWJvbFJlcGVhdERpcmVjdGlvbiA9PT0gJ3N0YXJ0JyA/IHB4U2lnbiA+IDAgOiBweFNpZ24gPCAwKSB7XG4gICAgICBpID0gcmVwZWF0VGltZXMgLSAxIC0gaW5kZXg7XG4gICAgfVxuXG4gICAgcG9zaXRpb25bdmFsdWVEaW0uaW5kZXhdID0gdW5pdCAqIChpIC0gcmVwZWF0VGltZXMgLyAyICsgMC41KSArIHBhdGhQb3NpdGlvblt2YWx1ZURpbS5pbmRleF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHBvc2l0aW9uWzBdLFxuICAgICAgeTogcG9zaXRpb25bMV0sXG4gICAgICBzY2FsZVg6IHN5bWJvbE1ldGEuc3ltYm9sU2NhbGVbMF0sXG4gICAgICBzY2FsZVk6IHN5bWJvbE1ldGEuc3ltYm9sU2NhbGVbMV0sXG4gICAgICByb3RhdGlvbjogc3ltYm9sTWV0YS5yb3RhdGlvblxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVTaW5nbGVTeW1ib2woYmFyLCBvcHQsIHN5bWJvbE1ldGEsIGlzVXBkYXRlKSB7XG4gIHZhciBidW5kbGUgPSBiYXIuX19waWN0b3JpYWxCdW5kbGU7XG4gIHZhciBtYWluUGF0aCA9IGJhci5fX3BpY3RvcmlhbE1haW5QYXRoO1xuXG4gIGlmICghbWFpblBhdGgpIHtcbiAgICBtYWluUGF0aCA9IGJhci5fX3BpY3RvcmlhbE1haW5QYXRoID0gY3JlYXRlUGF0aChzeW1ib2xNZXRhKTtcbiAgICBidW5kbGUuYWRkKG1haW5QYXRoKTtcbiAgICB1cGRhdGVBdHRyKG1haW5QYXRoLCB7XG4gICAgICB4OiBzeW1ib2xNZXRhLnBhdGhQb3NpdGlvblswXSxcbiAgICAgIHk6IHN5bWJvbE1ldGEucGF0aFBvc2l0aW9uWzFdLFxuICAgICAgc2NhbGVYOiAwLFxuICAgICAgc2NhbGVZOiAwLFxuICAgICAgcm90YXRpb246IHN5bWJvbE1ldGEucm90YXRpb25cbiAgICB9LCB7XG4gICAgICBzY2FsZVg6IHN5bWJvbE1ldGEuc3ltYm9sU2NhbGVbMF0sXG4gICAgICBzY2FsZVk6IHN5bWJvbE1ldGEuc3ltYm9sU2NhbGVbMV1cbiAgICB9LCBzeW1ib2xNZXRhLCBpc1VwZGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQXR0cihtYWluUGF0aCwgbnVsbCwge1xuICAgICAgeDogc3ltYm9sTWV0YS5wYXRoUG9zaXRpb25bMF0sXG4gICAgICB5OiBzeW1ib2xNZXRhLnBhdGhQb3NpdGlvblsxXSxcbiAgICAgIHNjYWxlWDogc3ltYm9sTWV0YS5zeW1ib2xTY2FsZVswXSxcbiAgICAgIHNjYWxlWTogc3ltYm9sTWV0YS5zeW1ib2xTY2FsZVsxXSxcbiAgICAgIHJvdGF0aW9uOiBzeW1ib2xNZXRhLnJvdGF0aW9uXG4gICAgfSwgc3ltYm9sTWV0YSwgaXNVcGRhdGUpO1xuICB9XG59IC8vIGJhciByZWN0IGlzIHVzZWQgZm9yIGxhYmVsLlxuXG5cbmZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlQmFyUmVjdChiYXIsIHN5bWJvbE1ldGEsIGlzVXBkYXRlKSB7XG4gIHZhciByZWN0U2hhcGUgPSB6clV0aWwuZXh0ZW5kKHt9LCBzeW1ib2xNZXRhLmJhclJlY3RTaGFwZSk7XG4gIHZhciBiYXJSZWN0ID0gYmFyLl9fcGljdG9yaWFsQmFyUmVjdDtcblxuICBpZiAoIWJhclJlY3QpIHtcbiAgICBiYXJSZWN0ID0gYmFyLl9fcGljdG9yaWFsQmFyUmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgejI6IDIsXG4gICAgICBzaGFwZTogcmVjdFNoYXBlLFxuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgc3Ryb2tlOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBmaWxsOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBsaW5lV2lkdGg6IDBcbiAgICAgIH1cbiAgICB9KTtcbiAgICBiYXIuYWRkKGJhclJlY3QpO1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUF0dHIoYmFyUmVjdCwgbnVsbCwge1xuICAgICAgc2hhcGU6IHJlY3RTaGFwZVxuICAgIH0sIHN5bWJvbE1ldGEsIGlzVXBkYXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUNsaXAoYmFyLCBvcHQsIHN5bWJvbE1ldGEsIGlzVXBkYXRlKSB7XG4gIC8vIElmIG5vdCBjbGlwLCBzeW1ib2wgd2lsbCBiZSByZW1vdmUgYW5kIHJlYnVpbHQuXG4gIGlmIChzeW1ib2xNZXRhLnN5bWJvbENsaXApIHtcbiAgICB2YXIgY2xpcFBhdGggPSBiYXIuX19waWN0b3JpYWxDbGlwUGF0aDtcbiAgICB2YXIgY2xpcFNoYXBlID0genJVdGlsLmV4dGVuZCh7fSwgc3ltYm9sTWV0YS5jbGlwU2hhcGUpO1xuICAgIHZhciB2YWx1ZURpbSA9IG9wdC52YWx1ZURpbTtcbiAgICB2YXIgYW5pbWF0aW9uTW9kZWwgPSBzeW1ib2xNZXRhLmFuaW1hdGlvbk1vZGVsO1xuICAgIHZhciBkYXRhSW5kZXggPSBzeW1ib2xNZXRhLmRhdGFJbmRleDtcblxuICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhjbGlwUGF0aCwge1xuICAgICAgICBzaGFwZTogY2xpcFNoYXBlXG4gICAgICB9LCBhbmltYXRpb25Nb2RlbCwgZGF0YUluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xpcFNoYXBlW3ZhbHVlRGltLndoXSA9IDA7XG4gICAgICBjbGlwUGF0aCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgICBzaGFwZTogY2xpcFNoYXBlXG4gICAgICB9KTtcblxuICAgICAgYmFyLl9fcGljdG9yaWFsQnVuZGxlLnNldENsaXBQYXRoKGNsaXBQYXRoKTtcblxuICAgICAgYmFyLl9fcGljdG9yaWFsQ2xpcFBhdGggPSBjbGlwUGF0aDtcbiAgICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICAgIHRhcmdldFt2YWx1ZURpbS53aF0gPSBzeW1ib2xNZXRhLmNsaXBTaGFwZVt2YWx1ZURpbS53aF07XG4gICAgICBncmFwaGljW2lzVXBkYXRlID8gJ3VwZGF0ZVByb3BzJyA6ICdpbml0UHJvcHMnXShjbGlwUGF0aCwge1xuICAgICAgICBzaGFwZTogdGFyZ2V0XG4gICAgICB9LCBhbmltYXRpb25Nb2RlbCwgZGF0YUluZGV4KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SXRlbU1vZGVsKGRhdGEsIGRhdGFJbmRleCkge1xuICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KTtcbiAgaXRlbU1vZGVsLmdldEFuaW1hdGlvbkRlbGF5UGFyYW1zID0gZ2V0QW5pbWF0aW9uRGVsYXlQYXJhbXM7XG4gIGl0ZW1Nb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQgPSBpc0FuaW1hdGlvbkVuYWJsZWQ7XG4gIHJldHVybiBpdGVtTW9kZWw7XG59XG5cbmZ1bmN0aW9uIGdldEFuaW1hdGlvbkRlbGF5UGFyYW1zKHBhdGgpIHtcbiAgLy8gVGhlIG9yZGVyIGlzIHRoZSBzYW1lIGFzIHRoZSB6LW9yZGVyLCBzZWUgYHN5bWJvbFJlcGVhdERpcmV0aW9uYC5cbiAgcmV0dXJuIHtcbiAgICBpbmRleDogcGF0aC5fX3BpY3RvcmlhbEFuaW1hdGlvbkluZGV4LFxuICAgIGNvdW50OiBwYXRoLl9fcGljdG9yaWFsUmVwZWF0VGltZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbmltYXRpb25FbmFibGVkKCkge1xuICAvLyBgYW5pbWF0aW9uYCBwcm9wIGNhbiBiZSBzZXQgb24gaXRlbU1vZGVsIGluIHBpY3RvcmlhbCBiYXIgY2hhcnQuXG4gIHJldHVybiB0aGlzLnBhcmVudE1vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpICYmICEhdGhpcy5nZXRTaGFsbG93KCdhbmltYXRpb24nKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQmFyKGRhdGEsIG9wdCwgc3ltYm9sTWV0YSwgaXNVcGRhdGUpIHtcbiAgLy8gYmFyIGlzIHRoZSBtYWluIGVsZW1lbnQgZm9yIGVhY2ggZGF0YS5cbiAgdmFyIGJhciA9IG5ldyBncmFwaGljLkdyb3VwKCk7IC8vIGJ1bmRsZSBpcyB1c2VkIGZvciBsb2NhdGlvbiBhbmQgY2xpcC5cblxuICB2YXIgYnVuZGxlID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgYmFyLmFkZChidW5kbGUpO1xuICBiYXIuX19waWN0b3JpYWxCdW5kbGUgPSBidW5kbGU7XG4gIGJ1bmRsZS54ID0gc3ltYm9sTWV0YS5idW5kbGVQb3NpdGlvblswXTtcbiAgYnVuZGxlLnkgPSBzeW1ib2xNZXRhLmJ1bmRsZVBvc2l0aW9uWzFdO1xuXG4gIGlmIChzeW1ib2xNZXRhLnN5bWJvbFJlcGVhdCkge1xuICAgIGNyZWF0ZU9yVXBkYXRlUmVwZWF0U3ltYm9scyhiYXIsIG9wdCwgc3ltYm9sTWV0YSk7XG4gIH0gZWxzZSB7XG4gICAgY3JlYXRlT3JVcGRhdGVTaW5nbGVTeW1ib2woYmFyLCBvcHQsIHN5bWJvbE1ldGEpO1xuICB9XG5cbiAgY3JlYXRlT3JVcGRhdGVCYXJSZWN0KGJhciwgc3ltYm9sTWV0YSwgaXNVcGRhdGUpO1xuICBjcmVhdGVPclVwZGF0ZUNsaXAoYmFyLCBvcHQsIHN5bWJvbE1ldGEsIGlzVXBkYXRlKTtcbiAgYmFyLl9fcGljdG9yaWFsU2hhcGVTdHIgPSBnZXRTaGFwZVN0cihkYXRhLCBzeW1ib2xNZXRhKTtcbiAgYmFyLl9fcGljdG9yaWFsU3ltYm9sTWV0YSA9IHN5bWJvbE1ldGE7XG4gIHJldHVybiBiYXI7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUJhcihiYXIsIG9wdCwgc3ltYm9sTWV0YSkge1xuICB2YXIgYW5pbWF0aW9uTW9kZWwgPSBzeW1ib2xNZXRhLmFuaW1hdGlvbk1vZGVsO1xuICB2YXIgZGF0YUluZGV4ID0gc3ltYm9sTWV0YS5kYXRhSW5kZXg7XG4gIHZhciBidW5kbGUgPSBiYXIuX19waWN0b3JpYWxCdW5kbGU7XG4gIGdyYXBoaWMudXBkYXRlUHJvcHMoYnVuZGxlLCB7XG4gICAgeDogc3ltYm9sTWV0YS5idW5kbGVQb3NpdGlvblswXSxcbiAgICB5OiBzeW1ib2xNZXRhLmJ1bmRsZVBvc2l0aW9uWzFdXG4gIH0sIGFuaW1hdGlvbk1vZGVsLCBkYXRhSW5kZXgpO1xuXG4gIGlmIChzeW1ib2xNZXRhLnN5bWJvbFJlcGVhdCkge1xuICAgIGNyZWF0ZU9yVXBkYXRlUmVwZWF0U3ltYm9scyhiYXIsIG9wdCwgc3ltYm9sTWV0YSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY3JlYXRlT3JVcGRhdGVTaW5nbGVTeW1ib2woYmFyLCBvcHQsIHN5bWJvbE1ldGEsIHRydWUpO1xuICB9XG5cbiAgY3JlYXRlT3JVcGRhdGVCYXJSZWN0KGJhciwgc3ltYm9sTWV0YSwgdHJ1ZSk7XG4gIGNyZWF0ZU9yVXBkYXRlQ2xpcChiYXIsIG9wdCwgc3ltYm9sTWV0YSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUJhcihkYXRhLCBkYXRhSW5kZXgsIGFuaW1hdGlvbk1vZGVsLCBiYXIpIHtcbiAgLy8gTm90IHNob3cgdGV4dCB3aGVuIGFuaW1hdGluZ1xuICB2YXIgbGFiZWxSZWN0ID0gYmFyLl9fcGljdG9yaWFsQmFyUmVjdDtcbiAgbGFiZWxSZWN0ICYmIGxhYmVsUmVjdC5yZW1vdmVUZXh0Q29udGVudCgpO1xuICB2YXIgcGF0aGVzID0gW107XG4gIGVhY2hQYXRoKGJhciwgZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBwYXRoZXMucHVzaChwYXRoKTtcbiAgfSk7XG4gIGJhci5fX3BpY3RvcmlhbE1haW5QYXRoICYmIHBhdGhlcy5wdXNoKGJhci5fX3BpY3RvcmlhbE1haW5QYXRoKTsgLy8gSSBkbyBub3QgZmluZCBwcm9wZXIgcmVtb3ZlIGFuaW1hdGlvbiBmb3IgY2xpcCB5ZXQuXG5cbiAgYmFyLl9fcGljdG9yaWFsQ2xpcFBhdGggJiYgKGFuaW1hdGlvbk1vZGVsID0gbnVsbCk7XG4gIHpyVXRpbC5lYWNoKHBhdGhlcywgZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBncmFwaGljLnJlbW92ZUVsZW1lbnQocGF0aCwge1xuICAgICAgc2NhbGVYOiAwLFxuICAgICAgc2NhbGVZOiAwXG4gICAgfSwgYW5pbWF0aW9uTW9kZWwsIGRhdGFJbmRleCwgZnVuY3Rpb24gKCkge1xuICAgICAgYmFyLnBhcmVudCAmJiBiYXIucGFyZW50LnJlbW92ZShiYXIpO1xuICAgIH0pO1xuICB9KTtcbiAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCwgbnVsbCk7XG59XG5cbmZ1bmN0aW9uIGdldFNoYXBlU3RyKGRhdGEsIHN5bWJvbE1ldGEpIHtcbiAgcmV0dXJuIFtkYXRhLmdldEl0ZW1WaXN1YWwoc3ltYm9sTWV0YS5kYXRhSW5kZXgsICdzeW1ib2wnKSB8fCAnbm9uZScsICEhc3ltYm9sTWV0YS5zeW1ib2xSZXBlYXQsICEhc3ltYm9sTWV0YS5zeW1ib2xDbGlwXS5qb2luKCc6Jyk7XG59XG5cbmZ1bmN0aW9uIGVhY2hQYXRoKGJhciwgY2IsIGNvbnRleHQpIHtcbiAgLy8gRG8gbm90IHVzZSBHcm91cCNlYWNoQ2hpbGQsIGJlY2F1c2UgaXQgZG8gbm90IHN1cHBvcnQgcmVtb3ZlLlxuICB6clV0aWwuZWFjaChiYXIuX19waWN0b3JpYWxCdW5kbGUuY2hpbGRyZW4oKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgZWwgIT09IGJhci5fX3BpY3RvcmlhbEJhclJlY3QgJiYgY2IuY2FsbChjb250ZXh0LCBlbCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVBdHRyKGVsLCBpbW1lZGlhdGVBdHRycywgYW5pbWF0aW9uQXR0cnMsIHN5bWJvbE1ldGEsIGlzVXBkYXRlLCBjYikge1xuICBpbW1lZGlhdGVBdHRycyAmJiBlbC5hdHRyKGltbWVkaWF0ZUF0dHJzKTsgLy8gd2hlbiBzeW1ib2xDaXAgdXNlZCwgb25seSBjbGlwIHBhdGggaGFzIGluaXQgYW5pbWF0aW9uLCBvdGhlcndpc2UgaXQgd291bGQgYmUgd2VpcmQgZWZmZWN0LlxuXG4gIGlmIChzeW1ib2xNZXRhLnN5bWJvbENsaXAgJiYgIWlzVXBkYXRlKSB7XG4gICAgYW5pbWF0aW9uQXR0cnMgJiYgZWwuYXR0cihhbmltYXRpb25BdHRycyk7XG4gIH0gZWxzZSB7XG4gICAgYW5pbWF0aW9uQXR0cnMgJiYgZ3JhcGhpY1tpc1VwZGF0ZSA/ICd1cGRhdGVQcm9wcycgOiAnaW5pdFByb3BzJ10oZWwsIGFuaW1hdGlvbkF0dHJzLCBzeW1ib2xNZXRhLmFuaW1hdGlvbk1vZGVsLCBzeW1ib2xNZXRhLmRhdGFJbmRleCwgY2IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbW1vbihiYXIsIG9wdCwgc3ltYm9sTWV0YSkge1xuICB2YXIgZGF0YUluZGV4ID0gc3ltYm9sTWV0YS5kYXRhSW5kZXg7XG4gIHZhciBpdGVtTW9kZWwgPSBzeW1ib2xNZXRhLml0ZW1Nb2RlbDsgLy8gQ29sb3IgbXVzdCBiZSBleGNsdWRlZC5cbiAgLy8gQmVjYXVzZSBzeW1ib2wgcHJvdmlkZSBzZXRDb2xvciBpbmRpdmlkdWFsbHkgdG8gc2V0IGZpbGwgYW5kIHN0cm9rZVxuXG4gIHZhciBlbXBoYXNpc01vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdlbXBoYXNpcycpO1xuICB2YXIgZW1waGFzaXNTdHlsZSA9IGVtcGhhc2lzTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZSgpO1xuICB2YXIgYmx1clN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKFsnYmx1cicsICdpdGVtU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCk7XG4gIHZhciBzZWxlY3RTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChbJ3NlbGVjdCcsICdpdGVtU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCk7XG4gIHZhciBjdXJzb3JTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdjdXJzb3InKTtcbiAgdmFyIGZvY3VzID0gZW1waGFzaXNNb2RlbC5nZXQoJ2ZvY3VzJyk7XG4gIHZhciBibHVyU2NvcGUgPSBlbXBoYXNpc01vZGVsLmdldCgnYmx1clNjb3BlJyk7XG4gIHZhciBob3ZlclNjYWxlID0gZW1waGFzaXNNb2RlbC5nZXQoJ3NjYWxlJyk7XG4gIGVhY2hQYXRoKGJhciwgZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFpSSW1hZ2UpIHtcbiAgICAgIHZhciBwYXRoU3R5bGUgPSBwYXRoLnN0eWxlO1xuICAgICAgcGF0aC51c2VTdHlsZSh6clV0aWwuZXh0ZW5kKHtcbiAgICAgICAgLy8gVE9ETyBvdGhlciBwcm9wZXJ0aWVzIGxpa2UgZHgsIGR5ID9cbiAgICAgICAgaW1hZ2U6IHBhdGhTdHlsZS5pbWFnZSxcbiAgICAgICAgeDogcGF0aFN0eWxlLngsXG4gICAgICAgIHk6IHBhdGhTdHlsZS55LFxuICAgICAgICB3aWR0aDogcGF0aFN0eWxlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHBhdGhTdHlsZS5oZWlnaHRcbiAgICAgIH0sIHN5bWJvbE1ldGEuc3R5bGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC51c2VTdHlsZShzeW1ib2xNZXRhLnN0eWxlKTtcbiAgICB9XG5cbiAgICB2YXIgZW1waGFzaXNTdGF0ZSA9IHBhdGguZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJyk7XG4gICAgZW1waGFzaXNTdGF0ZS5zdHlsZSA9IGVtcGhhc2lzU3R5bGU7XG5cbiAgICBpZiAoaG92ZXJTY2FsZSkge1xuICAgICAgLy8gTk9URTogTXVzdCBhZnRlciBzY2FsZSBpcyBzZXQgYWZ0ZXIgdXBkYXRlQXR0clxuICAgICAgZW1waGFzaXNTdGF0ZS5zY2FsZVggPSBwYXRoLnNjYWxlWCAqIDEuMTtcbiAgICAgIGVtcGhhc2lzU3RhdGUuc2NhbGVZID0gcGF0aC5zY2FsZVkgKiAxLjE7XG4gICAgfVxuXG4gICAgcGF0aC5lbnN1cmVTdGF0ZSgnYmx1cicpLnN0eWxlID0gYmx1clN0eWxlO1xuICAgIHBhdGguZW5zdXJlU3RhdGUoJ3NlbGVjdCcpLnN0eWxlID0gc2VsZWN0U3R5bGU7XG4gICAgY3Vyc29yU3R5bGUgJiYgKHBhdGguY3Vyc29yID0gY3Vyc29yU3R5bGUpO1xuICAgIHBhdGguejIgPSBzeW1ib2xNZXRhLnoyO1xuICB9KTtcbiAgdmFyIGJhclBvc2l0aW9uT3V0c2lkZSA9IG9wdC52YWx1ZURpbS5wb3NEZXNjWysoc3ltYm9sTWV0YS5ib3VuZGluZ0xlbmd0aCA+IDApXTtcbiAgdmFyIGJhclJlY3QgPSBiYXIuX19waWN0b3JpYWxCYXJSZWN0O1xuICBzZXRMYWJlbFN0eWxlKGJhclJlY3QsIGdldExhYmVsU3RhdGVzTW9kZWxzKGl0ZW1Nb2RlbCksIHtcbiAgICBsYWJlbEZldGNoZXI6IG9wdC5zZXJpZXNNb2RlbCxcbiAgICBsYWJlbERhdGFJbmRleDogZGF0YUluZGV4LFxuICAgIGRlZmF1bHRUZXh0OiBnZXREZWZhdWx0TGFiZWwob3B0LnNlcmllc01vZGVsLmdldERhdGEoKSwgZGF0YUluZGV4KSxcbiAgICBpbmhlcml0Q29sb3I6IHN5bWJvbE1ldGEuc3R5bGUuZmlsbCxcbiAgICBkZWZhdWx0T3BhY2l0eTogc3ltYm9sTWV0YS5zdHlsZS5vcGFjaXR5LFxuICAgIGRlZmF1bHRPdXRzaWRlUG9zaXRpb246IGJhclBvc2l0aW9uT3V0c2lkZVxuICB9KTtcbiAgZW5hYmxlSG92ZXJFbXBoYXNpcyhiYXIsIGZvY3VzLCBibHVyU2NvcGUpO1xufVxuXG5mdW5jdGlvbiB0b0ludFRpbWVzKHRpbWVzKSB7XG4gIHZhciByb3VuZGVkVGltZXMgPSBNYXRoLnJvdW5kKHRpbWVzKTsgLy8gRXNjYXBzZSBhY2N1cmF0ZSBlcnJvclxuXG4gIHJldHVybiBNYXRoLmFicyh0aW1lcyAtIHJvdW5kZWRUaW1lcykgPCAxZS00ID8gcm91bmRlZFRpbWVzIDogTWF0aC5jZWlsKHRpbWVzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUGljdG9yaWFsQmFyVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBsYXlvdXQsIGxhcmdlTGF5b3V0IH0gZnJvbSAnLi4vLi4vbGF5b3V0L2JhckdyaWQnO1xuaW1wb3J0IGRhdGFTYW1wbGUgZnJvbSAnLi4vLi4vcHJvY2Vzc29yL2RhdGFTYW1wbGUnO1xuaW1wb3J0IEJhclNlcmllcyBmcm9tICcuL0JhclNlcmllcyc7XG5pbXBvcnQgQmFyVmlldyBmcm9tICcuL0JhclZpZXcnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhCYXJWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU2VyaWVzTW9kZWwoQmFyU2VyaWVzKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KHJlZ2lzdGVycy5QUklPUklUWS5WSVNVQUwuTEFZT1VULCB6clV0aWwuY3VycnkobGF5b3V0LCAnYmFyJykpOyAvLyBVc2UgaGlnaGVyIHByb3JpdHkgdG8gYXZvaWQgdG8gYmUgYmxvY2tlZCBieSBvdGhlciBvdmVyYWxsIGxheW91dCwgd2hpY2ggZG8gbm90XG4gIC8vIG9ubHkgZXhpc3QgaW4gdGhpcyBtb2R1bGUsIGJ1dCBwcm9iYWJseSBhbHNvIGV4aXN0IGluIG90aGVyIG1vZHVsZXMsIGxpa2UgYGJhclBvbGFyYC5cblxuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQocmVnaXN0ZXJzLlBSSU9SSVRZLlZJU1VBTC5QUk9HUkVTU0lWRV9MQVlPVVQsIGxhcmdlTGF5b3V0KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyVmlzdWFsKHtcbiAgICBzZXJpZXNUeXBlOiAnYmFyJyxcbiAgICByZXNldDogZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAvLyBWaXN1YWwgY29kaW5nIGZvciBsZWdlbmRcbiAgICAgIHNlcmllc01vZGVsLmdldERhdGEoKS5zZXRWaXN1YWwoJ2xlZ2VuZFN5bWJvbCcsICdyb3VuZFJlY3QnKTtcbiAgICB9XG4gIH0pOyAvLyBEb3duIHNhbXBsZSBhZnRlciBmaWx0ZXJcblxuICByZWdpc3RlcnMucmVnaXN0ZXJQcm9jZXNzb3IocmVnaXN0ZXJzLlBSSU9SSVRZLlBST0NFU1NPUi5TVEFUSVNUSUMsIGRhdGFTYW1wbGUoJ2JhcicpKTtcbiAgLyoqXG4gICAqIEBwYXlsb2FkXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29tcG9uZW50VHlwZT1zZXJpZXNdXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHhdXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHldXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbV1cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcmlnaW5YXVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW29yaWdpblldXG4gICAqL1xuXG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbih7XG4gICAgdHlwZTogJ2NoYW5nZUF4aXNPcmRlcicsXG4gICAgZXZlbnQ6ICdjaGFuZ2VBeGlzT3JkZXInLFxuICAgIHVwZGF0ZTogJ3VwZGF0ZSdcbiAgfSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgICB2YXIgY29tcG9uZW50VHlwZSA9IHBheWxvYWQuY29tcG9uZW50VHlwZSB8fCAnc2VyaWVzJztcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6IGNvbXBvbmVudFR5cGUsXG4gICAgICBxdWVyeTogcGF5bG9hZFxuICAgIH0sIGZ1bmN0aW9uIChjb21wb25lbnRNb2RlbCkge1xuICAgICAgaWYgKHBheWxvYWQuc29ydEluZm8pIHtcbiAgICAgICAgY29tcG9uZW50TW9kZWwuYXhpcy5zZXRDYXRlZ29yeVNvcnRJbmZvKHBheWxvYWQuc29ydEluZm8pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IFBpY3RvcmlhbEJhclZpZXcgZnJvbSAnLi9QaWN0b3JpYWxCYXJWaWV3JztcbmltcG9ydCBQaWN0b3JpYWxCYXJTZXJpZXNNb2RlbCBmcm9tICcuL1BpY3RvcmlhbEJhclNlcmllcyc7XG5pbXBvcnQgeyBsYXlvdXQgfSBmcm9tICcuLi8uLi9sYXlvdXQvYmFyR3JpZCc7XG5pbXBvcnQgeyBjdXJyeSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ2hhcnRWaWV3KFBpY3RvcmlhbEJhclZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChQaWN0b3JpYWxCYXJTZXJpZXNNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckxheW91dChjdXJyeShsYXlvdXQsICdwaWN0b3JpYWxCYXInKSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcyc7XG5pbXBvcnQgeyBXaGlza2VyQm94Q29tbW9uTWl4aW4gfSBmcm9tICcuLi9oZWxwZXIvd2hpc2tlckJveENvbW1vbic7XG5pbXBvcnQgeyBtaXhpbiB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5cbnZhciBCb3hwbG90U2VyaWVzTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQm94cGxvdFNlcmllc01vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEJveHBsb3RTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBCb3hwbG90U2VyaWVzTW9kZWwudHlwZTsgLy8gVE9ET1xuICAgIC8vIGJveCB3aWR0aCByZXByZXNlbnRzIGdyb3VwIHNpemUsIHNvIGRpbWVuc2lvbiBzaG91bGQgaGF2ZSAnc2l6ZScuXG5cbiAgICAvKipcbiAgICAgKiBAc2VlIDxodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Cb3hfcGxvdD5cbiAgICAgKiBUaGUgbWVhbmluZ3Mgb2YgJ21pbicgYW5kICdtYXgnIGRlcGVuZCBvbiB1c2VyLFxuICAgICAqIGFuZCBlY2hhcnRzIGRvIG5vdCBuZWVkIHRvIGtub3cgaXQuXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG5cbiAgICBfdGhpcy5kZWZhdWx0VmFsdWVEaW1lbnNpb25zID0gW3tcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZGVmYXVsdFRvb2x0aXA6IHRydWVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnUTEnLFxuICAgICAgZGVmYXVsdFRvb2x0aXA6IHRydWVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWVkaWFuJyxcbiAgICAgIGRlZmF1bHRUb29sdGlwOiB0cnVlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1EzJyxcbiAgICAgIGRlZmF1bHRUb29sdGlwOiB0cnVlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ21heCcsXG4gICAgICBkZWZhdWx0VG9vbHRpcDogdHJ1ZVxuICAgIH1dO1xuICAgIF90aGlzLnZpc3VhbERyYXdUeXBlID0gJ3N0cm9rZSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgQm94cGxvdFNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLmJveHBsb3QnO1xuICBCb3hwbG90U2VyaWVzTW9kZWwuZGVwZW5kZW5jaWVzID0gWyd4QXhpcycsICd5QXhpcycsICdncmlkJ107XG4gIEJveHBsb3RTZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIHpsZXZlbDogMCxcbiAgICB6OiAyLFxuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdjYXJ0ZXNpYW4yZCcsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIGxheW91dDogbnVsbCxcbiAgICBib3hXaWR0aDogWzcsIDUwXSxcbiAgICBpdGVtU3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICBib3JkZXJXaWR0aDogMVxuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIHNjYWxlOiB0cnVlLFxuICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgIGJvcmRlcldpZHRoOiAyLFxuICAgICAgICBzaGFkb3dCbHVyOiA1LFxuICAgICAgICBzaGFkb3dPZmZzZXRYOiAxLFxuICAgICAgICBzaGFkb3dPZmZzZXRZOiAxLFxuICAgICAgICBzaGFkb3dDb2xvcjogJ3JnYmEoMCwwLDAsMC4yKSdcbiAgICAgIH1cbiAgICB9LFxuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA4MDBcbiAgfTtcbiAgcmV0dXJuIEJveHBsb3RTZXJpZXNNb2RlbDtcbn0oU2VyaWVzTW9kZWwpO1xuXG5taXhpbihCb3hwbG90U2VyaWVzTW9kZWwsIFdoaXNrZXJCb3hDb21tb25NaXhpbiwgdHJ1ZSk7XG5leHBvcnQgZGVmYXVsdCBCb3hwbG90U2VyaWVzTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ2hhcnQnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IHsgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsLCBlbmFibGVIb3ZlckVtcGhhc2lzIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMnO1xuaW1wb3J0IFBhdGggZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoJztcblxudmFyIEJveHBsb3RWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEJveHBsb3RWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEJveHBsb3RWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IEJveHBsb3RWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgQm94cGxvdFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7IC8vIFRoZXJlIGlzIG5vIG9sZCBkYXRhIG9ubHkgd2hlbiBmaXJzdCByZW5kZXJpbmcgb3Igc3dpdGNoaW5nIGZyb21cbiAgICAvLyBzdHJlYW0gbW9kZSB0byBub3JtYWwgbW9kZSwgd2hlcmUgcHJldmlvdXMgZWxlbWVudHMgc2hvdWxkIGJlIHJlbW92ZWQuXG5cbiAgICBpZiAoIXRoaXMuX2RhdGEpIHtcbiAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIH1cblxuICAgIHZhciBjb25zdERpbSA9IHNlcmllc01vZGVsLmdldCgnbGF5b3V0JykgPT09ICdob3Jpem9udGFsJyA/IDEgOiAwO1xuICAgIGRhdGEuZGlmZihvbGREYXRhKS5hZGQoZnVuY3Rpb24gKG5ld0lkeCkge1xuICAgICAgaWYgKGRhdGEuaGFzVmFsdWUobmV3SWR4KSkge1xuICAgICAgICB2YXIgaXRlbUxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChuZXdJZHgpO1xuICAgICAgICB2YXIgc3ltYm9sRWwgPSBjcmVhdGVOb3JtYWxCb3goaXRlbUxheW91dCwgZGF0YSwgbmV3SWR4LCBjb25zdERpbSwgdHJ1ZSk7XG4gICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIHN5bWJvbEVsKTtcbiAgICAgICAgZ3JvdXAuYWRkKHN5bWJvbEVsKTtcbiAgICAgIH1cbiAgICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgICB2YXIgc3ltYm9sRWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTsgLy8gRW1wdHkgZGF0YVxuXG4gICAgICBpZiAoIWRhdGEuaGFzVmFsdWUobmV3SWR4KSkge1xuICAgICAgICBncm91cC5yZW1vdmUoc3ltYm9sRWwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVtTGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KG5ld0lkeCk7XG5cbiAgICAgIGlmICghc3ltYm9sRWwpIHtcbiAgICAgICAgc3ltYm9sRWwgPSBjcmVhdGVOb3JtYWxCb3goaXRlbUxheW91dCwgZGF0YSwgbmV3SWR4LCBjb25zdERpbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVOb3JtYWxCb3hEYXRhKGl0ZW1MYXlvdXQsIHN5bWJvbEVsLCBkYXRhLCBuZXdJZHgpO1xuICAgICAgfVxuXG4gICAgICBncm91cC5hZGQoc3ltYm9sRWwpO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgc3ltYm9sRWwpO1xuICAgIH0pLnJlbW92ZShmdW5jdGlvbiAob2xkSWR4KSB7XG4gICAgICB2YXIgZWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICAgIGVsICYmIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgfSkuZXhlY3V0ZSgpO1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9O1xuXG4gIEJveHBsb3RWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgIGRhdGEgJiYgZGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsICYmIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgfSk7XG4gIH07XG5cbiAgQm94cGxvdFZpZXcudHlwZSA9ICdib3hwbG90JztcbiAgcmV0dXJuIEJveHBsb3RWaWV3O1xufShDaGFydFZpZXcpO1xuXG52YXIgQm94UGF0aFNoYXBlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQm94UGF0aFNoYXBlKCkge31cblxuICByZXR1cm4gQm94UGF0aFNoYXBlO1xufSgpO1xuXG52YXIgQm94UGF0aCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhCb3hQYXRoLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEJveFBhdGgob3B0cykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gJ2JveHBsb3RCb3hQYXRoJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBCb3hQYXRoLnByb3RvdHlwZS5nZXREZWZhdWx0U2hhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBCb3hQYXRoU2hhcGUoKTtcbiAgfTtcblxuICBCb3hQYXRoLnByb3RvdHlwZS5idWlsZFBhdGggPSBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciBlbmRzID0gc2hhcGUucG9pbnRzO1xuICAgIHZhciBpID0gMDtcbiAgICBjdHgubW92ZVRvKGVuZHNbaV1bMF0sIGVuZHNbaV1bMV0pO1xuICAgIGkrKztcblxuICAgIGZvciAoOyBpIDwgNDsgaSsrKSB7XG4gICAgICBjdHgubGluZVRvKGVuZHNbaV1bMF0sIGVuZHNbaV1bMV0pO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgIGZvciAoOyBpIDwgZW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgY3R4Lm1vdmVUbyhlbmRzW2ldWzBdLCBlbmRzW2ldWzFdKTtcbiAgICAgIGkrKztcbiAgICAgIGN0eC5saW5lVG8oZW5kc1tpXVswXSwgZW5kc1tpXVsxXSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBCb3hQYXRoO1xufShQYXRoKTtcblxuZnVuY3Rpb24gY3JlYXRlTm9ybWFsQm94KGl0ZW1MYXlvdXQsIGRhdGEsIGRhdGFJbmRleCwgY29uc3REaW0sIGlzSW5pdCkge1xuICB2YXIgZW5kcyA9IGl0ZW1MYXlvdXQuZW5kcztcbiAgdmFyIGVsID0gbmV3IEJveFBhdGgoe1xuICAgIHNoYXBlOiB7XG4gICAgICBwb2ludHM6IGlzSW5pdCA/IHRyYW5zSW5pdChlbmRzLCBjb25zdERpbSwgaXRlbUxheW91dCkgOiBlbmRzXG4gICAgfVxuICB9KTtcbiAgdXBkYXRlTm9ybWFsQm94RGF0YShpdGVtTGF5b3V0LCBlbCwgZGF0YSwgZGF0YUluZGV4LCBpc0luaXQpO1xuICByZXR1cm4gZWw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5vcm1hbEJveERhdGEoaXRlbUxheW91dCwgZWwsIGRhdGEsIGRhdGFJbmRleCwgaXNJbml0KSB7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICB2YXIgdXBkYXRlTWV0aG9kID0gZ3JhcGhpY1tpc0luaXQgPyAnaW5pdFByb3BzJyA6ICd1cGRhdGVQcm9wcyddO1xuICB1cGRhdGVNZXRob2QoZWwsIHtcbiAgICBzaGFwZToge1xuICAgICAgcG9pbnRzOiBpdGVtTGF5b3V0LmVuZHNcbiAgICB9XG4gIH0sIHNlcmllc01vZGVsLCBkYXRhSW5kZXgpO1xuICBlbC51c2VTdHlsZShkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4LCAnc3R5bGUnKSk7XG4gIGVsLnN0eWxlLnN0cm9rZU5vU2NhbGUgPSB0cnVlO1xuICBlbC56MiA9IDEwMDtcbiAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG4gIHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbChlbCwgaXRlbU1vZGVsKTtcbiAgZW5hYmxlSG92ZXJFbXBoYXNpcyhlbCwgaXRlbU1vZGVsLmdldChbJ2VtcGhhc2lzJywgJ2ZvY3VzJ10pLCBpdGVtTW9kZWwuZ2V0KFsnZW1waGFzaXMnLCAnYmx1clNjb3BlJ10pKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNJbml0KHBvaW50cywgZGltLCBpdGVtTGF5b3V0KSB7XG4gIHJldHVybiB6clV0aWwubWFwKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgcG9pbnQgPSBwb2ludC5zbGljZSgpO1xuICAgIHBvaW50W2RpbV0gPSBpdGVtTGF5b3V0LmluaXRCYXNlbGluZTtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBCb3hwbG90VmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBwYXJzZVBlcmNlbnQgfSBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYm94cGxvdExheW91dChlY01vZGVsKSB7XG4gIHZhciBncm91cFJlc3VsdCA9IGdyb3VwU2VyaWVzQnlBeGlzKGVjTW9kZWwpO1xuICBlYWNoKGdyb3VwUmVzdWx0LCBmdW5jdGlvbiAoZ3JvdXBJdGVtKSB7XG4gICAgdmFyIHNlcmllc01vZGVscyA9IGdyb3VwSXRlbS5zZXJpZXNNb2RlbHM7XG5cbiAgICBpZiAoIXNlcmllc01vZGVscy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxjdWxhdGVCYXNlKGdyb3VwSXRlbSk7XG4gICAgZWFjaChzZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgaWR4KSB7XG4gICAgICBsYXlvdXRTaW5nbGVTZXJpZXMoc2VyaWVzTW9kZWwsIGdyb3VwSXRlbS5ib3hPZmZzZXRMaXN0W2lkeF0sIGdyb3VwSXRlbS5ib3hXaWR0aExpc3RbaWR4XSk7XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXG4gKiBHcm91cCBzZXJpZXMgYnkgYXhpcy5cbiAqL1xuXG5mdW5jdGlvbiBncm91cFNlcmllc0J5QXhpcyhlY01vZGVsKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGF4aXNMaXN0ID0gW107XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgnYm94cGxvdCcsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBiYXNlQXhpcyA9IHNlcmllc01vZGVsLmdldEJhc2VBeGlzKCk7XG4gICAgdmFyIGlkeCA9IHpyVXRpbC5pbmRleE9mKGF4aXNMaXN0LCBiYXNlQXhpcyk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgaWR4ID0gYXhpc0xpc3QubGVuZ3RoO1xuICAgICAgYXhpc0xpc3RbaWR4XSA9IGJhc2VBeGlzO1xuICAgICAgcmVzdWx0W2lkeF0gPSB7XG4gICAgICAgIGF4aXM6IGJhc2VBeGlzLFxuICAgICAgICBzZXJpZXNNb2RlbHM6IFtdXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJlc3VsdFtpZHhdLnNlcmllc01vZGVscy5wdXNoKHNlcmllc01vZGVsKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBvZmZzZXQgYW5kIGJveCB3aWR0aCBmb3IgZWFjaCBzZXJpZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBjYWxjdWxhdGVCYXNlKGdyb3VwSXRlbSkge1xuICB2YXIgZXh0ZW50O1xuICB2YXIgYmFzZUF4aXMgPSBncm91cEl0ZW0uYXhpcztcbiAgdmFyIHNlcmllc01vZGVscyA9IGdyb3VwSXRlbS5zZXJpZXNNb2RlbHM7XG4gIHZhciBzZXJpZXNDb3VudCA9IHNlcmllc01vZGVscy5sZW5ndGg7XG4gIHZhciBib3hXaWR0aExpc3QgPSBncm91cEl0ZW0uYm94V2lkdGhMaXN0ID0gW107XG4gIHZhciBib3hPZmZzZXRMaXN0ID0gZ3JvdXBJdGVtLmJveE9mZnNldExpc3QgPSBbXTtcbiAgdmFyIGJvdW5kTGlzdCA9IFtdO1xuICB2YXIgYmFuZFdpZHRoO1xuXG4gIGlmIChiYXNlQXhpcy50eXBlID09PSAnY2F0ZWdvcnknKSB7XG4gICAgYmFuZFdpZHRoID0gYmFzZUF4aXMuZ2V0QmFuZFdpZHRoKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1heERhdGFDb3VudF8xID0gMDtcbiAgICBlYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICBtYXhEYXRhQ291bnRfMSA9IE1hdGgubWF4KG1heERhdGFDb3VudF8xLCBzZXJpZXNNb2RlbC5nZXREYXRhKCkuY291bnQoKSk7XG4gICAgfSk7XG4gICAgZXh0ZW50ID0gYmFzZUF4aXMuZ2V0RXh0ZW50KCksIE1hdGguYWJzKGV4dGVudFsxXSAtIGV4dGVudFswXSkgLyBtYXhEYXRhQ291bnRfMTtcbiAgfVxuXG4gIGVhY2goc2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgYm94V2lkdGhCb3VuZCA9IHNlcmllc01vZGVsLmdldCgnYm94V2lkdGgnKTtcblxuICAgIGlmICghenJVdGlsLmlzQXJyYXkoYm94V2lkdGhCb3VuZCkpIHtcbiAgICAgIGJveFdpZHRoQm91bmQgPSBbYm94V2lkdGhCb3VuZCwgYm94V2lkdGhCb3VuZF07XG4gICAgfVxuXG4gICAgYm91bmRMaXN0LnB1c2goW3BhcnNlUGVyY2VudChib3hXaWR0aEJvdW5kWzBdLCBiYW5kV2lkdGgpIHx8IDAsIHBhcnNlUGVyY2VudChib3hXaWR0aEJvdW5kWzFdLCBiYW5kV2lkdGgpIHx8IDBdKTtcbiAgfSk7XG4gIHZhciBhdmFpbGFibGVXaWR0aCA9IGJhbmRXaWR0aCAqIDAuOCAtIDI7XG4gIHZhciBib3hHYXAgPSBhdmFpbGFibGVXaWR0aCAvIHNlcmllc0NvdW50ICogMC4zO1xuICB2YXIgYm94V2lkdGggPSAoYXZhaWxhYmxlV2lkdGggLSBib3hHYXAgKiAoc2VyaWVzQ291bnQgLSAxKSkgLyBzZXJpZXNDb3VudDtcbiAgdmFyIGJhc2UgPSBib3hXaWR0aCAvIDIgLSBhdmFpbGFibGVXaWR0aCAvIDI7XG4gIGVhY2goc2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGlkeCkge1xuICAgIGJveE9mZnNldExpc3QucHVzaChiYXNlKTtcbiAgICBiYXNlICs9IGJveEdhcCArIGJveFdpZHRoO1xuICAgIGJveFdpZHRoTGlzdC5wdXNoKE1hdGgubWluKE1hdGgubWF4KGJveFdpZHRoLCBib3VuZExpc3RbaWR4XVswXSksIGJvdW5kTGlzdFtpZHhdWzFdKSk7XG4gIH0pO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgcG9pbnRzIGxvY2F0aW9uIGZvciBlYWNoIHNlcmllcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGxheW91dFNpbmdsZVNlcmllcyhzZXJpZXNNb2RlbCwgb2Zmc2V0LCBib3hXaWR0aCkge1xuICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIGhhbGZXaWR0aCA9IGJveFdpZHRoIC8gMjtcbiAgdmFyIGNEaW1JZHggPSBzZXJpZXNNb2RlbC5nZXQoJ2xheW91dCcpID09PSAnaG9yaXpvbnRhbCcgPyAwIDogMTtcbiAgdmFyIHZEaW1JZHggPSAxIC0gY0RpbUlkeDtcbiAgdmFyIGNvb3JkRGltcyA9IFsneCcsICd5J107XG4gIHZhciBjRGltID0gZGF0YS5tYXBEaW1lbnNpb24oY29vcmREaW1zW2NEaW1JZHhdKTtcbiAgdmFyIHZEaW1zID0gZGF0YS5tYXBEaW1lbnNpb25zQWxsKGNvb3JkRGltc1t2RGltSWR4XSk7XG5cbiAgaWYgKGNEaW0gPT0gbnVsbCB8fCB2RGltcy5sZW5ndGggPCA1KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgZGF0YUluZGV4ID0gMDsgZGF0YUluZGV4IDwgZGF0YS5jb3VudCgpOyBkYXRhSW5kZXgrKykge1xuICAgIHZhciBheGlzRGltVmFsID0gZGF0YS5nZXQoY0RpbSwgZGF0YUluZGV4KTtcbiAgICB2YXIgbWVkaWFuID0gZ2V0UG9pbnQoYXhpc0RpbVZhbCwgdkRpbXNbMl0sIGRhdGFJbmRleCk7XG4gICAgdmFyIGVuZDEgPSBnZXRQb2ludChheGlzRGltVmFsLCB2RGltc1swXSwgZGF0YUluZGV4KTtcbiAgICB2YXIgZW5kMiA9IGdldFBvaW50KGF4aXNEaW1WYWwsIHZEaW1zWzFdLCBkYXRhSW5kZXgpO1xuICAgIHZhciBlbmQ0ID0gZ2V0UG9pbnQoYXhpc0RpbVZhbCwgdkRpbXNbM10sIGRhdGFJbmRleCk7XG4gICAgdmFyIGVuZDUgPSBnZXRQb2ludChheGlzRGltVmFsLCB2RGltc1s0XSwgZGF0YUluZGV4KTtcbiAgICB2YXIgZW5kcyA9IFtdO1xuICAgIGFkZEJvZHlFbmQoZW5kcywgZW5kMiwgZmFsc2UpO1xuICAgIGFkZEJvZHlFbmQoZW5kcywgZW5kNCwgdHJ1ZSk7XG4gICAgZW5kcy5wdXNoKGVuZDEsIGVuZDIsIGVuZDUsIGVuZDQpO1xuICAgIGxheUVuZExpbmUoZW5kcywgZW5kMSk7XG4gICAgbGF5RW5kTGluZShlbmRzLCBlbmQ1KTtcbiAgICBsYXlFbmRMaW5lKGVuZHMsIG1lZGlhbik7XG4gICAgZGF0YS5zZXRJdGVtTGF5b3V0KGRhdGFJbmRleCwge1xuICAgICAgaW5pdEJhc2VsaW5lOiBtZWRpYW5bdkRpbUlkeF0sXG4gICAgICBlbmRzOiBlbmRzXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQb2ludChheGlzRGltVmFsLCBkaW0sIGRhdGFJbmRleCkge1xuICAgIHZhciB2YWwgPSBkYXRhLmdldChkaW0sIGRhdGFJbmRleCk7XG4gICAgdmFyIHAgPSBbXTtcbiAgICBwW2NEaW1JZHhdID0gYXhpc0RpbVZhbDtcbiAgICBwW3ZEaW1JZHhdID0gdmFsO1xuICAgIHZhciBwb2ludDtcblxuICAgIGlmIChpc05hTihheGlzRGltVmFsKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICBwb2ludCA9IFtOYU4sIE5hTl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQocCk7XG4gICAgICBwb2ludFtjRGltSWR4XSArPSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkQm9keUVuZChlbmRzLCBwb2ludCwgc3RhcnQpIHtcbiAgICB2YXIgcG9pbnQxID0gcG9pbnQuc2xpY2UoKTtcbiAgICB2YXIgcG9pbnQyID0gcG9pbnQuc2xpY2UoKTtcbiAgICBwb2ludDFbY0RpbUlkeF0gKz0gaGFsZldpZHRoO1xuICAgIHBvaW50MltjRGltSWR4XSAtPSBoYWxmV2lkdGg7XG4gICAgc3RhcnQgPyBlbmRzLnB1c2gocG9pbnQxLCBwb2ludDIpIDogZW5kcy5wdXNoKHBvaW50MiwgcG9pbnQxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxheUVuZExpbmUoZW5kcywgZW5kQ2VudGVyKSB7XG4gICAgdmFyIGZyb20gPSBlbmRDZW50ZXIuc2xpY2UoKTtcbiAgICB2YXIgdG8gPSBlbmRDZW50ZXIuc2xpY2UoKTtcbiAgICBmcm9tW2NEaW1JZHhdIC09IGhhbGZXaWR0aDtcbiAgICB0b1tjRGltSWR4XSArPSBoYWxmV2lkdGg7XG4gICAgZW5kcy5wdXNoKGZyb20sIHRvKTtcbiAgfVxufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgcHJlcGFyZUJveHBsb3REYXRhIGZyb20gJy4vcHJlcGFyZUJveHBsb3REYXRhJztcbmltcG9ydCB7IHRocm93RXJyb3IsIG1ha2VQcmludGFibGUgfSBmcm9tICcuLi8uLi91dGlsL2xvZyc7XG5pbXBvcnQgeyBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MgfSBmcm9tICcuLi8uLi91dGlsL3R5cGVzJztcbmV4cG9ydCB2YXIgYm94cGxvdFRyYW5zZm9ybSA9IHtcbiAgdHlwZTogJ2VjaGFydHM6Ym94cGxvdCcsXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHBhcmFtcykge1xuICAgIHZhciB1cHN0cmVhbSA9IHBhcmFtcy51cHN0cmVhbTtcblxuICAgIGlmICh1cHN0cmVhbS5zb3VyY2VGb3JtYXQgIT09IFNPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUykge1xuICAgICAgdmFyIGVyck1zZyA9ICcnO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBlcnJNc2cgPSBtYWtlUHJpbnRhYmxlKCdzb3VyY2UgZGF0YSBpcyBub3QgYXBwbGljYWJsZSBmb3IgdGhpcyBib3hwbG90IHRyYW5zZm9ybS4gRXhwZWN0IG51bWJlcltdW10uJyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gcHJlcGFyZUJveHBsb3REYXRhKHVwc3RyZWFtLmdldFJhd0RhdGEoKSwgcGFyYW1zLmNvbmZpZyk7XG4gICAgcmV0dXJuIFt7XG4gICAgICBkaW1lbnNpb25zOiBbJ0l0ZW1OYW1lJywgJ0xvdycsICdRMScsICdRMicsICdRMycsICdIaWdoJ10sXG4gICAgICBkYXRhOiByZXN1bHQuYm94RGF0YVxuICAgIH0sIHtcbiAgICAgIGRhdGE6IHJlc3VsdC5vdXRsaWVyc1xuICAgIH1dO1xuICB9XG59OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBib3hwbG90VmlzdWFsKGVjTW9kZWwsIGFwaSkge1xuICBlY01vZGVsLmVhY2hSYXdTZXJpZXNCeVR5cGUoJ2JveHBsb3QnLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICBzZXJpZXNNb2RlbC5nZXREYXRhKCkuc2V0VmlzdWFsKCdsZWdlbmRTeW1ib2wnLCAncm91bmRSZWN0Jyk7XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgQm94cGxvdFNlcmllc01vZGVsIGZyb20gJy4vQm94cGxvdFNlcmllcyc7XG5pbXBvcnQgQm94cGxvdFZpZXcgZnJvbSAnLi9Cb3hwbG90Vmlldyc7XG5pbXBvcnQgYm94cGxvdFZpc3VhbCBmcm9tICcuL2JveHBsb3RWaXN1YWwnO1xuaW1wb3J0IGJveHBsb3RMYXlvdXQgZnJvbSAnLi9ib3hwbG90TGF5b3V0JztcbmltcG9ydCB7IGJveHBsb3RUcmFuc2Zvcm0gfSBmcm9tICcuL2JveHBsb3RUcmFuc2Zvcm0nO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclNlcmllc01vZGVsKEJveHBsb3RTZXJpZXNNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhCb3hwbG90Vmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclZpc3VhbChib3hwbG90VmlzdWFsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KGJveHBsb3RMYXlvdXQpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJUcmFuc2Zvcm0oYm94cGxvdFRyYW5zZm9ybSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IHF1YW50aWxlLCBhc2MgfSBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc1N0cmluZyB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG4vKipcbiAqIFNlZTpcbiAqICA8aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQm94X3Bsb3QjY2l0ZV9ub3RlLWZyaWdnZV9ob2FnbGluX2lnbGV3aWN6LTI+XG4gKiAgPGh0dHA6Ly9zdGF0LmV0aHouY2gvUi1tYW51YWwvUi1kZXZlbC9saWJyYXJ5L2dyRGV2aWNlcy9odG1sL2JveHBsb3Quc3RhdHMuaHRtbD5cbiAqXG4gKiBIZWxwZXIgbWV0aG9kIGZvciBwcmVwYXJpbmcgZGF0YS5cbiAqXG4gKiBAcGFyYW0gcmF3RGF0YSBsaWtlXG4gKiAgICAgICAgW1xuICogICAgICAgICAgICBbMTIsMjMyLDQ0M10sIChyYXcgZGF0YSBzZXQgZm9yIHRoZSBmaXJzdCBib3gpXG4gKiAgICAgICAgICAgIFszODQzLDU1NDUsMTIzMl0sIChyYXcgZGF0YSBzZXQgZm9yIHRoZSBzZWNvbmQgYm94KVxuICogICAgICAgICAgICAuLi5cbiAqICAgICAgICBdXG4gKiBAcGFyYW0gb3B0LmJvdW5kSVFSPTEuNSBEYXRhIGxlc3MgdGhhbiBtaW4gYm91bmQgaXMgb3V0bGllci5cbiAqICAgICAgZGVmYXVsdCAxLjUsIG1lYW5zIFExIC0gMS41ICogKFEzIC0gUTEpLlxuICogICAgICBJZiAnbm9uZScvMCBwYXNzZWQsIG1pbiBib3VuZCB3aWxsIG5vdCBiZSB1c2VkLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByZXBhcmVCb3hwbG90RGF0YShyYXdEYXRhLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICB2YXIgYm94RGF0YSA9IFtdO1xuICB2YXIgb3V0bGllcnMgPSBbXTtcbiAgdmFyIGJvdW5kSVFSID0gb3B0LmJvdW5kSVFSO1xuICB2YXIgdXNlRXh0cmVtZSA9IGJvdW5kSVFSID09PSAnbm9uZScgfHwgYm91bmRJUVIgPT09IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGFzY0xpc3QgPSBhc2MocmF3RGF0YVtpXS5zbGljZSgpKTtcbiAgICB2YXIgUTEgPSBxdWFudGlsZShhc2NMaXN0LCAwLjI1KTtcbiAgICB2YXIgUTIgPSBxdWFudGlsZShhc2NMaXN0LCAwLjUpO1xuICAgIHZhciBRMyA9IHF1YW50aWxlKGFzY0xpc3QsIDAuNzUpO1xuICAgIHZhciBtaW4gPSBhc2NMaXN0WzBdO1xuICAgIHZhciBtYXggPSBhc2NMaXN0W2FzY0xpc3QubGVuZ3RoIC0gMV07XG4gICAgdmFyIGJvdW5kID0gKGJvdW5kSVFSID09IG51bGwgPyAxLjUgOiBib3VuZElRUikgKiAoUTMgLSBRMSk7XG4gICAgdmFyIGxvdyA9IHVzZUV4dHJlbWUgPyBtaW4gOiBNYXRoLm1heChtaW4sIFExIC0gYm91bmQpO1xuICAgIHZhciBoaWdoID0gdXNlRXh0cmVtZSA/IG1heCA6IE1hdGgubWluKG1heCwgUTMgKyBib3VuZCk7XG4gICAgdmFyIGl0ZW1OYW1lRm9ybWF0dGVyID0gb3B0Lml0ZW1OYW1lRm9ybWF0dGVyO1xuICAgIHZhciBpdGVtTmFtZSA9IGlzRnVuY3Rpb24oaXRlbU5hbWVGb3JtYXR0ZXIpID8gaXRlbU5hbWVGb3JtYXR0ZXIoe1xuICAgICAgdmFsdWU6IGlcbiAgICB9KSA6IGlzU3RyaW5nKGl0ZW1OYW1lRm9ybWF0dGVyKSA/IGl0ZW1OYW1lRm9ybWF0dGVyLnJlcGxhY2UoJ3t2YWx1ZX0nLCBpICsgJycpIDogaSArICcnO1xuICAgIGJveERhdGEucHVzaChbaXRlbU5hbWUsIGxvdywgUTEsIFEyLCBRMywgaGlnaF0pO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhc2NMaXN0Lmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZGF0YUl0ZW0gPSBhc2NMaXN0W2pdO1xuXG4gICAgICBpZiAoZGF0YUl0ZW0gPCBsb3cgfHwgZGF0YUl0ZW0gPiBoaWdoKSB7XG4gICAgICAgIHZhciBvdXRsaWVyID0gW2l0ZW1OYW1lLCBkYXRhSXRlbV07XG4gICAgICAgIG91dGxpZXJzLnB1c2gob3V0bGllcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBib3hEYXRhOiBib3hEYXRhLFxuICAgIG91dGxpZXJzOiBvdXRsaWVyc1xuICB9O1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9TZXJpZXMnO1xuaW1wb3J0IHsgV2hpc2tlckJveENvbW1vbk1peGluIH0gZnJvbSAnLi4vaGVscGVyL3doaXNrZXJCb3hDb21tb24nO1xuaW1wb3J0IHsgbWl4aW4gfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuXG52YXIgQ2FuZGxlc3RpY2tTZXJpZXNNb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDYW5kbGVzdGlja1Nlcmllc01vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIENhbmRsZXN0aWNrU2VyaWVzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gQ2FuZGxlc3RpY2tTZXJpZXNNb2RlbC50eXBlO1xuICAgIF90aGlzLmRlZmF1bHRWYWx1ZURpbWVuc2lvbnMgPSBbe1xuICAgICAgbmFtZTogJ29wZW4nLFxuICAgICAgZGVmYXVsdFRvb2x0aXA6IHRydWVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnY2xvc2UnLFxuICAgICAgZGVmYXVsdFRvb2x0aXA6IHRydWVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbG93ZXN0JyxcbiAgICAgIGRlZmF1bHRUb29sdGlwOiB0cnVlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2hpZ2hlc3QnLFxuICAgICAgZGVmYXVsdFRvb2x0aXA6IHRydWVcbiAgICB9XTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBkaW1lbnNpb24gZm9yIHNoYWRvdyBpbiBkYXRhWm9vbVxuICAgKiBAcmV0dXJuIGRpbWVuc2lvbiBuYW1lXG4gICAqL1xuXG5cbiAgQ2FuZGxlc3RpY2tTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0U2hhZG93RGltID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnb3Blbic7XG4gIH07XG5cbiAgQ2FuZGxlc3RpY2tTZXJpZXNNb2RlbC5wcm90b3R5cGUuYnJ1c2hTZWxlY3RvciA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIGRhdGEsIHNlbGVjdG9ycykge1xuICAgIHZhciBpdGVtTGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGRhdGFJbmRleCk7XG4gICAgcmV0dXJuIGl0ZW1MYXlvdXQgJiYgc2VsZWN0b3JzLnJlY3QoaXRlbUxheW91dC5icnVzaFJlY3QpO1xuICB9O1xuXG4gIENhbmRsZXN0aWNrU2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMuY2FuZGxlc3RpY2snO1xuICBDYW5kbGVzdGlja1Nlcmllc01vZGVsLmRlcGVuZGVuY2llcyA9IFsneEF4aXMnLCAneUF4aXMnLCAnZ3JpZCddO1xuICBDYW5kbGVzdGlja1Nlcmllc01vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgY29vcmRpbmF0ZVN5c3RlbTogJ2NhcnRlc2lhbjJkJyxcbiAgICBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG4gICAgLy8geEF4aXNJbmRleDogMCxcbiAgICAvLyB5QXhpc0luZGV4OiAwLFxuICAgIGxheW91dDogbnVsbCxcbiAgICBjbGlwOiB0cnVlLFxuICAgIGl0ZW1TdHlsZToge1xuICAgICAgY29sb3I6ICcjZWI1NDU0JyxcbiAgICAgIGNvbG9yMDogJyM0N2IyNjInLFxuICAgICAgYm9yZGVyQ29sb3I6ICcjZWI1NDU0JyxcbiAgICAgIGJvcmRlckNvbG9yMDogJyM0N2IyNjInLFxuICAgICAgLy8gYm9yZGVyQ29sb3I6ICcjZDI0MDQwJyxcbiAgICAgIC8vIGJvcmRlckNvbG9yMDogJyMzOThmNGYnLFxuICAgICAgYm9yZGVyV2lkdGg6IDFcbiAgICB9LFxuICAgIGVtcGhhc2lzOiB7XG4gICAgICBzY2FsZTogdHJ1ZSxcbiAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICBib3JkZXJXaWR0aDogMlxuICAgICAgfVxuICAgIH0sXG4gICAgYmFyTWF4V2lkdGg6IG51bGwsXG4gICAgYmFyTWluV2lkdGg6IG51bGwsXG4gICAgYmFyV2lkdGg6IG51bGwsXG4gICAgbGFyZ2U6IHRydWUsXG4gICAgbGFyZ2VUaHJlc2hvbGQ6IDYwMCxcbiAgICBwcm9ncmVzc2l2ZTogM2UzLFxuICAgIHByb2dyZXNzaXZlVGhyZXNob2xkOiAxZTQsXG4gICAgcHJvZ3Jlc3NpdmVDaHVua01vZGU6ICdtb2QnLFxuICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcicsXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDMwMFxuICB9O1xuICByZXR1cm4gQ2FuZGxlc3RpY2tTZXJpZXNNb2RlbDtcbn0oU2VyaWVzTW9kZWwpO1xuXG5taXhpbihDYW5kbGVzdGlja1Nlcmllc01vZGVsLCBXaGlza2VyQm94Q29tbW9uTWl4aW4sIHRydWUpO1xuZXhwb3J0IGRlZmF1bHQgQ2FuZGxlc3RpY2tTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBDaGFydFZpZXcgZnJvbSAnLi4vLi4vdmlldy9DaGFydCc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgeyBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcyc7XG5pbXBvcnQgUGF0aCBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL1BhdGgnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpcFBhdGggfSBmcm9tICcuLi9oZWxwZXIvY3JlYXRlQ2xpcFBhdGhGcm9tQ29vcmRTeXMnO1xudmFyIFNLSVBfUFJPUFMgPSBbJ2NvbG9yJywgJ2JvcmRlckNvbG9yJ107XG5cbnZhciBDYW5kbGVzdGlja1ZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ2FuZGxlc3RpY2tWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIENhbmRsZXN0aWNrVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBDYW5kbGVzdGlja1ZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBDYW5kbGVzdGlja1ZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgY2xpcFBhdGggY3JlYXRlZCBpbiBsYXJnZSBtb2RlLiBSZW1vdmUgaXQuXG4gICAgdGhpcy5ncm91cC5yZW1vdmVDbGlwUGF0aCgpO1xuXG4gICAgdGhpcy5fdXBkYXRlRHJhd01vZGUoc2VyaWVzTW9kZWwpO1xuXG4gICAgdGhpcy5faXNMYXJnZURyYXcgPyB0aGlzLl9yZW5kZXJMYXJnZShzZXJpZXNNb2RlbCkgOiB0aGlzLl9yZW5kZXJOb3JtYWwoc2VyaWVzTW9kZWwpO1xuICB9O1xuXG4gIENhbmRsZXN0aWNrVmlldy5wcm90b3R5cGUuaW5jcmVtZW50YWxQcmVwYXJlUmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLl9jbGVhcigpO1xuXG4gICAgdGhpcy5fdXBkYXRlRHJhd01vZGUoc2VyaWVzTW9kZWwpO1xuICB9O1xuXG4gIENhbmRsZXN0aWNrVmlldy5wcm90b3R5cGUuaW5jcmVtZW50YWxSZW5kZXIgPSBmdW5jdGlvbiAocGFyYW1zLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5faXNMYXJnZURyYXcgPyB0aGlzLl9pbmNyZW1lbnRhbFJlbmRlckxhcmdlKHBhcmFtcywgc2VyaWVzTW9kZWwpIDogdGhpcy5faW5jcmVtZW50YWxSZW5kZXJOb3JtYWwocGFyYW1zLCBzZXJpZXNNb2RlbCk7XG4gIH07XG5cbiAgQ2FuZGxlc3RpY2tWaWV3LnByb3RvdHlwZS5fdXBkYXRlRHJhd01vZGUgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgaXNMYXJnZURyYXcgPSBzZXJpZXNNb2RlbC5waXBlbGluZUNvbnRleHQubGFyZ2U7XG5cbiAgICBpZiAodGhpcy5faXNMYXJnZURyYXcgPT0gbnVsbCB8fCBpc0xhcmdlRHJhdyAhPT0gdGhpcy5faXNMYXJnZURyYXcpIHtcbiAgICAgIHRoaXMuX2lzTGFyZ2VEcmF3ID0gaXNMYXJnZURyYXc7XG5cbiAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgfVxuICB9O1xuXG4gIENhbmRsZXN0aWNrVmlldy5wcm90b3R5cGUuX3JlbmRlck5vcm1hbCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBpc1NpbXBsZUJveCA9IGRhdGEuZ2V0TGF5b3V0KCdpc1NpbXBsZUJveCcpO1xuICAgIHZhciBuZWVkc0NsaXAgPSBzZXJpZXNNb2RlbC5nZXQoJ2NsaXAnLCB0cnVlKTtcbiAgICB2YXIgY29vcmQgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBjbGlwQXJlYSA9IGNvb3JkLmdldEFyZWEgJiYgY29vcmQuZ2V0QXJlYSgpOyAvLyBUaGVyZSBpcyBubyBvbGQgZGF0YSBvbmx5IHdoZW4gZmlyc3QgcmVuZGVyaW5nIG9yIHN3aXRjaGluZyBmcm9tXG4gICAgLy8gc3RyZWFtIG1vZGUgdG8gbm9ybWFsIG1vZGUsIHdoZXJlIHByZXZpb3VzIGVsZW1lbnRzIHNob3VsZCBiZSByZW1vdmVkLlxuXG4gICAgaWYgKCF0aGlzLl9kYXRhKSB7XG4gICAgICBncm91cC5yZW1vdmVBbGwoKTtcbiAgICB9XG5cbiAgICBkYXRhLmRpZmYob2xkRGF0YSkuYWRkKGZ1bmN0aW9uIChuZXdJZHgpIHtcbiAgICAgIGlmIChkYXRhLmhhc1ZhbHVlKG5ld0lkeCkpIHtcbiAgICAgICAgdmFyIGl0ZW1MYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KTtcblxuICAgICAgICBpZiAobmVlZHNDbGlwICYmIGlzTm9ybWFsQm94Q2xpcHBlZChjbGlwQXJlYSwgaXRlbUxheW91dCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWwgPSBjcmVhdGVOb3JtYWxCb3goaXRlbUxheW91dCwgbmV3SWR4LCB0cnVlKTtcbiAgICAgICAgZ3JhcGhpYy5pbml0UHJvcHMoZWwsIHtcbiAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgcG9pbnRzOiBpdGVtTGF5b3V0LmVuZHNcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHNlcmllc01vZGVsLCBuZXdJZHgpO1xuICAgICAgICBzZXRCb3hDb21tb24oZWwsIGRhdGEsIG5ld0lkeCwgaXNTaW1wbGVCb3gpO1xuICAgICAgICBncm91cC5hZGQoZWwpO1xuICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBlbCk7XG4gICAgICB9XG4gICAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgdmFyIGVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7IC8vIEVtcHR5IGRhdGFcblxuICAgICAgaWYgKCFkYXRhLmhhc1ZhbHVlKG5ld0lkeCkpIHtcbiAgICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlbUxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChuZXdJZHgpO1xuXG4gICAgICBpZiAobmVlZHNDbGlwICYmIGlzTm9ybWFsQm94Q2xpcHBlZChjbGlwQXJlYSwgaXRlbUxheW91dCkpIHtcbiAgICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIGVsID0gY3JlYXRlTm9ybWFsQm94KGl0ZW1MYXlvdXQsIG5ld0lkeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCB7XG4gICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHBvaW50czogaXRlbUxheW91dC5lbmRzXG4gICAgICAgICAgfVxuICAgICAgICB9LCBzZXJpZXNNb2RlbCwgbmV3SWR4KTtcbiAgICAgIH1cblxuICAgICAgc2V0Qm94Q29tbW9uKGVsLCBkYXRhLCBuZXdJZHgsIGlzU2ltcGxlQm94KTtcbiAgICAgIGdyb3VwLmFkZChlbCk7XG4gICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBlbCk7XG4gICAgfSkucmVtb3ZlKGZ1bmN0aW9uIChvbGRJZHgpIHtcbiAgICAgIHZhciBlbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuICAgICAgZWwgJiYgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICB9KS5leGVjdXRlKCk7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH07XG5cbiAgQ2FuZGxlc3RpY2tWaWV3LnByb3RvdHlwZS5fcmVuZGVyTGFyZ2UgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB0aGlzLl9jbGVhcigpO1xuXG4gICAgY3JlYXRlTGFyZ2Uoc2VyaWVzTW9kZWwsIHRoaXMuZ3JvdXApO1xuICAgIHZhciBjbGlwUGF0aCA9IHNlcmllc01vZGVsLmdldCgnY2xpcCcsIHRydWUpID8gY3JlYXRlQ2xpcFBhdGgoc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSwgZmFsc2UsIHNlcmllc01vZGVsKSA6IG51bGw7XG5cbiAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgIHRoaXMuZ3JvdXAuc2V0Q2xpcFBhdGgoY2xpcFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdyb3VwLnJlbW92ZUNsaXBQYXRoKCk7XG4gICAgfVxuICB9O1xuXG4gIENhbmRsZXN0aWNrVmlldy5wcm90b3R5cGUuX2luY3JlbWVudGFsUmVuZGVyTm9ybWFsID0gZnVuY3Rpb24gKHBhcmFtcywgc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgaXNTaW1wbGVCb3ggPSBkYXRhLmdldExheW91dCgnaXNTaW1wbGVCb3gnKTtcbiAgICB2YXIgZGF0YUluZGV4O1xuXG4gICAgd2hpbGUgKChkYXRhSW5kZXggPSBwYXJhbXMubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICB2YXIgaXRlbUxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChkYXRhSW5kZXgpO1xuICAgICAgdmFyIGVsID0gY3JlYXRlTm9ybWFsQm94KGl0ZW1MYXlvdXQsIGRhdGFJbmRleCk7XG4gICAgICBzZXRCb3hDb21tb24oZWwsIGRhdGEsIGRhdGFJbmRleCwgaXNTaW1wbGVCb3gpO1xuICAgICAgZWwuaW5jcmVtZW50YWwgPSB0cnVlO1xuICAgICAgdGhpcy5ncm91cC5hZGQoZWwpO1xuICAgIH1cbiAgfTtcblxuICBDYW5kbGVzdGlja1ZpZXcucHJvdG90eXBlLl9pbmNyZW1lbnRhbFJlbmRlckxhcmdlID0gZnVuY3Rpb24gKHBhcmFtcywgc2VyaWVzTW9kZWwpIHtcbiAgICBjcmVhdGVMYXJnZShzZXJpZXNNb2RlbCwgdGhpcy5ncm91cCwgdHJ1ZSk7XG4gIH07XG5cbiAgQ2FuZGxlc3RpY2tWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIHRoaXMuX2NsZWFyKCk7XG4gIH07XG5cbiAgQ2FuZGxlc3RpY2tWaWV3LnByb3RvdHlwZS5fY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgfTtcblxuICBDYW5kbGVzdGlja1ZpZXcudHlwZSA9ICdjYW5kbGVzdGljayc7XG4gIHJldHVybiBDYW5kbGVzdGlja1ZpZXc7XG59KENoYXJ0Vmlldyk7XG5cbnZhciBOb3JtYWxCb3hQYXRoU2hhcGUgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb3JtYWxCb3hQYXRoU2hhcGUoKSB7fVxuXG4gIHJldHVybiBOb3JtYWxCb3hQYXRoU2hhcGU7XG59KCk7XG5cbnZhciBOb3JtYWxCb3hQYXRoID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKE5vcm1hbEJveFBhdGgsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gTm9ybWFsQm94UGF0aChvcHRzKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSAnbm9ybWFsQ2FuZGxlc3RpY2tCb3gnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIE5vcm1hbEJveFBhdGgucHJvdG90eXBlLmdldERlZmF1bHRTaGFwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IE5vcm1hbEJveFBhdGhTaGFwZSgpO1xuICB9O1xuXG4gIE5vcm1hbEJveFBhdGgucHJvdG90eXBlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIGVuZHMgPSBzaGFwZS5wb2ludHM7XG5cbiAgICBpZiAodGhpcy5fX3NpbXBsZUJveCkge1xuICAgICAgY3R4Lm1vdmVUbyhlbmRzWzRdWzBdLCBlbmRzWzRdWzFdKTtcbiAgICAgIGN0eC5saW5lVG8oZW5kc1s2XVswXSwgZW5kc1s2XVsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5tb3ZlVG8oZW5kc1swXVswXSwgZW5kc1swXVsxXSk7XG4gICAgICBjdHgubGluZVRvKGVuZHNbMV1bMF0sIGVuZHNbMV1bMV0pO1xuICAgICAgY3R4LmxpbmVUbyhlbmRzWzJdWzBdLCBlbmRzWzJdWzFdKTtcbiAgICAgIGN0eC5saW5lVG8oZW5kc1szXVswXSwgZW5kc1szXVsxXSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKGVuZHNbNF1bMF0sIGVuZHNbNF1bMV0pO1xuICAgICAgY3R4LmxpbmVUbyhlbmRzWzVdWzBdLCBlbmRzWzVdWzFdKTtcbiAgICAgIGN0eC5tb3ZlVG8oZW5kc1s2XVswXSwgZW5kc1s2XVsxXSk7XG4gICAgICBjdHgubGluZVRvKGVuZHNbN11bMF0sIGVuZHNbN11bMV0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTm9ybWFsQm94UGF0aDtcbn0oUGF0aCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vcm1hbEJveChpdGVtTGF5b3V0LCBkYXRhSW5kZXgsIGlzSW5pdCkge1xuICB2YXIgZW5kcyA9IGl0ZW1MYXlvdXQuZW5kcztcbiAgcmV0dXJuIG5ldyBOb3JtYWxCb3hQYXRoKHtcbiAgICBzaGFwZToge1xuICAgICAgcG9pbnRzOiBpc0luaXQgPyB0cmFuc0luaXQoZW5kcywgaXRlbUxheW91dCkgOiBlbmRzXG4gICAgfSxcbiAgICB6MjogMTAwXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc05vcm1hbEJveENsaXBwZWQoY2xpcEFyZWEsIGl0ZW1MYXlvdXQpIHtcbiAgdmFyIGNsaXBwZWQgPSB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbUxheW91dC5lbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gSWYgYW55IHBvaW50IGFyZSBpbiB0aGUgcmVnaW9uLlxuICAgIGlmIChjbGlwQXJlYS5jb250YWluKGl0ZW1MYXlvdXQuZW5kc1tpXVswXSwgaXRlbUxheW91dC5lbmRzW2ldWzFdKSkge1xuICAgICAgY2xpcHBlZCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsaXBwZWQ7XG59XG5cbmZ1bmN0aW9uIHNldEJveENvbW1vbihlbCwgZGF0YSwgZGF0YUluZGV4LCBpc1NpbXBsZUJveCkge1xuICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KTtcbiAgZWwudXNlU3R5bGUoZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ3N0eWxlJykpO1xuICBlbC5zdHlsZS5zdHJva2VOb1NjYWxlID0gdHJ1ZTtcbiAgZWwuX19zaW1wbGVCb3ggPSBpc1NpbXBsZUJveDtcbiAgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsKGVsLCBpdGVtTW9kZWwpO1xufVxuXG5mdW5jdGlvbiB0cmFuc0luaXQocG9pbnRzLCBpdGVtTGF5b3V0KSB7XG4gIHJldHVybiB6clV0aWwubWFwKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgcG9pbnQgPSBwb2ludC5zbGljZSgpO1xuICAgIHBvaW50WzFdID0gaXRlbUxheW91dC5pbml0QmFzZWxpbmU7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9KTtcbn1cblxudmFyIExhcmdlQm94UGF0aFNoYXBlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGFyZ2VCb3hQYXRoU2hhcGUoKSB7fVxuXG4gIHJldHVybiBMYXJnZUJveFBhdGhTaGFwZTtcbn0oKTtcblxudmFyIExhcmdlQm94UGF0aCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhMYXJnZUJveFBhdGgsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gTGFyZ2VCb3hQYXRoKG9wdHMpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9ICdsYXJnZUNhbmRsZXN0aWNrQm94JztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBMYXJnZUJveFBhdGgucHJvdG90eXBlLmdldERlZmF1bHRTaGFwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IExhcmdlQm94UGF0aFNoYXBlKCk7XG4gIH07XG5cbiAgTGFyZ2VCb3hQYXRoLnByb3RvdHlwZS5idWlsZFBhdGggPSBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIC8vIERyYXdpbmcgbGluZXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBkcmF3aW5nXG4gICAgLy8gYSB3aG9sZSBsaW5lIG9yIGRyYXdpbmcgcmVjdHMuXG4gICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDspIHtcbiAgICAgIGlmICh0aGlzLl9fc2lnbiA9PT0gcG9pbnRzW2krK10pIHtcbiAgICAgICAgdmFyIHggPSBwb2ludHNbaSsrXTtcbiAgICAgICAgY3R4Lm1vdmVUbyh4LCBwb2ludHNbaSsrXSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgcG9pbnRzW2krK10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSArPSAzO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTGFyZ2VCb3hQYXRoO1xufShQYXRoKTtcblxuZnVuY3Rpb24gY3JlYXRlTGFyZ2Uoc2VyaWVzTW9kZWwsIGdyb3VwLCBpbmNyZW1lbnRhbCkge1xuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIGxhcmdlUG9pbnRzID0gZGF0YS5nZXRMYXlvdXQoJ2xhcmdlUG9pbnRzJyk7XG4gIHZhciBlbFAgPSBuZXcgTGFyZ2VCb3hQYXRoKHtcbiAgICBzaGFwZToge1xuICAgICAgcG9pbnRzOiBsYXJnZVBvaW50c1xuICAgIH0sXG4gICAgX19zaWduOiAxXG4gIH0pO1xuICBncm91cC5hZGQoZWxQKTtcbiAgdmFyIGVsTiA9IG5ldyBMYXJnZUJveFBhdGgoe1xuICAgIHNoYXBlOiB7XG4gICAgICBwb2ludHM6IGxhcmdlUG9pbnRzXG4gICAgfSxcbiAgICBfX3NpZ246IC0xXG4gIH0pO1xuICBncm91cC5hZGQoZWxOKTtcbiAgc2V0TGFyZ2VTdHlsZSgxLCBlbFAsIHNlcmllc01vZGVsLCBkYXRhKTtcbiAgc2V0TGFyZ2VTdHlsZSgtMSwgZWxOLCBzZXJpZXNNb2RlbCwgZGF0YSk7XG5cbiAgaWYgKGluY3JlbWVudGFsKSB7XG4gICAgZWxQLmluY3JlbWVudGFsID0gdHJ1ZTtcbiAgICBlbE4uaW5jcmVtZW50YWwgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldExhcmdlU3R5bGUoc2lnbiwgZWwsIHNlcmllc01vZGVsLCBkYXRhKSB7XG4gIC8vIFRPRE8gcHV0IGluIHZpc3VhbD9cbiAgdmFyIGJvcmRlckNvbG9yID0gc2VyaWVzTW9kZWwuZ2V0KFsnaXRlbVN0eWxlJywgc2lnbiA+IDAgPyAnYm9yZGVyQ29sb3InIDogJ2JvcmRlckNvbG9yMCddKSB8fCBzZXJpZXNNb2RlbC5nZXQoWydpdGVtU3R5bGUnLCBzaWduID4gMCA/ICdjb2xvcicgOiAnY29sb3IwJ10pOyAvLyBDb2xvciBtdXN0IGJlIGV4Y2x1ZGVkLlxuICAvLyBCZWNhdXNlIHN5bWJvbCBwcm92aWRlIHNldENvbG9yIGluZGl2aWR1YWxseSB0byBzZXQgZmlsbCBhbmQgc3Ryb2tlXG5cbiAgdmFyIGl0ZW1TdHlsZSA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKS5nZXRJdGVtU3R5bGUoU0tJUF9QUk9QUyk7XG4gIGVsLnVzZVN0eWxlKGl0ZW1TdHlsZSk7XG4gIGVsLnN0eWxlLmZpbGwgPSBudWxsO1xuICBlbC5zdHlsZS5zdHJva2UgPSBib3JkZXJDb2xvcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FuZGxlc3RpY2tWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qIGdsb2JhbCBGbG9hdDMyQXJyYXkgKi9cbmltcG9ydCB7IHN1YlBpeGVsT3B0aW1pemUgfSBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IGNyZWF0ZVJlbmRlclBsYW5uZXIgZnJvbSAnLi4vaGVscGVyL2NyZWF0ZVJlbmRlclBsYW5uZXInO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50IH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXInO1xuaW1wb3J0IHsgcmV0cmlldmUyIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbnZhciBMYXJnZUFyciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG52YXIgY2FuZGxlc3RpY2tMYXlvdXQgPSB7XG4gIHNlcmllc1R5cGU6ICdjYW5kbGVzdGljaycsXG4gIHBsYW46IGNyZWF0ZVJlbmRlclBsYW5uZXIoKSxcbiAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGNhbmRsZVdpZHRoID0gY2FsY3VsYXRlQ2FuZGxlV2lkdGgoc2VyaWVzTW9kZWwsIGRhdGEpO1xuICAgIHZhciBjRGltSWR4ID0gMDtcbiAgICB2YXIgdkRpbUlkeCA9IDE7XG4gICAgdmFyIGNvb3JkRGltcyA9IFsneCcsICd5J107XG4gICAgdmFyIGNEaW0gPSBkYXRhLm1hcERpbWVuc2lvbihjb29yZERpbXNbY0RpbUlkeF0pO1xuICAgIHZhciB2RGltcyA9IGRhdGEubWFwRGltZW5zaW9uc0FsbChjb29yZERpbXNbdkRpbUlkeF0pO1xuICAgIHZhciBvcGVuRGltID0gdkRpbXNbMF07XG4gICAgdmFyIGNsb3NlRGltID0gdkRpbXNbMV07XG4gICAgdmFyIGxvd2VzdERpbSA9IHZEaW1zWzJdO1xuICAgIHZhciBoaWdoZXN0RGltID0gdkRpbXNbM107XG4gICAgZGF0YS5zZXRMYXlvdXQoe1xuICAgICAgY2FuZGxlV2lkdGg6IGNhbmRsZVdpZHRoLFxuICAgICAgLy8gVGhlIHZhbHVlIGlzIGV4cGVyaW1lbnRlZCB2aXN1YWxseS5cbiAgICAgIGlzU2ltcGxlQm94OiBjYW5kbGVXaWR0aCA8PSAxLjNcbiAgICB9KTtcblxuICAgIGlmIChjRGltID09IG51bGwgfHwgdkRpbXMubGVuZ3RoIDwgNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwcm9ncmVzczogc2VyaWVzTW9kZWwucGlwZWxpbmVDb250ZXh0LmxhcmdlID8gbGFyZ2VQcm9ncmVzcyA6IG5vcm1hbFByb2dyZXNzXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbFByb2dyZXNzKHBhcmFtcywgZGF0YSkge1xuICAgICAgdmFyIGRhdGFJbmRleDtcblxuICAgICAgd2hpbGUgKChkYXRhSW5kZXggPSBwYXJhbXMubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBheGlzRGltVmFsID0gZGF0YS5nZXQoY0RpbSwgZGF0YUluZGV4KTtcbiAgICAgICAgdmFyIG9wZW5WYWwgPSBkYXRhLmdldChvcGVuRGltLCBkYXRhSW5kZXgpO1xuICAgICAgICB2YXIgY2xvc2VWYWwgPSBkYXRhLmdldChjbG9zZURpbSwgZGF0YUluZGV4KTtcbiAgICAgICAgdmFyIGxvd2VzdFZhbCA9IGRhdGEuZ2V0KGxvd2VzdERpbSwgZGF0YUluZGV4KTtcbiAgICAgICAgdmFyIGhpZ2hlc3RWYWwgPSBkYXRhLmdldChoaWdoZXN0RGltLCBkYXRhSW5kZXgpO1xuICAgICAgICB2YXIgb2NMb3cgPSBNYXRoLm1pbihvcGVuVmFsLCBjbG9zZVZhbCk7XG4gICAgICAgIHZhciBvY0hpZ2ggPSBNYXRoLm1heChvcGVuVmFsLCBjbG9zZVZhbCk7XG4gICAgICAgIHZhciBvY0xvd1BvaW50ID0gZ2V0UG9pbnQob2NMb3csIGF4aXNEaW1WYWwpO1xuICAgICAgICB2YXIgb2NIaWdoUG9pbnQgPSBnZXRQb2ludChvY0hpZ2gsIGF4aXNEaW1WYWwpO1xuICAgICAgICB2YXIgbG93ZXN0UG9pbnQgPSBnZXRQb2ludChsb3dlc3RWYWwsIGF4aXNEaW1WYWwpO1xuICAgICAgICB2YXIgaGlnaGVzdFBvaW50ID0gZ2V0UG9pbnQoaGlnaGVzdFZhbCwgYXhpc0RpbVZhbCk7XG4gICAgICAgIHZhciBlbmRzID0gW107XG4gICAgICAgIGFkZEJvZHlFbmQoZW5kcywgb2NIaWdoUG9pbnQsIDApO1xuICAgICAgICBhZGRCb2R5RW5kKGVuZHMsIG9jTG93UG9pbnQsIDEpO1xuICAgICAgICBlbmRzLnB1c2goc3ViUGl4ZWxPcHRpbWl6ZVBvaW50KGhpZ2hlc3RQb2ludCksIHN1YlBpeGVsT3B0aW1pemVQb2ludChvY0hpZ2hQb2ludCksIHN1YlBpeGVsT3B0aW1pemVQb2ludChsb3dlc3RQb2ludCksIHN1YlBpeGVsT3B0aW1pemVQb2ludChvY0xvd1BvaW50KSk7XG4gICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChkYXRhSW5kZXgsIHtcbiAgICAgICAgICBzaWduOiBnZXRTaWduKGRhdGEsIGRhdGFJbmRleCwgb3BlblZhbCwgY2xvc2VWYWwsIGNsb3NlRGltKSxcbiAgICAgICAgICBpbml0QmFzZWxpbmU6IG9wZW5WYWwgPiBjbG9zZVZhbCA/IG9jSGlnaFBvaW50W3ZEaW1JZHhdIDogb2NMb3dQb2ludFt2RGltSWR4XSxcbiAgICAgICAgICBlbmRzOiBlbmRzLFxuICAgICAgICAgIGJydXNoUmVjdDogbWFrZUJydXNoUmVjdChsb3dlc3RWYWwsIGhpZ2hlc3RWYWwsIGF4aXNEaW1WYWwpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQb2ludCh2YWwsIGF4aXNEaW1WYWwpIHtcbiAgICAgICAgdmFyIHAgPSBbXTtcbiAgICAgICAgcFtjRGltSWR4XSA9IGF4aXNEaW1WYWw7XG4gICAgICAgIHBbdkRpbUlkeF0gPSB2YWw7XG4gICAgICAgIHJldHVybiBpc05hTihheGlzRGltVmFsKSB8fCBpc05hTih2YWwpID8gW05hTiwgTmFOXSA6IGNvb3JkU3lzLmRhdGFUb1BvaW50KHApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRCb2R5RW5kKGVuZHMsIHBvaW50LCBzdGFydCkge1xuICAgICAgICB2YXIgcG9pbnQxID0gcG9pbnQuc2xpY2UoKTtcbiAgICAgICAgdmFyIHBvaW50MiA9IHBvaW50LnNsaWNlKCk7XG4gICAgICAgIHBvaW50MVtjRGltSWR4XSA9IHN1YlBpeGVsT3B0aW1pemUocG9pbnQxW2NEaW1JZHhdICsgY2FuZGxlV2lkdGggLyAyLCAxLCBmYWxzZSk7XG4gICAgICAgIHBvaW50MltjRGltSWR4XSA9IHN1YlBpeGVsT3B0aW1pemUocG9pbnQyW2NEaW1JZHhdIC0gY2FuZGxlV2lkdGggLyAyLCAxLCB0cnVlKTtcbiAgICAgICAgc3RhcnQgPyBlbmRzLnB1c2gocG9pbnQxLCBwb2ludDIpIDogZW5kcy5wdXNoKHBvaW50MiwgcG9pbnQxKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWFrZUJydXNoUmVjdChsb3dlc3RWYWwsIGhpZ2hlc3RWYWwsIGF4aXNEaW1WYWwpIHtcbiAgICAgICAgdmFyIHBtaW4gPSBnZXRQb2ludChsb3dlc3RWYWwsIGF4aXNEaW1WYWwpO1xuICAgICAgICB2YXIgcG1heCA9IGdldFBvaW50KGhpZ2hlc3RWYWwsIGF4aXNEaW1WYWwpO1xuICAgICAgICBwbWluW2NEaW1JZHhdIC09IGNhbmRsZVdpZHRoIC8gMjtcbiAgICAgICAgcG1heFtjRGltSWR4XSAtPSBjYW5kbGVXaWR0aCAvIDI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogcG1pblswXSxcbiAgICAgICAgICB5OiBwbWluWzFdLFxuICAgICAgICAgIHdpZHRoOiB2RGltSWR4ID8gY2FuZGxlV2lkdGggOiBwbWF4WzBdIC0gcG1pblswXSxcbiAgICAgICAgICBoZWlnaHQ6IHZEaW1JZHggPyBwbWF4WzFdIC0gcG1pblsxXSA6IGNhbmRsZVdpZHRoXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN1YlBpeGVsT3B0aW1pemVQb2ludChwb2ludCkge1xuICAgICAgICBwb2ludFtjRGltSWR4XSA9IHN1YlBpeGVsT3B0aW1pemUocG9pbnRbY0RpbUlkeF0sIDEpO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFyZ2VQcm9ncmVzcyhwYXJhbXMsIGRhdGEpIHtcbiAgICAgIC8vIFN0cnVjdHVyZTogW3NpZ24sIHgsIHloaWdoLCB5bG93LCBzaWduLCB4LCB5aGlnaCwgeWxvdywgLi4uXVxuICAgICAgdmFyIHBvaW50cyA9IG5ldyBMYXJnZUFycihwYXJhbXMuY291bnQgKiA0KTtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgdmFyIHBvaW50O1xuICAgICAgdmFyIHRtcEluID0gW107XG4gICAgICB2YXIgdG1wT3V0ID0gW107XG4gICAgICB2YXIgZGF0YUluZGV4O1xuXG4gICAgICB3aGlsZSAoKGRhdGFJbmRleCA9IHBhcmFtcy5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGF4aXNEaW1WYWwgPSBkYXRhLmdldChjRGltLCBkYXRhSW5kZXgpO1xuICAgICAgICB2YXIgb3BlblZhbCA9IGRhdGEuZ2V0KG9wZW5EaW0sIGRhdGFJbmRleCk7XG4gICAgICAgIHZhciBjbG9zZVZhbCA9IGRhdGEuZ2V0KGNsb3NlRGltLCBkYXRhSW5kZXgpO1xuICAgICAgICB2YXIgbG93ZXN0VmFsID0gZGF0YS5nZXQobG93ZXN0RGltLCBkYXRhSW5kZXgpO1xuICAgICAgICB2YXIgaGlnaGVzdFZhbCA9IGRhdGEuZ2V0KGhpZ2hlc3REaW0sIGRhdGFJbmRleCk7XG5cbiAgICAgICAgaWYgKGlzTmFOKGF4aXNEaW1WYWwpIHx8IGlzTmFOKGxvd2VzdFZhbCkgfHwgaXNOYU4oaGlnaGVzdFZhbCkpIHtcbiAgICAgICAgICBwb2ludHNbb2Zmc2V0KytdID0gTmFOO1xuICAgICAgICAgIG9mZnNldCArPSAzO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9pbnRzW29mZnNldCsrXSA9IGdldFNpZ24oZGF0YSwgZGF0YUluZGV4LCBvcGVuVmFsLCBjbG9zZVZhbCwgY2xvc2VEaW0pO1xuICAgICAgICB0bXBJbltjRGltSWR4XSA9IGF4aXNEaW1WYWw7XG4gICAgICAgIHRtcEluW3ZEaW1JZHhdID0gbG93ZXN0VmFsO1xuICAgICAgICBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KHRtcEluLCBudWxsLCB0bXBPdXQpO1xuICAgICAgICBwb2ludHNbb2Zmc2V0KytdID0gcG9pbnQgPyBwb2ludFswXSA6IE5hTjtcbiAgICAgICAgcG9pbnRzW29mZnNldCsrXSA9IHBvaW50ID8gcG9pbnRbMV0gOiBOYU47XG4gICAgICAgIHRtcEluW3ZEaW1JZHhdID0gaGlnaGVzdFZhbDtcbiAgICAgICAgcG9pbnQgPSBjb29yZFN5cy5kYXRhVG9Qb2ludCh0bXBJbiwgbnVsbCwgdG1wT3V0KTtcbiAgICAgICAgcG9pbnRzW29mZnNldCsrXSA9IHBvaW50ID8gcG9pbnRbMV0gOiBOYU47XG4gICAgICB9XG5cbiAgICAgIGRhdGEuc2V0TGF5b3V0KCdsYXJnZVBvaW50cycsIHBvaW50cyk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRTaWduKGRhdGEsIGRhdGFJbmRleCwgb3BlblZhbCwgY2xvc2VWYWwsIGNsb3NlRGltKSB7XG4gIHZhciBzaWduO1xuXG4gIGlmIChvcGVuVmFsID4gY2xvc2VWYWwpIHtcbiAgICBzaWduID0gLTE7XG4gIH0gZWxzZSBpZiAob3BlblZhbCA8IGNsb3NlVmFsKSB7XG4gICAgc2lnbiA9IDE7XG4gIH0gZWxzZSB7XG4gICAgc2lnbiA9IGRhdGFJbmRleCA+IDAgLy8gSWYgY2xvc2UgPT09IG9wZW4sIGNvbXBhcmUgd2l0aCBjbG9zZSBvZiBsYXN0IHJlY29yZFxuICAgID8gZGF0YS5nZXQoY2xvc2VEaW0sIGRhdGFJbmRleCAtIDEpIDw9IGNsb3NlVmFsID8gMSA6IC0xIDogLy8gTm8gcmVjb3JkIG9mIHByZXZpb3VzLCBzZXQgdG8gYmUgcG9zaXRpdmVcbiAgICAxO1xuICB9XG5cbiAgcmV0dXJuIHNpZ247XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNhbmRsZVdpZHRoKHNlcmllc01vZGVsLCBkYXRhKSB7XG4gIHZhciBiYXNlQXhpcyA9IHNlcmllc01vZGVsLmdldEJhc2VBeGlzKCk7XG4gIHZhciBleHRlbnQ7XG4gIHZhciBiYW5kV2lkdGggPSBiYXNlQXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gYmFzZUF4aXMuZ2V0QmFuZFdpZHRoKCkgOiAoZXh0ZW50ID0gYmFzZUF4aXMuZ2V0RXh0ZW50KCksIE1hdGguYWJzKGV4dGVudFsxXSAtIGV4dGVudFswXSkgLyBkYXRhLmNvdW50KCkpO1xuICB2YXIgYmFyTWF4V2lkdGggPSBwYXJzZVBlcmNlbnQocmV0cmlldmUyKHNlcmllc01vZGVsLmdldCgnYmFyTWF4V2lkdGgnKSwgYmFuZFdpZHRoKSwgYmFuZFdpZHRoKTtcbiAgdmFyIGJhck1pbldpZHRoID0gcGFyc2VQZXJjZW50KHJldHJpZXZlMihzZXJpZXNNb2RlbC5nZXQoJ2Jhck1pbldpZHRoJyksIDEpLCBiYW5kV2lkdGgpO1xuICB2YXIgYmFyV2lkdGggPSBzZXJpZXNNb2RlbC5nZXQoJ2JhcldpZHRoJyk7XG4gIHJldHVybiBiYXJXaWR0aCAhPSBudWxsID8gcGFyc2VQZXJjZW50KGJhcldpZHRoLCBiYW5kV2lkdGgpIC8vIFB1dCBtYXggb3V0ZXIgdG8gZW5zdXJlIGJhciB2aXNpYmxlIGluIHNwaXRlIG9mIG92ZXJsYXAuXG4gIDogTWF0aC5tYXgoTWF0aC5taW4oYmFuZFdpZHRoIC8gMiwgYmFyTWF4V2lkdGgpLCBiYXJNaW5XaWR0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhbmRsZXN0aWNrTGF5b3V0OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgY3JlYXRlUmVuZGVyUGxhbm5lciBmcm9tICcuLi9oZWxwZXIvY3JlYXRlUmVuZGVyUGxhbm5lcic7XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xudmFyIHBvc2l0aXZlQm9yZGVyQ29sb3JRdWVyeSA9IFsnaXRlbVN0eWxlJywgJ2JvcmRlckNvbG9yJ107XG52YXIgbmVnYXRpdmVCb3JkZXJDb2xvclF1ZXJ5ID0gWydpdGVtU3R5bGUnLCAnYm9yZGVyQ29sb3IwJ107XG52YXIgcG9zaXRpdmVDb2xvclF1ZXJ5ID0gWydpdGVtU3R5bGUnLCAnY29sb3InXTtcbnZhciBuZWdhdGl2ZUNvbG9yUXVlcnkgPSBbJ2l0ZW1TdHlsZScsICdjb2xvcjAnXTtcbnZhciBjYW5kbGVzdGlja1Zpc3VhbCA9IHtcbiAgc2VyaWVzVHlwZTogJ2NhbmRsZXN0aWNrJyxcbiAgcGxhbjogY3JlYXRlUmVuZGVyUGxhbm5lcigpLFxuICAvLyBGb3IgbGVnZW5kLlxuICBwZXJmb3JtUmF3U2VyaWVzOiB0cnVlLFxuICByZXNldDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29sb3Ioc2lnbiwgbW9kZWwpIHtcbiAgICAgIHJldHVybiBtb2RlbC5nZXQoc2lnbiA+IDAgPyBwb3NpdGl2ZUNvbG9yUXVlcnkgOiBuZWdhdGl2ZUNvbG9yUXVlcnkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJvcmRlckNvbG9yKHNpZ24sIG1vZGVsKSB7XG4gICAgICByZXR1cm4gbW9kZWwuZ2V0KHNpZ24gPiAwID8gcG9zaXRpdmVCb3JkZXJDb2xvclF1ZXJ5IDogbmVnYXRpdmVCb3JkZXJDb2xvclF1ZXJ5KTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICBkYXRhLnNldFZpc3VhbCgnbGVnZW5kU3ltYm9sJywgJ3JvdW5kUmVjdCcpOyAvLyBPbmx5IHZpc2libGUgc2VyaWVzIGhhcyBlYWNoIGRhdGEgYmUgdmlzdWFsIGVuY29kZWRcblxuICAgIGlmIChlY01vZGVsLmlzU2VyaWVzRmlsdGVyZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlzTGFyZ2VSZW5kZXIgPSBzZXJpZXNNb2RlbC5waXBlbGluZUNvbnRleHQubGFyZ2U7XG4gICAgcmV0dXJuICFpc0xhcmdlUmVuZGVyICYmIHtcbiAgICAgIHByb2dyZXNzOiBmdW5jdGlvbiAocGFyYW1zLCBkYXRhKSB7XG4gICAgICAgIHZhciBkYXRhSW5kZXg7XG5cbiAgICAgICAgd2hpbGUgKChkYXRhSW5kZXggPSBwYXJhbXMubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG4gICAgICAgICAgdmFyIHNpZ24gPSBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KS5zaWduO1xuICAgICAgICAgIHZhciBzdHlsZSA9IGl0ZW1Nb2RlbC5nZXRJdGVtU3R5bGUoKTtcbiAgICAgICAgICBzdHlsZS5maWxsID0gZ2V0Q29sb3Ioc2lnbiwgaXRlbU1vZGVsKTtcbiAgICAgICAgICBzdHlsZS5zdHJva2UgPSBnZXRCb3JkZXJDb2xvcihzaWduLCBpdGVtTW9kZWwpIHx8IHN0eWxlLmZpbGw7XG4gICAgICAgICAgdmFyIGV4aXN0c1N0eWxlID0gZGF0YS5lbnN1cmVVbmlxdWVJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ3N0eWxlJyk7XG4gICAgICAgICAgZXh0ZW5kKGV4aXN0c1N0eWxlLCBzdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgY2FuZGxlc3RpY2tWaXN1YWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCBDYW5kbGVzdGlja1ZpZXcgZnJvbSAnLi9DYW5kbGVzdGlja1ZpZXcnO1xuaW1wb3J0IENhbmRsZXN0aWNrU2VyaWVzTW9kZWwgZnJvbSAnLi9DYW5kbGVzdGlja1Nlcmllcyc7XG5pbXBvcnQgcHJlcHJvY2Vzc29yIGZyb20gJy4vcHJlcHJvY2Vzc29yJztcbmltcG9ydCBjYW5kbGVzdGlja1Zpc3VhbCBmcm9tICcuL2NhbmRsZXN0aWNrVmlzdWFsJztcbmltcG9ydCBjYW5kbGVzdGlja0xheW91dCBmcm9tICcuL2NhbmRsZXN0aWNrTGF5b3V0JztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDaGFydFZpZXcoQ2FuZGxlc3RpY2tWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU2VyaWVzTW9kZWwoQ2FuZGxlc3RpY2tTZXJpZXNNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByZXByb2Nlc3NvcihwcmVwcm9jZXNzb3IpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJWaXN1YWwoY2FuZGxlc3RpY2tWaXN1YWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQoY2FuZGxlc3RpY2tMYXlvdXQpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhbmRsZXN0aWNrUHJlcHJvY2Vzc29yKG9wdGlvbikge1xuICBpZiAoIW9wdGlvbiB8fCAhenJVdGlsLmlzQXJyYXkob3B0aW9uLnNlcmllcykpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVHJhbnNsYXRlICdrJyB0byAnY2FuZGxlc3RpY2snLlxuXG5cbiAgenJVdGlsLmVhY2gob3B0aW9uLnNlcmllcywgZnVuY3Rpb24gKHNlcmllc0l0ZW0pIHtcbiAgICBpZiAoenJVdGlsLmlzT2JqZWN0KHNlcmllc0l0ZW0pICYmIHNlcmllc0l0ZW0udHlwZSA9PT0gJ2snKSB7XG4gICAgICBzZXJpZXNJdGVtLnR5cGUgPSAnY2FuZGxlc3RpY2snO1xuICAgIH1cbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgaGFzT3duLCBhc3NlcnQsIGlzU3RyaW5nLCByZXRyaWV2ZTIsIHJldHJpZXZlMywgZGVmYXVsdHMsIGVhY2gsIGtleXMsIGlzQXJyYXlMaWtlLCBiaW5kLCBpc0Z1bmN0aW9uLCBlcU5hTiwgaW5kZXhPZiwgY2xvbmUgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgZ3JhcGhpY1V0aWwgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCB7IHNldERlZmF1bHRTdGF0ZVByb3h5LCBlbmFibGVIb3ZlckVtcGhhc2lzIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMnO1xuaW1wb3J0ICogYXMgbGFiZWxTdHlsZUhlbHBlciBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlJztcbmltcG9ydCB7IGdldERlZmF1bHRMYWJlbCB9IGZyb20gJy4uL2hlbHBlci9sYWJlbEhlbHBlcic7XG5pbXBvcnQgY3JlYXRlTGlzdEZyb21BcnJheSBmcm9tICcuLi9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheSc7XG5pbXBvcnQgeyBnZXRMYXlvdXRPbkF4aXMgfSBmcm9tICcuLi8uLi9sYXlvdXQvYmFyR3JpZCc7XG5pbXBvcnQgRGF0YURpZmZlciBmcm9tICcuLi8uLi9kYXRhL0RhdGFEaWZmZXInO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcyc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ2hhcnQnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpcFBhdGggfSBmcm9tICcuLi9oZWxwZXIvY3JlYXRlQ2xpcFBhdGhGcm9tQ29vcmRTeXMnO1xuaW1wb3J0IHByZXBhcmVDYXJ0ZXNpYW4yZCBmcm9tICcuLi8uLi9jb29yZC9jYXJ0ZXNpYW4vcHJlcGFyZUN1c3RvbSc7XG5pbXBvcnQgcHJlcGFyZUdlbyBmcm9tICcuLi8uLi9jb29yZC9nZW8vcHJlcGFyZUN1c3RvbSc7XG5pbXBvcnQgcHJlcGFyZVNpbmdsZUF4aXMgZnJvbSAnLi4vLi4vY29vcmQvc2luZ2xlL3ByZXBhcmVDdXN0b20nO1xuaW1wb3J0IHByZXBhcmVQb2xhciBmcm9tICcuLi8uLi9jb29yZC9wb2xhci9wcmVwYXJlQ3VzdG9tJztcbmltcG9ydCBwcmVwYXJlQ2FsZW5kYXIgZnJvbSAnLi4vLi4vY29vcmQvY2FsZW5kYXIvcHJlcGFyZUN1c3RvbSc7XG5pbXBvcnQgeyBtYWtlSW5uZXIsIG5vcm1hbGl6ZVRvQXJyYXkgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbmltcG9ydCB7IGNvbnZlcnRUb0VDNFN0eWxlRm9yQ3VzdG9tU2VyaXNlLCBpc0VDNENvbXBhdGlibGVTdHlsZSwgY29udmVydEZyb21FQzRDb21wYXRpYmxlU3R5bGUsIHdhcm5EZXByZWNhdGVkIH0gZnJvbSAnLi4vLi4vdXRpbC9zdHlsZUNvbXBhdCc7XG5pbXBvcnQgVHJhbnNmb3JtYWJsZSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL1RyYW5zZm9ybWFibGUnO1xuaW1wb3J0IHsgY2xvbmVWYWx1ZSB9IGZyb20gJ3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvcic7XG5pbXBvcnQgeyB3YXJuLCB0aHJvd0Vycm9yIH0gZnJvbSAnLi4vLi4vdXRpbC9sb2cnO1xuaW1wb3J0IHsgY29tYmluZSwgaXNJbkFueU1vcnBoaW5nLCBtb3JwaFBhdGgsIGlzQ29tYmluaW5nUGF0aCwgc2VwYXJhdGUgfSBmcm9tICd6cmVuZGVyL2xpYi90b29sL21vcnBoUGF0aCc7XG5pbXBvcnQgKiBhcyBtYXRyaXggZnJvbSAnenJlbmRlci9saWIvY29yZS9tYXRyaXgnO1xuaW1wb3J0IHsgY3JlYXRlT3JVcGRhdGVQYXR0ZXJuRnJvbURlY2FsIH0gZnJvbSAnLi4vLi4vdXRpbC9kZWNhbCc7XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcbnZhciBUUkFOU0ZPUk1fUFJPUFMgPSB7XG4gIHg6IDEsXG4gIHk6IDEsXG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxLFxuICBvcmlnaW5YOiAxLFxuICBvcmlnaW5ZOiAxLFxuICByb3RhdGlvbjogMVxufTtcbnZhciB0cmFuc2Zvcm1Qcm9wTmFtZXNTdHIgPSBrZXlzKFRSQU5TRk9STV9QUk9QUykuam9pbignLCAnKTtcbjsgLy8gQWxzbyBjb21wYXQgd2l0aCBlYzQsIHdoZXJlXG4vLyBgdmlzdWFsKCdjb2xvcicpIHZpc3VhbCgnYm9yZGVyQ29sb3InKWAgaXMgc3VwcG9ydGVkLlxuXG52YXIgU1RZTEVfVklTVUFMX1RZUEUgPSB7XG4gIGNvbG9yOiAnZmlsbCcsXG4gIGJvcmRlckNvbG9yOiAnc3Ryb2tlJ1xufTtcbnZhciBOT05fU1RZTEVfVklTVUFMX1BST1BTID0ge1xuICBzeW1ib2w6IDEsXG4gIHN5bWJvbFNpemU6IDEsXG4gIHN5bWJvbEtlZXBBc3BlY3Q6IDEsXG4gIGxlZ2VuZFN5bWJvbDogMSxcbiAgdmlzdWFsTWV0YTogMSxcbiAgbGlmdFo6IDEsXG4gIGRlY2FsOiAxXG59O1xudmFyIEVNUEhBU0lTID0gJ2VtcGhhc2lzJztcbnZhciBOT1JNQUwgPSAnbm9ybWFsJztcbnZhciBCTFVSID0gJ2JsdXInO1xudmFyIFNFTEVDVCA9ICdzZWxlY3QnO1xudmFyIFNUQVRFUyA9IFtOT1JNQUwsIEVNUEhBU0lTLCBCTFVSLCBTRUxFQ1RdO1xudmFyIFBBVEhfSVRFTV9TVFlMRSA9IHtcbiAgbm9ybWFsOiBbJ2l0ZW1TdHlsZSddLFxuICBlbXBoYXNpczogW0VNUEhBU0lTLCAnaXRlbVN0eWxlJ10sXG4gIGJsdXI6IFtCTFVSLCAnaXRlbVN0eWxlJ10sXG4gIHNlbGVjdDogW1NFTEVDVCwgJ2l0ZW1TdHlsZSddXG59O1xudmFyIFBBVEhfTEFCRUwgPSB7XG4gIG5vcm1hbDogWydsYWJlbCddLFxuICBlbXBoYXNpczogW0VNUEhBU0lTLCAnbGFiZWwnXSxcbiAgYmx1cjogW0JMVVIsICdsYWJlbCddLFxuICBzZWxlY3Q6IFtTRUxFQ1QsICdsYWJlbCddXG59OyAvLyBVc2UgcHJlZml4IHRvIGF2b2lkIGluZGV4IHRvIGJlIHRoZSBzYW1lIGFzIGVsLm5hbWUsXG4vLyB3aGljaCB3aWxsIGNhdXNlIHdlaXJkIHVwZGF0ZSBhbmltYXRpb24uXG5cbnZhciBHUk9VUF9ESUZGX1BSRUZJWCA9ICdlXFwwXFwwJztcbnZhciBhdHRhY2hlZFR4SW5mb1RtcCA9IHtcbiAgbm9ybWFsOiB7fSxcbiAgZW1waGFzaXM6IHt9LFxuICBibHVyOiB7fSxcbiAgc2VsZWN0OiB7fVxufTtcbnZhciBMRUdBQ1lfVFJBTlNGT1JNX1BST1BTID0ge1xuICBwb3NpdGlvbjogWyd4JywgJ3knXSxcbiAgc2NhbGU6IFsnc2NhbGVYJywgJ3NjYWxlWSddLFxuICBvcmlnaW46IFsnb3JpZ2luWCcsICdvcmlnaW5ZJ11cbn07XG52YXIgdG1wVHJhbnNmb3JtYWJsZSA9IG5ldyBUcmFuc2Zvcm1hYmxlKCk7XG4vKipcbiAqIFRvIHJlZHVjZSB0b3RhbCBwYWNrYWdlIHNpemUgb2YgZWFjaCBjb29yZGluYXRlIHN5c3RlbXMsIHRoZSBtb2R1bGVzIGBwcmVwYXJlQ3VzdG9tYFxuICogb2YgZWFjaCBjb29yZGluYXRlIHN5c3RlbXMgYXJlIG5vdCByZXF1aXJlZCBieSBlYWNoIGNvb3JkaW5hdGUgc3lzdGVtcyBkaXJlY3RseSwgYnV0XG4gKiByZXF1aXJlZCBieSB0aGUgbW9kdWxlIGBjdXN0b21gLlxuICpcbiAqIHByZXBhcmVJbmZvRm9yQ3VzdG9tU2VyaWVzIHtGdW5jdGlvbn06IG9wdGlvbmFsXG4gKiAgICAgQHJldHVybiB7T2JqZWN0fSB7Y29vcmRTeXM6IHsuLi59LCBhcGk6IHtcbiAqICAgICAgICAgY29vcmQ6IGZ1bmN0aW9uIChkYXRhLCBjbGFtcCkge30sIC8vIHJldHVybiBwb2ludCBpbiBnbG9iYWwuXG4gKiAgICAgICAgIHNpemU6IGZ1bmN0aW9uIChkYXRhU2l6ZSwgZGF0YUl0ZW0pIHt9IC8vIHJldHVybiBzaXplIG9mIGVhY2ggYXhpcyBpbiBjb29yZFN5cy5cbiAqICAgICB9fVxuICovXG5cbnZhciBwcmVwYXJlQ3VzdG9tcyA9IHtcbiAgY2FydGVzaWFuMmQ6IHByZXBhcmVDYXJ0ZXNpYW4yZCxcbiAgZ2VvOiBwcmVwYXJlR2VvLFxuICBzaW5nbGVBeGlzOiBwcmVwYXJlU2luZ2xlQXhpcyxcbiAgcG9sYXI6IHByZXBhcmVQb2xhcixcbiAgY2FsZW5kYXI6IHByZXBhcmVDYWxlbmRhclxufTtcblxudmFyIEN1c3RvbVNlcmllc01vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEN1c3RvbVNlcmllc01vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEN1c3RvbVNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IEN1c3RvbVNlcmllc01vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgQ3VzdG9tU2VyaWVzTW9kZWwucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdXJyZW50WkxldmVsID0gdGhpcy5nZXQoJ3psZXZlbCcsIHRydWUpO1xuICAgIHRoaXMuY3VycmVudFogPSB0aGlzLmdldCgneicsIHRydWUpO1xuICB9O1xuXG4gIEN1c3RvbVNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YSA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICByZXR1cm4gY3JlYXRlTGlzdEZyb21BcnJheSh0aGlzLmdldFNvdXJjZSgpLCB0aGlzKTtcbiAgfTtcblxuICBDdXN0b21TZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0RGF0YVBhcmFtcyA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIGRhdGFUeXBlLCBlbCkge1xuICAgIHZhciBwYXJhbXMgPSBfc3VwZXIucHJvdG90eXBlLmdldERhdGFQYXJhbXMuY2FsbCh0aGlzLCBkYXRhSW5kZXgsIGRhdGFUeXBlKTtcblxuICAgIGVsICYmIChwYXJhbXMuaW5mbyA9IGlubmVyKGVsKS5pbmZvKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9O1xuXG4gIEN1c3RvbVNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLmN1c3RvbSc7XG4gIEN1c3RvbVNlcmllc01vZGVsLmRlcGVuZGVuY2llcyA9IFsnZ3JpZCcsICdwb2xhcicsICdnZW8nLCAnc2luZ2xlQXhpcycsICdjYWxlbmRhciddO1xuICBDdXN0b21TZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdjYXJ0ZXNpYW4yZCcsXG4gICAgemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIC8vIEN1c3RvbSBzZXJpZXMgd2lsbCBub3QgY2xpcCBieSBkZWZhdWx0LlxuICAgIC8vIFNvbWUgY2FzZSB3aWxsIHVzZSBjdXN0b20gc2VyaWVzIHRvIGRyYXcgbGFiZWxcbiAgICAvLyBGb3IgZXhhbXBsZSBodHRwczovL2VjaGFydHMuYXBhY2hlLm9yZy9leGFtcGxlcy9lbi9lZGl0b3IuaHRtbD9jPWN1c3RvbS1nYW50dC1mbGlnaHRcbiAgICBjbGlwOiBmYWxzZSAvLyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAvLyB4QXhpc0luZGV4OiAwLFxuICAgIC8vIHlBeGlzSW5kZXg6IDAsXG4gICAgLy8gUG9sYXIgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAvLyBwb2xhckluZGV4OiAwLFxuICAgIC8vIEdlbyBjb29yZGluYXRlIHN5c3RlbVxuICAgIC8vIGdlb0luZGV4OiAwLFxuXG4gIH07XG4gIHJldHVybiBDdXN0b21TZXJpZXNNb2RlbDtcbn0oU2VyaWVzTW9kZWwpO1xuXG52YXIgQ3VzdG9tU2VyaWVzVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDdXN0b21TZXJpZXNWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEN1c3RvbVNlcmllc1ZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gQ3VzdG9tU2VyaWVzVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEN1c3RvbVNlcmllc1ZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjdXN0b21TZXJpZXMsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgZGF0YSA9IGN1c3RvbVNlcmllcy5nZXREYXRhKCk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgcmVuZGVySXRlbSA9IG1ha2VSZW5kZXJJdGVtKGN1c3RvbVNlcmllcywgZGF0YSwgZWNNb2RlbCwgYXBpKTsgLy8gQnkgZGVmYXVsdCwgbWVyZ2UgbW9kZSBpcyBhcHBsaWVkLiBJbiBtb3N0IGNhc2VzLCBjdXN0b20gc2VyaWVzIGlzXG4gICAgLy8gdXNlZCBpbiB0aGUgc2NlbmFyaW8gdGhhdCBkYXRhIGFtb3VudCBpcyBub3QgbGFyZ2UgYnV0IGdyYXBoaWMgZWxlbWVudHNcbiAgICAvLyBpcyBjb21wbGljYXRlZCwgd2hlcmUgbWVyZ2UgbW9kZSBpcyBwcm9iYWJseSBuZWNlc3NhcnkgZm9yIG9wdGltaXphdGlvbi5cbiAgICAvLyBGb3IgZXhhbXBsZSwgcmV1c2UgZ3JhcGhpYyBlbGVtZW50cyBhbmQgb25seSB1cGRhdGUgdGhlIHRyYW5zZm9ybSB3aGVuXG4gICAgLy8gcm9hbSBvciBkYXRhIHpvb20gYWNjb3JkaW5nIHRvIGBhY3Rpb25UeXBlYC5cblxuICAgIHZhciB0cmFuc09wdCA9IGN1c3RvbVNlcmllcy5fX3RyYW5zaWVudFRyYW5zaXRpb25PcHQ7IC8vIEVuYWJsZSB1c2VyIHRvIGRpc2FibGUgdHJhbnNpdGlvbiBhbmltYXRpb24gYnkgYm90aCBzZXRcbiAgICAvLyBgZnJvbWAgYW5kIGB0b2AgZGltZW5zaW9uIGFzIGBudWxsYC9gdW5kZWZpbmVkYC5cblxuICAgIGlmICh0cmFuc09wdCAmJiAodHJhbnNPcHQuZnJvbSA9PSBudWxsIHx8IHRyYW5zT3B0LnRvID09IG51bGwpKSB7XG4gICAgICBvbGREYXRhICYmIG9sZERhdGEuZWFjaChmdW5jdGlvbiAob2xkSWR4KSB7XG4gICAgICAgIGRvUmVtb3ZlRWwob2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCksIGN1c3RvbVNlcmllcywgZ3JvdXApO1xuICAgICAgfSk7XG4gICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKG5ld0lkeCkge1xuICAgICAgICBjcmVhdGVPclVwZGF0ZUl0ZW0oYXBpLCBudWxsLCBuZXdJZHgsIHJlbmRlckl0ZW0obmV3SWR4LCBwYXlsb2FkKSwgY3VzdG9tU2VyaWVzLCBncm91cCwgZGF0YSwgbnVsbCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1vcnBoUHJlcGFyYXRpb25fMSA9IG5ldyBNb3JwaFByZXBhcmF0aW9uKGN1c3RvbVNlcmllcywgdHJhbnNPcHQpO1xuICAgICAgdmFyIGRpZmZNb2RlID0gdHJhbnNPcHQgPyAnbXVsdGlwbGUnIDogJ29uZVRvT25lJztcbiAgICAgIG5ldyBEYXRhRGlmZmVyKG9sZERhdGEgPyBvbGREYXRhLmdldEluZGljZXMoKSA6IFtdLCBkYXRhLmdldEluZGljZXMoKSwgY3JlYXRlR2V0S2V5KG9sZERhdGEsIGRpZmZNb2RlLCB0cmFuc09wdCAmJiB0cmFuc09wdC5mcm9tKSwgY3JlYXRlR2V0S2V5KGRhdGEsIGRpZmZNb2RlLCB0cmFuc09wdCAmJiB0cmFuc09wdC50byksIG51bGwsIGRpZmZNb2RlKS5hZGQoZnVuY3Rpb24gKG5ld0lkeCkge1xuICAgICAgICBjcmVhdGVPclVwZGF0ZUl0ZW0oYXBpLCBudWxsLCBuZXdJZHgsIHJlbmRlckl0ZW0obmV3SWR4LCBwYXlsb2FkKSwgY3VzdG9tU2VyaWVzLCBncm91cCwgZGF0YSwgbnVsbCk7XG4gICAgICB9KS5yZW1vdmUoZnVuY3Rpb24gKG9sZElkeCkge1xuICAgICAgICBkb1JlbW92ZUVsKG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpLCBjdXN0b21TZXJpZXMsIGdyb3VwKTtcbiAgICAgIH0pLnVwZGF0ZShmdW5jdGlvbiAobmV3SWR4LCBvbGRJZHgpIHtcbiAgICAgICAgbW9ycGhQcmVwYXJhdGlvbl8xLnJlc2V0KCdvbmVUb09uZScpO1xuICAgICAgICB2YXIgb2xkRWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICAgICAgbW9ycGhQcmVwYXJhdGlvbl8xLmZpbmRBbmRBZGRGcm9tKG9sZEVsKTsgLy8gUEVORElORzpcbiAgICAgICAgLy8gaWYgbWF5IG1vcnBoLCBjdXJyZW50bHkgd2UgYWx3YXkgcmVjcmVhdGUgdGhlIHdob2xlIGVsLlxuICAgICAgICAvLyBiZWNhdXNlIGlmIHJldXNlIHNvbWUgb2YgdGhlIGVsIGluIHRoZSBncm91cCB0cmVlLCB0aGUgb2xkIGVsIGhhcyB0b1xuICAgICAgICAvLyBiZSByZW1vdmVkIGZyb20gdGhlIGdyb3VwLCBhbmQgY29uc2VxdWVudGx5IHdlIGNhbiBub3QgY2FsY3VsYXRlXG4gICAgICAgIC8vIHRoZSBcImdsb2JhbCB0cmFuc2l0aW9uXCIgb2YgdGhlIG9sZCBlbGVtZW50LlxuICAgICAgICAvLyBCdXQgaXMgdGhlcmUgcGVyZm9ybWFuY2UgaXNzdWU/XG5cbiAgICAgICAgaWYgKG1vcnBoUHJlcGFyYXRpb25fMS5oYXNGcm9tKCkpIHtcbiAgICAgICAgICByZW1vdmVFbGVtZW50RGlyZWN0bHkob2xkRWwsIGdyb3VwKTtcbiAgICAgICAgICBvbGRFbCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjcmVhdGVPclVwZGF0ZUl0ZW0oYXBpLCBvbGRFbCwgbmV3SWR4LCByZW5kZXJJdGVtKG5ld0lkeCwgcGF5bG9hZCksIGN1c3RvbVNlcmllcywgZ3JvdXAsIGRhdGEsIG1vcnBoUHJlcGFyYXRpb25fMSk7XG4gICAgICAgIG1vcnBoUHJlcGFyYXRpb25fMS5hcHBseU1vcnBoaW5nKCk7XG4gICAgICB9KS51cGRhdGVNYW55VG9PbmUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSW5kaWNlcykge1xuICAgICAgICBtb3JwaFByZXBhcmF0aW9uXzEucmVzZXQoJ21hbnlUb09uZScpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBvbGRFbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJbmRpY2VzW2ldKTtcbiAgICAgICAgICBtb3JwaFByZXBhcmF0aW9uXzEuZmluZEFuZEFkZEZyb20ob2xkRWwpO1xuICAgICAgICAgIHJlbW92ZUVsZW1lbnREaXJlY3RseShvbGRFbCwgZ3JvdXApO1xuICAgICAgICB9XG5cbiAgICAgICAgY3JlYXRlT3JVcGRhdGVJdGVtKGFwaSwgbnVsbCwgbmV3SWR4LCByZW5kZXJJdGVtKG5ld0lkeCwgcGF5bG9hZCksIGN1c3RvbVNlcmllcywgZ3JvdXAsIGRhdGEsIG1vcnBoUHJlcGFyYXRpb25fMSk7XG4gICAgICAgIG1vcnBoUHJlcGFyYXRpb25fMS5hcHBseU1vcnBoaW5nKCk7XG4gICAgICB9KS51cGRhdGVPbmVUb01hbnkoZnVuY3Rpb24gKG5ld0luZGljZXMsIG9sZElkeCkge1xuICAgICAgICBtb3JwaFByZXBhcmF0aW9uXzEucmVzZXQoJ29uZVRvTWFueScpO1xuICAgICAgICB2YXIgbmV3TGVuID0gbmV3SW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIHZhciBvbGRFbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuICAgICAgICBtb3JwaFByZXBhcmF0aW9uXzEuZmluZEFuZEFkZEZyb20ob2xkRWwpO1xuICAgICAgICByZW1vdmVFbGVtZW50RGlyZWN0bHkob2xkRWwsIGdyb3VwKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0xlbjsgaSsrKSB7XG4gICAgICAgICAgY3JlYXRlT3JVcGRhdGVJdGVtKGFwaSwgbnVsbCwgbmV3SW5kaWNlc1tpXSwgcmVuZGVySXRlbShuZXdJbmRpY2VzW2ldLCBwYXlsb2FkKSwgY3VzdG9tU2VyaWVzLCBncm91cCwgZGF0YSwgbW9ycGhQcmVwYXJhdGlvbl8xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vcnBoUHJlcGFyYXRpb25fMS5hcHBseU1vcnBoaW5nKCk7XG4gICAgICB9KS5leGVjdXRlKCk7XG4gICAgfSAvLyBEbyBjbGlwcGluZ1xuXG5cbiAgICB2YXIgY2xpcFBhdGggPSBjdXN0b21TZXJpZXMuZ2V0KCdjbGlwJywgdHJ1ZSkgPyBjcmVhdGVDbGlwUGF0aChjdXN0b21TZXJpZXMuY29vcmRpbmF0ZVN5c3RlbSwgZmFsc2UsIGN1c3RvbVNlcmllcykgOiBudWxsO1xuXG4gICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICBncm91cC5zZXRDbGlwUGF0aChjbGlwUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwLnJlbW92ZUNsaXBQYXRoKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH07XG5cbiAgQ3VzdG9tU2VyaWVzVmlldy5wcm90b3R5cGUuaW5jcmVtZW50YWxQcmVwYXJlUmVuZGVyID0gZnVuY3Rpb24gKGN1c3RvbVNlcmllcywgZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgfTtcblxuICBDdXN0b21TZXJpZXNWaWV3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFJlbmRlciA9IGZ1bmN0aW9uIChwYXJhbXMsIGN1c3RvbVNlcmllcywgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdmFyIGRhdGEgPSBjdXN0b21TZXJpZXMuZ2V0RGF0YSgpO1xuICAgIHZhciByZW5kZXJJdGVtID0gbWFrZVJlbmRlckl0ZW0oY3VzdG9tU2VyaWVzLCBkYXRhLCBlY01vZGVsLCBhcGkpO1xuXG4gICAgZnVuY3Rpb24gc2V0SW5jcmVtZW50YWxBbmRIb3ZlckxheWVyKGVsKSB7XG4gICAgICBpZiAoIWVsLmlzR3JvdXApIHtcbiAgICAgICAgZWwuaW5jcmVtZW50YWwgPSB0cnVlO1xuICAgICAgICBlbC5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKS5ob3ZlckxheWVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpZHggPSBwYXJhbXMuc3RhcnQ7IGlkeCA8IHBhcmFtcy5lbmQ7IGlkeCsrKSB7XG4gICAgICB2YXIgZWwgPSBjcmVhdGVPclVwZGF0ZUl0ZW0obnVsbCwgbnVsbCwgaWR4LCByZW5kZXJJdGVtKGlkeCwgcGF5bG9hZCksIGN1c3RvbVNlcmllcywgdGhpcy5ncm91cCwgZGF0YSwgbnVsbCk7XG4gICAgICBlbC50cmF2ZXJzZShzZXRJbmNyZW1lbnRhbEFuZEhvdmVyTGF5ZXIpO1xuICAgIH1cbiAgfTtcblxuICBDdXN0b21TZXJpZXNWaWV3LnByb3RvdHlwZS5maWx0ZXJGb3JFeHBvc2VkRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBxdWVyeSwgdGFyZ2V0RWwsIHBhY2tlZEV2ZW50KSB7XG4gICAgdmFyIGVsZW1lbnROYW1lID0gcXVlcnkuZWxlbWVudDtcblxuICAgIGlmIChlbGVtZW50TmFtZSA9PSBudWxsIHx8IHRhcmdldEVsLm5hbWUgPT09IGVsZW1lbnROYW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIEVuYWJsZSB0byBnaXZlIGEgbmFtZSBvbiBhIGdyb3VwIG1hZGUgYnkgYHJlbmRlckl0ZW1gLCBhbmQgbGlzdGVuXG4gICAgLy8gZXZlbnRzIHRoYXQgdHJpZ2dlcmQgYnkgaXRzIGRlc2NlbmRlbnRzLlxuXG5cbiAgICB3aGlsZSAoKHRhcmdldEVsID0gdGFyZ2V0RWwuX19ob3N0VGFyZ2V0IHx8IHRhcmdldEVsLnBhcmVudCkgJiYgdGFyZ2V0RWwgIT09IHRoaXMuZ3JvdXApIHtcbiAgICAgIGlmICh0YXJnZXRFbC5uYW1lID09PSBlbGVtZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgQ3VzdG9tU2VyaWVzVmlldy50eXBlID0gJ2N1c3RvbSc7XG4gIHJldHVybiBDdXN0b21TZXJpZXNWaWV3O1xufShDaGFydFZpZXcpO1xuXG5mdW5jdGlvbiBjcmVhdGVHZXRLZXkoZGF0YSwgZGlmZk1vZGUsIGRpbWVuc2lvbikge1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZGlmZk1vZGUgPT09ICdvbmVUb09uZScpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJhd0lkeCwgZGF0YUluZGV4KSB7XG4gICAgICByZXR1cm4gZGF0YS5nZXRJZChkYXRhSW5kZXgpO1xuICAgIH07XG4gIH1cblxuICB2YXIgZGlmZkJ5RGltTmFtZSA9IGRhdGEuZ2V0RGltZW5zaW9uKGRpbWVuc2lvbik7XG4gIHZhciBkaW1JbmZvID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpZmZCeURpbU5hbWUpO1xuXG4gIGlmICghZGltSW5mbykge1xuICAgIHZhciBlcnJNc2cgPSAnJztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBlcnJNc2cgPSBkaW1lbnNpb24gKyBcIiBpcyBub3QgYSB2YWxpZCBkaW1lbnNpb24uXCI7XG4gICAgfVxuXG4gICAgdGhyb3dFcnJvcihlcnJNc2cpO1xuICB9XG5cbiAgdmFyIG9yZGluYWxNZXRhID0gZGltSW5mby5vcmRpbmFsTWV0YTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyYXdJZHgsIGRhdGFJbmRleCkge1xuICAgIHZhciBrZXkgPSBkYXRhLmdldChkaWZmQnlEaW1OYW1lLCBkYXRhSW5kZXgpO1xuXG4gICAgaWYgKG9yZGluYWxNZXRhKSB7XG4gICAgICBrZXkgPSBvcmRpbmFsTWV0YS5jYXRlZ29yaWVzW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleSA9PSBudWxsIHx8IGVxTmFOKGtleSkgPyByYXdJZHggKyAnJyA6ICdfZWNfJyArIGtleTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWwoZWxPcHRpb24pIHtcbiAgdmFyIGdyYXBoaWNUeXBlID0gZWxPcHRpb24udHlwZTtcbiAgdmFyIGVsOyAvLyBUaG9zZSBncmFwaGljIGVsZW1lbnRzIGFyZSBub3Qgc2hhcGVzLiBUaGV5IHNob3VsZCBub3QgYmVcbiAgLy8gb3ZlcndyaXR0ZW4gYnkgdXNlcnMsIHNvIGRvIHRoZW0gZmlyc3QuXG5cbiAgaWYgKGdyYXBoaWNUeXBlID09PSAncGF0aCcpIHtcbiAgICB2YXIgc2hhcGUgPSBlbE9wdGlvbi5zaGFwZTsgLy8gVXNpbmcgcGF0aFJlY3QgYnJpbmdzIGNvbnZlbmllbmNlIHRvIHVzZXJzIHNhY2xlIHN2ZyBwYXRoLlxuXG4gICAgdmFyIHBhdGhSZWN0ID0gc2hhcGUud2lkdGggIT0gbnVsbCAmJiBzaGFwZS5oZWlnaHQgIT0gbnVsbCA/IHtcbiAgICAgIHg6IHNoYXBlLnggfHwgMCxcbiAgICAgIHk6IHNoYXBlLnkgfHwgMCxcbiAgICAgIHdpZHRoOiBzaGFwZS53aWR0aCxcbiAgICAgIGhlaWdodDogc2hhcGUuaGVpZ2h0XG4gICAgfSA6IG51bGw7XG4gICAgdmFyIHBhdGhEYXRhID0gZ2V0UGF0aERhdGEoc2hhcGUpOyAvLyBQYXRoIGlzIGFsc28gdXNlZCBmb3IgaWNvbiwgc28gbGF5b3V0ICdjZW50ZXInIGJ5IGRlZmF1bHQuXG5cbiAgICBlbCA9IGdyYXBoaWNVdGlsLm1ha2VQYXRoKHBhdGhEYXRhLCBudWxsLCBwYXRoUmVjdCwgc2hhcGUubGF5b3V0IHx8ICdjZW50ZXInKTtcbiAgICBpbm5lcihlbCkuY3VzdG9tUGF0aERhdGEgPSBwYXRoRGF0YTtcbiAgfSBlbHNlIGlmIChncmFwaGljVHlwZSA9PT0gJ2ltYWdlJykge1xuICAgIGVsID0gbmV3IGdyYXBoaWNVdGlsLkltYWdlKHt9KTtcbiAgICBpbm5lcihlbCkuY3VzdG9tSW1hZ2VQYXRoID0gZWxPcHRpb24uc3R5bGUuaW1hZ2U7XG4gIH0gZWxzZSBpZiAoZ3JhcGhpY1R5cGUgPT09ICd0ZXh0Jykge1xuICAgIGVsID0gbmV3IGdyYXBoaWNVdGlsLlRleHQoe30pOyAvLyBpbm5lcihlbCkuY3VzdG9tVGV4dCA9IChlbE9wdGlvbi5zdHlsZSBhcyBUZXh0U3R5bGVQcm9wcykudGV4dDtcbiAgfSBlbHNlIGlmIChncmFwaGljVHlwZSA9PT0gJ2dyb3VwJykge1xuICAgIGVsID0gbmV3IGdyYXBoaWNVdGlsLkdyb3VwKCk7XG4gIH0gZWxzZSBpZiAoZ3JhcGhpY1R5cGUgPT09ICdjb21wb3VuZFBhdGgnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImNvbXBvdW5kUGF0aFwiIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LicpO1xuICB9IGVsc2Uge1xuICAgIHZhciBDbHogPSBncmFwaGljVXRpbC5nZXRTaGFwZUNsYXNzKGdyYXBoaWNUeXBlKTtcblxuICAgIGlmICghQ2x6KSB7XG4gICAgICB2YXIgZXJyTXNnID0gJyc7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVyck1zZyA9ICdncmFwaGljIHR5cGUgXCInICsgZ3JhcGhpY1R5cGUgKyAnXCIgY2FuIG5vdCBiZSBmb3VuZC4nO1xuICAgICAgfVxuXG4gICAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gICAgfVxuXG4gICAgZWwgPSBuZXcgQ2x6KCk7XG4gIH1cblxuICBpbm5lcihlbCkuY3VzdG9tR3JhcGhpY1R5cGUgPSBncmFwaGljVHlwZTtcbiAgZWwubmFtZSA9IGVsT3B0aW9uLm5hbWU7IC8vIENvbXBhdCBlYzQ6IHRoZSBkZWZhdWx0IHoyIGxpZnQgaXMgMS4gSWYgY2hhbmdpbmcgdGhlIG51bWJlcixcbiAgLy8gc29tZSBjYXNlcyBwcm9iYWJseSBiZSBicm9rZW46IGhpZXJhcmNoeSBsYXlvdXQgYWxvbmcgeiwgbGlrZSBjaXJjbGUgcGFja2luZyxcbiAgLy8gd2hlcmUgZW1waGFzaXMgb25seSBpbnRlbmRpbmcgdG8gbW9kaWZ5IGNvbG9yL2JvcmRlciByYXRoZXIgdGhhbiBsaWZ0IHoyLlxuXG4gIGVsLnoyRW1waGFzaXNMaWZ0ID0gMTtcbiAgZWwuejJTZWxlY3RMaWZ0ID0gMTtcbiAgcmV0dXJuIGVsO1xufVxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBbU1RSQVRFR1lfTUVSR0VdIE1lcmdlIHByb3BlcnRpZXMgb3IgZXJhc2UgYWxsIHByb3BlcnRpZXM6XG4gKlxuICogQmFzZWQgb24gdGhlIGZhY3QgdGhhdCB0aGUgZXhpc3RpbmcgenIgZWxlbWVudCBwcm9iYWJseSBiZSByZXVzZWQsIHdlIG5vdyBjb25zaWRlciB3aGV0aGVyXG4gKiBtZXJnZSBvciBlcmFzZSBhbGwgcHJvcGVydGllcyB0byB0aGUgZXhzaXRpbmcgZWxlbWVudHMuXG4gKiBUaGF0IGlzLCBpZiBhIGNlcnRhaW4gcHJvcHMgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgbGFzdGVzdCByZXR1cm4gb2YgYHJlbmRlckl0ZW1gOlxuICogKyBcIk1lcmdlXCIgbWVhbnMgdGhhdCBkbyBub3QgbW9kaWZ5IHRoZSB2YWx1ZSBvbiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAqICsgXCJFcmFzZSBhbGxcIiBtZWFucyB0aGF0IHVzZSBhIGRlZmF1bHQgdmFsdWUgdG8gdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gKlxuICogXCJNZXJnZVwiIG1pZ2h0IGJyaW5nIHNvbWUgdW5leHBlY3RlZCBzdGF0ZSByZXRhaW5pbmcgZm9yIHVzZXJzIGFuZCBcImVyYXNlIGFsbFwiIHNlYW1zIHRvIGJlXG4gKiBtb3JlIHNhZmUuIFwiZXJhc2UgYWxsXCIgZm9yY2UgdXNlcnMgdG8gc3BlY2lmeSBhbGwgb2YgdGhlIHByb3BzIGVhY2ggdGltZSwgd2hpY2ggaXMgcmVjb21tYW5kZWRcbiAqIGluIG1vc3QgY2FzZXMuXG4gKiBCdXQgXCJlcmFzZSBhbGxcIiB0aGVvcmV0aWNhbGx5IGRpc2FibGVzIHRoZSBjaGFuY2Ugb2YgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIChlLmcuLCBqdXN0XG4gKiBnZW5lcmV0ZSBzaGFwZSBhbmQgc3R5bGUgYXQgdGhlIGZpcnN0IHRpbWUgcmF0aGVyIHRoYW4gYWx3YXlzIGRvIHRoYXQpLlxuICogU28gd2Ugc3RpbGwgdXNlIFwibWVyZ2VcIiByYXRoZXIgdGhhbiBcImVyYXNlIGFsbFwiLiBJZiB1c2VycyBuZWVkIFwiZXJhc2UgYWxsXCIsIHRoZXkgY2FuXG4gKiBzaW1wbGUgYWx3YXlzIHNldCBhbGwgb2YgdGhlIHByb3BzIGVhY2ggdGltZS5cbiAqIFNvbWUgXCJvYmplY3QtbGlrZVwiIGNvbmZpZyBsaWtlIGB0ZXh0Q29uZmlnYCwgYHRleHRDb250ZW50YCwgYHN0eWxlYCB3aGljaCBhcmUgbm90IG5lZWRlZCBmb3JcbiAqIGV2ZXJ5IGVsbWVudCwgc28gd2UgcmVwbGFjZSB0aGVtIG9ubHkgd2hlbiB1c2VyIHNwZWNpZnkgdGhlbS4gQW5kIHRoZSB0aGF0IGlzIGEgdG90YWwgcmVwbGFjZS5cbiAqXG4gKiBUT0RPOiB0aGVyZSBpcyBubyBoaW50IG9mICdpc0ZpcnN0JyB0byB1c2Vycy4gU28gdGhlIHBlcmZvcm1hbmNlIGVuaGFuY2VtZW50IGNhbiBub3QgYmVcbiAqIHBlcmZvcm1lZCB5ZXQuIENvbnNpZGVyIHRoZSBjYXNlOlxuICogKDEpIHNldE9wdGlvbiB0byBcIm1lcmdlQ2hpbGRyZW5cIiB3aXRoIGEgc21hbGxlciBjaGlsZHJlbiBjb3VudFxuICogKDIpIFVzZSBkYXRhWm9vbSB0byBtYWtlIGFuIGl0ZW0gZGlzYXBwZWFyLlxuICogKDMpIFVzZXIgZGF0YVpvb20gdG8gbWFrZSB0aGUgaXRlbSBkaXNwbGF5IGFnYWluLiBBdCB0aGF0IHRpbWUsIHJlbmRlckl0ZW0gbmVlZCB0byByZXR1cm4gdGhlXG4gKiBmdWxsIG9wdGlvbiByYXRoZXIgdGhhbiBwYXJ0aWFsIG9wdGlvbiB0byByZWNyZWF0ZSB0aGUgZWxlbWVudC5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBbU1RSQVRFR1lfTlVMTF0gYGhhc093blByb3BlcnR5YCBvciBgPT0gbnVsbGA6XG4gKlxuICogRGl0aW5ndWlzaGluZyBcIm93biBwcm9wZXJ0eVwiIHByb2JhYmx5IGJyaW5nIGxpdHRsZSB0cm91YmxlIHRvIHVzZXIgd2hlbiBtYWtlIGVsIG9wdGlvbnMuXG4gKiBTbyB3ZSAgdHJhZGUgYSB7eHg6IG51bGx9IG9yIHt4eDogdW5kZWZpbmVkfSBhcyBcIm5vdCBzcGVjaWZpZWRcIiBpZiBwb3NzaWJsZSByYXRoZXIgdGhhblxuICogXCJzZXQgdGhlbSB0byBudWxsL3VuZGVmaW5lZFwiLiBJbiBtb3N0IGNhc2VzLCBwcm9wcyBjYW4gbm90IGJlIGNsZWFyZWQuIFNvbWUgdHlwaWNhbGxcbiAqIGNsZWFyYWJsZSBwcm9wcyBsaWtlIGBzdHlsZWAvYHRleHRDb25maWdgL2B0ZXh0Q29udGVudGAgd2UgZW5hYmxlIGBmYWxzZWAgdG8gbWVhbnNcbiAqIFwiY2xlYXJcIi4gSW4gc29tZSBvdGhlcmUgc3BlY2lhbCBjYXNlcyB0aGF0IHRoZSBwcm9wIGlzIGFibGUgdG8gc2V0IGFzIG51bGwvdW5kZWZpbmVkLFxuICogYnV0IG5vdCBzdWl0YWJsZSB0byB1c2UgYGZhbHNlYCwgYGhhc093blByb3BlcnR5YCBpcyBjaGVja2VkLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogW1NUUkFURUdZX1RSQU5TSVRJT05dIFRoZSBydWxlIG9mIHRyYW5zaXRpb246XG4gKiArIEZvciBwcm9wcyBvbiB0aGUgcm9vdCBsZXZlbCBvZiBhIGVsZW1lbnQ6XG4gKiAgICAgIElmIHRoZXJlIGlzIG5vIGB0cmFuc2l0aW9uYCBzcGVjaWZpZWQsIHRhbnNmb3JtIHByb3BzIHdpbGwgYmUgdHJhbnNpdGlvbmVkIGJ5IGRlZmF1bHQsXG4gKiAgICAgIHdoaWNoIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyBzZXR0aW5nIGluIGVjaGFydHM0IGFuZCBzdWl0YWJsZSBmb3IgdGhlIHNjZW5hcmlvXG4gKiAgICAgIG9mIGRhdGFab29tIGNoYW5nZS5cbiAqICAgICAgSWYgYHRyYW5zaXRpb25gIHNwZWNpZmllZCwgb25seSB0aGUgc3BlY2lmaWVkIHByb3BzIHdpbGwgYmUgdHJhbnNpdGlvbmVkLlxuICogKyBGb3IgcHJvcHMgaW4gYHNoYXBlYCBhbmQgYHN0eWxlYDpcbiAqICAgICAgT25seSBwcm9wcyBzcGVjaWZpZWQgaW4gYHRyYW5zaXRpb25gIHdpbGwgYmUgdHJhbnNpdGlvbmVkLlxuICogKyBCcmVhazpcbiAqICAgICAgU2luY2UgZWM1LCBkbyBub3QgbWFrZSB0cmFuc2l0aW9uIHRvIHNoYXBlIGJ5IGRlZmF1bHQsIGJlY2F1c2UgaXQgbWlnaHQgcmVzdWx0IGluXG4gKiAgICAgIHBlcmZvcm1hbmNlIGlzc3VlIChlc3BlY2lhbGx5IGBwb2ludHNgIG9mIHBvbHlnb24pIGFuZCBkbyBub3QgbmVjZXNzYXJ5IGluIG1vc3QgY2FzZXMuXG4gKlxuICogQHJldHVybiBpZiBgaXNNb3JwaFRvYCwgcmV0dXJuIGBhbGxQcm9wc0ZpbmFsYC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHVwZGF0ZUVsTm9ybWFsKCAvLyBDYW4gYmUgbnVsbC91bmRlZmluZWRcbmFwaSwgZWwsIC8vIFdoZXRoZXIgYmUgYSBtb3JwaCB0YXJnZXQuXG5pc01vcnBoVG8sIGRhdGFJbmRleCwgZWxPcHRpb24sIHN0eWxlT3B0LCBhdHRhY2hlZFR4SW5mbywgc2VyaWVzTW9kZWwsIGlzSW5pdCwgaXNUZXh0Q29udGVudCkge1xuICB2YXIgdHJhbnNGcm9tUHJvcHMgPSB7fTtcbiAgdmFyIGFsbFByb3BzRmluYWwgPSB7fTtcbiAgdmFyIGVsRGlzcGxheWFibGUgPSBlbC5pc0dyb3VwID8gbnVsbCA6IGVsOyAvLyBJZiBiZSBcIm1vcnBoIHRvXCIsIGRlbGF5IHRoZSBgdXBkYXRlRWxOb3JtYWxgIHdoZW4gYWxsIG9mIHRoZSBlbHMgaW5cbiAgLy8gdGhpcyBkYXRhIGl0ZW0gcHJvY2Vzc2VkLiBCZWNhdXNlIGF0IHRoYXQgdGltZSB3ZSBjYW4gZ2V0IGFsbCBvZiB0aGVcbiAgLy8gXCJtb3JwaCBmcm9tXCIgYW5kIG1ha2UgY29ycmVjdCBzZXBhcmF0ZS9jb21iaW5lLlxuXG4gICFpc01vcnBoVG8gJiYgcHJlcGFyZVNoYXBlT3JFeHRyYVRyYW5zaXRpb25Gcm9tKCdzaGFwZScsIGVsLCBudWxsLCBlbE9wdGlvbiwgdHJhbnNGcm9tUHJvcHMsIGlzSW5pdCk7XG4gIHByZXBhcmVTaGFwZU9yRXh0cmFBbGxQcm9wc0ZpbmFsKCdzaGFwZScsIGVsT3B0aW9uLCBhbGxQcm9wc0ZpbmFsKTtcbiAgIWlzTW9ycGhUbyAmJiBwcmVwYXJlU2hhcGVPckV4dHJhVHJhbnNpdGlvbkZyb20oJ2V4dHJhJywgZWwsIG51bGwsIGVsT3B0aW9uLCB0cmFuc0Zyb21Qcm9wcywgaXNJbml0KTtcbiAgcHJlcGFyZVNoYXBlT3JFeHRyYUFsbFByb3BzRmluYWwoJ2V4dHJhJywgZWxPcHRpb24sIGFsbFByb3BzRmluYWwpO1xuICAhaXNNb3JwaFRvICYmIHByZXBhcmVUcmFuc2Zvcm1UcmFuc2l0aW9uRnJvbShlbCwgbnVsbCwgZWxPcHRpb24sIHRyYW5zRnJvbVByb3BzLCBpc0luaXQpO1xuICBwcmVwYXJlVHJhbnNmb3JtQWxsUHJvcHNGaW5hbChlbE9wdGlvbiwgYWxsUHJvcHNGaW5hbCk7XG4gIHZhciB0eENmZ09wdCA9IGF0dGFjaGVkVHhJbmZvICYmIGF0dGFjaGVkVHhJbmZvLm5vcm1hbC5jZmc7XG5cbiAgaWYgKHR4Q2ZnT3B0KSB7XG4gICAgLy8gUEVORElORzogd2hldGhlciB1c2UgdXNlciBvYmplY3QgZGlyZWN0bHkgcmF0aGVyIHRoYW4gY2xvbmU/XG4gICAgLy8gVE9ETzo1LjAgdGV4dENvbmZpZyB0cmFuc2l0aW9uIGFuaW1hdGlvbj9cbiAgICBlbC5zZXRUZXh0Q29uZmlnKHR4Q2ZnT3B0KTtcbiAgfVxuXG4gIGlmIChlbC50eXBlID09PSAndGV4dCcgJiYgc3R5bGVPcHQpIHtcbiAgICB2YXIgdGV4dE9wdGlvblN0eWxlID0gc3R5bGVPcHQ7IC8vIENvbXBhdGlibGUgd2l0aCBlYzQ6IGlmIGB0ZXh0RmlsbGAgb3IgYHRleHRTdHJva2VgIGV4aXN0cyB1c2UgdGhlbS5cblxuICAgIGhhc093bih0ZXh0T3B0aW9uU3R5bGUsICd0ZXh0RmlsbCcpICYmICh0ZXh0T3B0aW9uU3R5bGUuZmlsbCA9IHRleHRPcHRpb25TdHlsZS50ZXh0RmlsbCk7XG4gICAgaGFzT3duKHRleHRPcHRpb25TdHlsZSwgJ3RleHRTdHJva2UnKSAmJiAodGV4dE9wdGlvblN0eWxlLnN0cm9rZSA9IHRleHRPcHRpb25TdHlsZS50ZXh0U3Ryb2tlKTtcbiAgfVxuXG4gIGlmIChzdHlsZU9wdCkge1xuICAgIHZhciBkZWNhbFBhdHRlcm4gPSB2b2lkIDA7XG4gICAgdmFyIGRlY2FsT2JqID0gaXNQYXRoKGVsKSA/IHN0eWxlT3B0LmRlY2FsIDogbnVsbDtcblxuICAgIGlmIChhcGkgJiYgZGVjYWxPYmopIHtcbiAgICAgIGRlY2FsT2JqLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIGRlY2FsUGF0dGVybiA9IGNyZWF0ZU9yVXBkYXRlUGF0dGVybkZyb21EZWNhbChkZWNhbE9iaiwgYXBpKTtcbiAgICB9IC8vIEFsd2F5cyBvdmVyd3JpdGUgaW4gY2FzZSB1c2VyIHNwZWNpZnkgdGhpcyBwcm9wLlxuXG5cbiAgICBzdHlsZU9wdC5fX2RlY2FsUGF0dGVybiA9IGRlY2FsUGF0dGVybjtcbiAgfVxuXG4gICFpc01vcnBoVG8gJiYgcHJlcGFyZVN0eWxlVHJhbnNpdGlvbkZyb20oZWwsIG51bGwsIGVsT3B0aW9uLCBzdHlsZU9wdCwgdHJhbnNGcm9tUHJvcHMsIGlzSW5pdCk7XG5cbiAgaWYgKGVsRGlzcGxheWFibGUpIHtcbiAgICBoYXNPd24oZWxPcHRpb24sICdpbnZpc2libGUnKSAmJiAoZWxEaXNwbGF5YWJsZS5pbnZpc2libGUgPSBlbE9wdGlvbi5pbnZpc2libGUpO1xuICB9IC8vIElmIGBpc01vcnBoVG9gLCB3ZSBzaG91bGQgbm90IHVwZGF0ZSB0aGVzZSBwcm9wcyB0byBlbCBkaXJlY3RseSwgb3RoZXJ3aXNlLFxuICAvLyB3aGVuIGFwcGx5aW5nIG1vcnBoIGZpbmFsbHksIHRoZSBvcmlnaW5hbCBwcm9wIGFyZSBtaXNzaW5nIGZvciBtYWtpbmcgXCJhbmltYXRpb24gZnJvbVwiLlxuXG5cbiAgaWYgKCFpc01vcnBoVG8pIHtcbiAgICBhcHBseVByb3BzRmluYWwoZWwsIGFsbFByb3BzRmluYWwsIHN0eWxlT3B0KTtcbiAgICBhcHBseVRyYW5zaXRpb25Gcm9tKGVsLCBkYXRhSW5kZXgsIGVsT3B0aW9uLCBzZXJpZXNNb2RlbCwgdHJhbnNGcm9tUHJvcHMsIGlzSW5pdCk7XG4gIH0gLy8gTWVyZ2UgYnkgZGVmYXVsdC5cblxuXG4gIGhhc093bihlbE9wdGlvbiwgJ3NpbGVudCcpICYmIChlbC5zaWxlbnQgPSBlbE9wdGlvbi5zaWxlbnQpO1xuICBoYXNPd24oZWxPcHRpb24sICdpZ25vcmUnKSAmJiAoZWwuaWdub3JlID0gZWxPcHRpb24uaWdub3JlKTtcblxuICBpZiAoIWlzVGV4dENvbnRlbnQpIHtcbiAgICAvLyBgZWxPcHRpb24uaW5mb2AgZW5hYmxlcyB1c2VyIHRvIG1vdW50IHNvbWUgaW5mbyBvblxuICAgIC8vIGVsZW1lbnRzIGFuZCB1c2UgdGhlbSBpbiBldmVudCBoYW5kbGVycy5cbiAgICAvLyBVcGRhdGUgdGhlbSBvbmx5IHdoZW4gdXNlciBzcGVjaWZpZWQsIG90aGVyd2lzZSwgcmVtYWluLlxuICAgIGhhc093bihlbE9wdGlvbiwgJ2luZm8nKSAmJiAoaW5uZXIoZWwpLmluZm8gPSBlbE9wdGlvbi5pbmZvKTtcbiAgfVxuXG4gIHN0eWxlT3B0ID8gZWwuZGlydHkoKSA6IGVsLm1hcmtSZWRyYXcoKTtcbiAgcmV0dXJuIGlzTW9ycGhUbyA/IGFsbFByb3BzRmluYWwgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBhcHBseVByb3BzRmluYWwoZWwsIC8vIENhbiBiZSBudWxsL3VuZGVmaW5lZFxuYWxsUHJvcHNGaW5hbCwgc3R5bGVPcHQpIHtcbiAgdmFyIGVsRGlzcGxheWFibGUgPSBlbC5pc0dyb3VwID8gbnVsbCA6IGVsO1xuXG4gIGlmIChlbERpc3BsYXlhYmxlICYmIHN0eWxlT3B0KSB7XG4gICAgdmFyIGRlY2FsUGF0dGVybiA9IHN0eWxlT3B0Ll9fZGVjYWxQYXR0ZXJuO1xuICAgIHZhciBvcmlnaW5hbERlY2FsT2JqID0gdm9pZCAwO1xuXG4gICAgaWYgKGRlY2FsUGF0dGVybikge1xuICAgICAgb3JpZ2luYWxEZWNhbE9iaiA9IHN0eWxlT3B0LmRlY2FsO1xuICAgICAgc3R5bGVPcHQuZGVjYWwgPSBkZWNhbFBhdHRlcm47XG4gICAgfSAvLyBQRU5ESU5HOiBoZXJlIHRoZSBpbnB1dCBzdHlsZSBvYmplY3QgaXMgdXNlZCBkaXJlY3RseS5cbiAgICAvLyBHb29kIGZvciBwZXJmb3JtYW5jZSBidXQgYmFkIGZvciBjb21wYXRpYmlsaXR5IGNvbnRyb2wuXG5cblxuICAgIGVsRGlzcGxheWFibGUudXNlU3R5bGUoc3R5bGVPcHQpO1xuXG4gICAgaWYgKGRlY2FsUGF0dGVybikge1xuICAgICAgc3R5bGVPcHQuZGVjYWwgPSBvcmlnaW5hbERlY2FsT2JqO1xuICAgIH0gLy8gV2hlbiBzdHlsZSBvYmplY3QgY2hhbmdlZCwgaG93IHRvIHRyYWRlIHRoZSBleGlzdGluZyBhbmltYXRpb24/XG4gICAgLy8gSXQgaXMgcHJvYmFibHkgY29ucGxpY2F0ZWQgYW5kIG5vdCBuZWVkZWQgdG8gY292ZXIgYWxsIHRoZSBjYXNlcy5cbiAgICAvLyBCdXQgc3RpbGwgbmVlZCBjb25zaWRlciB0aGUgY2FzZTpcbiAgICAvLyAoMSkgV2hlbiB1c2luZyBpbml0IGFuaW1hdGlvbiBvbiBgc3R5bGUub3BhY2l0eWAsIGFuZCBiZWZvcmUgdGhlIGFuaW1hdGlvblxuICAgIC8vICAgICBlbmRlZCB1c2VycyB0cmlnZ2VycyBhbiB1cGRhdGUgYnkgbW91c2V3aGVsbC4gQXQgdGhhdCB0aW1lIHRoZSBpbml0XG4gICAgLy8gICAgIGFuaW1hdGlvbiBzaG91bGQgYmV0dGVyIGJlIGNvbnRpbnVlZCByYXRoZXIgdGhhbiB0ZXJtaW5hdGVkLlxuICAgIC8vICAgICBTbyBhZnRlciBgdXNlU3R5bGVgIGNhbGxlZCwgd2Ugc2hvdWxkIGNoYW5nZSB0aGUgYW5pbWF0aW9uIHRhcmdldCBtYW51YWxseVxuICAgIC8vICAgICB0byBjb250aW51ZSB0aGUgZWZmZWN0IG9mIHRoZSBpbml0IGFuaW1hdGlvbi5cbiAgICAvLyAoMikgUEVORElORzogSWYgdGhlIHByZXZpb3VzIGFuaW1hdGlvbiB0YXJnZXRlZCBhdCBhIGB2YWwxYCwgYW5kIGN1cnJlbnRseSB3ZSBuZWVkXG4gICAgLy8gICAgIHRvIHVwZGF0ZSB0aGUgdmFsdWUgdG8gYHZhbDJgIGFuZCBubyBhbmltYXRpb24gZGVjbGFyZWQsIHNob3VsZCBiZSB0ZXJtaW5hdGVcbiAgICAvLyAgICAgdGhlIHByZXZpb3VzIGFuaW1hdGlvbiBvciBqdXN0IG1vZGlmeSB0aGUgdGFyZ2V0IG9mIHRoZSBhbmltYXRpb24/XG4gICAgLy8gICAgIFRoZXJvdGljYWxseSBUaGF0IHdpbGwgaGFwcGVuIG5vdCBvbmx5IG9uIGBzdHlsZWAgYnV0IGFsc28gb24gYHNoYXBlYCBhbmRcbiAgICAvLyAgICAgYHRyYW5zZnJvbWAgcHJvcHMuIEJ1dCB3ZSBoYXZlbid0IGhhbmRsZSB0aGlzIGNhc2UgYXQgcHJlc2VudCB5ZXQuXG4gICAgLy8gKDMpIFBFTkRJTkc6IElzIGl0IHByb3BlciB0byB2aXNpdCBgYW5pbWF0b3JzYCBhbmQgYHRhcmdldE5hbWVgP1xuXG5cbiAgICB2YXIgYW5pbWF0b3JzID0gZWxEaXNwbGF5YWJsZS5hbmltYXRvcnM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuaW1hdG9yID0gYW5pbWF0b3JzW2ldOyAvLyB0YXJnZXROYW1lIGlzIHRoZSBcInRvcEtleVwiLlxuXG4gICAgICBpZiAoYW5pbWF0b3IudGFyZ2V0TmFtZSA9PT0gJ3N0eWxlJykge1xuICAgICAgICBhbmltYXRvci5jaGFuZ2VUYXJnZXQoZWxEaXNwbGF5YWJsZS5zdHlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFNldCBlbCB0byB0aGUgZmluYWwgc3RhdGUgZmlyc3RseS5cblxuXG4gIGFsbFByb3BzRmluYWwgJiYgZWwuYXR0cihhbGxQcm9wc0ZpbmFsKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2l0aW9uRnJvbShlbCwgZGF0YUluZGV4LCBlbE9wdGlvbiwgc2VyaWVzTW9kZWwsIC8vIENhbiBiZSBudWxsL3VuZGVmaW5lZFxudHJhbnNGcm9tUHJvcHMsIGlzSW5pdCkge1xuICBpZiAodHJhbnNGcm9tUHJvcHMpIHtcbiAgICAvLyBEbyBub3QgdXNlIGBlbC51cGRhdGVEdXJpbmdBbmltYXRpb25gIGhlcmUgYmVjdWFzZSBgZWwudXBkYXRlRHVyaW5nQW5pbWF0aW9uYCB3aWxsXG4gICAgLy8gYmUgY2FsbGVkIG11dGlwbGUgdGltZSBpbiBlYWNoIGFuaW1hdGlvbiBmcmFtZS4gRm9yIGV4YW1wbGUsIGlmIGJvdGggXCJ0cmFuc2Zvcm1cIiBwcm9wc1xuICAgIC8vIGFuZCBzaGFwZSBwcm9wcyBhbmQgc3R5bGUgcHJvcHMgY2hhbmdlZCwgaXQgd2lsbCBnZW5lcmF0ZSB0aHJlZSBhbmltYXRvciBhbmQgY2FsbGVkXG4gICAgLy8gb25lLWJ5LW9uZSBpbiBlYWNoIGFuaW1hdGlvbiBmcmFtZS5cbiAgICAvLyBXZSB1c2UgdGhlIGR1cmluZyBpbiBgYW5pbWF0ZVRvL0Zyb21gIHBhcmFtcy5cbiAgICB2YXIgdXNlckR1cmluZyA9IGVsT3B0aW9uLmR1cmluZzsgLy8gRm9yIHNpbXBsaWNpdHksIGlmIGR1cmluZyBub3Qgc3BlY2lmaWVkLCB0aGUgcHJldmlvdXMgZHVyaW5nIHdpbGwgbm90IHdvcmsgYW55IG1vcmUuXG5cbiAgICBpbm5lcihlbCkudXNlckR1cmluZyA9IHVzZXJEdXJpbmc7XG4gICAgdmFyIGNmZ0R1cmluZ0NhbGwgPSB1c2VyRHVyaW5nID8gYmluZChkdXJpbmdDYWxsLCB7XG4gICAgICBlbDogZWwsXG4gICAgICB1c2VyRHVyaW5nOiB1c2VyRHVyaW5nXG4gICAgfSkgOiBudWxsO1xuICAgIHZhciBjZmcgPSB7XG4gICAgICBkYXRhSW5kZXg6IGRhdGFJbmRleCxcbiAgICAgIGlzRnJvbTogdHJ1ZSxcbiAgICAgIGR1cmluZzogY2ZnRHVyaW5nQ2FsbFxuICAgIH07XG4gICAgaXNJbml0ID8gZ3JhcGhpY1V0aWwuaW5pdFByb3BzKGVsLCB0cmFuc0Zyb21Qcm9wcywgc2VyaWVzTW9kZWwsIGNmZykgOiBncmFwaGljVXRpbC51cGRhdGVQcm9wcyhlbCwgdHJhbnNGcm9tUHJvcHMsIHNlcmllc01vZGVsLCBjZmcpO1xuICB9XG59IC8vIFNlZSBbU1RSQVRFR1lfVFJBTlNJVElPTl1cblxuXG5mdW5jdGlvbiBwcmVwYXJlU2hhcGVPckV4dHJhVHJhbnNpdGlvbkZyb20obWFpbkF0dHIsIGVsLCBtb3JwaEZyb21FbCwgZWxPcHRpb24sIHRyYW5zRnJvbVByb3BzLCBpc0luaXQpIHtcbiAgdmFyIGF0dHJPcHQgPSBlbE9wdGlvblttYWluQXR0cl07XG5cbiAgaWYgKCFhdHRyT3B0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVsUHJvcHNJbkF0dHIgPSBlbFttYWluQXR0cl07XG4gIHZhciB0cmFuc0Zyb21Qcm9wc0luQXR0cjtcbiAgdmFyIGVudGVyRnJvbSA9IGF0dHJPcHQuZW50ZXJGcm9tO1xuXG4gIGlmIChpc0luaXQgJiYgZW50ZXJGcm9tKSB7XG4gICAgIXRyYW5zRnJvbVByb3BzSW5BdHRyICYmICh0cmFuc0Zyb21Qcm9wc0luQXR0ciA9IHRyYW5zRnJvbVByb3BzW21haW5BdHRyXSA9IHt9KTtcbiAgICB2YXIgZW50ZXJGcm9tS2V5cyA9IGtleXMoZW50ZXJGcm9tKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50ZXJGcm9tS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gYGVudGVyRnJvbWAgcHJvcHMgYXJlIG5vdCBuZWNlc3NhcmlseSBhbHNvIGRlY2xhcmVkIGluIGBzaGFwZWAvYHN0eWxlYC8uLi4sXG4gICAgICAvLyBmb3IgZXhhbXBsZSwgYG9wYWNpdHlgIGNhbiBvbmx5IGRlY2xhcmVkIGluIGBlbnRlckZyb21gIGJ1dCBub3QgaW4gYHN0eWxlYC5cbiAgICAgIHZhciBrZXkgPSBlbnRlckZyb21LZXlzW2ldOyAvLyBEbyBub3QgY2xvbmUsIGFuaW1hdG9yIHdpbGwgcGVyZm9ybSB0aGF0IGNsb25lLlxuXG4gICAgICB0cmFuc0Zyb21Qcm9wc0luQXR0cltrZXldID0gZW50ZXJGcm9tW2tleV07XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc0luaXQgJiYgZWxQcm9wc0luQXR0ciAvLyBKdXN0IGlnbm9yZSBzaGFwZSBhbmltYXRpb24gaW4gbW9ycGhpbmcuXG4gICYmICEobW9ycGhGcm9tRWwgIT0gbnVsbCAmJiBtYWluQXR0ciA9PT0gJ3NoYXBlJykpIHtcbiAgICBpZiAoYXR0ck9wdC50cmFuc2l0aW9uKSB7XG4gICAgICAhdHJhbnNGcm9tUHJvcHNJbkF0dHIgJiYgKHRyYW5zRnJvbVByb3BzSW5BdHRyID0gdHJhbnNGcm9tUHJvcHNbbWFpbkF0dHJdID0ge30pO1xuICAgICAgdmFyIHRyYW5zaXRpb25LZXlzID0gbm9ybWFsaXplVG9BcnJheShhdHRyT3B0LnRyYW5zaXRpb24pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zaXRpb25LZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSB0cmFuc2l0aW9uS2V5c1tpXTtcbiAgICAgICAgdmFyIGVsVmFsID0gZWxQcm9wc0luQXR0cltrZXldO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tOb25TdHlsZVRhbnNpdGlvblJlZmVyKGtleSwgYXR0ck9wdFtrZXldLCBlbFZhbCk7XG4gICAgICAgIH0gLy8gRG8gbm90IGNsb25lLCBzZWUgYGNoZWNrTm9uU3R5bGVUYW5zaXRpb25SZWZlcmAuXG5cblxuICAgICAgICB0cmFuc0Zyb21Qcm9wc0luQXR0cltrZXldID0gZWxWYWw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRleE9mKGVsT3B0aW9uLnRyYW5zaXRpb24sIG1haW5BdHRyKSA+PSAwKSB7XG4gICAgICAhdHJhbnNGcm9tUHJvcHNJbkF0dHIgJiYgKHRyYW5zRnJvbVByb3BzSW5BdHRyID0gdHJhbnNGcm9tUHJvcHNbbWFpbkF0dHJdID0ge30pO1xuICAgICAgdmFyIGVsUHJvcHNJbkF0dHJLZXlzID0ga2V5cyhlbFByb3BzSW5BdHRyKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbFByb3BzSW5BdHRyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gZWxQcm9wc0luQXR0cktleXNbaV07XG4gICAgICAgIHZhciBlbFZhbCA9IGVsUHJvcHNJbkF0dHJba2V5XTtcblxuICAgICAgICBpZiAoaXNOb25TdHlsZVRyYW5zaXRpb25FbmFibGVkKGF0dHJPcHRba2V5XSwgZWxWYWwpKSB7XG4gICAgICAgICAgdHJhbnNGcm9tUHJvcHNJbkF0dHJba2V5XSA9IGVsVmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlYXZlVG8gPSBhdHRyT3B0LmxlYXZlVG87XG5cbiAgaWYgKGxlYXZlVG8pIHtcbiAgICB2YXIgbGVhdmVUb1Byb3BzID0gZ2V0T3JDcmVhdGVMZWF2ZVRvUHJvcHNGcm9tRWwoZWwpO1xuICAgIHZhciBsZWF2ZVRvUHJvcHNJbkF0dHIgPSBsZWF2ZVRvUHJvcHNbbWFpbkF0dHJdIHx8IChsZWF2ZVRvUHJvcHNbbWFpbkF0dHJdID0ge30pO1xuICAgIHZhciBsZWF2ZVRvS2V5cyA9IGtleXMobGVhdmVUbyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlYXZlVG9LZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gbGVhdmVUb0tleXNbaV07XG4gICAgICBsZWF2ZVRvUHJvcHNJbkF0dHJba2V5XSA9IGxlYXZlVG9ba2V5XTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZVNoYXBlT3JFeHRyYUFsbFByb3BzRmluYWwobWFpbkF0dHIsIGVsT3B0aW9uLCBhbGxQcm9wcykge1xuICB2YXIgYXR0ck9wdCA9IGVsT3B0aW9uW21haW5BdHRyXTtcblxuICBpZiAoIWF0dHJPcHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYWxsUHJvcHNJbkF0dHIgPSBhbGxQcm9wc1ttYWluQXR0cl0gPSB7fTtcbiAgdmFyIGtleXNJbkF0dHIgPSBrZXlzKGF0dHJPcHQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0luQXR0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzSW5BdHRyW2ldOyAvLyBUbyBhdm9pZCBzaGFyZSBvbmUgb2JqZWN0IHdpdGggZGlmZmVyZW50IGVsZW1lbnQsIGFuZFxuICAgIC8vIHRvIGF2b2lkIHVzZXIgbW9kaWZ5IHRoZSBvYmplY3QgaW5leHBlY3RlZGx5LCBoYXZlIHRvIGNsb25lLlxuXG4gICAgYWxsUHJvcHNJbkF0dHJba2V5XSA9IGNsb25lVmFsdWUoYXR0ck9wdFtrZXldKTtcbiAgfVxufSAvLyBTZWUgW1NUUkFURUdZX1RSQU5TSVRJT05dLlxuXG5cbmZ1bmN0aW9uIHByZXBhcmVUcmFuc2Zvcm1UcmFuc2l0aW9uRnJvbShlbCwgbW9ycGhGcm9tRWwsIGVsT3B0aW9uLCB0cmFuc0Zyb21Qcm9wcywgaXNJbml0KSB7XG4gIHZhciBlbnRlckZyb20gPSBlbE9wdGlvbi5lbnRlckZyb207XG5cbiAgaWYgKGlzSW5pdCAmJiBlbnRlckZyb20pIHtcbiAgICB2YXIgZW50ZXJGcm9tS2V5cyA9IGtleXMoZW50ZXJGcm9tKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50ZXJGcm9tS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGVudGVyRnJvbUtleXNbaV07XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNoZWNrVHJhbnNmb3JtUHJvcFJlZmVyKGtleSwgJ2VsLmVudGVyRnJvbScpO1xuICAgICAgfSAvLyBEbyBub3QgY2xvbmUsIGFuaW1hdG9yIHdpbGwgcGVyZm9ybSB0aGF0IGNsb25lLlxuXG5cbiAgICAgIHRyYW5zRnJvbVByb3BzW2tleV0gPSBlbnRlckZyb21ba2V5XTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWlzSW5pdCkge1xuICAgIC8vIElmIG1vcnBoaW5nLCBmb3JjZSB0cmFuc2l0aW9uIGFsbCB0cmFuc2Zvcm0gcHJvcHMuXG4gICAgLy8gb3RoZXJ3aXNlIG1pZ2h0IGhhdmUgaW5jb3JyZWN0IG1vcnBoaW5nIGFuaW1hdGlvbi5cbiAgICBpZiAobW9ycGhGcm9tRWwpIHtcbiAgICAgIHZhciBmcm9tVHJhbnNmb3JtYWJsZSA9IGNhbGNPbGRFbExvY2FsVHJhbnNmb3JtQmFzZWRPbk5ld0VsUGFyZW50KG1vcnBoRnJvbUVsLCBlbCk7XG4gICAgICBzZXRUcmFuc2Zvcm1Qcm9wVG9UcmFuc2l0aW9uRnJvbSh0cmFuc0Zyb21Qcm9wcywgJ3gnLCBmcm9tVHJhbnNmb3JtYWJsZSk7XG4gICAgICBzZXRUcmFuc2Zvcm1Qcm9wVG9UcmFuc2l0aW9uRnJvbSh0cmFuc0Zyb21Qcm9wcywgJ3knLCBmcm9tVHJhbnNmb3JtYWJsZSk7XG4gICAgICBzZXRUcmFuc2Zvcm1Qcm9wVG9UcmFuc2l0aW9uRnJvbSh0cmFuc0Zyb21Qcm9wcywgJ3NjYWxlWCcsIGZyb21UcmFuc2Zvcm1hYmxlKTtcbiAgICAgIHNldFRyYW5zZm9ybVByb3BUb1RyYW5zaXRpb25Gcm9tKHRyYW5zRnJvbVByb3BzLCAnc2NhbGVZJywgZnJvbVRyYW5zZm9ybWFibGUpO1xuICAgICAgc2V0VHJhbnNmb3JtUHJvcFRvVHJhbnNpdGlvbkZyb20odHJhbnNGcm9tUHJvcHMsICdvcmlnaW5YJywgZnJvbVRyYW5zZm9ybWFibGUpO1xuICAgICAgc2V0VHJhbnNmb3JtUHJvcFRvVHJhbnNpdGlvbkZyb20odHJhbnNGcm9tUHJvcHMsICdvcmlnaW5ZJywgZnJvbVRyYW5zZm9ybWFibGUpO1xuICAgICAgc2V0VHJhbnNmb3JtUHJvcFRvVHJhbnNpdGlvbkZyb20odHJhbnNGcm9tUHJvcHMsICdyb3RhdGlvbicsIGZyb21UcmFuc2Zvcm1hYmxlKTtcbiAgICB9IGVsc2UgaWYgKGVsT3B0aW9uLnRyYW5zaXRpb24pIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uS2V5cyA9IG5vcm1hbGl6ZVRvQXJyYXkoZWxPcHRpb24udHJhbnNpdGlvbik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNpdGlvbktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHRyYW5zaXRpb25LZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdzdHlsZScgfHwga2V5ID09PSAnc2hhcGUnIHx8IGtleSA9PT0gJ2V4dHJhJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsVmFsID0gZWxba2V5XTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrVHJhbnNmb3JtUHJvcFJlZmVyKGtleSwgJ2VsLnRyYW5zaXRpb24nKTtcbiAgICAgICAgICBjaGVja05vblN0eWxlVGFuc2l0aW9uUmVmZXIoa2V5LCBlbE9wdGlvbltrZXldLCBlbFZhbCk7XG4gICAgICAgIH0gLy8gRG8gbm90IGNsb25lLCBzZWUgYGNoZWNrTm9uU3R5bGVUYW5zaXRpb25SZWZlcmAuXG5cblxuICAgICAgICB0cmFuc0Zyb21Qcm9wc1trZXldID0gZWxWYWw7XG4gICAgICB9XG4gICAgfSAvLyBUaGlzIGRlZmF1bHQgdHJhbnNpdGlvbiBzZWUgW1NUUkFURUdZX1RSQU5TSVRJT05dXG4gICAgZWxzZSB7XG4gICAgICAgIHNldFRyYW5zZm9ybVByb3BUb1RyYW5zaXRpb25Gcm9tKHRyYW5zRnJvbVByb3BzLCAneCcsIGVsKTtcbiAgICAgICAgc2V0VHJhbnNmb3JtUHJvcFRvVHJhbnNpdGlvbkZyb20odHJhbnNGcm9tUHJvcHMsICd5JywgZWwpO1xuICAgICAgfVxuICB9XG5cbiAgdmFyIGxlYXZlVG8gPSBlbE9wdGlvbi5sZWF2ZVRvO1xuXG4gIGlmIChsZWF2ZVRvKSB7XG4gICAgdmFyIGxlYXZlVG9Qcm9wcyA9IGdldE9yQ3JlYXRlTGVhdmVUb1Byb3BzRnJvbUVsKGVsKTtcbiAgICB2YXIgbGVhdmVUb0tleXMgPSBrZXlzKGxlYXZlVG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWF2ZVRvS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGxlYXZlVG9LZXlzW2ldO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja1RyYW5zZm9ybVByb3BSZWZlcihrZXksICdlbC5sZWF2ZVRvJyk7XG4gICAgICB9XG5cbiAgICAgIGxlYXZlVG9Qcm9wc1trZXldID0gbGVhdmVUb1trZXldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVHJhbnNmb3JtQWxsUHJvcHNGaW5hbChlbE9wdGlvbiwgYWxsUHJvcHMpIHtcbiAgc2V0TGFnZWN5VHJhbnNmb3JtUHJvcChlbE9wdGlvbiwgYWxsUHJvcHMsICdwb3NpdGlvbicpO1xuICBzZXRMYWdlY3lUcmFuc2Zvcm1Qcm9wKGVsT3B0aW9uLCBhbGxQcm9wcywgJ3NjYWxlJyk7XG4gIHNldExhZ2VjeVRyYW5zZm9ybVByb3AoZWxPcHRpb24sIGFsbFByb3BzLCAnb3JpZ2luJyk7XG4gIHNldFRyYW5zZm9ybVByb3AoZWxPcHRpb24sIGFsbFByb3BzLCAneCcpO1xuICBzZXRUcmFuc2Zvcm1Qcm9wKGVsT3B0aW9uLCBhbGxQcm9wcywgJ3knKTtcbiAgc2V0VHJhbnNmb3JtUHJvcChlbE9wdGlvbiwgYWxsUHJvcHMsICdzY2FsZVgnKTtcbiAgc2V0VHJhbnNmb3JtUHJvcChlbE9wdGlvbiwgYWxsUHJvcHMsICdzY2FsZVknKTtcbiAgc2V0VHJhbnNmb3JtUHJvcChlbE9wdGlvbiwgYWxsUHJvcHMsICdvcmlnaW5YJyk7XG4gIHNldFRyYW5zZm9ybVByb3AoZWxPcHRpb24sIGFsbFByb3BzLCAnb3JpZ2luWScpO1xuICBzZXRUcmFuc2Zvcm1Qcm9wKGVsT3B0aW9uLCBhbGxQcm9wcywgJ3JvdGF0aW9uJyk7XG59IC8vIFNlZSBbU1RSQVRFR1lfVFJBTlNJVElPTl0uXG5cblxuZnVuY3Rpb24gcHJlcGFyZVN0eWxlVHJhbnNpdGlvbkZyb20oZWwsIG1vcnBoRnJvbUVsLCBlbE9wdGlvbiwgc3R5bGVPcHQsIHRyYW5zRnJvbVByb3BzLCBpc0luaXQpIHtcbiAgaWYgKCFzdHlsZU9wdCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBBdCBwcmVzZW50IGluIFwibWFueS10by1vbmVcIi9cIm9uZS10by1tYW55XCIgY2FzZSwgdG8gbm90IHN1cHBvcnQgXCJtYW55XCIgaGF2ZVxuICAvLyBkaWZmZXJlbnQgc3R5bGVzIGFuZCBtYWtlIHN0eWxlIHRyYW5zaXRpb25zLiBUaGF0IG1pZ2h0IGJlIGEgcmFyZSBjYXNlLlxuXG5cbiAgdmFyIGZyb21FbCA9IG1vcnBoRnJvbUVsIHx8IGVsO1xuICB2YXIgZnJvbUVsU3R5bGUgPSBmcm9tRWwuc3R5bGU7XG4gIHZhciB0cmFuc0Zyb21TdHlsZVByb3BzO1xuICB2YXIgZW50ZXJGcm9tID0gc3R5bGVPcHQuZW50ZXJGcm9tO1xuXG4gIGlmIChpc0luaXQgJiYgZW50ZXJGcm9tKSB7XG4gICAgdmFyIGVudGVyRnJvbUtleXMgPSBrZXlzKGVudGVyRnJvbSk7XG4gICAgIXRyYW5zRnJvbVN0eWxlUHJvcHMgJiYgKHRyYW5zRnJvbVN0eWxlUHJvcHMgPSB0cmFuc0Zyb21Qcm9wcy5zdHlsZSA9IHt9KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50ZXJGcm9tS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGVudGVyRnJvbUtleXNbaV07IC8vIERvIG5vdCBjbG9uZSwgYW5pbWF0b3Igd2lsbCBwZXJmb3JtIHRoYXQgY2xvbmUuXG5cbiAgICAgIHRyYW5zRnJvbVN0eWxlUHJvcHNba2V5XSA9IGVudGVyRnJvbVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaXNJbml0ICYmIGZyb21FbFN0eWxlKSB7XG4gICAgaWYgKHN0eWxlT3B0LnRyYW5zaXRpb24pIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uS2V5cyA9IG5vcm1hbGl6ZVRvQXJyYXkoc3R5bGVPcHQudHJhbnNpdGlvbik7XG4gICAgICAhdHJhbnNGcm9tU3R5bGVQcm9wcyAmJiAodHJhbnNGcm9tU3R5bGVQcm9wcyA9IHRyYW5zRnJvbVByb3BzLnN0eWxlID0ge30pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zaXRpb25LZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSB0cmFuc2l0aW9uS2V5c1tpXTtcbiAgICAgICAgdmFyIGVsVmFsID0gZnJvbUVsU3R5bGVba2V5XTsgLy8gRG8gbm90IGNsb25lLCBzZWUgYGNoZWNrTm9uU3R5bGVUYW5zaXRpb25SZWZlcmAuXG5cbiAgICAgICAgdHJhbnNGcm9tU3R5bGVQcm9wc1trZXldID0gZWxWYWw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbC5nZXRBbmltYXRpb25TdHlsZVByb3BzICYmIGluZGV4T2YoZWxPcHRpb24udHJhbnNpdGlvbiwgJ3N0eWxlJykgPj0gMCkge1xuICAgICAgdmFyIGFuaW1hdGlvblByb3BzID0gZWwuZ2V0QW5pbWF0aW9uU3R5bGVQcm9wcygpO1xuICAgICAgdmFyIGFuaW1hdGlvblN0eWxlUHJvcHMgPSBhbmltYXRpb25Qcm9wcyA/IGFuaW1hdGlvblByb3BzLnN0eWxlIDogbnVsbDtcblxuICAgICAgaWYgKGFuaW1hdGlvblN0eWxlUHJvcHMpIHtcbiAgICAgICAgIXRyYW5zRnJvbVN0eWxlUHJvcHMgJiYgKHRyYW5zRnJvbVN0eWxlUHJvcHMgPSB0cmFuc0Zyb21Qcm9wcy5zdHlsZSA9IHt9KTtcbiAgICAgICAgdmFyIHN0eWxlS2V5cyA9IGtleXMoc3R5bGVPcHQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHN0eWxlS2V5c1tpXTtcblxuICAgICAgICAgIGlmIChhbmltYXRpb25TdHlsZVByb3BzW2tleV0pIHtcbiAgICAgICAgICAgIHZhciBlbFZhbCA9IGZyb21FbFN0eWxlW2tleV07XG4gICAgICAgICAgICB0cmFuc0Zyb21TdHlsZVByb3BzW2tleV0gPSBlbFZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbGVhdmVUbyA9IHN0eWxlT3B0LmxlYXZlVG87XG5cbiAgaWYgKGxlYXZlVG8pIHtcbiAgICB2YXIgbGVhdmVUb0tleXMgPSBrZXlzKGxlYXZlVG8pO1xuICAgIHZhciBsZWF2ZVRvUHJvcHMgPSBnZXRPckNyZWF0ZUxlYXZlVG9Qcm9wc0Zyb21FbChlbCk7XG4gICAgdmFyIGxlYXZlVG9TdHlsZVByb3BzID0gbGVhdmVUb1Byb3BzLnN0eWxlIHx8IChsZWF2ZVRvUHJvcHMuc3R5bGUgPSB7fSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlYXZlVG9LZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gbGVhdmVUb0tleXNbaV07XG4gICAgICBsZWF2ZVRvU3R5bGVQcm9wc1trZXldID0gbGVhdmVUb1trZXldO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBJZiBtYWtlIFwidHJhbnNmb3JtXCIoeC95L3NjYWxlWC9zY2FsZVkvb3JpZW50L29yaWdpblgvb3JpZ2luWSkgdHJhbnNpdGlvbiBiZXR3ZWVuXG4gKiB0d28gcGF0aCBlbGVtZW50cyB0aGF0IGhhdmUgZGlmZmVyZW50IGhpZXJhcmNoeSwgYmVmb3JlIHdlIHJldHJpZXZlIHRoZSBcImZyb21cIiBwcm9wcyxcbiAqIHdlIGhhdmUgdG8gY2FsY3VsYXRlIHRoZSBsb2NhbCB0cmFuc2l0aW9uIG9mIHRoZSBcIm9sZFBhdGhcIiBiYXNlZCBvbiB0aGUgcGFyZW50IG9mXG4gKiB0aGUgXCJuZXdQYXRoXCIuXG4gKiBBdCBwcmVzZW50LCB0aGUgY2FzZSBvbmx5IGhhcHBlbmQgaW4gXCJtb3JwaGluZ1wiLiBXaXRob3V0IG1vcnBoaW5nLCB0aGUgdHJhbnNmb3JtXG4gKiB0cmFuc2l0aW9uIGFyZSBhbGwgYmV0d2VlbiBlbGVtZW50cyBpbiB0aGUgc2FtZSBoaWVyYXJjaHksIHdoZXJlIHRoaXMga2luZCBvZiBwcm9jZXNzXG4gKiBpcyBub3QgbmVlZGVkLlxuICpcbiAqIFtDQVZFQVRdOlxuICogVGhpcyBtZXRob2QgbWFrZXMgc2Vuc2Ugb25seSBpZjogKHZlcnkgdHJpY2t5KVxuICogKDEpIFwibmV3RWxcIiBoYXMgYmVlbiBhZGRlZCB0byBpdHMgZmluYWwgcGFyZW50LlxuICogKDIpIExvY2FsIHRyYW5zZm9ybSBwcm9wcyBvZiBcIm5ld1BhdGgucGFyZW50XCIgYXJlIG5vdCBhdCB0aGVpciBmaW5hbCB2YWx1ZSBidXQgYWxyZWFkeVxuICogaGF2ZSBiZWVuIGF0IHRoZSBcImZyb20gdmFsdWVcIi5cbiAqICAgICBUaGlzIGlzIGN1cnJlbnRseSBlbnN1cmVkIGJ5OlxuICogICAgICgyLjEpIFwiZ3JhcGhpY1V0aWwuYW5pbWF0aW9uRnJvbVwiLCB3aGljaCB3aWxsIHNldCB0aGUgZWxlbWVudCB0byB0aGUgXCJmcm9tIHZhbHVlXCJcbiAqICAgICBpbW1lZGlhdGVseS5cbiAqICAgICAoMi4yKSBcIm1vcnBoXCIgb3B0aW9uIGlzIG5vdCBhbGxvd2VkIHRvIGJlIHNldCBvbiBHcm91cCwgc28gYWxsIG9mIHRoZSBncm91cHMgaGF2ZVxuICogICAgIGJlZW4gZmluaXNoZWQgdGhlaXIgXCJ1cGRhdGVFbE5vcm1hbFwiIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBpbiBtb3JwaGluZyBwcm9jZXNzLlxuICovXG5cblxuZnVuY3Rpb24gY2FsY09sZEVsTG9jYWxUcmFuc2Zvcm1CYXNlZE9uTmV3RWxQYXJlbnQob2xkRWwsIG5ld0VsKSB7XG4gIGlmICghb2xkRWwgfHwgb2xkRWwgPT09IG5ld0VsIHx8IG9sZEVsLnBhcmVudCA9PT0gbmV3RWwucGFyZW50KSB7XG4gICAgcmV0dXJuIG9sZEVsO1xuICB9IC8vIE5vdCBzdXJlIG9sZEVsIGlzIHJlbmRlcmVkIChtYXkgaGF2ZSBcImxhenlVcGRhdGVcIiksXG4gIC8vIHNvIGFsd2F5cyBjYWxsIGBnZXRDb21wdXRlZFRyYW5zZm9ybWAuXG5cblxuICB2YXIgdG1wTSA9IHRtcFRyYW5zZm9ybWFibGUudHJhbnNmb3JtIHx8ICh0bXBUcmFuc2Zvcm1hYmxlLnRyYW5zZm9ybSA9IG1hdHJpeC5pZGVudGl0eShbXSkpO1xuICB2YXIgb2xkR2xvYmFsVHJhbnNmb3JtID0gb2xkRWwuZ2V0Q29tcHV0ZWRUcmFuc2Zvcm0oKTtcbiAgb2xkR2xvYmFsVHJhbnNmb3JtID8gbWF0cml4LmNvcHkodG1wTSwgb2xkR2xvYmFsVHJhbnNmb3JtKSA6IG1hdHJpeC5pZGVudGl0eSh0bXBNKTtcbiAgdmFyIG5ld1BhcmVudCA9IG5ld0VsLnBhcmVudDtcblxuICBpZiAobmV3UGFyZW50KSB7XG4gICAgbmV3UGFyZW50LmdldENvbXB1dGVkVHJhbnNmb3JtKCk7XG4gIH1cblxuICB0bXBUcmFuc2Zvcm1hYmxlLm9yaWdpblggPSBvbGRFbC5vcmlnaW5YO1xuICB0bXBUcmFuc2Zvcm1hYmxlLm9yaWdpblkgPSBvbGRFbC5vcmlnaW5ZO1xuICB0bXBUcmFuc2Zvcm1hYmxlLnBhcmVudCA9IG5ld1BhcmVudDtcbiAgdG1wVHJhbnNmb3JtYWJsZS5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcbiAgcmV0dXJuIHRtcFRyYW5zZm9ybWFibGU7XG59XG5cbnZhciBjaGVja05vblN0eWxlVGFuc2l0aW9uUmVmZXI7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGNoZWNrTm9uU3R5bGVUYW5zaXRpb25SZWZlciA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgb3B0VmFsLCBlbFZhbCkge1xuICAgIGlmICghaXNBcnJheUxpa2Uob3B0VmFsKSkge1xuICAgICAgYXNzZXJ0KG9wdFZhbCAhPSBudWxsICYmIGlzRmluaXRlKG9wdFZhbCksICdQcm9wIGAnICsgcHJvcE5hbWUgKyAnYCBtdXN0IHJlZmVyIHRvIGEgZmluaXRlIG51bWJlciBvciBBcnJheUxpa2UgZm9yIHRyYW5zaXRpb24uJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyeSBub3QgdG8gY29weSBhcnJheSBmb3IgcGVyZm9ybWFuY2UsIGJ1dCBpZiB1c2VyIHVzZSB0aGUgc2FtZSBvYmplY3QgaW4gZGlmZmVyZW50XG4gICAgICAvLyBjYWxsIG9mIGByZW5kZXJJdGVtYCwgaXQgd2lsbCBjYXN1ZSBhbmltYXRpb24gdHJhbnNpdGlvbiBmYWlsLlxuICAgICAgYXNzZXJ0KG9wdFZhbCAhPT0gZWxWYWwsICdQcm9wIGAnICsgcHJvcE5hbWUgKyAnYCBtdXN0IHVzZSBkaWZmZXJlbnQgQXJyYXkgb2JqZWN0IGVhY2ggdGltZSBmb3IgdHJhbnNpdGlvbi4nKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzTm9uU3R5bGVUcmFuc2l0aW9uRW5hYmxlZChvcHRWYWwsIGVsVmFsKSB7XG4gIC8vIFRoZSBzYW1lIGFzIGBjaGVja05vblN0eWxlVGFuc2l0aW9uUmVmZXJgLlxuICByZXR1cm4gIWlzQXJyYXlMaWtlKG9wdFZhbCkgPyBvcHRWYWwgIT0gbnVsbCAmJiBpc0Zpbml0ZShvcHRWYWwpIDogb3B0VmFsICE9PSBlbFZhbDtcbn1cblxudmFyIGNoZWNrVHJhbnNmb3JtUHJvcFJlZmVyO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBjaGVja1RyYW5zZm9ybVByb3BSZWZlciA9IGZ1bmN0aW9uIChrZXksIHVzZWRJbikge1xuICAgIGFzc2VydChoYXNPd24oVFJBTlNGT1JNX1BST1BTLCBrZXkpLCAnUHJvcCBgJyArIGtleSArICdgIGlzIG5vdCBhIHBlcm1pdHRlZCBpbiBgJyArIHVzZWRJbiArICdgLiAnICsgJ09ubHkgYCcgKyBrZXlzKFRSQU5TRk9STV9QUk9QUykuam9pbignYCwgYCcpICsgJ2AgYXJlIHBlcm1pdHRlZC4nKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVMZWF2ZVRvUHJvcHNGcm9tRWwoZWwpIHtcbiAgdmFyIGlubmVyRWwgPSBpbm5lcihlbCk7XG4gIHJldHVybiBpbm5lckVsLmxlYXZlVG9Qcm9wcyB8fCAoaW5uZXJFbC5sZWF2ZVRvUHJvcHMgPSB7fSk7XG59IC8vIFVzZSBpdCB0byBhdm9pZCBpdCBiZSBleHBvc2VkIHRvIHVzZXIuXG5cblxudmFyIHRtcER1cmluZ1Njb3BlID0ge307XG52YXIgY3VzdG9tRHVyaW5nQVBJID0ge1xuICAvLyBVc3VhbGx5IG90aGVyIHByb3BzIGRvIG5vdCBuZWVkIHRvIGJlIGNoYW5nZWQgaW4gYW5pbWF0aW9uIGR1cmluZy5cbiAgc2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0KGhhc093bihUUkFOU0ZPUk1fUFJPUFMsIGtleSksICdPbmx5ICcgKyB0cmFuc2Zvcm1Qcm9wTmFtZXNTdHIgKyAnIGF2YWlsYWJsZSBpbiBgc2V0VHJhbnNmb3JtYC4nKTtcbiAgICB9XG5cbiAgICB0bXBEdXJpbmdTY29wZS5lbFtrZXldID0gdmFsO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBnZXRUcmFuc2Zvcm06IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0KGhhc093bihUUkFOU0ZPUk1fUFJPUFMsIGtleSksICdPbmx5ICcgKyB0cmFuc2Zvcm1Qcm9wTmFtZXNTdHIgKyAnIGF2YWlsYWJsZSBpbiBgZ2V0VHJhbnNmb3JtYC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG1wRHVyaW5nU2NvcGUuZWxba2V5XTtcbiAgfSxcbiAgc2V0U2hhcGU6IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnROb3RSZXNlcnZlZChrZXkpO1xuICAgIH1cblxuICAgIHZhciBzaGFwZSA9IHRtcER1cmluZ1Njb3BlLmVsLnNoYXBlIHx8ICh0bXBEdXJpbmdTY29wZS5lbC5zaGFwZSA9IHt9KTtcbiAgICBzaGFwZVtrZXldID0gdmFsO1xuICAgIHRtcER1cmluZ1Njb3BlLmlzU2hhcGVEaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGdldFNoYXBlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydE5vdFJlc2VydmVkKGtleSk7XG4gICAgfVxuXG4gICAgdmFyIHNoYXBlID0gdG1wRHVyaW5nU2NvcGUuZWwuc2hhcGU7XG5cbiAgICBpZiAoc2hhcGUpIHtcbiAgICAgIHJldHVybiBzaGFwZVtrZXldO1xuICAgIH1cbiAgfSxcbiAgc2V0U3R5bGU6IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnROb3RSZXNlcnZlZChrZXkpO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHRtcER1cmluZ1Njb3BlLmVsLnN0eWxlO1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZXFOYU4odmFsKSkge1xuICAgICAgICAgIHdhcm4oJ3N0eWxlLicgKyBrZXkgKyAnIG11c3Qgbm90IGJlIGFzc2lnbmVkIHdpdGggTmFOLicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0eWxlW2tleV0gPSB2YWw7XG4gICAgICB0bXBEdXJpbmdTY29wZS5pc1N0eWxlRGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBnZXRTdHlsZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnROb3RSZXNlcnZlZChrZXkpO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHRtcER1cmluZ1Njb3BlLmVsLnN0eWxlO1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICByZXR1cm4gc3R5bGVba2V5XTtcbiAgICB9XG4gIH0sXG4gIHNldEV4dHJhOiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0Tm90UmVzZXJ2ZWQoa2V5KTtcbiAgICB9XG5cbiAgICB2YXIgZXh0cmEgPSB0bXBEdXJpbmdTY29wZS5lbC5leHRyYSB8fCAodG1wRHVyaW5nU2NvcGUuZWwuZXh0cmEgPSB7fSk7XG4gICAgZXh0cmFba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZ2V0RXh0cmE6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0Tm90UmVzZXJ2ZWQoa2V5KTtcbiAgICB9XG5cbiAgICB2YXIgZXh0cmEgPSB0bXBEdXJpbmdTY29wZS5lbC5leHRyYTtcblxuICAgIGlmIChleHRyYSkge1xuICAgICAgcmV0dXJuIGV4dHJhW2tleV07XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBhc3NlcnROb3RSZXNlcnZlZChrZXkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoa2V5ID09PSAndHJhbnNpdGlvbicgfHwga2V5ID09PSAnZW50ZXJGcm9tJyB8fCBrZXkgPT09ICdsZWF2ZVRvJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXkgbXVzdCBub3QgYmUgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGR1cmluZ0NhbGwoKSB7XG4gIC8vIERvIG5vdCBwcm92aWRlIFwicGVyY2VudFwiIHVudGlsIHNvbWUgcmVxdWlyZW1lbnRzIGNvbWUuXG4gIC8vIEJlY2F1c2UgY29uc2lkZXIgdGhpZXMgY2FzZTpcbiAgLy8gZW50ZXJGcm9tOiB7eDogMTAwLCB5OiAzMH0sIHRyYW5zaXRpb246ICd4Jy5cbiAgLy8gQW5kIGVudGVyIGR1cmF0aW9uIGlzIGRpZmZlcmVudCBmcm9tIHVwZGF0ZSBkdXJhdGlvbi5cbiAgLy8gVGh1cyBpdCBtaWdodCBiZSBjb25mdXNlZCBhYm91dCB0aGUgbWVhbmluZyBvZiBcInBlcmNlbnRcIiBpbiBkdXJpbmcgY2FsbGJhY2suXG4gIHZhciBzY29wZSA9IHRoaXM7XG4gIHZhciBlbCA9IHNjb3BlLmVsO1xuXG4gIGlmICghZWwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gSWYgZWwgaXMgcmVtb3ZlIGZyb20genIgYnkgcmVhc29uIGxpa2UgbGVnZW5kLCBkdXJpbmcgc3RpbGwgbmVlZCB0byBjYWxsZWQsXG4gIC8vIGJlY3Vhc2UgZWwgd2lsbCBiZSBhZGRlZCBiYWNrIHRvIHpyIGFuZCB0aGUgcHJvcCB2YWx1ZSBzaG91bGQgbm90IGJlIGluY29ycmVjdC5cblxuXG4gIHZhciBuZXdzdFVzZXJEdXJpbmcgPSBpbm5lcihlbCkudXNlckR1cmluZztcbiAgdmFyIHNjb3BlVXNlckR1cmluZyA9IHNjb3BlLnVzZXJEdXJpbmc7IC8vIEVuc3VyZWQgYSBkdXJpbmcgaXMgb25seSBjYWxsZWQgb25jZSBpbiBlYWNoIGFuaW1hdGlvbiBmcmFtZS5cbiAgLy8gSWYgYSBkdXJpbmcgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIG9uZSBmcmFtZSwgbWF5YmUgc29tZSB1c2VycycgY2FsdWxhdGlvbiBsb2dpY1xuICAvLyBtaWdodCBiZSB3cm9uZyAobm90IHN1cmUgd2hldGhlciB0aGlzIHVzYWdlIGV4aXN0cykuXG4gIC8vIFRoZSBjYXNlIG9mIGEgZHVyaW5nIG1pZ2h0IGJlIGNhbGxlZCB0d2ljZSBjYW4gYmU6IGJ5IGRlZmF1bHQgdGhlcmUgaXMgYSBhbmltYXRvciBmb3JcbiAgLy8gJ3gnLCAneScgd2hlbiBpbml0LiBCZWZvcmUgdGhlIGluaXQgYW5pbWF0aW9uIGZpbmlzaGVkLCBjYWxsIGBzZXRPcHRpb25gIHRvIHN0YXJ0XG4gIC8vIGFub3RoZXIgYW5pbWF0b3JzIGZvciAnc3R5bGUnLydzaGFwZScvJ2V4dHJhJy5cblxuICBpZiAobmV3c3RVc2VyRHVyaW5nICE9PSBzY29wZVVzZXJEdXJpbmcpIHtcbiAgICAvLyByZWxlYXNlXG4gICAgc2NvcGUuZWwgPSBzY29wZS51c2VyRHVyaW5nID0gbnVsbDtcbiAgICByZXR1cm47XG4gIH1cblxuICB0bXBEdXJpbmdTY29wZS5lbCA9IGVsO1xuICB0bXBEdXJpbmdTY29wZS5pc1NoYXBlRGlydHkgPSBmYWxzZTtcbiAgdG1wRHVyaW5nU2NvcGUuaXNTdHlsZURpcnR5ID0gZmFsc2U7IC8vIEdpdmUgbm8gYHRoaXNgIHRvIHVzZXIgaW4gXCJkdXJpbmdcIiBjYWxsaW5nLlxuXG4gIHNjb3BlVXNlckR1cmluZyhjdXN0b21EdXJpbmdBUEkpO1xuXG4gIGlmICh0bXBEdXJpbmdTY29wZS5pc1NoYXBlRGlydHkgJiYgZWwuZGlydHlTaGFwZSkge1xuICAgIGVsLmRpcnR5U2hhcGUoKTtcbiAgfVxuXG4gIGlmICh0bXBEdXJpbmdTY29wZS5pc1N0eWxlRGlydHkgJiYgZWwuZGlydHlTdHlsZSkge1xuICAgIGVsLmRpcnR5U3R5bGUoKTtcbiAgfSAvLyBtYXJrUmVkcmF3KCkgd2lsbCBiZSBjYWxsZWQgYnkgZGVmYXVsdCBpbiBkdXJpbmcuXG4gIC8vIEZJWE1FIGB0aGlzLm1hcmtSZWRyYXcoKTtgIGRpcmVjdGx5ID9cbiAgLy8gRklYTUU6IGlmIGluIGZ1dHVyZSBtZWV0IHRoZSBjYXNlIHRoYXQgc29tZSBwcm9wIHdpbGwgYmUgYm90aCBtb2RpZmllZCBpbiBgZHVyaW5nYCBhbmQgYHN0YXRlYCxcbiAgLy8gY29uc2lkZXIgdGhlIGlzc3VlIHRoYXQgdGhlIHByb3AgbWlnaHQgYmUgaW5jb3JyZWN0IHdoZW4gcmV0dXJuIHRvIFwibm9ybWFsXCIgc3RhdGUuXG5cbn1cblxuZnVuY3Rpb24gdXBkYXRlRWxPblN0YXRlKHN0YXRlLCBlbCwgZWxTdGF0ZU9wdCwgc3R5bGVPcHQsIGF0dGFjaGVkVHhJbmZvLCBpc1Jvb3QsIGlzVGV4dENvbnRlbnQpIHtcbiAgdmFyIGVsRGlzcGxheWFibGUgPSBlbC5pc0dyb3VwID8gbnVsbCA6IGVsO1xuICB2YXIgdHhDZmdPcHQgPSBhdHRhY2hlZFR4SW5mbyAmJiBhdHRhY2hlZFR4SW5mb1tzdGF0ZV0uY2ZnOyAvLyBQRU5ESU5HOjUuMCBzdXBwb3J0IGN1c3RvbWl6ZSBzY2FsZSBjaGFuZ2UgYW5kIHRyYW5zaXRpb24gYW5pbWF0aW9uP1xuXG4gIGlmIChlbERpc3BsYXlhYmxlKSB7XG4gICAgLy8gQnkgZGVmYXVsdCBzdXBwb3J0IGF1dG8gbGlmdCBjb2xvciB3aGVuIGhvdmVyIHdoZXRoZXIgYGVtcGhhc2lzYCBzcGVjaWZpZWQuXG4gICAgdmFyIHN0YXRlT2JqID0gZWxEaXNwbGF5YWJsZS5lbnN1cmVTdGF0ZShzdGF0ZSk7XG5cbiAgICBpZiAoc3R5bGVPcHQgPT09IGZhbHNlKSB7XG4gICAgICB2YXIgZXhpc3RpbmdFbXBoYXNpc1N0YXRlID0gZWxEaXNwbGF5YWJsZS5nZXRTdGF0ZShzdGF0ZSk7XG5cbiAgICAgIGlmIChleGlzdGluZ0VtcGhhc2lzU3RhdGUpIHtcbiAgICAgICAgZXhpc3RpbmdFbXBoYXNpc1N0YXRlLnN0eWxlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3R5bGUgaXMgbmVlZGVkIHRvIGVuYWJsZSBkZWZhdXQgZW1waGFzaXMuXG4gICAgICBzdGF0ZU9iai5zdHlsZSA9IHN0eWxlT3B0IHx8IG51bGw7XG4gICAgfSAvLyBJZiBgZWxPcHRpb24uc3R5bGVFbXBoYXNpc2Agb3IgYGVsT3B0aW9uLmVtcGhhc2lzLnN0eWxlYCBpcyBgZmFsc2VgLFxuICAgIC8vIHJlbW92ZSBob3ZlciBzdHlsZS5cbiAgICAvLyBJZiBgZWxPcHRpb24udGV4dENvbmZpZ2Agb3IgYGVsT3B0aW9uLmVtcGhhc2lzLnRleHRDb25maWdgIGlzIG51bGwvdW5kZWZpbmVkLCBpdCBkb2VzIG5vdFxuICAgIC8vIG1ha2Ugc2Vuc2UuIFNvIGZvciBzaW1wbGljaXR5LCB3ZSBkbyBub3QgZGl0aW5ndWlzaCBgaGFzT3duUHJvcGVydHlgIGFuZCBudWxsL3VuZGVmaW5lZC5cblxuXG4gICAgaWYgKHR4Q2ZnT3B0KSB7XG4gICAgICBzdGF0ZU9iai50ZXh0Q29uZmlnID0gdHhDZmdPcHQ7XG4gICAgfVxuXG4gICAgc2V0RGVmYXVsdFN0YXRlUHJveHkoZWxEaXNwbGF5YWJsZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlWihlbCwgZWxPcHRpb24sIHNlcmllc01vZGVsLCBhdHRhY2hlZFR4SW5mbykge1xuICAvLyBHcm91cCBub3Qgc3VwcG9ydCB0ZXh0Q29udGVudCBhbmQgbm90IHN1cHBvcnQgeiB5ZXQuXG4gIGlmIChlbC5pc0dyb3VwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVsRGlzcGxheWFibGUgPSBlbDtcbiAgdmFyIGN1cnJlbnRaID0gc2VyaWVzTW9kZWwuY3VycmVudFo7XG4gIHZhciBjdXJyZW50WkxldmVsID0gc2VyaWVzTW9kZWwuY3VycmVudFpMZXZlbDsgLy8gQWx3YXlzIGVyYXNlLlxuXG4gIGVsRGlzcGxheWFibGUueiA9IGN1cnJlbnRaO1xuICBlbERpc3BsYXlhYmxlLnpsZXZlbCA9IGN1cnJlbnRaTGV2ZWw7IC8vIHoyIG11c3Qgbm90IGJlIG51bGwvdW5kZWZpbmVkLCBvdGhlcndpc2Ugc29ydCBlcnJvciBtYXkgb2NjdXIuXG5cbiAgdmFyIG9wdFoyID0gZWxPcHRpb24uejI7XG4gIG9wdFoyICE9IG51bGwgJiYgKGVsRGlzcGxheWFibGUuejIgPSBvcHRaMiB8fCAwKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IFNUQVRFUy5sZW5ndGg7IGkrKykge1xuICAgIHVwZGF0ZVpGb3JFYWNoU3RhdGUoZWxEaXNwbGF5YWJsZSwgZWxPcHRpb24sIFNUQVRFU1tpXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlWkZvckVhY2hTdGF0ZShlbERpc3BsYXlhYmxlLCBlbE9wdGlvbiwgc3RhdGUpIHtcbiAgdmFyIGlzTm9ybWFsID0gc3RhdGUgPT09IE5PUk1BTDtcbiAgdmFyIGVsU3RhdGVPcHQgPSBpc05vcm1hbCA/IGVsT3B0aW9uIDogcmV0cmlldmVTdGF0ZU9wdGlvbihlbE9wdGlvbiwgc3RhdGUpO1xuICB2YXIgb3B0WjIgPSBlbFN0YXRlT3B0ID8gZWxTdGF0ZU9wdC56MiA6IG51bGw7XG4gIHZhciBzdGF0ZU9iajtcblxuICBpZiAob3B0WjIgIT0gbnVsbCkge1xuICAgIC8vIERvIG5vdCBgZW5zdXJlU3RhdGVgIHVudGlsIHJlcXVpcmVkLlxuICAgIHN0YXRlT2JqID0gaXNOb3JtYWwgPyBlbERpc3BsYXlhYmxlIDogZWxEaXNwbGF5YWJsZS5lbnN1cmVTdGF0ZShzdGF0ZSk7XG4gICAgc3RhdGVPYmouejIgPSBvcHRaMiB8fCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldExhZ2VjeVRyYW5zZm9ybVByb3AoZWxPcHRpb24sIHRhcmdldFByb3BzLCBsZWdhY3lOYW1lLCBmcm9tVHJhbnNmb3JtYWJsZSAvLyBJZiBwcm92aWRlZCwgcmV0cmlldmUgZnJvbSB0aGUgZWxlbWVudC5cbikge1xuICB2YXIgbGVnYWN5QXJyID0gZWxPcHRpb25bbGVnYWN5TmFtZV07XG4gIHZhciB4eU5hbWUgPSBMRUdBQ1lfVFJBTlNGT1JNX1BST1BTW2xlZ2FjeU5hbWVdO1xuXG4gIGlmIChsZWdhY3lBcnIpIHtcbiAgICBpZiAoZnJvbVRyYW5zZm9ybWFibGUpIHtcbiAgICAgIHRhcmdldFByb3BzW3h5TmFtZVswXV0gPSBmcm9tVHJhbnNmb3JtYWJsZVt4eU5hbWVbMF1dO1xuICAgICAgdGFyZ2V0UHJvcHNbeHlOYW1lWzFdXSA9IGZyb21UcmFuc2Zvcm1hYmxlW3h5TmFtZVsxXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFByb3BzW3h5TmFtZVswXV0gPSBsZWdhY3lBcnJbMF07XG4gICAgICB0YXJnZXRQcm9wc1t4eU5hbWVbMV1dID0gbGVnYWN5QXJyWzFdO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRUcmFuc2Zvcm1Qcm9wKGVsT3B0aW9uLCBhbGxQcm9wcywgbmFtZSwgZnJvbVRyYW5zZm9ybWFibGUgLy8gSWYgcHJvdmlkZWQsIHJldHJpZXZlIGZyb20gdGhlIGVsZW1lbnQuXG4pIHtcbiAgaWYgKGVsT3B0aW9uW25hbWVdICE9IG51bGwpIHtcbiAgICBhbGxQcm9wc1tuYW1lXSA9IGZyb21UcmFuc2Zvcm1hYmxlID8gZnJvbVRyYW5zZm9ybWFibGVbbmFtZV0gOiBlbE9wdGlvbltuYW1lXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRUcmFuc2Zvcm1Qcm9wVG9UcmFuc2l0aW9uRnJvbSh0cmFuc2l0aW9uRnJvbSwgbmFtZSwgZnJvbVRyYW5zZm9ybWFibGUgLy8gSWYgcHJvdmlkZWQsIHJldHJpZXZlIGZyb20gdGhlIGVsZW1lbnQuXG4pIHtcbiAgaWYgKGZyb21UcmFuc2Zvcm1hYmxlKSB7XG4gICAgdHJhbnNpdGlvbkZyb21bbmFtZV0gPSBmcm9tVHJhbnNmb3JtYWJsZVtuYW1lXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlUmVuZGVySXRlbShjdXN0b21TZXJpZXMsIGRhdGEsIGVjTW9kZWwsIGFwaSkge1xuICB2YXIgcmVuZGVySXRlbSA9IGN1c3RvbVNlcmllcy5nZXQoJ3JlbmRlckl0ZW0nKTtcbiAgdmFyIGNvb3JkU3lzID0gY3VzdG9tU2VyaWVzLmNvb3JkaW5hdGVTeXN0ZW07XG4gIHZhciBwcmVwYXJlUmVzdWx0ID0ge307XG5cbiAgaWYgKGNvb3JkU3lzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydChyZW5kZXJJdGVtLCAnc2VyaWVzLnJlbmRlciBpcyByZXF1aXJlZC4nKTtcbiAgICAgIGFzc2VydChjb29yZFN5cy5wcmVwYXJlQ3VzdG9tcyB8fCBwcmVwYXJlQ3VzdG9tc1tjb29yZFN5cy50eXBlXSwgJ1RoaXMgY29vcmRTeXMgZG9lcyBub3Qgc3VwcG9ydCBjdXN0b20gc2VyaWVzLicpO1xuICAgIH0gLy8gYGNvb3JkU3lzLnByZXBhcmVDdXN0b21zYCBpcyB1c2VkIGZvciBleHRlcm5hbCBjb29yZCBzeXMgbGlrZSBibWFwLlxuXG5cbiAgICBwcmVwYXJlUmVzdWx0ID0gY29vcmRTeXMucHJlcGFyZUN1c3RvbXMgPyBjb29yZFN5cy5wcmVwYXJlQ3VzdG9tcyhjb29yZFN5cykgOiBwcmVwYXJlQ3VzdG9tc1tjb29yZFN5cy50eXBlXShjb29yZFN5cyk7XG4gIH1cblxuICB2YXIgdXNlckFQSSA9IGRlZmF1bHRzKHtcbiAgICBnZXRXaWR0aDogYXBpLmdldFdpZHRoLFxuICAgIGdldEhlaWdodDogYXBpLmdldEhlaWdodCxcbiAgICBnZXRacjogYXBpLmdldFpyLFxuICAgIGdldERldmljZVBpeGVsUmF0aW86IGFwaS5nZXREZXZpY2VQaXhlbFJhdGlvLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgb3JkaW5hbFJhd1ZhbHVlOiBvcmRpbmFsUmF3VmFsdWUsXG4gICAgc3R5bGVFbXBoYXNpczogc3R5bGVFbXBoYXNpcyxcbiAgICB2aXN1YWw6IHZpc3VhbCxcbiAgICBiYXJMYXlvdXQ6IGJhckxheW91dCxcbiAgICBjdXJyZW50U2VyaWVzSW5kaWNlczogY3VycmVudFNlcmllc0luZGljZXMsXG4gICAgZm9udDogZm9udFxuICB9LCBwcmVwYXJlUmVzdWx0LmFwaSB8fCB7fSk7XG4gIHZhciB1c2VyUGFyYW1zID0ge1xuICAgIC8vIFRoZSBsaWZlIGN5Y2xlIG9mIGNvbnRleHQ6IGN1cnJlbnQgcm91bmQgb2YgcmVuZGVyaW5nLlxuICAgIC8vIFRoZSBnbG9iYWwgbGlmZSBjeWNsZSBpcyBwcm9iYWJseSBub3QgbmVjZXNzYXJ5LCBiZWNhdXNlXG4gICAgLy8gdXNlciBjYW4gc3RvcmUgZ2xvYmFsIHN0YXR1cyBieSB0aGVtc2VsdmVzLlxuICAgIGNvbnRleHQ6IHt9LFxuICAgIHNlcmllc0lkOiBjdXN0b21TZXJpZXMuaWQsXG4gICAgc2VyaWVzTmFtZTogY3VzdG9tU2VyaWVzLm5hbWUsXG4gICAgc2VyaWVzSW5kZXg6IGN1c3RvbVNlcmllcy5zZXJpZXNJbmRleCxcbiAgICBjb29yZFN5czogcHJlcGFyZVJlc3VsdC5jb29yZFN5cyxcbiAgICBkYXRhSW5zaWRlTGVuZ3RoOiBkYXRhLmNvdW50KCksXG4gICAgZW5jb2RlOiB3cmFwRW5jb2RlRGVmKGN1c3RvbVNlcmllcy5nZXREYXRhKCkpXG4gIH07IC8vIElmIHNvbWVkYXkgaW50ZW5kaW5nIHRvIHJlZmFjdG9yIHRoZW0gdG8gYSBjbGFzcywgc2hvdWxkIGNvbnNpZGVyIGRvIG5vdFxuICAvLyBicmVhayBjaGFuZ2U6IGN1cnJlbnRseSB0aGVzZSBhdHRyaWJ1dGUgbWVtYmVyIGFyZSBlbmNhcHN1bGF0ZWQgaW4gYSBjbG9zdXJlXG4gIC8vIHNvIHRoYXQgZG8gbm90IG5lZWQgdG8gZm9yY2UgdXNlciB0byBjYWxsIHRoZXNlIG1ldGhvZCB3aXRoIGEgc2NvcGUuXG4gIC8vIERvIG5vdCBzdXBwb3J0IGNhbGwgYGFwaWAgYXN5bmNocm9ub3VzbHkgd2l0aG91dCBkYXRhSW5kZXhJbnNpZGUgaW5wdXQuXG5cbiAgdmFyIGN1cnJEYXRhSW5kZXhJbnNpZGU7XG4gIHZhciBjdXJySXRlbU1vZGVsO1xuICB2YXIgY3Vyckl0ZW1TdHlsZU1vZGVscyA9IHt9O1xuICB2YXIgY3VyckxhYmVsTW9kZWxzID0ge307XG4gIHZhciBzZXJpZXNJdGVtU3R5bGVNb2RlbHMgPSB7fTtcbiAgdmFyIHNlcmllc0xhYmVsTW9kZWxzID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBTVEFURVMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RhdGVOYW1lID0gU1RBVEVTW2ldO1xuICAgIHNlcmllc0l0ZW1TdHlsZU1vZGVsc1tzdGF0ZU5hbWVdID0gY3VzdG9tU2VyaWVzLmdldE1vZGVsKFBBVEhfSVRFTV9TVFlMRVtzdGF0ZU5hbWVdKTtcbiAgICBzZXJpZXNMYWJlbE1vZGVsc1tzdGF0ZU5hbWVdID0gY3VzdG9tU2VyaWVzLmdldE1vZGVsKFBBVEhfTEFCRUxbc3RhdGVOYW1lXSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJdGVtTW9kZWwoZGF0YUluZGV4SW5zaWRlKSB7XG4gICAgcmV0dXJuIGRhdGFJbmRleEluc2lkZSA9PT0gY3VyckRhdGFJbmRleEluc2lkZSA/IGN1cnJJdGVtTW9kZWwgfHwgKGN1cnJJdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChkYXRhSW5kZXhJbnNpZGUpKSA6IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleEluc2lkZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJdGVtU3R5bGVNb2RlbChkYXRhSW5kZXhJbnNpZGUsIHN0YXRlKSB7XG4gICAgcmV0dXJuICFkYXRhLmhhc0l0ZW1PcHRpb24gPyBzZXJpZXNJdGVtU3R5bGVNb2RlbHNbc3RhdGVdIDogZGF0YUluZGV4SW5zaWRlID09PSBjdXJyRGF0YUluZGV4SW5zaWRlID8gY3Vyckl0ZW1TdHlsZU1vZGVsc1tzdGF0ZV0gfHwgKGN1cnJJdGVtU3R5bGVNb2RlbHNbc3RhdGVdID0gZ2V0SXRlbU1vZGVsKGRhdGFJbmRleEluc2lkZSkuZ2V0TW9kZWwoUEFUSF9JVEVNX1NUWUxFW3N0YXRlXSkpIDogZ2V0SXRlbU1vZGVsKGRhdGFJbmRleEluc2lkZSkuZ2V0TW9kZWwoUEFUSF9JVEVNX1NUWUxFW3N0YXRlXSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMYWJlbE1vZGVsKGRhdGFJbmRleEluc2lkZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gIWRhdGEuaGFzSXRlbU9wdGlvbiA/IHNlcmllc0xhYmVsTW9kZWxzW3N0YXRlXSA6IGRhdGFJbmRleEluc2lkZSA9PT0gY3VyckRhdGFJbmRleEluc2lkZSA/IGN1cnJMYWJlbE1vZGVsc1tzdGF0ZV0gfHwgKGN1cnJMYWJlbE1vZGVsc1tzdGF0ZV0gPSBnZXRJdGVtTW9kZWwoZGF0YUluZGV4SW5zaWRlKS5nZXRNb2RlbChQQVRIX0xBQkVMW3N0YXRlXSkpIDogZ2V0SXRlbU1vZGVsKGRhdGFJbmRleEluc2lkZSkuZ2V0TW9kZWwoUEFUSF9MQUJFTFtzdGF0ZV0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhSW5kZXhJbnNpZGUsIHBheWxvYWQpIHtcbiAgICBjdXJyRGF0YUluZGV4SW5zaWRlID0gZGF0YUluZGV4SW5zaWRlO1xuICAgIGN1cnJJdGVtTW9kZWwgPSBudWxsO1xuICAgIGN1cnJJdGVtU3R5bGVNb2RlbHMgPSB7fTtcbiAgICBjdXJyTGFiZWxNb2RlbHMgPSB7fTtcbiAgICByZXR1cm4gcmVuZGVySXRlbSAmJiByZW5kZXJJdGVtKGRlZmF1bHRzKHtcbiAgICAgIGRhdGFJbmRleEluc2lkZTogZGF0YUluZGV4SW5zaWRlLFxuICAgICAgZGF0YUluZGV4OiBkYXRhLmdldFJhd0luZGV4KGRhdGFJbmRleEluc2lkZSksXG4gICAgICAvLyBDYW4gYmUgdXNlZCBmb3Igb3B0aW1pemF0aW9uIHdoZW4gem9vbSBvciByb2FtLlxuICAgICAgYWN0aW9uVHlwZTogcGF5bG9hZCA/IHBheWxvYWQudHlwZSA6IG51bGxcbiAgICB9LCB1c2VyUGFyYW1zKSwgdXNlckFQSSk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSBkaW0gYnkgZGVmYXVsdCAwLlxuICAgKiBAcGFyYW0gZGF0YUluZGV4SW5zaWRlIGJ5IGRlZmF1bHQgYGN1cnJEYXRhSW5kZXhJbnNpZGVgLlxuICAgKi9cblxuICBmdW5jdGlvbiB2YWx1ZShkaW0sIGRhdGFJbmRleEluc2lkZSkge1xuICAgIGRhdGFJbmRleEluc2lkZSA9PSBudWxsICYmIChkYXRhSW5kZXhJbnNpZGUgPSBjdXJyRGF0YUluZGV4SW5zaWRlKTtcbiAgICByZXR1cm4gZGF0YS5nZXQoZGF0YS5nZXREaW1lbnNpb24oZGltIHx8IDApLCBkYXRhSW5kZXhJbnNpZGUpO1xuICB9XG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSBkaW0gYnkgZGVmYXVsdCAwLlxuICAgKiBAcGFyYW0gZGF0YUluZGV4SW5zaWRlIGJ5IGRlZmF1bHQgYGN1cnJEYXRhSW5kZXhJbnNpZGVgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG9yZGluYWxSYXdWYWx1ZShkaW0sIGRhdGFJbmRleEluc2lkZSkge1xuICAgIGRhdGFJbmRleEluc2lkZSA9PSBudWxsICYmIChkYXRhSW5kZXhJbnNpZGUgPSBjdXJyRGF0YUluZGV4SW5zaWRlKTtcbiAgICB2YXIgZGltSW5mbyA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW0gfHwgMCk7XG5cbiAgICBpZiAoIWRpbUluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdmFsID0gZGF0YS5nZXQoZGltSW5mby5uYW1lLCBkYXRhSW5kZXhJbnNpZGUpO1xuICAgIHZhciBvcmRpbmFsTWV0YSA9IGRpbUluZm8gJiYgZGltSW5mby5vcmRpbmFsTWV0YTtcbiAgICByZXR1cm4gb3JkaW5hbE1ldGEgPyBvcmRpbmFsTWV0YS5jYXRlZ29yaWVzW3ZhbF0gOiB2YWw7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBvcmdpbmluYWwgaW50ZW50aW9uIG9mIGBhcGkuc3R5bGVgIGlzIGVuYWJsZSB0byBzZXQgaXRlbVN0eWxlXG4gICAqIGxpa2Ugb3RoZXIgc2VyaWVzLiBCdXQgaXQgbm90IG5lY2Vzc2FyeSBhbmQgbm90IGVhc3kgdG8gZ2l2ZSBhIHN0cmljdCBkZWZpbml0aW9uXG4gICAqIG9mIHdoYXQgaXQgcmV0dXJuLiBBbmQgc2luY2UgZWNoYXJ0czUgaXQgbmVlZHMgdG8gYmUgbWFrZSBjb21wYXQgd29yay4gU29cbiAgICogZGVwcmVjYXRlcyBpdCBzaW5jZSBlY2hhcnRzNS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYHZpc3VhbGAgaXMgYXBwbGllZCB0byBzdHlsZSAodG8gc3VwcG9ydCB2aXN1YWxNYXApLlxuICAgKiBgdmlzdWFsLmNvbG9yYCBpcyBhcHBsaWVkIGF0IGBmaWxsYC4gSWYgdXNlciB3YW50IGFwcGx5IHZpc3VhbC5jb2xvciBvbiBgc3Ryb2tlYCxcbiAgICogaXQgY2FuIGJlIGltcGxlbWVudGVkIGFzOlxuICAgKiBgYXBpLnN0eWxlKHtzdHJva2U6IGFwaS52aXN1YWwoJ2NvbG9yJyksIGZpbGw6IG51bGx9KWA7XG4gICAqXG4gICAqIFtDb21wYXRdOiBzaW5jZSBlYzUsIFJlY3RUZXh0IGhhcyBiZWVuIHNlcGFyYXRlZCBmcm9tIGl0cyBob3N0cyBlbC5cbiAgICogc28gYGFwaS5zdHlsZSgpYCB3aWxsIG9ubHkgcmV0dXJuIHRoZSBzdHlsZSBmcm9tIGBpdGVtU3R5bGVgIGJ1dCBub3QgaGFuZGxlIGBsYWJlbGBcbiAgICogYW55IG1vcmUuIEJ1dCBgc2VyaWVzLmxhYmVsYCBjb25maWcgaXMgbmV2ZXIgcHVibGlzaGVkIGluIGRvYy5cbiAgICogV2Ugc3RpbGwgY29tcGF0IGl0IGluIGBhcGkuc3R5bGUoKWAuIEJ1dCBub3QgZW5jb3VyYWdlIHRvIHVzZSBpdCBhbmQgd2lsbCBzdGlsbCBub3RcbiAgICogdG8gcHVsaXNoIGl0IHRvIGRvYy5cbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gZGF0YUluZGV4SW5zaWRlIGJ5IGRlZmF1bHQgYGN1cnJEYXRhSW5kZXhJbnNpZGVgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN0eWxlKHVzZXJQcm9wcywgZGF0YUluZGV4SW5zaWRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5EZXByZWNhdGVkKCdhcGkuc3R5bGUnLCAnUGxlYXNlIHdyaXRlIGxpdGVyYWwgc3R5bGUgZGlyZWN0bHkgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICBkYXRhSW5kZXhJbnNpZGUgPT0gbnVsbCAmJiAoZGF0YUluZGV4SW5zaWRlID0gY3VyckRhdGFJbmRleEluc2lkZSk7XG4gICAgdmFyIHN0eWxlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleEluc2lkZSwgJ3N0eWxlJyk7XG4gICAgdmFyIHZpc3VhbENvbG9yID0gc3R5bGUgJiYgc3R5bGUuZmlsbDtcbiAgICB2YXIgb3BhY2l0eSA9IHN0eWxlICYmIHN0eWxlLm9wYWNpdHk7XG4gICAgdmFyIGl0ZW1TdHlsZSA9IGdldEl0ZW1TdHlsZU1vZGVsKGRhdGFJbmRleEluc2lkZSwgTk9STUFMKS5nZXRJdGVtU3R5bGUoKTtcbiAgICB2aXN1YWxDb2xvciAhPSBudWxsICYmIChpdGVtU3R5bGUuZmlsbCA9IHZpc3VhbENvbG9yKTtcbiAgICBvcGFjaXR5ICE9IG51bGwgJiYgKGl0ZW1TdHlsZS5vcGFjaXR5ID0gb3BhY2l0eSk7XG4gICAgdmFyIG9wdCA9IHtcbiAgICAgIGluaGVyaXRDb2xvcjogaXNTdHJpbmcodmlzdWFsQ29sb3IpID8gdmlzdWFsQ29sb3IgOiAnIzAwMCdcbiAgICB9O1xuICAgIHZhciBsYWJlbE1vZGVsID0gZ2V0TGFiZWxNb2RlbChkYXRhSW5kZXhJbnNpZGUsIE5PUk1BTCk7IC8vIE5vdyB0aGF0IHRoZSBmZXR1cmUgb2YgXCJhdXRvIGFkanVzdCB0ZXh0IGZpbGwvc3Ryb2tlXCIgaGFzIGJlZW4gbWlncmF0ZWQgdG8genJlbmRlclxuICAgIC8vIHNpbmNlIGVjNSwgd2Ugc2hvdWxkIHNldCBgaXNBdHRhY2hlZGAgYXMgYGZhbHNlYCBoZXJlIGFuZCBtYWtlIGNvbXBhdCBpblxuICAgIC8vIGBjb252ZXJ0VG9FQzRTdHlsZUZvckN1c3RvbVNlcmlzZWAuXG5cbiAgICB2YXIgdGV4dFN0eWxlID0gbGFiZWxTdHlsZUhlbHBlci5jcmVhdGVUZXh0U3R5bGUobGFiZWxNb2RlbCwgbnVsbCwgb3B0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgdGV4dFN0eWxlLnRleHQgPSBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKSA/IHJldHJpZXZlMihjdXN0b21TZXJpZXMuZ2V0Rm9ybWF0dGVkTGFiZWwoZGF0YUluZGV4SW5zaWRlLCBOT1JNQUwpLCBnZXREZWZhdWx0TGFiZWwoZGF0YSwgZGF0YUluZGV4SW5zaWRlKSkgOiBudWxsO1xuICAgIHZhciB0ZXh0Q29uZmlnID0gbGFiZWxTdHlsZUhlbHBlci5jcmVhdGVUZXh0Q29uZmlnKGxhYmVsTW9kZWwsIG9wdCwgZmFsc2UpO1xuICAgIHByZUZldGNoRnJvbUV4dHJhKHVzZXJQcm9wcywgaXRlbVN0eWxlKTtcbiAgICBpdGVtU3R5bGUgPSBjb252ZXJ0VG9FQzRTdHlsZUZvckN1c3RvbVNlcmlzZShpdGVtU3R5bGUsIHRleHRTdHlsZSwgdGV4dENvbmZpZyk7XG4gICAgdXNlclByb3BzICYmIGFwcGx5VXNlclByb3BzQWZ0ZXIoaXRlbVN0eWxlLCB1c2VyUHJvcHMpO1xuICAgIGl0ZW1TdHlsZS5sZWdhY3kgPSB0cnVlO1xuICAgIHJldHVybiBpdGVtU3R5bGU7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoZSByZWFzb24gc2VlIGBhcGkuc3R5bGUoKWBcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0gZGF0YUluZGV4SW5zaWRlIGJ5IGRlZmF1bHQgYGN1cnJEYXRhSW5kZXhJbnNpZGVgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN0eWxlRW1waGFzaXModXNlclByb3BzLCBkYXRhSW5kZXhJbnNpZGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybkRlcHJlY2F0ZWQoJ2FwaS5zdHlsZUVtcGhhc2lzJywgJ1BsZWFzZSB3cml0ZSBsaXRlcmFsIHN0eWxlIGRpcmVjdGx5IGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgZGF0YUluZGV4SW5zaWRlID09IG51bGwgJiYgKGRhdGFJbmRleEluc2lkZSA9IGN1cnJEYXRhSW5kZXhJbnNpZGUpO1xuICAgIHZhciBpdGVtU3R5bGUgPSBnZXRJdGVtU3R5bGVNb2RlbChkYXRhSW5kZXhJbnNpZGUsIEVNUEhBU0lTKS5nZXRJdGVtU3R5bGUoKTtcbiAgICB2YXIgbGFiZWxNb2RlbCA9IGdldExhYmVsTW9kZWwoZGF0YUluZGV4SW5zaWRlLCBFTVBIQVNJUyk7XG4gICAgdmFyIHRleHRTdHlsZSA9IGxhYmVsU3R5bGVIZWxwZXIuY3JlYXRlVGV4dFN0eWxlKGxhYmVsTW9kZWwsIG51bGwsIG51bGwsIHRydWUsIHRydWUpO1xuICAgIHRleHRTdHlsZS50ZXh0ID0gbGFiZWxNb2RlbC5nZXRTaGFsbG93KCdzaG93JykgPyByZXRyaWV2ZTMoY3VzdG9tU2VyaWVzLmdldEZvcm1hdHRlZExhYmVsKGRhdGFJbmRleEluc2lkZSwgRU1QSEFTSVMpLCBjdXN0b21TZXJpZXMuZ2V0Rm9ybWF0dGVkTGFiZWwoZGF0YUluZGV4SW5zaWRlLCBOT1JNQUwpLCBnZXREZWZhdWx0TGFiZWwoZGF0YSwgZGF0YUluZGV4SW5zaWRlKSkgOiBudWxsO1xuICAgIHZhciB0ZXh0Q29uZmlnID0gbGFiZWxTdHlsZUhlbHBlci5jcmVhdGVUZXh0Q29uZmlnKGxhYmVsTW9kZWwsIG51bGwsIHRydWUpO1xuICAgIHByZUZldGNoRnJvbUV4dHJhKHVzZXJQcm9wcywgaXRlbVN0eWxlKTtcbiAgICBpdGVtU3R5bGUgPSBjb252ZXJ0VG9FQzRTdHlsZUZvckN1c3RvbVNlcmlzZShpdGVtU3R5bGUsIHRleHRTdHlsZSwgdGV4dENvbmZpZyk7XG4gICAgdXNlclByb3BzICYmIGFwcGx5VXNlclByb3BzQWZ0ZXIoaXRlbVN0eWxlLCB1c2VyUHJvcHMpO1xuICAgIGl0ZW1TdHlsZS5sZWdhY3kgPSB0cnVlO1xuICAgIHJldHVybiBpdGVtU3R5bGU7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVVzZXJQcm9wc0FmdGVyKGl0ZW1TdHlsZSwgZXh0cmEpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZXh0cmEpIHtcbiAgICAgIGlmIChoYXNPd24oZXh0cmEsIGtleSkpIHtcbiAgICAgICAgaXRlbVN0eWxlW2tleV0gPSBleHRyYVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZUZldGNoRnJvbUV4dHJhKGV4dHJhLCBpdGVtU3R5bGUpIHtcbiAgICAvLyBBIHRyaWNrIHRvIHJldHJpZXZlIHRob3NlIHByb3BzIGZpcnN0bHksIHdoaWNoIGFyZSB1c2VkIHRvXG4gICAgLy8gYXBwbHkgYXV0byBpbnNpZGUgZmlsbC9zdHJva2UgaW4gYGNvbnZlcnRUb0VDNFN0eWxlRm9yQ3VzdG9tU2VyaXNlYC5cbiAgICAvLyAoSXQncyBub3QgcmVhc29uYWJsZSBidXQgb25seSBmb3IgYSBkZWdyZWUgb2YgY29tcGF0KVxuICAgIGlmIChleHRyYSkge1xuICAgICAgZXh0cmEudGV4dEZpbGwgJiYgKGl0ZW1TdHlsZS50ZXh0RmlsbCA9IGV4dHJhLnRleHRGaWxsKTtcbiAgICAgIGV4dHJhLnRleHRQb3NpdGlvbiAmJiAoaXRlbVN0eWxlLnRleHRQb3NpdGlvbiA9IGV4dHJhLnRleHRQb3NpdGlvbik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSBkYXRhSW5kZXhJbnNpZGUgYnkgZGVmYXVsdCBgY3VyckRhdGFJbmRleEluc2lkZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gdmlzdWFsKHZpc3VhbFR5cGUsIGRhdGFJbmRleEluc2lkZSkge1xuICAgIGRhdGFJbmRleEluc2lkZSA9PSBudWxsICYmIChkYXRhSW5kZXhJbnNpZGUgPSBjdXJyRGF0YUluZGV4SW5zaWRlKTtcblxuICAgIGlmIChoYXNPd24oU1RZTEVfVklTVUFMX1RZUEUsIHZpc3VhbFR5cGUpKSB7XG4gICAgICB2YXIgc3R5bGVfMSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXhJbnNpZGUsICdzdHlsZScpO1xuICAgICAgcmV0dXJuIHN0eWxlXzEgPyBzdHlsZV8xW1NUWUxFX1ZJU1VBTF9UWVBFW3Zpc3VhbFR5cGVdXSA6IG51bGw7XG4gICAgfSAvLyBPbmx5IHN1cHBvcnQgdGhlc2UgdmlzdWFscy4gT3RoZXIgdmlzdWFsIG1pZ2h0IGJlIGlubmVyIHRyaWNreVxuICAgIC8vIGZvciBwZXJmb3JtYW5jZSAobGlrZSBgc3R5bGVgKSwgZG8gbm90IGV4cG9zZSB0byB1c2Vycy5cblxuXG4gICAgaWYgKGhhc093bihOT05fU1RZTEVfVklTVUFMX1BST1BTLCB2aXN1YWxUeXBlKSkge1xuICAgICAgcmV0dXJuIGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXhJbnNpZGUsIHZpc3VhbFR5cGUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJuIElmIG5vdCBzdXBwb3J0LCByZXR1cm4gdW5kZWZpbmVkLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhckxheW91dChvcHQpIHtcbiAgICBpZiAoY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgIHJldHVybiBnZXRMYXlvdXRPbkF4aXMoZGVmYXVsdHMoe1xuICAgICAgICBheGlzOiBiYXNlQXhpc1xuICAgICAgfSwgb3B0KSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY3VycmVudFNlcmllc0luZGljZXMoKSB7XG4gICAgcmV0dXJuIGVjTW9kZWwuZ2V0Q3VycmVudFNlcmllc0luZGljZXMoKTtcbiAgfVxuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJuIGZvbnQgc3RyaW5nXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZm9udChvcHQpIHtcbiAgICByZXR1cm4gbGFiZWxTdHlsZUhlbHBlci5nZXRGb250KG9wdCwgZWNNb2RlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JhcEVuY29kZURlZihkYXRhKSB7XG4gIHZhciBlbmNvZGVEZWYgPSB7fTtcbiAgZWFjaChkYXRhLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkaW1OYW1lLCBkYXRhRGltSW5kZXgpIHtcbiAgICB2YXIgZGltSW5mbyA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1OYW1lKTtcblxuICAgIGlmICghZGltSW5mby5pc0V4dHJhQ29vcmQpIHtcbiAgICAgIHZhciBjb29yZERpbSA9IGRpbUluZm8uY29vcmREaW07XG4gICAgICB2YXIgZGF0YURpbXMgPSBlbmNvZGVEZWZbY29vcmREaW1dID0gZW5jb2RlRGVmW2Nvb3JkRGltXSB8fCBbXTtcbiAgICAgIGRhdGFEaW1zW2RpbUluZm8uY29vcmREaW1JbmRleF0gPSBkYXRhRGltSW5kZXg7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVuY29kZURlZjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVJdGVtKGFwaSwgZWwsIGRhdGFJbmRleCwgZWxPcHRpb24sIHNlcmllc01vZGVsLCBncm91cCwgZGF0YSwgbW9ycGhQcmVwYXJhdGlvbikge1xuICAvLyBbUnVsZV1cbiAgLy8gSWYgYHJlbmRlckl0ZW1gIHJldHVybnMgYG51bGxgL2B1bmRlZmluZWRgL2BmYWxzZWAsIHJlbW92ZSB0aGUgcHJldmlvdXMgZWwgaWYgZXhpc3RpbmcuXG4gIC8vICAgICAoSXQgc2VlbXMgdGhhdCB2aW9sYXRlIHRoZSBcIm1lcmdlXCIgcHJpbmNpcGxlLCBidXQgbW9zdCBvZiB1c2VycyBwcm9iYWJseSBpbnR1aXRpdmVseVxuICAvLyAgICAgcmVnYXJkIFwicmV0dXJuO1wiIGFzIFwic2hvdyBub3RoaW5nIGVsZW1lbnQgd2hhdGV2ZXJcIiwgc28gbWFrZSBhIGV4Y2VwdGlvbiB0byBtZWV0IHRoZVxuICAvLyAgICAgbW9zdCBjYXNlcy4pXG4gIC8vIFRoZSBydWxlIG9yIFwibWVyZ2VcIiBzZWUgW1NUUkFURUdZX01FUkdFXS5cbiAgLy8gSWYgYGVsT3B0aW9uYCBpcyBgbnVsbGAvYHVuZGVmaW5lZGAvYGZhbHNlYCAod2hlbiBgcmVuZGVySXRlbWAgcmV0dXJucyBub3RoaW5nKS5cbiAgaWYgKCFlbE9wdGlvbikge1xuICAgIHJlbW92ZUVsZW1lbnREaXJlY3RseShlbCwgZ3JvdXApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsID0gZG9DcmVhdGVPclVwZGF0ZUVsKGFwaSwgZWwsIGRhdGFJbmRleCwgZWxPcHRpb24sIHNlcmllc01vZGVsLCBncm91cCwgdHJ1ZSwgbW9ycGhQcmVwYXJhdGlvbik7XG4gIGVsICYmIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIGVsKTtcbiAgZW5hYmxlSG92ZXJFbXBoYXNpcyhlbCwgZWxPcHRpb24uZm9jdXMsIGVsT3B0aW9uLmJsdXJTY29wZSk7XG4gIHJldHVybiBlbDtcbn1cblxuZnVuY3Rpb24gZG9DcmVhdGVPclVwZGF0ZUVsKGFwaSwgZWwsIGRhdGFJbmRleCwgZWxPcHRpb24sIHNlcmllc01vZGVsLCBncm91cCwgaXNSb290LCBtb3JwaFByZXBhcmF0aW9uKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KGVsT3B0aW9uLCAnc2hvdWxkIG5vdCBoYXZlIGFuIG51bGwvdW5kZWZpbmVkIGVsZW1lbnQgc2V0dGluZycpO1xuICB9XG5cbiAgdmFyIHRvQmVSZXBsYWNlZElkeCA9IC0xO1xuXG4gIGlmIChlbCAmJiBkb2VzRWxOZWVkUmVjcmVhdGUoZWwsIGVsT3B0aW9uKSAvLyB8fCAoXG4gIC8vICAgICAvLyBQRU5ESU5HOiBldmVuIGluIG9uZS10by1vbmUgbWFwcGluZyBjYXNlLCBpZiBlbCBpcyBtYXJrZWQgYXMgbW9ycGgsXG4gIC8vICAgICAvLyBkbyBub3Qgc3VyZSB3aGV0aGVyIHRoZSBlbCB3aWxsIGJlIG1hcHBlZCB0byBhbm90aGVyIGVsIHdpdGggZGlmZmVyZW50XG4gIC8vICAgICAvLyBoaWVyYXJjaHkgaW4gR3JvdXAgdHJlZS4gU28gYWx3YXlzIHJlY3JlYXRlIGVsIHJhdGhlciB0aGFuIHJldXNlIHRoZSBlbC5cbiAgLy8gICAgIG1vcnBoUHJlcGFyYXRpb24gJiYgbW9ycGhQcmVwYXJhdGlvbi5pc09uZVRvT25lRnJvbShlbClcbiAgLy8gKVxuICApIHtcbiAgICAvLyBTaG91bGQga2VlcCBhdCB0aGUgb3JpZ2luYWwgaW5kZXgsIG90aGVyd2lzZSBcIm1lcmdlIGJ5IGluZGV4XCIgd2lsbCBiZSBpbmNvcnJlY3QuXG4gICAgdG9CZVJlcGxhY2VkSWR4ID0gZ3JvdXAuY2hpbGRyZW5SZWYoKS5pbmRleE9mKGVsKTtcbiAgICBlbCA9IG51bGw7XG4gIH1cblxuICB2YXIgZWxJc05ld0NyZWF0ZWQgPSAhZWw7XG5cbiAgaWYgKCFlbCkge1xuICAgIGVsID0gY3JlYXRlRWwoZWxPcHRpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIEZJTVhFOk5FWFQgdW5pZmllZCBjbGVhclN0YXRlP1xuICAgIC8vIElmIGluIHNvbWUgY2FzZSB0aGUgcGVyZm9ybWFuY2UgaXNzdWUgYXJpc2VkLCBjb25zaWRlclxuICAgIC8vIGRvIG5vdCBjbGVhclN0YXRlIGJ1dCB1cGRhdGUgY2FjaGVkIG5vcm1hbCBzdGF0ZSBkaXJlY3RseS5cbiAgICBlbC5jbGVhclN0YXRlcygpO1xuICB9XG5cbiAgdmFyIGNhbk1vcnBoID0gaW5uZXIoZWwpLmNhbk1vcnBoID0gZWxPcHRpb24ubW9ycGggJiYgaXNQYXRoKGVsKTtcbiAgdmFyIHRoaXNFbElzTW9ycGhUbyA9IGNhbk1vcnBoICYmIG1vcnBoUHJlcGFyYXRpb24gJiYgbW9ycGhQcmVwYXJhdGlvbi5oYXNGcm9tKCk7IC8vIFVzZSB1cGRhdGUgYW5pbWF0aW9uIHdoZW4gbW9ycGggaXMgZW5hYmxlZC5cblxuICB2YXIgaXNJbml0ID0gZWxJc05ld0NyZWF0ZWQgJiYgIXRoaXNFbElzTW9ycGhUbztcbiAgYXR0YWNoZWRUeEluZm9UbXAubm9ybWFsLmNmZyA9IGF0dGFjaGVkVHhJbmZvVG1wLm5vcm1hbC5jb25PcHQgPSBhdHRhY2hlZFR4SW5mb1RtcC5lbXBoYXNpcy5jZmcgPSBhdHRhY2hlZFR4SW5mb1RtcC5lbXBoYXNpcy5jb25PcHQgPSBhdHRhY2hlZFR4SW5mb1RtcC5ibHVyLmNmZyA9IGF0dGFjaGVkVHhJbmZvVG1wLmJsdXIuY29uT3B0ID0gYXR0YWNoZWRUeEluZm9UbXAuc2VsZWN0LmNmZyA9IGF0dGFjaGVkVHhJbmZvVG1wLnNlbGVjdC5jb25PcHQgPSBudWxsO1xuICBhdHRhY2hlZFR4SW5mb1RtcC5pc0xlZ2FjeSA9IGZhbHNlO1xuICBkb0NyZWF0ZU9yVXBkYXRlQXR0YWNoZWRUeChlbCwgZGF0YUluZGV4LCBlbE9wdGlvbiwgc2VyaWVzTW9kZWwsIGlzSW5pdCwgYXR0YWNoZWRUeEluZm9UbXApO1xuICBkb0NyZWF0ZU9yVXBkYXRlQ2xpcFBhdGgoZWwsIGRhdGFJbmRleCwgZWxPcHRpb24sIHNlcmllc01vZGVsLCBpc0luaXQpO1xuICB2YXIgcGVuZGluZ0FsbFByb3BzRmluYWwgPSB1cGRhdGVFbE5vcm1hbChhcGksIGVsLCB0aGlzRWxJc01vcnBoVG8sIGRhdGFJbmRleCwgZWxPcHRpb24sIGVsT3B0aW9uLnN0eWxlLCBhdHRhY2hlZFR4SW5mb1RtcCwgc2VyaWVzTW9kZWwsIGlzSW5pdCwgZmFsc2UpO1xuXG4gIGlmICh0aGlzRWxJc01vcnBoVG8pIHtcbiAgICBtb3JwaFByZXBhcmF0aW9uLmFkZFRvKGVsLCBlbE9wdGlvbiwgZGF0YUluZGV4LCBwZW5kaW5nQWxsUHJvcHNGaW5hbCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IFNUQVRFUy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGF0ZU5hbWUgPSBTVEFURVNbaV07XG5cbiAgICBpZiAoc3RhdGVOYW1lICE9PSBOT1JNQUwpIHtcbiAgICAgIHZhciBvdGhlclN0YXRlT3B0ID0gcmV0cmlldmVTdGF0ZU9wdGlvbihlbE9wdGlvbiwgc3RhdGVOYW1lKTtcbiAgICAgIHZhciBvdGhlclN0eWxlT3B0ID0gcmV0cmlldmVTdHlsZU9wdGlvbk9uU3RhdGUoZWxPcHRpb24sIG90aGVyU3RhdGVPcHQsIHN0YXRlTmFtZSk7XG4gICAgICB1cGRhdGVFbE9uU3RhdGUoc3RhdGVOYW1lLCBlbCwgb3RoZXJTdGF0ZU9wdCwgb3RoZXJTdHlsZU9wdCwgYXR0YWNoZWRUeEluZm9UbXAsIGlzUm9vdCwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVooZWwsIGVsT3B0aW9uLCBzZXJpZXNNb2RlbCwgYXR0YWNoZWRUeEluZm9UbXApO1xuXG4gIGlmIChlbE9wdGlvbi50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgbWVyZ2VDaGlsZHJlbihhcGksIGVsLCBkYXRhSW5kZXgsIGVsT3B0aW9uLCBzZXJpZXNNb2RlbCwgbW9ycGhQcmVwYXJhdGlvbik7XG4gIH1cblxuICBpZiAodG9CZVJlcGxhY2VkSWR4ID49IDApIHtcbiAgICBncm91cC5yZXBsYWNlQXQoZWwsIHRvQmVSZXBsYWNlZElkeCk7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAuYWRkKGVsKTtcbiAgfVxuXG4gIHJldHVybiBlbDtcbn0gLy8gYGVsYCBtdXN0IG5vdCBiZSBudWxsL3VuZGVmaW5lZC5cblxuXG5mdW5jdGlvbiBkb2VzRWxOZWVkUmVjcmVhdGUoZWwsIGVsT3B0aW9uKSB7XG4gIHZhciBlbElubmVyID0gaW5uZXIoZWwpO1xuICB2YXIgZWxPcHRpb25UeXBlID0gZWxPcHRpb24udHlwZTtcbiAgdmFyIGVsT3B0aW9uU2hhcGUgPSBlbE9wdGlvbi5zaGFwZTtcbiAgdmFyIGVsT3B0aW9uU3R5bGUgPSBlbE9wdGlvbi5zdHlsZTtcbiAgcmV0dXJuICgvLyBJZiBgZWxPcHRpb25UeXBlYCBpcyBgbnVsbGAsIGZvbGxvdyB0aGUgbWVyZ2UgcHJpbmNpcGxlLlxuICAgIGVsT3B0aW9uVHlwZSAhPSBudWxsICYmIGVsT3B0aW9uVHlwZSAhPT0gZWxJbm5lci5jdXN0b21HcmFwaGljVHlwZSB8fCBlbE9wdGlvblR5cGUgPT09ICdwYXRoJyAmJiBoYXNPd25QYXRoRGF0YShlbE9wdGlvblNoYXBlKSAmJiBnZXRQYXRoRGF0YShlbE9wdGlvblNoYXBlKSAhPT0gZWxJbm5lci5jdXN0b21QYXRoRGF0YSB8fCBlbE9wdGlvblR5cGUgPT09ICdpbWFnZScgJiYgaGFzT3duKGVsT3B0aW9uU3R5bGUsICdpbWFnZScpICYmIGVsT3B0aW9uU3R5bGUuaW1hZ2UgIT09IGVsSW5uZXIuY3VzdG9tSW1hZ2VQYXRoIC8vIC8vIEZJWE1FIHRlc3QgYW5kIHJlbW92ZSB0aGlzIHJlc3RyaWN0aW9uP1xuICAgIC8vIHx8IChlbE9wdGlvblR5cGUgPT09ICd0ZXh0J1xuICAgIC8vICAgICAmJiBoYXNPd24oZWxPcHRpb25TdHlsZSwgJ3RleHQnKVxuICAgIC8vICAgICAmJiAoZWxPcHRpb25TdHlsZSBhcyBUZXh0U3R5bGVQcm9wcykudGV4dCAhPT0gZWxJbm5lci5jdXN0b21UZXh0XG4gICAgLy8gKVxuXG4gICk7XG59XG5cbmZ1bmN0aW9uIGRvQ3JlYXRlT3JVcGRhdGVDbGlwUGF0aChlbCwgZGF0YUluZGV4LCBlbE9wdGlvbiwgc2VyaWVzTW9kZWwsIGlzSW5pdCkge1xuICAvLyBCYXNlZCBvbiB0aGUgXCJtZXJnZVwiIHByaW5jaXBsZSwgaWYgbm8gY2xpcFBhdGggcHJvdmlkZWQsXG4gIC8vIGRvIG5vdGhpbmcuIFRoZSBleGlzdHMgY2xpcCB3aWxsIGJlIHRvdGFsbHkgcmVtb3ZlZCBvbmx5IGlmXG4gIC8vIGBlbC5jbGlwUGF0aGAgaXMgYGZhbHNlYC4gT3RoZXJ3aXNlIGl0IHdpbGwgYmUgbWVyZ2VkL3JlcGxhY2VkLlxuICB2YXIgY2xpcFBhdGhPcHQgPSBlbE9wdGlvbi5jbGlwUGF0aDtcblxuICBpZiAoY2xpcFBhdGhPcHQgPT09IGZhbHNlKSB7XG4gICAgaWYgKGVsICYmIGVsLmdldENsaXBQYXRoKCkpIHtcbiAgICAgIGVsLnJlbW92ZUNsaXBQYXRoKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNsaXBQYXRoT3B0KSB7XG4gICAgdmFyIGNsaXBQYXRoID0gZWwuZ2V0Q2xpcFBhdGgoKTtcblxuICAgIGlmIChjbGlwUGF0aCAmJiBkb2VzRWxOZWVkUmVjcmVhdGUoY2xpcFBhdGgsIGNsaXBQYXRoT3B0KSkge1xuICAgICAgY2xpcFBhdGggPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghY2xpcFBhdGgpIHtcbiAgICAgIGNsaXBQYXRoID0gY3JlYXRlRWwoY2xpcFBhdGhPcHQpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhc3NlcnQoY2xpcFBhdGggaW5zdGFuY2VvZiBncmFwaGljVXRpbC5QYXRoLCAnT25seSBhbnkgdHlwZSBvZiBgcGF0aGAgY2FuIGJlIHVzZWQgaW4gYGNsaXBQYXRoYCwgcmF0aGVyIHRoYW4gJyArIGNsaXBQYXRoLnR5cGUgKyAnLicpO1xuICAgICAgfVxuXG4gICAgICBlbC5zZXRDbGlwUGF0aChjbGlwUGF0aCk7XG4gICAgfVxuXG4gICAgdXBkYXRlRWxOb3JtYWwobnVsbCwgY2xpcFBhdGgsIG51bGwsIGRhdGFJbmRleCwgY2xpcFBhdGhPcHQsIG51bGwsIG51bGwsIHNlcmllc01vZGVsLCBpc0luaXQsIGZhbHNlKTtcbiAgfSAvLyBJZiBub3QgZGVmaW5lIGBjbGlwUGF0aGAgaW4gb3B0aW9uLCBkbyBub3RoaW5nIHVubmVjZXNzYXJ5LlxuXG59XG5cbmZ1bmN0aW9uIGRvQ3JlYXRlT3JVcGRhdGVBdHRhY2hlZFR4KGVsLCBkYXRhSW5kZXgsIGVsT3B0aW9uLCBzZXJpZXNNb2RlbCwgaXNJbml0LCBhdHRhY2hlZFR4SW5mbykge1xuICAvLyBncm91cCBkbyBub3Qgc3VwcG9ydCB0ZXh0Q29udGVudCB0ZW1wb3JhcmlseSB1bnRpbGwgbmVjZXNzYXJ5LlxuICBpZiAoZWwuaXNHcm91cCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBOb3JtYWwgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGVtcGhhc2lzLCBmb3IgYGlzTGVnYWN5YCBkZXRlY3Rpb24uXG5cblxuICBwcm9jZXNzVHhJbmZvKGVsT3B0aW9uLCBudWxsLCBhdHRhY2hlZFR4SW5mbyk7XG4gIHByb2Nlc3NUeEluZm8oZWxPcHRpb24sIEVNUEhBU0lTLCBhdHRhY2hlZFR4SW5mbyk7IC8vIElmIGBlbE9wdGlvbi50ZXh0Q29uZmlnYCBvciBgZWxPcHRpb24udGV4dENvbnRlbnRgIGlzIG51bGwvdW5kZWZpbmVkLCBpdCBkb2VzIG5vdCBtYWtlIHNlbmNlLlxuICAvLyBTbyBmb3Igc2ltcGxpY2l0eSwgaWYgXCJlbE9wdGlvbiBoYXNPd25Qcm9wZXJ0eSBvZiB0aGVtIGJ1dCBiZSBudWxsL3VuZGVmaW5lZFwiLCB3ZSBkbyBub3RcbiAgLy8gdHJhZGUgdGhlbSBhcyBzZXQgdG8gbnVsbCB0byBlbC5cbiAgLy8gRXNwZWNpYWxseTpcbiAgLy8gYGVsT3B0aW9uLnRleHRDb250ZW50OiBmYWxzZWAgbWVhbnMgcmVtb3ZlIHRleHRDb250ZW50LlxuICAvLyBgZWxPcHRpb24udGV4dENvbnRlbnQuZW1waGFzaXMuc3R5bGU6IGZhbHNlYCBtZWFucyByZW1vdmUgdGhlIHN0eWxlIGZyb20gZW1waGFzaXMgc3RhdGUuXG5cbiAgdmFyIHR4Q29uT3B0Tm9ybWFsID0gYXR0YWNoZWRUeEluZm8ubm9ybWFsLmNvbk9wdDtcbiAgdmFyIHR4Q29uT3B0RW1waGFzaXMgPSBhdHRhY2hlZFR4SW5mby5lbXBoYXNpcy5jb25PcHQ7XG4gIHZhciB0eENvbk9wdEJsdXIgPSBhdHRhY2hlZFR4SW5mby5ibHVyLmNvbk9wdDtcbiAgdmFyIHR4Q29uT3B0U2VsZWN0ID0gYXR0YWNoZWRUeEluZm8uc2VsZWN0LmNvbk9wdDtcblxuICBpZiAodHhDb25PcHROb3JtYWwgIT0gbnVsbCB8fCB0eENvbk9wdEVtcGhhc2lzICE9IG51bGwgfHwgdHhDb25PcHRTZWxlY3QgIT0gbnVsbCB8fCB0eENvbk9wdEJsdXIgIT0gbnVsbCkge1xuICAgIHZhciB0ZXh0Q29udGVudCA9IGVsLmdldFRleHRDb250ZW50KCk7XG5cbiAgICBpZiAodHhDb25PcHROb3JtYWwgPT09IGZhbHNlKSB7XG4gICAgICB0ZXh0Q29udGVudCAmJiBlbC5yZW1vdmVUZXh0Q29udGVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eENvbk9wdE5vcm1hbCA9IGF0dGFjaGVkVHhJbmZvLm5vcm1hbC5jb25PcHQgPSB0eENvbk9wdE5vcm1hbCB8fCB7XG4gICAgICAgIHR5cGU6ICd0ZXh0J1xuICAgICAgfTtcblxuICAgICAgaWYgKCF0ZXh0Q29udGVudCkge1xuICAgICAgICB0ZXh0Q29udGVudCA9IGNyZWF0ZUVsKHR4Q29uT3B0Tm9ybWFsKTtcbiAgICAgICAgZWwuc2V0VGV4dENvbnRlbnQodGV4dENvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgaW4gc29tZSBjYXNlIHRoZSBwZXJmb3JtYW5jZSBpc3N1ZSBhcmlzZWQsIGNvbnNpZGVyXG4gICAgICAgIC8vIGRvIG5vdCBjbGVhclN0YXRlIGJ1dCB1cGRhdGUgY2FjaGVkIG5vcm1hbCBzdGF0ZSBkaXJlY3RseS5cbiAgICAgICAgdGV4dENvbnRlbnQuY2xlYXJTdGF0ZXMoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR4Q29uU3RsT3B0Tm9ybWFsID0gdHhDb25PcHROb3JtYWwgJiYgdHhDb25PcHROb3JtYWwuc3R5bGU7XG4gICAgICB1cGRhdGVFbE5vcm1hbChudWxsLCB0ZXh0Q29udGVudCwgbnVsbCwgZGF0YUluZGV4LCB0eENvbk9wdE5vcm1hbCwgdHhDb25TdGxPcHROb3JtYWwsIG51bGwsIHNlcmllc01vZGVsLCBpc0luaXQsIHRydWUpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNUQVRFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3RhdGVOYW1lID0gU1RBVEVTW2ldO1xuXG4gICAgICAgIGlmIChzdGF0ZU5hbWUgIT09IE5PUk1BTCkge1xuICAgICAgICAgIHZhciB0eENvbk9wdE90aGVyU3RhdGUgPSBhdHRhY2hlZFR4SW5mb1tzdGF0ZU5hbWVdLmNvbk9wdDtcbiAgICAgICAgICB1cGRhdGVFbE9uU3RhdGUoc3RhdGVOYW1lLCB0ZXh0Q29udGVudCwgdHhDb25PcHRPdGhlclN0YXRlLCByZXRyaWV2ZVN0eWxlT3B0aW9uT25TdGF0ZSh0eENvbk9wdE5vcm1hbCwgdHhDb25PcHRPdGhlclN0YXRlLCBzdGF0ZU5hbWUpLCBudWxsLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHhDb25TdGxPcHROb3JtYWwgPyB0ZXh0Q29udGVudC5kaXJ0eSgpIDogdGV4dENvbnRlbnQubWFya1JlZHJhdygpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzVHhJbmZvKGVsT3B0aW9uLCBzdGF0ZSwgYXR0YWNoZWRUeEluZm8pIHtcbiAgdmFyIHN0YXRlT3B0ID0gIXN0YXRlID8gZWxPcHRpb24gOiByZXRyaWV2ZVN0YXRlT3B0aW9uKGVsT3B0aW9uLCBzdGF0ZSk7XG4gIHZhciBzdHlsZU9wdCA9ICFzdGF0ZSA/IGVsT3B0aW9uLnN0eWxlIDogcmV0cmlldmVTdHlsZU9wdGlvbk9uU3RhdGUoZWxPcHRpb24sIHN0YXRlT3B0LCBFTVBIQVNJUyk7XG4gIHZhciBlbFR5cGUgPSBlbE9wdGlvbi50eXBlO1xuICB2YXIgdHhDZmcgPSBzdGF0ZU9wdCA/IHN0YXRlT3B0LnRleHRDb25maWcgOiBudWxsO1xuICB2YXIgdHhDb25PcHROb3JtYWwgPSBlbE9wdGlvbi50ZXh0Q29udGVudDtcbiAgdmFyIHR4Q29uT3B0ID0gIXR4Q29uT3B0Tm9ybWFsID8gbnVsbCA6ICFzdGF0ZSA/IHR4Q29uT3B0Tm9ybWFsIDogcmV0cmlldmVTdGF0ZU9wdGlvbih0eENvbk9wdE5vcm1hbCwgc3RhdGUpO1xuXG4gIGlmIChzdHlsZU9wdCAmJiAoIC8vIEJlY2F1c2UgZW1waGFzaXMgc3R5bGUgaGFzIGxpdHRsZSBpbmZvIHRvIGRldGVjdCBsZWdhY3ksXG4gIC8vIGlmIG5vcm1hbCBpcyBsZWdhY3ksIGVtcGhhc2lzIGlzIHRyYWRlIGFzIGxlZ2FjeS5cbiAgYXR0YWNoZWRUeEluZm8uaXNMZWdhY3kgfHwgaXNFQzRDb21wYXRpYmxlU3R5bGUoc3R5bGVPcHQsIGVsVHlwZSwgISF0eENmZywgISF0eENvbk9wdCkpKSB7XG4gICAgYXR0YWNoZWRUeEluZm8uaXNMZWdhY3kgPSB0cnVlO1xuICAgIHZhciBjb252ZXJ0UmVzdWx0ID0gY29udmVydEZyb21FQzRDb21wYXRpYmxlU3R5bGUoc3R5bGVPcHQsIGVsVHlwZSwgIXN0YXRlKTsgLy8gRXhwbGljaXRseSBzcGVjaWZpZWQgYHRleHRDb25maWdgIGFuZCBgdGV4dENvbnRlbnRgIGhhcyBoaWdoZXIgcHJpb3JpdHkgdGhhblxuICAgIC8vIHRoZSBvbmVzIGdlbmVyYXRlZCBieSBsZWdhY3kgc3R5bGUuIE90aGVyd2lzZSBpZiB1c2VycyB1c2UgdGhlbSBhbmQgYGFwaS5zdHlsZWBcbiAgICAvLyBhdCB0aGUgc2FtZSB0aW1lLCB0aGV5IG5vdCBib3RoIHdvcmsgYW5kIGhhcmRseSB0byBrbm93biB3aHkuXG5cbiAgICBpZiAoIXR4Q2ZnICYmIGNvbnZlcnRSZXN1bHQudGV4dENvbmZpZykge1xuICAgICAgdHhDZmcgPSBjb252ZXJ0UmVzdWx0LnRleHRDb25maWc7XG4gICAgfVxuXG4gICAgaWYgKCF0eENvbk9wdCAmJiBjb252ZXJ0UmVzdWx0LnRleHRDb250ZW50KSB7XG4gICAgICB0eENvbk9wdCA9IGNvbnZlcnRSZXN1bHQudGV4dENvbnRlbnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzdGF0ZSAmJiB0eENvbk9wdCkge1xuICAgIHZhciB0eENvbk9wdE5vcm1hbF8xID0gdHhDb25PcHQ7IC8vIGB0ZXh0Q29udGVudDoge3R5cGU6ICd0ZXh0J31gLCB0aGUgXCJ0eXBlXCIgaXMgZWFzeSB0byBiZSBtaXNzaW5nLiBTbyB3ZSB0b2xlcmF0ZSBpdC5cblxuICAgICF0eENvbk9wdE5vcm1hbF8xLnR5cGUgJiYgKHR4Q29uT3B0Tm9ybWFsXzEudHlwZSA9ICd0ZXh0Jyk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gRG8gbm90IHRvbGVyYXRlIGluY29ycmV0IHR5cGUgZm9yIGZvcndhcmQgY29tcGF0LlxuICAgICAgdHhDb25PcHROb3JtYWxfMS50eXBlICE9PSAndGV4dCcgJiYgYXNzZXJ0KHR4Q29uT3B0Tm9ybWFsXzEudHlwZSA9PT0gJ3RleHQnLCAndGV4dENvbnRlbnQudHlwZSBtdXN0IGJlIFwidGV4dFwiJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluZm8gPSAhc3RhdGUgPyBhdHRhY2hlZFR4SW5mby5ub3JtYWwgOiBhdHRhY2hlZFR4SW5mb1tzdGF0ZV07XG4gIGluZm8uY2ZnID0gdHhDZmc7XG4gIGluZm8uY29uT3B0ID0gdHhDb25PcHQ7XG59XG5cbmZ1bmN0aW9uIHJldHJpZXZlU3RhdGVPcHRpb24oZWxPcHRpb24sIHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUgPyBlbE9wdGlvbiA6IGVsT3B0aW9uID8gZWxPcHRpb25bc3RhdGVdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gcmV0cmlldmVTdHlsZU9wdGlvbk9uU3RhdGUoc3RhdGVPcHRpb25Ob3JtYWwsIHN0YXRlT3B0aW9uLCBzdGF0ZSkge1xuICB2YXIgc3R5bGUgPSBzdGF0ZU9wdGlvbiAmJiBzdGF0ZU9wdGlvbi5zdHlsZTtcblxuICBpZiAoc3R5bGUgPT0gbnVsbCAmJiBzdGF0ZSA9PT0gRU1QSEFTSVMgJiYgc3RhdGVPcHRpb25Ob3JtYWwpIHtcbiAgICBzdHlsZSA9IHN0YXRlT3B0aW9uTm9ybWFsLnN0eWxlRW1waGFzaXM7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59IC8vIFVzYWdlOlxuLy8gKDEpIEJ5IGRlZmF1bHQsIGBlbE9wdGlvbi4kbWVyZ2VDaGlsZHJlbmAgaXMgYCdieUluZGV4J2AsIHdoaWNoIGluZGljYXRlcyB0aGF0XG4vLyAgICAgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHdpbGwgbm90IGJlIHJlbW92ZWQsIGFuZCBlbmFibGVzIHRoZSBmZWF0dXJlIHRoYXRcbi8vICAgICB1cGRhdGUgc29tZSBvZiB0aGUgcHJvcHMgb2Ygc29tZSBvZiB0aGUgY2hpbGRyZW4gc2ltcGx5IGJ5IGNvbnN0cnVjdFxuLy8gICAgIHRoZSByZXR1cm5lZCBjaGlsZHJlbiBvZiBgcmVuZGVySXRlbWAgbGlrZTpcbi8vICAgICBgdmFyIGNoaWxkcmVuID0gZ3JvdXAuY2hpbGRyZW4gPSBbXTsgY2hpbGRyZW5bM10gPSB7b3BhY2l0eTogMC41fTtgXG4vLyAoMikgSWYgYGVsT3B0aW9uLiRtZXJnZUNoaWxkcmVuYCBpcyBgJ2J5TmFtZSdgLCBhZGQvdXBkYXRlL3JlbW92ZSBjaGlsZHJlblxuLy8gICAgIGJ5IGNoaWxkLm5hbWUuIEJ1dCB0aGF0IG1pZ2h0IGJlIGxvd2VyIHBlcmZvcm1hbmNlLlxuLy8gKDMpIElmIGBlbE9wdGlvbi4kbWVyZ2VDaGlsZHJlbmAgaXMgYGZhbHNlYCwgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHdpbGwgYmVcbi8vICAgICByZXBsYWNlZCB0b3RhbGx5LlxuLy8gKDQpIElmIGAhZWxPcHRpb24uY2hpbGRyZW5gLCBmb2xsb3dpbmcgdGhlIFwibWVyZ2VcIiBwcmluY2lwbGUsIG5vdGhpbmcgd2lsbCBoYXBwZW4uXG4vL1xuLy8gRm9yIGltcGxlbWVudGF0aW9uIHNpbXBsZW5lc3MsIGRvIG5vdCBwcm92aWRlIGEgZGlyZWN0IHdheSB0byByZW1vdmUgc2lubGdlXG4vLyBjaGlsZCAob3RoZXJ3aXNlIHRoZSB0b3RhbCBpbmRpY2llcyBvZiB0aGUgY2hpbGRyZW4gYXJyYXkgaGF2ZSB0byBiZSBtb2RpZmllZCkuXG4vLyBVc2VyIGNhbiByZW1vdmUgYSBzaW5nbGUgY2hpbGQgYnkgc2V0IGl0cyBgaWdub3JlYCBhcyBgdHJ1ZWAuXG5cblxuZnVuY3Rpb24gbWVyZ2VDaGlsZHJlbihhcGksIGVsLCBkYXRhSW5kZXgsIGVsT3B0aW9uLCBzZXJpZXNNb2RlbCwgbW9ycGhQcmVwYXJhdGlvbikge1xuICB2YXIgbmV3Q2hpbGRyZW4gPSBlbE9wdGlvbi5jaGlsZHJlbjtcbiAgdmFyIG5ld0xlbiA9IG5ld0NoaWxkcmVuID8gbmV3Q2hpbGRyZW4ubGVuZ3RoIDogMDtcbiAgdmFyIG1lcmdlQ2hpbGRyZW4gPSBlbE9wdGlvbi4kbWVyZ2VDaGlsZHJlbjsgLy8gYGRpZmZDaGlsZHJlbkJ5TmFtZWAgaGFzIGJlZW4gZGVwcmVjYXRlZC5cblxuICB2YXIgYnlOYW1lID0gbWVyZ2VDaGlsZHJlbiA9PT0gJ2J5TmFtZScgfHwgZWxPcHRpb24uZGlmZkNoaWxkcmVuQnlOYW1lO1xuICB2YXIgbm90TWVyZ2UgPSBtZXJnZUNoaWxkcmVuID09PSBmYWxzZTsgLy8gRm9yIGJldHRlciBwZXJmb3JtYW5jZSBvbiByb2FtIHVwZGF0ZSwgb25seSBlbnRlciBpZiBuZWNlc3NhcnkuXG5cbiAgaWYgKCFuZXdMZW4gJiYgIWJ5TmFtZSAmJiAhbm90TWVyZ2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoYnlOYW1lKSB7XG4gICAgZGlmZkdyb3VwQ2hpbGRyZW4oe1xuICAgICAgYXBpOiBhcGksXG4gICAgICBvbGRDaGlsZHJlbjogZWwuY2hpbGRyZW4oKSB8fCBbXSxcbiAgICAgIG5ld0NoaWxkcmVuOiBuZXdDaGlsZHJlbiB8fCBbXSxcbiAgICAgIGRhdGFJbmRleDogZGF0YUluZGV4LFxuICAgICAgc2VyaWVzTW9kZWw6IHNlcmllc01vZGVsLFxuICAgICAgZ3JvdXA6IGVsLFxuICAgICAgbW9ycGhQcmVwYXJhdGlvbjogbW9ycGhQcmVwYXJhdGlvblxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG5vdE1lcmdlICYmIGVsLnJlbW92ZUFsbCgpOyAvLyBNYXBwaW5nIGNoaWxkcmVuIG9mIGEgZ3JvdXAgc2ltcGx5IGJ5IGluZGV4LCB3aGljaFxuICAvLyBtaWdodCBiZSBiZXR0ZXIgcGVyZm9ybWFuY2UuXG5cbiAgdmFyIGluZGV4ID0gMDtcblxuICBmb3IgKDsgaW5kZXggPCBuZXdMZW47IGluZGV4KyspIHtcbiAgICBuZXdDaGlsZHJlbltpbmRleF0gJiYgZG9DcmVhdGVPclVwZGF0ZUVsKGFwaSwgZWwuY2hpbGRBdChpbmRleCksIGRhdGFJbmRleCwgbmV3Q2hpbGRyZW5baW5kZXhdLCBzZXJpZXNNb2RlbCwgZWwsIGZhbHNlLCBtb3JwaFByZXBhcmF0aW9uKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBlbC5jaGlsZENvdW50KCkgLSAxOyBpID49IGluZGV4OyBpLS0pIHtcbiAgICAvLyBEbyBub3Qgc3VwcHJvdCBsZWF2ZSBlbGVtZW50cyB0aGF0IGFyZSBub3QgbWVudGlvbmVkIGluIHRoZSBsYXRlc3RcbiAgICAvLyBgcmVuZGVySXRlbWAgcmV0dXJuLiBPdGhlcndpc2UgdXNlcnMgbWF5IG5vdCBoYXZlIGEgY2xlYXIgYW5kIHNpbXBsZVxuICAgIC8vIGNvbmNlcHQgdGhhdCBob3cgdG8gY29udG9ybCBhbGwgb2YgdGhlIGVsZW1lbnRzLlxuICAgIGRvUmVtb3ZlRWwoZWwuY2hpbGRBdChpKSwgc2VyaWVzTW9kZWwsIGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWZmR3JvdXBDaGlsZHJlbihjb250ZXh0KSB7XG4gIG5ldyBEYXRhRGlmZmVyKGNvbnRleHQub2xkQ2hpbGRyZW4sIGNvbnRleHQubmV3Q2hpbGRyZW4sIGdldEtleSwgZ2V0S2V5LCBjb250ZXh0KS5hZGQocHJvY2Vzc0FkZFVwZGF0ZSkudXBkYXRlKHByb2Nlc3NBZGRVcGRhdGUpLnJlbW92ZShwcm9jZXNzUmVtb3ZlKS5leGVjdXRlKCk7XG59XG5cbmZ1bmN0aW9uIGdldEtleShpdGVtLCBpZHgpIHtcbiAgdmFyIG5hbWUgPSBpdGVtICYmIGl0ZW0ubmFtZTtcbiAgcmV0dXJuIG5hbWUgIT0gbnVsbCA/IG5hbWUgOiBHUk9VUF9ESUZGX1BSRUZJWCArIGlkeDtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0FkZFVwZGF0ZShuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gIHZhciBjaGlsZE9wdGlvbiA9IG5ld0luZGV4ICE9IG51bGwgPyBjb250ZXh0Lm5ld0NoaWxkcmVuW25ld0luZGV4XSA6IG51bGw7XG4gIHZhciBjaGlsZCA9IG9sZEluZGV4ICE9IG51bGwgPyBjb250ZXh0Lm9sZENoaWxkcmVuW29sZEluZGV4XSA6IG51bGw7XG4gIGRvQ3JlYXRlT3JVcGRhdGVFbChjb250ZXh0LmFwaSwgY2hpbGQsIGNvbnRleHQuZGF0YUluZGV4LCBjaGlsZE9wdGlvbiwgY29udGV4dC5zZXJpZXNNb2RlbCwgY29udGV4dC5ncm91cCwgZmFsc2UsIGNvbnRleHQubW9ycGhQcmVwYXJhdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZW1vdmUob2xkSW5kZXgpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gIHZhciBjaGlsZCA9IGNvbnRleHQub2xkQ2hpbGRyZW5bb2xkSW5kZXhdO1xuICBkb1JlbW92ZUVsKGNoaWxkLCBjb250ZXh0LnNlcmllc01vZGVsLCBjb250ZXh0Lmdyb3VwKTtcbn1cblxuZnVuY3Rpb24gZG9SZW1vdmVFbChlbCwgc2VyaWVzTW9kZWwsIGdyb3VwKSB7XG4gIGlmIChlbCkge1xuICAgIHZhciBsZWF2ZVRvUHJvcHMgPSBpbm5lcihlbCkubGVhdmVUb1Byb3BzO1xuICAgIGxlYXZlVG9Qcm9wcyA/IGdyYXBoaWNVdGlsLnVwZGF0ZVByb3BzKGVsLCBsZWF2ZVRvUHJvcHMsIHNlcmllc01vZGVsLCB7XG4gICAgICBjYjogZnVuY3Rpb24gKCkge1xuICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgfVxuICAgIH0pIDogZ3JvdXAucmVtb3ZlKGVsKTtcbiAgfVxufVxuLyoqXG4gKiBAcmV0dXJuIFNWRyBQYXRoIGRhdGEuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRQYXRoRGF0YShzaGFwZSkge1xuICAvLyBcImRcIiBmb2xsb3dzIHRoZSBTVkcgY29udmVudGlvbi5cbiAgcmV0dXJuIHNoYXBlICYmIChzaGFwZS5wYXRoRGF0YSB8fCBzaGFwZS5kKTtcbn1cblxuZnVuY3Rpb24gaGFzT3duUGF0aERhdGEoc2hhcGUpIHtcbiAgcmV0dXJuIHNoYXBlICYmIChoYXNPd24oc2hhcGUsICdwYXRoRGF0YScpIHx8IGhhc093bihzaGFwZSwgJ2QnKSk7XG59XG5cbmZ1bmN0aW9uIGlzUGF0aChlbCkge1xuICByZXR1cm4gZWwgJiYgZWwgaW5zdGFuY2VvZiBncmFwaGljVXRpbC5QYXRoO1xufVxuXG5mdW5jdGlvbiByZW1vdmVFbGVtZW50RGlyZWN0bHkoZWwsIGdyb3VwKSB7XG4gIGVsICYmIGdyb3VwLnJlbW92ZShlbCk7XG59XG4vKipcbiAqIEFueSBtb3JwaC1wb3RlbnRpYWwgZWwgc2hvdWxkIGFkZGVkIGJ5IGBtb3JwaFByZXBhcmF0aW9uLmFkZFRvKGVsKWAuXG4gKiBBbmQgdGhleSBtYXkgYXBwbHkgbW9ycGggb3Igbm90IHdoZW4gYG1vcnBoUHJlcGFyYXRpb24uYXBwbHlNb3JwaGluZygpYC5cbiAqIEJ1dCBhdCBsZWFzdCwgYWxsIG9mIHRoZSBcInRvXCIgZWxlbWVudHMgd2lsbCBhcHBseSBhbGwgb2YgdGhlIHVwZGF0ZXNcbiAqIGFzIGBkb0NyZWF0ZU9yVXBkYXRlSXRlbWAgZGlkLlxuICovXG5cblxudmFyIE1vcnBoUHJlcGFyYXRpb24gPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNb3JwaFByZXBhcmF0aW9uKHNlcmllc01vZGVsLCB0cmFuc09wdCkge1xuICAgIHRoaXMuX2Zyb21MaXN0ID0gW107XG4gICAgdGhpcy5fdG9MaXN0ID0gW107XG4gICAgdGhpcy5fdG9FbE9wdGlvbkxpc3QgPSBbXTtcbiAgICB0aGlzLl9hbGxQcm9wc0ZpbmFsTGlzdCA9IFtdO1xuICAgIHRoaXMuX3RvRGF0YUluZGljZXMgPSBbXTsgLy8gS2V5OiBgdG9EYXRhSW5kZXhgLCBub3QgYHRvSWR4YFxuXG4gICAgdGhpcy5fbW9ycGhDb25maWdMaXN0ID0gW107XG4gICAgdGhpcy5fc2VyaWVzTW9kZWwgPSBzZXJpZXNNb2RlbDtcbiAgICB0aGlzLl90cmFuc09wdCA9IHRyYW5zT3B0O1xuICB9XG5cbiAgTW9ycGhQcmVwYXJhdGlvbi5wcm90b3R5cGUuaGFzRnJvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9mcm9tTGlzdC5sZW5ndGg7XG4gIH07IC8vIGlzT25lVG9PbmVGcm9tKGVsOiBFbGVtZW50KTogYm9vbGVhbiB7XG4gIC8vICAgICBpZiAoZWwgJiYgaW5uZXIoZWwpLmNhbk1vcnBoKSB7XG4gIC8vICAgICAgICAgY29uc3QgZnJvbUxpc3QgPSB0aGlzLl9mcm9tTGlzdDtcbiAgLy8gICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyb21MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gIC8vICAgICAgICAgICAgIGlmIChmcm9tTGlzdFtpXSA9PT0gZWwpIHtcbiAgLy8gICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAvLyAgICAgICAgICAgICB9XG4gIC8vICAgICAgICAgfVxuICAvLyAgICAgfVxuICAvLyB9XG5cblxuICBNb3JwaFByZXBhcmF0aW9uLnByb3RvdHlwZS5maW5kQW5kQWRkRnJvbSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICghZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5uZXIoZWwpLmNhbk1vcnBoKSB7XG4gICAgICB0aGlzLl9mcm9tTGlzdC5wdXNoKGVsKTtcbiAgICB9XG5cbiAgICBpZiAoZWwuaXNHcm91cCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW5SZWYoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmZpbmRBbmRBZGRGcm9tKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgTW9ycGhQcmVwYXJhdGlvbi5wcm90b3R5cGUuYWRkVG8gPSBmdW5jdGlvbiAocGF0aCwgZWxPcHRpb24sIGRhdGFJbmRleCwgYWxsUHJvcHNGaW5hbCkge1xuICAgIGlmIChwYXRoKSB7XG4gICAgICB0aGlzLl90b0xpc3QucHVzaChwYXRoKTtcblxuICAgICAgdGhpcy5fdG9FbE9wdGlvbkxpc3QucHVzaChlbE9wdGlvbik7XG5cbiAgICAgIHRoaXMuX3RvRGF0YUluZGljZXMucHVzaChkYXRhSW5kZXgpO1xuXG4gICAgICB0aGlzLl9hbGxQcm9wc0ZpbmFsTGlzdC5wdXNoKGFsbFByb3BzRmluYWwpO1xuICAgIH1cbiAgfTtcblxuICBNb3JwaFByZXBhcmF0aW9uLnByb3RvdHlwZS5hcHBseU1vcnBoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFtNT1JQSElOR19MT0dJQ19ISU5UXVxuICAgIC8vIFBheSBhdHRlbnRpb24gdG8gdGhlIG9yZGVyOlxuICAgIC8vIChBKSBBcHBseSBgYWxsUHJvcHNGaW5hbGAgYW5kIGBzdHlsZU9wdGlvbmAgdG8gXCJ0b1wiLlxuICAgIC8vICAgICAoVGhlbiBcInRvXCIgYmVjb21lcyB0byB0aGUgZmluYWwgc3RhdGUuKVxuICAgIC8vIChCKSBBcHBseSBgbW9ycGhQYXRoYC9gY29tYmluZWAvYHNlcGFyYXRlYC5cbiAgICAvLyAgICAgKEJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG9mIFwiZnJvbVwiIGFuZCB0aGUgZmluYWwgc3RhdGUgb2YgXCJ0b1wiLilcbiAgICAvLyAgICAgKFRoZW4gd2UgbWF5IGdldCBcImZyb20uc3ViTGlzdFwiIG9yIFwidG8uc3ViTGlzdFwiLilcbiAgICAvLyAoQykgQ29weSB0aGUgcmVsYXRlZCBwcm9wcyBmcm9tIFwiZnJvbVwiIHRvIFwiZnJvbS5zdWJMaXN0XCIsIGZyb20gXCJ0b1wiIHRvIFwidG8uc3ViTGlzdFwiLlxuICAgIC8vIChEKSBDb2xsZWN0IGB0cmFuc2l0aW9uRnJvbVByb3BzYCBmb3IgXCJ0b1wiIGFuZCBcInRvLnN1Ykxpc3RcIlxuICAgIC8vICAgICAoQmFzZWQgb24gXCJmcm9tXCIgb3IgXCJmcm9tLnN1Ykxpc3RcIi4pXG4gICAgLy8gKEUpIEFwcGx5IGB0cmFuc2l0aW9uRnJvbVByb3BzYCB0byBcInRvXCIgYW5kIFwidG8uc3ViTGlzdFwiXG4gICAgLy8gICAgIChJdCBtaWdodCBjaGFuZ2UgdGhlIHByb3AgdmFsdWVzIHRvIHRoZSBmaXJzdCBmcmFtZSB2YWx1ZS4pXG4gICAgLy8gQ2FzZV9JOlxuICAgIC8vICAgICBJZiAoRCkgc2hvdWxkIGJlIGFmdGVyIChDKSwgd2UgdXNlIHNlcXVlbmNlOiBBIC0gQiAtIEMgLSBEIC0gRVxuICAgIC8vIENhc2VfSUk6XG4gICAgLy8gICAgIElmIChBKSBzaG91bGQgYmUgYWZ0ZXIgKEQpLCB3ZSB1c2Ugc2VxdWVuY2U6IEQgLSBBIC0gQiAtIEMgLSBFXG4gICAgLy8gW01PUlBISU5HX0xPR0lDX0hJTlRdXG4gICAgLy8genJlbmRlciBgbW9ycGhQYXRoYC9gY29tYmluZWAvYHNlcGFyYXRlYCBvbmx5IG1hbmFnZXMgdGhlIHNoYXBlIGFuaW1hdGlvbi5cbiAgICAvLyBPdGhlciBwcm9wcyAobGlrZSB0cmFuc2Zyb20sIHN0eWxlIHRyYW5zaXRpb24pIHdpbGwgaGFuZGxlZCBpbiBlY2hhcnRzKS5cbiAgICAvLyBbTU9SUEhJTkdfTE9HSUNfSElOVF1cbiAgICAvLyBNYWtlIHN1cmUgYGFwcGx5UHJvcHNGaW5hbGAgYWx3YXlzIGJlIGNhbGxlZCBmb3IgXCJ0b1wiLlxuICAgIHZhciB0eXBlID0gdGhpcy5fdHlwZTtcbiAgICB2YXIgZnJvbUxpc3QgPSB0aGlzLl9mcm9tTGlzdDtcbiAgICB2YXIgdG9MaXN0ID0gdGhpcy5fdG9MaXN0O1xuICAgIHZhciB0b0xpc3RMZW4gPSB0b0xpc3QubGVuZ3RoO1xuICAgIHZhciBmcm9tTGlzdExlbiA9IGZyb21MaXN0Lmxlbmd0aDtcblxuICAgIGlmICghZnJvbUxpc3RMZW4gfHwgIXRvTGlzdExlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnb25lVG9PbmUnKSB7XG4gICAgICAvLyBJbiBvbmUtdG8tb25lIGNhc2UsIHdlIGJ5IGRlZmF1bHQgYXBwbHkgYSBzaW1wbGUgcnVsZTpcbiAgICAgIC8vIG1hcCBcImZyb21cIiBhbmQgXCJ0b1wiIG9uZSBieSBvbmUuXG4gICAgICAvLyBGb3IgdGhpcyBjYXNlOiBvbGRfZGF0YV9pdGVtX2VsIGFuZCBuZXdfZGF0YV9pdGVtX2VsXG4gICAgICAvLyBoYXMgdGhlIHNhbWUgaGllcmFyY2h5IG9mIGdyb3VwIHRyZWUgYnV0IG9ubHkgc29tZSBwYXRoIHR5cGUgY2hhbmdlZC5cbiAgICAgIGZvciAodmFyIHRvSWR4ID0gMDsgdG9JZHggPCB0b0xpc3RMZW47IHRvSWR4KyspIHtcbiAgICAgICAgdGhpcy5fb25lVG9PbmVGb3JTaW5nbGVUbyh0b0lkeCwgdG9JZHgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ21hbnlUb09uZScpIHtcbiAgICAgIC8vIEEgcm91Z2ggc3RyYXRlZ3k6IGlmIHRoZXJlIGFyZSBtb3JlIHRoYW4gb25lIFwidG9cIiwgd2Ugc2ltcGx5IGRpdmlkZSBcImZyb21MaXN0XCIgZXF1YWxseS5cbiAgICAgIHZhciBmcm9tU2luZ2xlU2VnTGVuID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihmcm9tTGlzdExlbiAvIHRvTGlzdExlbikpO1xuXG4gICAgICBmb3IgKHZhciB0b0lkeCA9IDAsIGZyb21JZHhTdGFydCA9IDA7IHRvSWR4IDwgdG9MaXN0TGVuOyB0b0lkeCsrLCBmcm9tSWR4U3RhcnQgKz0gZnJvbVNpbmdsZVNlZ0xlbikge1xuICAgICAgICB2YXIgZnJvbUNvdW50ID0gdG9JZHggKyAxID49IHRvTGlzdExlbiA/IGZyb21MaXN0TGVuIC0gZnJvbUlkeFN0YXJ0IDogZnJvbVNpbmdsZVNlZ0xlbjtcblxuICAgICAgICB0aGlzLl9tYW55VG9PbmVGb3JTaW5nbGVUbyh0b0lkeCwgZnJvbUlkeFN0YXJ0ID49IGZyb21MaXN0TGVuID8gbnVsbCA6IGZyb21JZHhTdGFydCwgZnJvbUNvdW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvbmVUb01hbnknKSB7XG4gICAgICAvLyBBIHJvdWdoIHN0cmF0ZWd5OiBpZiB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uZSBcImZyb21cIiwgd2Ugc2ltcGx5IGRpdmlkZSBcInRvTGlzdFwiIGVxdWFsbHkuXG4gICAgICB2YXIgdG9TaW5nbGVTZWdMZW4gPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHRvTGlzdExlbiAvIGZyb21MaXN0TGVuKSk7XG5cbiAgICAgIGZvciAodmFyIHRvSWR4U3RhcnQgPSAwLCBmcm9tSWR4ID0gMDsgdG9JZHhTdGFydCA8IHRvTGlzdExlbjsgdG9JZHhTdGFydCArPSB0b1NpbmdsZVNlZ0xlbiwgZnJvbUlkeCsrKSB7XG4gICAgICAgIHZhciB0b0NvdW50ID0gdG9JZHhTdGFydCArIHRvU2luZ2xlU2VnTGVuID49IHRvTGlzdExlbiA/IHRvTGlzdExlbiAtIHRvSWR4U3RhcnQgOiB0b1NpbmdsZVNlZ0xlbjtcblxuICAgICAgICB0aGlzLl9vbmVUb01hbnlGb3JTaW5nbGVGcm9tKHRvSWR4U3RhcnQsIHRvQ291bnQsIGZyb21JZHggPj0gZnJvbUxpc3RMZW4gPyBudWxsIDogZnJvbUlkeCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE1vcnBoUHJlcGFyYXRpb24ucHJvdG90eXBlLl9vbmVUb09uZUZvclNpbmdsZVRvID0gZnVuY3Rpb24gKCAvLyBcInRvXCIgbXVzdCBOT1QgYmUgbnVsbC91bmRlZmluZWQuXG4gIHRvSWR4LCAvLyBNYXkgYGZyb21JZHggPj0gdGhpcy5fZnJvbUxpc3QubGVuZ3RoYFxuICBmcm9tSWR4KSB7XG4gICAgdmFyIHRvID0gdGhpcy5fdG9MaXN0W3RvSWR4XTtcbiAgICB2YXIgdG9FbE9wdGlvbiA9IHRoaXMuX3RvRWxPcHRpb25MaXN0W3RvSWR4XTtcbiAgICB2YXIgdG9EYXRhSW5kZXggPSB0aGlzLl90b0RhdGFJbmRpY2VzW3RvSWR4XTtcbiAgICB2YXIgYWxsUHJvcHNGaW5hbCA9IHRoaXMuX2FsbFByb3BzRmluYWxMaXN0W3RvSWR4XTtcbiAgICB2YXIgZnJvbSA9IHRoaXMuX2Zyb21MaXN0W2Zyb21JZHhdO1xuXG4gICAgdmFyIGVsQW5pbWF0aW9uQ29uZmlnID0gdGhpcy5fZ2V0T3JDcmVhdGVNb3JwaENvbmZpZyh0b0RhdGFJbmRleCk7XG5cbiAgICB2YXIgbW9ycGhEdXJhdGlvbiA9IGVsQW5pbWF0aW9uQ29uZmlnLmR1cmF0aW9uO1xuXG4gICAgaWYgKGZyb20gJiYgaXNDb21iaW5pbmdQYXRoKGZyb20pKSB7XG4gICAgICBhcHBseVByb3BzRmluYWwodG8sIGFsbFByb3BzRmluYWwsIHRvRWxPcHRpb24uc3R5bGUpO1xuXG4gICAgICBpZiAobW9ycGhEdXJhdGlvbikge1xuICAgICAgICB2YXIgY29tYmluZVJlc3VsdCA9IGNvbWJpbmUoW2Zyb21dLCB0bywgZWxBbmltYXRpb25Db25maWcsIGNvcHlQcm9wc1doZW5EaXZpZGVkKTtcblxuICAgICAgICB0aGlzLl9wcm9jZXNzUmVzdWx0SW5kaXZpZHVhbHMoY29tYmluZVJlc3VsdCwgdG9JZHgsIG51bGwpO1xuICAgICAgfSAvLyBUaGUgdGFyZ2V0IGVsIHdpbGwgbm90IGJlIGRpc3BsYXllZCBhbmQgdHJhbnNpdGlvbiBmcm9tIG11bHRpcGxlIHBhdGguXG4gICAgICAvLyB0cmFuc2l0aW9uIG9uIHRoZSB0YXJnZXQgZWwgZG9lcyBub3QgbWFrZSBzZW5zZS5cblxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW9ycGhGcm9tID0gbW9ycGhEdXJhdGlvbiAvLyBmcm9tID09PSB0byB1c3VhbGx5IGhhcHBlbiBpbiBzY2VuYXJpb3Mgd2hlcmUgaW50ZXJuYWwgdXBkYXRlIGxpa2VcbiAgICAgIC8vIFwiZGF0YVpvb21cIiwgXCJsZWdlbmRUb2dnbGVcIiBoYXBwZW4uIElmIGZyb20gaXMgbm90IGluIGFueSBtb3JwaGluZyxcbiAgICAgIC8vIHdlIGRvIG5vdCBuZWVkIHRvIGNhbGwgYG1vcnBoUGF0aGAuXG4gICAgICAmJiBmcm9tICYmIChmcm9tICE9PSB0byB8fCBpc0luQW55TW9ycGhpbmcoZnJvbSkpID8gZnJvbSA6IG51bGw7IC8vIFNlZSBbQ2FzZV9JSV0gYWJvdmUuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIHRoZXJlIGlzIHByb2JhYmx5IGBmcm9tID09PSB0b2AuIEFuZCB0aGUgYHRyYW5zaXRpb25Gcm9tUHJvcHNgIGNvbGxlY3RpbmdcbiAgICAgIC8vIGRvZXMgbm90IGRlcGVuZHMgb24gbW9ycGhpbmcuIFNvIHdlIGNvbGxlY3QgYHRyYW5zaXRpb25Gcm9tUHJvcHNgIGZpcnN0LlxuXG4gICAgICB2YXIgdHJhbnNGcm9tUHJvcHMgPSB7fTtcbiAgICAgIHByZXBhcmVTaGFwZU9yRXh0cmFUcmFuc2l0aW9uRnJvbSgnc2hhcGUnLCB0bywgbW9ycGhGcm9tLCB0b0VsT3B0aW9uLCB0cmFuc0Zyb21Qcm9wcywgZmFsc2UpO1xuICAgICAgcHJlcGFyZVNoYXBlT3JFeHRyYVRyYW5zaXRpb25Gcm9tKCdleHRyYScsIHRvLCBtb3JwaEZyb20sIHRvRWxPcHRpb24sIHRyYW5zRnJvbVByb3BzLCBmYWxzZSk7XG4gICAgICBwcmVwYXJlVHJhbnNmb3JtVHJhbnNpdGlvbkZyb20odG8sIG1vcnBoRnJvbSwgdG9FbE9wdGlvbiwgdHJhbnNGcm9tUHJvcHMsIGZhbHNlKTtcbiAgICAgIHByZXBhcmVTdHlsZVRyYW5zaXRpb25Gcm9tKHRvLCBtb3JwaEZyb20sIHRvRWxPcHRpb24sIHRvRWxPcHRpb24uc3R5bGUsIHRyYW5zRnJvbVByb3BzLCBmYWxzZSk7XG4gICAgICBhcHBseVByb3BzRmluYWwodG8sIGFsbFByb3BzRmluYWwsIHRvRWxPcHRpb24uc3R5bGUpO1xuXG4gICAgICBpZiAobW9ycGhGcm9tKSB7XG4gICAgICAgIG1vcnBoUGF0aChtb3JwaEZyb20sIHRvLCBlbEFuaW1hdGlvbkNvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIGFwcGx5VHJhbnNpdGlvbkZyb20odG8sIHRvRGF0YUluZGV4LCB0b0VsT3B0aW9uLCB0aGlzLl9zZXJpZXNNb2RlbCwgdHJhbnNGcm9tUHJvcHMsIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgTW9ycGhQcmVwYXJhdGlvbi5wcm90b3R5cGUuX21hbnlUb09uZUZvclNpbmdsZVRvID0gZnVuY3Rpb24gKCAvLyBcInRvXCIgbXVzdCBOT1QgYmUgbnVsbC91bmRlZmluZWQuXG4gIHRvSWR4LCAvLyBNYXkgYmUgbnVsbC5cbiAgZnJvbUlkeFN0YXJ0LCBmcm9tQ291bnQpIHtcbiAgICB2YXIgdG8gPSB0aGlzLl90b0xpc3RbdG9JZHhdO1xuICAgIHZhciB0b0VsT3B0aW9uID0gdGhpcy5fdG9FbE9wdGlvbkxpc3RbdG9JZHhdO1xuICAgIHZhciBhbGxQcm9wc0ZpbmFsID0gdGhpcy5fYWxsUHJvcHNGaW5hbExpc3RbdG9JZHhdO1xuICAgIGFwcGx5UHJvcHNGaW5hbCh0bywgYWxsUHJvcHNGaW5hbCwgdG9FbE9wdGlvbi5zdHlsZSk7XG5cbiAgICB2YXIgZWxBbmltYXRpb25Db25maWcgPSB0aGlzLl9nZXRPckNyZWF0ZU1vcnBoQ29uZmlnKHRoaXMuX3RvRGF0YUluZGljZXNbdG9JZHhdKTtcblxuICAgIGlmIChlbEFuaW1hdGlvbkNvbmZpZy5kdXJhdGlvbiAmJiBmcm9tSWR4U3RhcnQgIT0gbnVsbCkge1xuICAgICAgdmFyIGNvbWJpbmVGcm9tTGlzdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBmcm9tSWR4ID0gZnJvbUlkeFN0YXJ0OyBmcm9tSWR4IDwgZnJvbUNvdW50OyBmcm9tSWR4KyspIHtcbiAgICAgICAgY29tYmluZUZyb21MaXN0LnB1c2godGhpcy5fZnJvbUxpc3RbZnJvbUlkeF0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29tYmluZVJlc3VsdCA9IGNvbWJpbmUoY29tYmluZUZyb21MaXN0LCB0bywgZWxBbmltYXRpb25Db25maWcsIGNvcHlQcm9wc1doZW5EaXZpZGVkKTtcblxuICAgICAgdGhpcy5fcHJvY2Vzc1Jlc3VsdEluZGl2aWR1YWxzKGNvbWJpbmVSZXN1bHQsIHRvSWR4LCBudWxsKTtcbiAgICB9XG4gIH07XG5cbiAgTW9ycGhQcmVwYXJhdGlvbi5wcm90b3R5cGUuX29uZVRvTWFueUZvclNpbmdsZUZyb20gPSBmdW5jdGlvbiAoIC8vIFwidG9cIiBtdXN0IE5PVCBiZSBudWxsL3VuZGVmaW5lZC5cbiAgdG9JZHhTdGFydCwgdG9Db3VudCwgLy8gTWF5IGJlIG51bGxcbiAgZnJvbUlkeCkge1xuICAgIHZhciBmcm9tID0gZnJvbUlkeCA9PSBudWxsID8gbnVsbCA6IHRoaXMuX2Zyb21MaXN0W2Zyb21JZHhdO1xuICAgIHZhciB0b0xpc3QgPSB0aGlzLl90b0xpc3Q7XG4gICAgdmFyIHNlcGFyYXRlVG9MaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciB0b0lkeCA9IHRvSWR4U3RhcnQ7IHRvSWR4IDwgdG9Db3VudDsgdG9JZHgrKykge1xuICAgICAgdmFyIHRvID0gdG9MaXN0W3RvSWR4XTtcbiAgICAgIGFwcGx5UHJvcHNGaW5hbCh0bywgdGhpcy5fYWxsUHJvcHNGaW5hbExpc3RbdG9JZHhdLCB0aGlzLl90b0VsT3B0aW9uTGlzdFt0b0lkeF0uc3R5bGUpO1xuICAgICAgc2VwYXJhdGVUb0xpc3QucHVzaCh0byk7XG4gICAgfVxuXG4gICAgdmFyIGVsQW5pbWF0aW9uQ29uZmlnID0gdGhpcy5fZ2V0T3JDcmVhdGVNb3JwaENvbmZpZyh0aGlzLl90b0RhdGFJbmRpY2VzW3RvSWR4U3RhcnRdKTtcblxuICAgIGlmIChlbEFuaW1hdGlvbkNvbmZpZy5kdXJhdGlvbiAmJiBmcm9tKSB7XG4gICAgICB2YXIgc2VwYXJhdGVSZXN1bHQgPSBzZXBhcmF0ZShmcm9tLCBzZXBhcmF0ZVRvTGlzdCwgZWxBbmltYXRpb25Db25maWcsIGNvcHlQcm9wc1doZW5EaXZpZGVkKTtcblxuICAgICAgdGhpcy5fcHJvY2Vzc1Jlc3VsdEluZGl2aWR1YWxzKHNlcGFyYXRlUmVzdWx0LCB0b0lkeFN0YXJ0LCB0b0NvdW50KTtcbiAgICB9XG4gIH07XG5cbiAgTW9ycGhQcmVwYXJhdGlvbi5wcm90b3R5cGUuX3Byb2Nlc3NSZXN1bHRJbmRpdmlkdWFscyA9IGZ1bmN0aW9uIChjb21iaW5lU2VwYXJhdGVSZXN1bHQsIHRvSWR4U3RhcnQsIHRvQ291bnQpIHtcbiAgICB2YXIgaXNTZXBhcmF0ZSA9IHRvQ291bnQgIT0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tYmluZVNlcGFyYXRlUmVzdWx0LmNvdW50OyBpKyspIHtcbiAgICAgIHZhciBmcm9tSW5kaXZpZHVhbCA9IGNvbWJpbmVTZXBhcmF0ZVJlc3VsdC5mcm9tSW5kaXZpZHVhbHNbaV07XG4gICAgICB2YXIgdG9JbmRpdmlkdWFsID0gY29tYmluZVNlcGFyYXRlUmVzdWx0LnRvSW5kaXZpZHVhbHNbaV07IC8vIEhlcmUgaXQncyBhIHRyaWNrOlxuICAgICAgLy8gRm9yIFwiY29tYmluZVwiIGNhc2UsIGFsbCBvZiB0aGUgYHRvSW5kaXZpZHVhbHNgIG1hcCB0byB0aGUgc2FtZSBgdG9JZHhgLlxuICAgICAgLy8gRm9yIFwic2VwYXJhdGVcIiBjYXNlLCB0aGUgYHRvSW5kaXZpZHVhbHNgIG1hcCB0byBzb21lIGNlcnRhaW4gc2VnbWVudCBvZiBgX3RvTGlzdGAgYWNjdXJhdGVseS5cblxuICAgICAgdmFyIHRvSWR4ID0gdG9JZHhTdGFydCArIChpc1NlcGFyYXRlID8gaSA6IDApO1xuICAgICAgdmFyIHRvRWxPcHRpb24gPSB0aGlzLl90b0VsT3B0aW9uTGlzdFt0b0lkeF07XG4gICAgICB2YXIgZGF0YUluZGV4ID0gdGhpcy5fdG9EYXRhSW5kaWNlc1t0b0lkeF07XG4gICAgICB2YXIgdHJhbnNGcm9tUHJvcHMgPSB7fTtcbiAgICAgIHByZXBhcmVUcmFuc2Zvcm1UcmFuc2l0aW9uRnJvbSh0b0luZGl2aWR1YWwsIGZyb21JbmRpdmlkdWFsLCB0b0VsT3B0aW9uLCB0cmFuc0Zyb21Qcm9wcywgZmFsc2UpO1xuICAgICAgcHJlcGFyZVN0eWxlVHJhbnNpdGlvbkZyb20odG9JbmRpdmlkdWFsLCBmcm9tSW5kaXZpZHVhbCwgdG9FbE9wdGlvbiwgdG9FbE9wdGlvbi5zdHlsZSwgdHJhbnNGcm9tUHJvcHMsIGZhbHNlKTtcbiAgICAgIGFwcGx5VHJhbnNpdGlvbkZyb20odG9JbmRpdmlkdWFsLCBkYXRhSW5kZXgsIHRvRWxPcHRpb24sIHRoaXMuX3Nlcmllc01vZGVsLCB0cmFuc0Zyb21Qcm9wcywgZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBNb3JwaFByZXBhcmF0aW9uLnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVNb3JwaENvbmZpZyA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICB2YXIgbW9ycGhDb25maWdMaXN0ID0gdGhpcy5fbW9ycGhDb25maWdMaXN0O1xuICAgIHZhciBjb25maWcgPSBtb3JwaENvbmZpZ0xpc3RbZGF0YUluZGV4XTtcblxuICAgIGlmIChjb25maWcpIHtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgdmFyIGR1cmF0aW9uO1xuICAgIHZhciBlYXNpbmc7XG4gICAgdmFyIGRlbGF5O1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IHRoaXMuX3Nlcmllc01vZGVsO1xuICAgIHZhciB0cmFuc09wdCA9IHRoaXMuX3RyYW5zT3B0O1xuXG4gICAgaWYgKHNlcmllc01vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAvLyBQRU5ESU5HOiByZWZhY3Rvcj8gdGhpcyBpcyB0aGUgc2FtZSBsb2dpYyBhcyBgc3JjL3V0aWwvZ3JhcGhpYy50cyNhbmltYXRlT3JTZXRQcm9wc2AuXG4gICAgICB2YXIgYW5pbWF0aW9uUGF5bG9hZCA9IHZvaWQgMDtcblxuICAgICAgaWYgKHNlcmllc01vZGVsICYmIHNlcmllc01vZGVsLmVjTW9kZWwpIHtcbiAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBzZXJpZXNNb2RlbC5lY01vZGVsLmdldFVwZGF0ZVBheWxvYWQoKTtcbiAgICAgICAgYW5pbWF0aW9uUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgJiYgdXBkYXRlUGF5bG9hZC5hbmltYXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmltYXRpb25QYXlsb2FkKSB7XG4gICAgICAgIGR1cmF0aW9uID0gYW5pbWF0aW9uUGF5bG9hZC5kdXJhdGlvbiB8fCAwO1xuICAgICAgICBlYXNpbmcgPSBhbmltYXRpb25QYXlsb2FkLmVhc2luZyB8fCAnY3ViaWNPdXQnO1xuICAgICAgICBkZWxheSA9IGFuaW1hdGlvblBheWxvYWQuZGVsYXkgfHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhc2luZyA9IHNlcmllc01vZGVsLmdldCgnYW5pbWF0aW9uRWFzaW5nVXBkYXRlJyk7XG4gICAgICAgIHZhciBkZWxheU9wdGlvbiA9IHNlcmllc01vZGVsLmdldCgnYW5pbWF0aW9uRGVsYXlVcGRhdGUnKTtcbiAgICAgICAgZGVsYXkgPSBpc0Z1bmN0aW9uKGRlbGF5T3B0aW9uKSA/IGRlbGF5T3B0aW9uKGRhdGFJbmRleCkgOiBkZWxheU9wdGlvbjtcbiAgICAgICAgdmFyIGR1cmF0aW9uT3B0aW9uID0gc2VyaWVzTW9kZWwuZ2V0KCdhbmltYXRpb25EdXJhdGlvblVwZGF0ZScpO1xuICAgICAgICBkdXJhdGlvbiA9IGlzRnVuY3Rpb24oZHVyYXRpb25PcHRpb24pID8gZHVyYXRpb25PcHRpb24oZGF0YUluZGV4KSA6IGR1cmF0aW9uT3B0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbmZpZyA9IHtcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiB8fCAwLFxuICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgZWFzaW5nOiBlYXNpbmcsXG4gICAgICBkaXZpZGluZ01ldGhvZDogdHJhbnNPcHQgPyB0cmFuc09wdC5kaXZpZGluZ01ldGhvZCA6IG51bGxcbiAgICB9O1xuICAgIG1vcnBoQ29uZmlnTGlzdFtkYXRhSW5kZXhdID0gY29uZmlnO1xuICAgIHJldHVybiBjb25maWc7XG4gIH07XG5cbiAgTW9ycGhQcmVwYXJhdGlvbi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIC8vIGB0aGlzLl9tb3JwaENvbmZpZ0xpc3RgIGNhbiBiZSBrZXB0LiBJdCBvbmx5IHJlbGF0ZWQgdG8gYGRhdGFJbmRleGAuXG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fZnJvbUxpc3QubGVuZ3RoID0gdGhpcy5fdG9MaXN0Lmxlbmd0aCA9IHRoaXMuX3RvRWxPcHRpb25MaXN0Lmxlbmd0aCA9IHRoaXMuX2FsbFByb3BzRmluYWxMaXN0Lmxlbmd0aCA9IHRoaXMuX3RvRGF0YUluZGljZXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICByZXR1cm4gTW9ycGhQcmVwYXJhdGlvbjtcbn0oKTtcblxuZnVuY3Rpb24gY29weVByb3BzV2hlbkRpdmlkZWQoc3JjUGF0aCwgdGFyUGF0aCwgd2lsbENsb25lKSB7XG4gIC8vIERvIG5vdCBjb3B5IHRyYW5zZm9ybSBwcm9wcy5cbiAgLy8gU3ViIHBhdGhzIGFyZSB0cmFuc2Zyb20gYmFzZWQgb24gdGhlaXIgaG9zdCBwYXRoLlxuICAvLyB0YXJQYXRoLnggPSBzcmNQYXRoLng7XG4gIC8vIHRhclBhdGgueSA9IHNyY1BhdGgueTtcbiAgLy8gdGFyUGF0aC5zY2FsZVggPSBzcmNQYXRoLnNjYWxlWDtcbiAgLy8gdGFyUGF0aC5zY2FsZVkgPSBzcmNQYXRoLnNjYWxlWTtcbiAgLy8gdGFyUGF0aC5vcmlnaW5YID0gc3JjUGF0aC5vcmlnaW5YO1xuICAvLyB0YXJQYXRoLm9yaWdpblkgPSBzcmNQYXRoLm9yaWdpblk7XG4gIC8vIElmIGp1c3QgY2FycnkgdGhlIHN0eWxlLCB3aWxsIG5vdCBiZSBtb2RpZmVkLCBzbyBkbyBub3QgY29weS5cbiAgdGFyUGF0aC5zdHlsZSA9IHdpbGxDbG9uZSA/IGNsb25lKHNyY1BhdGguc3R5bGUpIDogc3JjUGF0aC5zdHlsZTtcbiAgdGFyUGF0aC56bGV2ZWwgPSBzcmNQYXRoLnpsZXZlbDtcbiAgdGFyUGF0aC56ID0gc3JjUGF0aC56O1xuICB0YXJQYXRoLnoyID0gc3JjUGF0aC56Mjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhDdXN0b21TZXJpZXNWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU2VyaWVzTW9kZWwoQ3VzdG9tU2VyaWVzTW9kZWwpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBjcmVhdGVMaXN0RnJvbUFycmF5IGZyb20gJy4uL2hlbHBlci9jcmVhdGVMaXN0RnJvbUFycmF5JztcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9TZXJpZXMnO1xuXG52YXIgRWZmZWN0U2NhdHRlclNlcmllc01vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEVmZmVjdFNjYXR0ZXJTZXJpZXNNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBFZmZlY3RTY2F0dGVyU2VyaWVzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gRWZmZWN0U2NhdHRlclNlcmllc01vZGVsLnR5cGU7XG4gICAgX3RoaXMuaGFzU3ltYm9sVmlzdWFsID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBFZmZlY3RTY2F0dGVyU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIHJldHVybiBjcmVhdGVMaXN0RnJvbUFycmF5KHRoaXMuZ2V0U291cmNlKCksIHRoaXMsIHtcbiAgICAgIHVzZUVuY29kZURlZmF1bHRlcjogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIEVmZmVjdFNjYXR0ZXJTZXJpZXNNb2RlbC5wcm90b3R5cGUuYnJ1c2hTZWxlY3RvciA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIGRhdGEsIHNlbGVjdG9ycykge1xuICAgIHJldHVybiBzZWxlY3RvcnMucG9pbnQoZGF0YS5nZXRJdGVtTGF5b3V0KGRhdGFJbmRleCkpO1xuICB9O1xuXG4gIEVmZmVjdFNjYXR0ZXJTZXJpZXNNb2RlbC50eXBlID0gJ3Nlcmllcy5lZmZlY3RTY2F0dGVyJztcbiAgRWZmZWN0U2NhdHRlclNlcmllc01vZGVsLmRlcGVuZGVuY2llcyA9IFsnZ3JpZCcsICdwb2xhciddO1xuICBFZmZlY3RTY2F0dGVyU2VyaWVzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICBjb29yZGluYXRlU3lzdGVtOiAnY2FydGVzaWFuMmQnLFxuICAgIHpsZXZlbDogMCxcbiAgICB6OiAyLFxuICAgIGxlZ2VuZEhvdmVyTGluazogdHJ1ZSxcbiAgICBlZmZlY3RUeXBlOiAncmlwcGxlJyxcbiAgICBwcm9ncmVzc2l2ZTogMCxcbiAgICAvLyBXaGVuIHRvIHNob3cgdGhlIGVmZmVjdCwgb3B0aW9uOiAncmVuZGVyJ3wnZW1waGFzaXMnXG4gICAgc2hvd0VmZmVjdE9uOiAncmVuZGVyJyxcbiAgICAvLyBSaXBwbGUgZWZmZWN0IGNvbmZpZ1xuICAgIHJpcHBsZUVmZmVjdDoge1xuICAgICAgcGVyaW9kOiA0LFxuICAgICAgLy8gU2NhbGUgb2YgcmlwcGxlXG4gICAgICBzY2FsZTogMi41LFxuICAgICAgLy8gQnJ1c2ggdHlwZSBjYW4gYmUgZmlsbCBvciBzdHJva2VcbiAgICAgIGJydXNoVHlwZTogJ2ZpbGwnXG4gICAgfSxcbiAgICAvLyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAvLyB4QXhpc0luZGV4OiAwLFxuICAgIC8vIHlBeGlzSW5kZXg6IDAsXG4gICAgLy8gUG9sYXIgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAvLyBwb2xhckluZGV4OiAwLFxuICAgIC8vIEdlbyBjb29yZGluYXRlIHN5c3RlbVxuICAgIC8vIGdlb0luZGV4OiAwLFxuICAgIC8vIHN5bWJvbDogbnVsbCwgICAgICAgIC8vIOWbvuW9ouexu+Wei1xuICAgIHN5bWJvbFNpemU6IDEwIC8vIOWbvuW9ouWkp+Wwj++8jOWNiuWuve+8iOWNiuW+hO+8ieWPguaVsO+8jOW9k+WbvuW9ouS4uuaWueWQkeaIluiPseW9ouWImeaAu+WuveW6puS4unN5bWJvbFNpemUgKiAyXG4gICAgLy8gc3ltYm9sUm90YXRlOiBudWxsLCAgLy8g5Zu+5b2i5peL6L2s5o6n5Yi2XG4gICAgLy8gaXRlbVN0eWxlOiB7XG4gICAgLy8gICAgIG9wYWNpdHk6IDFcbiAgICAvLyB9XG5cbiAgfTtcbiAgcmV0dXJuIEVmZmVjdFNjYXR0ZXJTZXJpZXNNb2RlbDtcbn0oU2VyaWVzTW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBFZmZlY3RTY2F0dGVyU2VyaWVzTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFN5bWJvbERyYXcgZnJvbSAnLi4vaGVscGVyL1N5bWJvbERyYXcnO1xuaW1wb3J0IEVmZmVjdFN5bWJvbCBmcm9tICcuLi9oZWxwZXIvRWZmZWN0U3ltYm9sJztcbmltcG9ydCAqIGFzIG1hdHJpeCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeCc7XG5pbXBvcnQgcG9pbnRzTGF5b3V0IGZyb20gJy4uLy4uL2xheW91dC9wb2ludHMnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0JztcblxudmFyIEVmZmVjdFNjYXR0ZXJWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEVmZmVjdFNjYXR0ZXJWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEVmZmVjdFNjYXR0ZXJWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IEVmZmVjdFNjYXR0ZXJWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgRWZmZWN0U2NhdHRlclZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fc3ltYm9sRHJhdyA9IG5ldyBTeW1ib2xEcmF3KEVmZmVjdFN5bWJvbCk7XG4gIH07XG5cbiAgRWZmZWN0U2NhdHRlclZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGVmZmVjdFN5bWJvbERyYXcgPSB0aGlzLl9zeW1ib2xEcmF3O1xuICAgIGVmZmVjdFN5bWJvbERyYXcudXBkYXRlRGF0YShkYXRhKTtcbiAgICB0aGlzLmdyb3VwLmFkZChlZmZlY3RTeW1ib2xEcmF3Lmdyb3VwKTtcbiAgfTtcblxuICBFZmZlY3RTY2F0dGVyVmlldy5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB0aGlzLmdyb3VwLmRpcnR5KCk7XG4gICAgdmFyIHJlcyA9IHBvaW50c0xheW91dCgnJykucmVzZXQoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG5cbiAgICBpZiAocmVzLnByb2dyZXNzKSB7XG4gICAgICByZXMucHJvZ3Jlc3Moe1xuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZW5kOiBkYXRhLmNvdW50KCksXG4gICAgICAgIGNvdW50OiBkYXRhLmNvdW50KClcbiAgICAgIH0sIGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX3N5bWJvbERyYXcudXBkYXRlTGF5b3V0KCk7XG4gIH07XG5cbiAgRWZmZWN0U2NhdHRlclZpZXcucHJvdG90eXBlLl91cGRhdGVHcm91cFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMuZ2V0Um9hbVRyYW5zZm9ybSkge1xuICAgICAgdGhpcy5ncm91cC50cmFuc2Zvcm0gPSBtYXRyaXguY2xvbmUoY29vcmRTeXMuZ2V0Um9hbVRyYW5zZm9ybSgpKTtcbiAgICAgIHRoaXMuZ3JvdXAuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gICAgfVxuICB9O1xuXG4gIEVmZmVjdFNjYXR0ZXJWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5fc3ltYm9sRHJhdyAmJiB0aGlzLl9zeW1ib2xEcmF3LnJlbW92ZSh0cnVlKTtcbiAgfTtcblxuICBFZmZlY3RTY2F0dGVyVmlldy50eXBlID0gJ2VmZmVjdFNjYXR0ZXInO1xuICByZXR1cm4gRWZmZWN0U2NhdHRlclZpZXc7XG59KENoYXJ0Vmlldyk7XG5cbmV4cG9ydCBkZWZhdWx0IEVmZmVjdFNjYXR0ZXJWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgRWZmZWN0U2NhdHRlclZpZXcgZnJvbSAnLi9FZmZlY3RTY2F0dGVyVmlldyc7XG5pbXBvcnQgRWZmZWN0U2NhdHRlclNlcmllc01vZGVsIGZyb20gJy4vRWZmZWN0U2NhdHRlclNlcmllcyc7XG5pbXBvcnQgbGF5b3V0UG9pbnRzIGZyb20gJy4uLy4uL2xheW91dC9wb2ludHMnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhFZmZlY3RTY2F0dGVyVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclNlcmllc01vZGVsKEVmZmVjdFNjYXR0ZXJTZXJpZXNNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckxheW91dChsYXlvdXRQb2ludHMoJ2VmZmVjdFNjYXR0ZXInKSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgY3JlYXRlTGlzdFNpbXBseSBmcm9tICcuLi9oZWxwZXIvY3JlYXRlTGlzdFNpbXBseSc7XG5pbXBvcnQgeyBkZWZhdWx0RW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbmltcG9ydCB7IG1ha2VTZXJpZXNFbmNvZGVGb3JOYW1lQmFzZWQgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9zb3VyY2VIZWxwZXInO1xuaW1wb3J0IExlZ2VuZFZpc3VhbFByb3ZpZGVyIGZyb20gJy4uLy4uL3Zpc3VhbC9MZWdlbmRWaXN1YWxQcm92aWRlcic7XG5pbXBvcnQgU2VyaWVzTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvU2VyaWVzJztcblxudmFyIEZ1bm5lbFNlcmllc01vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEZ1bm5lbFNlcmllc01vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEZ1bm5lbFNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IEZ1bm5lbFNlcmllc01vZGVsLnR5cGU7XG4gICAgX3RoaXMudXNlQ29sb3JQYWxldHRlT25EYXRhID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBGdW5uZWxTZXJpZXNNb2RlbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gRW5hYmxlIGxlZ2VuZCBzZWxlY3Rpb24gZm9yIGVhY2ggZGF0YSBpdGVtXG4gICAgLy8gVXNlIGEgZnVuY3Rpb24gaW5zdGVhZCBvZiBkaXJlY3QgYWNjZXNzIGJlY2F1c2UgZGF0YSByZWZlcmVuY2UgbWF5IGNoYW5nZWRcblxuXG4gICAgdGhpcy5sZWdlbmRWaXN1YWxQcm92aWRlciA9IG5ldyBMZWdlbmRWaXN1YWxQcm92aWRlcih6clV0aWwuYmluZCh0aGlzLmdldERhdGEsIHRoaXMpLCB6clV0aWwuYmluZCh0aGlzLmdldFJhd0RhdGEsIHRoaXMpKTsgLy8gRXh0ZW5kIGxhYmVsTGluZSBlbXBoYXNpc1xuXG4gICAgdGhpcy5fZGVmYXVsdExhYmVsTGluZShvcHRpb24pO1xuICB9O1xuXG4gIEZ1bm5lbFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YSA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICByZXR1cm4gY3JlYXRlTGlzdFNpbXBseSh0aGlzLCB7XG4gICAgICBjb29yZERpbWVuc2lvbnM6IFsndmFsdWUnXSxcbiAgICAgIGVuY29kZURlZmF1bHRlcjogenJVdGlsLmN1cnJ5KG1ha2VTZXJpZXNFbmNvZGVGb3JOYW1lQmFzZWQsIHRoaXMpXG4gICAgfSk7XG4gIH07XG5cbiAgRnVubmVsU2VyaWVzTW9kZWwucHJvdG90eXBlLl9kZWZhdWx0TGFiZWxMaW5lID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIC8vIEV4dGVuZCBsYWJlbExpbmUgZW1waGFzaXNcbiAgICBkZWZhdWx0RW1waGFzaXMob3B0aW9uLCAnbGFiZWxMaW5lJywgWydzaG93J10pO1xuICAgIHZhciBsYWJlbExpbmVOb3JtYWxPcHQgPSBvcHRpb24ubGFiZWxMaW5lO1xuICAgIHZhciBsYWJlbExpbmVFbXBoYXNpc09wdCA9IG9wdGlvbi5lbXBoYXNpcy5sYWJlbExpbmU7IC8vIE5vdCBzaG93IGxhYmVsIGxpbmUgaWYgYGxhYmVsLm5vcm1hbC5zaG93ID0gZmFsc2VgXG5cbiAgICBsYWJlbExpbmVOb3JtYWxPcHQuc2hvdyA9IGxhYmVsTGluZU5vcm1hbE9wdC5zaG93ICYmIG9wdGlvbi5sYWJlbC5zaG93O1xuICAgIGxhYmVsTGluZUVtcGhhc2lzT3B0LnNob3cgPSBsYWJlbExpbmVFbXBoYXNpc09wdC5zaG93ICYmIG9wdGlvbi5lbXBoYXNpcy5sYWJlbC5zaG93O1xuICB9OyAvLyBPdmVyd3JpdGVcblxuXG4gIEZ1bm5lbFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXREYXRhUGFyYW1zID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKCk7XG5cbiAgICB2YXIgcGFyYW1zID0gX3N1cGVyLnByb3RvdHlwZS5nZXREYXRhUGFyYW1zLmNhbGwodGhpcywgZGF0YUluZGV4KTtcblxuICAgIHZhciB2YWx1ZURpbSA9IGRhdGEubWFwRGltZW5zaW9uKCd2YWx1ZScpO1xuICAgIHZhciBzdW0gPSBkYXRhLmdldFN1bSh2YWx1ZURpbSk7IC8vIFBlcmNlbnQgaXMgMCBpZiBzdW0gaXMgMFxuXG4gICAgcGFyYW1zLnBlcmNlbnQgPSAhc3VtID8gMCA6ICsoZGF0YS5nZXQodmFsdWVEaW0sIGRhdGFJbmRleCkgLyBzdW0gKiAxMDApLnRvRml4ZWQoMik7XG4gICAgcGFyYW1zLiR2YXJzLnB1c2goJ3BlcmNlbnQnKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9O1xuXG4gIEZ1bm5lbFNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLmZ1bm5lbCc7XG4gIEZ1bm5lbFNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIGxlZnQ6IDgwLFxuICAgIHRvcDogNjAsXG4gICAgcmlnaHQ6IDgwLFxuICAgIGJvdHRvbTogNjAsXG4gICAgLy8gd2lkdGg6IHt0b3RhbFdpZHRofSAtIGxlZnQgLSByaWdodCxcbiAgICAvLyBoZWlnaHQ6IHt0b3RhbEhlaWdodH0gLSB0b3AgLSBib3R0b20sXG4gICAgLy8g6buY6K6k5Y+W5pWw5o2u5pyA5bCP5pyA5aSn5YC8XG4gICAgLy8gbWluOiAwLFxuICAgIC8vIG1heDogMTAwLFxuICAgIG1pblNpemU6ICcwJScsXG4gICAgbWF4U2l6ZTogJzEwMCUnLFxuICAgIHNvcnQ6ICdkZXNjZW5kaW5nJyxcbiAgICBvcmllbnQ6ICd2ZXJ0aWNhbCcsXG4gICAgZ2FwOiAwLFxuICAgIGZ1bm5lbEFsaWduOiAnY2VudGVyJyxcbiAgICBsYWJlbDoge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIHBvc2l0aW9uOiAnb3V0ZXInIC8vIGZvcm1hdHRlcjog5qCH562+5paH5pys5qC85byP5Zmo77yM5ZCMVG9vbHRpcC5mb3JtYXR0ZXLvvIzkuI3mlK/mjIHlvILmraXlm57osINcblxuICAgIH0sXG4gICAgbGFiZWxMaW5lOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgbGVuZ3RoOiAyMCxcbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAvLyBjb2xvcjog5ZCE5byCLFxuICAgICAgICB3aWR0aDogMVxuICAgICAgfVxuICAgIH0sXG4gICAgaXRlbVN0eWxlOiB7XG4gICAgICAvLyBjb2xvcjog5ZCE5byCLFxuICAgICAgYm9yZGVyQ29sb3I6ICcjZmZmJyxcbiAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0OiB7XG4gICAgICBpdGVtU3R5bGU6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMjEyMTIxJ1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEZ1bm5lbFNlcmllc01vZGVsO1xufShTZXJpZXNNb2RlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IEZ1bm5lbFNlcmllc01vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCB7IHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbCwgZW5hYmxlSG92ZXJFbXBoYXNpcyB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdGVzJztcbmltcG9ydCBDaGFydFZpZXcgZnJvbSAnLi4vLi4vdmlldy9DaGFydCc7XG5pbXBvcnQgeyBzZXRMYWJlbExpbmVTdHlsZSwgZ2V0TGFiZWxMaW5lU3RhdGVzTW9kZWxzIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxHdWlkZUhlbHBlcic7XG5pbXBvcnQgeyBzZXRMYWJlbFN0eWxlLCBnZXRMYWJlbFN0YXRlc01vZGVscyB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUnO1xudmFyIG9wYWNpdHlBY2Nlc3NQYXRoID0gWydpdGVtU3R5bGUnLCAnb3BhY2l0eSddO1xuLyoqXG4gKiBQaWVjZSBvZiBwaWUgaW5jbHVkaW5nIFNlY3RvciwgTGFiZWwsIExhYmVsTGluZVxuICovXG5cbnZhciBGdW5uZWxQaWVjZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhGdW5uZWxQaWVjZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBGdW5uZWxQaWVjZShkYXRhLCBpZHgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgdmFyIHBvbHlnb24gPSBfdGhpcztcbiAgICB2YXIgbGFiZWxMaW5lID0gbmV3IGdyYXBoaWMuUG9seWxpbmUoKTtcbiAgICB2YXIgdGV4dCA9IG5ldyBncmFwaGljLlRleHQoKTtcbiAgICBwb2x5Z29uLnNldFRleHRDb250ZW50KHRleHQpO1xuXG4gICAgX3RoaXMuc2V0VGV4dEd1aWRlTGluZShsYWJlbExpbmUpO1xuXG4gICAgX3RoaXMudXBkYXRlRGF0YShkYXRhLCBpZHgsIHRydWUpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgRnVubmVsUGllY2UucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgaWR4LCBmaXJzdENyZWF0ZSkge1xuICAgIHZhciBwb2x5Z29uID0gdGhpcztcbiAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICB2YXIgbGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgdmFyIGVtcGhhc2lzTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJyk7XG4gICAgdmFyIG9wYWNpdHkgPSBpdGVtTW9kZWwuZ2V0KG9wYWNpdHlBY2Nlc3NQYXRoKTtcbiAgICBvcGFjaXR5ID0gb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHk7IC8vIFVwZGF0ZSBjb21tb24gc3R5bGVcblxuICAgIHBvbHlnb24udXNlU3R5bGUoZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJykpO1xuICAgIHBvbHlnb24uc3R5bGUubGluZUpvaW4gPSAncm91bmQnO1xuXG4gICAgaWYgKGZpcnN0Q3JlYXRlKSB7XG4gICAgICBwb2x5Z29uLnNldFNoYXBlKHtcbiAgICAgICAgcG9pbnRzOiBsYXlvdXQucG9pbnRzXG4gICAgICB9KTtcbiAgICAgIHBvbHlnb24uc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICBncmFwaGljLmluaXRQcm9wcyhwb2x5Z29uLCB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgb3BhY2l0eTogb3BhY2l0eVxuICAgICAgICB9XG4gICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2x5Z29uLCB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgb3BhY2l0eTogb3BhY2l0eVxuICAgICAgICB9LFxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIHBvaW50czogbGF5b3V0LnBvaW50c1xuICAgICAgICB9XG4gICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICB9XG5cbiAgICBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwocG9seWdvbiwgaXRlbU1vZGVsKTtcblxuICAgIHRoaXMuX3VwZGF0ZUxhYmVsKGRhdGEsIGlkeCk7XG5cbiAgICBlbmFibGVIb3ZlckVtcGhhc2lzKHRoaXMsIGVtcGhhc2lzTW9kZWwuZ2V0KCdmb2N1cycpLCBlbXBoYXNpc01vZGVsLmdldCgnYmx1clNjb3BlJykpO1xuICB9O1xuXG4gIEZ1bm5lbFBpZWNlLnByb3RvdHlwZS5fdXBkYXRlTGFiZWwgPSBmdW5jdGlvbiAoZGF0YSwgaWR4KSB7XG4gICAgdmFyIHBvbHlnb24gPSB0aGlzO1xuICAgIHZhciBsYWJlbExpbmUgPSB0aGlzLmdldFRleHRHdWlkZUxpbmUoKTtcbiAgICB2YXIgbGFiZWxUZXh0ID0gcG9seWdvbi5nZXRUZXh0Q29udGVudCgpO1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICB2YXIgbGFiZWxMYXlvdXQgPSBsYXlvdXQubGFiZWw7XG4gICAgdmFyIHN0eWxlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJyk7XG4gICAgdmFyIHZpc3VhbENvbG9yID0gc3R5bGUuZmlsbDtcbiAgICBzZXRMYWJlbFN0eWxlKCAvLyBwb3NpdGlvbiB3aWxsIG5vdCBiZSB1c2VkIGluIHNldExhYmVsU3R5bGVcbiAgICBsYWJlbFRleHQsIGdldExhYmVsU3RhdGVzTW9kZWxzKGl0ZW1Nb2RlbCksIHtcbiAgICAgIGxhYmVsRmV0Y2hlcjogZGF0YS5ob3N0TW9kZWwsXG4gICAgICBsYWJlbERhdGFJbmRleDogaWR4LFxuICAgICAgZGVmYXVsdE9wYWNpdHk6IHN0eWxlLm9wYWNpdHksXG4gICAgICBkZWZhdWx0VGV4dDogZGF0YS5nZXROYW1lKGlkeClcbiAgICB9LCB7XG4gICAgICBub3JtYWw6IHtcbiAgICAgICAgYWxpZ246IGxhYmVsTGF5b3V0LnRleHRBbGlnbixcbiAgICAgICAgdmVydGljYWxBbGlnbjogbGFiZWxMYXlvdXQudmVydGljYWxBbGlnblxuICAgICAgfVxuICAgIH0pO1xuICAgIHBvbHlnb24uc2V0VGV4dENvbmZpZyh7XG4gICAgICBsb2NhbDogdHJ1ZSxcbiAgICAgIGluc2lkZTogISFsYWJlbExheW91dC5pbnNpZGUsXG4gICAgICBpbnNpZGVTdHJva2U6IHZpc3VhbENvbG9yLFxuICAgICAgLy8gaW5zaWRlRmlsbDogJ2F1dG8nLFxuICAgICAgb3V0c2lkZUZpbGw6IHZpc3VhbENvbG9yXG4gICAgfSk7XG4gICAgdmFyIGxpbmVQb2ludHMgPSBsYWJlbExheW91dC5saW5lUG9pbnRzO1xuICAgIGxhYmVsTGluZS5zZXRTaGFwZSh7XG4gICAgICBwb2ludHM6IGxpbmVQb2ludHNcbiAgICB9KTtcbiAgICBwb2x5Z29uLnRleHRHdWlkZUxpbmVDb25maWcgPSB7XG4gICAgICBhbmNob3I6IGxpbmVQb2ludHMgPyBuZXcgZ3JhcGhpYy5Qb2ludChsaW5lUG9pbnRzWzBdWzBdLCBsaW5lUG9pbnRzWzBdWzFdKSA6IG51bGxcbiAgICB9OyAvLyBNYWtlIHN1cmUgdXBkYXRlIHN0eWxlIG9uIGxhYmVsVGV4dCBhZnRlciBzZXRMYWJlbFN0eWxlLlxuICAgIC8vIEJlY2F1c2Ugc2V0TGFiZWxTdHlsZSB3aWxsIHJlcGxhY2UgYSBuZXcgc3R5bGUgb24gaXQuXG5cbiAgICBncmFwaGljLnVwZGF0ZVByb3BzKGxhYmVsVGV4dCwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgeDogbGFiZWxMYXlvdXQueCxcbiAgICAgICAgeTogbGFiZWxMYXlvdXQueVxuICAgICAgfVxuICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICAgIGxhYmVsVGV4dC5hdHRyKHtcbiAgICAgIHJvdGF0aW9uOiBsYWJlbExheW91dC5yb3RhdGlvbixcbiAgICAgIG9yaWdpblg6IGxhYmVsTGF5b3V0LngsXG4gICAgICBvcmlnaW5ZOiBsYWJlbExheW91dC55LFxuICAgICAgejI6IDEwXG4gICAgfSk7XG4gICAgc2V0TGFiZWxMaW5lU3R5bGUocG9seWdvbiwgZ2V0TGFiZWxMaW5lU3RhdGVzTW9kZWxzKGl0ZW1Nb2RlbCksIHtcbiAgICAgIC8vIERlZmF1bHQgdXNlIGl0ZW0gdmlzdWFsIGNvbG9yXG4gICAgICBzdHJva2U6IHZpc3VhbENvbG9yXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEZ1bm5lbFBpZWNlO1xufShncmFwaGljLlBvbHlnb24pO1xuXG52YXIgRnVubmVsVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhGdW5uZWxWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEZ1bm5lbFZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gRnVubmVsVmlldy50eXBlO1xuICAgIF90aGlzLmlnbm9yZUxhYmVsTGluZVVwZGF0ZSA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgRnVubmVsVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICBkYXRhLmRpZmYob2xkRGF0YSkuYWRkKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBmdW5uZWxQaWVjZSA9IG5ldyBGdW5uZWxQaWVjZShkYXRhLCBpZHgpO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgZnVubmVsUGllY2UpO1xuICAgICAgZ3JvdXAuYWRkKGZ1bm5lbFBpZWNlKTtcbiAgICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgICB2YXIgcGllY2UgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICAgIHBpZWNlLnVwZGF0ZURhdGEoZGF0YSwgbmV3SWR4KTtcbiAgICAgIGdyb3VwLmFkZChwaWVjZSk7XG4gICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBwaWVjZSk7XG4gICAgfSkucmVtb3ZlKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBwaWVjZSA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpO1xuICAgICAgZ3JhcGhpYy5yZW1vdmVFbGVtZW50V2l0aEZhZGVPdXQocGllY2UsIHNlcmllc01vZGVsLCBpZHgpO1xuICAgIH0pLmV4ZWN1dGUoKTtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfTtcblxuICBGdW5uZWxWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgfTtcblxuICBGdW5uZWxWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG5cbiAgRnVubmVsVmlldy50eXBlID0gJ2Z1bm5lbCc7XG4gIHJldHVybiBGdW5uZWxWaWV3O1xufShDaGFydFZpZXcpO1xuXG5leHBvcnQgZGVmYXVsdCBGdW5uZWxWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgKiBhcyBsYXlvdXQgZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQnO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50LCBsaW5lYXJNYXAgfSBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG5cbmZ1bmN0aW9uIGdldFZpZXdSZWN0KHNlcmllc01vZGVsLCBhcGkpIHtcbiAgcmV0dXJuIGxheW91dC5nZXRMYXlvdXRSZWN0KHNlcmllc01vZGVsLmdldEJveExheW91dFBhcmFtcygpLCB7XG4gICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTb3J0ZWRJbmRpY2VzKGRhdGEsIHNvcnQpIHtcbiAgdmFyIHZhbHVlRGltID0gZGF0YS5tYXBEaW1lbnNpb24oJ3ZhbHVlJyk7XG4gIHZhciB2YWx1ZUFyciA9IGRhdGEubWFwQXJyYXkodmFsdWVEaW0sIGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9KTtcbiAgdmFyIGluZGljZXMgPSBbXTtcbiAgdmFyIGlzQXNjZW5kaW5nID0gc29ydCA9PT0gJ2FzY2VuZGluZyc7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaW5kaWNlc1tpXSA9IGk7XG4gIH0gLy8gQWRkIGN1c3RvbSBzb3J0YWJsZSBmdW5jdGlvbiAmIG5vbmUgc29ydGFibGUgb3BldGlvbiBieSBcIm9wdGlvbnMuc29ydFwiXG5cblxuICBpZiAodHlwZW9mIHNvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbmRpY2VzLnNvcnQoc29ydCk7XG4gIH0gZWxzZSBpZiAoc29ydCAhPT0gJ25vbmUnKSB7XG4gICAgaW5kaWNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gaXNBc2NlbmRpbmcgPyB2YWx1ZUFyclthXSAtIHZhbHVlQXJyW2JdIDogdmFsdWVBcnJbYl0gLSB2YWx1ZUFyclthXTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBpbmRpY2VzO1xufVxuXG5mdW5jdGlvbiBsYWJlbExheW91dChkYXRhKSB7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICB2YXIgb3JpZW50ID0gc2VyaWVzTW9kZWwuZ2V0KCdvcmllbnQnKTtcbiAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICB2YXIgbGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwnKTtcbiAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgIHZhciBsYWJlbExpbmVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWxMaW5lJyk7XG4gICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgIHZhciBwb2ludHMgPSBsYXlvdXQucG9pbnRzO1xuICAgIHZhciBpc0xhYmVsSW5zaWRlID0gbGFiZWxQb3NpdGlvbiA9PT0gJ2lubmVyJyB8fCBsYWJlbFBvc2l0aW9uID09PSAnaW5zaWRlJyB8fCBsYWJlbFBvc2l0aW9uID09PSAnY2VudGVyJyB8fCBsYWJlbFBvc2l0aW9uID09PSAnaW5zaWRlTGVmdCcgfHwgbGFiZWxQb3NpdGlvbiA9PT0gJ2luc2lkZVJpZ2h0JztcbiAgICB2YXIgdGV4dEFsaWduO1xuICAgIHZhciB0ZXh0WDtcbiAgICB2YXIgdGV4dFk7XG4gICAgdmFyIGxpbmVQb2ludHM7XG5cbiAgICBpZiAoaXNMYWJlbEluc2lkZSkge1xuICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT09ICdpbnNpZGVMZWZ0Jykge1xuICAgICAgICB0ZXh0WCA9IChwb2ludHNbMF1bMF0gKyBwb2ludHNbM11bMF0pIC8gMiArIDU7XG4gICAgICAgIHRleHRZID0gKHBvaW50c1swXVsxXSArIHBvaW50c1szXVsxXSkgLyAyO1xuICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICB9IGVsc2UgaWYgKGxhYmVsUG9zaXRpb24gPT09ICdpbnNpZGVSaWdodCcpIHtcbiAgICAgICAgdGV4dFggPSAocG9pbnRzWzFdWzBdICsgcG9pbnRzWzJdWzBdKSAvIDIgLSA1O1xuICAgICAgICB0ZXh0WSA9IChwb2ludHNbMV1bMV0gKyBwb2ludHNbMl1bMV0pIC8gMjtcbiAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHRYID0gKHBvaW50c1swXVswXSArIHBvaW50c1sxXVswXSArIHBvaW50c1syXVswXSArIHBvaW50c1szXVswXSkgLyA0O1xuICAgICAgICB0ZXh0WSA9IChwb2ludHNbMF1bMV0gKyBwb2ludHNbMV1bMV0gKyBwb2ludHNbMl1bMV0gKyBwb2ludHNbM11bMV0pIC8gNDtcbiAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB9XG5cbiAgICAgIGxpbmVQb2ludHMgPSBbW3RleHRYLCB0ZXh0WV0sIFt0ZXh0WCwgdGV4dFldXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHgxID0gdm9pZCAwO1xuICAgICAgdmFyIHkxID0gdm9pZCAwO1xuICAgICAgdmFyIHgyID0gdm9pZCAwO1xuICAgICAgdmFyIHkyID0gdm9pZCAwO1xuICAgICAgdmFyIGxhYmVsTGluZUxlbiA9IGxhYmVsTGluZU1vZGVsLmdldCgnbGVuZ3RoJyk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChvcmllbnQgPT09ICd2ZXJ0aWNhbCcgJiYgWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihsYWJlbFBvc2l0aW9uKSA+IC0xKSB7XG4gICAgICAgICAgbGFiZWxQb3NpdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Bvc2l0aW9uIGVycm9yOiBGdW5uZWwgY2hhcnQgb24gdmVydGljYWwgb3JpZW50IGRvc2Ugbm90IHN1cHBvcnQgdG9wIGFuZCBib3R0b20uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcgJiYgWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihsYWJlbFBvc2l0aW9uKSA+IC0xKSB7XG4gICAgICAgICAgbGFiZWxQb3NpdGlvbiA9ICdib3R0b20nO1xuICAgICAgICAgIGNvbnNvbGUud2FybignUG9zaXRpb24gZXJyb3I6IEZ1bm5lbCBjaGFydCBvbiBob3Jpem9udGFsIG9yaWVudCBkb3NlIG5vdCBzdXBwb3J0IGxlZnQgYW5kIHJpZ2h0LicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgLy8gTGVmdCBzaWRlXG4gICAgICAgIHgxID0gKHBvaW50c1szXVswXSArIHBvaW50c1swXVswXSkgLyAyO1xuICAgICAgICB5MSA9IChwb2ludHNbM11bMV0gKyBwb2ludHNbMF1bMV0pIC8gMjtcbiAgICAgICAgeDIgPSB4MSAtIGxhYmVsTGluZUxlbjtcbiAgICAgICAgdGV4dFggPSB4MiAtIDU7XG4gICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICB9IGVsc2UgaWYgKGxhYmVsUG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgLy8gUmlnaHQgc2lkZVxuICAgICAgICB4MSA9IChwb2ludHNbMV1bMF0gKyBwb2ludHNbMl1bMF0pIC8gMjtcbiAgICAgICAgeTEgPSAocG9pbnRzWzFdWzFdICsgcG9pbnRzWzJdWzFdKSAvIDI7XG4gICAgICAgIHgyID0geDEgKyBsYWJlbExpbmVMZW47XG4gICAgICAgIHRleHRYID0geDIgKyA1O1xuICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICB9IGVsc2UgaWYgKGxhYmVsUG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgIC8vIFRvcCBzaWRlXG4gICAgICAgIHgxID0gKHBvaW50c1szXVswXSArIHBvaW50c1swXVswXSkgLyAyO1xuICAgICAgICB5MSA9IChwb2ludHNbM11bMV0gKyBwb2ludHNbMF1bMV0pIC8gMjtcbiAgICAgICAgeTIgPSB5MSAtIGxhYmVsTGluZUxlbjtcbiAgICAgICAgdGV4dFkgPSB5MiAtIDU7XG4gICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgfSBlbHNlIGlmIChsYWJlbFBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICAvLyBCb3R0b20gc2lkZVxuICAgICAgICB4MSA9IChwb2ludHNbMV1bMF0gKyBwb2ludHNbMl1bMF0pIC8gMjtcbiAgICAgICAgeTEgPSAocG9pbnRzWzFdWzFdICsgcG9pbnRzWzJdWzFdKSAvIDI7XG4gICAgICAgIHkyID0geTEgKyBsYWJlbExpbmVMZW47XG4gICAgICAgIHRleHRZID0geTIgKyA1O1xuICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIH0gZWxzZSBpZiAobGFiZWxQb3NpdGlvbiA9PT0gJ3JpZ2h0VG9wJykge1xuICAgICAgICAvLyBSaWdodFRvcCBzaWRlXG4gICAgICAgIHgxID0gb3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyBwb2ludHNbM11bMF0gOiBwb2ludHNbMV1bMF07XG4gICAgICAgIHkxID0gb3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyBwb2ludHNbM11bMV0gOiBwb2ludHNbMV1bMV07XG5cbiAgICAgICAgaWYgKG9yaWVudCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgeTIgPSB5MSAtIGxhYmVsTGluZUxlbjtcbiAgICAgICAgICB0ZXh0WSA9IHkyIC0gNTtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4MiA9IHgxICsgbGFiZWxMaW5lTGVuO1xuICAgICAgICAgIHRleHRYID0geDIgKyA1O1xuICAgICAgICAgIHRleHRBbGlnbiA9ICd0b3AnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxhYmVsUG9zaXRpb24gPT09ICdyaWdodEJvdHRvbScpIHtcbiAgICAgICAgLy8gUmlnaHRCb3R0b20gc2lkZVxuICAgICAgICB4MSA9IHBvaW50c1syXVswXTtcbiAgICAgICAgeTEgPSBwb2ludHNbMl1bMV07XG5cbiAgICAgICAgaWYgKG9yaWVudCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgeTIgPSB5MSArIGxhYmVsTGluZUxlbjtcbiAgICAgICAgICB0ZXh0WSA9IHkyICsgNTtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4MiA9IHgxICsgbGFiZWxMaW5lTGVuO1xuICAgICAgICAgIHRleHRYID0geDIgKyA1O1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdib3R0b20nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxhYmVsUG9zaXRpb24gPT09ICdsZWZ0VG9wJykge1xuICAgICAgICAvLyBMZWZ0VG9wIHNpZGVcbiAgICAgICAgeDEgPSBwb2ludHNbMF1bMF07XG4gICAgICAgIHkxID0gb3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyBwb2ludHNbMF1bMV0gOiBwb2ludHNbMV1bMV07XG5cbiAgICAgICAgaWYgKG9yaWVudCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgeTIgPSB5MSAtIGxhYmVsTGluZUxlbjtcbiAgICAgICAgICB0ZXh0WSA9IHkyIC0gNTtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4MiA9IHgxIC0gbGFiZWxMaW5lTGVuO1xuICAgICAgICAgIHRleHRYID0geDIgLSA1O1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobGFiZWxQb3NpdGlvbiA9PT0gJ2xlZnRCb3R0b20nKSB7XG4gICAgICAgIC8vIExlZnRCb3R0b20gc2lkZVxuICAgICAgICB4MSA9IG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gcG9pbnRzWzFdWzBdIDogcG9pbnRzWzNdWzBdO1xuICAgICAgICB5MSA9IG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gcG9pbnRzWzFdWzFdIDogcG9pbnRzWzJdWzFdO1xuXG4gICAgICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgIHkyID0geTEgKyBsYWJlbExpbmVMZW47XG4gICAgICAgICAgdGV4dFkgPSB5MiArIDU7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeDIgPSB4MSAtIGxhYmVsTGluZUxlbjtcbiAgICAgICAgICB0ZXh0WCA9IHgyIC0gNTtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSaWdodCBzaWRlIG9yIEJvdHRvbSBzaWRlXG4gICAgICAgIHgxID0gKHBvaW50c1sxXVswXSArIHBvaW50c1syXVswXSkgLyAyO1xuICAgICAgICB5MSA9IChwb2ludHNbMV1bMV0gKyBwb2ludHNbMl1bMV0pIC8gMjtcblxuICAgICAgICBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICB5MiA9IHkxICsgbGFiZWxMaW5lTGVuO1xuICAgICAgICAgIHRleHRZID0geTIgKyA1O1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHgyID0geDEgKyBsYWJlbExpbmVMZW47XG4gICAgICAgICAgdGV4dFggPSB4MiArIDU7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICB4MiA9IHgxO1xuICAgICAgICB0ZXh0WCA9IHgyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTIgPSB5MTtcbiAgICAgICAgdGV4dFkgPSB5MjtcbiAgICAgIH1cblxuICAgICAgbGluZVBvaW50cyA9IFtbeDEsIHkxXSwgW3gyLCB5Ml1dO1xuICAgIH1cblxuICAgIGxheW91dC5sYWJlbCA9IHtcbiAgICAgIGxpbmVQb2ludHM6IGxpbmVQb2ludHMsXG4gICAgICB4OiB0ZXh0WCxcbiAgICAgIHk6IHRleHRZLFxuICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgIGluc2lkZTogaXNMYWJlbEluc2lkZVxuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5uZWxMYXlvdXQoZWNNb2RlbCwgYXBpKSB7XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgnZnVubmVsJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHZhbHVlRGltID0gZGF0YS5tYXBEaW1lbnNpb24oJ3ZhbHVlJyk7XG4gICAgdmFyIHNvcnQgPSBzZXJpZXNNb2RlbC5nZXQoJ3NvcnQnKTtcbiAgICB2YXIgdmlld1JlY3QgPSBnZXRWaWV3UmVjdChzZXJpZXNNb2RlbCwgYXBpKTtcbiAgICB2YXIgb3JpZW50ID0gc2VyaWVzTW9kZWwuZ2V0KCdvcmllbnQnKTtcbiAgICB2YXIgdmlld1dpZHRoID0gdmlld1JlY3Qud2lkdGg7XG4gICAgdmFyIHZpZXdIZWlnaHQgPSB2aWV3UmVjdC5oZWlnaHQ7XG4gICAgdmFyIGluZGljZXMgPSBnZXRTb3J0ZWRJbmRpY2VzKGRhdGEsIHNvcnQpO1xuICAgIHZhciB4ID0gdmlld1JlY3QueDtcbiAgICB2YXIgeSA9IHZpZXdSZWN0Lnk7XG4gICAgdmFyIHNpemVFeHRlbnQgPSBvcmllbnQgPT09ICdob3Jpem9udGFsJyA/IFtwYXJzZVBlcmNlbnQoc2VyaWVzTW9kZWwuZ2V0KCdtaW5TaXplJyksIHZpZXdIZWlnaHQpLCBwYXJzZVBlcmNlbnQoc2VyaWVzTW9kZWwuZ2V0KCdtYXhTaXplJyksIHZpZXdIZWlnaHQpXSA6IFtwYXJzZVBlcmNlbnQoc2VyaWVzTW9kZWwuZ2V0KCdtaW5TaXplJyksIHZpZXdXaWR0aCksIHBhcnNlUGVyY2VudChzZXJpZXNNb2RlbC5nZXQoJ21heFNpemUnKSwgdmlld1dpZHRoKV07XG4gICAgdmFyIGRhdGFFeHRlbnQgPSBkYXRhLmdldERhdGFFeHRlbnQodmFsdWVEaW0pO1xuICAgIHZhciBtaW4gPSBzZXJpZXNNb2RlbC5nZXQoJ21pbicpO1xuICAgIHZhciBtYXggPSBzZXJpZXNNb2RlbC5nZXQoJ21heCcpO1xuXG4gICAgaWYgKG1pbiA9PSBudWxsKSB7XG4gICAgICBtaW4gPSBNYXRoLm1pbihkYXRhRXh0ZW50WzBdLCAwKTtcbiAgICB9XG5cbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IGRhdGFFeHRlbnRbMV07XG4gICAgfVxuXG4gICAgdmFyIGZ1bm5lbEFsaWduID0gc2VyaWVzTW9kZWwuZ2V0KCdmdW5uZWxBbGlnbicpO1xuICAgIHZhciBnYXAgPSBzZXJpZXNNb2RlbC5nZXQoJ2dhcCcpO1xuICAgIHZhciB2aWV3U2l6ZSA9IG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gdmlld1dpZHRoIDogdmlld0hlaWdodDtcbiAgICB2YXIgaXRlbVNpemUgPSAodmlld1NpemUgLSBnYXAgKiAoZGF0YS5jb3VudCgpIC0gMSkpIC8gZGF0YS5jb3VudCgpO1xuXG4gICAgdmFyIGdldExpbmVQb2ludHMgPSBmdW5jdGlvbiAoaWR4LCBvZmZzZXQpIHtcbiAgICAgIC8vIEVuZCBwb2ludCBpbmRleCBpcyBkYXRhLmNvdW50KCkgYW5kIHdlIGFzc2lnbiBpdCAwXG4gICAgICBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgdmFyIHZhbF8xID0gZGF0YS5nZXQodmFsdWVEaW0sIGlkeCkgfHwgMDtcbiAgICAgICAgdmFyIGl0ZW1IZWlnaHQgPSBsaW5lYXJNYXAodmFsXzEsIFttaW4sIG1heF0sIHNpemVFeHRlbnQsIHRydWUpO1xuICAgICAgICB2YXIgeTAgPSB2b2lkIDA7XG5cbiAgICAgICAgc3dpdGNoIChmdW5uZWxBbGlnbikge1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICB5MCA9IHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICB5MCA9IHkgKyAodmlld0hlaWdodCAtIGl0ZW1IZWlnaHQpIC8gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHkwID0geSArICh2aWV3SGVpZ2h0IC0gaXRlbUhlaWdodCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbW29mZnNldCwgeTBdLCBbb2Zmc2V0LCB5MCArIGl0ZW1IZWlnaHRdXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbCA9IGRhdGEuZ2V0KHZhbHVlRGltLCBpZHgpIHx8IDA7XG4gICAgICB2YXIgaXRlbVdpZHRoID0gbGluZWFyTWFwKHZhbCwgW21pbiwgbWF4XSwgc2l6ZUV4dGVudCwgdHJ1ZSk7XG4gICAgICB2YXIgeDA7XG5cbiAgICAgIHN3aXRjaCAoZnVubmVsQWxpZ24pIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgeDAgPSB4O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgeDAgPSB4ICsgKHZpZXdXaWR0aCAtIGl0ZW1XaWR0aCkgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICB4MCA9IHggKyB2aWV3V2lkdGggLSBpdGVtV2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbW3gwLCBvZmZzZXRdLCBbeDAgKyBpdGVtV2lkdGgsIG9mZnNldF1dO1xuICAgIH07XG5cbiAgICBpZiAoc29ydCA9PT0gJ2FzY2VuZGluZycpIHtcbiAgICAgIC8vIEZyb20gYm90dG9tIHRvIHRvcFxuICAgICAgaXRlbVNpemUgPSAtaXRlbVNpemU7XG4gICAgICBnYXAgPSAtZ2FwO1xuXG4gICAgICBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgeCArPSB2aWV3V2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5ICs9IHZpZXdIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGluZGljZXMgPSBpbmRpY2VzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZHggPSBpbmRpY2VzW2ldO1xuICAgICAgdmFyIG5leHRJZHggPSBpbmRpY2VzW2kgKyAxXTtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuXG4gICAgICBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gaXRlbU1vZGVsLmdldChbJ2l0ZW1TdHlsZScsICd3aWR0aCddKTtcblxuICAgICAgICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgIHdpZHRoID0gaXRlbVNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2lkdGggPSBwYXJzZVBlcmNlbnQod2lkdGgsIHZpZXdXaWR0aCk7XG5cbiAgICAgICAgICBpZiAoc29ydCA9PT0gJ2FzY2VuZGluZycpIHtcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydCA9IGdldExpbmVQb2ludHMoaWR4LCB4KTtcbiAgICAgICAgdmFyIGVuZCA9IGdldExpbmVQb2ludHMobmV4dElkeCwgeCArIHdpZHRoKTtcbiAgICAgICAgeCArPSB3aWR0aCArIGdhcDtcbiAgICAgICAgZGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwge1xuICAgICAgICAgIHBvaW50czogc3RhcnQuY29uY2F0KGVuZC5zbGljZSgpLnJldmVyc2UoKSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gaXRlbU1vZGVsLmdldChbJ2l0ZW1TdHlsZScsICdoZWlnaHQnXSk7XG5cbiAgICAgICAgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgaGVpZ2h0ID0gaXRlbVNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVpZ2h0ID0gcGFyc2VQZXJjZW50KGhlaWdodCwgdmlld0hlaWdodCk7XG5cbiAgICAgICAgICBpZiAoc29ydCA9PT0gJ2FzY2VuZGluZycpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gZ2V0TGluZVBvaW50cyhpZHgsIHkpO1xuICAgICAgICB2YXIgZW5kID0gZ2V0TGluZVBvaW50cyhuZXh0SWR4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgeSArPSBoZWlnaHQgKyBnYXA7XG4gICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHtcbiAgICAgICAgICBwb2ludHM6IHN0YXJ0LmNvbmNhdChlbmQuc2xpY2UoKS5yZXZlcnNlKCkpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhYmVsTGF5b3V0KGRhdGEpO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IEZ1bm5lbFZpZXcgZnJvbSAnLi9GdW5uZWxWaWV3JztcbmltcG9ydCBGdW5uZWxTZXJpZXNNb2RlbCBmcm9tICcuL0Z1bm5lbFNlcmllcyc7XG5pbXBvcnQgZnVubmVsTGF5b3V0IGZyb20gJy4vZnVubmVsTGF5b3V0JztcbmltcG9ydCBkYXRhRmlsdGVyIGZyb20gJy4uLy4uL3Byb2Nlc3Nvci9kYXRhRmlsdGVyJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDaGFydFZpZXcoRnVubmVsVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclNlcmllc01vZGVsKEZ1bm5lbFNlcmllc01vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KGZ1bm5lbExheW91dCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByb2Nlc3NvcihkYXRhRmlsdGVyKCdmdW5uZWwnKSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IGNyZWF0ZUxpc3RTaW1wbHkgZnJvbSAnLi4vaGVscGVyL2NyZWF0ZUxpc3RTaW1wbHknO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcyc7XG5cbnZhciBHYXVnZVNlcmllc01vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEdhdWdlU2VyaWVzTW9kZWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gR2F1Z2VTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBHYXVnZVNlcmllc01vZGVsLnR5cGU7XG4gICAgX3RoaXMudmlzdWFsU3R5bGVBY2Nlc3NQYXRoID0gJ2l0ZW1TdHlsZSc7XG4gICAgX3RoaXMudXNlQ29sb3JQYWxldHRlT25EYXRhID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBHYXVnZVNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YSA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICByZXR1cm4gY3JlYXRlTGlzdFNpbXBseSh0aGlzLCBbJ3ZhbHVlJ10pO1xuICB9O1xuXG4gIEdhdWdlU2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMuZ2F1Z2UnO1xuICBHYXVnZVNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgLy8g6buY6K6k5YWo5bGA5bGF5LitXG4gICAgY2VudGVyOiBbJzUwJScsICc1MCUnXSxcbiAgICBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG4gICAgcmFkaXVzOiAnNzUlJyxcbiAgICBzdGFydEFuZ2xlOiAyMjUsXG4gICAgZW5kQW5nbGU6IC00NSxcbiAgICBjbG9ja3dpc2U6IHRydWUsXG4gICAgLy8g5pyA5bCP5YC8XG4gICAgbWluOiAwLFxuICAgIC8vIOacgOWkp+WAvFxuICAgIG1heDogMTAwLFxuICAgIC8vIOWIhuWJsuauteaVsO+8jOm7mOiupOS4ujEwXG4gICAgc3BsaXROdW1iZXI6IDEwLFxuICAgIC8vIOWdkOagh+i9tOe6v1xuICAgIGF4aXNMaW5lOiB7XG4gICAgICAvLyDpu5jorqTmmL7npLrvvIzlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCmXG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgcm91bmRDYXA6IGZhbHNlLFxuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiBbWzEsICcjRTZFQkY4J11dLFxuICAgICAgICB3aWR0aDogMTBcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIOWdkOagh+i9tOe6v1xuICAgIHByb2dyZXNzOiB7XG4gICAgICAvLyDpu5jorqTmmL7npLrvvIzlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCmXG4gICAgICBzaG93OiBmYWxzZSxcbiAgICAgIG92ZXJsYXA6IHRydWUsXG4gICAgICB3aWR0aDogMTAsXG4gICAgICByb3VuZENhcDogZmFsc2UsXG4gICAgICBjbGlwOiB0cnVlXG4gICAgfSxcbiAgICAvLyDliIbpmpTnur9cbiAgICBzcGxpdExpbmU6IHtcbiAgICAgIC8vIOm7mOiupOaYvuekuu+8jOWxnuaAp3Nob3fmjqfliLbmmL7npLrkuI7lkKZcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICAvLyDlsZ7mgKdsZW5ndGjmjqfliLbnur/plb9cbiAgICAgIGxlbmd0aDogMTAsXG4gICAgICBkaXN0YW5jZTogMTAsXG4gICAgICAvLyDlsZ7mgKdsaW5lU3R5bGXvvIjor6bop4FsaW5lU3R5bGXvvInmjqfliLbnur/mnaHmoLflvI9cbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBjb2xvcjogJyM2MzY3N0EnLFxuICAgICAgICB3aWR0aDogMyxcbiAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8g5Z2Q5qCH6L205bCP5qCH6K6wXG4gICAgYXhpc1RpY2s6IHtcbiAgICAgIC8vIOWxnuaAp3Nob3fmjqfliLbmmL7npLrkuI7lkKbvvIzpu5jorqTkuI3mmL7npLpcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICAvLyDmr4/ku71zcGxpdOe7huWIhuWkmuWwkeautVxuICAgICAgc3BsaXROdW1iZXI6IDUsXG4gICAgICAvLyDlsZ7mgKdsZW5ndGjmjqfliLbnur/plb9cbiAgICAgIGxlbmd0aDogNixcbiAgICAgIGRpc3RhbmNlOiAxMCxcbiAgICAgIC8vIOWxnuaAp2xpbmVTdHlsZeaOp+WItue6v+adoeagt+W8j1xuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAnIzYzNjc3QScsXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICB0eXBlOiAnc29saWQnXG4gICAgICB9XG4gICAgfSxcbiAgICBheGlzTGFiZWw6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBkaXN0YW5jZTogMTUsXG4gICAgICAvLyBmb3JtYXR0ZXI6IG51bGwsXG4gICAgICBjb2xvcjogJyM0NjQ2NDYnLFxuICAgICAgZm9udFNpemU6IDEyXG4gICAgfSxcbiAgICBwb2ludGVyOiB7XG4gICAgICBpY29uOiBudWxsLFxuICAgICAgb2Zmc2V0Q2VudGVyOiBbMCwgMF0sXG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgbGVuZ3RoOiAnNjAlJyxcbiAgICAgIHdpZHRoOiA2LFxuICAgICAga2VlcEFzcGVjdDogZmFsc2VcbiAgICB9LFxuICAgIGFuY2hvcjoge1xuICAgICAgc2hvdzogZmFsc2UsXG4gICAgICBzaG93QWJvdmU6IGZhbHNlLFxuICAgICAgc2l6ZTogNixcbiAgICAgIGljb246ICdjaXJjbGUnLFxuICAgICAgb2Zmc2V0Q2VudGVyOiBbMCwgMF0sXG4gICAgICBrZWVwQXNwZWN0OiBmYWxzZSxcbiAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjNTQ3MGM2J1xuICAgICAgfVxuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICAvLyB4LCB577yM5Y2V5L2NcHhcbiAgICAgIG9mZnNldENlbnRlcjogWzAsICcyMCUnXSxcbiAgICAgIC8vIOWFtuS9meWxnuaAp+m7mOiupOS9v+eUqOWFqOWxgOaWh+acrOagt+W8j++8jOivpuingVRFWFRTVFlMRVxuICAgICAgY29sb3I6ICcjNDY0NjQ2JyxcbiAgICAgIGZvbnRTaXplOiAxNixcbiAgICAgIHZhbHVlQW5pbWF0aW9uOiBmYWxzZVxuICAgIH0sXG4gICAgZGV0YWlsOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgICB3aWR0aDogMTAwLFxuICAgICAgaGVpZ2h0OiBudWxsLFxuICAgICAgcGFkZGluZzogWzUsIDEwXSxcbiAgICAgIC8vIHgsIHnvvIzljZXkvY1weFxuICAgICAgb2Zmc2V0Q2VudGVyOiBbMCwgJzQwJSddLFxuICAgICAgLy8gZm9ybWF0dGVyOiBudWxsLFxuICAgICAgLy8g5YW25L2Z5bGe5oCn6buY6K6k5L2/55So5YWo5bGA5paH5pys5qC35byP77yM6K+m6KeBVEVYVFNUWUxFXG4gICAgICBjb2xvcjogJyM0NjQ2NDYnLFxuICAgICAgZm9udFNpemU6IDMwLFxuICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgbGluZUhlaWdodDogMzAsXG4gICAgICB2YWx1ZUFuaW1hdGlvbjogZmFsc2VcbiAgICB9XG4gIH07XG4gIHJldHVybiBHYXVnZVNlcmllc01vZGVsO1xufShTZXJpZXNNb2RlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IEdhdWdlU2VyaWVzTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFBvaW50ZXJQYXRoIGZyb20gJy4vUG9pbnRlclBhdGgnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IHsgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsLCBlbmFibGVIb3ZlckVtcGhhc2lzIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMnO1xuaW1wb3J0IHsgY3JlYXRlVGV4dFN0eWxlLCBzZXRMYWJlbFZhbHVlQW5pbWF0aW9uLCBhbmltYXRlTGFiZWxWYWx1ZSB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0JztcbmltcG9ydCB7IHBhcnNlUGVyY2VudCwgcm91bmQsIGxpbmVhck1hcCB9IGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyJztcbmltcG9ydCBTYXVzYWdlIGZyb20gJy4uLy4uL3V0aWwvc2hhcGUvc2F1c2FnZSc7XG5pbXBvcnQgeyBjcmVhdGVTeW1ib2wgfSBmcm9tICcuLi8uLi91dGlsL3N5bWJvbCc7XG5cbmZ1bmN0aW9uIHBhcnNlUG9zaXRpb24oc2VyaWVzTW9kZWwsIGFwaSkge1xuICB2YXIgY2VudGVyID0gc2VyaWVzTW9kZWwuZ2V0KCdjZW50ZXInKTtcbiAgdmFyIHdpZHRoID0gYXBpLmdldFdpZHRoKCk7XG4gIHZhciBoZWlnaHQgPSBhcGkuZ2V0SGVpZ2h0KCk7XG4gIHZhciBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gIHZhciBjeCA9IHBhcnNlUGVyY2VudChjZW50ZXJbMF0sIGFwaS5nZXRXaWR0aCgpKTtcbiAgdmFyIGN5ID0gcGFyc2VQZXJjZW50KGNlbnRlclsxXSwgYXBpLmdldEhlaWdodCgpKTtcbiAgdmFyIHIgPSBwYXJzZVBlcmNlbnQoc2VyaWVzTW9kZWwuZ2V0KCdyYWRpdXMnKSwgc2l6ZSAvIDIpO1xuICByZXR1cm4ge1xuICAgIGN4OiBjeCxcbiAgICBjeTogY3ksXG4gICAgcjogclxuICB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRMYWJlbCh2YWx1ZSwgbGFiZWxGb3JtYXR0ZXIpIHtcbiAgdmFyIGxhYmVsID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUgKyAnJztcblxuICBpZiAobGFiZWxGb3JtYXR0ZXIpIHtcbiAgICBpZiAodHlwZW9mIGxhYmVsRm9ybWF0dGVyID09PSAnc3RyaW5nJykge1xuICAgICAgbGFiZWwgPSBsYWJlbEZvcm1hdHRlci5yZXBsYWNlKCd7dmFsdWV9JywgbGFiZWwpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxhYmVsRm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBsYWJlbCA9IGxhYmVsRm9ybWF0dGVyKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGFiZWw7XG59XG5cbnZhciBQSTIgPSBNYXRoLlBJICogMjtcblxudmFyIEdhdWdlVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhHYXVnZVZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gR2F1Z2VWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IEdhdWdlVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEdhdWdlVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHZhciBjb2xvckxpc3QgPSBzZXJpZXNNb2RlbC5nZXQoWydheGlzTGluZScsICdsaW5lU3R5bGUnLCAnY29sb3InXSk7XG4gICAgdmFyIHBvc0luZm8gPSBwYXJzZVBvc2l0aW9uKHNlcmllc01vZGVsLCBhcGkpO1xuXG4gICAgdGhpcy5fcmVuZGVyTWFpbihzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBjb2xvckxpc3QsIHBvc0luZm8pO1xuXG4gICAgdGhpcy5fZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgfTtcblxuICBHYXVnZVZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBHYXVnZVZpZXcucHJvdG90eXBlLl9yZW5kZXJNYWluID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIGNvbG9yTGlzdCwgcG9zSW5mbykge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGNsb2Nrd2lzZSA9IHNlcmllc01vZGVsLmdldCgnY2xvY2t3aXNlJyk7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSAtc2VyaWVzTW9kZWwuZ2V0KCdzdGFydEFuZ2xlJykgLyAxODAgKiBNYXRoLlBJO1xuICAgIHZhciBlbmRBbmdsZSA9IC1zZXJpZXNNb2RlbC5nZXQoJ2VuZEFuZ2xlJykgLyAxODAgKiBNYXRoLlBJO1xuICAgIHZhciBheGlzTGluZU1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNMaW5lJyk7XG4gICAgdmFyIHJvdW5kQ2FwID0gYXhpc0xpbmVNb2RlbC5nZXQoJ3JvdW5kQ2FwJyk7XG4gICAgdmFyIE1haW5QYXRoID0gcm91bmRDYXAgPyBTYXVzYWdlIDogZ3JhcGhpYy5TZWN0b3I7XG4gICAgdmFyIHNob3dBeGlzID0gYXhpc0xpbmVNb2RlbC5nZXQoJ3Nob3cnKTtcbiAgICB2YXIgbGluZVN0eWxlTW9kZWwgPSBheGlzTGluZU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgICB2YXIgYXhpc0xpbmVXaWR0aCA9IGxpbmVTdHlsZU1vZGVsLmdldCgnd2lkdGgnKTtcbiAgICB2YXIgYW5nbGVSYW5nZVNwYW4gPSAhKChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpICUgUEkyKSAmJiBlbmRBbmdsZSAhPT0gc3RhcnRBbmdsZSA/IFBJMiA6IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpICUgUEkyO1xuICAgIHZhciBwcmV2RW5kQW5nbGUgPSBzdGFydEFuZ2xlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IHNob3dBeGlzICYmIGkgPCBjb2xvckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIENsYW1wXG4gICAgICB2YXIgcGVyY2VudCA9IE1hdGgubWluKE1hdGgubWF4KGNvbG9yTGlzdFtpXVswXSwgMCksIDEpO1xuICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgYW5nbGVSYW5nZVNwYW4gKiBwZXJjZW50O1xuICAgICAgdmFyIHNlY3RvciA9IG5ldyBNYWluUGF0aCh7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgc3RhcnRBbmdsZTogcHJldkVuZEFuZ2xlLFxuICAgICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcbiAgICAgICAgICBjeDogcG9zSW5mby5jeCxcbiAgICAgICAgICBjeTogcG9zSW5mby5jeSxcbiAgICAgICAgICBjbG9ja3dpc2U6IGNsb2Nrd2lzZSxcbiAgICAgICAgICByMDogcG9zSW5mby5yIC0gYXhpc0xpbmVXaWR0aCxcbiAgICAgICAgICByOiBwb3NJbmZvLnJcbiAgICAgICAgfSxcbiAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHNlY3Rvci5zZXRTdHlsZSh7XG4gICAgICAgIGZpbGw6IGNvbG9yTGlzdFtpXVsxXVxuICAgICAgfSk7XG4gICAgICBzZWN0b3Iuc2V0U3R5bGUobGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCAvLyBCZWNhdXNlIHdlIHVzZSBzZWN0b3IgdG8gc2ltdWxhdGUgYXJjXG4gICAgICAvLyBzbyB0aGUgcHJvcGVydGllcyBmb3Igc3Ryb2tpbmcgYXJlIHVzZWxlc3NcbiAgICAgIFsnY29sb3InLCAnd2lkdGgnXSkpO1xuICAgICAgZ3JvdXAuYWRkKHNlY3Rvcik7XG4gICAgICBwcmV2RW5kQW5nbGUgPSBlbmRBbmdsZTtcbiAgICB9XG5cbiAgICB2YXIgZ2V0Q29sb3IgPSBmdW5jdGlvbiAocGVyY2VudCkge1xuICAgICAgLy8gTGVzcyB0aGFuIDBcbiAgICAgIGlmIChwZXJjZW50IDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yTGlzdFswXVsxXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xvckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNvbG9yTGlzdFtpXVswXSA+PSBwZXJjZW50ICYmIChpID09PSAwID8gMCA6IGNvbG9yTGlzdFtpIC0gMV1bMF0pIDwgcGVyY2VudCkge1xuICAgICAgICAgIHJldHVybiBjb2xvckxpc3RbaV1bMV07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gTW9yZSB0aGFuIDFcblxuXG4gICAgICByZXR1cm4gY29sb3JMaXN0W2kgLSAxXVsxXTtcbiAgICB9O1xuXG4gICAgaWYgKCFjbG9ja3dpc2UpIHtcbiAgICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlO1xuICAgICAgZW5kQW5nbGUgPSB0bXA7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyVGlja3Moc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgZ2V0Q29sb3IsIHBvc0luZm8sIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbG9ja3dpc2UsIGF4aXNMaW5lV2lkdGgpO1xuXG4gICAgdGhpcy5fcmVuZGVyVGl0bGVBbmREZXRhaWwoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgZ2V0Q29sb3IsIHBvc0luZm8pO1xuXG4gICAgdGhpcy5fcmVuZGVyQW5jaG9yKHNlcmllc01vZGVsLCBwb3NJbmZvKTtcblxuICAgIHRoaXMuX3JlbmRlclBvaW50ZXIoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgZ2V0Q29sb3IsIHBvc0luZm8sIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbG9ja3dpc2UsIGF4aXNMaW5lV2lkdGgpO1xuICB9O1xuXG4gIEdhdWdlVmlldy5wcm90b3R5cGUuX3JlbmRlclRpY2tzID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIGdldENvbG9yLCBwb3NJbmZvLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2xvY2t3aXNlLCBheGlzTGluZVdpZHRoKSB7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgY3ggPSBwb3NJbmZvLmN4O1xuICAgIHZhciBjeSA9IHBvc0luZm8uY3k7XG4gICAgdmFyIHIgPSBwb3NJbmZvLnI7XG4gICAgdmFyIG1pblZhbCA9ICtzZXJpZXNNb2RlbC5nZXQoJ21pbicpO1xuICAgIHZhciBtYXhWYWwgPSArc2VyaWVzTW9kZWwuZ2V0KCdtYXgnKTtcbiAgICB2YXIgc3BsaXRMaW5lTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRMaW5lJyk7XG4gICAgdmFyIHRpY2tNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdheGlzVGljaycpO1xuICAgIHZhciBsYWJlbE1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNMYWJlbCcpO1xuICAgIHZhciBzcGxpdE51bWJlciA9IHNlcmllc01vZGVsLmdldCgnc3BsaXROdW1iZXInKTtcbiAgICB2YXIgc3ViU3BsaXROdW1iZXIgPSB0aWNrTW9kZWwuZ2V0KCdzcGxpdE51bWJlcicpO1xuICAgIHZhciBzcGxpdExpbmVMZW4gPSBwYXJzZVBlcmNlbnQoc3BsaXRMaW5lTW9kZWwuZ2V0KCdsZW5ndGgnKSwgcik7XG4gICAgdmFyIHRpY2tMZW4gPSBwYXJzZVBlcmNlbnQodGlja01vZGVsLmdldCgnbGVuZ3RoJyksIHIpO1xuICAgIHZhciBhbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgdmFyIHN0ZXAgPSAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIHNwbGl0TnVtYmVyO1xuICAgIHZhciBzdWJTdGVwID0gc3RlcCAvIHN1YlNwbGl0TnVtYmVyO1xuICAgIHZhciBzcGxpdExpbmVTdHlsZSA9IHNwbGl0TGluZU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKTtcbiAgICB2YXIgdGlja0xpbmVTdHlsZSA9IHRpY2tNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCk7XG4gICAgdmFyIHNwbGl0TGluZURpc3RhbmNlID0gc3BsaXRMaW5lTW9kZWwuZ2V0KCdkaXN0YW5jZScpO1xuICAgIHZhciB1bml0WDtcbiAgICB2YXIgdW5pdFk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBzcGxpdE51bWJlcjsgaSsrKSB7XG4gICAgICB1bml0WCA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIHVuaXRZID0gTWF0aC5zaW4oYW5nbGUpOyAvLyBTcGxpdCBsaW5lXG5cbiAgICAgIGlmIChzcGxpdExpbmVNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBzcGxpdExpbmVEaXN0YW5jZSA/IHNwbGl0TGluZURpc3RhbmNlICsgYXhpc0xpbmVXaWR0aCA6IGF4aXNMaW5lV2lkdGg7XG4gICAgICAgIHZhciBzcGxpdExpbmUgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcbiAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgeDE6IHVuaXRYICogKHIgLSBkaXN0YW5jZSkgKyBjeCxcbiAgICAgICAgICAgIHkxOiB1bml0WSAqIChyIC0gZGlzdGFuY2UpICsgY3ksXG4gICAgICAgICAgICB4MjogdW5pdFggKiAociAtIHNwbGl0TGluZUxlbiAtIGRpc3RhbmNlKSArIGN4LFxuICAgICAgICAgICAgeTI6IHVuaXRZICogKHIgLSBzcGxpdExpbmVMZW4gLSBkaXN0YW5jZSkgKyBjeVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3R5bGU6IHNwbGl0TGluZVN0eWxlLFxuICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3BsaXRMaW5lU3R5bGUuc3Ryb2tlID09PSAnYXV0bycpIHtcbiAgICAgICAgICBzcGxpdExpbmUuc2V0U3R5bGUoe1xuICAgICAgICAgICAgc3Ryb2tlOiBnZXRDb2xvcihpIC8gc3BsaXROdW1iZXIpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBncm91cC5hZGQoc3BsaXRMaW5lKTtcbiAgICAgIH0gLy8gTGFiZWxcblxuXG4gICAgICBpZiAobGFiZWxNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBsYWJlbE1vZGVsLmdldCgnZGlzdGFuY2UnKSArIHNwbGl0TGluZURpc3RhbmNlO1xuICAgICAgICB2YXIgbGFiZWwgPSBmb3JtYXRMYWJlbChyb3VuZChpIC8gc3BsaXROdW1iZXIgKiAobWF4VmFsIC0gbWluVmFsKSArIG1pblZhbCksIGxhYmVsTW9kZWwuZ2V0KCdmb3JtYXR0ZXInKSk7XG4gICAgICAgIHZhciBhdXRvQ29sb3IgPSBnZXRDb2xvcihpIC8gc3BsaXROdW1iZXIpO1xuICAgICAgICBncm91cC5hZGQobmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgICAgc3R5bGU6IGNyZWF0ZVRleHRTdHlsZShsYWJlbE1vZGVsLCB7XG4gICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgIHg6IHVuaXRYICogKHIgLSBzcGxpdExpbmVMZW4gLSBkaXN0YW5jZSkgKyBjeCxcbiAgICAgICAgICAgIHk6IHVuaXRZICogKHIgLSBzcGxpdExpbmVMZW4gLSBkaXN0YW5jZSkgKyBjeSxcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246IHVuaXRZIDwgLTAuOCA/ICd0b3AnIDogdW5pdFkgPiAwLjggPyAnYm90dG9tJyA6ICdtaWRkbGUnLFxuICAgICAgICAgICAgYWxpZ246IHVuaXRYIDwgLTAuNCA/ICdsZWZ0JyA6IHVuaXRYID4gMC40ID8gJ3JpZ2h0JyA6ICdjZW50ZXInXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgaW5oZXJpdENvbG9yOiBhdXRvQ29sb3JcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgfSAvLyBBeGlzIHRpY2tcblxuXG4gICAgICBpZiAodGlja01vZGVsLmdldCgnc2hvdycpICYmIGkgIT09IHNwbGl0TnVtYmVyKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHRpY2tNb2RlbC5nZXQoJ2Rpc3RhbmNlJyk7XG4gICAgICAgIGRpc3RhbmNlID0gZGlzdGFuY2UgPyBkaXN0YW5jZSArIGF4aXNMaW5lV2lkdGggOiBheGlzTGluZVdpZHRoO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IHN1YlNwbGl0TnVtYmVyOyBqKyspIHtcbiAgICAgICAgICB1bml0WCA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICB1bml0WSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgICB2YXIgdGlja0xpbmUgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgIHgxOiB1bml0WCAqIChyIC0gZGlzdGFuY2UpICsgY3gsXG4gICAgICAgICAgICAgIHkxOiB1bml0WSAqIChyIC0gZGlzdGFuY2UpICsgY3ksXG4gICAgICAgICAgICAgIHgyOiB1bml0WCAqIChyIC0gdGlja0xlbiAtIGRpc3RhbmNlKSArIGN4LFxuICAgICAgICAgICAgICB5MjogdW5pdFkgKiAociAtIHRpY2tMZW4gLSBkaXN0YW5jZSkgKyBjeVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgIHN0eWxlOiB0aWNrTGluZVN0eWxlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodGlja0xpbmVTdHlsZS5zdHJva2UgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgdGlja0xpbmUuc2V0U3R5bGUoe1xuICAgICAgICAgICAgICBzdHJva2U6IGdldENvbG9yKChpICsgaiAvIHN1YlNwbGl0TnVtYmVyKSAvIHNwbGl0TnVtYmVyKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ3JvdXAuYWRkKHRpY2tMaW5lKTtcbiAgICAgICAgICBhbmdsZSArPSBzdWJTdGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5nbGUgLT0gc3ViU3RlcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuZ2xlICs9IHN0ZXA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEdhdWdlVmlldy5wcm90b3R5cGUuX3JlbmRlclBvaW50ZXIgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgZ2V0Q29sb3IsIHBvc0luZm8sIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbG9ja3dpc2UsIGF4aXNMaW5lV2lkdGgpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgb2xkUHJvZ3Jlc3NEYXRhID0gdGhpcy5fcHJvZ3Jlc3NFbHM7XG4gICAgdmFyIHByb2dyZXNzTGlzdCA9IFtdO1xuICAgIHZhciBzaG93UG9pbnRlciA9IHNlcmllc01vZGVsLmdldChbJ3BvaW50ZXInLCAnc2hvdyddKTtcbiAgICB2YXIgcHJvZ3Jlc3NNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdwcm9ncmVzcycpO1xuICAgIHZhciBzaG93UHJvZ3Jlc3MgPSBwcm9ncmVzc01vZGVsLmdldCgnc2hvdycpO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciB2YWx1ZURpbSA9IGRhdGEubWFwRGltZW5zaW9uKCd2YWx1ZScpO1xuICAgIHZhciBtaW5WYWwgPSArc2VyaWVzTW9kZWwuZ2V0KCdtaW4nKTtcbiAgICB2YXIgbWF4VmFsID0gK3Nlcmllc01vZGVsLmdldCgnbWF4Jyk7XG4gICAgdmFyIHZhbHVlRXh0ZW50ID0gW21pblZhbCwgbWF4VmFsXTtcbiAgICB2YXIgYW5nbGVFeHRlbnQgPSBbc3RhcnRBbmdsZSwgZW5kQW5nbGVdO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlUG9pbnRlcihpZHgsIGFuZ2xlKSB7XG4gICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgIHZhciBwb2ludGVyTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ3BvaW50ZXInKTtcbiAgICAgIHZhciBwb2ludGVyV2lkdGggPSBwYXJzZVBlcmNlbnQocG9pbnRlck1vZGVsLmdldCgnd2lkdGgnKSwgcG9zSW5mby5yKTtcbiAgICAgIHZhciBwb2ludGVyTGVuZ3RoID0gcGFyc2VQZXJjZW50KHBvaW50ZXJNb2RlbC5nZXQoJ2xlbmd0aCcpLCBwb3NJbmZvLnIpO1xuICAgICAgdmFyIHBvaW50ZXJTdHIgPSBzZXJpZXNNb2RlbC5nZXQoWydwb2ludGVyJywgJ2ljb24nXSk7XG4gICAgICB2YXIgcG9pbnRlck9mZnNldCA9IHBvaW50ZXJNb2RlbC5nZXQoJ29mZnNldENlbnRlcicpO1xuICAgICAgdmFyIHBvaW50ZXJPZmZzZXRYID0gcGFyc2VQZXJjZW50KHBvaW50ZXJPZmZzZXRbMF0sIHBvc0luZm8ucik7XG4gICAgICB2YXIgcG9pbnRlck9mZnNldFkgPSBwYXJzZVBlcmNlbnQocG9pbnRlck9mZnNldFsxXSwgcG9zSW5mby5yKTtcbiAgICAgIHZhciBwb2ludGVyS2VlcEFzcGVjdCA9IHBvaW50ZXJNb2RlbC5nZXQoJ2tlZXBBc3BlY3QnKTtcbiAgICAgIHZhciBwb2ludGVyOyAvLyBub3QgZXhpc3QgaWNvbiB0eXBlIHdpbGwgYmUgc2V0ICdyZWN0J1xuXG4gICAgICBpZiAocG9pbnRlclN0cikge1xuICAgICAgICBwb2ludGVyID0gY3JlYXRlU3ltYm9sKHBvaW50ZXJTdHIsIHBvaW50ZXJPZmZzZXRYIC0gcG9pbnRlcldpZHRoIC8gMiwgcG9pbnRlck9mZnNldFkgLSBwb2ludGVyTGVuZ3RoLCBwb2ludGVyV2lkdGgsIHBvaW50ZXJMZW5ndGgsIG51bGwsIHBvaW50ZXJLZWVwQXNwZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50ZXIgPSBuZXcgUG9pbnRlclBhdGgoe1xuICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBhbmdsZTogLU1hdGguUEkgLyAyLFxuICAgICAgICAgICAgd2lkdGg6IHBvaW50ZXJXaWR0aCxcbiAgICAgICAgICAgIHI6IHBvaW50ZXJMZW5ndGgsXG4gICAgICAgICAgICB4OiBwb2ludGVyT2Zmc2V0WCxcbiAgICAgICAgICAgIHk6IHBvaW50ZXJPZmZzZXRZXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcG9pbnRlci5yb3RhdGlvbiA9IC0oYW5nbGUgKyBNYXRoLlBJIC8gMik7XG4gICAgICBwb2ludGVyLnggPSBwb3NJbmZvLmN4O1xuICAgICAgcG9pbnRlci55ID0gcG9zSW5mby5jeTtcbiAgICAgIHJldHVybiBwb2ludGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb2dyZXNzKGlkeCwgZW5kQW5nbGUpIHtcbiAgICAgIHZhciByb3VuZENhcCA9IHByb2dyZXNzTW9kZWwuZ2V0KCdyb3VuZENhcCcpO1xuICAgICAgdmFyIFByb2dyZXNzUGF0aCA9IHJvdW5kQ2FwID8gU2F1c2FnZSA6IGdyYXBoaWMuU2VjdG9yO1xuICAgICAgdmFyIGlzT3ZlcmxhcCA9IHByb2dyZXNzTW9kZWwuZ2V0KCdvdmVybGFwJyk7XG4gICAgICB2YXIgcHJvZ3Jlc3NXaWR0aCA9IGlzT3ZlcmxhcCA/IHByb2dyZXNzTW9kZWwuZ2V0KCd3aWR0aCcpIDogYXhpc0xpbmVXaWR0aCAvIGRhdGEuY291bnQoKTtcbiAgICAgIHZhciByMCA9IGlzT3ZlcmxhcCA/IHBvc0luZm8uciAtIHByb2dyZXNzV2lkdGggOiBwb3NJbmZvLnIgLSAoaWR4ICsgMSkgKiBwcm9ncmVzc1dpZHRoO1xuICAgICAgdmFyIHIgPSBpc092ZXJsYXAgPyBwb3NJbmZvLnIgOiBwb3NJbmZvLnIgLSBpZHggKiBwcm9ncmVzc1dpZHRoO1xuICAgICAgdmFyIHByb2dyZXNzID0gbmV3IFByb2dyZXNzUGF0aCh7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICAgICAgY3g6IHBvc0luZm8uY3gsXG4gICAgICAgICAgY3k6IHBvc0luZm8uY3ksXG4gICAgICAgICAgY2xvY2t3aXNlOiBjbG9ja3dpc2UsXG4gICAgICAgICAgcjA6IHIwLFxuICAgICAgICAgIHI6IHJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpc092ZXJsYXAgJiYgKHByb2dyZXNzLnoyID0gbWF4VmFsIC0gZGF0YS5nZXQodmFsdWVEaW0sIGlkeCkgJSBtYXhWYWwpO1xuICAgICAgcmV0dXJuIHByb2dyZXNzO1xuICAgIH1cblxuICAgIGlmIChzaG93UHJvZ3Jlc3MgfHwgc2hvd1BvaW50ZXIpIHtcbiAgICAgIGRhdGEuZGlmZihvbGREYXRhKS5hZGQoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICBpZiAoc2hvd1BvaW50ZXIpIHtcbiAgICAgICAgICB2YXIgcG9pbnRlciA9IGNyZWF0ZVBvaW50ZXIoaWR4LCBzdGFydEFuZ2xlKTtcbiAgICAgICAgICBncmFwaGljLmluaXRQcm9wcyhwb2ludGVyLCB7XG4gICAgICAgICAgICByb3RhdGlvbjogLShsaW5lYXJNYXAoZGF0YS5nZXQodmFsdWVEaW0sIGlkeCksIHZhbHVlRXh0ZW50LCBhbmdsZUV4dGVudCwgdHJ1ZSkgKyBNYXRoLlBJIC8gMilcbiAgICAgICAgICB9LCBzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgZ3JvdXAuYWRkKHBvaW50ZXIpO1xuICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIHBvaW50ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3dQcm9ncmVzcykge1xuICAgICAgICAgIHZhciBwcm9ncmVzcyA9IGNyZWF0ZVByb2dyZXNzKGlkeCwgc3RhcnRBbmdsZSk7XG4gICAgICAgICAgdmFyIGlzQ2xpcCA9IHByb2dyZXNzTW9kZWwuZ2V0KCdjbGlwJyk7XG4gICAgICAgICAgZ3JhcGhpYy5pbml0UHJvcHMocHJvZ3Jlc3MsIHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgIGVuZEFuZ2xlOiBsaW5lYXJNYXAoZGF0YS5nZXQodmFsdWVEaW0sIGlkeCksIHZhbHVlRXh0ZW50LCBhbmdsZUV4dGVudCwgaXNDbGlwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgICAgICBncm91cC5hZGQocHJvZ3Jlc3MpO1xuICAgICAgICAgIHByb2dyZXNzTGlzdFtpZHhdID0gcHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgIH0pLnVwZGF0ZShmdW5jdGlvbiAobmV3SWR4LCBvbGRJZHgpIHtcbiAgICAgICAgaWYgKHNob3dQb2ludGVyKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzUG9pbnRlciA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuICAgICAgICAgIHZhciBwcmV2aW91c1JvdGF0ZSA9IHByZXZpb3VzUG9pbnRlciA/IHByZXZpb3VzUG9pbnRlci5yb3RhdGlvbiA6IHN0YXJ0QW5nbGU7XG4gICAgICAgICAgdmFyIHBvaW50ZXIgPSBjcmVhdGVQb2ludGVyKG5ld0lkeCwgcHJldmlvdXNSb3RhdGUpO1xuICAgICAgICAgIHBvaW50ZXIucm90YXRpb24gPSBwcmV2aW91c1JvdGF0ZTtcbiAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHBvaW50ZXIsIHtcbiAgICAgICAgICAgIHJvdGF0aW9uOiAtKGxpbmVhck1hcChkYXRhLmdldCh2YWx1ZURpbSwgbmV3SWR4KSwgdmFsdWVFeHRlbnQsIGFuZ2xlRXh0ZW50LCB0cnVlKSArIE1hdGguUEkgLyAyKVxuICAgICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgICAgICBncm91cC5hZGQocG9pbnRlcik7XG4gICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgcG9pbnRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvd1Byb2dyZXNzKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzUHJvZ3Jlc3MgPSBvbGRQcm9ncmVzc0RhdGFbb2xkSWR4XTtcbiAgICAgICAgICB2YXIgcHJldmlvdXNFbmRBbmdsZSA9IHByZXZpb3VzUHJvZ3Jlc3MgPyBwcmV2aW91c1Byb2dyZXNzLnNoYXBlLmVuZEFuZ2xlIDogc3RhcnRBbmdsZTtcbiAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBjcmVhdGVQcm9ncmVzcyhuZXdJZHgsIHByZXZpb3VzRW5kQW5nbGUpO1xuICAgICAgICAgIHZhciBpc0NsaXAgPSBwcm9ncmVzc01vZGVsLmdldCgnY2xpcCcpO1xuICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocHJvZ3Jlc3MsIHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgIGVuZEFuZ2xlOiBsaW5lYXJNYXAoZGF0YS5nZXQodmFsdWVEaW0sIG5ld0lkeCksIHZhbHVlRXh0ZW50LCBhbmdsZUV4dGVudCwgaXNDbGlwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgICAgICBncm91cC5hZGQocHJvZ3Jlc3MpO1xuICAgICAgICAgIHByb2dyZXNzTGlzdFtuZXdJZHhdID0gcHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgIH0pLmV4ZWN1dGUoKTtcbiAgICAgIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgICB2YXIgZW1waGFzaXNNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKTtcblxuICAgICAgICBpZiAoc2hvd1BvaW50ZXIpIHtcbiAgICAgICAgICB2YXIgcG9pbnRlciA9IGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpO1xuICAgICAgICAgIHBvaW50ZXIudXNlU3R5bGUoZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJykpO1xuICAgICAgICAgIHBvaW50ZXIuc2V0U3R5bGUoaXRlbU1vZGVsLmdldE1vZGVsKFsncG9pbnRlcicsICdpdGVtU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCkpO1xuXG4gICAgICAgICAgaWYgKHBvaW50ZXIuc3R5bGUuZmlsbCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBwb2ludGVyLnNldFN0eWxlKCdmaWxsJywgZ2V0Q29sb3IobGluZWFyTWFwKGRhdGEuZ2V0KHZhbHVlRGltLCBpZHgpLCB2YWx1ZUV4dGVudCwgWzAsIDFdLCB0cnVlKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvaW50ZXIuejJFbXBoYXNpc0xpZnQgPSAwO1xuICAgICAgICAgIHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbChwb2ludGVyLCBpdGVtTW9kZWwpO1xuICAgICAgICAgIGVuYWJsZUhvdmVyRW1waGFzaXMocG9pbnRlciwgZW1waGFzaXNNb2RlbC5nZXQoJ2ZvY3VzJyksIGVtcGhhc2lzTW9kZWwuZ2V0KCdibHVyU2NvcGUnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvd1Byb2dyZXNzKSB7XG4gICAgICAgICAgdmFyIHByb2dyZXNzID0gcHJvZ3Jlc3NMaXN0W2lkeF07XG4gICAgICAgICAgcHJvZ3Jlc3MudXNlU3R5bGUoZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJykpO1xuICAgICAgICAgIHByb2dyZXNzLnNldFN0eWxlKGl0ZW1Nb2RlbC5nZXRNb2RlbChbJ3Byb2dyZXNzJywgJ2l0ZW1TdHlsZSddKS5nZXRJdGVtU3R5bGUoKSk7XG4gICAgICAgICAgcHJvZ3Jlc3MuejJFbXBoYXNpc0xpZnQgPSAwO1xuICAgICAgICAgIHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbChwcm9ncmVzcywgaXRlbU1vZGVsKTtcbiAgICAgICAgICBlbmFibGVIb3ZlckVtcGhhc2lzKHByb2dyZXNzLCBlbXBoYXNpc01vZGVsLmdldCgnZm9jdXMnKSwgZW1waGFzaXNNb2RlbC5nZXQoJ2JsdXJTY29wZScpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9wcm9ncmVzc0VscyA9IHByb2dyZXNzTGlzdDtcbiAgICB9XG4gIH07XG5cbiAgR2F1Z2VWaWV3LnByb3RvdHlwZS5fcmVuZGVyQW5jaG9yID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBwb3NJbmZvKSB7XG4gICAgdmFyIGFuY2hvck1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2FuY2hvcicpO1xuICAgIHZhciBzaG93QW5jaG9yID0gYW5jaG9yTW9kZWwuZ2V0KCdzaG93Jyk7XG5cbiAgICBpZiAoc2hvd0FuY2hvcikge1xuICAgICAgdmFyIGFuY2hvclNpemUgPSBhbmNob3JNb2RlbC5nZXQoJ3NpemUnKTtcbiAgICAgIHZhciBhbmNob3JUeXBlID0gYW5jaG9yTW9kZWwuZ2V0KCdpY29uJyk7XG4gICAgICB2YXIgb2Zmc2V0Q2VudGVyID0gYW5jaG9yTW9kZWwuZ2V0KCdvZmZzZXRDZW50ZXInKTtcbiAgICAgIHZhciBhbmNob3JLZWVwQXNwZWN0ID0gYW5jaG9yTW9kZWwuZ2V0KCdrZWVwQXNwZWN0Jyk7XG4gICAgICB2YXIgYW5jaG9yID0gY3JlYXRlU3ltYm9sKGFuY2hvclR5cGUsIHBvc0luZm8uY3ggLSBhbmNob3JTaXplIC8gMiArIHBhcnNlUGVyY2VudChvZmZzZXRDZW50ZXJbMF0sIHBvc0luZm8uciksIHBvc0luZm8uY3kgLSBhbmNob3JTaXplIC8gMiArIHBhcnNlUGVyY2VudChvZmZzZXRDZW50ZXJbMV0sIHBvc0luZm8uciksIGFuY2hvclNpemUsIGFuY2hvclNpemUsIG51bGwsIGFuY2hvcktlZXBBc3BlY3QpO1xuICAgICAgYW5jaG9yLnoyID0gYW5jaG9yTW9kZWwuZ2V0KCdzaG93QWJvdmUnKSA/IDEgOiAwO1xuICAgICAgYW5jaG9yLnNldFN0eWxlKGFuY2hvck1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKS5nZXRJdGVtU3R5bGUoKSk7XG4gICAgICB0aGlzLmdyb3VwLmFkZChhbmNob3IpO1xuICAgIH1cbiAgfTtcblxuICBHYXVnZVZpZXcucHJvdG90eXBlLl9yZW5kZXJUaXRsZUFuZERldGFpbCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBnZXRDb2xvciwgcG9zSW5mbykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgdmFsdWVEaW0gPSBkYXRhLm1hcERpbWVuc2lvbigndmFsdWUnKTtcbiAgICB2YXIgbWluVmFsID0gK3Nlcmllc01vZGVsLmdldCgnbWluJyk7XG4gICAgdmFyIG1heFZhbCA9ICtzZXJpZXNNb2RlbC5nZXQoJ21heCcpO1xuICAgIHZhciBjb250ZW50R3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIHZhciBuZXdUaXRsZUVscyA9IFtdO1xuICAgIHZhciBuZXdEZXRhaWxFbHMgPSBbXTtcbiAgICB2YXIgaGFzQW5pbWF0aW9uID0gc2VyaWVzTW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCk7XG4gICAgZGF0YS5kaWZmKHRoaXMuX2RhdGEpLmFkZChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICBuZXdUaXRsZUVsc1tpZHhdID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBuZXdEZXRhaWxFbHNbaWR4XSA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pLnVwZGF0ZShmdW5jdGlvbiAoaWR4LCBvbGRJZHgpIHtcbiAgICAgIG5ld1RpdGxlRWxzW2lkeF0gPSBfdGhpcy5fdGl0bGVFbHNbb2xkSWR4XTtcbiAgICAgIG5ld0RldGFpbEVsc1tpZHhdID0gX3RoaXMuX2RldGFpbEVsc1tvbGRJZHhdO1xuICAgIH0pLmV4ZWN1dGUoKTtcbiAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICB2YXIgdmFsdWUgPSBkYXRhLmdldCh2YWx1ZURpbSwgaWR4KTtcbiAgICAgIHZhciBpdGVtR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgICAgdmFyIGF1dG9Db2xvciA9IGdldENvbG9yKGxpbmVhck1hcCh2YWx1ZSwgW21pblZhbCwgbWF4VmFsXSwgWzAsIDFdLCB0cnVlKSk7XG4gICAgICB2YXIgaXRlbVRpdGxlTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ3RpdGxlJyk7XG5cbiAgICAgIGlmIChpdGVtVGl0bGVNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgICB2YXIgdGl0bGVPZmZzZXRDZW50ZXIgPSBpdGVtVGl0bGVNb2RlbC5nZXQoJ29mZnNldENlbnRlcicpO1xuICAgICAgICB2YXIgdGl0bGVYID0gcG9zSW5mby5jeCArIHBhcnNlUGVyY2VudCh0aXRsZU9mZnNldENlbnRlclswXSwgcG9zSW5mby5yKTtcbiAgICAgICAgdmFyIHRpdGxlWSA9IHBvc0luZm8uY3kgKyBwYXJzZVBlcmNlbnQodGl0bGVPZmZzZXRDZW50ZXJbMV0sIHBvc0luZm8ucik7XG4gICAgICAgIHZhciBsYWJlbEVsID0gbmV3VGl0bGVFbHNbaWR4XTtcbiAgICAgICAgbGFiZWxFbC5hdHRyKHtcbiAgICAgICAgICBzdHlsZTogY3JlYXRlVGV4dFN0eWxlKGl0ZW1UaXRsZU1vZGVsLCB7XG4gICAgICAgICAgICB4OiB0aXRsZVgsXG4gICAgICAgICAgICB5OiB0aXRsZVksXG4gICAgICAgICAgICB0ZXh0OiBkYXRhLmdldE5hbWUoaWR4KSxcbiAgICAgICAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgaW5oZXJpdENvbG9yOiBhdXRvQ29sb3JcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaXRlbUdyb3VwLmFkZChsYWJlbEVsKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZW1EZXRhaWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnZGV0YWlsJyk7XG5cbiAgICAgIGlmIChpdGVtRGV0YWlsTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgdmFyIGRldGFpbE9mZnNldENlbnRlciA9IGl0ZW1EZXRhaWxNb2RlbC5nZXQoJ29mZnNldENlbnRlcicpO1xuICAgICAgICB2YXIgZGV0YWlsWCA9IHBvc0luZm8uY3ggKyBwYXJzZVBlcmNlbnQoZGV0YWlsT2Zmc2V0Q2VudGVyWzBdLCBwb3NJbmZvLnIpO1xuICAgICAgICB2YXIgZGV0YWlsWSA9IHBvc0luZm8uY3kgKyBwYXJzZVBlcmNlbnQoZGV0YWlsT2Zmc2V0Q2VudGVyWzFdLCBwb3NJbmZvLnIpO1xuICAgICAgICB2YXIgd2lkdGggPSBwYXJzZVBlcmNlbnQoaXRlbURldGFpbE1vZGVsLmdldCgnd2lkdGgnKSwgcG9zSW5mby5yKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlUGVyY2VudChpdGVtRGV0YWlsTW9kZWwuZ2V0KCdoZWlnaHQnKSwgcG9zSW5mby5yKTtcbiAgICAgICAgdmFyIGRldGFpbENvbG9yID0gc2VyaWVzTW9kZWwuZ2V0KFsncHJvZ3Jlc3MnLCAnc2hvdyddKSA/IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzdHlsZScpLmZpbGwgOiBhdXRvQ29sb3I7XG4gICAgICAgIHZhciBsYWJlbEVsID0gbmV3RGV0YWlsRWxzW2lkeF07XG4gICAgICAgIHZhciBmb3JtYXR0ZXJfMSA9IGl0ZW1EZXRhaWxNb2RlbC5nZXQoJ2Zvcm1hdHRlcicpO1xuICAgICAgICBsYWJlbEVsLmF0dHIoe1xuICAgICAgICAgIHN0eWxlOiBjcmVhdGVUZXh0U3R5bGUoaXRlbURldGFpbE1vZGVsLCB7XG4gICAgICAgICAgICB4OiBkZXRhaWxYLFxuICAgICAgICAgICAgeTogZGV0YWlsWSxcbiAgICAgICAgICAgIHRleHQ6IGZvcm1hdExhYmVsKHZhbHVlLCBmb3JtYXR0ZXJfMSksXG4gICAgICAgICAgICB3aWR0aDogaXNOYU4od2lkdGgpID8gbnVsbCA6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBpc05hTihoZWlnaHQpID8gbnVsbCA6IGhlaWdodCxcbiAgICAgICAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgaW5oZXJpdENvbG9yOiBkZXRhaWxDb2xvclxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBzZXRMYWJlbFZhbHVlQW5pbWF0aW9uKGxhYmVsRWwsIHtcbiAgICAgICAgICBub3JtYWw6IGl0ZW1EZXRhaWxNb2RlbFxuICAgICAgICB9LCB2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdExhYmVsKHZhbHVlLCBmb3JtYXR0ZXJfMSk7XG4gICAgICAgIH0pO1xuICAgICAgICBoYXNBbmltYXRpb24gJiYgYW5pbWF0ZUxhYmVsVmFsdWUobGFiZWxFbCwgaWR4LCBkYXRhLCBzZXJpZXNNb2RlbCwge1xuICAgICAgICAgIGdldEZvcm1hdHRlZExhYmVsOiBmdW5jdGlvbiAobGFiZWxEYXRhSW5kZXgsIHN0YXR1cywgZGF0YVR5cGUsIGxhYmVsRGltSW5kZXgsIGZtdCwgZXh0ZW5kUGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TGFiZWwoZXh0ZW5kUGFyYW1zID8gZXh0ZW5kUGFyYW1zLmludGVycG9sYXRlZFZhbHVlIDogdmFsdWUsIGZvcm1hdHRlcl8xKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpdGVtR3JvdXAuYWRkKGxhYmVsRWwpO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50R3JvdXAuYWRkKGl0ZW1Hcm91cCk7XG4gICAgfSk7XG4gICAgdGhpcy5ncm91cC5hZGQoY29udGVudEdyb3VwKTtcbiAgICB0aGlzLl90aXRsZUVscyA9IG5ld1RpdGxlRWxzO1xuICAgIHRoaXMuX2RldGFpbEVscyA9IG5ld0RldGFpbEVscztcbiAgfTtcblxuICBHYXVnZVZpZXcudHlwZSA9ICdnYXVnZSc7XG4gIHJldHVybiBHYXVnZVZpZXc7XG59KENoYXJ0Vmlldyk7XG5cbmV4cG9ydCBkZWZhdWx0IEdhdWdlVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgUGF0aCBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL1BhdGgnO1xuXG52YXIgUG9pbnRlclNoYXBlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9pbnRlclNoYXBlKCkge1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIHRoaXMud2lkdGggPSAxMDtcbiAgICB0aGlzLnIgPSAxMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gIH1cblxuICByZXR1cm4gUG9pbnRlclNoYXBlO1xufSgpO1xuXG52YXIgUG9pbnRlclBhdGggPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUG9pbnRlclBhdGgsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gUG9pbnRlclBhdGgob3B0cykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gJ3BvaW50ZXInO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFBvaW50ZXJQYXRoLnByb3RvdHlwZS5nZXREZWZhdWx0U2hhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludGVyU2hhcGUoKTtcbiAgfTtcblxuICBQb2ludGVyUGF0aC5wcm90b3R5cGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuICAgIHZhciBtYXRoU2luID0gTWF0aC5zaW47XG4gICAgdmFyIHIgPSBzaGFwZS5yO1xuICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgIHZhciBhbmdsZSA9IHNoYXBlLmFuZ2xlO1xuICAgIHZhciB4ID0gc2hhcGUueCAtIG1hdGhDb3MoYW5nbGUpICogd2lkdGggKiAod2lkdGggPj0gciAvIDMgPyAxIDogMik7XG4gICAgdmFyIHkgPSBzaGFwZS55IC0gbWF0aFNpbihhbmdsZSkgKiB3aWR0aCAqICh3aWR0aCA+PSByIC8gMyA/IDEgOiAyKTtcbiAgICBhbmdsZSA9IHNoYXBlLmFuZ2xlIC0gTWF0aC5QSSAvIDI7XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICBjdHgubGluZVRvKHNoYXBlLnggKyBtYXRoQ29zKGFuZ2xlKSAqIHdpZHRoLCBzaGFwZS55ICsgbWF0aFNpbihhbmdsZSkgKiB3aWR0aCk7XG4gICAgY3R4LmxpbmVUbyhzaGFwZS54ICsgbWF0aENvcyhzaGFwZS5hbmdsZSkgKiByLCBzaGFwZS55ICsgbWF0aFNpbihzaGFwZS5hbmdsZSkgKiByKTtcbiAgICBjdHgubGluZVRvKHNoYXBlLnggLSBtYXRoQ29zKGFuZ2xlKSAqIHdpZHRoLCBzaGFwZS55IC0gbWF0aFNpbihhbmdsZSkgKiB3aWR0aCk7XG4gICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgfTtcblxuICByZXR1cm4gUG9pbnRlclBhdGg7XG59KFBhdGgpO1xuXG5leHBvcnQgZGVmYXVsdCBQb2ludGVyUGF0aDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IEdhdWdlVmlldyBmcm9tICcuL0dhdWdlVmlldyc7XG5pbXBvcnQgR2F1Z2VTZXJpZXNNb2RlbCBmcm9tICcuL0dhdWdlU2VyaWVzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDaGFydFZpZXcoR2F1Z2VWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU2VyaWVzTW9kZWwoR2F1Z2VTZXJpZXNNb2RlbCk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IExpc3QgZnJvbSAnLi4vLi4vZGF0YS9MaXN0JztcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgZGVmYXVsdEVtcGhhc2lzIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvTW9kZWwnO1xuaW1wb3J0IGNyZWF0ZUdyYXBoRnJvbU5vZGVFZGdlIGZyb20gJy4uL2hlbHBlci9jcmVhdGVHcmFwaEZyb21Ob2RlRWRnZSc7XG5pbXBvcnQgTGVnZW5kVmlzdWFsUHJvdmlkZXIgZnJvbSAnLi4vLi4vdmlzdWFsL0xlZ2VuZFZpc3VhbFByb3ZpZGVyJztcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9TZXJpZXMnO1xuaW1wb3J0IHsgY3JlYXRlVG9vbHRpcE1hcmt1cCB9IGZyb20gJy4uLy4uL2NvbXBvbmVudC90b29sdGlwL3Rvb2x0aXBNYXJrdXAnO1xuaW1wb3J0IHsgZGVmYXVsdFNlcmllc0Zvcm1hdFRvb2x0aXAgfSBmcm9tICcuLi8uLi9jb21wb25lbnQvdG9vbHRpcC9zZXJpZXNGb3JtYXRUb29sdGlwJztcbmltcG9ydCB7IGluaXRDdXJ2ZW5lc3NMaXN0LCBjcmVhdGVFZGdlTWFwRm9yQ3VydmVuZXNzIH0gZnJvbSAnLi4vaGVscGVyL211bHRpcGxlR3JhcGhFZGdlSGVscGVyJztcblxudmFyIEdyYXBoU2VyaWVzTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoR3JhcGhTZXJpZXNNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBHcmFwaFNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IEdyYXBoU2VyaWVzTW9kZWwudHlwZTtcbiAgICBfdGhpcy5oYXNTeW1ib2xWaXN1YWwgPSB0cnVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEdyYXBoU2VyaWVzTW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBnZXRDYXRlZ29yaWVzRGF0YSgpIHtcbiAgICAgIHJldHVybiBzZWxmLl9jYXRlZ29yaWVzRGF0YTtcbiAgICB9IC8vIFByb3ZpZGUgZGF0YSBmb3IgbGVnZW5kIHNlbGVjdFxuXG5cbiAgICB0aGlzLmxlZ2VuZFZpc3VhbFByb3ZpZGVyID0gbmV3IExlZ2VuZFZpc3VhbFByb3ZpZGVyKGdldENhdGVnb3JpZXNEYXRhLCBnZXRDYXRlZ29yaWVzRGF0YSk7XG4gICAgdGhpcy5maWxsRGF0YVRleHRTdHlsZShvcHRpb24uZWRnZXMgfHwgb3B0aW9uLmxpbmtzKTtcblxuICAgIHRoaXMuX3VwZGF0ZUNhdGVnb3JpZXNEYXRhKCk7XG4gIH07XG5cbiAgR3JhcGhTZXJpZXNNb2RlbC5wcm90b3R5cGUubWVyZ2VPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5tZXJnZU9wdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5maWxsRGF0YVRleHRTdHlsZShvcHRpb24uZWRnZXMgfHwgb3B0aW9uLmxpbmtzKTtcblxuICAgIHRoaXMuX3VwZGF0ZUNhdGVnb3JpZXNEYXRhKCk7XG4gIH07XG5cbiAgR3JhcGhTZXJpZXNNb2RlbC5wcm90b3R5cGUubWVyZ2VEZWZhdWx0QW5kVGhlbWUgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5tZXJnZURlZmF1bHRBbmRUaGVtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgZGVmYXVsdEVtcGhhc2lzKG9wdGlvbiwgJ2VkZ2VMYWJlbCcsIFsnc2hvdyddKTtcbiAgfTtcblxuICBHcmFwaFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YSA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICB2YXIgZWRnZXMgPSBvcHRpb24uZWRnZXMgfHwgb3B0aW9uLmxpbmtzIHx8IFtdO1xuICAgIHZhciBub2RlcyA9IG9wdGlvbi5kYXRhIHx8IG9wdGlvbi5ub2RlcyB8fCBbXTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAobm9kZXMgJiYgZWRnZXMpIHtcbiAgICAgIC8vIGF1dG8gY3VydmVuZXNzXG4gICAgICBpbml0Q3VydmVuZXNzTGlzdCh0aGlzKTtcbiAgICAgIHZhciBncmFwaCA9IGNyZWF0ZUdyYXBoRnJvbU5vZGVFZGdlKG5vZGVzLCBlZGdlcywgdGhpcywgdHJ1ZSwgYmVmb3JlTGluayk7XG4gICAgICB6clV0aWwuZWFjaChncmFwaC5lZGdlcywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgY3JlYXRlRWRnZU1hcEZvckN1cnZlbmVzcyhlZGdlLm5vZGUxLCBlZGdlLm5vZGUyLCB0aGlzLCBlZGdlLmRhdGFJbmRleCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHJldHVybiBncmFwaC5kYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJlZm9yZUxpbmsobm9kZURhdGEsIGVkZ2VEYXRhKSB7XG4gICAgICAvLyBPdmVyd3JpdGUgbm9kZURhdGEuZ2V0SXRlbU1vZGVsIHRvXG4gICAgICBub2RlRGF0YS53cmFwTWV0aG9kKCdnZXRJdGVtTW9kZWwnLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXNNb2RlbHMgPSBzZWxmLl9jYXRlZ29yaWVzTW9kZWxzO1xuICAgICAgICB2YXIgY2F0ZWdvcnlJZHggPSBtb2RlbC5nZXRTaGFsbG93KCdjYXRlZ29yeScpO1xuICAgICAgICB2YXIgY2F0ZWdvcnlNb2RlbCA9IGNhdGVnb3JpZXNNb2RlbHNbY2F0ZWdvcnlJZHhdO1xuXG4gICAgICAgIGlmIChjYXRlZ29yeU1vZGVsKSB7XG4gICAgICAgICAgY2F0ZWdvcnlNb2RlbC5wYXJlbnRNb2RlbCA9IG1vZGVsLnBhcmVudE1vZGVsO1xuICAgICAgICAgIG1vZGVsLnBhcmVudE1vZGVsID0gY2F0ZWdvcnlNb2RlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgIH0pOyAvLyBUT0RPIEluaGVyaXQgcmVzb2x2ZVBhcmVudFBhdGggYnkgZGVmYXVsdCBpbiBNb2RlbCNnZXRNb2RlbD9cblxuICAgICAgdmFyIG9sZEdldE1vZGVsID0gTW9kZWwucHJvdG90eXBlLmdldE1vZGVsO1xuXG4gICAgICBmdW5jdGlvbiBuZXdHZXRNb2RlbChwYXRoLCBwYXJlbnRNb2RlbCkge1xuICAgICAgICB2YXIgbW9kZWwgPSBvbGRHZXRNb2RlbC5jYWxsKHRoaXMsIHBhdGgsIHBhcmVudE1vZGVsKTtcbiAgICAgICAgbW9kZWwucmVzb2x2ZVBhcmVudFBhdGggPSByZXNvbHZlUGFyZW50UGF0aDtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgfVxuXG4gICAgICBlZGdlRGF0YS53cmFwTWV0aG9kKCdnZXRJdGVtTW9kZWwnLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgbW9kZWwucmVzb2x2ZVBhcmVudFBhdGggPSByZXNvbHZlUGFyZW50UGF0aDtcbiAgICAgICAgbW9kZWwuZ2V0TW9kZWwgPSBuZXdHZXRNb2RlbDtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVQYXJlbnRQYXRoKHBhdGhBcnIpIHtcbiAgICAgICAgaWYgKHBhdGhBcnIgJiYgKHBhdGhBcnJbMF0gPT09ICdsYWJlbCcgfHwgcGF0aEFyclsxXSA9PT0gJ2xhYmVsJykpIHtcbiAgICAgICAgICB2YXIgbmV3UGF0aEFyciA9IHBhdGhBcnIuc2xpY2UoKTtcblxuICAgICAgICAgIGlmIChwYXRoQXJyWzBdID09PSAnbGFiZWwnKSB7XG4gICAgICAgICAgICBuZXdQYXRoQXJyWzBdID0gJ2VkZ2VMYWJlbCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXRoQXJyWzFdID09PSAnbGFiZWwnKSB7XG4gICAgICAgICAgICBuZXdQYXRoQXJyWzFdID0gJ2VkZ2VMYWJlbCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ld1BhdGhBcnI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aEFycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgR3JhcGhTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0R3JhcGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGF0YSgpLmdyYXBoO1xuICB9O1xuXG4gIEdyYXBoU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEVkZ2VEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldEdyYXBoKCkuZWRnZURhdGE7XG4gIH07XG5cbiAgR3JhcGhTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0Q2F0ZWdvcmllc0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhdGVnb3JpZXNEYXRhO1xuICB9O1xuXG4gIEdyYXBoU2VyaWVzTW9kZWwucHJvdG90eXBlLmZvcm1hdFRvb2x0aXAgPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBtdWx0aXBsZVNlcmllcywgZGF0YVR5cGUpIHtcbiAgICBpZiAoZGF0YVR5cGUgPT09ICdlZGdlJykge1xuICAgICAgdmFyIG5vZGVEYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgICB2YXIgcGFyYW1zID0gdGhpcy5nZXREYXRhUGFyYW1zKGRhdGFJbmRleCwgZGF0YVR5cGUpO1xuICAgICAgdmFyIGVkZ2UgPSBub2RlRGF0YS5ncmFwaC5nZXRFZGdlQnlJbmRleChkYXRhSW5kZXgpO1xuICAgICAgdmFyIHNvdXJjZU5hbWUgPSBub2RlRGF0YS5nZXROYW1lKGVkZ2Uubm9kZTEuZGF0YUluZGV4KTtcbiAgICAgIHZhciB0YXJnZXROYW1lID0gbm9kZURhdGEuZ2V0TmFtZShlZGdlLm5vZGUyLmRhdGFJbmRleCk7XG4gICAgICB2YXIgbmFtZUFyciA9IFtdO1xuICAgICAgc291cmNlTmFtZSAhPSBudWxsICYmIG5hbWVBcnIucHVzaChzb3VyY2VOYW1lKTtcbiAgICAgIHRhcmdldE5hbWUgIT0gbnVsbCAmJiBuYW1lQXJyLnB1c2godGFyZ2V0TmFtZSk7XG4gICAgICByZXR1cm4gY3JlYXRlVG9vbHRpcE1hcmt1cCgnbmFtZVZhbHVlJywge1xuICAgICAgICBuYW1lOiBuYW1lQXJyLmpvaW4oJyA+ICcpLFxuICAgICAgICB2YWx1ZTogcGFyYW1zLnZhbHVlLFxuICAgICAgICBub1ZhbHVlOiBwYXJhbXMudmFsdWUgPT0gbnVsbFxuICAgICAgfSk7XG4gICAgfSAvLyBkYXRhVHlwZSA9PT0gJ25vZGUnIG9yIGVtcHR5XG5cblxuICAgIHZhciBub2RlTWFya3VwID0gZGVmYXVsdFNlcmllc0Zvcm1hdFRvb2x0aXAoe1xuICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgZGF0YUluZGV4OiBkYXRhSW5kZXgsXG4gICAgICBtdWx0aXBsZVNlcmllczogbXVsdGlwbGVTZXJpZXNcbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZU1hcmt1cDtcbiAgfTtcblxuICBHcmFwaFNlcmllc01vZGVsLnByb3RvdHlwZS5fdXBkYXRlQ2F0ZWdvcmllc0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhdGVnb3JpZXMgPSB6clV0aWwubWFwKHRoaXMub3B0aW9uLmNhdGVnb3JpZXMgfHwgW10sIGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgLy8gRGF0YSBtdXN0IGhhcyB2YWx1ZVxuICAgICAgcmV0dXJuIGNhdGVnb3J5LnZhbHVlICE9IG51bGwgPyBjYXRlZ29yeSA6IHpyVXRpbC5leHRlbmQoe1xuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSwgY2F0ZWdvcnkpO1xuICAgIH0pO1xuICAgIHZhciBjYXRlZ29yaWVzRGF0YSA9IG5ldyBMaXN0KFsndmFsdWUnXSwgdGhpcyk7XG4gICAgY2F0ZWdvcmllc0RhdGEuaW5pdERhdGEoY2F0ZWdvcmllcyk7XG4gICAgdGhpcy5fY2F0ZWdvcmllc0RhdGEgPSBjYXRlZ29yaWVzRGF0YTtcbiAgICB0aGlzLl9jYXRlZ29yaWVzTW9kZWxzID0gY2F0ZWdvcmllc0RhdGEubWFwQXJyYXkoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgcmV0dXJuIGNhdGVnb3JpZXNEYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgIH0pO1xuICB9O1xuXG4gIEdyYXBoU2VyaWVzTW9kZWwucHJvdG90eXBlLnNldFpvb20gPSBmdW5jdGlvbiAoem9vbSkge1xuICAgIHRoaXMub3B0aW9uLnpvb20gPSB6b29tO1xuICB9O1xuXG4gIEdyYXBoU2VyaWVzTW9kZWwucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uIChjZW50ZXIpIHtcbiAgICB0aGlzLm9wdGlvbi5jZW50ZXIgPSBjZW50ZXI7XG4gIH07XG5cbiAgR3JhcGhTZXJpZXNNb2RlbC5wcm90b3R5cGUuaXNBbmltYXRpb25FbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmlzQW5pbWF0aW9uRW5hYmxlZC5jYWxsKHRoaXMpIC8vIE5vdCBlbmFibGUgYW5pbWF0aW9uIHdoZW4gZG8gZm9yY2UgbGF5b3V0XG4gICAgJiYgISh0aGlzLmdldCgnbGF5b3V0JykgPT09ICdmb3JjZScgJiYgdGhpcy5nZXQoWydmb3JjZScsICdsYXlvdXRBbmltYXRpb24nXSkpO1xuICB9O1xuXG4gIEdyYXBoU2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMuZ3JhcGgnO1xuICBHcmFwaFNlcmllc01vZGVsLmRlcGVuZGVuY2llcyA9IFsnZ3JpZCcsICdwb2xhcicsICdnZW8nLCAnc2luZ2xlQXhpcycsICdjYWxlbmRhciddO1xuICBHcmFwaFNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgY29vcmRpbmF0ZVN5c3RlbTogJ3ZpZXcnLFxuICAgIC8vIERlZmF1bHQgb3B0aW9uIGZvciBhbGwgY29vcmRpbmF0ZSBzeXN0ZW1zXG4gICAgLy8geEF4aXNJbmRleDogMCxcbiAgICAvLyB5QXhpc0luZGV4OiAwLFxuICAgIC8vIHBvbGFySW5kZXg6IDAsXG4gICAgLy8gZ2VvSW5kZXg6IDAsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIGxheW91dDogbnVsbCxcbiAgICAvLyBDb25maWd1cmF0aW9uIG9mIGNpcmN1bGFyIGxheW91dFxuICAgIGNpcmN1bGFyOiB7XG4gICAgICByb3RhdGVMYWJlbDogZmFsc2VcbiAgICB9LFxuICAgIC8vIENvbmZpZ3VyYXRpb24gb2YgZm9yY2UgZGlyZWN0ZWQgbGF5b3V0XG4gICAgZm9yY2U6IHtcbiAgICAgIGluaXRMYXlvdXQ6IG51bGwsXG4gICAgICAvLyBOb2RlIHJlcHVsc2lvbi4gQ2FuIGJlIGFuIGFycmF5IHRvIHJlcHJlc2VudCByYW5nZS5cbiAgICAgIHJlcHVsc2lvbjogWzAsIDUwXSxcbiAgICAgIGdyYXZpdHk6IDAuMSxcbiAgICAgIC8vIEluaXRpYWwgZnJpY3Rpb25cbiAgICAgIGZyaWN0aW9uOiAwLjYsXG4gICAgICAvLyBFZGdlIGxlbmd0aC4gQ2FuIGJlIGFuIGFycmF5IHRvIHJlcHJlc2VudCByYW5nZS5cbiAgICAgIGVkZ2VMZW5ndGg6IDMwLFxuICAgICAgbGF5b3V0QW5pbWF0aW9uOiB0cnVlXG4gICAgfSxcbiAgICBsZWZ0OiAnY2VudGVyJyxcbiAgICB0b3A6ICdjZW50ZXInLFxuICAgIC8vIHJpZ2h0OiBudWxsLFxuICAgIC8vIGJvdHRvbTogbnVsbCxcbiAgICAvLyB3aWR0aDogJzgwJScsXG4gICAgLy8gaGVpZ2h0OiAnODAlJyxcbiAgICBzeW1ib2w6ICdjaXJjbGUnLFxuICAgIHN5bWJvbFNpemU6IDEwLFxuICAgIGVkZ2VTeW1ib2w6IFsnbm9uZScsICdub25lJ10sXG4gICAgZWRnZVN5bWJvbFNpemU6IDEwLFxuICAgIGVkZ2VMYWJlbDoge1xuICAgICAgcG9zaXRpb246ICdtaWRkbGUnLFxuICAgICAgZGlzdGFuY2U6IDVcbiAgICB9LFxuICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgcm9hbTogZmFsc2UsXG4gICAgLy8gRGVmYXVsdCBvbiBjZW50ZXIgb2YgZ3JhcGhcbiAgICBjZW50ZXI6IG51bGwsXG4gICAgem9vbTogMSxcbiAgICAvLyBTeW1ib2wgc2l6ZSBzY2FsZSByYXRpbyBpbiByb2FtXG4gICAgbm9kZVNjYWxlUmF0aW86IDAuNixcbiAgICAvLyBjdXJzb3I6IG51bGwsXG4gICAgLy8gY2F0ZWdvcmllczogW10sXG4gICAgLy8gZGF0YTogW11cbiAgICAvLyBPclxuICAgIC8vIG5vZGVzOiBbXVxuICAgIC8vXG4gICAgLy8gbGlua3M6IFtdXG4gICAgLy8gT3JcbiAgICAvLyBlZGdlczogW11cbiAgICBsYWJlbDoge1xuICAgICAgc2hvdzogZmFsc2UsXG4gICAgICBmb3JtYXR0ZXI6ICd7Yn0nXG4gICAgfSxcbiAgICBpdGVtU3R5bGU6IHt9LFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgY29sb3I6ICcjYWFhJyxcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgb3BhY2l0eTogMC41XG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgc2NhbGU6IHRydWUsXG4gICAgICBsYWJlbDoge1xuICAgICAgICBzaG93OiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3Q6IHtcbiAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICBib3JkZXJDb2xvcjogJyMyMTIxMjEnXG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gR3JhcGhTZXJpZXNNb2RlbDtcbn0oU2VyaWVzTW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBHcmFwaFNlcmllc01vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IFN5bWJvbERyYXcgZnJvbSAnLi4vaGVscGVyL1N5bWJvbERyYXcnO1xuaW1wb3J0IExpbmVEcmF3IGZyb20gJy4uL2hlbHBlci9MaW5lRHJhdyc7XG5pbXBvcnQgUm9hbUNvbnRyb2xsZXIgZnJvbSAnLi4vLi4vY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlcic7XG5pbXBvcnQgKiBhcyByb2FtSGVscGVyIGZyb20gJy4uLy4uL2NvbXBvbmVudC9oZWxwZXIvcm9hbUhlbHBlcic7XG5pbXBvcnQgeyBvbklycmVsZXZhbnRFbGVtZW50IH0gZnJvbSAnLi4vLi4vY29tcG9uZW50L2hlbHBlci9jdXJzb3JIZWxwZXInO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IGFkanVzdEVkZ2UgZnJvbSAnLi9hZGp1c3RFZGdlJztcbmltcG9ydCB7IGdldE5vZGVHbG9iYWxTY2FsZSB9IGZyb20gJy4vZ3JhcGhIZWxwZXInO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0JztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZSc7XG5cbmZ1bmN0aW9uIGlzVmlld0Nvb3JkU3lzKGNvb3JkU3lzKSB7XG4gIHJldHVybiBjb29yZFN5cy50eXBlID09PSAndmlldyc7XG59XG5cbnZhciBHcmFwaFZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoR3JhcGhWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEdyYXBoVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBHcmFwaFZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBHcmFwaFZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIHN5bWJvbERyYXcgPSBuZXcgU3ltYm9sRHJhdygpO1xuICAgIHZhciBsaW5lRHJhdyA9IG5ldyBMaW5lRHJhdygpO1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdGhpcy5fY29udHJvbGxlciA9IG5ldyBSb2FtQ29udHJvbGxlcihhcGkuZ2V0WnIoKSk7XG4gICAgdGhpcy5fY29udHJvbGxlckhvc3QgPSB7XG4gICAgICB0YXJnZXQ6IGdyb3VwXG4gICAgfTtcbiAgICBncm91cC5hZGQoc3ltYm9sRHJhdy5ncm91cCk7XG4gICAgZ3JvdXAuYWRkKGxpbmVEcmF3Lmdyb3VwKTtcbiAgICB0aGlzLl9zeW1ib2xEcmF3ID0gc3ltYm9sRHJhdztcbiAgICB0aGlzLl9saW5lRHJhdyA9IGxpbmVEcmF3O1xuICAgIHRoaXMuX2ZpcnN0UmVuZGVyID0gdHJ1ZTtcbiAgfTtcblxuICBHcmFwaFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdGhpcy5fbW9kZWwgPSBzZXJpZXNNb2RlbDtcbiAgICB2YXIgc3ltYm9sRHJhdyA9IHRoaXMuX3N5bWJvbERyYXc7XG4gICAgdmFyIGxpbmVEcmF3ID0gdGhpcy5fbGluZURyYXc7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcblxuICAgIGlmIChpc1ZpZXdDb29yZFN5cyhjb29yZFN5cykpIHtcbiAgICAgIHZhciBncm91cE5ld1Byb3AgPSB7XG4gICAgICAgIHg6IGNvb3JkU3lzLngsXG4gICAgICAgIHk6IGNvb3JkU3lzLnksXG4gICAgICAgIHNjYWxlWDogY29vcmRTeXMuc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IGNvb3JkU3lzLnNjYWxlWVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuX2ZpcnN0UmVuZGVyKSB7XG4gICAgICAgIGdyb3VwLmF0dHIoZ3JvdXBOZXdQcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZ3JvdXAsIGdyb3VwTmV3UHJvcCwgc2VyaWVzTW9kZWwpO1xuICAgICAgfVxuICAgIH0gLy8gRml4IGVkZ2UgY29udGFjdCBwb2ludCB3aXRoIG5vZGVcblxuXG4gICAgYWRqdXN0RWRnZShzZXJpZXNNb2RlbC5nZXRHcmFwaCgpLCBnZXROb2RlR2xvYmFsU2NhbGUoc2VyaWVzTW9kZWwpKTtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICBzeW1ib2xEcmF3LnVwZGF0ZURhdGEoZGF0YSk7XG4gICAgdmFyIGVkZ2VEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RWRnZURhdGEoKTsgLy8gVE9ETzogVFlQRVxuXG4gICAgbGluZURyYXcudXBkYXRlRGF0YShlZGdlRGF0YSk7XG5cbiAgICB0aGlzLl91cGRhdGVOb2RlQW5kTGlua1NjYWxlKCk7XG5cbiAgICB0aGlzLl91cGRhdGVDb250cm9sbGVyKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpO1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2xheW91dFRpbWVvdXQpO1xuICAgIHZhciBmb3JjZUxheW91dCA9IHNlcmllc01vZGVsLmZvcmNlTGF5b3V0O1xuICAgIHZhciBsYXlvdXRBbmltYXRpb24gPSBzZXJpZXNNb2RlbC5nZXQoWydmb3JjZScsICdsYXlvdXRBbmltYXRpb24nXSk7XG5cbiAgICBpZiAoZm9yY2VMYXlvdXQpIHtcbiAgICAgIHRoaXMuX3N0YXJ0Rm9yY2VMYXlvdXRJdGVyYXRpb24oZm9yY2VMYXlvdXQsIGxheW91dEFuaW1hdGlvbik7XG4gICAgfVxuXG4gICAgZGF0YS5ncmFwaC5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGlkeCA9IG5vZGUuZGF0YUluZGV4O1xuICAgICAgdmFyIGVsID0gbm9kZS5nZXRHcmFwaGljRWwoKTtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBub2RlLmdldE1vZGVsKCk7IC8vIFVwZGF0ZSBkcmFnZ2FibGVcblxuICAgICAgZWwub2ZmKCdkcmFnJykub2ZmKCdkcmFnZW5kJyk7XG4gICAgICB2YXIgZHJhZ2dhYmxlID0gaXRlbU1vZGVsLmdldCgnZHJhZ2dhYmxlJyk7XG5cbiAgICAgIGlmIChkcmFnZ2FibGUpIHtcbiAgICAgICAgZWwub24oJ2RyYWcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGZvcmNlTGF5b3V0KSB7XG4gICAgICAgICAgICBmb3JjZUxheW91dC53YXJtVXAoKTtcbiAgICAgICAgICAgICFfdGhpcy5fbGF5b3V0aW5nICYmIF90aGlzLl9zdGFydEZvcmNlTGF5b3V0SXRlcmF0aW9uKGZvcmNlTGF5b3V0LCBsYXlvdXRBbmltYXRpb24pO1xuICAgICAgICAgICAgZm9yY2VMYXlvdXQuc2V0Rml4ZWQoaWR4KTsgLy8gV3JpdGUgcG9zaXRpb24gYmFjayB0byBsYXlvdXRcblxuICAgICAgICAgICAgZGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwgW2VsLngsIGVsLnldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLm9uKCdkcmFnZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmb3JjZUxheW91dCkge1xuICAgICAgICAgICAgZm9yY2VMYXlvdXQuc2V0VW5maXhlZChpZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGVsLnNldERyYWdnYWJsZShkcmFnZ2FibGUgJiYgISFmb3JjZUxheW91dCk7XG4gICAgICB2YXIgZm9jdXMgPSBpdGVtTW9kZWwuZ2V0KFsnZW1waGFzaXMnLCAnZm9jdXMnXSk7XG5cbiAgICAgIGlmIChmb2N1cyA9PT0gJ2FkamFjZW5jeScpIHtcbiAgICAgICAgZ2V0RUNEYXRhKGVsKS5mb2N1cyA9IG5vZGUuZ2V0QWRqYWNlbnREYXRhSW5kaWNlcygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRhdGEuZ3JhcGguZWFjaEVkZ2UoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHZhciBlbCA9IGVkZ2UuZ2V0R3JhcGhpY0VsKCk7XG4gICAgICB2YXIgZm9jdXMgPSBlZGdlLmdldE1vZGVsKCkuZ2V0KFsnZW1waGFzaXMnLCAnZm9jdXMnXSk7XG5cbiAgICAgIGlmIChmb2N1cyA9PT0gJ2FkamFjZW5jeScpIHtcbiAgICAgICAgZ2V0RUNEYXRhKGVsKS5mb2N1cyA9IHtcbiAgICAgICAgICBlZGdlOiBbZWRnZS5kYXRhSW5kZXhdLFxuICAgICAgICAgIG5vZGU6IFtlZGdlLm5vZGUxLmRhdGFJbmRleCwgZWRnZS5ub2RlMi5kYXRhSW5kZXhdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGNpcmN1bGFyUm90YXRlTGFiZWwgPSBzZXJpZXNNb2RlbC5nZXQoJ2xheW91dCcpID09PSAnY2lyY3VsYXInICYmIHNlcmllc01vZGVsLmdldChbJ2NpcmN1bGFyJywgJ3JvdGF0ZUxhYmVsJ10pO1xuICAgIHZhciBjeCA9IGRhdGEuZ2V0TGF5b3V0KCdjeCcpO1xuICAgIHZhciBjeSA9IGRhdGEuZ2V0TGF5b3V0KCdjeScpO1xuICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgdmFyIGxhYmVsUm90YXRlID0gaXRlbU1vZGVsLmdldChbJ2xhYmVsJywgJ3JvdGF0ZSddKSB8fCAwO1xuICAgICAgdmFyIHN5bWJvbFBhdGggPSBlbC5nZXRTeW1ib2xQYXRoKCk7XG5cbiAgICAgIGlmIChjaXJjdWxhclJvdGF0ZUxhYmVsKSB7XG4gICAgICAgIHZhciBwb3MgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICAgICAgdmFyIHJhZCA9IE1hdGguYXRhbjIocG9zWzFdIC0gY3ksIHBvc1swXSAtIGN4KTtcblxuICAgICAgICBpZiAocmFkIDwgMCkge1xuICAgICAgICAgIHJhZCA9IE1hdGguUEkgKiAyICsgcmFkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzTGVmdCA9IHBvc1swXSA8IGN4O1xuXG4gICAgICAgIGlmIChpc0xlZnQpIHtcbiAgICAgICAgICByYWQgPSByYWQgLSBNYXRoLlBJO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRQb3NpdGlvbiA9IGlzTGVmdCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgIHN5bWJvbFBhdGguc2V0VGV4dENvbmZpZyh7XG4gICAgICAgICAgcm90YXRpb246IC1yYWQsXG4gICAgICAgICAgcG9zaXRpb246IHRleHRQb3NpdGlvbixcbiAgICAgICAgICBvcmlnaW46ICdjZW50ZXInXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZW1waGFzaXNTdGF0ZSA9IHN5bWJvbFBhdGguZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJyk7XG4gICAgICAgIHpyVXRpbC5leHRlbmQoZW1waGFzaXNTdGF0ZS50ZXh0Q29uZmlnIHx8IChlbXBoYXNpc1N0YXRlLnRleHRDb25maWcgPSB7fSksIHtcbiAgICAgICAgICBwb3NpdGlvbjogdGV4dFBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ltYm9sUGF0aC5zZXRUZXh0Q29uZmlnKHtcbiAgICAgICAgICByb3RhdGlvbjogbGFiZWxSb3RhdGUgKj0gTWF0aC5QSSAvIDE4MFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9maXJzdFJlbmRlciA9IGZhbHNlO1xuICB9O1xuXG4gIEdyYXBoVmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jb250cm9sbGVyICYmIHRoaXMuX2NvbnRyb2xsZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2NvbnRyb2xsZXJIb3N0ID0gbnVsbDtcbiAgfTtcblxuICBHcmFwaFZpZXcucHJvdG90eXBlLl9zdGFydEZvcmNlTGF5b3V0SXRlcmF0aW9uID0gZnVuY3Rpb24gKGZvcmNlTGF5b3V0LCBsYXlvdXRBbmltYXRpb24pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAoZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIGZvcmNlTGF5b3V0LnN0ZXAoZnVuY3Rpb24gKHN0b3BwZWQpIHtcbiAgICAgICAgc2VsZi51cGRhdGVMYXlvdXQoc2VsZi5fbW9kZWwpO1xuICAgICAgICAoc2VsZi5fbGF5b3V0aW5nID0gIXN0b3BwZWQpICYmIChsYXlvdXRBbmltYXRpb24gPyBzZWxmLl9sYXlvdXRUaW1lb3V0ID0gc2V0VGltZW91dChzdGVwLCAxNikgOiBzdGVwKCkpO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfTtcblxuICBHcmFwaFZpZXcucHJvdG90eXBlLl91cGRhdGVDb250cm9sbGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVyO1xuICAgIHZhciBjb250cm9sbGVySG9zdCA9IHRoaXMuX2NvbnRyb2xsZXJIb3N0O1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgY29udHJvbGxlci5zZXRQb2ludGVyQ2hlY2tlcihmdW5jdGlvbiAoZSwgeCwgeSkge1xuICAgICAgdmFyIHJlY3QgPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgIHJlY3QuYXBwbHlUcmFuc2Zvcm0oZ3JvdXAudHJhbnNmb3JtKTtcbiAgICAgIHJldHVybiByZWN0LmNvbnRhaW4oeCwgeSkgJiYgIW9uSXJyZWxldmFudEVsZW1lbnQoZSwgYXBpLCBzZXJpZXNNb2RlbCk7XG4gICAgfSk7XG5cbiAgICBpZiAoIWlzVmlld0Nvb3JkU3lzKHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0pKSB7XG4gICAgICBjb250cm9sbGVyLmRpc2FibGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250cm9sbGVyLmVuYWJsZShzZXJpZXNNb2RlbC5nZXQoJ3JvYW0nKSk7XG4gICAgY29udHJvbGxlckhvc3Quem9vbUxpbWl0ID0gc2VyaWVzTW9kZWwuZ2V0KCdzY2FsZUxpbWl0Jyk7XG4gICAgY29udHJvbGxlckhvc3Quem9vbSA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0Wm9vbSgpO1xuICAgIGNvbnRyb2xsZXIub2ZmKCdwYW4nKS5vZmYoJ3pvb20nKS5vbigncGFuJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJvYW1IZWxwZXIudXBkYXRlVmlld09uUGFuKGNvbnRyb2xsZXJIb3N0LCBlLmR4LCBlLmR5KTtcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgIHNlcmllc0lkOiBzZXJpZXNNb2RlbC5pZCxcbiAgICAgICAgdHlwZTogJ2dyYXBoUm9hbScsXG4gICAgICAgIGR4OiBlLmR4LFxuICAgICAgICBkeTogZS5keVxuICAgICAgfSk7XG4gICAgfSkub24oJ3pvb20nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcm9hbUhlbHBlci51cGRhdGVWaWV3T25ab29tKGNvbnRyb2xsZXJIb3N0LCBlLnNjYWxlLCBlLm9yaWdpblgsIGUub3JpZ2luWSk7XG4gICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICBzZXJpZXNJZDogc2VyaWVzTW9kZWwuaWQsXG4gICAgICAgIHR5cGU6ICdncmFwaFJvYW0nLFxuICAgICAgICB6b29tOiBlLnNjYWxlLFxuICAgICAgICBvcmlnaW5YOiBlLm9yaWdpblgsXG4gICAgICAgIG9yaWdpblk6IGUub3JpZ2luWVxuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLl91cGRhdGVOb2RlQW5kTGlua1NjYWxlKCk7XG5cbiAgICAgIGFkanVzdEVkZ2Uoc2VyaWVzTW9kZWwuZ2V0R3JhcGgoKSwgZ2V0Tm9kZUdsb2JhbFNjYWxlKHNlcmllc01vZGVsKSk7XG5cbiAgICAgIF90aGlzLl9saW5lRHJhdy51cGRhdGVMYXlvdXQoKTsgLy8gT25seSB1cGRhdGUgbGFiZWwgbGF5b3V0IG9uIHpvb21cblxuXG4gICAgICBhcGkudXBkYXRlTGFiZWxMYXlvdXQoKTtcbiAgICB9KTtcbiAgfTtcblxuICBHcmFwaFZpZXcucHJvdG90eXBlLl91cGRhdGVOb2RlQW5kTGlua1NjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBub2RlU2NhbGUgPSBnZXROb2RlR2xvYmFsU2NhbGUoc2VyaWVzTW9kZWwpO1xuICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgIGVsLnNldFN5bWJvbFNjYWxlKG5vZGVTY2FsZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgR3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGVMYXlvdXQgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICBhZGp1c3RFZGdlKHNlcmllc01vZGVsLmdldEdyYXBoKCksIGdldE5vZGVHbG9iYWxTY2FsZShzZXJpZXNNb2RlbCkpO1xuXG4gICAgdGhpcy5fc3ltYm9sRHJhdy51cGRhdGVMYXlvdXQoKTtcblxuICAgIHRoaXMuX2xpbmVEcmF3LnVwZGF0ZUxheW91dCgpO1xuICB9O1xuXG4gIEdyYXBoVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuX3N5bWJvbERyYXcgJiYgdGhpcy5fc3ltYm9sRHJhdy5yZW1vdmUoKTtcbiAgICB0aGlzLl9saW5lRHJhdyAmJiB0aGlzLl9saW5lRHJhdy5yZW1vdmUoKTtcbiAgfTtcblxuICBHcmFwaFZpZXcudHlwZSA9ICdncmFwaCc7XG4gIHJldHVybiBHcmFwaFZpZXc7XG59KENoYXJ0Vmlldyk7XG5cbmV4cG9ydCBkZWZhdWx0IEdyYXBoVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgY3VydmVUb29sIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvY3VydmUnO1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvcic7XG5pbXBvcnQgeyBnZXRTeW1ib2xTaXplIH0gZnJvbSAnLi9ncmFwaEhlbHBlcic7XG52YXIgdjEgPSBbXTtcbnZhciB2MiA9IFtdO1xudmFyIHYzID0gW107XG52YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZVRvb2wucXVhZHJhdGljQXQ7XG52YXIgdjJEaXN0U3F1YXJlID0gdmVjMi5kaXN0U3F1YXJlO1xudmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuZnVuY3Rpb24gaW50ZXJzZWN0Q3VydmVDaXJjbGUoY3VydmVQb2ludHMsIGNlbnRlciwgcmFkaXVzKSB7XG4gIHZhciBwMCA9IGN1cnZlUG9pbnRzWzBdO1xuICB2YXIgcDEgPSBjdXJ2ZVBvaW50c1sxXTtcbiAgdmFyIHAyID0gY3VydmVQb2ludHNbMl07XG4gIHZhciBkID0gSW5maW5pdHk7XG4gIHZhciB0O1xuICB2YXIgcmFkaXVzU3F1YXJlID0gcmFkaXVzICogcmFkaXVzO1xuICB2YXIgaW50ZXJ2YWwgPSAwLjE7XG5cbiAgZm9yICh2YXIgX3QgPSAwLjE7IF90IDw9IDAuOTsgX3QgKz0gMC4xKSB7XG4gICAgdjFbMF0gPSBxdWFkcmF0aWNBdChwMFswXSwgcDFbMF0sIHAyWzBdLCBfdCk7XG4gICAgdjFbMV0gPSBxdWFkcmF0aWNBdChwMFsxXSwgcDFbMV0sIHAyWzFdLCBfdCk7XG4gICAgdmFyIGRpZmYgPSBtYXRoQWJzKHYyRGlzdFNxdWFyZSh2MSwgY2VudGVyKSAtIHJhZGl1c1NxdWFyZSk7XG5cbiAgICBpZiAoZGlmZiA8IGQpIHtcbiAgICAgIGQgPSBkaWZmO1xuICAgICAgdCA9IF90O1xuICAgIH1cbiAgfSAvLyBBc3N1bWUgdGhlIHNlZ21lbnQgaXMgbW9ub3RvbmXvvIxGaW5kIHJvb3QgdGhyb3VnaCBCaXNlY3Rpb24gbWV0aG9kXG4gIC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAvLyBsZXQgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICB2YXIgbmV4dCA9IHQgKyBpbnRlcnZhbDsgLy8gdjFbMF0gPSBxdWFkcmF0aWNBdChwMFswXSwgcDFbMF0sIHAyWzBdLCBwcmV2KTtcbiAgICAvLyB2MVsxXSA9IHF1YWRyYXRpY0F0KHAwWzFdLCBwMVsxXSwgcDJbMV0sIHByZXYpO1xuXG4gICAgdjJbMF0gPSBxdWFkcmF0aWNBdChwMFswXSwgcDFbMF0sIHAyWzBdLCB0KTtcbiAgICB2MlsxXSA9IHF1YWRyYXRpY0F0KHAwWzFdLCBwMVsxXSwgcDJbMV0sIHQpO1xuICAgIHYzWzBdID0gcXVhZHJhdGljQXQocDBbMF0sIHAxWzBdLCBwMlswXSwgbmV4dCk7XG4gICAgdjNbMV0gPSBxdWFkcmF0aWNBdChwMFsxXSwgcDFbMV0sIHAyWzFdLCBuZXh0KTtcbiAgICB2YXIgZGlmZiA9IHYyRGlzdFNxdWFyZSh2MiwgY2VudGVyKSAtIHJhZGl1c1NxdWFyZTtcblxuICAgIGlmIChtYXRoQWJzKGRpZmYpIDwgMWUtMikge1xuICAgICAgYnJlYWs7XG4gICAgfSAvLyBsZXQgcHJldkRpZmYgPSB2MkRpc3RTcXVhcmUodjEsIGNlbnRlcikgLSByYWRpdXNTcXVhcmU7XG5cblxuICAgIHZhciBuZXh0RGlmZiA9IHYyRGlzdFNxdWFyZSh2MywgY2VudGVyKSAtIHJhZGl1c1NxdWFyZTtcbiAgICBpbnRlcnZhbCAvPSAyO1xuXG4gICAgaWYgKGRpZmYgPCAwKSB7XG4gICAgICBpZiAobmV4dERpZmYgPj0gMCkge1xuICAgICAgICB0ID0gdCArIGludGVydmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IHQgLSBpbnRlcnZhbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5leHREaWZmID49IDApIHtcbiAgICAgICAgdCA9IHQgLSBpbnRlcnZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSB0ICsgaW50ZXJ2YWw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHQ7XG59IC8vIEFkanVzdCBlZGdlIHRvIGF2b2lkXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRqdXN0RWRnZShncmFwaCwgc2NhbGUpIHtcbiAgdmFyIHRtcDAgPSBbXTtcbiAgdmFyIHF1YWRyYXRpY1N1YmRpdmlkZSA9IGN1cnZlVG9vbC5xdWFkcmF0aWNTdWJkaXZpZGU7XG4gIHZhciBwdHMgPSBbW10sIFtdLCBbXV07XG4gIHZhciBwdHMyID0gW1tdLCBbXV07XG4gIHZhciB2ID0gW107XG4gIHNjYWxlIC89IDI7XG4gIGdyYXBoLmVhY2hFZGdlKGZ1bmN0aW9uIChlZGdlLCBpZHgpIHtcbiAgICB2YXIgbGluZVBvaW50cyA9IGVkZ2UuZ2V0TGF5b3V0KCk7XG4gICAgdmFyIGZyb21TeW1ib2wgPSBlZGdlLmdldFZpc3VhbCgnZnJvbVN5bWJvbCcpO1xuICAgIHZhciB0b1N5bWJvbCA9IGVkZ2UuZ2V0VmlzdWFsKCd0b1N5bWJvbCcpO1xuXG4gICAgaWYgKCFsaW5lUG9pbnRzLl9fb3JpZ2luYWwpIHtcbiAgICAgIGxpbmVQb2ludHMuX19vcmlnaW5hbCA9IFt2ZWMyLmNsb25lKGxpbmVQb2ludHNbMF0pLCB2ZWMyLmNsb25lKGxpbmVQb2ludHNbMV0pXTtcblxuICAgICAgaWYgKGxpbmVQb2ludHNbMl0pIHtcbiAgICAgICAgbGluZVBvaW50cy5fX29yaWdpbmFsLnB1c2godmVjMi5jbG9uZShsaW5lUG9pbnRzWzJdKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbmFsUG9pbnRzID0gbGluZVBvaW50cy5fX29yaWdpbmFsOyAvLyBRdWFkcmF0aWMgY3VydmVcblxuICAgIGlmIChsaW5lUG9pbnRzWzJdICE9IG51bGwpIHtcbiAgICAgIHZlYzIuY29weShwdHNbMF0sIG9yaWdpbmFsUG9pbnRzWzBdKTtcbiAgICAgIHZlYzIuY29weShwdHNbMV0sIG9yaWdpbmFsUG9pbnRzWzJdKTtcbiAgICAgIHZlYzIuY29weShwdHNbMl0sIG9yaWdpbmFsUG9pbnRzWzFdKTtcblxuICAgICAgaWYgKGZyb21TeW1ib2wgJiYgZnJvbVN5bWJvbCAhPT0gJ25vbmUnKSB7XG4gICAgICAgIHZhciBzeW1ib2xTaXplID0gZ2V0U3ltYm9sU2l6ZShlZGdlLm5vZGUxKTtcbiAgICAgICAgdmFyIHQgPSBpbnRlcnNlY3RDdXJ2ZUNpcmNsZShwdHMsIG9yaWdpbmFsUG9pbnRzWzBdLCBzeW1ib2xTaXplICogc2NhbGUpOyAvLyBTdWJkaXZpZGUgYW5kIGdldCB0aGUgc2Vjb25kXG5cbiAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKHB0c1swXVswXSwgcHRzWzFdWzBdLCBwdHNbMl1bMF0sIHQsIHRtcDApO1xuICAgICAgICBwdHNbMF1bMF0gPSB0bXAwWzNdO1xuICAgICAgICBwdHNbMV1bMF0gPSB0bXAwWzRdO1xuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUocHRzWzBdWzFdLCBwdHNbMV1bMV0sIHB0c1syXVsxXSwgdCwgdG1wMCk7XG4gICAgICAgIHB0c1swXVsxXSA9IHRtcDBbM107XG4gICAgICAgIHB0c1sxXVsxXSA9IHRtcDBbNF07XG4gICAgICB9XG5cbiAgICAgIGlmICh0b1N5bWJvbCAmJiB0b1N5bWJvbCAhPT0gJ25vbmUnKSB7XG4gICAgICAgIHZhciBzeW1ib2xTaXplID0gZ2V0U3ltYm9sU2l6ZShlZGdlLm5vZGUyKTtcbiAgICAgICAgdmFyIHQgPSBpbnRlcnNlY3RDdXJ2ZUNpcmNsZShwdHMsIG9yaWdpbmFsUG9pbnRzWzFdLCBzeW1ib2xTaXplICogc2NhbGUpOyAvLyBTdWJkaXZpZGUgYW5kIGdldCB0aGUgZmlyc3RcblxuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUocHRzWzBdWzBdLCBwdHNbMV1bMF0sIHB0c1syXVswXSwgdCwgdG1wMCk7XG4gICAgICAgIHB0c1sxXVswXSA9IHRtcDBbMV07XG4gICAgICAgIHB0c1syXVswXSA9IHRtcDBbMl07XG4gICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZShwdHNbMF1bMV0sIHB0c1sxXVsxXSwgcHRzWzJdWzFdLCB0LCB0bXAwKTtcbiAgICAgICAgcHRzWzFdWzFdID0gdG1wMFsxXTtcbiAgICAgICAgcHRzWzJdWzFdID0gdG1wMFsyXTtcbiAgICAgIH0gLy8gQ29weSBiYWNrIHRvIGxheW91dFxuXG5cbiAgICAgIHZlYzIuY29weShsaW5lUG9pbnRzWzBdLCBwdHNbMF0pO1xuICAgICAgdmVjMi5jb3B5KGxpbmVQb2ludHNbMV0sIHB0c1syXSk7XG4gICAgICB2ZWMyLmNvcHkobGluZVBvaW50c1syXSwgcHRzWzFdKTtcbiAgICB9IC8vIExpbmVcbiAgICBlbHNlIHtcbiAgICAgICAgdmVjMi5jb3B5KHB0czJbMF0sIG9yaWdpbmFsUG9pbnRzWzBdKTtcbiAgICAgICAgdmVjMi5jb3B5KHB0czJbMV0sIG9yaWdpbmFsUG9pbnRzWzFdKTtcbiAgICAgICAgdmVjMi5zdWIodiwgcHRzMlsxXSwgcHRzMlswXSk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKHYsIHYpO1xuXG4gICAgICAgIGlmIChmcm9tU3ltYm9sICYmIGZyb21TeW1ib2wgIT09ICdub25lJykge1xuICAgICAgICAgIHZhciBzeW1ib2xTaXplID0gZ2V0U3ltYm9sU2l6ZShlZGdlLm5vZGUxKTtcbiAgICAgICAgICB2ZWMyLnNjYWxlQW5kQWRkKHB0czJbMF0sIHB0czJbMF0sIHYsIHN5bWJvbFNpemUgKiBzY2FsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9TeW1ib2wgJiYgdG9TeW1ib2wgIT09ICdub25lJykge1xuICAgICAgICAgIHZhciBzeW1ib2xTaXplID0gZ2V0U3ltYm9sU2l6ZShlZGdlLm5vZGUyKTtcbiAgICAgICAgICB2ZWMyLnNjYWxlQW5kQWRkKHB0czJbMV0sIHB0czJbMV0sIHYsIC1zeW1ib2xTaXplICogc2NhbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmVjMi5jb3B5KGxpbmVQb2ludHNbMF0sIHB0czJbMF0pO1xuICAgICAgICB2ZWMyLmNvcHkobGluZVBvaW50c1sxXSwgcHRzMlsxXSk7XG4gICAgICB9XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYXRlZ29yeUZpbHRlcihlY01vZGVsKSB7XG4gIHZhciBsZWdlbmRNb2RlbHMgPSBlY01vZGVsLmZpbmRDb21wb25lbnRzKHtcbiAgICBtYWluVHlwZTogJ2xlZ2VuZCdcbiAgfSk7XG5cbiAgaWYgKCFsZWdlbmRNb2RlbHMgfHwgIWxlZ2VuZE1vZGVscy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ2dyYXBoJywgZnVuY3Rpb24gKGdyYXBoU2VyaWVzKSB7XG4gICAgdmFyIGNhdGVnb3JpZXNEYXRhID0gZ3JhcGhTZXJpZXMuZ2V0Q2F0ZWdvcmllc0RhdGEoKTtcbiAgICB2YXIgZ3JhcGggPSBncmFwaFNlcmllcy5nZXRHcmFwaCgpO1xuICAgIHZhciBkYXRhID0gZ3JhcGguZGF0YTtcbiAgICB2YXIgY2F0ZWdvcnlOYW1lcyA9IGNhdGVnb3JpZXNEYXRhLm1hcEFycmF5KGNhdGVnb3JpZXNEYXRhLmdldE5hbWUpO1xuICAgIGRhdGEuZmlsdGVyU2VsZihmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgbW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgdmFyIGNhdGVnb3J5ID0gbW9kZWwuZ2V0U2hhbGxvdygnY2F0ZWdvcnknKTtcblxuICAgICAgaWYgKGNhdGVnb3J5ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYXRlZ29yeSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBjYXRlZ29yeSA9IGNhdGVnb3J5TmFtZXNbY2F0ZWdvcnldO1xuICAgICAgICB9IC8vIElmIGluIGFueSBsZWdlbmQgY29tcG9uZW50IHRoZSBzdGF0dXMgaXMgbm90IHNlbGVjdGVkLlxuXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWdlbmRNb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWxlZ2VuZE1vZGVsc1tpXS5pc1NlbGVjdGVkKGNhdGVnb3J5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYXRlZ29yeVZpc3VhbChlY01vZGVsKSB7XG4gIHZhciBwYWxldHRlU2NvcGUgPSB7fTtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCdncmFwaCcsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBjYXRlZ29yaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldENhdGVnb3JpZXNEYXRhKCk7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGNhdGVnb3J5TmFtZUlkeE1hcCA9IHt9O1xuICAgIGNhdGVnb3JpZXNEYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIG5hbWUgPSBjYXRlZ29yaWVzRGF0YS5nZXROYW1lKGlkeCk7IC8vIEFkZCBwcmVmaXggdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlLlxuXG4gICAgICBjYXRlZ29yeU5hbWVJZHhNYXBbJ2VjLScgKyBuYW1lXSA9IGlkeDtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBjYXRlZ29yaWVzRGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgIHZhciBzdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJykuZ2V0SXRlbVN0eWxlKCk7XG5cbiAgICAgIGlmICghc3R5bGUuZmlsbCkge1xuICAgICAgICAvLyBHZXQgY29sb3IgZnJvbSBwYWxldHRlLlxuICAgICAgICBzdHlsZS5maWxsID0gc2VyaWVzTW9kZWwuZ2V0Q29sb3JGcm9tUGFsZXR0ZShuYW1lLCBwYWxldHRlU2NvcGUpO1xuICAgICAgfVxuXG4gICAgICBjYXRlZ29yaWVzRGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJywgc3R5bGUpO1xuICAgICAgdmFyIHN5bWJvbFZpc3VhbExpc3QgPSBbJ3N5bWJvbCcsICdzeW1ib2xTaXplJywgJ3N5bWJvbEtlZXBBc3BlY3QnXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xWaXN1YWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzeW1ib2xWaXN1YWwgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdyhzeW1ib2xWaXN1YWxMaXN0W2ldLCB0cnVlKTtcblxuICAgICAgICBpZiAoc3ltYm9sVmlzdWFsICE9IG51bGwpIHtcbiAgICAgICAgICBjYXRlZ29yaWVzRGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwgc3ltYm9sVmlzdWFsTGlzdFtpXSwgc3ltYm9sVmlzdWFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyBBc3NpZ24gY2F0ZWdvcnkgY29sb3IgdG8gdmlzdWFsXG5cbiAgICBpZiAoY2F0ZWdvcmllc0RhdGEuY291bnQoKSkge1xuICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgICAgdmFyIGNhdGVnb3J5SWR4ID0gbW9kZWwuZ2V0U2hhbGxvdygnY2F0ZWdvcnknKTtcblxuICAgICAgICBpZiAoY2F0ZWdvcnlJZHggIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2F0ZWdvcnlJZHggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjYXRlZ29yeUlkeCA9IGNhdGVnb3J5TmFtZUlkeE1hcFsnZWMtJyArIGNhdGVnb3J5SWR4XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2F0ZWdvcnlTdHlsZSA9IGNhdGVnb3JpZXNEYXRhLmdldEl0ZW1WaXN1YWwoY2F0ZWdvcnlJZHgsICdzdHlsZScpO1xuICAgICAgICAgIHZhciBzdHlsZSA9IGRhdGEuZW5zdXJlVW5pcXVlSXRlbVZpc3VhbChpZHgsICdzdHlsZScpO1xuICAgICAgICAgIGV4dGVuZChzdHlsZSwgY2F0ZWdvcnlTdHlsZSk7XG4gICAgICAgICAgdmFyIHZpc3VhbExpc3QgPSBbJ3N5bWJvbCcsICdzeW1ib2xTaXplJywgJ3N5bWJvbEtlZXBBc3BlY3QnXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlzdWFsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwgdmlzdWFsTGlzdFtpXSwgY2F0ZWdvcmllc0RhdGEuZ2V0SXRlbVZpc3VhbChjYXRlZ29yeUlkeCwgdmlzdWFsTGlzdFtpXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgY2lyY3VsYXJMYXlvdXQgfSBmcm9tICcuL2NpcmN1bGFyTGF5b3V0SGVscGVyJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdyYXBoQ2lyY3VsYXJMYXlvdXQoZWNNb2RlbCkge1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ2dyYXBoJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgaWYgKHNlcmllc01vZGVsLmdldCgnbGF5b3V0JykgPT09ICdjaXJjdWxhcicpIHtcbiAgICAgIGNpcmN1bGFyTGF5b3V0KHNlcmllc01vZGVsLCAnc3ltYm9sU2l6ZScpO1xuICAgIH1cbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnenJlbmRlci9saWIvY29yZS92ZWN0b3InO1xuaW1wb3J0IHsgZ2V0U3ltYm9sU2l6ZSwgZ2V0Tm9kZUdsb2JhbFNjYWxlIH0gZnJvbSAnLi9ncmFwaEhlbHBlcic7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCB7IGdldEN1cnZlbmVzc0ZvckVkZ2UgfSBmcm9tICcuLi9oZWxwZXIvbXVsdGlwbGVHcmFwaEVkZ2VIZWxwZXInO1xudmFyIFBJID0gTWF0aC5QSTtcbnZhciBfc3ltYm9sUmFkaWFuc0hhbGYgPSBbXTtcbi8qKlxuICogYGJhc2VkT25gIGNhbiBiZTpcbiAqICd2YWx1ZSc6XG4gKiAgICAgVGhpcyBsYXlvdXQgaXMgbm90IGFjY3VyYXRlIGFuZCBoYXZlIHNhbWUgYmFkIGNhc2UuIEZvciBleGFtcGxlLFxuICogICAgIGlmIHRoZSBtaW4gdmFsdWUgaXMgdmVyeSBzbWFsbGVyIHRoYW4gdGhlIG1heCB2YWx1ZSwgdGhlIG5vZGVzXG4gKiAgICAgd2l0aCB0aGUgbWluIHZhbHVlIHByb2JhYmx5IG92ZXJsYXAgZXZlbiB0aG91Z2ggdGhlcmUgaXMgZW5vdWdoXG4gKiAgICAgc3BhY2UgdG8gbGF5b3V0IHRoZW0uIFNvIHdlIG9ubHkgdXNlIHRoaXMgYXBwcm9hY2ggaW4gdGhlIGFzIHRoZVxuICogICAgIGluaXQgbGF5b3V0IG9mIHRoZSBmb3JjZSBsYXlvdXQuXG4gKiAgICAgRklYTUVcbiAqICAgICBQcm9iYWJseSB3ZSBkbyBub3QgbmVlZCB0aGlzIG1ldGhvZCBhbnkgbW9yZSBidXQgdXNlXG4gKiAgICAgYGJhc2VkT246ICdzeW1ib2xTaXplJ2AgaW4gZm9yY2UgbGF5b3V0IGlmXG4gKiAgICAgZGVsYXkgaXRzIGluaXQgb3BlcmF0aW9ucyB0byBHcmFwaFZpZXcuXG4gKiAnc3ltYm9sU2l6ZSc6XG4gKiAgICAgVGhpcyBhcHByb2FjaCB3b3JrIG9ubHkgaWYgYWxsIG9mIHRoZSBzeW1ib2wgc2l6ZSBjYWxjdWxhdGVkLlxuICogICAgIFRoYXQgaXMsIHRoZSBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgaXMgbm90IGFwcGxpZWQgdG8gZ3JhcGguXG4gKiAgICAgRklYTUVcbiAqICAgICBJZiBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgaXMgYXBwbGllZCB0byBncmFwaCBzb21lIGRheSxcbiAqICAgICBwcm9iYWJseSB3ZSBoYXZlIHRvIHVzZSBgYmFzZWRPbjogJ3ZhbHVlJ2AuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNpcmN1bGFyTGF5b3V0KHNlcmllc01vZGVsLCBiYXNlZE9uKSB7XG4gIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgaWYgKGNvb3JkU3lzICYmIGNvb3JkU3lzLnR5cGUgIT09ICd2aWV3Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZWN0ID0gY29vcmRTeXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gIHZhciBub2RlRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIGdyYXBoID0gbm9kZURhdGEuZ3JhcGg7XG4gIHZhciBjeCA9IHJlY3Qud2lkdGggLyAyICsgcmVjdC54O1xuICB2YXIgY3kgPSByZWN0LmhlaWdodCAvIDIgKyByZWN0Lnk7XG4gIHZhciByID0gTWF0aC5taW4ocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpIC8gMjtcbiAgdmFyIGNvdW50ID0gbm9kZURhdGEuY291bnQoKTtcbiAgbm9kZURhdGEuc2V0TGF5b3V0KHtcbiAgICBjeDogY3gsXG4gICAgY3k6IGN5XG4gIH0pO1xuXG4gIGlmICghY291bnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBfbGF5b3V0Tm9kZXNCYXNlZE9uW2Jhc2VkT25dKHNlcmllc01vZGVsLCBncmFwaCwgbm9kZURhdGEsIHIsIGN4LCBjeSwgY291bnQpO1xuXG4gIGdyYXBoLmVhY2hFZGdlKGZ1bmN0aW9uIChlZGdlLCBpbmRleCkge1xuICAgIHZhciBjdXJ2ZW5lc3MgPSB6clV0aWwucmV0cmlldmUzKGVkZ2UuZ2V0TW9kZWwoKS5nZXQoWydsaW5lU3R5bGUnLCAnY3VydmVuZXNzJ10pLCBnZXRDdXJ2ZW5lc3NGb3JFZGdlKGVkZ2UsIHNlcmllc01vZGVsLCBpbmRleCksIDApO1xuICAgIHZhciBwMSA9IHZlYzIuY2xvbmUoZWRnZS5ub2RlMS5nZXRMYXlvdXQoKSk7XG4gICAgdmFyIHAyID0gdmVjMi5jbG9uZShlZGdlLm5vZGUyLmdldExheW91dCgpKTtcbiAgICB2YXIgY3AxO1xuICAgIHZhciB4MTIgPSAocDFbMF0gKyBwMlswXSkgLyAyO1xuICAgIHZhciB5MTIgPSAocDFbMV0gKyBwMlsxXSkgLyAyO1xuXG4gICAgaWYgKCtjdXJ2ZW5lc3MpIHtcbiAgICAgIGN1cnZlbmVzcyAqPSAzO1xuICAgICAgY3AxID0gW2N4ICogY3VydmVuZXNzICsgeDEyICogKDEgLSBjdXJ2ZW5lc3MpLCBjeSAqIGN1cnZlbmVzcyArIHkxMiAqICgxIC0gY3VydmVuZXNzKV07XG4gICAgfVxuXG4gICAgZWRnZS5zZXRMYXlvdXQoW3AxLCBwMiwgY3AxXSk7XG4gIH0pO1xufVxudmFyIF9sYXlvdXROb2Rlc0Jhc2VkT24gPSB7XG4gIHZhbHVlOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGdyYXBoLCBub2RlRGF0YSwgciwgY3gsIGN5LCBjb3VudCkge1xuICAgIHZhciBhbmdsZSA9IDA7XG4gICAgdmFyIHN1bSA9IG5vZGVEYXRhLmdldFN1bSgndmFsdWUnKTtcbiAgICB2YXIgdW5pdEFuZ2xlID0gTWF0aC5QSSAqIDIgLyAoc3VtIHx8IGNvdW50KTtcbiAgICBncmFwaC5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRWYWx1ZSgndmFsdWUnKTtcbiAgICAgIHZhciByYWRpYW5IYWxmID0gdW5pdEFuZ2xlICogKHN1bSA/IHZhbHVlIDogMSkgLyAyO1xuICAgICAgYW5nbGUgKz0gcmFkaWFuSGFsZjtcbiAgICAgIG5vZGUuc2V0TGF5b3V0KFtyICogTWF0aC5jb3MoYW5nbGUpICsgY3gsIHIgKiBNYXRoLnNpbihhbmdsZSkgKyBjeV0pO1xuICAgICAgYW5nbGUgKz0gcmFkaWFuSGFsZjtcbiAgICB9KTtcbiAgfSxcbiAgc3ltYm9sU2l6ZTogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBncmFwaCwgbm9kZURhdGEsIHIsIGN4LCBjeSwgY291bnQpIHtcbiAgICB2YXIgc3VtUmFkaWFuID0gMDtcbiAgICBfc3ltYm9sUmFkaWFuc0hhbGYubGVuZ3RoID0gY291bnQ7XG4gICAgdmFyIG5vZGVTY2FsZSA9IGdldE5vZGVHbG9iYWxTY2FsZShzZXJpZXNNb2RlbCk7XG4gICAgZ3JhcGguZWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBzeW1ib2xTaXplID0gZ2V0U3ltYm9sU2l6ZShub2RlKTsgLy8gTm9ybWFsbHkgdGhpcyBjYXNlIHdpbGwgbm90IGhhcHBlbiwgYnV0IHdlIHN0aWxsIGFkZFxuICAgICAgLy8gc29tZSB0aGUgZGVmZW5zaXZlIGNvZGUgKDJweCBpcyBhbiBhcmJpdHJhcnkgdmFsdWUpLlxuXG4gICAgICBpc05hTihzeW1ib2xTaXplKSAmJiAoc3ltYm9sU2l6ZSA9IDIpO1xuICAgICAgc3ltYm9sU2l6ZSA8IDAgJiYgKHN5bWJvbFNpemUgPSAwKTtcbiAgICAgIHN5bWJvbFNpemUgKj0gbm9kZVNjYWxlO1xuICAgICAgdmFyIHN5bWJvbFJhZGlhbkhhbGYgPSBNYXRoLmFzaW4oc3ltYm9sU2l6ZSAvIDIgLyByKTsgLy8gd2hlbiBgc3ltYm9sU2l6ZSAvIDJgIGlzIGJpZ2dlciB0aGFuIGByYC5cblxuICAgICAgaXNOYU4oc3ltYm9sUmFkaWFuSGFsZikgJiYgKHN5bWJvbFJhZGlhbkhhbGYgPSBQSSAvIDIpO1xuICAgICAgX3N5bWJvbFJhZGlhbnNIYWxmW25vZGUuZGF0YUluZGV4XSA9IHN5bWJvbFJhZGlhbkhhbGY7XG4gICAgICBzdW1SYWRpYW4gKz0gc3ltYm9sUmFkaWFuSGFsZiAqIDI7XG4gICAgfSk7XG4gICAgdmFyIGhhbGZSZW1haW5SYWRpYW4gPSAoMiAqIFBJIC0gc3VtUmFkaWFuKSAvIGNvdW50IC8gMjtcbiAgICB2YXIgYW5nbGUgPSAwO1xuICAgIGdyYXBoLmVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgcmFkaWFuSGFsZiA9IGhhbGZSZW1haW5SYWRpYW4gKyBfc3ltYm9sUmFkaWFuc0hhbGZbbm9kZS5kYXRhSW5kZXhdO1xuICAgICAgYW5nbGUgKz0gcmFkaWFuSGFsZjtcbiAgICAgIG5vZGUuc2V0TGF5b3V0KFtyICogTWF0aC5jb3MoYW5nbGUpICsgY3gsIHIgKiBNYXRoLnNpbihhbmdsZSkgKyBjeV0pO1xuICAgICAgYW5nbGUgKz0gcmFkaWFuSGFsZjtcbiAgICB9KTtcbiAgfVxufTsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gRklYTUUgV2hlcmUgdG8gY3JlYXRlIHRoZSBzaW1wbGUgdmlldyBjb29yZGluYXRlIHN5c3RlbVxuaW1wb3J0IFZpZXcgZnJvbSAnLi4vLi4vY29vcmQvVmlldyc7XG5pbXBvcnQgeyBnZXRMYXlvdXRSZWN0IH0gZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQnO1xuaW1wb3J0ICogYXMgYmJveCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL2Jib3gnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcblxuZnVuY3Rpb24gZ2V0Vmlld1JlY3Qoc2VyaWVzTW9kZWwsIGFwaSwgYXNwZWN0KSB7XG4gIHZhciBvcHRpb24gPSBleHRlbmQoc2VyaWVzTW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCksIHtcbiAgICBhc3BlY3Q6IGFzcGVjdFxuICB9KTtcbiAgcmV0dXJuIGdldExheW91dFJlY3Qob3B0aW9uLCB7XG4gICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVWaWV3Q29vcmRTeXMoZWNNb2RlbCwgYXBpKSB7XG4gIHZhciB2aWV3TGlzdCA9IFtdO1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ2dyYXBoJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGNvb3JkU3lzVHlwZSA9IHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpO1xuXG4gICAgaWYgKCFjb29yZFN5c1R5cGUgfHwgY29vcmRTeXNUeXBlID09PSAndmlldycpIHtcbiAgICAgIHZhciBkYXRhXzEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB2YXIgcG9zaXRpb25zID0gZGF0YV8xLm1hcEFycmF5KGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGFfMS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgICAgcmV0dXJuIFsraXRlbU1vZGVsLmdldCgneCcpLCAraXRlbU1vZGVsLmdldCgneScpXTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG1pbiA9IFtdO1xuICAgICAgdmFyIG1heCA9IFtdO1xuICAgICAgYmJveC5mcm9tUG9pbnRzKHBvc2l0aW9ucywgbWluLCBtYXgpOyAvLyBJZiB3aWR0aCBvciBoZWlnaHQgaXMgMFxuXG4gICAgICBpZiAobWF4WzBdIC0gbWluWzBdID09PSAwKSB7XG4gICAgICAgIG1heFswXSArPSAxO1xuICAgICAgICBtaW5bMF0gLT0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heFsxXSAtIG1pblsxXSA9PT0gMCkge1xuICAgICAgICBtYXhbMV0gKz0gMTtcbiAgICAgICAgbWluWzFdIC09IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBhc3BlY3QgPSAobWF4WzBdIC0gbWluWzBdKSAvIChtYXhbMV0gLSBtaW5bMV0pOyAvLyBGSVhNRSBJZiBnZXQgdmlldyByZWN0IGFmdGVyIGRhdGEgcHJvY2Vzc2VkP1xuXG4gICAgICB2YXIgdmlld1JlY3QgPSBnZXRWaWV3UmVjdChzZXJpZXNNb2RlbCwgYXBpLCBhc3BlY3QpOyAvLyBQb3NpdGlvbiBtYXkgYmUgTmFOLCB1c2UgdmlldyByZWN0IGluc3RlYWRcblxuICAgICAgaWYgKGlzTmFOKGFzcGVjdCkpIHtcbiAgICAgICAgbWluID0gW3ZpZXdSZWN0LngsIHZpZXdSZWN0LnldO1xuICAgICAgICBtYXggPSBbdmlld1JlY3QueCArIHZpZXdSZWN0LndpZHRoLCB2aWV3UmVjdC55ICsgdmlld1JlY3QuaGVpZ2h0XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJiV2lkdGggPSBtYXhbMF0gLSBtaW5bMF07XG4gICAgICB2YXIgYmJIZWlnaHQgPSBtYXhbMV0gLSBtaW5bMV07XG4gICAgICB2YXIgdmlld1dpZHRoID0gdmlld1JlY3Qud2lkdGg7XG4gICAgICB2YXIgdmlld0hlaWdodCA9IHZpZXdSZWN0LmhlaWdodDtcbiAgICAgIHZhciB2aWV3Q29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gbmV3IFZpZXcoKTtcbiAgICAgIHZpZXdDb29yZFN5cy56b29tTGltaXQgPSBzZXJpZXNNb2RlbC5nZXQoJ3NjYWxlTGltaXQnKTtcbiAgICAgIHZpZXdDb29yZFN5cy5zZXRCb3VuZGluZ1JlY3QobWluWzBdLCBtaW5bMV0sIGJiV2lkdGgsIGJiSGVpZ2h0KTtcbiAgICAgIHZpZXdDb29yZFN5cy5zZXRWaWV3UmVjdCh2aWV3UmVjdC54LCB2aWV3UmVjdC55LCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpOyAvLyBVcGRhdGUgcm9hbSBpbmZvXG5cbiAgICAgIHZpZXdDb29yZFN5cy5zZXRDZW50ZXIoc2VyaWVzTW9kZWwuZ2V0KCdjZW50ZXInKSk7XG4gICAgICB2aWV3Q29vcmRTeXMuc2V0Wm9vbShzZXJpZXNNb2RlbC5nZXQoJ3pvb20nKSk7XG4gICAgICB2aWV3TGlzdC5wdXNoKHZpZXdDb29yZFN5cyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHZpZXdMaXN0O1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuXG5mdW5jdGlvbiBub3JtYWxpemUoYSkge1xuICBpZiAoIShhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgYSA9IFthLCBhXTtcbiAgfVxuXG4gIHJldHVybiBhO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBncmFwaEVkZ2VWaXN1YWwoZWNNb2RlbCkge1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ2dyYXBoJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGdyYXBoID0gc2VyaWVzTW9kZWwuZ2V0R3JhcGgoKTtcbiAgICB2YXIgZWRnZURhdGEgPSBzZXJpZXNNb2RlbC5nZXRFZGdlRGF0YSgpO1xuICAgIHZhciBzeW1ib2xUeXBlID0gbm9ybWFsaXplKHNlcmllc01vZGVsLmdldCgnZWRnZVN5bWJvbCcpKTtcbiAgICB2YXIgc3ltYm9sU2l6ZSA9IG5vcm1hbGl6ZShzZXJpZXNNb2RlbC5nZXQoJ2VkZ2VTeW1ib2xTaXplJykpOyAvLyBjb25zdCBjb2xvclF1ZXJ5ID0gWydsaW5lU3R5bGUnLCAnY29sb3InXSBhcyBjb25zdDtcbiAgICAvLyBjb25zdCBvcGFjaXR5UXVlcnkgPSBbJ2xpbmVTdHlsZScsICdvcGFjaXR5J10gYXMgY29uc3Q7XG5cbiAgICBlZGdlRGF0YS5zZXRWaXN1YWwoJ2Zyb21TeW1ib2wnLCBzeW1ib2xUeXBlICYmIHN5bWJvbFR5cGVbMF0pO1xuICAgIGVkZ2VEYXRhLnNldFZpc3VhbCgndG9TeW1ib2wnLCBzeW1ib2xUeXBlICYmIHN5bWJvbFR5cGVbMV0pO1xuICAgIGVkZ2VEYXRhLnNldFZpc3VhbCgnZnJvbVN5bWJvbFNpemUnLCBzeW1ib2xTaXplICYmIHN5bWJvbFNpemVbMF0pO1xuICAgIGVkZ2VEYXRhLnNldFZpc3VhbCgndG9TeW1ib2xTaXplJywgc3ltYm9sU2l6ZSAmJiBzeW1ib2xTaXplWzFdKTtcbiAgICBlZGdlRGF0YS5zZXRWaXN1YWwoJ3N0eWxlJywgc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpKTtcbiAgICBlZGdlRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBlZGdlRGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgIHZhciBlZGdlID0gZ3JhcGguZ2V0RWRnZUJ5SW5kZXgoaWR4KTtcbiAgICAgIHZhciBzeW1ib2xUeXBlID0gbm9ybWFsaXplKGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2wnLCB0cnVlKSk7XG4gICAgICB2YXIgc3ltYm9sU2l6ZSA9IG5vcm1hbGl6ZShpdGVtTW9kZWwuZ2V0U2hhbGxvdygnc3ltYm9sU2l6ZScsIHRydWUpKTsgLy8gRWRnZSB2aXN1YWwgbXVzdCBhZnRlciBub2RlIHZpc3VhbFxuXG4gICAgICB2YXIgc3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpO1xuICAgICAgdmFyIGV4aXN0c1N0eWxlID0gZWRnZURhdGEuZW5zdXJlVW5pcXVlSXRlbVZpc3VhbChpZHgsICdzdHlsZScpO1xuICAgICAgZXh0ZW5kKGV4aXN0c1N0eWxlLCBzdHlsZSk7XG5cbiAgICAgIHN3aXRjaCAoZXhpc3RzU3R5bGUuc3Ryb2tlKSB7XG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5vZGVTdHlsZSA9IGVkZ2Uubm9kZTEuZ2V0VmlzdWFsKCdzdHlsZScpO1xuICAgICAgICAgICAgZXhpc3RzU3R5bGUuc3Ryb2tlID0gbm9kZVN0eWxlICYmIG5vZGVTdHlsZS5maWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5vZGVTdHlsZSA9IGVkZ2Uubm9kZTIuZ2V0VmlzdWFsKCdzdHlsZScpO1xuICAgICAgICAgICAgZXhpc3RzU3R5bGUuc3Ryb2tlID0gbm9kZVN0eWxlICYmIG5vZGVTdHlsZS5maWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzeW1ib2xUeXBlWzBdICYmIGVkZ2Uuc2V0VmlzdWFsKCdmcm9tU3ltYm9sJywgc3ltYm9sVHlwZVswXSk7XG4gICAgICBzeW1ib2xUeXBlWzFdICYmIGVkZ2Uuc2V0VmlzdWFsKCd0b1N5bWJvbCcsIHN5bWJvbFR5cGVbMV0pO1xuICAgICAgc3ltYm9sU2l6ZVswXSAmJiBlZGdlLnNldFZpc3VhbCgnZnJvbVN5bWJvbFNpemUnLCBzeW1ib2xTaXplWzBdKTtcbiAgICAgIHN5bWJvbFNpemVbMV0gJiYgZWRnZS5zZXRWaXN1YWwoJ3RvU3ltYm9sU2l6ZScsIHN5bWJvbFNpemVbMV0pO1xuICAgIH0pO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKlxuKiBBIHRoaXJkLXBhcnR5IGxpY2Vuc2UgaXMgZW1iZWRlZCBmb3Igc29tZSBvZiB0aGUgY29kZSBpbiB0aGlzIGZpbGU6XG4qIFNvbWUgZm9ybXVsYXMgd2VyZSBvcmlnaW5hbGx5IGNvcGllZCBmcm9tIFwiZDMuanNcIiB3aXRoIHNvbWVcbiogbW9kaWZpY2F0aW9ucyBtYWRlIGZvciB0aGlzIHByb2plY3QuXG4qIChTZWUgbW9yZSBkZXRhaWxzIGluIHRoZSBjb21tZW50IG9mIHRoZSBtZXRob2QgXCJzdGVwXCIgYmVsb3cuKVxuKiBUaGUgdXNlIG9mIHRoZSBzb3VyY2UgY29kZSBvZiB0aGlzIGZpbGUgaXMgYWxzbyBzdWJqZWN0IHRvIHRoZSB0ZXJtc1xuKiBhbmQgY29uc2l0aW9ucyBvZiB0aGUgbGljZW5zZSBvZiBcImQzLmpzXCIgKEJTRC0zQ2xhdXNlLCBzZWVcbiogPC9saWNlbnNlcy9MSUNFTlNFLWQzPikuXG4qL1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvcic7XG52YXIgc2NhbGVBbmRBZGQgPSB2ZWMyLnNjYWxlQW5kQWRkOyAvLyBmdW5jdGlvbiBhZGphY2VudE5vZGUobiwgZSkge1xuLy8gICAgIHJldHVybiBlLm4xID09PSBuID8gZS5uMiA6IGUubjE7XG4vLyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JjZUxheW91dChpbk5vZGVzLCBpbkVkZ2VzLCBvcHRzKSB7XG4gIHZhciBub2RlcyA9IGluTm9kZXM7XG4gIHZhciBlZGdlcyA9IGluRWRnZXM7XG4gIHZhciByZWN0ID0gb3B0cy5yZWN0O1xuICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIHZhciBjZW50ZXIgPSBbcmVjdC54ICsgd2lkdGggLyAyLCByZWN0LnkgKyBoZWlnaHQgLyAyXTsgLy8gbGV0IHNjYWxlID0gb3B0cy5zY2FsZSB8fCAxO1xuXG4gIHZhciBncmF2aXR5ID0gb3B0cy5ncmF2aXR5ID09IG51bGwgPyAwLjEgOiBvcHRzLmdyYXZpdHk7IC8vIGZvciAobGV0IGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgLy8gICAgIGxldCBlID0gZWRnZXNbaV07XG4gIC8vICAgICBsZXQgbjEgPSBlLm4xO1xuICAvLyAgICAgbGV0IG4yID0gZS5uMjtcbiAgLy8gICAgIG4xLmVkZ2VzID0gbjEuZWRnZXMgfHwgW107XG4gIC8vICAgICBuMi5lZGdlcyA9IG4yLmVkZ2VzIHx8IFtdO1xuICAvLyAgICAgbjEuZWRnZXMucHVzaChlKTtcbiAgLy8gICAgIG4yLmVkZ2VzLnB1c2goZSk7XG4gIC8vIH1cbiAgLy8gSW5pdCBwb3NpdGlvblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbiA9IG5vZGVzW2ldO1xuXG4gICAgaWYgKCFuLnApIHtcbiAgICAgIG4ucCA9IHZlYzIuY3JlYXRlKHdpZHRoICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICsgY2VudGVyWzBdLCBoZWlnaHQgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKyBjZW50ZXJbMV0pO1xuICAgIH1cblxuICAgIG4ucHAgPSB2ZWMyLmNsb25lKG4ucCk7XG4gICAgbi5lZGdlcyA9IG51bGw7XG4gIH0gLy8gRm9ybXVsYSBpbiAnR3JhcGggRHJhd2luZyBieSBGb3JjZS1kaXJlY3RlZCBQbGFjZW1lbnQnXG4gIC8vIGxldCBrID0gc2NhbGUgKiBNYXRoLnNxcnQod2lkdGggKiBoZWlnaHQgLyBub2Rlcy5sZW5ndGgpO1xuICAvLyBsZXQgazIgPSBrICogaztcblxuXG4gIHZhciBpbml0aWFsRnJpY3Rpb24gPSBvcHRzLmZyaWN0aW9uID09IG51bGwgPyAwLjYgOiBvcHRzLmZyaWN0aW9uO1xuICB2YXIgZnJpY3Rpb24gPSBpbml0aWFsRnJpY3Rpb247XG4gIHZhciBiZWZvcmVTdGVwQ2FsbGJhY2s7XG4gIHZhciBhZnRlclN0ZXBDYWxsYmFjaztcbiAgcmV0dXJuIHtcbiAgICB3YXJtVXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZyaWN0aW9uID0gaW5pdGlhbEZyaWN0aW9uICogMC44O1xuICAgIH0sXG4gICAgc2V0Rml4ZWQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIG5vZGVzW2lkeF0uZml4ZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgc2V0VW5maXhlZDogZnVuY3Rpb24gKGlkeCkge1xuICAgICAgbm9kZXNbaWR4XS5maXhlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCZWZvcmUgc3RlcCBob29rXG4gICAgICovXG4gICAgYmVmb3JlU3RlcDogZnVuY3Rpb24gKGNiKSB7XG4gICAgICBiZWZvcmVTdGVwQ2FsbGJhY2sgPSBjYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWZ0ZXIgc3RlcCBob29rXG4gICAgICovXG4gICAgYWZ0ZXJTdGVwOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIGFmdGVyU3RlcENhbGxiYWNrID0gY2I7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNvbWUgZm9ybXVsYXMgd2VyZSBvcmlnaW5hbGx5IGNvcGllZCBmcm9tIFwiZDMuanNcIlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy9ibG9iL2I1MTZkNzdmYjg1NjZiNTc2MDg4ZTczNDEwNDM3NDk0NzE3YWRhMjYvc3JjL2xheW91dC9mb3JjZS5qc1xuICAgICAqIHdpdGggc29tZSBtb2RpZmljYXRpb25zIG1hZGUgZm9yIHRoaXMgcHJvamVjdC5cbiAgICAgKiBTZWUgdGhlIGxpY2Vuc2Ugc3RhdGVtZW50IGF0IHRoZSBoZWFkIG9mIHRoaXMgZmlsZS5cbiAgICAgKi9cbiAgICBzdGVwOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIGJlZm9yZVN0ZXBDYWxsYmFjayAmJiBiZWZvcmVTdGVwQ2FsbGJhY2sobm9kZXMsIGVkZ2VzKTtcbiAgICAgIHZhciB2MTIgPSBbXTtcbiAgICAgIHZhciBuTGVuID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlID0gZWRnZXNbaV07XG5cbiAgICAgICAgaWYgKGUuaWdub3JlRm9yY2VMYXlvdXQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuMSA9IGUubjE7XG4gICAgICAgIHZhciBuMiA9IGUubjI7XG4gICAgICAgIHZlYzIuc3ViKHYxMiwgbjIucCwgbjEucCk7XG4gICAgICAgIHZhciBkID0gdmVjMi5sZW4odjEyKSAtIGUuZDtcbiAgICAgICAgdmFyIHcgPSBuMi53IC8gKG4xLncgKyBuMi53KTtcblxuICAgICAgICBpZiAoaXNOYU4odykpIHtcbiAgICAgICAgICB3ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZlYzIubm9ybWFsaXplKHYxMiwgdjEyKTtcbiAgICAgICAgIW4xLmZpeGVkICYmIHNjYWxlQW5kQWRkKG4xLnAsIG4xLnAsIHYxMiwgdyAqIGQgKiBmcmljdGlvbik7XG4gICAgICAgICFuMi5maXhlZCAmJiBzY2FsZUFuZEFkZChuMi5wLCBuMi5wLCB2MTIsIC0oMSAtIHcpICogZCAqIGZyaWN0aW9uKTtcbiAgICAgIH0gLy8gR3Jhdml0eVxuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBuID0gbm9kZXNbaV07XG5cbiAgICAgICAgaWYgKCFuLmZpeGVkKSB7XG4gICAgICAgICAgdmVjMi5zdWIodjEyLCBjZW50ZXIsIG4ucCk7IC8vIGxldCBkID0gdmVjMi5sZW4odjEyKTtcbiAgICAgICAgICAvLyB2ZWMyLnNjYWxlKHYxMiwgdjEyLCAxIC8gZCk7XG4gICAgICAgICAgLy8gbGV0IGdyYXZpdHlGYWN0b3IgPSBncmF2aXR5O1xuXG4gICAgICAgICAgc2NhbGVBbmRBZGQobi5wLCBuLnAsIHYxMiwgZ3Jhdml0eSAqIGZyaWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZXB1bHNpdmVcbiAgICAgIC8vIFBFTkRJTkdcblxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5MZW47IGkrKykge1xuICAgICAgICB2YXIgbjEgPSBub2Rlc1tpXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBuTGVuOyBqKyspIHtcbiAgICAgICAgICB2YXIgbjIgPSBub2Rlc1tqXTtcbiAgICAgICAgICB2ZWMyLnN1Yih2MTIsIG4yLnAsIG4xLnApO1xuICAgICAgICAgIHZhciBkID0gdmVjMi5sZW4odjEyKTtcblxuICAgICAgICAgIGlmIChkID09PSAwKSB7XG4gICAgICAgICAgICAvLyBSYW5kb20gcmVwdWxzZVxuICAgICAgICAgICAgdmVjMi5zZXQodjEyLCBNYXRoLnJhbmRvbSgpIC0gMC41LCBNYXRoLnJhbmRvbSgpIC0gMC41KTtcbiAgICAgICAgICAgIGQgPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZXBGYWN0ID0gKG4xLnJlcCArIG4yLnJlcCkgLyBkIC8gZDtcbiAgICAgICAgICAhbjEuZml4ZWQgJiYgc2NhbGVBbmRBZGQobjEucHAsIG4xLnBwLCB2MTIsIHJlcEZhY3QpO1xuICAgICAgICAgICFuMi5maXhlZCAmJiBzY2FsZUFuZEFkZChuMi5wcCwgbjIucHAsIHYxMiwgLXJlcEZhY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBuID0gbm9kZXNbaV07XG5cbiAgICAgICAgaWYgKCFuLmZpeGVkKSB7XG4gICAgICAgICAgdmVjMi5zdWIodiwgbi5wLCBuLnBwKTtcbiAgICAgICAgICBzY2FsZUFuZEFkZChuLnAsIG4ucCwgdiwgZnJpY3Rpb24pO1xuICAgICAgICAgIHZlYzIuY29weShuLnBwLCBuLnApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyaWN0aW9uID0gZnJpY3Rpb24gKiAwLjk5MjtcbiAgICAgIHZhciBmaW5pc2hlZCA9IGZyaWN0aW9uIDwgMC4wMTtcbiAgICAgIGFmdGVyU3RlcENhbGxiYWNrICYmIGFmdGVyU3RlcENhbGxiYWNrKG5vZGVzLCBlZGdlcywgZmluaXNoZWQpO1xuICAgICAgY2IgJiYgY2IoZmluaXNoZWQpO1xuICAgIH1cbiAgfTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgZm9yY2VMYXlvdXQgfSBmcm9tICcuL2ZvcmNlSGVscGVyJztcbmltcG9ydCB7IHNpbXBsZUxheW91dCB9IGZyb20gJy4vc2ltcGxlTGF5b3V0SGVscGVyJztcbmltcG9ydCB7IGNpcmN1bGFyTGF5b3V0IH0gZnJvbSAnLi9jaXJjdWxhckxheW91dEhlbHBlcic7XG5pbXBvcnQgeyBsaW5lYXJNYXAgfSBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJztcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgZ2V0Q3VydmVuZXNzRm9yRWRnZSB9IGZyb20gJy4uL2hlbHBlci9tdWx0aXBsZUdyYXBoRWRnZUhlbHBlcic7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBncmFwaEZvcmNlTGF5b3V0KGVjTW9kZWwpIHtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCdncmFwaCcsIGZ1bmN0aW9uIChncmFwaFNlcmllcykge1xuICAgIHZhciBjb29yZFN5cyA9IGdyYXBoU2VyaWVzLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMudHlwZSAhPT0gJ3ZpZXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGdyYXBoU2VyaWVzLmdldCgnbGF5b3V0JykgPT09ICdmb3JjZScpIHtcbiAgICAgIHZhciBwcmVzZXJ2ZWRQb2ludHNfMSA9IGdyYXBoU2VyaWVzLnByZXNlcnZlZFBvaW50cyB8fCB7fTtcbiAgICAgIHZhciBncmFwaF8xID0gZ3JhcGhTZXJpZXMuZ2V0R3JhcGgoKTtcbiAgICAgIHZhciBub2RlRGF0YV8xID0gZ3JhcGhfMS5kYXRhO1xuICAgICAgdmFyIGVkZ2VEYXRhID0gZ3JhcGhfMS5lZGdlRGF0YTtcbiAgICAgIHZhciBmb3JjZU1vZGVsID0gZ3JhcGhTZXJpZXMuZ2V0TW9kZWwoJ2ZvcmNlJyk7XG4gICAgICB2YXIgaW5pdExheW91dCA9IGZvcmNlTW9kZWwuZ2V0KCdpbml0TGF5b3V0Jyk7XG5cbiAgICAgIGlmIChncmFwaFNlcmllcy5wcmVzZXJ2ZWRQb2ludHMpIHtcbiAgICAgICAgbm9kZURhdGFfMS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICB2YXIgaWQgPSBub2RlRGF0YV8xLmdldElkKGlkeCk7XG4gICAgICAgICAgbm9kZURhdGFfMS5zZXRJdGVtTGF5b3V0KGlkeCwgcHJlc2VydmVkUG9pbnRzXzFbaWRdIHx8IFtOYU4sIE5hTl0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIWluaXRMYXlvdXQgfHwgaW5pdExheW91dCA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHNpbXBsZUxheW91dChncmFwaFNlcmllcyk7XG4gICAgICB9IGVsc2UgaWYgKGluaXRMYXlvdXQgPT09ICdjaXJjdWxhcicpIHtcbiAgICAgICAgY2lyY3VsYXJMYXlvdXQoZ3JhcGhTZXJpZXMsICd2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZURhdGFFeHRlbnRfMSA9IG5vZGVEYXRhXzEuZ2V0RGF0YUV4dGVudCgndmFsdWUnKTtcbiAgICAgIHZhciBlZGdlRGF0YUV4dGVudF8xID0gZWRnZURhdGEuZ2V0RGF0YUV4dGVudCgndmFsdWUnKTsgLy8gbGV0IGVkZ2VEYXRhRXh0ZW50ID0gZWRnZURhdGEuZ2V0RGF0YUV4dGVudCgndmFsdWUnKTtcblxuICAgICAgdmFyIHJlcHVsc2lvbiA9IGZvcmNlTW9kZWwuZ2V0KCdyZXB1bHNpb24nKTtcbiAgICAgIHZhciBlZGdlTGVuZ3RoID0gZm9yY2VNb2RlbC5nZXQoJ2VkZ2VMZW5ndGgnKTtcbiAgICAgIHZhciByZXB1bHNpb25BcnJfMSA9IHpyVXRpbC5pc0FycmF5KHJlcHVsc2lvbikgPyByZXB1bHNpb24gOiBbcmVwdWxzaW9uLCByZXB1bHNpb25dO1xuICAgICAgdmFyIGVkZ2VMZW5ndGhBcnJfMSA9IHpyVXRpbC5pc0FycmF5KGVkZ2VMZW5ndGgpID8gZWRnZUxlbmd0aCA6IFtlZGdlTGVuZ3RoLCBlZGdlTGVuZ3RoXTsgLy8gTGFyZ2VyIHZhbHVlIGhhcyBzbWFsbGVyIGxlbmd0aFxuXG4gICAgICBlZGdlTGVuZ3RoQXJyXzEgPSBbZWRnZUxlbmd0aEFycl8xWzFdLCBlZGdlTGVuZ3RoQXJyXzFbMF1dO1xuICAgICAgdmFyIG5vZGVzXzEgPSBub2RlRGF0YV8xLm1hcEFycmF5KCd2YWx1ZScsIGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICAgIHZhciBwb2ludCA9IG5vZGVEYXRhXzEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgICB2YXIgcmVwID0gbGluZWFyTWFwKHZhbHVlLCBub2RlRGF0YUV4dGVudF8xLCByZXB1bHNpb25BcnJfMSk7XG5cbiAgICAgICAgaWYgKGlzTmFOKHJlcCkpIHtcbiAgICAgICAgICByZXAgPSAocmVwdWxzaW9uQXJyXzFbMF0gKyByZXB1bHNpb25BcnJfMVsxXSkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3OiByZXAsXG4gICAgICAgICAgcmVwOiByZXAsXG4gICAgICAgICAgZml4ZWQ6IG5vZGVEYXRhXzEuZ2V0SXRlbU1vZGVsKGlkeCkuZ2V0KCdmaXhlZCcpLFxuICAgICAgICAgIHA6ICFwb2ludCB8fCBpc05hTihwb2ludFswXSkgfHwgaXNOYU4ocG9pbnRbMV0pID8gbnVsbCA6IHBvaW50XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHZhciBlZGdlcyA9IGVkZ2VEYXRhLm1hcEFycmF5KCd2YWx1ZScsIGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICAgIHZhciBlZGdlID0gZ3JhcGhfMS5nZXRFZGdlQnlJbmRleChpZHgpO1xuICAgICAgICB2YXIgZCA9IGxpbmVhck1hcCh2YWx1ZSwgZWRnZURhdGFFeHRlbnRfMSwgZWRnZUxlbmd0aEFycl8xKTtcblxuICAgICAgICBpZiAoaXNOYU4oZCkpIHtcbiAgICAgICAgICBkID0gKGVkZ2VMZW5ndGhBcnJfMVswXSArIGVkZ2VMZW5ndGhBcnJfMVsxXSkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkZ2VNb2RlbCA9IGVkZ2UuZ2V0TW9kZWwoKTtcbiAgICAgICAgdmFyIGN1cnZlbmVzcyA9IHpyVXRpbC5yZXRyaWV2ZTMoZWRnZS5nZXRNb2RlbCgpLmdldChbJ2xpbmVTdHlsZScsICdjdXJ2ZW5lc3MnXSksIC1nZXRDdXJ2ZW5lc3NGb3JFZGdlKGVkZ2UsIGdyYXBoU2VyaWVzLCBpZHgsIHRydWUpLCAwKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuMTogbm9kZXNfMVtlZGdlLm5vZGUxLmRhdGFJbmRleF0sXG4gICAgICAgICAgbjI6IG5vZGVzXzFbZWRnZS5ub2RlMi5kYXRhSW5kZXhdLFxuICAgICAgICAgIGQ6IGQsXG4gICAgICAgICAgY3VydmVuZXNzOiBjdXJ2ZW5lc3MsXG4gICAgICAgICAgaWdub3JlRm9yY2VMYXlvdXQ6IGVkZ2VNb2RlbC5nZXQoJ2lnbm9yZUZvcmNlTGF5b3V0JylcbiAgICAgICAgfTtcbiAgICAgIH0pOyAvLyBsZXQgY29vcmRTeXMgPSBncmFwaFNlcmllcy5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgICB2YXIgcmVjdCA9IGNvb3JkU3lzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgdmFyIGZvcmNlSW5zdGFuY2UgPSBmb3JjZUxheW91dChub2Rlc18xLCBlZGdlcywge1xuICAgICAgICByZWN0OiByZWN0LFxuICAgICAgICBncmF2aXR5OiBmb3JjZU1vZGVsLmdldCgnZ3Jhdml0eScpLFxuICAgICAgICBmcmljdGlvbjogZm9yY2VNb2RlbC5nZXQoJ2ZyaWN0aW9uJylcbiAgICAgIH0pO1xuICAgICAgZm9yY2VJbnN0YW5jZS5iZWZvcmVTdGVwKGZ1bmN0aW9uIChub2RlcywgZWRnZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAobm9kZXNbaV0uZml4ZWQpIHtcbiAgICAgICAgICAgIC8vIFdyaXRlIGJhY2sgdG8gbGF5b3V0IGluc3RhbmNlXG4gICAgICAgICAgICB2ZWMyLmNvcHkobm9kZXNbaV0ucCwgZ3JhcGhfMS5nZXROb2RlQnlJbmRleChpKS5nZXRMYXlvdXQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGZvcmNlSW5zdGFuY2UuYWZ0ZXJTdGVwKGZ1bmN0aW9uIChub2RlcywgZWRnZXMsIHN0b3BwZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoIW5vZGVzW2ldLmZpeGVkKSB7XG4gICAgICAgICAgICBncmFwaF8xLmdldE5vZGVCeUluZGV4KGkpLnNldExheW91dChub2Rlc1tpXS5wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcmVzZXJ2ZWRQb2ludHNfMVtub2RlRGF0YV8xLmdldElkKGkpXSA9IG5vZGVzW2ldLnA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVkZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgICAgICAgdmFyIGVkZ2UgPSBncmFwaF8xLmdldEVkZ2VCeUluZGV4KGkpO1xuICAgICAgICAgIHZhciBwMSA9IGUubjEucDtcbiAgICAgICAgICB2YXIgcDIgPSBlLm4yLnA7XG4gICAgICAgICAgdmFyIHBvaW50cyA9IGVkZ2UuZ2V0TGF5b3V0KCk7XG4gICAgICAgICAgcG9pbnRzID0gcG9pbnRzID8gcG9pbnRzLnNsaWNlKCkgOiBbXTtcbiAgICAgICAgICBwb2ludHNbMF0gPSBwb2ludHNbMF0gfHwgW107XG4gICAgICAgICAgcG9pbnRzWzFdID0gcG9pbnRzWzFdIHx8IFtdO1xuICAgICAgICAgIHZlYzIuY29weShwb2ludHNbMF0sIHAxKTtcbiAgICAgICAgICB2ZWMyLmNvcHkocG9pbnRzWzFdLCBwMik7XG5cbiAgICAgICAgICBpZiAoK2UuY3VydmVuZXNzKSB7XG4gICAgICAgICAgICBwb2ludHNbMl0gPSBbKHAxWzBdICsgcDJbMF0pIC8gMiAtIChwMVsxXSAtIHAyWzFdKSAqIGUuY3VydmVuZXNzLCAocDFbMV0gKyBwMlsxXSkgLyAyIC0gKHAyWzBdIC0gcDFbMF0pICogZS5jdXJ2ZW5lc3NdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVkZ2Uuc2V0TGF5b3V0KHBvaW50cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZ3JhcGhTZXJpZXMuZm9yY2VMYXlvdXQgPSBmb3JjZUluc3RhbmNlO1xuICAgICAgZ3JhcGhTZXJpZXMucHJlc2VydmVkUG9pbnRzID0gcHJlc2VydmVkUG9pbnRzXzE7IC8vIFN0ZXAgdG8gZ2V0IHRoZSBsYXlvdXRcblxuICAgICAgZm9yY2VJbnN0YW5jZS5zdGVwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSBwcmV2IGluamVjdGVkIGZvcmNlTGF5b3V0IGluc3RhbmNlXG4gICAgICBncmFwaFNlcmllcy5mb3JjZUxheW91dCA9IG51bGw7XG4gICAgfVxuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVHbG9iYWxTY2FsZShzZXJpZXNNb2RlbCkge1xuICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gIGlmIChjb29yZFN5cy50eXBlICE9PSAndmlldycpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBub2RlU2NhbGVSYXRpbyA9IHNlcmllc01vZGVsLm9wdGlvbi5ub2RlU2NhbGVSYXRpbztcbiAgdmFyIGdyb3VwWm9vbSA9IGNvb3JkU3lzLnNjYWxlWDsgLy8gU2NhbGUgbm9kZSB3aGVuIHpvb20gY2hhbmdlc1xuXG4gIHZhciByb2FtWm9vbSA9IGNvb3JkU3lzLmdldFpvb20oKTtcbiAgdmFyIG5vZGVTY2FsZSA9IChyb2FtWm9vbSAtIDEpICogbm9kZVNjYWxlUmF0aW8gKyAxO1xuICByZXR1cm4gbm9kZVNjYWxlIC8gZ3JvdXBab29tO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFN5bWJvbFNpemUobm9kZSkge1xuICB2YXIgc3ltYm9sU2l6ZSA9IG5vZGUuZ2V0VmlzdWFsKCdzeW1ib2xTaXplJyk7XG5cbiAgaWYgKHN5bWJvbFNpemUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHN5bWJvbFNpemUgPSAoc3ltYm9sU2l6ZVswXSArIHN5bWJvbFNpemVbMV0pIC8gMjtcbiAgfVxuXG4gIHJldHVybiArc3ltYm9sU2l6ZTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IGNhdGVnb3J5RmlsdGVyIGZyb20gJy4vY2F0ZWdvcnlGaWx0ZXInO1xuaW1wb3J0IGNhdGVnb3J5VmlzdWFsIGZyb20gJy4vY2F0ZWdvcnlWaXN1YWwnO1xuaW1wb3J0IGVkZ2VWaXN1YWwgZnJvbSAnLi9lZGdlVmlzdWFsJztcbmltcG9ydCBzaW1wbGVMYXlvdXQgZnJvbSAnLi9zaW1wbGVMYXlvdXQnO1xuaW1wb3J0IGNpcmN1bGFyTGF5b3V0IGZyb20gJy4vY2lyY3VsYXJMYXlvdXQnO1xuaW1wb3J0IGZvcmNlTGF5b3V0IGZyb20gJy4vZm9yY2VMYXlvdXQnO1xuaW1wb3J0IGNyZWF0ZVZpZXcgZnJvbSAnLi9jcmVhdGVWaWV3JztcbmltcG9ydCBWaWV3IGZyb20gJy4uLy4uL2Nvb3JkL1ZpZXcnO1xuaW1wb3J0IEdyYXBoVmlldyBmcm9tICcuL0dyYXBoVmlldyc7XG5pbXBvcnQgR3JhcGhTZXJpZXNNb2RlbCBmcm9tICcuL0dyYXBoU2VyaWVzJztcbmltcG9ydCB7IHVwZGF0ZUNlbnRlckFuZFpvb20gfSBmcm9tICcuLi8uLi9hY3Rpb24vcm9hbUhlbHBlcic7XG52YXIgYWN0aW9uSW5mbyA9IHtcbiAgdHlwZTogJ2dyYXBoUm9hbScsXG4gIGV2ZW50OiAnZ3JhcGhSb2FtJyxcbiAgdXBkYXRlOiAnbm9uZSdcbn07XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ2hhcnRWaWV3KEdyYXBoVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclNlcmllc01vZGVsKEdyYXBoU2VyaWVzTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJQcm9jZXNzb3IoY2F0ZWdvcnlGaWx0ZXIpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJWaXN1YWwoY2F0ZWdvcnlWaXN1YWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJWaXN1YWwoZWRnZVZpc3VhbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckxheW91dChzaW1wbGVMYXlvdXQpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQocmVnaXN0ZXJzLlBSSU9SSVRZLlZJU1VBTC5QT1NUX0NIQVJUX0xBWU9VVCwgY2lyY3VsYXJMYXlvdXQpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQoZm9yY2VMYXlvdXQpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb29yZGluYXRlU3lzdGVtKCdncmFwaFZpZXcnLCB7XG4gICAgZGltZW5zaW9uczogVmlldy5kaW1lbnNpb25zLFxuICAgIGNyZWF0ZTogY3JlYXRlVmlld1xuICB9KTsgLy8gUmVnaXN0ZXIgbGVnYWN5IGZvY3VzIGFjdGlvbnNcblxuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oe1xuICAgIHR5cGU6ICdmb2N1c05vZGVBZGphY2VuY3knLFxuICAgIGV2ZW50OiAnZm9jdXNOb2RlQWRqYWNlbmN5JyxcbiAgICB1cGRhdGU6ICdzZXJpZXM6Zm9jdXNOb2RlQWRqYWNlbmN5J1xuICB9LCBmdW5jdGlvbiAoKSB7fSk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbih7XG4gICAgdHlwZTogJ3VuZm9jdXNOb2RlQWRqYWNlbmN5JyxcbiAgICBldmVudDogJ3VuZm9jdXNOb2RlQWRqYWNlbmN5JyxcbiAgICB1cGRhdGU6ICdzZXJpZXM6dW5mb2N1c05vZGVBZGphY2VuY3knXG4gIH0sIGZ1bmN0aW9uICgpIHt9KTsgLy8gUmVnaXN0ZXIgcm9hbSBhY3Rpb24uXG5cbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKGFjdGlvbkluZm8sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgIG1haW5UeXBlOiAnc2VyaWVzJyxcbiAgICAgIHF1ZXJ5OiBwYXlsb2FkXG4gICAgfSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgdmFyIHJlcyA9IHVwZGF0ZUNlbnRlckFuZFpvb20oY29vcmRTeXMsIHBheWxvYWQpO1xuICAgICAgc2VyaWVzTW9kZWwuc2V0Q2VudGVyICYmIHNlcmllc01vZGVsLnNldENlbnRlcihyZXMuY2VudGVyKTtcbiAgICAgIHNlcmllc01vZGVsLnNldFpvb20gJiYgc2VyaWVzTW9kZWwuc2V0Wm9vbShyZXMuem9vbSk7XG4gICAgfSk7XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCB7IHNpbXBsZUxheW91dCwgc2ltcGxlTGF5b3V0RWRnZSB9IGZyb20gJy4vc2ltcGxlTGF5b3V0SGVscGVyJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdyYXBoU2ltcGxlTGF5b3V0KGVjTW9kZWwsIGFwaSkge1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ2dyYXBoJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGxheW91dCA9IHNlcmllc01vZGVsLmdldCgnbGF5b3V0Jyk7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgIGlmIChjb29yZFN5cyAmJiBjb29yZFN5cy50eXBlICE9PSAndmlldycpIHtcbiAgICAgIHZhciBkYXRhXzEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB2YXIgZGltZW5zaW9uc18xID0gW107XG4gICAgICBlYWNoKGNvb3JkU3lzLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChjb29yZERpbSkge1xuICAgICAgICBkaW1lbnNpb25zXzEgPSBkaW1lbnNpb25zXzEuY29uY2F0KGRhdGFfMS5tYXBEaW1lbnNpb25zQWxsKGNvb3JkRGltKSk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgZGF0YUluZGV4ID0gMDsgZGF0YUluZGV4IDwgZGF0YV8xLmNvdW50KCk7IGRhdGFJbmRleCsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IFtdO1xuICAgICAgICB2YXIgaGFzVmFsdWUgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnNfMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB2YWwgPSBkYXRhXzEuZ2V0KGRpbWVuc2lvbnNfMVtpXSwgZGF0YUluZGV4KTtcblxuICAgICAgICAgIGlmICghaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlLnB1c2godmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNWYWx1ZSkge1xuICAgICAgICAgIGRhdGFfMS5zZXRJdGVtTGF5b3V0KGRhdGFJbmRleCwgY29vcmRTeXMuZGF0YVRvUG9pbnQodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbHNvIHtBcnJheS48bnVtYmVyPn0sIG5vdCB1bmRlZmluZWQgdG8gYXZvaWQgaWYuLi5lbHNlLi4uIHN0YXRlbWVudFxuICAgICAgICAgIGRhdGFfMS5zZXRJdGVtTGF5b3V0KGRhdGFJbmRleCwgW05hTiwgTmFOXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2ltcGxlTGF5b3V0RWRnZShkYXRhXzEuZ3JhcGgsIHNlcmllc01vZGVsKTtcbiAgICB9IGVsc2UgaWYgKCFsYXlvdXQgfHwgbGF5b3V0ID09PSAnbm9uZScpIHtcbiAgICAgIHNpbXBsZUxheW91dChzZXJpZXNNb2RlbCk7XG4gICAgfVxuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvcic7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCB7IGdldEN1cnZlbmVzc0ZvckVkZ2UgfSBmcm9tICcuLi9oZWxwZXIvbXVsdGlwbGVHcmFwaEVkZ2VIZWxwZXInO1xuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsZUxheW91dChzZXJpZXNNb2RlbCkge1xuICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gIGlmIChjb29yZFN5cyAmJiBjb29yZFN5cy50eXBlICE9PSAndmlldycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZ3JhcGggPSBzZXJpZXNNb2RlbC5nZXRHcmFwaCgpO1xuICBncmFwaC5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBtb2RlbCA9IG5vZGUuZ2V0TW9kZWwoKTtcbiAgICBub2RlLnNldExheW91dChbK21vZGVsLmdldCgneCcpLCArbW9kZWwuZ2V0KCd5JyldKTtcbiAgfSk7XG4gIHNpbXBsZUxheW91dEVkZ2UoZ3JhcGgsIHNlcmllc01vZGVsKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGVMYXlvdXRFZGdlKGdyYXBoLCBzZXJpZXNNb2RlbCkge1xuICBncmFwaC5lYWNoRWRnZShmdW5jdGlvbiAoZWRnZSwgaW5kZXgpIHtcbiAgICB2YXIgY3VydmVuZXNzID0genJVdGlsLnJldHJpZXZlMyhlZGdlLmdldE1vZGVsKCkuZ2V0KFsnbGluZVN0eWxlJywgJ2N1cnZlbmVzcyddKSwgLWdldEN1cnZlbmVzc0ZvckVkZ2UoZWRnZSwgc2VyaWVzTW9kZWwsIGluZGV4LCB0cnVlKSwgMCk7XG4gICAgdmFyIHAxID0gdmVjMi5jbG9uZShlZGdlLm5vZGUxLmdldExheW91dCgpKTtcbiAgICB2YXIgcDIgPSB2ZWMyLmNsb25lKGVkZ2Uubm9kZTIuZ2V0TGF5b3V0KCkpO1xuICAgIHZhciBwb2ludHMgPSBbcDEsIHAyXTtcblxuICAgIGlmICgrY3VydmVuZXNzKSB7XG4gICAgICBwb2ludHMucHVzaChbKHAxWzBdICsgcDJbMF0pIC8gMiAtIChwMVsxXSAtIHAyWzFdKSAqIGN1cnZlbmVzcywgKHAxWzFdICsgcDJbMV0pIC8gMiAtIChwMlswXSAtIHAxWzBdKSAqIGN1cnZlbmVzc10pO1xuICAgIH1cblxuICAgIGVkZ2Uuc2V0TGF5b3V0KHBvaW50cyk7XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qIGdsb2JhbCBVaW50OENsYW1wZWRBcnJheSAqL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG52YXIgR1JBRElFTlRfTEVWRUxTID0gMjU2O1xuXG52YXIgSGVhdG1hcExheWVyID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSGVhdG1hcExheWVyKCkge1xuICAgIHRoaXMuYmx1clNpemUgPSAzMDtcbiAgICB0aGlzLnBvaW50U2l6ZSA9IDIwO1xuICAgIHRoaXMubWF4T3BhY2l0eSA9IDE7XG4gICAgdGhpcy5taW5PcGFjaXR5ID0gMDtcbiAgICB0aGlzLl9ncmFkaWVudFBpeGVscyA9IHtcbiAgICAgIGluUmFuZ2U6IG51bGwsXG4gICAgICBvdXRPZlJhbmdlOiBudWxsXG4gICAgfTtcbiAgICB2YXIgY2FudmFzID0genJVdGlsLmNyZWF0ZUNhbnZhcygpO1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIEhlYXRtYXAgYW5kIHJldHVybnMgdGhlIHJlbmRlcmVkIGNhbnZhc1xuICAgKiBAcGFyYW0gZGF0YSBhcnJheSBvZiBkYXRhLCBlYWNoIGhhcyB4LCB5LCB2YWx1ZVxuICAgKiBAcGFyYW0gd2lkdGggY2FudmFzIHdpZHRoXG4gICAqIEBwYXJhbSBoZWlnaHQgY2FudmFzIGhlaWdodFxuICAgKi9cblxuXG4gIEhlYXRtYXBMYXllci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIHdpZHRoLCBoZWlnaHQsIG5vcm1hbGl6ZSwgY29sb3JGdW5jLCBpc0luUmFuZ2UpIHtcbiAgICB2YXIgYnJ1c2ggPSB0aGlzLl9nZXRCcnVzaCgpO1xuXG4gICAgdmFyIGdyYWRpZW50SW5SYW5nZSA9IHRoaXMuX2dldEdyYWRpZW50KGNvbG9yRnVuYywgJ2luUmFuZ2UnKTtcblxuICAgIHZhciBncmFkaWVudE91dE9mUmFuZ2UgPSB0aGlzLl9nZXRHcmFkaWVudChjb2xvckZ1bmMsICdvdXRPZlJhbmdlJyk7XG5cbiAgICB2YXIgciA9IHRoaXMucG9pbnRTaXplICsgdGhpcy5ibHVyU2l6ZTtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdmFyIHAgPSBkYXRhW2ldO1xuICAgICAgdmFyIHggPSBwWzBdO1xuICAgICAgdmFyIHkgPSBwWzFdO1xuICAgICAgdmFyIHZhbHVlID0gcFsyXTsgLy8gY2FsY3VsYXRlIGFscGhhIHVzaW5nIHZhbHVlXG5cbiAgICAgIHZhciBhbHBoYSA9IG5vcm1hbGl6ZSh2YWx1ZSk7IC8vIGRyYXcgd2l0aCB0aGUgY2lyY2xlIGJydXNoIHdpdGggYWxwaGFcblxuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgICBjdHguZHJhd0ltYWdlKGJydXNoLCB4IC0gciwgeSAtIHIpO1xuICAgIH1cblxuICAgIGlmICghY2FudmFzLndpZHRoIHx8ICFjYW52YXMuaGVpZ2h0KSB7XG4gICAgICAvLyBBdm9pZCBcIlVuY2F1Z2h0IERPTUV4Y2VwdGlvbjogRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldEltYWdlRGF0YScgb25cbiAgICAgIC8vICdDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQnOiBUaGUgc291cmNlIGhlaWdodCBpcyAwLlwiXG4gICAgICByZXR1cm4gY2FudmFzO1xuICAgIH0gLy8gY29sb3JpemUgdGhlIGNhbnZhcyB1c2luZyBhbHBoYSB2YWx1ZSBhbmQgc2V0IHdpdGggZ3JhZGllbnRcblxuXG4gICAgdmFyIGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB2YXIgcGl4ZWxzID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIHBpeGVsTGVuID0gcGl4ZWxzLmxlbmd0aDtcbiAgICB2YXIgbWluT3BhY2l0eSA9IHRoaXMubWluT3BhY2l0eTtcbiAgICB2YXIgbWF4T3BhY2l0eSA9IHRoaXMubWF4T3BhY2l0eTtcbiAgICB2YXIgZGlmZk9wYWNpdHkgPSBtYXhPcGFjaXR5IC0gbWluT3BhY2l0eTtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBwaXhlbExlbikge1xuICAgICAgdmFyIGFscGhhID0gcGl4ZWxzW29mZnNldCArIDNdIC8gMjU2O1xuICAgICAgdmFyIGdyYWRpZW50T2Zmc2V0ID0gTWF0aC5mbG9vcihhbHBoYSAqIChHUkFESUVOVF9MRVZFTFMgLSAxKSkgKiA0OyAvLyBTaW1wbGUgb3B0aW1pemUgdG8gaWdub3JlIHRoZSBlbXB0eSBkYXRhXG5cbiAgICAgIGlmIChhbHBoYSA+IDApIHtcbiAgICAgICAgdmFyIGdyYWRpZW50ID0gaXNJblJhbmdlKGFscGhhKSA/IGdyYWRpZW50SW5SYW5nZSA6IGdyYWRpZW50T3V0T2ZSYW5nZTsgLy8gQW55IGFscGhhID4gMCB3aWxsIGJlIG1hcHBlZCB0byBbbWluT3BhY2l0eSwgbWF4T3BhY2l0eV1cblxuICAgICAgICBhbHBoYSA+IDAgJiYgKGFscGhhID0gYWxwaGEgKiBkaWZmT3BhY2l0eSArIG1pbk9wYWNpdHkpO1xuICAgICAgICBwaXhlbHNbb2Zmc2V0KytdID0gZ3JhZGllbnRbZ3JhZGllbnRPZmZzZXRdO1xuICAgICAgICBwaXhlbHNbb2Zmc2V0KytdID0gZ3JhZGllbnRbZ3JhZGllbnRPZmZzZXQgKyAxXTtcbiAgICAgICAgcGl4ZWxzW29mZnNldCsrXSA9IGdyYWRpZW50W2dyYWRpZW50T2Zmc2V0ICsgMl07XG4gICAgICAgIHBpeGVsc1tvZmZzZXQrK10gPSBncmFkaWVudFtncmFkaWVudE9mZnNldCArIDNdICogYWxwaGEgKiAyNTY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfTtcbiAgLyoqXG4gICAqIGdldCBjYW52YXMgb2YgYSBibGFjayBjaXJjbGUgYnJ1c2ggdXNlZCBmb3IgY2FudmFzIHRvIGRyYXcgbGF0ZXJcbiAgICovXG5cblxuICBIZWF0bWFwTGF5ZXIucHJvdG90eXBlLl9nZXRCcnVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYnJ1c2hDYW52YXMgPSB0aGlzLl9icnVzaENhbnZhcyB8fCAodGhpcy5fYnJ1c2hDYW52YXMgPSB6clV0aWwuY3JlYXRlQ2FudmFzKCkpOyAvLyBzZXQgYnJ1c2ggc2l6ZVxuXG4gICAgdmFyIHIgPSB0aGlzLnBvaW50U2l6ZSArIHRoaXMuYmx1clNpemU7XG4gICAgdmFyIGQgPSByICogMjtcbiAgICBicnVzaENhbnZhcy53aWR0aCA9IGQ7XG4gICAgYnJ1c2hDYW52YXMuaGVpZ2h0ID0gZDtcbiAgICB2YXIgY3R4ID0gYnJ1c2hDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGQsIGQpOyAvLyBpbiBvcmRlciB0byByZW5kZXIgc2hhZG93IHdpdGhvdXQgdGhlIGRpc3RpbmN0IGNpcmNsZSxcbiAgICAvLyBkcmF3IHRoZSBkaXN0aW5jdCBjaXJjbGUgaW4gYW4gaW52aXNpYmxlIHBsYWNlLFxuICAgIC8vIGFuZCB1c2Ugc2hhZG93T2Zmc2V0IHRvIGRyYXcgc2hhZG93IGluIHRoZSBjZW50ZXIgb2YgdGhlIGNhbnZhc1xuXG4gICAgY3R4LnNoYWRvd09mZnNldFggPSBkO1xuICAgIGN0eC5zaGFkb3dCbHVyID0gdGhpcy5ibHVyU2l6ZTsgLy8gZHJhdyB0aGUgc2hhZG93IGluIGJsYWNrLCBhbmQgdXNlIGFscGhhIGFuZCBzaGFkb3cgYmx1ciB0byBnZW5lcmF0ZVxuICAgIC8vIGNvbG9yIGluIGNvbG9yIG1hcFxuXG4gICAgY3R4LnNoYWRvd0NvbG9yID0gJyMwMDAnOyAvLyBkcmF3IGNpcmNsZSBpbiB0aGUgbGVmdCB0byB0aGUgY2FudmFzXG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYygtciwgciwgdGhpcy5wb2ludFNpemUsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwoKTtcbiAgICByZXR1cm4gYnJ1c2hDYW52YXM7XG4gIH07XG4gIC8qKlxuICAgKiBnZXQgZ3JhZGllbnQgY29sb3IgbWFwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgSGVhdG1hcExheWVyLnByb3RvdHlwZS5fZ2V0R3JhZGllbnQgPSBmdW5jdGlvbiAoY29sb3JGdW5jLCBzdGF0ZSkge1xuICAgIHZhciBncmFkaWVudFBpeGVscyA9IHRoaXMuX2dyYWRpZW50UGl4ZWxzO1xuICAgIHZhciBwaXhlbHNTaW5nbGVTdGF0ZSA9IGdyYWRpZW50UGl4ZWxzW3N0YXRlXSB8fCAoZ3JhZGllbnRQaXhlbHNbc3RhdGVdID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDI1NiAqIDQpKTtcbiAgICB2YXIgY29sb3IgPSBbMCwgMCwgMCwgMF07XG4gICAgdmFyIG9mZiA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBjb2xvckZ1bmNbc3RhdGVdKGkgLyAyNTUsIHRydWUsIGNvbG9yKTtcbiAgICAgIHBpeGVsc1NpbmdsZVN0YXRlW29mZisrXSA9IGNvbG9yWzBdO1xuICAgICAgcGl4ZWxzU2luZ2xlU3RhdGVbb2ZmKytdID0gY29sb3JbMV07XG4gICAgICBwaXhlbHNTaW5nbGVTdGF0ZVtvZmYrK10gPSBjb2xvclsyXTtcbiAgICAgIHBpeGVsc1NpbmdsZVN0YXRlW29mZisrXSA9IGNvbG9yWzNdO1xuICAgIH1cblxuICAgIHJldHVybiBwaXhlbHNTaW5nbGVTdGF0ZTtcbiAgfTtcblxuICByZXR1cm4gSGVhdG1hcExheWVyO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBIZWF0bWFwTGF5ZXI7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcyc7XG5pbXBvcnQgY3JlYXRlTGlzdEZyb21BcnJheSBmcm9tICcuLi9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheSc7XG5pbXBvcnQgQ29vcmRpbmF0ZVN5c3RlbSBmcm9tICcuLi8uLi9jb3JlL0Nvb3JkaW5hdGVTeXN0ZW0nO1xuXG52YXIgSGVhdG1hcFNlcmllc01vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEhlYXRtYXBTZXJpZXNNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBIZWF0bWFwU2VyaWVzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gSGVhdG1hcFNlcmllc01vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgSGVhdG1hcFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YSA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICByZXR1cm4gY3JlYXRlTGlzdEZyb21BcnJheSh0aGlzLmdldFNvdXJjZSgpLCB0aGlzLCB7XG4gICAgICBnZW5lcmF0ZUNvb3JkOiAndmFsdWUnXG4gICAgfSk7XG4gIH07XG5cbiAgSGVhdG1hcFNlcmllc01vZGVsLnByb3RvdHlwZS5wcmV2ZW50SW5jcmVtZW50YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvb3JkU3lzQ3JlYXRvciA9IENvb3JkaW5hdGVTeXN0ZW0uZ2V0KHRoaXMuZ2V0KCdjb29yZGluYXRlU3lzdGVtJykpO1xuXG4gICAgaWYgKGNvb3JkU3lzQ3JlYXRvciAmJiBjb29yZFN5c0NyZWF0b3IuZGltZW5zaW9ucykge1xuICAgICAgcmV0dXJuIGNvb3JkU3lzQ3JlYXRvci5kaW1lbnNpb25zWzBdID09PSAnbG5nJyAmJiBjb29yZFN5c0NyZWF0b3IuZGltZW5zaW9uc1sxXSA9PT0gJ2xhdCc7XG4gICAgfVxuICB9O1xuXG4gIEhlYXRtYXBTZXJpZXNNb2RlbC50eXBlID0gJ3Nlcmllcy5oZWF0bWFwJztcbiAgSGVhdG1hcFNlcmllc01vZGVsLmRlcGVuZGVuY2llcyA9IFsnZ3JpZCcsICdnZW8nLCAnY2FsZW5kYXInXTtcbiAgSGVhdG1hcFNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgY29vcmRpbmF0ZVN5c3RlbTogJ2NhcnRlc2lhbjJkJyxcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogMixcbiAgICAvLyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAvLyB4QXhpc0luZGV4OiAwLFxuICAgIC8vIHlBeGlzSW5kZXg6IDAsXG4gICAgLy8gR2VvIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgZ2VvSW5kZXg6IDAsXG4gICAgYmx1clNpemU6IDMwLFxuICAgIHBvaW50U2l6ZTogMjAsXG4gICAgbWF4T3BhY2l0eTogMSxcbiAgICBtaW5PcGFjaXR5OiAwLFxuICAgIHNlbGVjdDoge1xuICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzIxMjEyMSdcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBIZWF0bWFwU2VyaWVzTW9kZWw7XG59KFNlcmllc01vZGVsKTtcblxuZXhwb3J0IGRlZmF1bHQgSGVhdG1hcFNlcmllc01vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCB7IGVuYWJsZUhvdmVyRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcyc7XG5pbXBvcnQgSGVhdG1hcExheWVyIGZyb20gJy4vSGVhdG1hcExheWVyJztcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0JztcbmltcG9ydCB7IGlzQ29vcmRpbmF0ZVN5c3RlbVR5cGUgfSBmcm9tICcuLi8uLi9jb29yZC9Db29yZGluYXRlU3lzdGVtJztcbmltcG9ydCB7IHNldExhYmVsU3R5bGUsIGdldExhYmVsU3RhdGVzTW9kZWxzIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZSc7XG5cbmZ1bmN0aW9uIGdldElzSW5QaWVjZXdpc2VSYW5nZShkYXRhRXh0ZW50LCBwaWVjZUxpc3QsIHNlbGVjdGVkKSB7XG4gIHZhciBkYXRhU3BhbiA9IGRhdGFFeHRlbnRbMV0gLSBkYXRhRXh0ZW50WzBdO1xuICBwaWVjZUxpc3QgPSB6clV0aWwubWFwKHBpZWNlTGlzdCwgZnVuY3Rpb24gKHBpZWNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGludGVydmFsOiBbKHBpZWNlLmludGVydmFsWzBdIC0gZGF0YUV4dGVudFswXSkgLyBkYXRhU3BhbiwgKHBpZWNlLmludGVydmFsWzFdIC0gZGF0YUV4dGVudFswXSkgLyBkYXRhU3Bhbl1cbiAgICB9O1xuICB9KTtcbiAgdmFyIGxlbiA9IHBpZWNlTGlzdC5sZW5ndGg7XG4gIHZhciBsYXN0SW5kZXggPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhciBpOyAvLyBUcnkgdG8gZmluZCBpbiB0aGUgbG9jYXRpb24gb2YgdGhlIGxhc3QgZm91bmRcblxuICAgIGZvciAoaSA9IGxhc3RJbmRleDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgaW50ZXJ2YWwgPSBwaWVjZUxpc3RbaV0uaW50ZXJ2YWw7XG5cbiAgICAgIGlmIChpbnRlcnZhbFswXSA8PSB2YWwgJiYgdmFsIDw9IGludGVydmFsWzFdKSB7XG4gICAgICAgIGxhc3RJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpID09PSBsZW4pIHtcbiAgICAgIC8vIE5vdCBmb3VuZCwgYmFjayBpbnRlcmF0aW9uXG4gICAgICBmb3IgKGkgPSBsYXN0SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBwaWVjZUxpc3RbaV0uaW50ZXJ2YWw7XG5cbiAgICAgICAgaWYgKGludGVydmFsWzBdIDw9IHZhbCAmJiB2YWwgPD0gaW50ZXJ2YWxbMV0pIHtcbiAgICAgICAgICBsYXN0SW5kZXggPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGkgPj0gMCAmJiBpIDwgbGVuICYmIHNlbGVjdGVkW2ldO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRJc0luQ29udGludW91c1JhbmdlKGRhdGFFeHRlbnQsIHJhbmdlKSB7XG4gIHZhciBkYXRhU3BhbiA9IGRhdGFFeHRlbnRbMV0gLSBkYXRhRXh0ZW50WzBdO1xuICByYW5nZSA9IFsocmFuZ2VbMF0gLSBkYXRhRXh0ZW50WzBdKSAvIGRhdGFTcGFuLCAocmFuZ2VbMV0gLSBkYXRhRXh0ZW50WzBdKSAvIGRhdGFTcGFuXTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsID49IHJhbmdlWzBdICYmIHZhbCA8PSByYW5nZVsxXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNHZW9Db29yZFN5cyhjb29yZFN5cykge1xuICB2YXIgZGltZW5zaW9ucyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7IC8vIE5vdCB1c2UgY29vclN5cy50eXBlID09PSAnZ2VvJyBiZWNhdXNlIGNvb3JkU3lzIG1heWJlIGV4dGVuZGVkXG5cbiAgcmV0dXJuIGRpbWVuc2lvbnNbMF0gPT09ICdsbmcnICYmIGRpbWVuc2lvbnNbMV0gPT09ICdsYXQnO1xufVxuXG52YXIgSGVhdG1hcFZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoSGVhdG1hcFZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gSGVhdG1hcFZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gSGVhdG1hcFZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBIZWF0bWFwVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgdmlzdWFsTWFwT2ZUaGlzU2VyaWVzO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgndmlzdWFsTWFwJywgZnVuY3Rpb24gKHZpc3VhbE1hcCkge1xuICAgICAgdmlzdWFsTWFwLmVhY2hUYXJnZXRTZXJpZXMoZnVuY3Rpb24gKHRhcmdldFNlcmllcykge1xuICAgICAgICBpZiAodGFyZ2V0U2VyaWVzID09PSBzZXJpZXNNb2RlbCkge1xuICAgICAgICAgIHZpc3VhbE1hcE9mVGhpc1NlcmllcyA9IHZpc3VhbE1hcDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCF2aXN1YWxNYXBPZlRoaXNTZXJpZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIZWF0bWFwIG11c3QgdXNlIHdpdGggdmlzdWFsTWFwJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLl9pbmNyZW1lbnRhbERpc3BsYXlhYmxlID0gbnVsbDtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgaWYgKGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgfHwgY29vcmRTeXMudHlwZSA9PT0gJ2NhbGVuZGFyJykge1xuICAgICAgdGhpcy5fcmVuZGVyT25DYXJ0ZXNpYW5BbmRDYWxlbmRhcihzZXJpZXNNb2RlbCwgYXBpLCAwLCBzZXJpZXNNb2RlbC5nZXREYXRhKCkuY291bnQoKSk7XG4gICAgfSBlbHNlIGlmIChpc0dlb0Nvb3JkU3lzKGNvb3JkU3lzKSkge1xuICAgICAgdGhpcy5fcmVuZGVyT25HZW8oY29vcmRTeXMsIHNlcmllc01vZGVsLCB2aXN1YWxNYXBPZlRoaXNTZXJpZXMsIGFwaSk7XG4gICAgfVxuICB9O1xuXG4gIEhlYXRtYXBWaWV3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFByZXBhcmVSZW5kZXIgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gIH07XG5cbiAgSGVhdG1hcFZpZXcucHJvdG90eXBlLmluY3JlbWVudGFsUmVuZGVyID0gZnVuY3Rpb24gKHBhcmFtcywgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICBpZiAoY29vcmRTeXMpIHtcbiAgICAgIC8vIGdlbyBkb2VzIG5vdCBzdXBwb3J0IGluY3JlbWVudGFsIHJlbmRlcmluZz9cbiAgICAgIGlmIChpc0dlb0Nvb3JkU3lzKGNvb3JkU3lzKSkge1xuICAgICAgICB0aGlzLnJlbmRlcihzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlck9uQ2FydGVzaWFuQW5kQ2FsZW5kYXIoc2VyaWVzTW9kZWwsIGFwaSwgcGFyYW1zLnN0YXJ0LCBwYXJhbXMuZW5kLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSGVhdG1hcFZpZXcucHJvdG90eXBlLl9yZW5kZXJPbkNhcnRlc2lhbkFuZENhbGVuZGFyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBhcGksIHN0YXJ0LCBlbmQsIGluY3JlbWVudGFsKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgd2lkdGg7XG4gICAgdmFyIGhlaWdodDtcbiAgICB2YXIgeEF4aXNFeHRlbnQ7XG4gICAgdmFyIHlBeGlzRXh0ZW50O1xuXG4gICAgaWYgKGlzQ29vcmRpbmF0ZVN5c3RlbVR5cGUoY29vcmRTeXMsICdjYXJ0ZXNpYW4yZCcpKSB7XG4gICAgICB2YXIgeEF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKCd4Jyk7XG4gICAgICB2YXIgeUF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKCd5Jyk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICghKHhBeGlzLnR5cGUgPT09ICdjYXRlZ29yeScgJiYgeUF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hlYXRtYXAgb24gY2FydGVzaWFuIG11c3QgaGF2ZSB0d28gY2F0ZWdvcnkgYXhlcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoeEF4aXMub25CYW5kICYmIHlBeGlzLm9uQmFuZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hlYXRtYXAgb24gY2FydGVzaWFuIG11c3QgaGF2ZSB0d28gYXhlcyB3aXRoIGJvdW5kYXJ5R2FwIHRydWUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aWR0aCA9IHhBeGlzLmdldEJhbmRXaWR0aCgpO1xuICAgICAgaGVpZ2h0ID0geUF4aXMuZ2V0QmFuZFdpZHRoKCk7XG4gICAgICB4QXhpc0V4dGVudCA9IHhBeGlzLnNjYWxlLmdldEV4dGVudCgpO1xuICAgICAgeUF4aXNFeHRlbnQgPSB5QXhpcy5zY2FsZS5nZXRFeHRlbnQoKTtcbiAgICB9XG5cbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBlbXBoYXNpc1N0eWxlID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoWydlbXBoYXNpcycsICdpdGVtU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCk7XG4gICAgdmFyIGJsdXJTdHlsZSA9IHNlcmllc01vZGVsLmdldE1vZGVsKFsnYmx1cicsICdpdGVtU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCk7XG4gICAgdmFyIHNlbGVjdFN0eWxlID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoWydzZWxlY3QnLCAnaXRlbVN0eWxlJ10pLmdldEl0ZW1TdHlsZSgpO1xuICAgIHZhciBsYWJlbFN0YXRlc01vZGVscyA9IGdldExhYmVsU3RhdGVzTW9kZWxzKHNlcmllc01vZGVsKTtcbiAgICB2YXIgZm9jdXMgPSBzZXJpZXNNb2RlbC5nZXQoWydlbXBoYXNpcycsICdmb2N1cyddKTtcbiAgICB2YXIgYmx1clNjb3BlID0gc2VyaWVzTW9kZWwuZ2V0KFsnZW1waGFzaXMnLCAnYmx1clNjb3BlJ10pO1xuICAgIHZhciBkYXRhRGltcyA9IGlzQ29vcmRpbmF0ZVN5c3RlbVR5cGUoY29vcmRTeXMsICdjYXJ0ZXNpYW4yZCcpID8gW2RhdGEubWFwRGltZW5zaW9uKCd4JyksIGRhdGEubWFwRGltZW5zaW9uKCd5JyksIGRhdGEubWFwRGltZW5zaW9uKCd2YWx1ZScpXSA6IFtkYXRhLm1hcERpbWVuc2lvbigndGltZScpLCBkYXRhLm1hcERpbWVuc2lvbigndmFsdWUnKV07XG5cbiAgICBmb3IgKHZhciBpZHggPSBzdGFydDsgaWR4IDwgZW5kOyBpZHgrKykge1xuICAgICAgdmFyIHJlY3QgPSB2b2lkIDA7XG4gICAgICB2YXIgc3R5bGUgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3R5bGUnKTtcblxuICAgICAgaWYgKGlzQ29vcmRpbmF0ZVN5c3RlbVR5cGUoY29vcmRTeXMsICdjYXJ0ZXNpYW4yZCcpKSB7XG4gICAgICAgIHZhciBkYXRhRGltWCA9IGRhdGEuZ2V0KGRhdGFEaW1zWzBdLCBpZHgpO1xuICAgICAgICB2YXIgZGF0YURpbVkgPSBkYXRhLmdldChkYXRhRGltc1sxXSwgaWR4KTsgLy8gSWdub3JlIGVtcHR5IGRhdGEgYW5kIG91dCBvZiBleHRlbnQgZGF0YVxuXG4gICAgICAgIGlmIChpc05hTihkYXRhLmdldChkYXRhRGltc1syXSwgaWR4KSkgfHwgZGF0YURpbVggPCB4QXhpc0V4dGVudFswXSB8fCBkYXRhRGltWCA+IHhBeGlzRXh0ZW50WzFdIHx8IGRhdGFEaW1ZIDwgeUF4aXNFeHRlbnRbMF0gfHwgZGF0YURpbVkgPiB5QXhpc0V4dGVudFsxXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoW2RhdGFEaW1YLCBkYXRhRGltWV0pO1xuICAgICAgICByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHg6IE1hdGguZmxvb3IoTWF0aC5yb3VuZChwb2ludFswXSkgLSB3aWR0aCAvIDIpLFxuICAgICAgICAgICAgeTogTWF0aC5mbG9vcihNYXRoLnJvdW5kKHBvaW50WzFdKSAtIGhlaWdodCAvIDIpLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGguY2VpbCh3aWR0aCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGguY2VpbChoZWlnaHQpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHlsZTogc3R5bGVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZ25vcmUgZW1wdHkgZGF0YVxuICAgICAgICBpZiAoaXNOYU4oZGF0YS5nZXQoZGF0YURpbXNbMV0sIGlkeCkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgICAgejI6IDEsXG4gICAgICAgICAgc2hhcGU6IGNvb3JkU3lzLmRhdGFUb1JlY3QoW2RhdGEuZ2V0KGRhdGFEaW1zWzBdLCBpZHgpXSkuY29udGVudFNoYXBlLFxuICAgICAgICAgIHN0eWxlOiBzdHlsZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7IC8vIE9wdGltaXphdGlvbiBmb3IgbGFyZ2UgZGF0c2V0XG5cbiAgICAgIGlmIChkYXRhLmhhc0l0ZW1PcHRpb24pIHtcbiAgICAgICAgdmFyIGVtcGhhc2lzTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJyk7XG4gICAgICAgIGVtcGhhc2lzU3R5bGUgPSBlbXBoYXNpc01vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgICAgYmx1clN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKFsnYmx1cicsICdpdGVtU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCk7XG4gICAgICAgIHNlbGVjdFN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKFsnc2VsZWN0JywgJ2l0ZW1TdHlsZSddKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgICAgZm9jdXMgPSBlbXBoYXNpc01vZGVsLmdldCgnZm9jdXMnKTtcbiAgICAgICAgYmx1clNjb3BlID0gZW1waGFzaXNNb2RlbC5nZXQoJ2JsdXJTY29wZScpO1xuICAgICAgICBsYWJlbFN0YXRlc01vZGVscyA9IGdldExhYmVsU3RhdGVzTW9kZWxzKGl0ZW1Nb2RlbCk7XG4gICAgICB9XG5cbiAgICAgIHZhciByYXdWYWx1ZSA9IHNlcmllc01vZGVsLmdldFJhd1ZhbHVlKGlkeCk7XG4gICAgICB2YXIgZGVmYXVsdFRleHQgPSAnLSc7XG5cbiAgICAgIGlmIChyYXdWYWx1ZSAmJiByYXdWYWx1ZVsyXSAhPSBudWxsKSB7XG4gICAgICAgIGRlZmF1bHRUZXh0ID0gcmF3VmFsdWVbMl0gKyAnJztcbiAgICAgIH1cblxuICAgICAgc2V0TGFiZWxTdHlsZShyZWN0LCBsYWJlbFN0YXRlc01vZGVscywge1xuICAgICAgICBsYWJlbEZldGNoZXI6IHNlcmllc01vZGVsLFxuICAgICAgICBsYWJlbERhdGFJbmRleDogaWR4LFxuICAgICAgICBkZWZhdWx0T3BhY2l0eTogc3R5bGUub3BhY2l0eSxcbiAgICAgICAgZGVmYXVsdFRleHQ6IGRlZmF1bHRUZXh0XG4gICAgICB9KTtcbiAgICAgIHJlY3QuZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJykuc3R5bGUgPSBlbXBoYXNpc1N0eWxlO1xuICAgICAgcmVjdC5lbnN1cmVTdGF0ZSgnYmx1cicpLnN0eWxlID0gYmx1clN0eWxlO1xuICAgICAgcmVjdC5lbnN1cmVTdGF0ZSgnc2VsZWN0Jykuc3R5bGUgPSBzZWxlY3RTdHlsZTtcbiAgICAgIGVuYWJsZUhvdmVyRW1waGFzaXMocmVjdCwgZm9jdXMsIGJsdXJTY29wZSk7XG4gICAgICByZWN0LmluY3JlbWVudGFsID0gaW5jcmVtZW50YWw7IC8vIFBFTkRJTkdcblxuICAgICAgaWYgKGluY3JlbWVudGFsKSB7XG4gICAgICAgIC8vIFJlY3QgbXVzdCB1c2UgaG92ZXIgbGF5ZXIgaWYgaXQncyBpbmNyZW1lbnRhbC5cbiAgICAgICAgcmVjdC5zdGF0ZXMuZW1waGFzaXMuaG92ZXJMYXllciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGdyb3VwLmFkZChyZWN0KTtcbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIHJlY3QpO1xuICAgIH1cbiAgfTtcblxuICBIZWF0bWFwVmlldy5wcm90b3R5cGUuX3JlbmRlck9uR2VvID0gZnVuY3Rpb24gKGdlbywgc2VyaWVzTW9kZWwsIHZpc3VhbE1hcE1vZGVsLCBhcGkpIHtcbiAgICB2YXIgaW5SYW5nZVZpc3VhbHMgPSB2aXN1YWxNYXBNb2RlbC50YXJnZXRWaXN1YWxzLmluUmFuZ2U7XG4gICAgdmFyIG91dE9mUmFuZ2VWaXN1YWxzID0gdmlzdWFsTWFwTW9kZWwudGFyZ2V0VmlzdWFscy5vdXRPZlJhbmdlOyAvLyBpZiAoIXZpc3VhbE1hcHBpbmcpIHtcbiAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIHJhbmdlIG11c3QgaGF2ZSBjb2xvciB2aXN1YWxzJyk7XG4gICAgLy8gfVxuXG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGhtTGF5ZXIgPSB0aGlzLl9obUxheWVyIHx8IHRoaXMuX2htTGF5ZXIgfHwgbmV3IEhlYXRtYXBMYXllcigpO1xuICAgIGhtTGF5ZXIuYmx1clNpemUgPSBzZXJpZXNNb2RlbC5nZXQoJ2JsdXJTaXplJyk7XG4gICAgaG1MYXllci5wb2ludFNpemUgPSBzZXJpZXNNb2RlbC5nZXQoJ3BvaW50U2l6ZScpO1xuICAgIGhtTGF5ZXIubWluT3BhY2l0eSA9IHNlcmllc01vZGVsLmdldCgnbWluT3BhY2l0eScpO1xuICAgIGhtTGF5ZXIubWF4T3BhY2l0eSA9IHNlcmllc01vZGVsLmdldCgnbWF4T3BhY2l0eScpO1xuICAgIHZhciByZWN0ID0gZ2VvLmdldFZpZXdSZWN0KCkuY2xvbmUoKTtcbiAgICB2YXIgcm9hbVRyYW5zZm9ybSA9IGdlby5nZXRSb2FtVHJhbnNmb3JtKCk7XG4gICAgcmVjdC5hcHBseVRyYW5zZm9ybShyb2FtVHJhbnNmb3JtKTsgLy8gQ2xhbXAgb24gdmlld3BvcnRcblxuICAgIHZhciB4ID0gTWF0aC5tYXgocmVjdC54LCAwKTtcbiAgICB2YXIgeSA9IE1hdGgubWF4KHJlY3QueSwgMCk7XG4gICAgdmFyIHgyID0gTWF0aC5taW4ocmVjdC53aWR0aCArIHJlY3QueCwgYXBpLmdldFdpZHRoKCkpO1xuICAgIHZhciB5MiA9IE1hdGgubWluKHJlY3QuaGVpZ2h0ICsgcmVjdC55LCBhcGkuZ2V0SGVpZ2h0KCkpO1xuICAgIHZhciB3aWR0aCA9IHgyIC0geDtcbiAgICB2YXIgaGVpZ2h0ID0geTIgLSB5O1xuICAgIHZhciBkaW1zID0gW2RhdGEubWFwRGltZW5zaW9uKCdsbmcnKSwgZGF0YS5tYXBEaW1lbnNpb24oJ2xhdCcpLCBkYXRhLm1hcERpbWVuc2lvbigndmFsdWUnKV07XG4gICAgdmFyIHBvaW50cyA9IGRhdGEubWFwQXJyYXkoZGltcywgZnVuY3Rpb24gKGxuZywgbGF0LCB2YWx1ZSkge1xuICAgICAgdmFyIHB0ID0gZ2VvLmRhdGFUb1BvaW50KFtsbmcsIGxhdF0pO1xuICAgICAgcHRbMF0gLT0geDtcbiAgICAgIHB0WzFdIC09IHk7XG4gICAgICBwdC5wdXNoKHZhbHVlKTtcbiAgICAgIHJldHVybiBwdDtcbiAgICB9KTtcbiAgICB2YXIgZGF0YUV4dGVudCA9IHZpc3VhbE1hcE1vZGVsLmdldEV4dGVudCgpO1xuICAgIHZhciBpc0luUmFuZ2UgPSB2aXN1YWxNYXBNb2RlbC50eXBlID09PSAndmlzdWFsTWFwLmNvbnRpbnVvdXMnID8gZ2V0SXNJbkNvbnRpbnVvdXNSYW5nZShkYXRhRXh0ZW50LCB2aXN1YWxNYXBNb2RlbC5vcHRpb24ucmFuZ2UpIDogZ2V0SXNJblBpZWNld2lzZVJhbmdlKGRhdGFFeHRlbnQsIHZpc3VhbE1hcE1vZGVsLmdldFBpZWNlTGlzdCgpLCB2aXN1YWxNYXBNb2RlbC5vcHRpb24uc2VsZWN0ZWQpO1xuICAgIGhtTGF5ZXIudXBkYXRlKHBvaW50cywgd2lkdGgsIGhlaWdodCwgaW5SYW5nZVZpc3VhbHMuY29sb3IuZ2V0Tm9ybWFsaXplcigpLCB7XG4gICAgICBpblJhbmdlOiBpblJhbmdlVmlzdWFscy5jb2xvci5nZXRDb2xvck1hcHBlcigpLFxuICAgICAgb3V0T2ZSYW5nZTogb3V0T2ZSYW5nZVZpc3VhbHMuY29sb3IuZ2V0Q29sb3JNYXBwZXIoKVxuICAgIH0sIGlzSW5SYW5nZSk7XG4gICAgdmFyIGltZyA9IG5ldyBncmFwaGljLkltYWdlKHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIGltYWdlOiBobUxheWVyLmNhbnZhc1xuICAgICAgfSxcbiAgICAgIHNpbGVudDogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuZ3JvdXAuYWRkKGltZyk7XG4gIH07XG5cbiAgSGVhdG1hcFZpZXcudHlwZSA9ICdoZWF0bWFwJztcbiAgcmV0dXJuIEhlYXRtYXBWaWV3O1xufShDaGFydFZpZXcpO1xuXG5leHBvcnQgZGVmYXVsdCBIZWF0bWFwVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IEhlYXRtYXBWaWV3IGZyb20gJy4vSGVhdG1hcFZpZXcnO1xuaW1wb3J0IEhlYXRtYXBTZXJpZXNNb2RlbCBmcm9tICcuL0hlYXRtYXBTZXJpZXMnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhIZWF0bWFwVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclNlcmllc01vZGVsKEhlYXRtYXBTZXJpZXNNb2RlbCk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuLyoqXG4gKiBQcm92aWRlIGVmZmVjdCBmb3IgbGluZVxuICovXG5cbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCBMaW5lIGZyb20gJy4vTGluZSc7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCB7IGNyZWF0ZVN5bWJvbCB9IGZyb20gJy4uLy4uL3V0aWwvc3ltYm9sJztcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnenJlbmRlci9saWIvY29yZS92ZWN0b3InO1xuaW1wb3J0ICogYXMgY3VydmVVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvY3VydmUnO1xuXG52YXIgRWZmZWN0TGluZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhFZmZlY3RMaW5lLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEVmZmVjdExpbmUobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuYWRkKF90aGlzLmNyZWF0ZUxpbmUobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpKTtcblxuICAgIF90aGlzLl91cGRhdGVFZmZlY3RTeW1ib2wobGluZURhdGEsIGlkeCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBFZmZlY3RMaW5lLnByb3RvdHlwZS5jcmVhdGVMaW5lID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbiAgfTtcblxuICBFZmZlY3RMaW5lLnByb3RvdHlwZS5fdXBkYXRlRWZmZWN0U3ltYm9sID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgpIHtcbiAgICB2YXIgaXRlbU1vZGVsID0gbGluZURhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgdmFyIGVmZmVjdE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdlZmZlY3QnKTtcbiAgICB2YXIgc2l6ZSA9IGVmZmVjdE1vZGVsLmdldCgnc3ltYm9sU2l6ZScpO1xuICAgIHZhciBzeW1ib2xUeXBlID0gZWZmZWN0TW9kZWwuZ2V0KCdzeW1ib2wnKTtcblxuICAgIGlmICghenJVdGlsLmlzQXJyYXkoc2l6ZSkpIHtcbiAgICAgIHNpemUgPSBbc2l6ZSwgc2l6ZV07XG4gICAgfVxuXG4gICAgdmFyIGxpbmVTdHlsZSA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3R5bGUnKTtcbiAgICB2YXIgY29sb3IgPSBlZmZlY3RNb2RlbC5nZXQoJ2NvbG9yJykgfHwgbGluZVN0eWxlICYmIGxpbmVTdHlsZS5zdHJva2U7XG4gICAgdmFyIHN5bWJvbCA9IHRoaXMuY2hpbGRBdCgxKTtcblxuICAgIGlmICh0aGlzLl9zeW1ib2xUeXBlICE9PSBzeW1ib2xUeXBlKSB7XG4gICAgICAvLyBSZW1vdmUgcHJldmlvdXNcbiAgICAgIHRoaXMucmVtb3ZlKHN5bWJvbCk7XG4gICAgICBzeW1ib2wgPSBjcmVhdGVTeW1ib2woc3ltYm9sVHlwZSwgLTAuNSwgLTAuNSwgMSwgMSwgY29sb3IpO1xuICAgICAgc3ltYm9sLnoyID0gMTAwO1xuICAgICAgc3ltYm9sLmN1bGxpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5hZGQoc3ltYm9sKTtcbiAgICB9IC8vIFN5bWJvbCBtYXkgYmUgcmVtb3ZlZCBpZiBsb29wIGlzIGZhbHNlXG5cblxuICAgIGlmICghc3ltYm9sKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBTaGFkb3cgY29sb3IgaXMgc2FtZSB3aXRoIGNvbG9yIGluIGRlZmF1bHRcblxuXG4gICAgc3ltYm9sLnNldFN0eWxlKCdzaGFkb3dDb2xvcicsIGNvbG9yKTtcbiAgICBzeW1ib2wuc2V0U3R5bGUoZWZmZWN0TW9kZWwuZ2V0SXRlbVN0eWxlKFsnY29sb3InXSkpO1xuICAgIHN5bWJvbC5zY2FsZVggPSBzaXplWzBdO1xuICAgIHN5bWJvbC5zY2FsZVkgPSBzaXplWzFdO1xuICAgIHN5bWJvbC5zZXRDb2xvcihjb2xvcik7XG4gICAgdGhpcy5fc3ltYm9sVHlwZSA9IHN5bWJvbFR5cGU7XG4gICAgdGhpcy5fc3ltYm9sU2NhbGUgPSBzaXplO1xuXG4gICAgdGhpcy5fdXBkYXRlRWZmZWN0QW5pbWF0aW9uKGxpbmVEYXRhLCBlZmZlY3RNb2RlbCwgaWR4KTtcbiAgfTtcblxuICBFZmZlY3RMaW5lLnByb3RvdHlwZS5fdXBkYXRlRWZmZWN0QW5pbWF0aW9uID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBlZmZlY3RNb2RlbCwgaWR4KSB7XG4gICAgdmFyIHN5bWJvbCA9IHRoaXMuY2hpbGRBdCgxKTtcblxuICAgIGlmICghc3ltYm9sKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwb2ludHMgPSBsaW5lRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgdmFyIHBlcmlvZCA9IGVmZmVjdE1vZGVsLmdldCgncGVyaW9kJykgKiAxMDAwO1xuICAgIHZhciBsb29wID0gZWZmZWN0TW9kZWwuZ2V0KCdsb29wJyk7XG4gICAgdmFyIGNvbnN0YW50U3BlZWQgPSBlZmZlY3RNb2RlbC5nZXQoJ2NvbnN0YW50U3BlZWQnKTtcbiAgICB2YXIgZGVsYXlFeHByID0genJVdGlsLnJldHJpZXZlKGVmZmVjdE1vZGVsLmdldCgnZGVsYXknKSwgZnVuY3Rpb24gKGlkeCkge1xuICAgICAgcmV0dXJuIGlkeCAvIGxpbmVEYXRhLmNvdW50KCkgKiBwZXJpb2QgLyAzO1xuICAgIH0pOyAvLyBJZ25vcmUgd2hlbiB1cGRhdGluZ1xuXG4gICAgc3ltYm9sLmlnbm9yZSA9IHRydWU7XG5cbiAgICB0aGlzLl91cGRhdGVBbmltYXRpb25Qb2ludHMoc3ltYm9sLCBwb2ludHMpO1xuXG4gICAgaWYgKGNvbnN0YW50U3BlZWQgPiAwKSB7XG4gICAgICBwZXJpb2QgPSB0aGlzLl9nZXRMaW5lTGVuZ3RoKHN5bWJvbCkgLyBjb25zdGFudFNwZWVkICogMTAwMDtcbiAgICB9XG5cbiAgICBpZiAocGVyaW9kICE9PSB0aGlzLl9wZXJpb2QgfHwgbG9vcCAhPT0gdGhpcy5fbG9vcCkge1xuICAgICAgc3ltYm9sLnN0b3BBbmltYXRpb24oKTtcblxuICAgICAgaWYgKHBlcmlvZCA+IDApIHtcbiAgICAgICAgdmFyIGRlbGF5TnVtID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZGVsYXlFeHByID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVsYXlOdW0gPSBkZWxheUV4cHIoaWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxheU51bSA9IGRlbGF5RXhwcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzeW1ib2wuX190ID4gMCkge1xuICAgICAgICAgIGRlbGF5TnVtID0gLXBlcmlvZCAqIHN5bWJvbC5fX3Q7XG4gICAgICAgIH1cblxuICAgICAgICBzeW1ib2wuX190ID0gMDtcbiAgICAgICAgdmFyIGFuaW1hdG9yID0gc3ltYm9sLmFuaW1hdGUoJycsIGxvb3ApLndoZW4ocGVyaW9kLCB7XG4gICAgICAgICAgX190OiAxXG4gICAgICAgIH0pLmRlbGF5KGRlbGF5TnVtKS5kdXJpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuX3VwZGF0ZVN5bWJvbFBvc2l0aW9uKHN5bWJvbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghbG9vcCkge1xuICAgICAgICAgIGFuaW1hdG9yLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5yZW1vdmUoc3ltYm9sKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW1hdG9yLnN0YXJ0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcGVyaW9kID0gcGVyaW9kO1xuICAgIHRoaXMuX2xvb3AgPSBsb29wO1xuICB9O1xuXG4gIEVmZmVjdExpbmUucHJvdG90eXBlLl9nZXRMaW5lTGVuZ3RoID0gZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgIC8vIE5vdCBzbyBhY2N1cmF0ZVxuICAgIHJldHVybiB2ZWMyLmRpc3Qoc3ltYm9sLl9fcDEsIHN5bWJvbC5fX2NwMSkgKyB2ZWMyLmRpc3Qoc3ltYm9sLl9fY3AxLCBzeW1ib2wuX19wMik7XG4gIH07XG5cbiAgRWZmZWN0TGluZS5wcm90b3R5cGUuX3VwZGF0ZUFuaW1hdGlvblBvaW50cyA9IGZ1bmN0aW9uIChzeW1ib2wsIHBvaW50cykge1xuICAgIHN5bWJvbC5fX3AxID0gcG9pbnRzWzBdO1xuICAgIHN5bWJvbC5fX3AyID0gcG9pbnRzWzFdO1xuICAgIHN5bWJvbC5fX2NwMSA9IHBvaW50c1syXSB8fCBbKHBvaW50c1swXVswXSArIHBvaW50c1sxXVswXSkgLyAyLCAocG9pbnRzWzBdWzFdICsgcG9pbnRzWzFdWzFdKSAvIDJdO1xuICB9O1xuXG4gIEVmZmVjdExpbmUucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgICB0aGlzLmNoaWxkQXQoMCkudXBkYXRlRGF0YShsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG5cbiAgICB0aGlzLl91cGRhdGVFZmZlY3RTeW1ib2wobGluZURhdGEsIGlkeCk7XG4gIH07XG5cbiAgRWZmZWN0TGluZS5wcm90b3R5cGUuX3VwZGF0ZVN5bWJvbFBvc2l0aW9uID0gZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgIHZhciBwMSA9IHN5bWJvbC5fX3AxO1xuICAgIHZhciBwMiA9IHN5bWJvbC5fX3AyO1xuICAgIHZhciBjcDEgPSBzeW1ib2wuX19jcDE7XG4gICAgdmFyIHQgPSBzeW1ib2wuX190O1xuICAgIHZhciBwb3MgPSBbc3ltYm9sLngsIHN5bWJvbC55XTtcbiAgICB2YXIgbGFzdFBvcyA9IHBvcy5zbGljZSgpO1xuICAgIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlVXRpbC5xdWFkcmF0aWNBdDtcbiAgICB2YXIgcXVhZHJhdGljRGVyaXZhdGl2ZUF0ID0gY3VydmVVdGlsLnF1YWRyYXRpY0Rlcml2YXRpdmVBdDtcbiAgICBwb3NbMF0gPSBxdWFkcmF0aWNBdChwMVswXSwgY3AxWzBdLCBwMlswXSwgdCk7XG4gICAgcG9zWzFdID0gcXVhZHJhdGljQXQocDFbMV0sIGNwMVsxXSwgcDJbMV0sIHQpOyAvLyBUYW5nZW50XG5cbiAgICB2YXIgdHggPSBxdWFkcmF0aWNEZXJpdmF0aXZlQXQocDFbMF0sIGNwMVswXSwgcDJbMF0sIHQpO1xuICAgIHZhciB0eSA9IHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMVsxXSwgY3AxWzFdLCBwMlsxXSwgdCk7XG4gICAgc3ltYm9sLnJvdGF0aW9uID0gLU1hdGguYXRhbjIodHksIHR4KSAtIE1hdGguUEkgLyAyOyAvLyBlbmFibGUgY29udGludWl0eSB0cmFpbCBmb3IgJ2xpbmUnLCAncmVjdCcsICdyb3VuZFJlY3QnIHN5bWJvbFR5cGVcblxuICAgIGlmICh0aGlzLl9zeW1ib2xUeXBlID09PSAnbGluZScgfHwgdGhpcy5fc3ltYm9sVHlwZSA9PT0gJ3JlY3QnIHx8IHRoaXMuX3N5bWJvbFR5cGUgPT09ICdyb3VuZFJlY3QnKSB7XG4gICAgICBpZiAoc3ltYm9sLl9fbGFzdFQgIT09IHVuZGVmaW5lZCAmJiBzeW1ib2wuX19sYXN0VCA8IHN5bWJvbC5fX3QpIHtcbiAgICAgICAgc3ltYm9sLnNjYWxlWSA9IHZlYzIuZGlzdChsYXN0UG9zLCBwb3MpICogMS4wNTsgLy8gbWFrZSBzdXJlIHRoZSBsYXN0IHNlZ21lbnQgcmVuZGVyIHdpdGhpbiBlbmRQb2ludFxuXG4gICAgICAgIGlmICh0ID09PSAxKSB7XG4gICAgICAgICAgcG9zWzBdID0gbGFzdFBvc1swXSArIChwb3NbMF0gLSBsYXN0UG9zWzBdKSAvIDI7XG4gICAgICAgICAgcG9zWzFdID0gbGFzdFBvc1sxXSArIChwb3NbMV0gLSBsYXN0UG9zWzFdKSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3ltYm9sLl9fbGFzdFQgPT09IDEpIHtcbiAgICAgICAgLy8gQWZ0ZXIgZmlyc3QgbG9vcCwgc3ltYm9sLl9fdCBkb2VzIE5PVCBzdGFydCB3aXRoIDAsIHNvIGNvbm5lY3QgcDEgdG8gcG9zIGRpcmVjdGx5LlxuICAgICAgICBzeW1ib2wuc2NhbGVZID0gMiAqIHZlYzIuZGlzdChwMSwgcG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN5bWJvbC5zY2FsZVkgPSB0aGlzLl9zeW1ib2xTY2FsZVsxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW1ib2wuX19sYXN0VCA9IHN5bWJvbC5fX3Q7XG4gICAgc3ltYm9sLmlnbm9yZSA9IGZhbHNlO1xuICAgIHN5bWJvbC54ID0gcG9zWzBdO1xuICAgIHN5bWJvbC55ID0gcG9zWzFdO1xuICB9O1xuXG4gIEVmZmVjdExpbmUucHJvdG90eXBlLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4KSB7XG4gICAgdGhpcy5jaGlsZEF0KDApLnVwZGF0ZUxheW91dChsaW5lRGF0YSwgaWR4KTtcbiAgICB2YXIgZWZmZWN0TW9kZWwgPSBsaW5lRGF0YS5nZXRJdGVtTW9kZWwoaWR4KS5nZXRNb2RlbCgnZWZmZWN0Jyk7XG5cbiAgICB0aGlzLl91cGRhdGVFZmZlY3RBbmltYXRpb24obGluZURhdGEsIGVmZmVjdE1vZGVsLCBpZHgpO1xuICB9O1xuXG4gIHJldHVybiBFZmZlY3RMaW5lO1xufShncmFwaGljLkdyb3VwKTtcblxuZXhwb3J0IGRlZmF1bHQgRWZmZWN0TGluZTsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgUG9seWxpbmUgZnJvbSAnLi9Qb2x5bGluZSc7XG5pbXBvcnQgRWZmZWN0TGluZSBmcm9tICcuL0VmZmVjdExpbmUnO1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvcic7XG5cbnZhciBFZmZlY3RQb2x5bGluZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhFZmZlY3RQb2x5bGluZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBFZmZlY3RQb2x5bGluZSgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLl9sYXN0RnJhbWUgPSAwO1xuICAgIF90aGlzLl9sYXN0RnJhbWVQZXJjZW50ID0gMDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH0gLy8gT3ZlcnJpZGVcblxuXG4gIEVmZmVjdFBvbHlsaW5lLnByb3RvdHlwZS5jcmVhdGVMaW5lID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5bGluZShsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG4gIH07XG5cbiAgOyAvLyBPdmVycmlkZVxuXG4gIEVmZmVjdFBvbHlsaW5lLnByb3RvdHlwZS5fdXBkYXRlQW5pbWF0aW9uUG9pbnRzID0gZnVuY3Rpb24gKHN5bWJvbCwgcG9pbnRzKSB7XG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICAgIHZhciBhY2NMZW5BcnIgPSBbMF07XG4gICAgdmFyIGxlbiA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAxID0gcG9pbnRzW2kgLSAxXTtcbiAgICAgIHZhciBwMiA9IHBvaW50c1tpXTtcbiAgICAgIGxlbiArPSB2ZWMyLmRpc3QocDEsIHAyKTtcbiAgICAgIGFjY0xlbkFyci5wdXNoKGxlbik7XG4gICAgfVxuXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjY0xlbkFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYWNjTGVuQXJyW2ldIC89IGxlbjtcbiAgICB9XG5cbiAgICB0aGlzLl9vZmZzZXRzID0gYWNjTGVuQXJyO1xuICAgIHRoaXMuX2xlbmd0aCA9IGxlbjtcbiAgfTtcblxuICA7IC8vIE92ZXJyaWRlXG5cbiAgRWZmZWN0UG9seWxpbmUucHJvdG90eXBlLl9nZXRMaW5lTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gIH07XG5cbiAgOyAvLyBPdmVycmlkZVxuXG4gIEVmZmVjdFBvbHlsaW5lLnByb3RvdHlwZS5fdXBkYXRlU3ltYm9sUG9zaXRpb24gPSBmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgdmFyIHQgPSBzeW1ib2wuX190O1xuICAgIHZhciBwb2ludHMgPSB0aGlzLl9wb2ludHM7XG4gICAgdmFyIG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgaWYgKCFvZmZzZXRzKSB7XG4gICAgICAvLyBIYXMgbGVuZ3RoIDBcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGFzdEZyYW1lID0gdGhpcy5fbGFzdEZyYW1lO1xuICAgIHZhciBmcmFtZTtcblxuICAgIGlmICh0IDwgdGhpcy5fbGFzdEZyYW1lUGVyY2VudCkge1xuICAgICAgLy8gU3RhcnQgZnJvbSB0aGUgbmV4dCBmcmFtZVxuICAgICAgLy8gUEVORElORyBzdGFydCBmcm9tIGxhc3RGcmFtZSA/XG4gICAgICB2YXIgc3RhcnQgPSBNYXRoLm1pbihsYXN0RnJhbWUgKyAxLCBsZW4gLSAxKTtcblxuICAgICAgZm9yIChmcmFtZSA9IHN0YXJ0OyBmcmFtZSA+PSAwOyBmcmFtZS0tKSB7XG4gICAgICAgIGlmIChvZmZzZXRzW2ZyYW1lXSA8PSB0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUEVORElORyByZWFsbHkgbmVlZCB0byBkbyB0aGlzID9cblxuXG4gICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lLCBsZW4gLSAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChmcmFtZSA9IGxhc3RGcmFtZTsgZnJhbWUgPCBsZW47IGZyYW1lKyspIHtcbiAgICAgICAgaWYgKG9mZnNldHNbZnJhbWVdID4gdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUgLSAxLCBsZW4gLSAyKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9ICh0IC0gb2Zmc2V0c1tmcmFtZV0pIC8gKG9mZnNldHNbZnJhbWUgKyAxXSAtIG9mZnNldHNbZnJhbWVdKTtcbiAgICB2YXIgcDAgPSBwb2ludHNbZnJhbWVdO1xuICAgIHZhciBwMSA9IHBvaW50c1tmcmFtZSArIDFdO1xuICAgIHN5bWJvbC54ID0gcDBbMF0gKiAoMSAtIHApICsgcCAqIHAxWzBdO1xuICAgIHN5bWJvbC55ID0gcDBbMV0gKiAoMSAtIHApICsgcCAqIHAxWzFdO1xuICAgIHZhciB0eCA9IHAxWzBdIC0gcDBbMF07XG4gICAgdmFyIHR5ID0gcDFbMV0gLSBwMFsxXTtcbiAgICBzeW1ib2wucm90YXRpb24gPSAtTWF0aC5hdGFuMih0eSwgdHgpIC0gTWF0aC5QSSAvIDI7XG4gICAgdGhpcy5fbGFzdEZyYW1lID0gZnJhbWU7XG4gICAgdGhpcy5fbGFzdEZyYW1lUGVyY2VudCA9IHQ7XG4gICAgc3ltYm9sLmlnbm9yZSA9IGZhbHNlO1xuICB9O1xuXG4gIDtcbiAgcmV0dXJuIEVmZmVjdFBvbHlsaW5lO1xufShFZmZlY3RMaW5lKTtcblxuZXhwb3J0IGRlZmF1bHQgRWZmZWN0UG9seWxpbmU7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBjcmVhdGVTeW1ib2wgfSBmcm9tICcuLi8uLi91dGlsL3N5bWJvbCc7XG5pbXBvcnQgeyBHcm91cCB9IGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgeyBlbnRlckVtcGhhc2lzLCBsZWF2ZUVtcGhhc2lzLCBlbmFibGVIb3ZlckVtcGhhc2lzIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMnO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50IH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXInO1xuaW1wb3J0IFN5bWJvbENseiBmcm9tICcuL1N5bWJvbCc7XG52YXIgRUZGRUNUX1JJUFBMRV9OVU1CRVIgPSAzO1xuXG5mdW5jdGlvbiBub3JtYWxpemVTeW1ib2xTaXplKHN5bWJvbFNpemUpIHtcbiAgaWYgKCF6clV0aWwuaXNBcnJheShzeW1ib2xTaXplKSkge1xuICAgIHN5bWJvbFNpemUgPSBbK3N5bWJvbFNpemUsICtzeW1ib2xTaXplXTtcbiAgfVxuXG4gIHJldHVybiBzeW1ib2xTaXplO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSaXBwbGVQYXRoKHJpcHBsZUdyb3VwLCBlZmZlY3RDZmcpIHtcbiAgdmFyIGNvbG9yID0gZWZmZWN0Q2ZnLnJpcHBsZUVmZmVjdENvbG9yIHx8IGVmZmVjdENmZy5jb2xvcjtcbiAgcmlwcGxlR3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChyaXBwbGVQYXRoKSB7XG4gICAgcmlwcGxlUGF0aC5hdHRyKHtcbiAgICAgIHo6IGVmZmVjdENmZy56LFxuICAgICAgemxldmVsOiBlZmZlY3RDZmcuemxldmVsLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgc3Ryb2tlOiBlZmZlY3RDZmcuYnJ1c2hUeXBlID09PSAnc3Ryb2tlJyA/IGNvbG9yIDogbnVsbCxcbiAgICAgICAgZmlsbDogZWZmZWN0Q2ZnLmJydXNoVHlwZSA9PT0gJ2ZpbGwnID8gY29sb3IgOiBudWxsXG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG52YXIgRWZmZWN0U3ltYm9sID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEVmZmVjdFN5bWJvbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBFZmZlY3RTeW1ib2woZGF0YSwgaWR4KSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIHZhciBzeW1ib2wgPSBuZXcgU3ltYm9sQ2x6KGRhdGEsIGlkeCk7XG4gICAgdmFyIHJpcHBsZUdyb3VwID0gbmV3IEdyb3VwKCk7XG5cbiAgICBfdGhpcy5hZGQoc3ltYm9sKTtcblxuICAgIF90aGlzLmFkZChyaXBwbGVHcm91cCk7XG5cbiAgICBfdGhpcy51cGRhdGVEYXRhKGRhdGEsIGlkeCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBFZmZlY3RTeW1ib2wucHJvdG90eXBlLnN0b3BFZmZlY3RBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jaGlsZEF0KDEpLnJlbW92ZUFsbCgpO1xuICB9O1xuXG4gIEVmZmVjdFN5bWJvbC5wcm90b3R5cGUuc3RhcnRFZmZlY3RBbmltYXRpb24gPSBmdW5jdGlvbiAoZWZmZWN0Q2ZnKSB7XG4gICAgdmFyIHN5bWJvbFR5cGUgPSBlZmZlY3RDZmcuc3ltYm9sVHlwZTtcbiAgICB2YXIgY29sb3IgPSBlZmZlY3RDZmcuY29sb3I7XG4gICAgdmFyIHJpcHBsZUdyb3VwID0gdGhpcy5jaGlsZEF0KDEpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBFRkZFQ1RfUklQUExFX05VTUJFUjsgaSsrKSB7XG4gICAgICAvLyBJZiB3aWR0aC9oZWlnaHQgYXJlIHNldCB0b28gc21hbGwgKGUuZy4sIHNldCB0byAxKSBvbiBpb3MxMFxuICAgICAgLy8gYW5kIG1hY09TIFNpZXJyYSwgYSBjaXJjbGUgc3Ryb2tlIGJlY29tZSBhIHJlY3QsIG5vIG1hdHRlciB3aGF0XG4gICAgICAvLyB0aGUgc2NhbGUgaXMgc2V0LiBTbyB3ZSBzZXQgd2lkdGgvaGVpZ2h0IGFzIDIuIFNlZSAjNDEzNi5cbiAgICAgIHZhciByaXBwbGVQYXRoID0gY3JlYXRlU3ltYm9sKHN5bWJvbFR5cGUsIC0xLCAtMSwgMiwgMiwgY29sb3IpO1xuICAgICAgcmlwcGxlUGF0aC5hdHRyKHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBzdHJva2VOb1NjYWxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHoyOiA5OSxcbiAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICBzY2FsZVg6IDAuNSxcbiAgICAgICAgc2NhbGVZOiAwLjVcbiAgICAgIH0pO1xuICAgICAgdmFyIGRlbGF5ID0gLWkgLyBFRkZFQ1RfUklQUExFX05VTUJFUiAqIGVmZmVjdENmZy5wZXJpb2QgKyBlZmZlY3RDZmcuZWZmZWN0T2Zmc2V0OyAvLyBUT0RPIENvbmZpZ3VyYWJsZSBlZmZlY3RDZmcucGVyaW9kXG5cbiAgICAgIHJpcHBsZVBhdGguYW5pbWF0ZSgnJywgdHJ1ZSkud2hlbihlZmZlY3RDZmcucGVyaW9kLCB7XG4gICAgICAgIHNjYWxlOiBbZWZmZWN0Q2ZnLnJpcHBsZVNjYWxlIC8gMiwgZWZmZWN0Q2ZnLnJpcHBsZVNjYWxlIC8gMl1cbiAgICAgIH0pLmRlbGF5KGRlbGF5KS5zdGFydCgpO1xuICAgICAgcmlwcGxlUGF0aC5hbmltYXRlU3R5bGUodHJ1ZSkud2hlbihlZmZlY3RDZmcucGVyaW9kLCB7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0pLmRlbGF5KGRlbGF5KS5zdGFydCgpO1xuICAgICAgcmlwcGxlR3JvdXAuYWRkKHJpcHBsZVBhdGgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVJpcHBsZVBhdGgocmlwcGxlR3JvdXAsIGVmZmVjdENmZyk7XG4gIH07XG4gIC8qKlxuICAgKiBVcGRhdGUgZWZmZWN0IHN5bWJvbFxuICAgKi9cblxuXG4gIEVmZmVjdFN5bWJvbC5wcm90b3R5cGUudXBkYXRlRWZmZWN0QW5pbWF0aW9uID0gZnVuY3Rpb24gKGVmZmVjdENmZykge1xuICAgIHZhciBvbGRFZmZlY3RDZmcgPSB0aGlzLl9lZmZlY3RDZmc7XG4gICAgdmFyIHJpcHBsZUdyb3VwID0gdGhpcy5jaGlsZEF0KDEpOyAvLyBNdXN0IHJlaW5pdGlhbGl6ZSBlZmZlY3QgaWYgZm9sbG93aW5nIGNvbmZpZ3VyYXRpb24gY2hhbmdlZFxuXG4gICAgdmFyIERJRkZJQ1VMVF9QUk9QUyA9IFsnc3ltYm9sVHlwZScsICdwZXJpb2QnLCAncmlwcGxlU2NhbGUnXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRElGRklDVUxUX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBESUZGSUNVTFRfUFJPUFNbaV07XG5cbiAgICAgIGlmIChvbGRFZmZlY3RDZmdbcHJvcE5hbWVdICE9PSBlZmZlY3RDZmdbcHJvcE5hbWVdKSB7XG4gICAgICAgIHRoaXMuc3RvcEVmZmVjdEFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLnN0YXJ0RWZmZWN0QW5pbWF0aW9uKGVmZmVjdENmZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVSaXBwbGVQYXRoKHJpcHBsZUdyb3VwLCBlZmZlY3RDZmcpO1xuICB9O1xuICAvKipcbiAgICogSGlnaGxpZ2h0IHN5bWJvbFxuICAgKi9cblxuXG4gIEVmZmVjdFN5bWJvbC5wcm90b3R5cGUuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIGVudGVyRW1waGFzaXModGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiBEb3ducGxheSBzeW1ib2xcbiAgICovXG5cblxuICBFZmZlY3RTeW1ib2wucHJvdG90eXBlLmRvd25wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIGxlYXZlRW1waGFzaXModGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiBVcGRhdGUgc3ltYm9sIHByb3BlcnRpZXNcbiAgICovXG5cblxuICBFZmZlY3RTeW1ib2wucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgaWR4KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICAgIHRoaXMuY2hpbGRBdCgwKS51cGRhdGVEYXRhKGRhdGEsIGlkeCk7XG4gICAgdmFyIHJpcHBsZUdyb3VwID0gdGhpcy5jaGlsZEF0KDEpO1xuICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgIHZhciBzeW1ib2xUeXBlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbCcpO1xuICAgIHZhciBzeW1ib2xTaXplID0gbm9ybWFsaXplU3ltYm9sU2l6ZShkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScpKTtcbiAgICB2YXIgc3ltYm9sU3R5bGUgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3R5bGUnKTtcbiAgICB2YXIgY29sb3IgPSBzeW1ib2xTdHlsZSAmJiBzeW1ib2xTdHlsZS5maWxsO1xuICAgIHJpcHBsZUdyb3VwLnNldFNjYWxlKHN5bWJvbFNpemUpO1xuICAgIHJpcHBsZUdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChyaXBwbGVQYXRoKSB7XG4gICAgICByaXBwbGVQYXRoLnNldFN0eWxlKCdmaWxsJywgY29sb3IpO1xuICAgIH0pO1xuICAgIHZhciBzeW1ib2xPZmZzZXQgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnc3ltYm9sT2Zmc2V0Jyk7XG5cbiAgICBpZiAoc3ltYm9sT2Zmc2V0KSB7XG4gICAgICByaXBwbGVHcm91cC54ID0gcGFyc2VQZXJjZW50KHN5bWJvbE9mZnNldFswXSwgc3ltYm9sU2l6ZVswXSk7XG4gICAgICByaXBwbGVHcm91cC55ID0gcGFyc2VQZXJjZW50KHN5bWJvbE9mZnNldFsxXSwgc3ltYm9sU2l6ZVsxXSk7XG4gICAgfVxuXG4gICAgdmFyIHN5bWJvbFJvdGF0ZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xSb3RhdGUnKTtcbiAgICByaXBwbGVHcm91cC5yb3RhdGlvbiA9IChzeW1ib2xSb3RhdGUgfHwgMCkgKiBNYXRoLlBJIC8gMTgwIHx8IDA7XG4gICAgdmFyIGVmZmVjdENmZyA9IHt9O1xuICAgIGVmZmVjdENmZy5zaG93RWZmZWN0T24gPSBzZXJpZXNNb2RlbC5nZXQoJ3Nob3dFZmZlY3RPbicpO1xuICAgIGVmZmVjdENmZy5yaXBwbGVTY2FsZSA9IGl0ZW1Nb2RlbC5nZXQoWydyaXBwbGVFZmZlY3QnLCAnc2NhbGUnXSk7XG4gICAgZWZmZWN0Q2ZnLmJydXNoVHlwZSA9IGl0ZW1Nb2RlbC5nZXQoWydyaXBwbGVFZmZlY3QnLCAnYnJ1c2hUeXBlJ10pO1xuICAgIGVmZmVjdENmZy5wZXJpb2QgPSBpdGVtTW9kZWwuZ2V0KFsncmlwcGxlRWZmZWN0JywgJ3BlcmlvZCddKSAqIDEwMDA7XG4gICAgZWZmZWN0Q2ZnLmVmZmVjdE9mZnNldCA9IGlkeCAvIGRhdGEuY291bnQoKTtcbiAgICBlZmZlY3RDZmcueiA9IHNlcmllc01vZGVsLmdldFNoYWxsb3coJ3onKSB8fCAwO1xuICAgIGVmZmVjdENmZy56bGV2ZWwgPSBzZXJpZXNNb2RlbC5nZXRTaGFsbG93KCd6bGV2ZWwnKSB8fCAwO1xuICAgIGVmZmVjdENmZy5zeW1ib2xUeXBlID0gc3ltYm9sVHlwZTtcbiAgICBlZmZlY3RDZmcuY29sb3IgPSBjb2xvcjtcbiAgICBlZmZlY3RDZmcucmlwcGxlRWZmZWN0Q29sb3IgPSBpdGVtTW9kZWwuZ2V0KFsncmlwcGxlRWZmZWN0JywgJ2NvbG9yJ10pO1xuICAgIHRoaXMub2ZmKCdtb3VzZW92ZXInKS5vZmYoJ21vdXNlb3V0Jykub2ZmKCdlbXBoYXNpcycpLm9mZignbm9ybWFsJyk7XG5cbiAgICBpZiAoZWZmZWN0Q2ZnLnNob3dFZmZlY3RPbiA9PT0gJ3JlbmRlcicpIHtcbiAgICAgIHRoaXMuX2VmZmVjdENmZyA/IHRoaXMudXBkYXRlRWZmZWN0QW5pbWF0aW9uKGVmZmVjdENmZykgOiB0aGlzLnN0YXJ0RWZmZWN0QW5pbWF0aW9uKGVmZmVjdENmZyk7XG4gICAgICB0aGlzLl9lZmZlY3RDZmcgPSBlZmZlY3RDZmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vdCBrZWVwIG9sZCBlZmZlY3QgY29uZmlnXG4gICAgICB0aGlzLl9lZmZlY3RDZmcgPSBudWxsO1xuICAgICAgdGhpcy5zdG9wRWZmZWN0QW5pbWF0aW9uKCk7XG5cbiAgICAgIHRoaXMub25Ib3ZlclN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKHRvU3RhdGUpIHtcbiAgICAgICAgaWYgKHRvU3RhdGUgPT09ICdlbXBoYXNpcycpIHtcbiAgICAgICAgICBpZiAoZWZmZWN0Q2ZnLnNob3dFZmZlY3RPbiAhPT0gJ3JlbmRlcicpIHtcbiAgICAgICAgICAgIF90aGlzLnN0YXJ0RWZmZWN0QW5pbWF0aW9uKGVmZmVjdENmZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRvU3RhdGUgPT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgaWYgKGVmZmVjdENmZy5zaG93RWZmZWN0T24gIT09ICdyZW5kZXInKSB7XG4gICAgICAgICAgICBfdGhpcy5zdG9wRWZmZWN0QW5pbWF0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuX2VmZmVjdENmZyA9IGVmZmVjdENmZztcbiAgICBlbmFibGVIb3ZlckVtcGhhc2lzKHRoaXMpO1xuICB9O1xuXG4gIDtcblxuICBFZmZlY3RTeW1ib2wucHJvdG90eXBlLmZhZGVPdXQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICB0aGlzLm9mZignbW91c2VvdmVyJykub2ZmKCdtb3VzZW91dCcpO1xuICAgIGNiICYmIGNiKCk7XG4gIH07XG5cbiAgO1xuICByZXR1cm4gRWZmZWN0U3ltYm9sO1xufShHcm91cCk7XG5cbnpyVXRpbC5pbmhlcml0cyhFZmZlY3RTeW1ib2wsIEdyb3VwKTtcbmV4cG9ydCBkZWZhdWx0IEVmZmVjdFN5bWJvbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7IC8vIFRPRE8gQmF0Y2ggYnkgY29sb3JcblxuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IEluY3JlbWVudGFsRGlzcGxheWFibGUgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9JbmNyZW1lbnRhbERpc3BsYXlhYmxlJztcbmltcG9ydCAqIGFzIGxpbmVDb250YWluIGZyb20gJ3pyZW5kZXIvbGliL2NvbnRhaW4vbGluZSc7XG5pbXBvcnQgKiBhcyBxdWFkcmF0aWNDb250YWluIGZyb20gJ3pyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljJztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZSc7XG5cbnZhciBMYXJnZUxpbmVzUGF0aFNoYXBlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGFyZ2VMaW5lc1BhdGhTaGFwZSgpIHtcbiAgICB0aGlzLnBvbHlsaW5lID0gZmFsc2U7XG4gICAgdGhpcy5jdXJ2ZW5lc3MgPSAwO1xuICAgIHRoaXMuc2VncyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIExhcmdlTGluZXNQYXRoU2hhcGU7XG59KCk7XG5cbnZhciBMYXJnZUxpbmVzUGF0aCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhMYXJnZUxpbmVzUGF0aCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBMYXJnZUxpbmVzUGF0aChvcHRzKSB7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG4gIH1cblxuICBMYXJnZUxpbmVzUGF0aC5wcm90b3R5cGUuZ2V0RGVmYXVsdFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgIGZpbGw6IG51bGxcbiAgICB9O1xuICB9O1xuXG4gIExhcmdlTGluZXNQYXRoLnByb3RvdHlwZS5nZXREZWZhdWx0U2hhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBMYXJnZUxpbmVzUGF0aFNoYXBlKCk7XG4gIH07XG5cbiAgTGFyZ2VMaW5lc1BhdGgucHJvdG90eXBlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHNlZ3MgPSBzaGFwZS5zZWdzO1xuICAgIHZhciBjdXJ2ZW5lc3MgPSBzaGFwZS5jdXJ2ZW5lc3M7XG5cbiAgICBpZiAoc2hhcGUucG9seWxpbmUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7KSB7XG4gICAgICAgIHZhciBjb3VudCA9IHNlZ3NbaSsrXTtcblxuICAgICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhzZWdzW2krK10sIHNlZ3NbaSsrXSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBrID0gMTsgayA8IGNvdW50OyBrKyspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oc2Vnc1tpKytdLCBzZWdzW2krK10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOykge1xuICAgICAgICB2YXIgeDAgPSBzZWdzW2krK107XG4gICAgICAgIHZhciB5MCA9IHNlZ3NbaSsrXTtcbiAgICAgICAgdmFyIHgxID0gc2Vnc1tpKytdO1xuICAgICAgICB2YXIgeTEgPSBzZWdzW2krK107XG4gICAgICAgIGN0eC5tb3ZlVG8oeDAsIHkwKTtcblxuICAgICAgICBpZiAoY3VydmVuZXNzID4gMCkge1xuICAgICAgICAgIHZhciB4MiA9ICh4MCArIHgxKSAvIDIgLSAoeTAgLSB5MSkgKiBjdXJ2ZW5lc3M7XG4gICAgICAgICAgdmFyIHkyID0gKHkwICsgeTEpIC8gMiAtICh4MSAtIHgwKSAqIGN1cnZlbmVzcztcbiAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4MiwgeTIsIHgxLCB5MSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4MSwgeTEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIExhcmdlTGluZXNQYXRoLnByb3RvdHlwZS5maW5kRGF0YUluZGV4ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgIHZhciBzZWdzID0gc2hhcGUuc2VncztcbiAgICB2YXIgY3VydmVuZXNzID0gc2hhcGUuY3VydmVuZXNzO1xuICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLnN0eWxlLmxpbmVXaWR0aDtcblxuICAgIGlmIChzaGFwZS5wb2x5bGluZSkge1xuICAgICAgdmFyIGRhdGFJbmRleCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7KSB7XG4gICAgICAgIHZhciBjb3VudCA9IHNlZ3NbaSsrXTtcblxuICAgICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgdmFyIHgwID0gc2Vnc1tpKytdO1xuICAgICAgICAgIHZhciB5MCA9IHNlZ3NbaSsrXTtcblxuICAgICAgICAgIGZvciAodmFyIGsgPSAxOyBrIDwgY291bnQ7IGsrKykge1xuICAgICAgICAgICAgdmFyIHgxID0gc2Vnc1tpKytdO1xuICAgICAgICAgICAgdmFyIHkxID0gc2Vnc1tpKytdO1xuXG4gICAgICAgICAgICBpZiAobGluZUNvbnRhaW4uY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGF0YUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFJbmRleCsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YUluZGV4ID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDspIHtcbiAgICAgICAgdmFyIHgwID0gc2Vnc1tpKytdO1xuICAgICAgICB2YXIgeTAgPSBzZWdzW2krK107XG4gICAgICAgIHZhciB4MSA9IHNlZ3NbaSsrXTtcbiAgICAgICAgdmFyIHkxID0gc2Vnc1tpKytdO1xuXG4gICAgICAgIGlmIChjdXJ2ZW5lc3MgPiAwKSB7XG4gICAgICAgICAgdmFyIHgyID0gKHgwICsgeDEpIC8gMiAtICh5MCAtIHkxKSAqIGN1cnZlbmVzcztcbiAgICAgICAgICB2YXIgeTIgPSAoeTAgKyB5MSkgLyAyIC0gKHgxIC0geDApICogY3VydmVuZXNzO1xuXG4gICAgICAgICAgaWYgKHF1YWRyYXRpY0NvbnRhaW4uY29udGFpblN0cm9rZSh4MCwgeTAsIHgyLCB5MiwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YUluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobGluZUNvbnRhaW4uY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhSW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgcmV0dXJuIExhcmdlTGluZXNQYXRoO1xufShncmFwaGljLlBhdGgpO1xuXG52YXIgTGFyZ2VMaW5lRHJhdyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExhcmdlTGluZURyYXcoKSB7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gIH1cblxuICBMYXJnZUxpbmVEcmF3LnByb3RvdHlwZS5pc1BlcnNpc3RlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICF0aGlzLl9pbmNyZW1lbnRhbDtcbiAgfTtcblxuICA7XG4gIC8qKlxuICAgKiBVcGRhdGUgc3ltYm9scyBkcmF3IGJ5IG5ldyBkYXRhXG4gICAqL1xuXG4gIExhcmdlTGluZURyYXcucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgdmFyIGxpbmVFbCA9IG5ldyBMYXJnZUxpbmVzUGF0aCh7XG4gICAgICByZWN0SG92ZXI6IHRydWUsXG4gICAgICBjdXJzb3I6ICdkZWZhdWx0J1xuICAgIH0pO1xuICAgIGxpbmVFbC5zZXRTaGFwZSh7XG4gICAgICBzZWdzOiBkYXRhLmdldExheW91dCgnbGluZXNQb2ludHMnKVxuICAgIH0pO1xuXG4gICAgdGhpcy5fc2V0Q29tbW9uKGxpbmVFbCwgZGF0YSk7IC8vIEFkZCBiYWNrXG5cblxuICAgIHRoaXMuZ3JvdXAuYWRkKGxpbmVFbCk7XG4gICAgdGhpcy5faW5jcmVtZW50YWwgPSBudWxsO1xuICB9O1xuXG4gIDtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuICBMYXJnZUxpbmVEcmF3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFByZXBhcmVVcGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICB0aGlzLl9jbGVhckluY3JlbWVudGFsKCk7XG5cbiAgICBpZiAoZGF0YS5jb3VudCgpID4gNWU1KSB7XG4gICAgICBpZiAoIXRoaXMuX2luY3JlbWVudGFsKSB7XG4gICAgICAgIHRoaXMuX2luY3JlbWVudGFsID0gbmV3IEluY3JlbWVudGFsRGlzcGxheWFibGUoe1xuICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ncm91cC5hZGQodGhpcy5faW5jcmVtZW50YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbmNyZW1lbnRhbCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIDtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuICBMYXJnZUxpbmVEcmF3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFVwZGF0ZSA9IGZ1bmN0aW9uICh0YXNrUGFyYW1zLCBkYXRhKSB7XG4gICAgdmFyIGxpbmVFbCA9IG5ldyBMYXJnZUxpbmVzUGF0aCgpO1xuICAgIGxpbmVFbC5zZXRTaGFwZSh7XG4gICAgICBzZWdzOiBkYXRhLmdldExheW91dCgnbGluZXNQb2ludHMnKVxuICAgIH0pO1xuXG4gICAgdGhpcy5fc2V0Q29tbW9uKGxpbmVFbCwgZGF0YSwgISF0aGlzLl9pbmNyZW1lbnRhbCk7XG5cbiAgICBpZiAoIXRoaXMuX2luY3JlbWVudGFsKSB7XG4gICAgICBsaW5lRWwucmVjdEhvdmVyID0gdHJ1ZTtcbiAgICAgIGxpbmVFbC5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICBsaW5lRWwuX19zdGFydEluZGV4ID0gdGFza1BhcmFtcy5zdGFydDtcbiAgICAgIHRoaXMuZ3JvdXAuYWRkKGxpbmVFbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2luY3JlbWVudGFsLmFkZERpc3BsYXlhYmxlKGxpbmVFbCwgdHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIDtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuICBMYXJnZUxpbmVEcmF3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xlYXJJbmNyZW1lbnRhbCgpO1xuXG4gICAgdGhpcy5faW5jcmVtZW50YWwgPSBudWxsO1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gIH07XG5cbiAgO1xuXG4gIExhcmdlTGluZURyYXcucHJvdG90eXBlLl9zZXRDb21tb24gPSBmdW5jdGlvbiAobGluZUVsLCBkYXRhLCBpc0luY3JlbWVudGFsKSB7XG4gICAgdmFyIGhvc3RNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICAgIGxpbmVFbC5zZXRTaGFwZSh7XG4gICAgICBwb2x5bGluZTogaG9zdE1vZGVsLmdldCgncG9seWxpbmUnKSxcbiAgICAgIGN1cnZlbmVzczogaG9zdE1vZGVsLmdldChbJ2xpbmVTdHlsZScsICdjdXJ2ZW5lc3MnXSlcbiAgICB9KTtcbiAgICBsaW5lRWwudXNlU3R5bGUoaG9zdE1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKSk7XG4gICAgbGluZUVsLnN0eWxlLnN0cm9rZU5vU2NhbGUgPSB0cnVlO1xuICAgIHZhciBzdHlsZSA9IGRhdGEuZ2V0VmlzdWFsKCdzdHlsZScpO1xuXG4gICAgaWYgKHN0eWxlICYmIHN0eWxlLnN0cm9rZSkge1xuICAgICAgbGluZUVsLnNldFN0eWxlKCdzdHJva2UnLCBzdHlsZS5zdHJva2UpO1xuICAgIH1cblxuICAgIGxpbmVFbC5zZXRTdHlsZSgnZmlsbCcsIG51bGwpO1xuXG4gICAgaWYgKCFpc0luY3JlbWVudGFsKSB7XG4gICAgICB2YXIgZWNEYXRhXzEgPSBnZXRFQ0RhdGEobGluZUVsKTsgLy8gRW5hYmxlIHRvb2x0aXBcbiAgICAgIC8vIFBFTkRJTkcgTWF5IGhhdmUgcGVyZm9ybWFuY2UgaXNzdWUgd2hlbiBwYXRoIGlzIGV4dHJlbWVseSBsYXJnZVxuXG4gICAgICBlY0RhdGFfMS5zZXJpZXNJbmRleCA9IGhvc3RNb2RlbC5zZXJpZXNJbmRleDtcbiAgICAgIGxpbmVFbC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZWNEYXRhXzEuZGF0YUluZGV4ID0gbnVsbDtcbiAgICAgICAgdmFyIGRhdGFJbmRleCA9IGxpbmVFbC5maW5kRGF0YUluZGV4KGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcblxuICAgICAgICBpZiAoZGF0YUluZGV4ID4gMCkge1xuICAgICAgICAgIC8vIFByb3ZpZGUgZGF0YUluZGV4IGZvciB0b29sdGlwXG4gICAgICAgICAgZWNEYXRhXzEuZGF0YUluZGV4ID0gZGF0YUluZGV4ICsgbGluZUVsLl9fc3RhcnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIDtcblxuICBMYXJnZUxpbmVEcmF3LnByb3RvdHlwZS5fY2xlYXJJbmNyZW1lbnRhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5jcmVtZW50YWwgPSB0aGlzLl9pbmNyZW1lbnRhbDtcblxuICAgIGlmIChpbmNyZW1lbnRhbCkge1xuICAgICAgaW5jcmVtZW50YWwuY2xlYXJEaXNwbGF5YmxlcygpO1xuICAgIH1cbiAgfTtcblxuICA7XG4gIHJldHVybiBMYXJnZUxpbmVEcmF3O1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBMYXJnZUxpbmVEcmF3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbi8qIGdsb2JhbCBGbG9hdDMyQXJyYXkgKi9cbi8vIFRPRE8gQmF0Y2ggYnkgY29sb3JcblxuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IHsgY3JlYXRlU3ltYm9sIH0gZnJvbSAnLi4vLi4vdXRpbC9zeW1ib2wnO1xuaW1wb3J0IEluY3JlbWVudGFsRGlzcGxheWFibGUgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9JbmNyZW1lbnRhbERpc3BsYXlhYmxlJztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZSc7XG52YXIgQk9PU1RfU0laRV9USFJFU0hPTEQgPSA0O1xuXG52YXIgTGFyZ2VTeW1ib2xQYXRoU2hhcGUgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYXJnZVN5bWJvbFBhdGhTaGFwZSgpIHt9XG5cbiAgcmV0dXJuIExhcmdlU3ltYm9sUGF0aFNoYXBlO1xufSgpO1xuXG52YXIgTGFyZ2VTeW1ib2xQYXRoID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKExhcmdlU3ltYm9sUGF0aCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBMYXJnZVN5bWJvbFBhdGgob3B0cykge1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICB9XG5cbiAgTGFyZ2VTeW1ib2xQYXRoLnByb3RvdHlwZS5nZXREZWZhdWx0U2hhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBMYXJnZVN5bWJvbFBhdGhTaGFwZSgpO1xuICB9O1xuXG4gIExhcmdlU3ltYm9sUGF0aC5wcm90b3R5cGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XG4gICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICB2YXIgc2l6ZSA9IHNoYXBlLnNpemU7XG4gICAgdmFyIHN5bWJvbFByb3h5ID0gdGhpcy5zeW1ib2xQcm94eTtcbiAgICB2YXIgc3ltYm9sUHJveHlTaGFwZSA9IHN5bWJvbFByb3h5LnNoYXBlO1xuICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQgPyBwYXRoLmdldENvbnRleHQoKSA6IHBhdGg7XG4gICAgdmFyIGNhbkJvb3N0ID0gY3R4ICYmIHNpemVbMF0gPCBCT09TVF9TSVpFX1RIUkVTSE9MRDsgLy8gRG8gZHJhdyBpbiBhZnRlckJydXNoLlxuXG4gICAgaWYgKGNhbkJvb3N0KSB7XG4gICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY3R4ID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDspIHtcbiAgICAgIHZhciB4ID0gcG9pbnRzW2krK107XG4gICAgICB2YXIgeSA9IHBvaW50c1tpKytdO1xuXG4gICAgICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNvZnRDbGlwU2hhcGUgJiYgIXRoaXMuc29mdENsaXBTaGFwZS5jb250YWluKHgsIHkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzeW1ib2xQcm94eVNoYXBlLnggPSB4IC0gc2l6ZVswXSAvIDI7XG4gICAgICBzeW1ib2xQcm94eVNoYXBlLnkgPSB5IC0gc2l6ZVsxXSAvIDI7XG4gICAgICBzeW1ib2xQcm94eVNoYXBlLndpZHRoID0gc2l6ZVswXTtcbiAgICAgIHN5bWJvbFByb3h5U2hhcGUuaGVpZ2h0ID0gc2l6ZVsxXTtcbiAgICAgIHN5bWJvbFByb3h5LmJ1aWxkUGF0aChwYXRoLCBzeW1ib2xQcm94eVNoYXBlLCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgTGFyZ2VTeW1ib2xQYXRoLnByb3RvdHlwZS5hZnRlckJydXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICB2YXIgc2l6ZSA9IHNoYXBlLnNpemU7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblxuICAgIGlmICghY3R4KSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBQRU5ESU5HIElmIHN0eWxlIG9yIG90aGVyIGNhbnZhcyBzdGF0dXMgY2hhbmdlZD9cblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOykge1xuICAgICAgdmFyIHggPSBwb2ludHNbaSsrXTtcbiAgICAgIHZhciB5ID0gcG9pbnRzW2krK107XG5cbiAgICAgIGlmIChpc05hTih4KSB8fCBpc05hTih5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc29mdENsaXBTaGFwZSAmJiAhdGhpcy5zb2Z0Q2xpcFNoYXBlLmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGZpbGxSZWN0IGlzIGZhc3RlciB0aGFuIGJ1aWxkaW5nIGEgcmVjdCBwYXRoIGFuZCBkcmF3LlxuICAgICAgLy8gQW5kIGl0IHN1cHBvcnQgbGlnaHQgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uLlxuXG5cbiAgICAgIGN0eC5maWxsUmVjdCh4IC0gc2l6ZVswXSAvIDIsIHkgLSBzaXplWzFdIC8gMiwgc2l6ZVswXSwgc2l6ZVsxXSk7XG4gICAgfVxuICB9O1xuXG4gIExhcmdlU3ltYm9sUGF0aC5wcm90b3R5cGUuZmluZERhdGFJbmRleCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgLy8gVE9ETyA/Pz9cbiAgICAvLyBDb25zaWRlciB0cmFuc2Zvcm1cbiAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gICAgdmFyIHNpemUgPSBzaGFwZS5zaXplO1xuICAgIHZhciB3ID0gTWF0aC5tYXgoc2l6ZVswXSwgNCk7XG4gICAgdmFyIGggPSBNYXRoLm1heChzaXplWzFdLCA0KTsgLy8gTm90IGNvbnNpZGVyIHRyYW5zZm9ybVxuICAgIC8vIFRyZWF0IGVhY2ggZWxlbWVudCBhcyBhIHJlY3RcbiAgICAvLyB0b3AgZG93biB0cmF2ZXJzZVxuXG4gICAgZm9yICh2YXIgaWR4ID0gcG9pbnRzLmxlbmd0aCAvIDIgLSAxOyBpZHggPj0gMDsgaWR4LS0pIHtcbiAgICAgIHZhciBpID0gaWR4ICogMjtcbiAgICAgIHZhciB4MCA9IHBvaW50c1tpXSAtIHcgLyAyO1xuICAgICAgdmFyIHkwID0gcG9pbnRzW2kgKyAxXSAtIGggLyAyO1xuXG4gICAgICBpZiAoeCA+PSB4MCAmJiB5ID49IHkwICYmIHggPD0geDAgKyB3ICYmIHkgPD0geTAgKyBoKSB7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIHJldHVybiBMYXJnZVN5bWJvbFBhdGg7XG59KGdyYXBoaWMuUGF0aCk7XG5cbnZhciBMYXJnZVN5bWJvbERyYXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYXJnZVN5bWJvbERyYXcoKSB7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gIH1cblxuICBMYXJnZVN5bWJvbERyYXcucHJvdG90eXBlLmlzUGVyc2lzdGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2luY3JlbWVudGFsO1xuICB9O1xuXG4gIDtcbiAgLyoqXG4gICAqIFVwZGF0ZSBzeW1ib2xzIGRyYXcgYnkgbmV3IGRhdGFcbiAgICovXG5cbiAgTGFyZ2VTeW1ib2xEcmF3LnByb3RvdHlwZS51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGRhdGEsIG9wdCkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgdmFyIHN5bWJvbEVsID0gbmV3IExhcmdlU3ltYm9sUGF0aCh7XG4gICAgICByZWN0SG92ZXI6IHRydWUsXG4gICAgICBjdXJzb3I6ICdkZWZhdWx0J1xuICAgIH0pO1xuICAgIHN5bWJvbEVsLnNldFNoYXBlKHtcbiAgICAgIHBvaW50czogZGF0YS5nZXRMYXlvdXQoJ3BvaW50cycpXG4gICAgfSk7XG5cbiAgICB0aGlzLl9zZXRDb21tb24oc3ltYm9sRWwsIGRhdGEsIGZhbHNlLCBvcHQpO1xuXG4gICAgdGhpcy5ncm91cC5hZGQoc3ltYm9sRWwpO1xuICAgIHRoaXMuX2luY3JlbWVudGFsID0gbnVsbDtcbiAgfTtcblxuICBMYXJnZVN5bWJvbERyYXcucHJvdG90eXBlLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKHRoaXMuX2luY3JlbWVudGFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvaW50cyA9IGRhdGEuZ2V0TGF5b3V0KCdwb2ludHMnKTtcbiAgICB0aGlzLmdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5zdGFydEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGxlbiA9IChjaGlsZC5lbmRJbmRleCAtIGNoaWxkLnN0YXJ0SW5kZXgpICogMjtcbiAgICAgICAgdmFyIGJ5dGVPZmZzZXQgPSBjaGlsZC5zdGFydEluZGV4ICogNCAqIDI7XG4gICAgICAgIHBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQuc2V0U2hhcGUoJ3BvaW50cycsIHBvaW50cyk7XG4gICAgfSk7XG4gIH07XG5cbiAgTGFyZ2VTeW1ib2xEcmF3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFByZXBhcmVVcGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICB0aGlzLl9jbGVhckluY3JlbWVudGFsKCk7IC8vIE9ubHkgdXNlIGluY3JlbWVudGFsIGRpc3BsYXlhYmxlcyB3aGVuIGRhdGEgYW1vdW50IGlzIGxhcmdlciB0aGFuIDIgbWlsbGlvbi5cbiAgICAvLyBQRU5ESU5HIEluY3JlbWVudGFsIGRhdGE/XG5cblxuICAgIGlmIChkYXRhLmNvdW50KCkgPiAyZTYpIHtcbiAgICAgIGlmICghdGhpcy5faW5jcmVtZW50YWwpIHtcbiAgICAgICAgdGhpcy5faW5jcmVtZW50YWwgPSBuZXcgSW5jcmVtZW50YWxEaXNwbGF5YWJsZSh7XG4gICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLl9pbmNyZW1lbnRhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2luY3JlbWVudGFsID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgTGFyZ2VTeW1ib2xEcmF3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFVwZGF0ZSA9IGZ1bmN0aW9uICh0YXNrUGFyYW1zLCBkYXRhLCBvcHQpIHtcbiAgICB2YXIgc3ltYm9sRWw7XG5cbiAgICBpZiAodGhpcy5faW5jcmVtZW50YWwpIHtcbiAgICAgIHN5bWJvbEVsID0gbmV3IExhcmdlU3ltYm9sUGF0aCgpO1xuXG4gICAgICB0aGlzLl9pbmNyZW1lbnRhbC5hZGREaXNwbGF5YWJsZShzeW1ib2xFbCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN5bWJvbEVsID0gbmV3IExhcmdlU3ltYm9sUGF0aCh7XG4gICAgICAgIHJlY3RIb3ZlcjogdHJ1ZSxcbiAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCcsXG4gICAgICAgIHN0YXJ0SW5kZXg6IHRhc2tQYXJhbXMuc3RhcnQsXG4gICAgICAgIGVuZEluZGV4OiB0YXNrUGFyYW1zLmVuZFxuICAgICAgfSk7XG4gICAgICBzeW1ib2xFbC5pbmNyZW1lbnRhbCA9IHRydWU7XG4gICAgICB0aGlzLmdyb3VwLmFkZChzeW1ib2xFbCk7XG4gICAgfVxuXG4gICAgc3ltYm9sRWwuc2V0U2hhcGUoe1xuICAgICAgcG9pbnRzOiBkYXRhLmdldExheW91dCgncG9pbnRzJylcbiAgICB9KTtcblxuICAgIHRoaXMuX3NldENvbW1vbihzeW1ib2xFbCwgZGF0YSwgISF0aGlzLl9pbmNyZW1lbnRhbCwgb3B0KTtcbiAgfTtcblxuICBMYXJnZVN5bWJvbERyYXcucHJvdG90eXBlLl9zZXRDb21tb24gPSBmdW5jdGlvbiAoc3ltYm9sRWwsIGRhdGEsIGlzSW5jcmVtZW50YWwsIG9wdCkge1xuICAgIHZhciBob3N0TW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICBvcHQgPSBvcHQgfHwge307XG4gICAgdmFyIHNpemUgPSBkYXRhLmdldFZpc3VhbCgnc3ltYm9sU2l6ZScpO1xuICAgIHN5bWJvbEVsLnNldFNoYXBlKCdzaXplJywgc2l6ZSBpbnN0YW5jZW9mIEFycmF5ID8gc2l6ZSA6IFtzaXplLCBzaXplXSk7XG4gICAgc3ltYm9sRWwuc29mdENsaXBTaGFwZSA9IG9wdC5jbGlwU2hhcGUgfHwgbnVsbDsgLy8gQ3JlYXRlIHN5bWJvbFByb3h5IHRvIGJ1aWxkIHBhdGggZm9yIGVhY2ggZGF0YVxuXG4gICAgc3ltYm9sRWwuc3ltYm9sUHJveHkgPSBjcmVhdGVTeW1ib2woZGF0YS5nZXRWaXN1YWwoJ3N5bWJvbCcpLCAwLCAwLCAwLCAwKTsgLy8gVXNlIHN5bWJvbFByb3h5IHNldENvbG9yIG1ldGhvZFxuXG4gICAgc3ltYm9sRWwuc2V0Q29sb3IgPSBzeW1ib2xFbC5zeW1ib2xQcm94eS5zZXRDb2xvcjtcbiAgICB2YXIgZXh0cnVkZVNoYWRvdyA9IHN5bWJvbEVsLnNoYXBlLnNpemVbMF0gPCBCT09TVF9TSVpFX1RIUkVTSE9MRDtcbiAgICBzeW1ib2xFbC51c2VTdHlsZSggLy8gRHJhdyBzaGFkb3cgd2hlbiBkb2luZyBmaWxsUmVjdCBpcyBleHRyZW1lbHkgc2xvdy5cbiAgICBob3N0TW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZShleHRydWRlU2hhZG93ID8gWydjb2xvcicsICdzaGFkb3dCbHVyJywgJ3NoYWRvd0NvbG9yJ10gOiBbJ2NvbG9yJ10pKTtcbiAgICB2YXIgZ2xvYmFsU3R5bGUgPSBkYXRhLmdldFZpc3VhbCgnc3R5bGUnKTtcbiAgICB2YXIgdmlzdWFsQ29sb3IgPSBnbG9iYWxTdHlsZSAmJiBnbG9iYWxTdHlsZS5maWxsO1xuXG4gICAgaWYgKHZpc3VhbENvbG9yKSB7XG4gICAgICBzeW1ib2xFbC5zZXRDb2xvcih2aXN1YWxDb2xvcik7XG4gICAgfVxuXG4gICAgaWYgKCFpc0luY3JlbWVudGFsKSB7XG4gICAgICB2YXIgZWNEYXRhXzEgPSBnZXRFQ0RhdGEoc3ltYm9sRWwpOyAvLyBFbmFibGUgdG9vbHRpcFxuICAgICAgLy8gUEVORElORyBNYXkgaGF2ZSBwZXJmb3JtYW5jZSBpc3N1ZSB3aGVuIHBhdGggaXMgZXh0cmVtZWx5IGxhcmdlXG5cbiAgICAgIGVjRGF0YV8xLnNlcmllc0luZGV4ID0gaG9zdE1vZGVsLnNlcmllc0luZGV4O1xuICAgICAgc3ltYm9sRWwub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGVjRGF0YV8xLmRhdGFJbmRleCA9IG51bGw7XG4gICAgICAgIHZhciBkYXRhSW5kZXggPSBzeW1ib2xFbC5maW5kRGF0YUluZGV4KGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcblxuICAgICAgICBpZiAoZGF0YUluZGV4ID49IDApIHtcbiAgICAgICAgICAvLyBQcm92aWRlIGRhdGFJbmRleCBmb3IgdG9vbHRpcFxuICAgICAgICAgIGVjRGF0YV8xLmRhdGFJbmRleCA9IGRhdGFJbmRleCArIChzeW1ib2xFbC5zdGFydEluZGV4IHx8IDApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgTGFyZ2VTeW1ib2xEcmF3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xlYXJJbmNyZW1lbnRhbCgpO1xuXG4gICAgdGhpcy5faW5jcmVtZW50YWwgPSBudWxsO1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gIH07XG5cbiAgTGFyZ2VTeW1ib2xEcmF3LnByb3RvdHlwZS5fY2xlYXJJbmNyZW1lbnRhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5jcmVtZW50YWwgPSB0aGlzLl9pbmNyZW1lbnRhbDtcblxuICAgIGlmIChpbmNyZW1lbnRhbCkge1xuICAgICAgaW5jcmVtZW50YWwuY2xlYXJEaXNwbGF5YmxlcygpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTGFyZ2VTeW1ib2xEcmF3O1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBMYXJnZVN5bWJvbERyYXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IHsgZW5hYmxlSG92ZXJFbXBoYXNpcyB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdGVzJztcblxudmFyIFBvbHlsaW5lID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBvbHlsaW5lLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFBvbHlsaW5lKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF90aGlzLl9jcmVhdGVQb2x5bGluZShsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBQb2x5bGluZS5wcm90b3R5cGUuX2NyZWF0ZVBvbHlsaW5lID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgLy8gbGV0IHNlcmllc01vZGVsID0gbGluZURhdGEuaG9zdE1vZGVsO1xuICAgIHZhciBwb2ludHMgPSBsaW5lRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgdmFyIGxpbmUgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSh7XG4gICAgICBzaGFwZToge1xuICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYWRkKGxpbmUpO1xuXG4gICAgdGhpcy5fdXBkYXRlQ29tbW9uU3RsKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbiAgfTtcblxuICA7XG5cbiAgUG9seWxpbmUucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgICB2YXIgc2VyaWVzTW9kZWwgPSBsaW5lRGF0YS5ob3N0TW9kZWw7XG4gICAgdmFyIGxpbmUgPSB0aGlzLmNoaWxkQXQoMCk7XG4gICAgdmFyIHRhcmdldCA9IHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHBvaW50czogbGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpXG4gICAgICB9XG4gICAgfTtcbiAgICBncmFwaGljLnVwZGF0ZVByb3BzKGxpbmUsIHRhcmdldCwgc2VyaWVzTW9kZWwsIGlkeCk7XG5cbiAgICB0aGlzLl91cGRhdGVDb21tb25TdGwobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpO1xuICB9O1xuXG4gIDtcblxuICBQb2x5bGluZS5wcm90b3R5cGUuX3VwZGF0ZUNvbW1vblN0bCA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICAgIHZhciBsaW5lID0gdGhpcy5jaGlsZEF0KDApO1xuICAgIHZhciBpdGVtTW9kZWwgPSBsaW5lRGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICB2YXIgaG92ZXJMaW5lU3R5bGUgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5lbXBoYXNpc0xpbmVTdHlsZTtcblxuICAgIGlmICghc2VyaWVzU2NvcGUgfHwgbGluZURhdGEuaGFzSXRlbU9wdGlvbikge1xuICAgICAgaG92ZXJMaW5lU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoWydlbXBoYXNpcycsICdsaW5lU3R5bGUnXSkuZ2V0TGluZVN0eWxlKCk7XG4gICAgfVxuXG4gICAgbGluZS51c2VTdHlsZShsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJykpO1xuICAgIGxpbmUuc3R5bGUuZmlsbCA9IG51bGw7XG4gICAgbGluZS5zdHlsZS5zdHJva2VOb1NjYWxlID0gdHJ1ZTtcbiAgICB2YXIgbGluZUVtcGhhc2lzU3RhdGUgPSBsaW5lLmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpO1xuICAgIGxpbmVFbXBoYXNpc1N0YXRlLnN0eWxlID0gaG92ZXJMaW5lU3R5bGU7XG4gICAgZW5hYmxlSG92ZXJFbXBoYXNpcyh0aGlzKTtcbiAgfTtcblxuICA7XG5cbiAgUG9seWxpbmUucHJvdG90eXBlLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4KSB7XG4gICAgdmFyIHBvbHlsaW5lID0gdGhpcy5jaGlsZEF0KDApO1xuICAgIHBvbHlsaW5lLnNldFNoYXBlKCdwb2ludHMnLCBsaW5lRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCkpO1xuICB9O1xuXG4gIDtcbiAgcmV0dXJuIFBvbHlsaW5lO1xufShncmFwaGljLkdyb3VwKTtcblxuZXhwb3J0IGRlZmF1bHQgUG9seWxpbmU7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXInO1xuXG5mdW5jdGlvbiBjcmVhdGVHcmlkQ2xpcFBhdGgoY2FydGVzaWFuLCBoYXNBbmltYXRpb24sIHNlcmllc01vZGVsLCBkb25lLCBkdXJpbmcpIHtcbiAgdmFyIHJlY3QgPSBjYXJ0ZXNpYW4uZ2V0QXJlYSgpO1xuICB2YXIgeCA9IHJlY3QueDtcbiAgdmFyIHkgPSByZWN0Lnk7XG4gIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgdmFyIGxpbmVXaWR0aCA9IHNlcmllc01vZGVsLmdldChbJ2xpbmVTdHlsZScsICd3aWR0aCddKSB8fCAyOyAvLyBFeHBhbmQgdGhlIGNsaXAgcGF0aCBhIGJpdCB0byBhdm9pZCB0aGUgYm9yZGVyIGlzIGNsaXBwZWQgYW5kIGxvb2tzIHRoaW5uZXJcblxuICB4IC09IGxpbmVXaWR0aCAvIDI7XG4gIHkgLT0gbGluZVdpZHRoIC8gMjtcbiAgd2lkdGggKz0gbGluZVdpZHRoO1xuICBoZWlnaHQgKz0gbGluZVdpZHRoOyAvLyBmaXg6IGh0dHBzOi8vZ2l0aHViLmNvbS9hcGFjaGUvaW5jdWJhdG9yLWVjaGFydHMvaXNzdWVzLzExMzY5XG5cbiAgeCA9IE1hdGguZmxvb3IoeCk7XG4gIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gIHZhciBjbGlwUGF0aCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgIHNoYXBlOiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfVxuICB9KTtcblxuICBpZiAoaGFzQW5pbWF0aW9uKSB7XG4gICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG4gICAgdmFyIGlzSG9yaXpvbnRhbCA9IGJhc2VBeGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIHZhciBpc0F4aXNJbnZlcnNlZCA9IGJhc2VBeGlzLmludmVyc2U7XG5cbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICBpZiAoaXNBeGlzSW52ZXJzZWQpIHtcbiAgICAgICAgY2xpcFBhdGguc2hhcGUueCArPSB3aWR0aDtcbiAgICAgIH1cblxuICAgICAgY2xpcFBhdGguc2hhcGUud2lkdGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWlzQXhpc0ludmVyc2VkKSB7XG4gICAgICAgIGNsaXBQYXRoLnNoYXBlLnkgKz0gaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBjbGlwUGF0aC5zaGFwZS5oZWlnaHQgPSAwO1xuICAgIH1cblxuICAgIHZhciBkdXJpbmdDYiA9IHR5cGVvZiBkdXJpbmcgPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiAocGVyY2VudCkge1xuICAgICAgZHVyaW5nKHBlcmNlbnQsIGNsaXBQYXRoKTtcbiAgICB9IDogbnVsbDtcbiAgICBncmFwaGljLmluaXRQcm9wcyhjbGlwUGF0aCwge1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfVxuICAgIH0sIHNlcmllc01vZGVsLCBudWxsLCBkb25lLCBkdXJpbmdDYik7XG4gIH1cblxuICByZXR1cm4gY2xpcFBhdGg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvbGFyQ2xpcFBhdGgocG9sYXIsIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwpIHtcbiAgdmFyIHNlY3RvckFyZWEgPSBwb2xhci5nZXRBcmVhKCk7IC8vIEF2b2lkIGZsb2F0IG51bWJlciByb3VuZGluZyBlcnJvciBmb3Igc3ltYm9sIG9uIHRoZSBlZGdlIG9mIGF4aXMgZXh0ZW50LlxuXG4gIHZhciByMCA9IHJvdW5kKHNlY3RvckFyZWEucjAsIDEpO1xuICB2YXIgciA9IHJvdW5kKHNlY3RvckFyZWEuciwgMSk7XG4gIHZhciBjbGlwUGF0aCA9IG5ldyBncmFwaGljLlNlY3Rvcih7XG4gICAgc2hhcGU6IHtcbiAgICAgIGN4OiByb3VuZChwb2xhci5jeCwgMSksXG4gICAgICBjeTogcm91bmQocG9sYXIuY3ksIDEpLFxuICAgICAgcjA6IHIwLFxuICAgICAgcjogcixcbiAgICAgIHN0YXJ0QW5nbGU6IHNlY3RvckFyZWEuc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlOiBzZWN0b3JBcmVhLmVuZEFuZ2xlLFxuICAgICAgY2xvY2t3aXNlOiBzZWN0b3JBcmVhLmNsb2Nrd2lzZVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGhhc0FuaW1hdGlvbikge1xuICAgIHZhciBpc1JhZGlhbCA9IHBvbGFyLmdldEJhc2VBeGlzKCkuZGltID09PSAnYW5nbGUnO1xuXG4gICAgaWYgKGlzUmFkaWFsKSB7XG4gICAgICBjbGlwUGF0aC5zaGFwZS5lbmRBbmdsZSA9IHNlY3RvckFyZWEuc3RhcnRBbmdsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xpcFBhdGguc2hhcGUuciA9IHIwO1xuICAgIH1cblxuICAgIGdyYXBoaWMuaW5pdFByb3BzKGNsaXBQYXRoLCB7XG4gICAgICBzaGFwZToge1xuICAgICAgICBlbmRBbmdsZTogc2VjdG9yQXJlYS5lbmRBbmdsZSxcbiAgICAgICAgcjogclxuICAgICAgfVxuICAgIH0sIHNlcmllc01vZGVsKTtcbiAgfVxuXG4gIHJldHVybiBjbGlwUGF0aDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2xpcFBhdGgoY29vcmRTeXMsIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwsIGRvbmUsIGR1cmluZykge1xuICBpZiAoIWNvb3JkU3lzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoY29vcmRTeXMudHlwZSA9PT0gJ3BvbGFyJykge1xuICAgIHJldHVybiBjcmVhdGVQb2xhckNsaXBQYXRoKGNvb3JkU3lzLCBoYXNBbmltYXRpb24sIHNlcmllc01vZGVsKTtcbiAgfSBlbHNlIGlmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUdyaWRDbGlwUGF0aChjb29yZFN5cywgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCwgZG9uZSwgZHVyaW5nKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBjcmVhdGVHcmlkQ2xpcFBhdGgsIGNyZWF0ZVBvbGFyQ2xpcFBhdGgsIGNyZWF0ZUNsaXBQYXRoIH07IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IExpc3QgZnJvbSAnLi4vLi4vZGF0YS9MaXN0JztcbmltcG9ydCBHcmFwaCBmcm9tICcuLi8uLi9kYXRhL0dyYXBoJztcbmltcG9ydCBsaW5rTGlzdCBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9saW5rTGlzdCc7XG5pbXBvcnQgY3JlYXRlRGltZW5zaW9ucyBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9jcmVhdGVEaW1lbnNpb25zJztcbmltcG9ydCBDb29yZGluYXRlU3lzdGVtIGZyb20gJy4uLy4uL2NvcmUvQ29vcmRpbmF0ZVN5c3RlbSc7XG5pbXBvcnQgY3JlYXRlTGlzdEZyb21BcnJheSBmcm9tICcuL2NyZWF0ZUxpc3RGcm9tQXJyYXknO1xuaW1wb3J0IHsgY29udmVydE9wdGlvbklkTmFtZSB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlR3JhcGhGcm9tTm9kZUVkZ2Uobm9kZXMsIGVkZ2VzLCBzZXJpZXNNb2RlbCwgZGlyZWN0ZWQsIGJlZm9yZUxpbmspIHtcbiAgLy8gPz8/IFRPRE9cbiAgLy8gc3VwcG9ydCBkYXRhc2V0P1xuICB2YXIgZ3JhcGggPSBuZXcgR3JhcGgoZGlyZWN0ZWQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBncmFwaC5hZGROb2RlKHpyVXRpbC5yZXRyaWV2ZSggLy8gSWQsIG5hbWUsIGRhdGFJbmRleFxuICAgIG5vZGVzW2ldLmlkLCBub2Rlc1tpXS5uYW1lLCBpKSwgaSk7XG4gIH1cblxuICB2YXIgbGlua05hbWVMaXN0ID0gW107XG4gIHZhciB2YWxpZEVkZ2VzID0gW107XG4gIHZhciBsaW5rQ291bnQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluayA9IGVkZ2VzW2ldO1xuICAgIHZhciBzb3VyY2UgPSBsaW5rLnNvdXJjZTtcbiAgICB2YXIgdGFyZ2V0ID0gbGluay50YXJnZXQ7IC8vIGFkZEVkZ2UgbWF5IGZhaWwgd2hlbiBzb3VyY2Ugb3IgdGFyZ2V0IG5vdCBleGlzdHNcblxuICAgIGlmIChncmFwaC5hZGRFZGdlKHNvdXJjZSwgdGFyZ2V0LCBsaW5rQ291bnQpKSB7XG4gICAgICB2YWxpZEVkZ2VzLnB1c2gobGluayk7XG4gICAgICBsaW5rTmFtZUxpc3QucHVzaCh6clV0aWwucmV0cmlldmUoY29udmVydE9wdGlvbklkTmFtZShsaW5rLmlkLCBudWxsKSwgc291cmNlICsgJyA+ICcgKyB0YXJnZXQpKTtcbiAgICAgIGxpbmtDb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpO1xuICB2YXIgbm9kZURhdGE7XG5cbiAgaWYgKGNvb3JkU3lzID09PSAnY2FydGVzaWFuMmQnIHx8IGNvb3JkU3lzID09PSAncG9sYXInKSB7XG4gICAgbm9kZURhdGEgPSBjcmVhdGVMaXN0RnJvbUFycmF5KG5vZGVzLCBzZXJpZXNNb2RlbCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvb3JkU3lzQ3RvciA9IENvb3JkaW5hdGVTeXN0ZW0uZ2V0KGNvb3JkU3lzKTtcbiAgICB2YXIgY29vcmREaW1lbnNpb25zID0gY29vcmRTeXNDdG9yID8gY29vcmRTeXNDdG9yLmRpbWVuc2lvbnMgfHwgW10gOiBbXTsgLy8gRklYTUU6IFNvbWUgZ2VvIGRvIG5vdCBuZWVkIGB2YWx1ZWAgZGltZW5zb24sIHdoZXJlYXMgYGNhbGVuZGFyYCBuZWVkc1xuICAgIC8vIGB2YWx1ZWAgZGltZW5zaW9uLCBidXQgZ3JhcGggbmVlZCBgdmFsdWVgIGRpbWVuc2lvbi4gSXQncyBiZXR0ZXIgdG9cbiAgICAvLyB1bmlmb3JtIHRoaXMgYmVoYXZpb3IuXG5cbiAgICBpZiAoenJVdGlsLmluZGV4T2YoY29vcmREaW1lbnNpb25zLCAndmFsdWUnKSA8IDApIHtcbiAgICAgIGNvb3JkRGltZW5zaW9ucy5jb25jYXQoWyd2YWx1ZSddKTtcbiAgICB9XG5cbiAgICB2YXIgZGltZW5zaW9uTmFtZXMgPSBjcmVhdGVEaW1lbnNpb25zKG5vZGVzLCB7XG4gICAgICBjb29yZERpbWVuc2lvbnM6IGNvb3JkRGltZW5zaW9uc1xuICAgIH0pO1xuICAgIG5vZGVEYXRhID0gbmV3IExpc3QoZGltZW5zaW9uTmFtZXMsIHNlcmllc01vZGVsKTtcbiAgICBub2RlRGF0YS5pbml0RGF0YShub2Rlcyk7XG4gIH1cblxuICB2YXIgZWRnZURhdGEgPSBuZXcgTGlzdChbJ3ZhbHVlJ10sIHNlcmllc01vZGVsKTtcbiAgZWRnZURhdGEuaW5pdERhdGEodmFsaWRFZGdlcywgbGlua05hbWVMaXN0KTtcbiAgYmVmb3JlTGluayAmJiBiZWZvcmVMaW5rKG5vZGVEYXRhLCBlZGdlRGF0YSk7XG4gIGxpbmtMaXN0KHtcbiAgICBtYWluRGF0YTogbm9kZURhdGEsXG4gICAgc3RydWN0OiBncmFwaCxcbiAgICBzdHJ1Y3RBdHRyOiAnZ3JhcGgnLFxuICAgIGRhdGFzOiB7XG4gICAgICBub2RlOiBub2RlRGF0YSxcbiAgICAgIGVkZ2U6IGVkZ2VEYXRhXG4gICAgfSxcbiAgICBkYXRhc0F0dHI6IHtcbiAgICAgIG5vZGU6ICdkYXRhJyxcbiAgICAgIGVkZ2U6ICdlZGdlRGF0YSdcbiAgICB9XG4gIH0pOyAvLyBVcGRhdGUgZGF0YUluZGV4IG9mIG5vZGVzIGFuZCBlZGdlcyBiZWNhdXNlIGludmFsaWQgZWRnZSBtYXkgYmUgcmVtb3ZlZFxuXG4gIGdyYXBoLnVwZGF0ZSgpO1xuICByZXR1cm4gZ3JhcGg7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCBjcmVhdGVEaW1lbnNpb25zIGZyb20gJy4uLy4uL2RhdGEvaGVscGVyL2NyZWF0ZURpbWVuc2lvbnMnO1xuaW1wb3J0IExpc3QgZnJvbSAnLi4vLi4vZGF0YS9MaXN0JztcbmltcG9ydCB7IGV4dGVuZCwgaXNBcnJheSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG4vKipcbiAqIFtVc2FnZV06XG4gKiAoMSlcbiAqIGNyZWF0ZUxpc3RTaW1wbHkoc2VyaWVzTW9kZWwsIFsndmFsdWUnXSk7XG4gKiAoMilcbiAqIGNyZWF0ZUxpc3RTaW1wbHkoc2VyaWVzTW9kZWwsIHtcbiAqICAgICBjb29yZERpbWVuc2lvbnM6IFsndmFsdWUnXSxcbiAqICAgICBkaW1lbnNpb25zQ291bnQ6IDVcbiAqIH0pO1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUxpc3RTaW1wbHkoc2VyaWVzTW9kZWwsIG9wdCwgbmFtZUxpc3QpIHtcbiAgb3B0ID0gaXNBcnJheShvcHQpICYmIHtcbiAgICBjb29yZERpbWVuc2lvbnM6IG9wdFxuICB9IHx8IGV4dGVuZCh7fSwgb3B0KTtcbiAgdmFyIHNvdXJjZSA9IHNlcmllc01vZGVsLmdldFNvdXJjZSgpO1xuICB2YXIgZGltZW5zaW9uc0luZm8gPSBjcmVhdGVEaW1lbnNpb25zKHNvdXJjZSwgb3B0KTtcbiAgdmFyIGxpc3QgPSBuZXcgTGlzdChkaW1lbnNpb25zSW5mbywgc2VyaWVzTW9kZWwpO1xuICBsaXN0LmluaXREYXRhKHNvdXJjZSwgbmFtZUxpc3QpO1xuICByZXR1cm4gbGlzdDtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgZ2V0RGVjYWxGcm9tUGFsZXR0ZSB9IGZyb20gJy4uLy4uL21vZGVsL21peGluL3BhbGV0dGUnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZW5hYmxlQXJpYURlY2FsRm9yVHJlZShzZXJpZXNNb2RlbCkge1xuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIHRyZWUgPSBkYXRhLnRyZWU7XG4gIHZhciBkZWNhbFBhbGV0dGVTY29wZSA9IHt9O1xuICB0cmVlLmVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgLy8gVXNlIGRlY2FsIG9mIGxldmVsIDEgbm9kZVxuICAgIHZhciBjdXJyZW50ID0gbm9kZTtcblxuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQuZGVwdGggPiAxKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHZhciBkZWNhbCA9IGdldERlY2FsRnJvbVBhbGV0dGUoc2VyaWVzTW9kZWwuZWNNb2RlbCwgY3VycmVudC5uYW1lIHx8IGN1cnJlbnQuZGF0YUluZGV4ICsgJycsIGRlY2FsUGFsZXR0ZVNjb3BlKTtcbiAgICBub2RlLnNldFZpc3VhbCgnZGVjYWwnLCBkZWNhbCk7XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBAdHMtbm9jaGVja1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG52YXIgS0VZX0RFTElNSVRFUiA9ICctLT4nO1xuLyoqXG4gKiBwYXJhbXMgaGFuZGxlclxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXNNb2RlbH0gc2VyaWVzTW9kZWxcbiAqIEByZXR1cm5zIHsqfVxuICovXG5cbnZhciBnZXRBdXRvQ3VydmVuZXNzUGFyYW1zID0gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gIHJldHVybiBzZXJpZXNNb2RlbC5nZXQoJ2F1dG9DdXJ2ZW5lc3MnKSB8fCBudWxsO1xufTtcbi8qKlxuICogR2VuZXJhdGUgYSBsaXN0IG9mIGVkZ2UgY3VydmF0dXJlcywgMjAgaXMgdGhlIGRlZmF1bHRcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzTW9kZWx9IHNlcmllc01vZGVsXG4gKiBAcGFyYW0ge251bWJlcn0gYXBwZW5kTGVuZ3RoXG4gKiBAcmV0dXJuICAyMCA9PiBbMCwgLTAuMiwgMC4yLCAtMC40LCAwLjQsIC0wLjYsIDAuNiwgLTAuOCwgMC44LCAtMSwgMSwgLTEuMiwgMS4yLCAtMS40LCAxLjQsIC0xLjYsIDEuNiwgLTEuOCwgMS44LCAtMl1cbiAqL1xuXG5cbnZhciBjcmVhdGVDdXJ2ZW5lc3MgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGFwcGVuZExlbmd0aCkge1xuICB2YXIgYXV0b0N1cnZlbmVzc1Bhcm1hcyA9IGdldEF1dG9DdXJ2ZW5lc3NQYXJhbXMoc2VyaWVzTW9kZWwpO1xuICB2YXIgbGVuZ3RoID0gMjA7XG4gIHZhciBjdXJ2ZW5lc3NMaXN0ID0gW107IC8vIGhhbmRsZXIgdGhlIGZ1bmN0aW9uIHNldFxuXG4gIGlmICh0eXBlb2YgYXV0b0N1cnZlbmVzc1Bhcm1hcyA9PT0gJ251bWJlcicpIHtcbiAgICBsZW5ndGggPSBhdXRvQ3VydmVuZXNzUGFybWFzO1xuICB9IGVsc2UgaWYgKHpyVXRpbC5pc0FycmF5KGF1dG9DdXJ2ZW5lc3NQYXJtYXMpKSB7XG4gICAgc2VyaWVzTW9kZWwuX19jdXJ2ZW5lc3NMaXN0ID0gYXV0b0N1cnZlbmVzc1Bhcm1hcztcbiAgICByZXR1cm47XG4gIH0gLy8gYXBwZW5kIGxlbmd0aFxuXG5cbiAgaWYgKGFwcGVuZExlbmd0aCA+IGxlbmd0aCkge1xuICAgIGxlbmd0aCA9IGFwcGVuZExlbmd0aDtcbiAgfSAvLyBtYWtlIHN1cmUgdGhlIGxlbmd0aCBpcyBldmVuXG5cblxuICB2YXIgbGVuID0gbGVuZ3RoICUgMiA/IGxlbmd0aCArIDIgOiBsZW5ndGggKyAzO1xuICBjdXJ2ZW5lc3NMaXN0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGN1cnZlbmVzc0xpc3QucHVzaCgoaSAlIDIgPyBpICsgMSA6IGkpIC8gMTAgKiAoaSAlIDIgPyAtMSA6IDEpKTtcbiAgfVxuXG4gIHNlcmllc01vZGVsLl9fY3VydmVuZXNzTGlzdCA9IGN1cnZlbmVzc0xpc3Q7XG59O1xuLyoqXG4gKiBDcmVhdGUgZGlmZmVyZW50IGNhY2hlIGtleSBkYXRhIGluIHRoZSBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgZGlyZWN0aW9ucywgaW4gb3JkZXIgdG8gc2V0IHRoZSBjdXJ2YXR1cmUgbGF0ZXJcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xtb2R1bGU6ZWNoYXJ0cy9kYXRhL0dyYXBoLk5vZGV9IG4xXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8bW9kdWxlOmVjaGFydHMvZGF0YS9HcmFwaC5Ob2RlfSBuMlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXNNb2RlbH0gc2VyaWVzTW9kZWxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGtleVxuICovXG5cblxudmFyIGdldEtleU9mRWRnZXMgPSBmdW5jdGlvbiAobjEsIG4yLCBzZXJpZXNNb2RlbCkge1xuICB2YXIgc291cmNlID0gW24xLmlkLCBuMS5kYXRhSW5kZXhdLmpvaW4oJy4nKTtcbiAgdmFyIHRhcmdldCA9IFtuMi5pZCwgbjIuZGF0YUluZGV4XS5qb2luKCcuJyk7XG4gIHJldHVybiBbc2VyaWVzTW9kZWwudWlkLCBzb3VyY2UsIHRhcmdldF0uam9pbihLRVlfREVMSU1JVEVSKTtcbn07XG4vKipcbiAqIGdldCBvcHBvc2l0ZSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG52YXIgZ2V0T3Bwb3NpdGVLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciBrZXlzID0ga2V5LnNwbGl0KEtFWV9ERUxJTUlURVIpO1xuICByZXR1cm4gW2tleXNbMF0sIGtleXNbMl0sIGtleXNbMV1dLmpvaW4oS0VZX0RFTElNSVRFUik7XG59O1xuLyoqXG4gKiBnZXQgZWRnZU1hcCB3aXRoIGtleVxuICogQHBhcmFtIGVkZ2VcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzTW9kZWx9IHNlcmllc01vZGVsXG4gKi9cblxuXG52YXIgZ2V0RWRnZUZyb21NYXAgPSBmdW5jdGlvbiAoZWRnZSwgc2VyaWVzTW9kZWwpIHtcbiAgdmFyIGtleSA9IGdldEtleU9mRWRnZXMoZWRnZS5ub2RlMSwgZWRnZS5ub2RlMiwgc2VyaWVzTW9kZWwpO1xuICByZXR1cm4gc2VyaWVzTW9kZWwuX19lZGdlTWFwW2tleV07XG59O1xuLyoqXG4gKiBjYWxjdWxhdGUgYWxsIGNhc2VzIHRvdGFsIGxlbmd0aFxuICogQHBhcmFtIGVkZ2VcbiAqIEBwYXJhbSBzZXJpZXNNb2RlbFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuXG5cbnZhciBnZXRUb3RhbExlbmd0aEJldHdlZW5Ob2RlcyA9IGZ1bmN0aW9uIChlZGdlLCBzZXJpZXNNb2RlbCkge1xuICB2YXIgbGVuID0gZ2V0RWRnZU1hcExlbmd0aFdpdGhLZXkoZ2V0S2V5T2ZFZGdlcyhlZGdlLm5vZGUxLCBlZGdlLm5vZGUyLCBzZXJpZXNNb2RlbCksIHNlcmllc01vZGVsKTtcbiAgdmFyIGxlblYgPSBnZXRFZGdlTWFwTGVuZ3RoV2l0aEtleShnZXRLZXlPZkVkZ2VzKGVkZ2Uubm9kZTIsIGVkZ2Uubm9kZTEsIHNlcmllc01vZGVsKSwgc2VyaWVzTW9kZWwpO1xuICByZXR1cm4gbGVuICsgbGVuVjtcbn07XG4vKipcbiAqXG4gKiBAcGFyYW0ga2V5XG4gKi9cblxuXG52YXIgZ2V0RWRnZU1hcExlbmd0aFdpdGhLZXkgPSBmdW5jdGlvbiAoa2V5LCBzZXJpZXNNb2RlbCkge1xuICB2YXIgZWRnZU1hcCA9IHNlcmllc01vZGVsLl9fZWRnZU1hcDtcbiAgcmV0dXJuIGVkZ2VNYXBba2V5XSA/IGVkZ2VNYXBba2V5XS5sZW5ndGggOiAwO1xufTtcbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBlZGdlcyBiZXR3ZWVuIHRoZSBzYW1lIHR3byBwb2ludHMsIHVzZWQgdG8gb2J0YWluIHRoZSBjdXJ2YXR1cmUgdGFibGUgYW5kIHRoZSBwYXJpdHkgb2YgdGhlIGVkZ2VcbiAqIEBzZWUgL2dyYXBoL0dyYXBoU2VyaWVzLmpzQGdldEluaXRpYWxEYXRhXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc01vZGVsfSBzZXJpZXNNb2RlbFxuICovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRDdXJ2ZW5lc3NMaXN0KHNlcmllc01vZGVsKSB7XG4gIGlmICghZ2V0QXV0b0N1cnZlbmVzc1BhcmFtcyhzZXJpZXNNb2RlbCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzZXJpZXNNb2RlbC5fX2N1cnZlbmVzc0xpc3QgPSBbXTtcbiAgc2VyaWVzTW9kZWwuX19lZGdlTWFwID0ge307IC8vIGNhbGMgdGhlIGFycmF5IG9mIGN1cnZlbmVzcyBMaXN0XG5cbiAgY3JlYXRlQ3VydmVuZXNzKHNlcmllc01vZGVsKTtcbn1cbi8qKlxuICogc2V0IGVkZ2VNYXAgd2l0aCBrZXlcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xtb2R1bGU6ZWNoYXJ0cy9kYXRhL0dyYXBoLk5vZGV9IG4xXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8bW9kdWxlOmVjaGFydHMvZGF0YS9HcmFwaC5Ob2RlfSBuMlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXNNb2RlbH0gc2VyaWVzTW9kZWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFZGdlTWFwRm9yQ3VydmVuZXNzKG4xLCBuMiwgc2VyaWVzTW9kZWwsIGluZGV4KSB7XG4gIGlmICghZ2V0QXV0b0N1cnZlbmVzc1BhcmFtcyhzZXJpZXNNb2RlbCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIga2V5ID0gZ2V0S2V5T2ZFZGdlcyhuMSwgbjIsIHNlcmllc01vZGVsKTtcbiAgdmFyIGVkZ2VNYXAgPSBzZXJpZXNNb2RlbC5fX2VkZ2VNYXA7XG4gIHZhciBvcHBvc2l0ZUVkZ2VzID0gZWRnZU1hcFtnZXRPcHBvc2l0ZUtleShrZXkpXTsgLy8gc2V0IGRpcmVjdGlvblxuXG4gIGlmIChlZGdlTWFwW2tleV0gJiYgIW9wcG9zaXRlRWRnZXMpIHtcbiAgICBlZGdlTWFwW2tleV0uaXNGb3J3YXJkID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChvcHBvc2l0ZUVkZ2VzICYmIGVkZ2VNYXBba2V5XSkge1xuICAgIG9wcG9zaXRlRWRnZXMuaXNGb3J3YXJkID0gdHJ1ZTtcbiAgICBlZGdlTWFwW2tleV0uaXNGb3J3YXJkID0gZmFsc2U7XG4gIH1cblxuICBlZGdlTWFwW2tleV0gPSBlZGdlTWFwW2tleV0gfHwgW107XG4gIGVkZ2VNYXBba2V5XS5wdXNoKGluZGV4KTtcbn1cbi8qKlxuICogZ2V0IGN1cnZhdHVyZSBmb3IgZWRnZVxuICogQHBhcmFtIGVkZ2VcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzTW9kZWx9IHNlcmllc01vZGVsXG4gKiBAcGFyYW0gaW5kZXhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VydmVuZXNzRm9yRWRnZShlZGdlLCBzZXJpZXNNb2RlbCwgaW5kZXgsIG5lZWRSZXZlcnNlKSB7XG4gIHZhciBhdXRvQ3VydmVuZXNzUGFyYW1zID0gZ2V0QXV0b0N1cnZlbmVzc1BhcmFtcyhzZXJpZXNNb2RlbCk7XG4gIHZhciBpc0FycmF5UGFyYW0gPSB6clV0aWwuaXNBcnJheShhdXRvQ3VydmVuZXNzUGFyYW1zKTtcblxuICBpZiAoIWF1dG9DdXJ2ZW5lc3NQYXJhbXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBlZGdlQXJyYXkgPSBnZXRFZGdlRnJvbU1hcChlZGdlLCBzZXJpZXNNb2RlbCk7XG5cbiAgaWYgKCFlZGdlQXJyYXkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBlZGdlSW5kZXggPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlZGdlQXJyYXlbaV0gPT09IGluZGV4KSB7XG4gICAgICBlZGdlSW5kZXggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9IC8vIGlmIHRvdGFsTGVuIGlzIExvbmdlciBjcmVhdGVDdXJ2ZW5lc3NcblxuXG4gIHZhciB0b3RhbExlbiA9IGdldFRvdGFsTGVuZ3RoQmV0d2Vlbk5vZGVzKGVkZ2UsIHNlcmllc01vZGVsKTtcbiAgY3JlYXRlQ3VydmVuZXNzKHNlcmllc01vZGVsLCB0b3RhbExlbik7XG4gIGVkZ2UubGluZVN0eWxlID0gZWRnZS5saW5lU3R5bGUgfHwge307IC8vIGlmIGlzIG9wcG9zaXRlIGVkZ2UsIG11c3Qgc2V0IGN1cnZlbnNzIHRvIG9wcG9zaXRlIG51bWJlclxuXG4gIHZhciBjdXJLZXkgPSBnZXRLZXlPZkVkZ2VzKGVkZ2Uubm9kZTEsIGVkZ2Uubm9kZTIsIHNlcmllc01vZGVsKTtcbiAgdmFyIGN1cnZlbmVzc0xpc3QgPSBzZXJpZXNNb2RlbC5fX2N1cnZlbmVzc0xpc3Q7IC8vIGlmIHBhc3MgYXJyYXkgbm8gbmVlZCBwYXJpdHlcblxuICB2YXIgcGFyaXR5Q29ycmVjdGlvbiA9IGlzQXJyYXlQYXJhbSA/IDAgOiB0b3RhbExlbiAlIDIgPyAwIDogMTtcblxuICBpZiAoIWVkZ2VBcnJheS5pc0ZvcndhcmQpIHtcbiAgICAvLyB0aGUgb3Bwb3NpdGUgZWRnZSBzaG93IG91dHNpZGVcbiAgICB2YXIgb3Bwb3NpdGVLZXkgPSBnZXRPcHBvc2l0ZUtleShjdXJLZXkpO1xuICAgIHZhciBsZW4gPSBnZXRFZGdlTWFwTGVuZ3RoV2l0aEtleShvcHBvc2l0ZUtleSwgc2VyaWVzTW9kZWwpO1xuICAgIHZhciByZXNWYWx1ZSA9IGN1cnZlbmVzc0xpc3RbZWRnZUluZGV4ICsgbGVuICsgcGFyaXR5Q29ycmVjdGlvbl07IC8vIGlzTmVlZFJldmVyc2UsIHNpbXBsZSwgZm9yY2UgdHlwZSBuZWVkIHJldmVyc2UgdGhlIGN1cnZlbmVzcyBpbiB0aGUganVuY3Rpb24gb2YgdGhlIGZvcndvcmQgYW5kIHRoZSBvcHBvc2l0ZVxuXG4gICAgaWYgKG5lZWRSZXZlcnNlKSB7XG4gICAgICAvLyBzZXQgYXMgYXJyYXkgbWF5IG1ha2UgdGhlIHBhcml0eSBoYW5kbGUgd2l0aCB0aGUgbGVuIG9mIG9wcG9zaXRlXG4gICAgICBpZiAoaXNBcnJheVBhcmFtKSB7XG4gICAgICAgIGlmIChhdXRvQ3VydmVuZXNzUGFyYW1zICYmIGF1dG9DdXJ2ZW5lc3NQYXJhbXNbMF0gPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gKGxlbiArIHBhcml0eUNvcnJlY3Rpb24pICUgMiA/IHJlc1ZhbHVlIDogLXJlc1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAoKGxlbiAlIDIgPyAwIDogMSkgKyBwYXJpdHlDb3JyZWN0aW9uKSAlIDIgPyByZXNWYWx1ZSA6IC1yZXNWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChsZW4gKyBwYXJpdHlDb3JyZWN0aW9uKSAlIDIgPyByZXNWYWx1ZSA6IC1yZXNWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN1cnZlbmVzc0xpc3RbZWRnZUluZGV4ICsgbGVuICsgcGFyaXR5Q29ycmVjdGlvbl07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjdXJ2ZW5lc3NMaXN0W3Bhcml0eUNvcnJlY3Rpb24gKyBlZGdlSW5kZXhdO1xuICB9XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50IH0gZnJvbSAnenJlbmRlci9saWIvY29udGFpbi90ZXh0JztcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWN0b3JDb3JuZXJSYWRpdXMobW9kZWwsIHNoYXBlKSB7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSBtb2RlbC5nZXQoJ2JvcmRlclJhZGl1cycpO1xuXG4gIGlmIChjb3JuZXJSYWRpdXMgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCFpc0FycmF5KGNvcm5lclJhZGl1cykpIHtcbiAgICBjb3JuZXJSYWRpdXMgPSBbY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXNdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpbm5lckNvcm5lclJhZGl1czogcGFyc2VQZXJjZW50KGNvcm5lclJhZGl1c1swXSwgc2hhcGUucjApLFxuICAgIGNvcm5lclJhZGl1czogcGFyc2VQZXJjZW50KGNvcm5lclJhZGl1c1sxXSwgc2hhcGUucilcbiAgfTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5leHBvcnQgZnVuY3Rpb24gcmV0cmlldmVUYXJnZXRJbmZvKHBheWxvYWQsIHZhbGlkUGF5bG9hZFR5cGVzLCBzZXJpZXNNb2RlbCkge1xuICBpZiAocGF5bG9hZCAmJiB6clV0aWwuaW5kZXhPZih2YWxpZFBheWxvYWRUeXBlcywgcGF5bG9hZC50eXBlKSA+PSAwKSB7XG4gICAgdmFyIHJvb3QgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCkudHJlZS5yb290O1xuICAgIHZhciB0YXJnZXROb2RlID0gcGF5bG9hZC50YXJnZXROb2RlO1xuXG4gICAgaWYgKHR5cGVvZiB0YXJnZXROb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgdGFyZ2V0Tm9kZSA9IHJvb3QuZ2V0Tm9kZUJ5SWQodGFyZ2V0Tm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldE5vZGUgJiYgcm9vdC5jb250YWlucyh0YXJnZXROb2RlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogdGFyZ2V0Tm9kZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZUlkID0gcGF5bG9hZC50YXJnZXROb2RlSWQ7XG5cbiAgICBpZiAodGFyZ2V0Tm9kZUlkICE9IG51bGwgJiYgKHRhcmdldE5vZGUgPSByb290LmdldE5vZGVCeUlkKHRhcmdldE5vZGVJZCkpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiB0YXJnZXROb2RlXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSAvLyBOb3QgaW5jbHVkZXMgdGhlIGdpdmVuIG5vZGUgYXQgdGhlIGxhc3QgaXRlbS5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhdGhUb1Jvb3Qobm9kZSkge1xuICB2YXIgcGF0aCA9IFtdO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICBub2RlICYmIHBhdGgucHVzaChub2RlKTtcbiAgfVxuXG4gIHJldHVybiBwYXRoLnJldmVyc2UoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhYm92ZVZpZXdSb290KHZpZXdSb290LCBub2RlKSB7XG4gIHZhciB2aWV3UGF0aCA9IGdldFBhdGhUb1Jvb3Qodmlld1Jvb3QpO1xuICByZXR1cm4genJVdGlsLmluZGV4T2Yodmlld1BhdGgsIG5vZGUpID49IDA7XG59IC8vIEZyb20gcm9vdCB0byB0aGUgaW5wdXQgbm9kZSAodGhlIGlucHV0IG5vZGUgd2lsbCBiZSBpbmNsdWRlZCkuXG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwVHJlZVBhdGhJbmZvKG5vZGUsIHNlcmllc01vZGVsKSB7XG4gIHZhciB0cmVlUGF0aEluZm8gPSBbXTtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIHZhciBub2RlRGF0YUluZGV4ID0gbm9kZS5kYXRhSW5kZXg7XG4gICAgdHJlZVBhdGhJbmZvLnB1c2goe1xuICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgZGF0YUluZGV4OiBub2RlRGF0YUluZGV4LFxuICAgICAgdmFsdWU6IHNlcmllc01vZGVsLmdldFJhd1ZhbHVlKG5vZGVEYXRhSW5kZXgpXG4gICAgfSk7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHRyZWVQYXRoSW5mby5yZXZlcnNlKCk7XG4gIHJldHVybiB0cmVlUGF0aEluZm87XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCBjcmVhdGVMaXN0U2ltcGx5IGZyb20gJy4uL2hlbHBlci9jcmVhdGVMaXN0U2ltcGx5JztcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgZ2V0RGltZW5zaW9uVHlwZUJ5QXhpcyB9IGZyb20gJy4uLy4uL2RhdGEvaGVscGVyL2RpbWVuc2lvbkhlbHBlcic7XG5pbXBvcnQgeyBtYWtlU2VyaWVzRW5jb2RlRm9yQXhpc0Nvb3JkU3lzIH0gZnJvbSAnLi4vLi4vZGF0YS9oZWxwZXIvc291cmNlSGVscGVyJztcblxudmFyIFdoaXNrZXJCb3hDb21tb25NaXhpbiA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdoaXNrZXJCb3hDb21tb25NaXhpbigpIHt9XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBXaGlza2VyQm94Q29tbW9uTWl4aW4ucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIC8vIFdoZW4gYm90aCB0eXBlcyBvZiB4QXhpcyBhbmQgeUF4aXMgYXJlICd2YWx1ZScsIGxheW91dCBpc1xuICAgIC8vIG5lZWRlZCB0byBiZSBzcGVjaWZpZWQgYnkgdXNlci4gT3RoZXJ3aXNlLCBsYXlvdXQgY2FuIGJlXG4gICAgLy8ganVkZ2VkIGJ5IHdoaWNoIGF4aXMgaXMgY2F0ZWdvcnkuXG4gICAgdmFyIG9yZGluYWxNZXRhO1xuICAgIHZhciB4QXhpc01vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ3hBeGlzJywgdGhpcy5nZXQoJ3hBeGlzSW5kZXgnKSk7XG4gICAgdmFyIHlBeGlzTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudCgneUF4aXMnLCB0aGlzLmdldCgneUF4aXNJbmRleCcpKTtcbiAgICB2YXIgeEF4aXNUeXBlID0geEF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgeUF4aXNUeXBlID0geUF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgYWRkT3JkaW5hbDsgLy8gRklYTUVcbiAgICAvLyBDb25zaWRlciB0aW1lIGF4aXMuXG5cbiAgICBpZiAoeEF4aXNUeXBlID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICBvcHRpb24ubGF5b3V0ID0gJ2hvcml6b250YWwnO1xuICAgICAgb3JkaW5hbE1ldGEgPSB4QXhpc01vZGVsLmdldE9yZGluYWxNZXRhKCk7XG4gICAgICBhZGRPcmRpbmFsID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHlBeGlzVHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgb3B0aW9uLmxheW91dCA9ICd2ZXJ0aWNhbCc7XG4gICAgICBvcmRpbmFsTWV0YSA9IHlBeGlzTW9kZWwuZ2V0T3JkaW5hbE1ldGEoKTtcbiAgICAgIGFkZE9yZGluYWwgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb24ubGF5b3V0ID0gb3B0aW9uLmxheW91dCB8fCAnaG9yaXpvbnRhbCc7XG4gICAgfVxuXG4gICAgdmFyIGNvb3JkRGltcyA9IFsneCcsICd5J107XG4gICAgdmFyIGJhc2VBeGlzRGltSW5kZXggPSBvcHRpb24ubGF5b3V0ID09PSAnaG9yaXpvbnRhbCcgPyAwIDogMTtcbiAgICB2YXIgYmFzZUF4aXNEaW0gPSB0aGlzLl9iYXNlQXhpc0RpbSA9IGNvb3JkRGltc1tiYXNlQXhpc0RpbUluZGV4XTtcbiAgICB2YXIgb3RoZXJBeGlzRGltID0gY29vcmREaW1zWzEgLSBiYXNlQXhpc0RpbUluZGV4XTtcbiAgICB2YXIgYXhpc01vZGVscyA9IFt4QXhpc01vZGVsLCB5QXhpc01vZGVsXTtcbiAgICB2YXIgYmFzZUF4aXNUeXBlID0gYXhpc01vZGVsc1tiYXNlQXhpc0RpbUluZGV4XS5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgb3RoZXJBeGlzVHlwZSA9IGF4aXNNb2RlbHNbMSAtIGJhc2VBeGlzRGltSW5kZXhdLmdldCgndHlwZScpO1xuICAgIHZhciBkYXRhID0gb3B0aW9uLmRhdGE7IC8vID8/PyBGSVhNRSBtYWtlIGEgc3RhZ2UgdG8gcGVyZm9ybSBkYXRhIHRyYW5zZnJvbS5cbiAgICAvLyBNVVNUIGNyZWF0ZSBhIG5ldyBkYXRhLCBjb25zaWRlciBzZXRPcHRpb24oe30pIGFnYWluLlxuXG4gICAgaWYgKGRhdGEgJiYgYWRkT3JkaW5hbCkge1xuICAgICAgdmFyIG5ld09wdGlvbkRhdGFfMSA9IFtdO1xuICAgICAgenJVdGlsLmVhY2goZGF0YSwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHZhciBuZXdJdGVtO1xuXG4gICAgICAgIGlmICh6clV0aWwuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgIG5ld0l0ZW0gPSBpdGVtLnNsaWNlKCk7XG4gICAgICAgICAgaXRlbS51bnNoaWZ0KGluZGV4KTtcbiAgICAgICAgfSBlbHNlIGlmICh6clV0aWwuaXNBcnJheShpdGVtLnZhbHVlKSkge1xuICAgICAgICAgIG5ld0l0ZW0gPSBpdGVtLnZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgaXRlbS52YWx1ZS51bnNoaWZ0KGluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdJdGVtID0gaXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld09wdGlvbkRhdGFfMS5wdXNoKG5ld0l0ZW0pO1xuICAgICAgfSk7XG4gICAgICBvcHRpb24uZGF0YSA9IG5ld09wdGlvbkRhdGFfMTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFZhbHVlRGltZW5zaW9ucyA9IHRoaXMuZGVmYXVsdFZhbHVlRGltZW5zaW9ucztcbiAgICB2YXIgY29vcmREaW1lbnNpb25zID0gW3tcbiAgICAgIG5hbWU6IGJhc2VBeGlzRGltLFxuICAgICAgdHlwZTogZ2V0RGltZW5zaW9uVHlwZUJ5QXhpcyhiYXNlQXhpc1R5cGUpLFxuICAgICAgb3JkaW5hbE1ldGE6IG9yZGluYWxNZXRhLFxuICAgICAgb3RoZXJEaW1zOiB7XG4gICAgICAgIHRvb2x0aXA6IGZhbHNlLFxuICAgICAgICBpdGVtTmFtZTogMFxuICAgICAgfSxcbiAgICAgIGRpbXNEZWY6IFsnYmFzZSddXG4gICAgfSwge1xuICAgICAgbmFtZTogb3RoZXJBeGlzRGltLFxuICAgICAgdHlwZTogZ2V0RGltZW5zaW9uVHlwZUJ5QXhpcyhvdGhlckF4aXNUeXBlKSxcbiAgICAgIGRpbXNEZWY6IGRlZmF1bHRWYWx1ZURpbWVuc2lvbnMuc2xpY2UoKVxuICAgIH1dO1xuICAgIHJldHVybiBjcmVhdGVMaXN0U2ltcGx5KHRoaXMsIHtcbiAgICAgIGNvb3JkRGltZW5zaW9uczogY29vcmREaW1lbnNpb25zLFxuICAgICAgZGltZW5zaW9uc0NvdW50OiBkZWZhdWx0VmFsdWVEaW1lbnNpb25zLmxlbmd0aCArIDEsXG4gICAgICBlbmNvZGVEZWZhdWx0ZXI6IHpyVXRpbC5jdXJyeShtYWtlU2VyaWVzRW5jb2RlRm9yQXhpc0Nvb3JkU3lzLCBjb29yZERpbWVuc2lvbnMsIHRoaXMpXG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBJZiBob3Jpem9udGFsLCBiYXNlIGF4aXMgaXMgeCwgb3RoZXJ3aXNlIHkuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIFdoaXNrZXJCb3hDb21tb25NaXhpbi5wcm90b3R5cGUuZ2V0QmFzZUF4aXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRpbSA9IHRoaXMuX2Jhc2VBeGlzRGltO1xuICAgIHJldHVybiB0aGlzLmVjTW9kZWwuZ2V0Q29tcG9uZW50KGRpbSArICdBeGlzJywgdGhpcy5nZXQoZGltICsgJ0F4aXNJbmRleCcpKS5heGlzO1xuICB9O1xuXG4gIHJldHVybiBXaGlza2VyQm94Q29tbW9uTWl4aW47XG59KCk7XG5cbjtcbmV4cG9ydCB7IFdoaXNrZXJCb3hDb21tb25NaXhpbiB9OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBjcmVhdGVMaXN0RnJvbUFycmF5IGZyb20gJy4uL2hlbHBlci9jcmVhdGVMaXN0RnJvbUFycmF5JztcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9TZXJpZXMnO1xuXG52YXIgTGluZVNlcmllc01vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKExpbmVTZXJpZXNNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBMaW5lU2VyaWVzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gTGluZVNlcmllc01vZGVsLnR5cGU7XG4gICAgX3RoaXMuaGFzU3ltYm9sVmlzdWFsID0gdHJ1ZTtcbiAgICBfdGhpcy5sZWdlbmRTeW1ib2wgPSAnbGluZSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgTGluZVNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YSA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGNvb3JkU3lzID0gb3B0aW9uLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICAgIGlmIChjb29yZFN5cyAhPT0gJ3BvbGFyJyAmJiBjb29yZFN5cyAhPT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmUgbm90IHN1cHBvcnQgY29vcmRpbmF0ZVN5c3RlbSBiZXNpZGVzIGNhcnRlc2lhbiBhbmQgcG9sYXInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlTGlzdEZyb21BcnJheSh0aGlzLmdldFNvdXJjZSgpLCB0aGlzLCB7XG4gICAgICB1c2VFbmNvZGVEZWZhdWx0ZXI6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICBMaW5lU2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMubGluZSc7XG4gIExpbmVTZXJpZXNNb2RlbC5kZXBlbmRlbmNpZXMgPSBbJ2dyaWQnLCAncG9sYXInXTtcbiAgTGluZVNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDMsXG4gICAgY29vcmRpbmF0ZVN5c3RlbTogJ2NhcnRlc2lhbjJkJyxcbiAgICBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG4gICAgY2xpcDogdHJ1ZSxcbiAgICBsYWJlbDoge1xuICAgICAgcG9zaXRpb246ICd0b3AnXG4gICAgfSxcbiAgICBlbmRMYWJlbDoge1xuICAgICAgc2hvdzogZmFsc2UsXG4gICAgICB2YWx1ZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgIGRpc3RhbmNlOiA4XG4gICAgfSxcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIHdpZHRoOiAyLFxuICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIHNjYWxlOiB0cnVlLFxuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiAnYm9sZGVyJ1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gYXJlYVN0eWxlOiB7XG4gICAgLy8gb3JpZ2luIG9mIGFyZWFTdHlsZS4gVmFsaWQgdmFsdWVzOlxuICAgIC8vIGAnYXV0bycvbnVsbC91bmRlZmluZWRgOiBmcm9tIGF4aXNMaW5lIHRvIGRhdGFcbiAgICAvLyBgJ3N0YXJ0J2A6IGZyb20gbWluIHRvIGRhdGFcbiAgICAvLyBgJ2VuZCdgOiBmcm9tIGRhdGEgdG8gbWF4XG4gICAgLy8gb3JpZ2luOiAnYXV0bydcbiAgICAvLyB9LFxuICAgIC8vIGZhbHNlLCAnc3RhcnQnLCAnZW5kJywgJ21pZGRsZSdcbiAgICBzdGVwOiBmYWxzZSxcbiAgICAvLyBEaXNhYmxlZCBpZiBzdGVwIGlzIHRydWVcbiAgICBzbW9vdGg6IGZhbHNlLFxuICAgIHNtb290aE1vbm90b25lOiBudWxsLFxuICAgIHN5bWJvbDogJ2VtcHR5Q2lyY2xlJyxcbiAgICBzeW1ib2xTaXplOiA0LFxuICAgIHN5bWJvbFJvdGF0ZTogbnVsbCxcbiAgICBzaG93U3ltYm9sOiB0cnVlLFxuICAgIC8vIGBmYWxzZWA6IGZvbGxvdyB0aGUgbGFiZWwgaW50ZXJ2YWwgc3RyYXRlZ3kuXG4gICAgLy8gYHRydWVgOiBzaG93IGFsbCBzeW1ib2xzLlxuICAgIC8vIGAnYXV0bydgOiBJZiBwb3NzaWJsZSwgc2hvdyBhbGwgc3ltYm9scywgb3RoZXJ3aXNlXG4gICAgLy8gICAgICAgICAgIGZvbGxvdyB0aGUgbGFiZWwgaW50ZXJ2YWwgc3RyYXRlZ3kuXG4gICAgc2hvd0FsbFN5bWJvbDogJ2F1dG8nLFxuICAgIC8vIFdoZXRoZXIgdG8gY29ubmVjdCBicmVhayBwb2ludC5cbiAgICBjb25uZWN0TnVsbHM6IGZhbHNlLFxuICAgIC8vIFNhbXBsaW5nIGZvciBsYXJnZSBkYXRhLiBDYW4gYmU6ICdhdmVyYWdlJywgJ21heCcsICdtaW4nLCAnc3VtJywgJ2x0dGInLlxuICAgIHNhbXBsaW5nOiAnbm9uZScsXG4gICAgYW5pbWF0aW9uRWFzaW5nOiAnbGluZWFyJyxcbiAgICAvLyBEaXNhYmxlIHByb2dyZXNzaXZlXG4gICAgcHJvZ3Jlc3NpdmU6IDAsXG4gICAgaG92ZXJMYXllclRocmVzaG9sZDogSW5maW5pdHlcbiAgfTtcbiAgcmV0dXJuIExpbmVTZXJpZXNNb2RlbDtcbn0oU2VyaWVzTW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBMaW5lU2VyaWVzTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiOyAvLyBGSVhNRSBzdGVwIG5vdCBzdXBwb3J0IHBvbGFyXG5cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IFN5bWJvbERyYXcgZnJvbSAnLi4vaGVscGVyL1N5bWJvbERyYXcnO1xuaW1wb3J0IFN5bWJvbENseiBmcm9tICcuLi9oZWxwZXIvU3ltYm9sJztcbmltcG9ydCBsaW5lQW5pbWF0aW9uRGlmZiBmcm9tICcuL2xpbmVBbmltYXRpb25EaWZmJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCAqIGFzIG1vZGVsVXRpbCBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbmltcG9ydCB7IEVDUG9seWxpbmUsIEVDUG9seWdvbiB9IGZyb20gJy4vcG9seSc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ2hhcnQnO1xuaW1wb3J0IHsgcHJlcGFyZURhdGFDb29yZEluZm8sIGdldFN0YWNrZWRPblBvaW50IH0gZnJvbSAnLi9oZWxwZXInO1xuaW1wb3J0IHsgY3JlYXRlR3JpZENsaXBQYXRoLCBjcmVhdGVQb2xhckNsaXBQYXRoIH0gZnJvbSAnLi4vaGVscGVyL2NyZWF0ZUNsaXBQYXRoRnJvbUNvb3JkU3lzJztcbmltcG9ydCB7IGlzQ29vcmRpbmF0ZVN5c3RlbVR5cGUgfSBmcm9tICcuLi8uLi9jb29yZC9Db29yZGluYXRlU3lzdGVtJztcbmltcG9ydCB7IHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbCwgc2V0U3RhdGVzRmxhZywgZW5hYmxlSG92ZXJFbXBoYXNpcyB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdGVzJztcbmltcG9ydCB7IHNldExhYmVsU3R5bGUsIGdldExhYmVsU3RhdGVzTW9kZWxzLCBsYWJlbElubmVyIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZSc7XG5pbXBvcnQgeyBnZXREZWZhdWx0TGFiZWwsIGdldERlZmF1bHRJbnRlcnBvbGF0ZWRMYWJlbCB9IGZyb20gJy4uL2hlbHBlci9sYWJlbEhlbHBlcic7XG5pbXBvcnQgeyBnZXRFQ0RhdGEgfSBmcm9tICcuLi8uLi91dGlsL2lubmVyU3RvcmUnO1xuaW1wb3J0IHsgY3JlYXRlRmxvYXQzMkFycmF5IH0gZnJvbSAnLi4vLi4vdXRpbC92ZW5kb3InO1xuaW1wb3J0IHsgY29udmVydFRvQ29sb3JTdHJpbmcgfSBmcm9tICcuLi8uLi91dGlsL2Zvcm1hdCc7XG5cbmZ1bmN0aW9uIGlzUG9pbnRzU2FtZShwb2ludHMxLCBwb2ludHMyKSB7XG4gIGlmIChwb2ludHMxLmxlbmd0aCAhPT0gcG9pbnRzMi5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50czEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocG9pbnRzMVtpXSAhPT0gcG9pbnRzMltpXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBiYm94RnJvbVBvaW50cyhwb2ludHMpIHtcbiAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgdmFyIG1pblkgPSBJbmZpbml0eTtcbiAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gIHZhciBtYXhZID0gLUluZmluaXR5O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDspIHtcbiAgICB2YXIgeCA9IHBvaW50c1tpKytdO1xuICAgIHZhciB5ID0gcG9pbnRzW2krK107XG5cbiAgICBpZiAoIWlzTmFOKHgpKSB7XG4gICAgICBtaW5YID0gTWF0aC5taW4oeCwgbWluWCk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgoeCwgbWF4WCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc05hTih5KSkge1xuICAgICAgbWluWSA9IE1hdGgubWluKHksIG1pblkpO1xuICAgICAgbWF4WSA9IE1hdGgubWF4KHksIG1heFkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbW21pblgsIG1pblldLCBbbWF4WCwgbWF4WV1dO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0RpZmYocG9pbnRzMSwgcG9pbnRzMikge1xuICB2YXIgX2EgPSBiYm94RnJvbVBvaW50cyhwb2ludHMxKSxcbiAgICAgIG1pbjEgPSBfYVswXSxcbiAgICAgIG1heDEgPSBfYVsxXTtcblxuICB2YXIgX2IgPSBiYm94RnJvbVBvaW50cyhwb2ludHMyKSxcbiAgICAgIG1pbjIgPSBfYlswXSxcbiAgICAgIG1heDIgPSBfYlsxXTsgLy8gR2V0IGEgbWF4IHZhbHVlIGZyb20gZWFjaCBjb3JuZXIgb2YgdHdvIGJvdW5kaW5ncy5cblxuXG4gIHJldHVybiBNYXRoLm1heChNYXRoLmFicyhtaW4xWzBdIC0gbWluMlswXSksIE1hdGguYWJzKG1pbjFbMV0gLSBtaW4yWzFdKSwgTWF0aC5hYnMobWF4MVswXSAtIG1heDJbMF0pLCBNYXRoLmFicyhtYXgxWzFdIC0gbWF4MlsxXSkpO1xufVxuXG5mdW5jdGlvbiBnZXRTbW9vdGgoc21vb3RoKSB7XG4gIHJldHVybiB0eXBlb2Ygc21vb3RoID09PSAnbnVtYmVyJyA/IHNtb290aCA6IHNtb290aCA/IDAuNSA6IDA7XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrZWRPblBvaW50cyhjb29yZFN5cywgZGF0YSwgZGF0YUNvb3JkSW5mbykge1xuICBpZiAoIWRhdGFDb29yZEluZm8udmFsdWVEaW0pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbGVuID0gZGF0YS5jb3VudCgpO1xuICB2YXIgcG9pbnRzID0gY3JlYXRlRmxvYXQzMkFycmF5KGxlbiAqIDIpO1xuXG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICB2YXIgcHQgPSBnZXRTdGFja2VkT25Qb2ludChkYXRhQ29vcmRJbmZvLCBjb29yZFN5cywgZGF0YSwgaWR4KTtcbiAgICBwb2ludHNbaWR4ICogMl0gPSBwdFswXTtcbiAgICBwb2ludHNbaWR4ICogMiArIDFdID0gcHRbMV07XG4gIH1cblxuICByZXR1cm4gcG9pbnRzO1xufVxuXG5mdW5jdGlvbiB0dXJuUG9pbnRzSW50b1N0ZXAocG9pbnRzLCBjb29yZFN5cywgc3RlcFR1cm5BdCkge1xuICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICB2YXIgYmFzZUluZGV4ID0gYmFzZUF4aXMuZGltID09PSAneCcgfHwgYmFzZUF4aXMuZGltID09PSAncmFkaXVzJyA/IDAgOiAxO1xuICB2YXIgc3RlcFBvaW50cyA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBzdGVwUHQgPSBbXTtcbiAgdmFyIHB0ID0gW107XG4gIHZhciBuZXh0UHQgPSBbXTtcblxuICBmb3IgKDsgaSA8IHBvaW50cy5sZW5ndGggLSAyOyBpICs9IDIpIHtcbiAgICBuZXh0UHRbMF0gPSBwb2ludHNbaSArIDJdO1xuICAgIG5leHRQdFsxXSA9IHBvaW50c1tpICsgM107XG4gICAgcHRbMF0gPSBwb2ludHNbaV07XG4gICAgcHRbMV0gPSBwb2ludHNbaSArIDFdO1xuICAgIHN0ZXBQb2ludHMucHVzaChwdFswXSwgcHRbMV0pO1xuXG4gICAgc3dpdGNoIChzdGVwVHVybkF0KSB7XG4gICAgICBjYXNlICdlbmQnOlxuICAgICAgICBzdGVwUHRbYmFzZUluZGV4XSA9IG5leHRQdFtiYXNlSW5kZXhdO1xuICAgICAgICBzdGVwUHRbMSAtIGJhc2VJbmRleF0gPSBwdFsxIC0gYmFzZUluZGV4XTtcbiAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdFswXSwgc3RlcFB0WzFdKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgIHZhciBtaWRkbGUgPSAocHRbYmFzZUluZGV4XSArIG5leHRQdFtiYXNlSW5kZXhdKSAvIDI7XG4gICAgICAgIHZhciBzdGVwUHQyID0gW107XG4gICAgICAgIHN0ZXBQdFtiYXNlSW5kZXhdID0gc3RlcFB0MltiYXNlSW5kZXhdID0gbWlkZGxlO1xuICAgICAgICBzdGVwUHRbMSAtIGJhc2VJbmRleF0gPSBwdFsxIC0gYmFzZUluZGV4XTtcbiAgICAgICAgc3RlcFB0MlsxIC0gYmFzZUluZGV4XSA9IG5leHRQdFsxIC0gYmFzZUluZGV4XTtcbiAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdFswXSwgc3RlcFB0WzFdKTtcbiAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdDJbMF0sIHN0ZXBQdDJbMV0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gZGVmYXVsdCBpcyBzdGFydFxuICAgICAgICBzdGVwUHRbYmFzZUluZGV4XSA9IHB0W2Jhc2VJbmRleF07XG4gICAgICAgIHN0ZXBQdFsxIC0gYmFzZUluZGV4XSA9IG5leHRQdFsxIC0gYmFzZUluZGV4XTtcbiAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdFswXSwgc3RlcFB0WzFdKTtcbiAgICB9XG4gIH0gLy8gTGFzdCBwb2ludHNcblxuXG4gIHN0ZXBQb2ludHMucHVzaChwb2ludHNbaSsrXSwgcG9pbnRzW2krK10pO1xuICByZXR1cm4gc3RlcFBvaW50cztcbn1cblxuZnVuY3Rpb24gZ2V0VmlzdWFsR3JhZGllbnQoZGF0YSwgY29vcmRTeXMpIHtcbiAgdmFyIHZpc3VhbE1ldGFMaXN0ID0gZGF0YS5nZXRWaXN1YWwoJ3Zpc3VhbE1ldGEnKTtcblxuICBpZiAoIXZpc3VhbE1ldGFMaXN0IHx8ICF2aXN1YWxNZXRhTGlzdC5sZW5ndGggfHwgIWRhdGEuY291bnQoKSkge1xuICAgIC8vIFdoZW4gZGF0YS5jb3VudCgpIGlzIDAsIGdyYWRpZW50IHJhbmdlIGNhbiBub3QgYmUgY2FsY3VsYXRlZC5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29vcmRTeXMudHlwZSAhPT0gJ2NhcnRlc2lhbjJkJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Zpc3VhbCBtYXAgb24gbGluZSBzdHlsZSBpcyBvbmx5IHN1cHBvcnRlZCBvbiBjYXJ0ZXNpYW4yZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29vcmREaW07XG4gIHZhciB2aXN1YWxNZXRhO1xuXG4gIGZvciAodmFyIGkgPSB2aXN1YWxNZXRhTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBkaW1JbmRleCA9IHZpc3VhbE1ldGFMaXN0W2ldLmRpbWVuc2lvbjtcbiAgICB2YXIgZGltTmFtZSA9IGRhdGEuZGltZW5zaW9uc1tkaW1JbmRleF07XG4gICAgdmFyIGRpbUluZm8gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oZGltTmFtZSk7XG4gICAgY29vcmREaW0gPSBkaW1JbmZvICYmIGRpbUluZm8uY29vcmREaW07IC8vIENhbiBvbmx5IGJlIHggb3IgeVxuXG4gICAgaWYgKGNvb3JkRGltID09PSAneCcgfHwgY29vcmREaW0gPT09ICd5Jykge1xuICAgICAgdmlzdWFsTWV0YSA9IHZpc3VhbE1ldGFMaXN0W2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF2aXN1YWxNZXRhKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUud2FybignVmlzdWFsIG1hcCBvbiBsaW5lIHN0eWxlIG9ubHkgc3VwcG9ydCB4IG9yIHkgZGltZW5zaW9uLicpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSAvLyBJZiB0aGUgYXJlYSB0byBiZSByZW5kZXJlZCBpcyBiaWdnZXIgdGhhbiBhcmVhIGRlZmluZWQgYnkgTGluZWFyR3JhZGllbnQsXG4gIC8vIHRoZSBjYW52YXMgc3BlYyBwcmVzY3JpYmVzIHRoYXQgdGhlIGNvbG9yIG9mIHRoZSBmaXJzdCBzdG9wIGFuZCB0aGUgbGFzdFxuICAvLyBzdG9wIHNob3VsZCBiZSB1c2VkLiBCdXQgaWYgdHdvIHN0b3BzIGFyZSBhZGRlZCBhdCBvZmZzZXQgMCwgaW4gZWZmZWN0XG4gIC8vIGJyb3dzZXJzIHVzZSB0aGUgY29sb3Igb2YgdGhlIHNlY29uZCBzdG9wIHRvIHJlbmRlciBhcmVhIG91dHNpZGVcbiAgLy8gTGluZWFyR3JhZGllbnQuIFNvIHdlIGNhbiBvbmx5IGluZmluaXRlc2ltYWxseSBleHRlbmQgYXJlYSBkZWZpbmVkIGluXG4gIC8vIExpbmVhckdyYWRpZW50IHRvIHJlbmRlciBgb3V0ZXJDb2xvcnNgLlxuXG5cbiAgdmFyIGF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKGNvb3JkRGltKTsgLy8gZGF0YVRvQ29vciBtYXBwaW5nIG1heSBub3QgYmUgbGluZWFyLCBidXQgbXVzdCBiZSBtb25vdG9uaWMuXG5cbiAgdmFyIGNvbG9yU3RvcHMgPSB6clV0aWwubWFwKHZpc3VhbE1ldGEuc3RvcHMsIGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIGNvb3JkOiBheGlzLnRvR2xvYmFsQ29vcmQoYXhpcy5kYXRhVG9Db29yZChzdG9wLnZhbHVlKSksXG4gICAgICBjb2xvcjogc3RvcC5jb2xvclxuICAgIH07XG4gIH0pO1xuICB2YXIgc3RvcExlbiA9IGNvbG9yU3RvcHMubGVuZ3RoO1xuICB2YXIgb3V0ZXJDb2xvcnMgPSB2aXN1YWxNZXRhLm91dGVyQ29sb3JzLnNsaWNlKCk7XG5cbiAgaWYgKHN0b3BMZW4gJiYgY29sb3JTdG9wc1swXS5jb29yZCA+IGNvbG9yU3RvcHNbc3RvcExlbiAtIDFdLmNvb3JkKSB7XG4gICAgY29sb3JTdG9wcy5yZXZlcnNlKCk7XG4gICAgb3V0ZXJDb2xvcnMucmV2ZXJzZSgpO1xuICB9XG5cbiAgdmFyIHRpbnlFeHRlbnQgPSAxMDsgLy8gQXJiaXRyYXJ5IHZhbHVlOiAxMHB4XG5cbiAgdmFyIG1pbkNvb3JkID0gY29sb3JTdG9wc1swXS5jb29yZCAtIHRpbnlFeHRlbnQ7XG4gIHZhciBtYXhDb29yZCA9IGNvbG9yU3RvcHNbc3RvcExlbiAtIDFdLmNvb3JkICsgdGlueUV4dGVudDtcbiAgdmFyIGNvb3JkU3BhbiA9IG1heENvb3JkIC0gbWluQ29vcmQ7XG5cbiAgaWYgKGNvb3JkU3BhbiA8IDFlLTMpIHtcbiAgICByZXR1cm4gJ3RyYW5zcGFyZW50JztcbiAgfVxuXG4gIHpyVXRpbC5lYWNoKGNvbG9yU3RvcHMsIGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgc3RvcC5vZmZzZXQgPSAoc3RvcC5jb29yZCAtIG1pbkNvb3JkKSAvIGNvb3JkU3BhbjtcbiAgfSk7XG4gIGNvbG9yU3RvcHMucHVzaCh7XG4gICAgb2Zmc2V0OiBzdG9wTGVuID8gY29sb3JTdG9wc1tzdG9wTGVuIC0gMV0ub2Zmc2V0IDogMC41LFxuICAgIGNvbG9yOiBvdXRlckNvbG9yc1sxXSB8fCAndHJhbnNwYXJlbnQnXG4gIH0pO1xuICBjb2xvclN0b3BzLnVuc2hpZnQoe1xuICAgIG9mZnNldDogc3RvcExlbiA/IGNvbG9yU3RvcHNbMF0ub2Zmc2V0IDogMC41LFxuICAgIGNvbG9yOiBvdXRlckNvbG9yc1swXSB8fCAndHJhbnNwYXJlbnQnXG4gIH0pOyAvLyB6clV0aWwuZWFjaChjb2xvclN0b3BzLCBmdW5jdGlvbiAoY29sb3JTdG9wKSB7XG4gIC8vICAgICAvLyBNYWtlIHN1cmUgZWFjaCBvZmZzZXQgaGFzIHJvdW5kZWQgcHggdG8gYXZvaWQgbm90IHNoYXJwIGVkZ2VcbiAgLy8gICAgIGNvbG9yU3RvcC5vZmZzZXQgPSAoTWF0aC5yb3VuZChjb2xvclN0b3Aub2Zmc2V0ICogKGVuZCAtIHN0YXJ0KSArIHN0YXJ0KSAtIHN0YXJ0KSAvIChlbmQgLSBzdGFydCk7XG4gIC8vIH0pO1xuXG4gIHZhciBncmFkaWVudCA9IG5ldyBncmFwaGljLkxpbmVhckdyYWRpZW50KDAsIDAsIDAsIDAsIGNvbG9yU3RvcHMsIHRydWUpO1xuICBncmFkaWVudFtjb29yZERpbV0gPSBtaW5Db29yZDtcbiAgZ3JhZGllbnRbY29vcmREaW0gKyAnMiddID0gbWF4Q29vcmQ7XG4gIHJldHVybiBncmFkaWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0SXNJZ25vcmVGdW5jKHNlcmllc01vZGVsLCBkYXRhLCBjb29yZFN5cykge1xuICB2YXIgc2hvd0FsbFN5bWJvbCA9IHNlcmllc01vZGVsLmdldCgnc2hvd0FsbFN5bWJvbCcpO1xuICB2YXIgaXNBdXRvID0gc2hvd0FsbFN5bWJvbCA9PT0gJ2F1dG8nO1xuXG4gIGlmIChzaG93QWxsU3ltYm9sICYmICFpc0F1dG8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2F0ZWdvcnlBeGlzID0gY29vcmRTeXMuZ2V0QXhlc0J5U2NhbGUoJ29yZGluYWwnKVswXTtcblxuICBpZiAoIWNhdGVnb3J5QXhpcykge1xuICAgIHJldHVybjtcbiAgfSAvLyBOb3RlIHRoYXQgY2F0ZWdvcnkgbGFiZWwgaW50ZXJ2YWwgc3RyYXRlZ3kgbWlnaHQgYnJpbmcgc29tZSB3ZWlyZCBlZmZlY3RcbiAgLy8gaW4gc29tZSBzY2VuYXJpbzogdXNlcnMgbWF5IHdvbmRlciB3aHkgc29tZSBvZiB0aGUgc3ltYm9scyBhcmUgbm90XG4gIC8vIGRpc3BsYXllZC4gU28gd2Ugc2hvdyBhbGwgc3ltYm9scyBhcyBwb3NzaWJsZSBhcyB3ZSBjYW4uXG5cblxuICBpZiAoaXNBdXRvIC8vIFNpbXBsaWZ5IHRoZSBsb2dpYywgZG8gbm90IGRldGVybWluZSBsYWJlbCBvdmVybGFwIGhlcmUuXG4gICYmIGNhblNob3dBbGxTeW1ib2xGb3JDYXRlZ29yeShjYXRlZ29yeUF4aXMsIGRhdGEpKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE90aGVyd2lzZSBmb2xsb3cgdGhlIGxhYmVsIGludGVydmFsIHN0cmF0ZWd5IG9uIGNhdGVnb3J5IGF4aXMuXG5cblxuICB2YXIgY2F0ZWdvcnlEYXRhRGltID0gZGF0YS5tYXBEaW1lbnNpb24oY2F0ZWdvcnlBeGlzLmRpbSk7XG4gIHZhciBsYWJlbE1hcCA9IHt9O1xuICB6clV0aWwuZWFjaChjYXRlZ29yeUF4aXMuZ2V0Vmlld0xhYmVscygpLCBmdW5jdGlvbiAobGFiZWxJdGVtKSB7XG4gICAgdmFyIG9yZGluYWxOdW1iZXIgPSBjYXRlZ29yeUF4aXMuc2NhbGUuZ2V0UmF3T3JkaW5hbE51bWJlcihsYWJlbEl0ZW0udGlja1ZhbHVlKTtcbiAgICBsYWJlbE1hcFtvcmRpbmFsTnVtYmVyXSA9IDE7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgIHJldHVybiAhbGFiZWxNYXAuaGFzT3duUHJvcGVydHkoZGF0YS5nZXQoY2F0ZWdvcnlEYXRhRGltLCBkYXRhSW5kZXgpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FuU2hvd0FsbFN5bWJvbEZvckNhdGVnb3J5KGNhdGVnb3J5QXhpcywgZGF0YSkge1xuICAvLyBJbiBtb3NlIGNhc2VzLCBsaW5lIGlzIG1vbm90b25vdXMgb24gY2F0ZWdvcnkgYXhpcywgYW5kIHRoZSBsYWJlbCBzaXplXG4gIC8vIGlzIGNsb3NlIHdpdGggZWFjaCBvdGhlci4gU28gd2UgY2hlY2sgdGhlIHN5bWJvbCBzaXplIGFuZCBzb21lIG9mIHRoZVxuICAvLyBsYWJlbCBzaXplIGFsb25lIHdpdGggdGhlIGNhdGVnb3J5IGF4aXMgdG8gZXN0aW1hdGUgd2hldGhlciBhbGwgc3ltYm9sXG4gIC8vIGNhbiBiZSBzaG93biB3aXRob3V0IG92ZXJsYXAuXG4gIHZhciBheGlzRXh0ZW50ID0gY2F0ZWdvcnlBeGlzLmdldEV4dGVudCgpO1xuICB2YXIgYXZhaWxTaXplID0gTWF0aC5hYnMoYXhpc0V4dGVudFsxXSAtIGF4aXNFeHRlbnRbMF0pIC8gY2F0ZWdvcnlBeGlzLnNjYWxlLmNvdW50KCk7XG4gIGlzTmFOKGF2YWlsU2l6ZSkgJiYgKGF2YWlsU2l6ZSA9IDApOyAvLyAwLzAgaXMgTmFOLlxuICAvLyBTYW1wbGluZyBzb21lIHBvaW50cywgbWF4IDUuXG5cbiAgdmFyIGRhdGFMZW4gPSBkYXRhLmNvdW50KCk7XG4gIHZhciBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChkYXRhTGVuIC8gNSkpO1xuXG4gIGZvciAodmFyIGRhdGFJbmRleCA9IDA7IGRhdGFJbmRleCA8IGRhdGFMZW47IGRhdGFJbmRleCArPSBzdGVwKSB7XG4gICAgaWYgKFN5bWJvbENsei5nZXRTeW1ib2xTaXplKGRhdGEsIGRhdGFJbmRleCAvLyBPbmx5IGZvciBjYXJ0ZXNpYW4sIHdoZXJlIGBpc0hvcml6b250YWxgIGV4aXN0cy5cbiAgICApW2NhdGVnb3J5QXhpcy5pc0hvcml6b250YWwoKSA/IDEgOiAwXSAvLyBFbXBpcmljYWwgbnVtYmVyXG4gICAgKiAxLjUgPiBhdmFpbFNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNQb2ludE51bGwoeCwgeSkge1xuICByZXR1cm4gaXNOYU4oeCkgfHwgaXNOYU4oeSk7XG59XG5cbmZ1bmN0aW9uIGdldExhc3RJbmRleE5vdE51bGwocG9pbnRzKSB7XG4gIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoIC8gMjtcblxuICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICBpZiAoIWlzUG9pbnROdWxsKHBvaW50c1tsZW4gKiAyIC0gMl0sIHBvaW50c1tsZW4gKiAyIC0gMV0pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGVuIC0gMTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9pbnRBdEluZGV4KHBvaW50cywgaWR4KSB7XG4gIHJldHVybiBbcG9pbnRzW2lkeCAqIDJdLCBwb2ludHNbaWR4ICogMiArIDFdXTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhSYW5nZShwb2ludHMsIHhPclksIGRpbSkge1xuICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gIHZhciBkaW1JZHggPSBkaW0gPT09ICd4JyA/IDAgOiAxO1xuICB2YXIgYTtcbiAgdmFyIGI7XG4gIHZhciBwcmV2SW5kZXggPSAwO1xuICB2YXIgbmV4dEluZGV4ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGIgPSBwb2ludHNbaSAqIDIgKyBkaW1JZHhdO1xuXG4gICAgaWYgKGlzTmFOKGIpIHx8IGlzTmFOKHBvaW50c1tpICogMiArIDEgLSBkaW1JZHhdKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGEgPSBiO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGEgPD0geE9yWSAmJiBiID49IHhPclkgfHwgYSA+PSB4T3JZICYmIGIgPD0geE9yWSkge1xuICAgICAgbmV4dEluZGV4ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHByZXZJbmRleCA9IGk7XG4gICAgYSA9IGI7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJhbmdlOiBbcHJldkluZGV4LCBuZXh0SW5kZXhdLFxuICAgIHQ6ICh4T3JZIC0gYSkgLyAoYiAtIGEpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmVDbGlwUGF0aChsaW5lVmlldywgY29vcmRTeXMsIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwpIHtcbiAgaWYgKGlzQ29vcmRpbmF0ZVN5c3RlbVR5cGUoY29vcmRTeXMsICdjYXJ0ZXNpYW4yZCcpKSB7XG4gICAgdmFyIGVuZExhYmVsTW9kZWxfMSA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdlbmRMYWJlbCcpO1xuICAgIHZhciBzaG93RW5kTGFiZWwgPSBlbmRMYWJlbE1vZGVsXzEuZ2V0KCdzaG93Jyk7XG4gICAgdmFyIHZhbHVlQW5pbWF0aW9uXzEgPSBlbmRMYWJlbE1vZGVsXzEuZ2V0KCd2YWx1ZUFuaW1hdGlvbicpO1xuICAgIHZhciBkYXRhXzEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGxhYmVsQW5pbWF0aW9uUmVjb3JkXzEgPSB7XG4gICAgICBsYXN0RnJhbWVJbmRleDogMFxuICAgIH07XG4gICAgdmFyIGR1cmluZyA9IHNob3dFbmRMYWJlbCA/IGZ1bmN0aW9uIChwZXJjZW50LCBjbGlwUmVjdCkge1xuICAgICAgbGluZVZpZXcuX2VuZExhYmVsT25EdXJpbmcocGVyY2VudCwgY2xpcFJlY3QsIGRhdGFfMSwgbGFiZWxBbmltYXRpb25SZWNvcmRfMSwgdmFsdWVBbmltYXRpb25fMSwgZW5kTGFiZWxNb2RlbF8xLCBjb29yZFN5cyk7XG4gICAgfSA6IG51bGw7XG4gICAgdmFyIGlzSG9yaXpvbnRhbCA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCkuaXNIb3Jpem9udGFsKCk7XG4gICAgdmFyIGNsaXBQYXRoID0gY3JlYXRlR3JpZENsaXBQYXRoKGNvb3JkU3lzLCBoYXNBbmltYXRpb24sIHNlcmllc01vZGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZW5kTGFiZWwgPSBsaW5lVmlldy5fZW5kTGFiZWw7XG5cbiAgICAgIGlmIChlbmRMYWJlbCAmJiBoYXNBbmltYXRpb24pIHtcbiAgICAgICAgaWYgKGxhYmVsQW5pbWF0aW9uUmVjb3JkXzEub3JpZ2luYWxYICE9IG51bGwpIHtcbiAgICAgICAgICBlbmRMYWJlbC5hdHRyKHtcbiAgICAgICAgICAgIHg6IGxhYmVsQW5pbWF0aW9uUmVjb3JkXzEub3JpZ2luYWxYLFxuICAgICAgICAgICAgeTogbGFiZWxBbmltYXRpb25SZWNvcmRfMS5vcmlnaW5hbFlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGR1cmluZyk7IC8vIEV4cGFuZCBjbGlwIHNoYXBlIHRvIGF2b2lkIGNsaXBwaW5nIHdoZW4gbGluZSB2YWx1ZSBleGNlZWRzIGF4aXNcblxuICAgIGlmICghc2VyaWVzTW9kZWwuZ2V0KCdjbGlwJywgdHJ1ZSkpIHtcbiAgICAgIHZhciByZWN0U2hhcGUgPSBjbGlwUGF0aC5zaGFwZTtcbiAgICAgIHZhciBleHBhbmRTaXplID0gTWF0aC5tYXgocmVjdFNoYXBlLndpZHRoLCByZWN0U2hhcGUuaGVpZ2h0KTtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICByZWN0U2hhcGUueSAtPSBleHBhbmRTaXplO1xuICAgICAgICByZWN0U2hhcGUuaGVpZ2h0ICs9IGV4cGFuZFNpemUgKiAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjdFNoYXBlLnggLT0gZXhwYW5kU2l6ZTtcbiAgICAgICAgcmVjdFNoYXBlLndpZHRoICs9IGV4cGFuZFNpemUgKiAyO1xuICAgICAgfVxuICAgIH0gLy8gU2V0IHRvIHRoZSBmaW5hbCBmcmFtZS4gVG8gbWFrZSBzdXJlIGxhYmVsIGxheW91dCBpcyByaWdodC5cblxuXG4gICAgaWYgKGR1cmluZykge1xuICAgICAgZHVyaW5nKDEsIGNsaXBQYXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xpcFBhdGg7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChzZXJpZXNNb2RlbC5nZXQoWydlbmRMYWJlbCcsICdzaG93J10pKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignZW5kTGFiZWwgaXMgbm90IHN1cHBvcnRlZCBmb3IgbGluZXMgaW4gcG9sYXIgc3lzdGVtcy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlUG9sYXJDbGlwUGF0aChjb29yZFN5cywgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RW5kTGFiZWxTdGF0ZVNwZWNpZmllZChlbmRMYWJlbE1vZGVsLCBjb29yZFN5cykge1xuICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICB2YXIgaXNIb3Jpem9udGFsID0gYmFzZUF4aXMuaXNIb3Jpem9udGFsKCk7XG4gIHZhciBpc0Jhc2VJbnZlcnNlZCA9IGJhc2VBeGlzLmludmVyc2U7XG4gIHZhciBhbGlnbiA9IGlzSG9yaXpvbnRhbCA/IGlzQmFzZUludmVyc2VkID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6ICdjZW50ZXInO1xuICB2YXIgdmVydGljYWxBbGlnbiA9IGlzSG9yaXpvbnRhbCA/ICdtaWRkbGUnIDogaXNCYXNlSW52ZXJzZWQgPyAndG9wJyA6ICdib3R0b20nO1xuICByZXR1cm4ge1xuICAgIG5vcm1hbDoge1xuICAgICAgYWxpZ246IGVuZExhYmVsTW9kZWwuZ2V0KCdhbGlnbicpIHx8IGFsaWduLFxuICAgICAgdmVydGljYWxBbGlnbjogZW5kTGFiZWxNb2RlbC5nZXQoJ3ZlcnRpY2FsQWxpZ24nKSB8fCB2ZXJ0aWNhbEFsaWduXG4gICAgfVxuICB9O1xufVxuXG52YXIgTGluZVZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTGluZVZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gTGluZVZpZXcoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgTGluZVZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpbmVHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgdmFyIHN5bWJvbERyYXcgPSBuZXcgU3ltYm9sRHJhdygpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbERyYXcuZ3JvdXApO1xuICAgIHRoaXMuX3N5bWJvbERyYXcgPSBzeW1ib2xEcmF3O1xuICAgIHRoaXMuX2xpbmVHcm91cCA9IGxpbmVHcm91cDtcbiAgfTtcblxuICBMaW5lVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBsaW5lU3R5bGVNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgICB2YXIgYXJlYVN0eWxlTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnYXJlYVN0eWxlJyk7XG4gICAgdmFyIHBvaW50cyA9IGRhdGEuZ2V0TGF5b3V0KCdwb2ludHMnKSB8fCBbXTtcbiAgICB2YXIgaXNDb29yZFN5c1BvbGFyID0gY29vcmRTeXMudHlwZSA9PT0gJ3BvbGFyJztcbiAgICB2YXIgcHJldkNvb3JkU3lzID0gdGhpcy5fY29vcmRTeXM7XG4gICAgdmFyIHN5bWJvbERyYXcgPSB0aGlzLl9zeW1ib2xEcmF3O1xuICAgIHZhciBwb2x5bGluZSA9IHRoaXMuX3BvbHlsaW5lO1xuICAgIHZhciBwb2x5Z29uID0gdGhpcy5fcG9seWdvbjtcbiAgICB2YXIgbGluZUdyb3VwID0gdGhpcy5fbGluZUdyb3VwO1xuICAgIHZhciBoYXNBbmltYXRpb24gPSBzZXJpZXNNb2RlbC5nZXQoJ2FuaW1hdGlvbicpO1xuICAgIHZhciBpc0FyZWFDaGFydCA9ICFhcmVhU3R5bGVNb2RlbC5pc0VtcHR5KCk7XG4gICAgdmFyIHZhbHVlT3JpZ2luID0gYXJlYVN0eWxlTW9kZWwuZ2V0KCdvcmlnaW4nKTtcbiAgICB2YXIgZGF0YUNvb3JkSW5mbyA9IHByZXBhcmVEYXRhQ29vcmRJbmZvKGNvb3JkU3lzLCBkYXRhLCB2YWx1ZU9yaWdpbik7XG4gICAgdmFyIHN0YWNrZWRPblBvaW50cyA9IGlzQXJlYUNoYXJ0ICYmIGdldFN0YWNrZWRPblBvaW50cyhjb29yZFN5cywgZGF0YSwgZGF0YUNvb3JkSW5mbyk7XG4gICAgdmFyIHNob3dTeW1ib2wgPSBzZXJpZXNNb2RlbC5nZXQoJ3Nob3dTeW1ib2wnKTtcbiAgICB2YXIgaXNJZ25vcmVGdW5jID0gc2hvd1N5bWJvbCAmJiAhaXNDb29yZFN5c1BvbGFyICYmIGdldElzSWdub3JlRnVuYyhzZXJpZXNNb2RlbCwgZGF0YSwgY29vcmRTeXMpOyAvLyBSZW1vdmUgdGVtcG9yYXJ5IHN5bWJvbHNcblxuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICBvbGREYXRhICYmIG9sZERhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgIGlmIChlbC5fX3RlbXApIHtcbiAgICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICAgICAgb2xkRGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgbnVsbCk7XG4gICAgICB9XG4gICAgfSk7IC8vIFJlbW92ZSBwcmV2aW91cyBjcmVhdGVkIHN5bWJvbHMgaWYgc2hvd1N5bWJvbCBjaGFuZ2VkIHRvIGZhbHNlXG5cbiAgICBpZiAoIXNob3dTeW1ib2wpIHtcbiAgICAgIHN5bWJvbERyYXcucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgZ3JvdXAuYWRkKGxpbmVHcm91cCk7IC8vIEZJWE1FIHN0ZXAgbm90IHN1cHBvcnQgcG9sYXJcblxuICAgIHZhciBzdGVwID0gIWlzQ29vcmRTeXNQb2xhciA/IHNlcmllc01vZGVsLmdldCgnc3RlcCcpIDogZmFsc2U7XG4gICAgdmFyIGNsaXBTaGFwZUZvclN5bWJvbDtcblxuICAgIGlmIChjb29yZFN5cyAmJiBjb29yZFN5cy5nZXRBcmVhICYmIHNlcmllc01vZGVsLmdldCgnY2xpcCcsIHRydWUpKSB7XG4gICAgICBjbGlwU2hhcGVGb3JTeW1ib2wgPSBjb29yZFN5cy5nZXRBcmVhKCk7IC8vIEF2b2lkIGZsb2F0IG51bWJlciByb3VuZGluZyBlcnJvciBmb3Igc3ltYm9sIG9uIHRoZSBlZGdlIG9mIGF4aXMgZXh0ZW50LlxuICAgICAgLy8gU2VlICM3OTEzIGFuZCBgdGVzdC9kYXRhWm9vbS1jbGlwLmh0bWxgLlxuXG4gICAgICBpZiAoY2xpcFNoYXBlRm9yU3ltYm9sLndpZHRoICE9IG51bGwpIHtcbiAgICAgICAgY2xpcFNoYXBlRm9yU3ltYm9sLnggLT0gMC4xO1xuICAgICAgICBjbGlwU2hhcGVGb3JTeW1ib2wueSAtPSAwLjE7XG4gICAgICAgIGNsaXBTaGFwZUZvclN5bWJvbC53aWR0aCArPSAwLjI7XG4gICAgICAgIGNsaXBTaGFwZUZvclN5bWJvbC5oZWlnaHQgKz0gMC4yO1xuICAgICAgfSBlbHNlIGlmIChjbGlwU2hhcGVGb3JTeW1ib2wucjApIHtcbiAgICAgICAgY2xpcFNoYXBlRm9yU3ltYm9sLnIwIC09IDAuNTtcbiAgICAgICAgY2xpcFNoYXBlRm9yU3ltYm9sLnIgKz0gMC41O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2NsaXBTaGFwZUZvclN5bWJvbCA9IGNsaXBTaGFwZUZvclN5bWJvbDtcbiAgICB2YXIgdmlzdWFsQ29sb3IgPSBnZXRWaXN1YWxHcmFkaWVudChkYXRhLCBjb29yZFN5cykgfHwgZGF0YS5nZXRWaXN1YWwoJ3N0eWxlJylbZGF0YS5nZXRWaXN1YWwoJ2RyYXdUeXBlJyldOyAvLyBJbml0aWFsaXphdGlvbiBhbmltYXRpb24gb3IgY29vcmRpbmF0ZSBzeXN0ZW0gY2hhbmdlZFxuXG4gICAgaWYgKCEocG9seWxpbmUgJiYgcHJldkNvb3JkU3lzLnR5cGUgPT09IGNvb3JkU3lzLnR5cGUgJiYgc3RlcCA9PT0gdGhpcy5fc3RlcCkpIHtcbiAgICAgIHNob3dTeW1ib2wgJiYgc3ltYm9sRHJhdy51cGRhdGVEYXRhKGRhdGEsIHtcbiAgICAgICAgaXNJZ25vcmU6IGlzSWdub3JlRnVuYyxcbiAgICAgICAgY2xpcFNoYXBlOiBjbGlwU2hhcGVGb3JTeW1ib2wsXG4gICAgICAgIGRpc2FibGVBbmltYXRpb246IHRydWUsXG4gICAgICAgIGdldFN5bWJvbFBvaW50OiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgcmV0dXJuIFtwb2ludHNbaWR4ICogMl0sIHBvaW50c1tpZHggKiAyICsgMV1dO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGhhc0FuaW1hdGlvbiAmJiB0aGlzLl9pbml0U3ltYm9sTGFiZWxBbmltYXRpb24oZGF0YSwgY29vcmRTeXMsIGNsaXBTaGFwZUZvclN5bWJvbCk7XG5cbiAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgIC8vIFRPRE8gSWYgc3RhY2tlZCBzZXJpZXMgaXMgbm90IHN0ZXBcbiAgICAgICAgcG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuXG4gICAgICAgIGlmIChzdGFja2VkT25Qb2ludHMpIHtcbiAgICAgICAgICBzdGFja2VkT25Qb2ludHMgPSB0dXJuUG9pbnRzSW50b1N0ZXAoc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgc3RlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcG9seWxpbmUgPSB0aGlzLl9uZXdQb2x5bGluZShwb2ludHMpO1xuXG4gICAgICBpZiAoaXNBcmVhQ2hhcnQpIHtcbiAgICAgICAgcG9seWdvbiA9IHRoaXMuX25ld1BvbHlnb24ocG9pbnRzLCBzdGFja2VkT25Qb2ludHMpO1xuICAgICAgfSAvLyBOT1RFOiBNdXN0IHVwZGF0ZSBfZW5kTGFiZWwgYmVmb3JlIHNldENsaXBQYXRoLlxuXG5cbiAgICAgIGlmICghaXNDb29yZFN5c1BvbGFyKSB7XG4gICAgICAgIHRoaXMuX2luaXRPclVwZGF0ZUVuZExhYmVsKHNlcmllc01vZGVsLCBjb29yZFN5cywgY29udmVydFRvQ29sb3JTdHJpbmcodmlzdWFsQ29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgbGluZUdyb3VwLnNldENsaXBQYXRoKGNyZWF0ZUxpbmVDbGlwUGF0aCh0aGlzLCBjb29yZFN5cywgdHJ1ZSwgc2VyaWVzTW9kZWwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQXJlYUNoYXJ0ICYmICFwb2x5Z29uKSB7XG4gICAgICAgIC8vIElmIGFyZWFTdHlsZSBpcyBhZGRlZFxuICAgICAgICBwb2x5Z29uID0gdGhpcy5fbmV3UG9seWdvbihwb2ludHMsIHN0YWNrZWRPblBvaW50cyk7XG4gICAgICB9IGVsc2UgaWYgKHBvbHlnb24gJiYgIWlzQXJlYUNoYXJ0KSB7XG4gICAgICAgIC8vIElmIGFyZWFTdHlsZSBpcyByZW1vdmVkXG4gICAgICAgIGxpbmVHcm91cC5yZW1vdmUocG9seWdvbik7XG4gICAgICAgIHBvbHlnb24gPSB0aGlzLl9wb2x5Z29uID0gbnVsbDtcbiAgICAgIH0gLy8gTk9URTogTXVzdCB1cGRhdGUgX2VuZExhYmVsIGJlZm9yZSBzZXRDbGlwUGF0aC5cblxuXG4gICAgICBpZiAoIWlzQ29vcmRTeXNQb2xhcikge1xuICAgICAgICB0aGlzLl9pbml0T3JVcGRhdGVFbmRMYWJlbChzZXJpZXNNb2RlbCwgY29vcmRTeXMsIGNvbnZlcnRUb0NvbG9yU3RyaW5nKHZpc3VhbENvbG9yKSk7XG4gICAgICB9IC8vIFVwZGF0ZSBjbGlwUGF0aFxuXG5cbiAgICAgIGxpbmVHcm91cC5zZXRDbGlwUGF0aChjcmVhdGVMaW5lQ2xpcFBhdGgodGhpcywgY29vcmRTeXMsIGZhbHNlLCBzZXJpZXNNb2RlbCkpOyAvLyBBbHdheXMgdXBkYXRlLCBvciBpdCBpcyB3cm9uZyBpbiB0aGUgY2FzZSB0dXJuaW5nIG9uIGxlZ2VuZFxuICAgICAgLy8gYmVjYXVzZSBwb2ludHMgYXJlIG5vdCBjaGFuZ2VkXG5cbiAgICAgIHNob3dTeW1ib2wgJiYgc3ltYm9sRHJhdy51cGRhdGVEYXRhKGRhdGEsIHtcbiAgICAgICAgaXNJZ25vcmU6IGlzSWdub3JlRnVuYyxcbiAgICAgICAgY2xpcFNoYXBlOiBjbGlwU2hhcGVGb3JTeW1ib2wsXG4gICAgICAgIGRpc2FibGVBbmltYXRpb246IHRydWUsXG4gICAgICAgIGdldFN5bWJvbFBvaW50OiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgcmV0dXJuIFtwb2ludHNbaWR4ICogMl0sIHBvaW50c1tpZHggKiAyICsgMV1dO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gSW4gdGhlIGNhc2UgZGF0YSB6b29tIHRyaWdnZXJyZWQgcmVmcmVzaGluZyBmcmVxdWVudGx5XG4gICAgICAvLyBEYXRhIG1heSBub3QgY2hhbmdlIGlmIGxpbmUgaGFzIGEgY2F0ZWdvcnkgYXhpcy4gU28gaXQgc2hvdWxkIGFuaW1hdGUgbm90aGluZ1xuXG4gICAgICBpZiAoIWlzUG9pbnRzU2FtZSh0aGlzLl9zdGFja2VkT25Qb2ludHMsIHN0YWNrZWRPblBvaW50cykgfHwgIWlzUG9pbnRzU2FtZSh0aGlzLl9wb2ludHMsIHBvaW50cykpIHtcbiAgICAgICAgaWYgKGhhc0FuaW1hdGlvbikge1xuICAgICAgICAgIHRoaXMuX2RvVXBkYXRlQW5pbWF0aW9uKGRhdGEsIHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIGFwaSwgc3RlcCwgdmFsdWVPcmlnaW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vdCBkbyBpdCBpbiB1cGRhdGUgd2l0aCBhbmltYXRpb25cbiAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgLy8gVE9ETyBJZiBzdGFja2VkIHNlcmllcyBpcyBub3Qgc3RlcFxuICAgICAgICAgICAgcG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuXG4gICAgICAgICAgICBpZiAoc3RhY2tlZE9uUG9pbnRzKSB7XG4gICAgICAgICAgICAgIHN0YWNrZWRPblBvaW50cyA9IHR1cm5Qb2ludHNJbnRvU3RlcChzdGFja2VkT25Qb2ludHMsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb2x5bGluZS5zZXRTaGFwZSh7XG4gICAgICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvbHlnb24gJiYgcG9seWdvbi5zZXRTaGFwZSh7XG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgICAgIHN0YWNrZWRPblBvaW50czogc3RhY2tlZE9uUG9pbnRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZm9jdXMgPSBzZXJpZXNNb2RlbC5nZXQoWydlbXBoYXNpcycsICdmb2N1cyddKTtcbiAgICB2YXIgYmx1clNjb3BlID0gc2VyaWVzTW9kZWwuZ2V0KFsnZW1waGFzaXMnLCAnYmx1clNjb3BlJ10pO1xuICAgIHBvbHlsaW5lLnVzZVN0eWxlKHpyVXRpbC5kZWZhdWx0cyggLy8gVXNlIGNvbG9yIGluIGxpbmVTdHlsZSBmaXJzdFxuICAgIGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpLCB7XG4gICAgICBmaWxsOiAnbm9uZScsXG4gICAgICBzdHJva2U6IHZpc3VhbENvbG9yLFxuICAgICAgbGluZUpvaW46ICdiZXZlbCdcbiAgICB9KSk7XG4gICAgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsKHBvbHlsaW5lLCBzZXJpZXNNb2RlbCwgJ2xpbmVTdHlsZScpO1xuXG4gICAgaWYgKHBvbHlsaW5lLnN0eWxlLmxpbmVXaWR0aCA+IDAgJiYgc2VyaWVzTW9kZWwuZ2V0KFsnZW1waGFzaXMnLCAnbGluZVN0eWxlJywgJ3dpZHRoJ10pID09PSAnYm9sZGVyJykge1xuICAgICAgdmFyIGVtcGhhc2lzTGluZVN0eWxlID0gcG9seWxpbmUuZ2V0U3RhdGUoJ2VtcGhhc2lzJykuc3R5bGU7XG4gICAgICBlbXBoYXNpc0xpbmVTdHlsZS5saW5lV2lkdGggPSBwb2x5bGluZS5zdHlsZS5saW5lV2lkdGggKyAxO1xuICAgIH0gLy8gTmVlZHMgc2VyaWVzSW5kZXggZm9yIGZvY3VzXG5cblxuICAgIGdldEVDRGF0YShwb2x5bGluZSkuc2VyaWVzSW5kZXggPSBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleDtcbiAgICBlbmFibGVIb3ZlckVtcGhhc2lzKHBvbHlsaW5lLCBmb2N1cywgYmx1clNjb3BlKTtcbiAgICB2YXIgc21vb3RoID0gZ2V0U21vb3RoKHNlcmllc01vZGVsLmdldCgnc21vb3RoJykpO1xuICAgIHZhciBzbW9vdGhNb25vdG9uZSA9IHNlcmllc01vZGVsLmdldCgnc21vb3RoTW9ub3RvbmUnKTtcbiAgICB2YXIgY29ubmVjdE51bGxzID0gc2VyaWVzTW9kZWwuZ2V0KCdjb25uZWN0TnVsbHMnKTtcbiAgICBwb2x5bGluZS5zZXRTaGFwZSh7XG4gICAgICBzbW9vdGg6IHNtb290aCxcbiAgICAgIHNtb290aE1vbm90b25lOiBzbW9vdGhNb25vdG9uZSxcbiAgICAgIGNvbm5lY3ROdWxsczogY29ubmVjdE51bGxzXG4gICAgfSk7XG5cbiAgICBpZiAocG9seWdvbikge1xuICAgICAgdmFyIHN0YWNrZWRPblNlcmllcyA9IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja2VkT25TZXJpZXMnKTtcbiAgICAgIHZhciBzdGFja2VkT25TbW9vdGggPSAwO1xuICAgICAgcG9seWdvbi51c2VTdHlsZSh6clV0aWwuZGVmYXVsdHMoYXJlYVN0eWxlTW9kZWwuZ2V0QXJlYVN0eWxlKCksIHtcbiAgICAgICAgZmlsbDogdmlzdWFsQ29sb3IsXG4gICAgICAgIG9wYWNpdHk6IDAuNyxcbiAgICAgICAgbGluZUpvaW46ICdiZXZlbCcsXG4gICAgICAgIGRlY2FsOiBkYXRhLmdldFZpc3VhbCgnc3R5bGUnKS5kZWNhbFxuICAgICAgfSkpO1xuXG4gICAgICBpZiAoc3RhY2tlZE9uU2VyaWVzKSB7XG4gICAgICAgIHN0YWNrZWRPblNtb290aCA9IGdldFNtb290aChzdGFja2VkT25TZXJpZXMuZ2V0KCdzbW9vdGgnKSk7XG4gICAgICB9XG5cbiAgICAgIHBvbHlnb24uc2V0U2hhcGUoe1xuICAgICAgICBzbW9vdGg6IHNtb290aCxcbiAgICAgICAgc3RhY2tlZE9uU21vb3RoOiBzdGFja2VkT25TbW9vdGgsXG4gICAgICAgIHNtb290aE1vbm90b25lOiBzbW9vdGhNb25vdG9uZSxcbiAgICAgICAgY29ubmVjdE51bGxzOiBjb25uZWN0TnVsbHNcbiAgICAgIH0pO1xuICAgICAgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsKHBvbHlnb24sIHNlcmllc01vZGVsLCAnYXJlYVN0eWxlJyk7IC8vIE5lZWRzIHNlcmllc0luZGV4IGZvciBmb2N1c1xuXG4gICAgICBnZXRFQ0RhdGEocG9seWdvbikuc2VyaWVzSW5kZXggPSBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleDtcbiAgICAgIGVuYWJsZUhvdmVyRW1waGFzaXMocG9seWdvbiwgZm9jdXMsIGJsdXJTY29wZSk7XG4gICAgfVxuXG4gICAgdmFyIGNoYW5nZVBvbHlTdGF0ZSA9IGZ1bmN0aW9uICh0b1N0YXRlKSB7XG4gICAgICBfdGhpcy5fY2hhbmdlUG9seVN0YXRlKHRvU3RhdGUpO1xuICAgIH07XG5cbiAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgLy8gU3dpdGNoIHBvbHlsaW5lIC8gcG9seWdvbiBzdGF0ZSBpZiBlbGVtZW50IGNoYW5nZWQgaXRzIHN0YXRlLlxuICAgICAgZWwgJiYgKGVsLm9uSG92ZXJTdGF0ZUNoYW5nZSA9IGNoYW5nZVBvbHlTdGF0ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcG9seWxpbmUub25Ib3ZlclN0YXRlQ2hhbmdlID0gY2hhbmdlUG9seVN0YXRlO1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhOyAvLyBTYXZlIHRoZSBjb29yZGluYXRlIHN5c3RlbSBmb3IgdHJhbnNpdGlvbiBhbmltYXRpb24gd2hlbiBkYXRhIGNoYW5nZWRcblxuICAgIHRoaXMuX2Nvb3JkU3lzID0gY29vcmRTeXM7XG4gICAgdGhpcy5fc3RhY2tlZE9uUG9pbnRzID0gc3RhY2tlZE9uUG9pbnRzO1xuICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgICB0aGlzLl92YWx1ZU9yaWdpbiA9IHZhbHVlT3JpZ2luO1xuICB9O1xuXG4gIExpbmVWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG5cbiAgTGluZVZpZXcucHJvdG90eXBlLmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGRhdGFJbmRleCA9IG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleChkYXRhLCBwYXlsb2FkKTtcblxuICAgIHRoaXMuX2NoYW5nZVBvbHlTdGF0ZSgnZW1waGFzaXMnKTtcblxuICAgIGlmICghKGRhdGFJbmRleCBpbnN0YW5jZW9mIEFycmF5KSAmJiBkYXRhSW5kZXggIT0gbnVsbCAmJiBkYXRhSW5kZXggPj0gMCkge1xuICAgICAgdmFyIHBvaW50cyA9IGRhdGEuZ2V0TGF5b3V0KCdwb2ludHMnKTtcbiAgICAgIHZhciBzeW1ib2wgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4KTtcblxuICAgICAgaWYgKCFzeW1ib2wpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IHN5bWJvbCBpZiBpdCBpcyBub3QgZXhpc3RzXG4gICAgICAgIHZhciB4ID0gcG9pbnRzW2RhdGFJbmRleCAqIDJdO1xuICAgICAgICB2YXIgeSA9IHBvaW50c1tkYXRhSW5kZXggKiAyICsgMV07XG5cbiAgICAgICAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSB7XG4gICAgICAgICAgLy8gTnVsbCBkYXRhXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIGZpeCAjMTEzNjA6IHNob3VsZCd0IGRyYXcgc3ltYm9sIG91dHNpZGUgY2xpcFNoYXBlRm9yU3ltYm9sXG5cblxuICAgICAgICBpZiAodGhpcy5fY2xpcFNoYXBlRm9yU3ltYm9sICYmICF0aGlzLl9jbGlwU2hhcGVGb3JTeW1ib2wuY29udGFpbih4LCB5KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN5bWJvbCA9IG5ldyBTeW1ib2xDbHooZGF0YSwgZGF0YUluZGV4KTtcbiAgICAgICAgc3ltYm9sLnggPSB4O1xuICAgICAgICBzeW1ib2wueSA9IHk7XG4gICAgICAgIHN5bWJvbC5zZXRaKHNlcmllc01vZGVsLmdldCgnemxldmVsJyksIHNlcmllc01vZGVsLmdldCgneicpKTtcbiAgICAgICAgc3ltYm9sLl9fdGVtcCA9IHRydWU7XG4gICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIHN5bWJvbCk7IC8vIFN0b3Agc2NhbGUgYW5pbWF0aW9uXG5cbiAgICAgICAgc3ltYm9sLnN0b3BTeW1ib2xBbmltYXRpb24odHJ1ZSk7XG4gICAgICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbCk7XG4gICAgICB9XG5cbiAgICAgIHN5bWJvbC5oaWdobGlnaHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSGlnaGxpZ2h0IHdob2xlIHNlcmllc1xuICAgICAgQ2hhcnRWaWV3LnByb3RvdHlwZS5oaWdobGlnaHQuY2FsbCh0aGlzLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICB9XG4gIH07XG5cbiAgTGluZVZpZXcucHJvdG90eXBlLmRvd25wbGF5ID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgZGF0YUluZGV4ID0gbW9kZWxVdGlsLnF1ZXJ5RGF0YUluZGV4KGRhdGEsIHBheWxvYWQpO1xuXG4gICAgdGhpcy5fY2hhbmdlUG9seVN0YXRlKCdub3JtYWwnKTtcblxuICAgIGlmIChkYXRhSW5kZXggIT0gbnVsbCAmJiBkYXRhSW5kZXggPj0gMCkge1xuICAgICAgdmFyIHN5bWJvbCA9IGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgpO1xuXG4gICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgIGlmIChzeW1ib2wuX190ZW1wKSB7XG4gICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCwgbnVsbCk7XG4gICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmUoc3ltYm9sKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzeW1ib2wuZG93bnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGSVhNRVxuICAgICAgLy8gY2FuIG5vdCBkb3ducGxheSBjb21wbGV0ZWx5LlxuICAgICAgLy8gRG93bnBsYXkgd2hvbGUgc2VyaWVzXG4gICAgICBDaGFydFZpZXcucHJvdG90eXBlLmRvd25wbGF5LmNhbGwodGhpcywgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgfVxuICB9O1xuXG4gIExpbmVWaWV3LnByb3RvdHlwZS5fY2hhbmdlUG9seVN0YXRlID0gZnVuY3Rpb24gKHRvU3RhdGUpIHtcbiAgICB2YXIgcG9seWdvbiA9IHRoaXMuX3BvbHlnb247XG4gICAgc2V0U3RhdGVzRmxhZyh0aGlzLl9wb2x5bGluZSwgdG9TdGF0ZSk7XG4gICAgcG9seWdvbiAmJiBzZXRTdGF0ZXNGbGFnKHBvbHlnb24sIHRvU3RhdGUpO1xuICB9O1xuXG4gIExpbmVWaWV3LnByb3RvdHlwZS5fbmV3UG9seWxpbmUgPSBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgdmFyIHBvbHlsaW5lID0gdGhpcy5fcG9seWxpbmU7IC8vIFJlbW92ZSBwcmV2aW91cyBjcmVhdGVkIHBvbHlsaW5lXG5cbiAgICBpZiAocG9seWxpbmUpIHtcbiAgICAgIHRoaXMuX2xpbmVHcm91cC5yZW1vdmUocG9seWxpbmUpO1xuICAgIH1cblxuICAgIHBvbHlsaW5lID0gbmV3IEVDUG9seWxpbmUoe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgIH0sXG4gICAgICBzZWdtZW50SWdub3JlVGhyZXNob2xkOiAyLFxuICAgICAgejI6IDEwXG4gICAgfSk7XG5cbiAgICB0aGlzLl9saW5lR3JvdXAuYWRkKHBvbHlsaW5lKTtcblxuICAgIHRoaXMuX3BvbHlsaW5lID0gcG9seWxpbmU7XG4gICAgcmV0dXJuIHBvbHlsaW5lO1xuICB9O1xuXG4gIExpbmVWaWV3LnByb3RvdHlwZS5fbmV3UG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMsIHN0YWNrZWRPblBvaW50cykge1xuICAgIHZhciBwb2x5Z29uID0gdGhpcy5fcG9seWdvbjsgLy8gUmVtb3ZlIHByZXZpb3VzIGNyZWF0ZWQgcG9seWdvblxuXG4gICAgaWYgKHBvbHlnb24pIHtcbiAgICAgIHRoaXMuX2xpbmVHcm91cC5yZW1vdmUocG9seWdvbik7XG4gICAgfVxuXG4gICAgcG9seWdvbiA9IG5ldyBFQ1BvbHlnb24oe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgIHN0YWNrZWRPblBvaW50czogc3RhY2tlZE9uUG9pbnRzXG4gICAgICB9LFxuICAgICAgc2VnbWVudElnbm9yZVRocmVzaG9sZDogMlxuICAgIH0pO1xuXG4gICAgdGhpcy5fbGluZUdyb3VwLmFkZChwb2x5Z29uKTtcblxuICAgIHRoaXMuX3BvbHlnb24gPSBwb2x5Z29uO1xuICAgIHJldHVybiBwb2x5Z29uO1xuICB9O1xuXG4gIExpbmVWaWV3LnByb3RvdHlwZS5faW5pdFN5bWJvbExhYmVsQW5pbWF0aW9uID0gZnVuY3Rpb24gKGRhdGEsIGNvb3JkU3lzLCBjbGlwU2hhcGUpIHtcbiAgICB2YXIgaXNIb3Jpem9udGFsT3JSYWRpYWw7XG4gICAgdmFyIGlzQ29vcmRTeXNQb2xhcjtcbiAgICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgIHZhciBpc0F4aXNJbnZlcnNlID0gYmFzZUF4aXMuaW52ZXJzZTtcblxuICAgIGlmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICBpc0hvcml6b250YWxPclJhZGlhbCA9IGJhc2VBeGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgaXNDb29yZFN5c1BvbGFyID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChjb29yZFN5cy50eXBlID09PSAncG9sYXInKSB7XG4gICAgICBpc0hvcml6b250YWxPclJhZGlhbCA9IGJhc2VBeGlzLmRpbSA9PT0gJ2FuZ2xlJztcbiAgICAgIGlzQ29vcmRTeXNQb2xhciA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgdmFyIHNlcmllc0R1cmF0aW9uID0gc2VyaWVzTW9kZWwuZ2V0KCdhbmltYXRpb25EdXJhdGlvbicpO1xuXG4gICAgaWYgKHR5cGVvZiBzZXJpZXNEdXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2VyaWVzRHVyYXRpb24gPSBzZXJpZXNEdXJhdGlvbihudWxsKTtcbiAgICB9XG5cbiAgICB2YXIgc2VyaWVzRGFsYXkgPSBzZXJpZXNNb2RlbC5nZXQoJ2FuaW1hdGlvbkRlbGF5JykgfHwgMDtcbiAgICB2YXIgc2VyaWVzRGFsYXlWYWx1ZSA9IHR5cGVvZiBzZXJpZXNEYWxheSA9PT0gJ2Z1bmN0aW9uJyA/IHNlcmllc0RhbGF5KG51bGwpIDogc2VyaWVzRGFsYXk7XG4gICAgZGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoc3ltYm9sLCBpZHgpIHtcbiAgICAgIHZhciBlbCA9IHN5bWJvbDtcblxuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIHZhciBwb2ludCA9IFtzeW1ib2wueCwgc3ltYm9sLnldO1xuICAgICAgICB2YXIgc3RhcnQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBlbmQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChpc0Nvb3JkU3lzUG9sYXIpIHtcbiAgICAgICAgICB2YXIgcG9sYXJDbGlwID0gY2xpcFNoYXBlO1xuICAgICAgICAgIHZhciBjb29yZCA9IGNvb3JkU3lzLnBvaW50VG9Db29yZChwb2ludCk7XG5cbiAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsT3JSYWRpYWwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gcG9sYXJDbGlwLnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICBlbmQgPSBwb2xhckNsaXAuZW5kQW5nbGU7XG4gICAgICAgICAgICBjdXJyZW50ID0gLWNvb3JkWzFdIC8gMTgwICogTWF0aC5QSTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBwb2xhckNsaXAucjA7XG4gICAgICAgICAgICBlbmQgPSBwb2xhckNsaXAucjtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjb29yZFswXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGdyaWRDbGlwID0gY2xpcFNoYXBlO1xuXG4gICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbE9yUmFkaWFsKSB7XG4gICAgICAgICAgICBzdGFydCA9IGdyaWRDbGlwLng7XG4gICAgICAgICAgICBlbmQgPSBncmlkQ2xpcC54ICsgZ3JpZENsaXAud2lkdGg7XG4gICAgICAgICAgICBjdXJyZW50ID0gc3ltYm9sLng7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZ3JpZENsaXAueSArIGdyaWRDbGlwLmhlaWdodDtcbiAgICAgICAgICAgIGVuZCA9IGdyaWRDbGlwLnk7XG4gICAgICAgICAgICBjdXJyZW50ID0gc3ltYm9sLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhdGlvID0gZW5kID09PSBzdGFydCA/IDAgOiAoY3VycmVudCAtIHN0YXJ0KSAvIChlbmQgLSBzdGFydCk7XG5cbiAgICAgICAgaWYgKGlzQXhpc0ludmVyc2UpIHtcbiAgICAgICAgICByYXRpbyA9IDEgLSByYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWxheSA9IHR5cGVvZiBzZXJpZXNEYWxheSA9PT0gJ2Z1bmN0aW9uJyA/IHNlcmllc0RhbGF5KGlkeCkgOiBzZXJpZXNEdXJhdGlvbiAqIHJhdGlvICsgc2VyaWVzRGFsYXlWYWx1ZTtcbiAgICAgICAgdmFyIHN5bWJvbFBhdGggPSBlbC5nZXRTeW1ib2xQYXRoKCk7XG4gICAgICAgIHZhciB0ZXh0ID0gc3ltYm9sUGF0aC5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICBlbC5hdHRyKHtcbiAgICAgICAgICBzY2FsZVg6IDAsXG4gICAgICAgICAgc2NhbGVZOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBlbC5hbmltYXRlVG8oe1xuICAgICAgICAgIHNjYWxlWDogMSxcbiAgICAgICAgICBzY2FsZVk6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiAyMDAsXG4gICAgICAgICAgZGVsYXk6IGRlbGF5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgdGV4dC5hbmltYXRlRnJvbSh7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIGRlbGF5OiBkZWxheVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ltYm9sUGF0aC5kaXNhYmxlTGFiZWxBbmltYXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIExpbmVWaWV3LnByb3RvdHlwZS5faW5pdE9yVXBkYXRlRW5kTGFiZWwgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGNvb3JkU3lzLCBpbmhlcml0Q29sb3IpIHtcbiAgICB2YXIgZW5kTGFiZWxNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdlbmRMYWJlbCcpO1xuXG4gICAgaWYgKGVuZExhYmVsTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgIHZhciBkYXRhXzIgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB2YXIgcG9seWxpbmUgPSB0aGlzLl9wb2x5bGluZTtcbiAgICAgIHZhciBlbmRMYWJlbCA9IHRoaXMuX2VuZExhYmVsO1xuXG4gICAgICBpZiAoIWVuZExhYmVsKSB7XG4gICAgICAgIGVuZExhYmVsID0gdGhpcy5fZW5kTGFiZWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgICB6MjogMjAwIC8vIHNob3VsZCBiZSBoaWdoZXIgdGhhbiBpdGVtIHN5bWJvbFxuXG4gICAgICAgIH0pO1xuICAgICAgICBlbmRMYWJlbC5pZ25vcmVDbGlwID0gdHJ1ZTtcbiAgICAgICAgcG9seWxpbmUuc2V0VGV4dENvbnRlbnQodGhpcy5fZW5kTGFiZWwpO1xuICAgICAgICBwb2x5bGluZS5kaXNhYmxlTGFiZWxBbmltYXRpb24gPSB0cnVlO1xuICAgICAgfSAvLyBGaW5kIGxhc3Qgbm9uLU5hTiBkYXRhIHRvIGRpc3BsYXkgZGF0YVxuXG5cbiAgICAgIHZhciBkYXRhSW5kZXggPSBnZXRMYXN0SW5kZXhOb3ROdWxsKGRhdGFfMi5nZXRMYXlvdXQoJ3BvaW50cycpKTtcblxuICAgICAgaWYgKGRhdGFJbmRleCA+PSAwKSB7XG4gICAgICAgIHNldExhYmVsU3R5bGUocG9seWxpbmUsIGdldExhYmVsU3RhdGVzTW9kZWxzKHNlcmllc01vZGVsLCAnZW5kTGFiZWwnKSwge1xuICAgICAgICAgIGluaGVyaXRDb2xvcjogaW5oZXJpdENvbG9yLFxuICAgICAgICAgIGxhYmVsRmV0Y2hlcjogc2VyaWVzTW9kZWwsXG4gICAgICAgICAgbGFiZWxEYXRhSW5kZXg6IGRhdGFJbmRleCxcbiAgICAgICAgICBkZWZhdWx0VGV4dDogZnVuY3Rpb24gKGRhdGFJbmRleCwgb3B0LCBpbnRlcnBvbGF0ZWRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlZFZhbHVlICE9IG51bGwgPyBnZXREZWZhdWx0SW50ZXJwb2xhdGVkTGFiZWwoZGF0YV8yLCBpbnRlcnBvbGF0ZWRWYWx1ZSkgOiBnZXREZWZhdWx0TGFiZWwoZGF0YV8yLCBkYXRhSW5kZXgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5hYmxlVGV4dFNldHRlcjogdHJ1ZVxuICAgICAgICB9LCBnZXRFbmRMYWJlbFN0YXRlU3BlY2lmaWVkKGVuZExhYmVsTW9kZWwsIGNvb3JkU3lzKSk7XG4gICAgICAgIHBvbHlsaW5lLnRleHRDb25maWcucG9zaXRpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fZW5kTGFiZWwpIHtcbiAgICAgIHRoaXMuX3BvbHlsaW5lLnJlbW92ZVRleHRDb250ZW50KCk7XG5cbiAgICAgIHRoaXMuX2VuZExhYmVsID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgTGluZVZpZXcucHJvdG90eXBlLl9lbmRMYWJlbE9uRHVyaW5nID0gZnVuY3Rpb24gKHBlcmNlbnQsIGNsaXBSZWN0LCBkYXRhLCBhbmltYXRpb25SZWNvcmQsIHZhbHVlQW5pbWF0aW9uLCBlbmRMYWJlbE1vZGVsLCBjb29yZFN5cykge1xuICAgIHZhciBlbmRMYWJlbCA9IHRoaXMuX2VuZExhYmVsO1xuICAgIHZhciBwb2x5bGluZSA9IHRoaXMuX3BvbHlsaW5lO1xuXG4gICAgaWYgKGVuZExhYmVsKSB7XG4gICAgICAvLyBOT1RFOiBEb24ndCByZW1vdmUgcGVyY2VudCA8IDEuIHBlcmNlbnQgPT09IDEgbWVhbnMgdGhlIGZpcnN0IGZyYW1lIGR1cmluZyByZW5kZXIuXG4gICAgICAvLyBUaGUgbGFiZWwgaXMgbm90IHByZXBhcmVkIGF0IHRoaXMgdGltZS5cbiAgICAgIGlmIChwZXJjZW50IDwgMSAmJiBhbmltYXRpb25SZWNvcmQub3JpZ2luYWxYID09IG51bGwpIHtcbiAgICAgICAgYW5pbWF0aW9uUmVjb3JkLm9yaWdpbmFsWCA9IGVuZExhYmVsLng7XG4gICAgICAgIGFuaW1hdGlvblJlY29yZC5vcmlnaW5hbFkgPSBlbmRMYWJlbC55O1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRzID0gZGF0YS5nZXRMYXlvdXQoJ3BvaW50cycpO1xuICAgICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgICB2YXIgY29ubmVjdE51bGxzID0gc2VyaWVzTW9kZWwuZ2V0KCdjb25uZWN0TnVsbHMnKTtcbiAgICAgIHZhciBwcmVjaXNpb24gPSBlbmRMYWJlbE1vZGVsLmdldCgncHJlY2lzaW9uJyk7XG4gICAgICB2YXIgZGlzdGFuY2UgPSBlbmRMYWJlbE1vZGVsLmdldCgnZGlzdGFuY2UnKSB8fCAwO1xuICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgIHZhciBpc0hvcml6b250YWwgPSBiYXNlQXhpcy5pc0hvcml6b250YWwoKTtcbiAgICAgIHZhciBpc0Jhc2VJbnZlcnNlZCA9IGJhc2VBeGlzLmludmVyc2U7XG4gICAgICB2YXIgY2xpcFNoYXBlID0gY2xpcFJlY3Quc2hhcGU7XG4gICAgICB2YXIgeE9yWSA9IGlzQmFzZUludmVyc2VkID8gaXNIb3Jpem9udGFsID8gY2xpcFNoYXBlLnggOiBjbGlwU2hhcGUueSArIGNsaXBTaGFwZS5oZWlnaHQgOiBpc0hvcml6b250YWwgPyBjbGlwU2hhcGUueCArIGNsaXBTaGFwZS53aWR0aCA6IGNsaXBTaGFwZS55O1xuICAgICAgdmFyIGRpc3RhbmNlWCA9IChpc0hvcml6b250YWwgPyBkaXN0YW5jZSA6IDApICogKGlzQmFzZUludmVyc2VkID8gLTEgOiAxKTtcbiAgICAgIHZhciBkaXN0YW5jZVkgPSAoaXNIb3Jpem9udGFsID8gMCA6IC1kaXN0YW5jZSkgKiAoaXNCYXNlSW52ZXJzZWQgPyAtMSA6IDEpO1xuICAgICAgdmFyIGRpbSA9IGlzSG9yaXpvbnRhbCA/ICd4JyA6ICd5JztcbiAgICAgIHZhciBkYXRhSW5kZXhSYW5nZSA9IGdldEluZGV4UmFuZ2UocG9pbnRzLCB4T3JZLCBkaW0pO1xuICAgICAgdmFyIGluZGljZXMgPSBkYXRhSW5kZXhSYW5nZS5yYW5nZTtcbiAgICAgIHZhciBkaWZmID0gaW5kaWNlc1sxXSAtIGluZGljZXNbMF07XG4gICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChkaWZmID49IDEpIHtcbiAgICAgICAgLy8gZGlmZiA+IDEgJiYgY29ubmVjdE51bGxzLCB3aGljaCBpcyBvbiB0aGUgbnVsbCBkYXRhLlxuICAgICAgICBpZiAoZGlmZiA+IDEgJiYgIWNvbm5lY3ROdWxscykge1xuICAgICAgICAgIHZhciBwdCA9IGdldFBvaW50QXRJbmRleChwb2ludHMsIGluZGljZXNbMF0pO1xuICAgICAgICAgIGVuZExhYmVsLmF0dHIoe1xuICAgICAgICAgICAgeDogcHRbMF0gKyBkaXN0YW5jZVgsXG4gICAgICAgICAgICB5OiBwdFsxXSArIGRpc3RhbmNlWVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhbHVlQW5pbWF0aW9uICYmICh2YWx1ZSA9IHNlcmllc01vZGVsLmdldFJhd1ZhbHVlKGluZGljZXNbMF0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHQgPSBwb2x5bGluZS5nZXRQb2ludE9uKHhPclksIGRpbSk7XG4gICAgICAgICAgcHQgJiYgZW5kTGFiZWwuYXR0cih7XG4gICAgICAgICAgICB4OiBwdFswXSArIGRpc3RhbmNlWCxcbiAgICAgICAgICAgIHk6IHB0WzFdICsgZGlzdGFuY2VZXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShpbmRpY2VzWzBdKTtcbiAgICAgICAgICB2YXIgZW5kVmFsdWUgPSBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShpbmRpY2VzWzFdKTtcbiAgICAgICAgICB2YWx1ZUFuaW1hdGlvbiAmJiAodmFsdWUgPSBtb2RlbFV0aWwuaW50ZXJwb2xhdGVSYXdWYWx1ZXMoZGF0YSwgcHJlY2lzaW9uLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZGF0YUluZGV4UmFuZ2UudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5pbWF0aW9uUmVjb3JkLmxhc3RGcmFtZUluZGV4ID0gaW5kaWNlc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGRpZmYgPD0gMCwgd2hpY2ggaXMgdGhlIHJhbmdlIGlzIG5vdCBmb3VuZChJbmNsdWRlIE5hTilcbiAgICAgICAgLy8gQ2hvb3NlIHRoZSBmaXJzdCBwb2ludCBvciBsYXN0IHBvaW50LlxuICAgICAgICB2YXIgaWR4ID0gcGVyY2VudCA9PT0gMSB8fCBhbmltYXRpb25SZWNvcmQubGFzdEZyYW1lSW5kZXggPiAwID8gaW5kaWNlc1swXSA6IDA7XG4gICAgICAgIHZhciBwdCA9IGdldFBvaW50QXRJbmRleChwb2ludHMsIGlkeCk7XG4gICAgICAgIHZhbHVlQW5pbWF0aW9uICYmICh2YWx1ZSA9IHNlcmllc01vZGVsLmdldFJhd1ZhbHVlKGlkeCkpO1xuICAgICAgICBlbmRMYWJlbC5hdHRyKHtcbiAgICAgICAgICB4OiBwdFswXSArIGRpc3RhbmNlWCxcbiAgICAgICAgICB5OiBwdFsxXSArIGRpc3RhbmNlWVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlQW5pbWF0aW9uKSB7XG4gICAgICAgIGxhYmVsSW5uZXIoZW5kTGFiZWwpLnNldExhYmVsVGV4dCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIC8vIEZJWE1FIFR3byB2YWx1ZSBheGlzXG5cblxuICBMaW5lVmlldy5wcm90b3R5cGUuX2RvVXBkYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKGRhdGEsIHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIGFwaSwgc3RlcCwgdmFsdWVPcmlnaW4pIHtcbiAgICB2YXIgcG9seWxpbmUgPSB0aGlzLl9wb2x5bGluZTtcbiAgICB2YXIgcG9seWdvbiA9IHRoaXMuX3BvbHlnb247XG4gICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgdmFyIGRpZmYgPSBsaW5lQW5pbWF0aW9uRGlmZih0aGlzLl9kYXRhLCBkYXRhLCB0aGlzLl9zdGFja2VkT25Qb2ludHMsIHN0YWNrZWRPblBvaW50cywgdGhpcy5fY29vcmRTeXMsIGNvb3JkU3lzLCB0aGlzLl92YWx1ZU9yaWdpbiwgdmFsdWVPcmlnaW4pO1xuICAgIHZhciBjdXJyZW50ID0gZGlmZi5jdXJyZW50O1xuICAgIHZhciBzdGFja2VkT25DdXJyZW50ID0gZGlmZi5zdGFja2VkT25DdXJyZW50O1xuICAgIHZhciBuZXh0ID0gZGlmZi5uZXh0O1xuICAgIHZhciBzdGFja2VkT25OZXh0ID0gZGlmZi5zdGFja2VkT25OZXh0O1xuXG4gICAgaWYgKHN0ZXApIHtcbiAgICAgIC8vIFRPRE8gSWYgc3RhY2tlZCBzZXJpZXMgaXMgbm90IHN0ZXBcbiAgICAgIGN1cnJlbnQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5jdXJyZW50LCBjb29yZFN5cywgc3RlcCk7XG4gICAgICBzdGFja2VkT25DdXJyZW50ID0gdHVyblBvaW50c0ludG9TdGVwKGRpZmYuc3RhY2tlZE9uQ3VycmVudCwgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgbmV4dCA9IHR1cm5Qb2ludHNJbnRvU3RlcChkaWZmLm5leHQsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgIHN0YWNrZWRPbk5leHQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5zdGFja2VkT25OZXh0LCBjb29yZFN5cywgc3RlcCk7XG4gICAgfSAvLyBEb24ndCBhcHBseSBhbmltYXRpb24gaWYgZGlmZiBpcyBsYXJnZS5cbiAgICAvLyBGb3IgYmV0dGVyIHJlc3VsdCBhbmQgYXZvaWQgbWVtb3J5IGV4cGxvc2lvbiBwcm9ibGVtcyBsaWtlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9pbmN1YmF0b3ItZWNoYXJ0cy9pc3N1ZXMvMTIyMjlcblxuXG4gICAgaWYgKGdldEJvdW5kaW5nRGlmZihjdXJyZW50LCBuZXh0KSA+IDMwMDAgfHwgcG9seWdvbiAmJiBnZXRCb3VuZGluZ0RpZmYoc3RhY2tlZE9uQ3VycmVudCwgc3RhY2tlZE9uTmV4dCkgPiAzMDAwKSB7XG4gICAgICBwb2x5bGluZS5zZXRTaGFwZSh7XG4gICAgICAgIHBvaW50czogbmV4dFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChwb2x5Z29uKSB7XG4gICAgICAgIHBvbHlnb24uc2V0U2hhcGUoe1xuICAgICAgICAgIHBvaW50czogbmV4dCxcbiAgICAgICAgICBzdGFja2VkT25Qb2ludHM6IHN0YWNrZWRPbk5leHRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwb2x5bGluZS5zaGFwZS5fX3BvaW50cyA9IGRpZmYuY3VycmVudDtcbiAgICBwb2x5bGluZS5zaGFwZS5wb2ludHMgPSBjdXJyZW50O1xuICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICBzaGFwZToge1xuICAgICAgICBwb2ludHM6IG5leHRcbiAgICAgIH1cbiAgICB9OyAvLyBBbHNvIGFuaW1hdGUgdGhlIG9yaWdpbmFsIHBvaW50cy5cbiAgICAvLyBJZiBwb2ludHMgcmVmZXJlbmNlIGlzIGNoYW5nZWQgd2hlbiB0dXJuaW5nIGludG8gc3RlcCBsaW5lLlxuXG4gICAgaWYgKGRpZmYuY3VycmVudCAhPT0gY3VycmVudCkge1xuICAgICAgdGFyZ2V0LnNoYXBlLl9fcG9pbnRzID0gZGlmZi5uZXh0O1xuICAgIH0gLy8gU3RvcCBwcmV2aW91cyBhbmltYXRpb24uXG5cblxuICAgIHBvbHlsaW5lLnN0b3BBbmltYXRpb24oKTtcbiAgICBncmFwaGljLnVwZGF0ZVByb3BzKHBvbHlsaW5lLCB0YXJnZXQsIHNlcmllc01vZGVsKTtcblxuICAgIGlmIChwb2x5Z29uKSB7XG4gICAgICBwb2x5Z29uLnNldFNoYXBlKHtcbiAgICAgICAgLy8gUmV1c2UgdGhlIHBvaW50cyB3aXRoIHBvbHlsaW5lLlxuICAgICAgICBwb2ludHM6IGN1cnJlbnQsXG4gICAgICAgIHN0YWNrZWRPblBvaW50czogc3RhY2tlZE9uQ3VycmVudFxuICAgICAgfSk7XG4gICAgICBwb2x5Z29uLnN0b3BBbmltYXRpb24oKTtcbiAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocG9seWdvbiwge1xuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIHN0YWNrZWRPblBvaW50czogc3RhY2tlZE9uTmV4dFxuICAgICAgICB9XG4gICAgICB9LCBzZXJpZXNNb2RlbCk7IC8vIElmIHVzZSBhdHRyIGRpcmVjdGx5IGluIHVwZGF0ZVByb3BzLlxuXG4gICAgICBpZiAocG9seWxpbmUuc2hhcGUucG9pbnRzICE9PSBwb2x5Z29uLnNoYXBlLnBvaW50cykge1xuICAgICAgICBwb2x5Z29uLnNoYXBlLnBvaW50cyA9IHBvbHlsaW5lLnNoYXBlLnBvaW50cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlZERhdGFJbmZvID0gW107XG4gICAgdmFyIGRpZmZTdGF0dXMgPSBkaWZmLnN0YXR1cztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZlN0YXR1cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNtZCA9IGRpZmZTdGF0dXNbaV0uY21kO1xuXG4gICAgICBpZiAoY21kID09PSAnPScpIHtcbiAgICAgICAgdmFyIGVsID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRpZmZTdGF0dXNbaV0uaWR4MSk7XG5cbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgdXBkYXRlZERhdGFJbmZvLnB1c2goe1xuICAgICAgICAgICAgZWw6IGVsLFxuICAgICAgICAgICAgcHRJZHg6IGkgLy8gSW5kZXggb2YgcG9pbnRzXG5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb2x5bGluZS5hbmltYXRvcnMgJiYgcG9seWxpbmUuYW5pbWF0b3JzLmxlbmd0aCkge1xuICAgICAgcG9seWxpbmUuYW5pbWF0b3JzWzBdLmR1cmluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBvbHlnb24gJiYgcG9seWdvbi5kaXJ0eVNoYXBlKCk7XG4gICAgICAgIHZhciBwb2ludHMgPSBwb2x5bGluZS5zaGFwZS5fX3BvaW50cztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZWREYXRhSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbCA9IHVwZGF0ZWREYXRhSW5mb1tpXS5lbDtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gdXBkYXRlZERhdGFJbmZvW2ldLnB0SWR4ICogMjtcbiAgICAgICAgICBlbC54ID0gcG9pbnRzW29mZnNldF07XG4gICAgICAgICAgZWwueSA9IHBvaW50c1tvZmZzZXQgKyAxXTtcbiAgICAgICAgICBlbC5tYXJrUmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBMaW5lVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcblxuICAgIHRoaXMuX2xpbmVHcm91cC5yZW1vdmVBbGwoKTtcblxuICAgIHRoaXMuX3N5bWJvbERyYXcucmVtb3ZlKHRydWUpOyAvLyBSZW1vdmUgdGVtcG9yYXJ5IGNyZWF0ZWQgZWxlbWVudHMgd2hlbiBoaWdobGlnaHRpbmdcblxuXG4gICAgb2xkRGF0YSAmJiBvbGREYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICBpZiAoZWwuX190ZW1wKSB7XG4gICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgIG9sZERhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3BvbHlsaW5lID0gdGhpcy5fcG9seWdvbiA9IHRoaXMuX2Nvb3JkU3lzID0gdGhpcy5fcG9pbnRzID0gdGhpcy5fc3RhY2tlZE9uUG9pbnRzID0gdGhpcy5fZW5kTGFiZWwgPSB0aGlzLl9kYXRhID0gbnVsbDtcbiAgfTtcblxuICBMaW5lVmlldy50eXBlID0gJ2xpbmUnO1xuICByZXR1cm4gTGluZVZpZXc7XG59KENoYXJ0Vmlldyk7XG5cbmV4cG9ydCBkZWZhdWx0IExpbmVWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBpc0RpbWVuc2lvblN0YWNrZWQgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9kYXRhU3RhY2tIZWxwZXInO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlRGF0YUNvb3JkSW5mbyhjb29yZFN5cywgZGF0YSwgdmFsdWVPcmlnaW4pIHtcbiAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgdmFyIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gIHZhciB2YWx1ZVN0YXJ0ID0gZ2V0VmFsdWVTdGFydCh2YWx1ZUF4aXMsIHZhbHVlT3JpZ2luKTtcbiAgdmFyIGJhc2VBeGlzRGltID0gYmFzZUF4aXMuZGltO1xuICB2YXIgdmFsdWVBeGlzRGltID0gdmFsdWVBeGlzLmRpbTtcbiAgdmFyIHZhbHVlRGltID0gZGF0YS5tYXBEaW1lbnNpb24odmFsdWVBeGlzRGltKTtcbiAgdmFyIGJhc2VEaW0gPSBkYXRhLm1hcERpbWVuc2lvbihiYXNlQXhpc0RpbSk7XG4gIHZhciBiYXNlRGF0YU9mZnNldCA9IHZhbHVlQXhpc0RpbSA9PT0gJ3gnIHx8IHZhbHVlQXhpc0RpbSA9PT0gJ3JhZGl1cycgPyAxIDogMDtcbiAgdmFyIGRpbXMgPSBtYXAoY29vcmRTeXMuZGltZW5zaW9ucywgZnVuY3Rpb24gKGNvb3JkRGltKSB7XG4gICAgcmV0dXJuIGRhdGEubWFwRGltZW5zaW9uKGNvb3JkRGltKTtcbiAgfSk7XG4gIHZhciBzdGFja2VkID0gZmFsc2U7XG4gIHZhciBzdGFja1Jlc3VsdERpbSA9IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja1Jlc3VsdERpbWVuc2lvbicpO1xuXG4gIGlmIChpc0RpbWVuc2lvblN0YWNrZWQoZGF0YSwgZGltc1swXVxuICAvKiwgZGltc1sxXSovXG4gICkpIHtcbiAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBzdGFja2VkID0gdHJ1ZTtcbiAgICBkaW1zWzBdID0gc3RhY2tSZXN1bHREaW07XG4gIH1cblxuICBpZiAoaXNEaW1lbnNpb25TdGFja2VkKGRhdGEsIGRpbXNbMV1cbiAgLyosIGRpbXNbMF0qL1xuICApKSB7XG4gICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgc3RhY2tlZCA9IHRydWU7XG4gICAgZGltc1sxXSA9IHN0YWNrUmVzdWx0RGltO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhRGltc0ZvclBvaW50OiBkaW1zLFxuICAgIHZhbHVlU3RhcnQ6IHZhbHVlU3RhcnQsXG4gICAgdmFsdWVBeGlzRGltOiB2YWx1ZUF4aXNEaW0sXG4gICAgYmFzZUF4aXNEaW06IGJhc2VBeGlzRGltLFxuICAgIHN0YWNrZWQ6ICEhc3RhY2tlZCxcbiAgICB2YWx1ZURpbTogdmFsdWVEaW0sXG4gICAgYmFzZURpbTogYmFzZURpbSxcbiAgICBiYXNlRGF0YU9mZnNldDogYmFzZURhdGFPZmZzZXQsXG4gICAgc3RhY2tlZE92ZXJEaW1lbnNpb246IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja2VkT3ZlckRpbWVuc2lvbicpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlU3RhcnQodmFsdWVBeGlzLCB2YWx1ZU9yaWdpbikge1xuICB2YXIgdmFsdWVTdGFydCA9IDA7XG4gIHZhciBleHRlbnQgPSB2YWx1ZUF4aXMuc2NhbGUuZ2V0RXh0ZW50KCk7XG5cbiAgaWYgKHZhbHVlT3JpZ2luID09PSAnc3RhcnQnKSB7XG4gICAgdmFsdWVTdGFydCA9IGV4dGVudFswXTtcbiAgfSBlbHNlIGlmICh2YWx1ZU9yaWdpbiA9PT0gJ2VuZCcpIHtcbiAgICB2YWx1ZVN0YXJ0ID0gZXh0ZW50WzFdO1xuICB9IC8vIGF1dG9cbiAgZWxzZSB7XG4gICAgICAvLyBCb3RoIHBvc2l0aXZlXG4gICAgICBpZiAoZXh0ZW50WzBdID4gMCkge1xuICAgICAgICB2YWx1ZVN0YXJ0ID0gZXh0ZW50WzBdO1xuICAgICAgfSAvLyBCb3RoIG5lZ2F0aXZlXG4gICAgICBlbHNlIGlmIChleHRlbnRbMV0gPCAwKSB7XG4gICAgICAgICAgdmFsdWVTdGFydCA9IGV4dGVudFsxXTtcbiAgICAgICAgfSAvLyBJZiBpcyBvbmUgcG9zaXRpdmUsIGFuZCBvbmUgbmVnYXRpdmUsIG9uWmVybyBzaGFsbCBiZSB0cnVlXG5cbiAgICB9XG5cbiAgcmV0dXJuIHZhbHVlU3RhcnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGFja2VkT25Qb2ludChkYXRhQ29vcmRJbmZvLCBjb29yZFN5cywgZGF0YSwgaWR4KSB7XG4gIHZhciB2YWx1ZSA9IE5hTjtcblxuICBpZiAoZGF0YUNvb3JkSW5mby5zdGFja2VkKSB7XG4gICAgdmFsdWUgPSBkYXRhLmdldChkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZE92ZXJEaW1lbnNpb24nKSwgaWR4KTtcbiAgfVxuXG4gIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IGRhdGFDb29yZEluZm8udmFsdWVTdGFydDtcbiAgfVxuXG4gIHZhciBiYXNlRGF0YU9mZnNldCA9IGRhdGFDb29yZEluZm8uYmFzZURhdGFPZmZzZXQ7XG4gIHZhciBzdGFja2VkRGF0YSA9IFtdO1xuICBzdGFja2VkRGF0YVtiYXNlRGF0YU9mZnNldF0gPSBkYXRhLmdldChkYXRhQ29vcmRJbmZvLmJhc2VEaW0sIGlkeCk7XG4gIHN0YWNrZWREYXRhWzEgLSBiYXNlRGF0YU9mZnNldF0gPSB2YWx1ZTtcbiAgcmV0dXJuIGNvb3JkU3lzLmRhdGFUb1BvaW50KHN0YWNrZWREYXRhKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IExpbmVTZXJpZXMgZnJvbSAnLi9MaW5lU2VyaWVzJztcbmltcG9ydCBMaW5lVmlldyBmcm9tICcuL0xpbmVWaWV3JzsgLy8gSW4gY2FzZSBkZXZlbG9wZXIgZm9yZ2V0IHRvIGluY2x1ZGUgZ3JpZCBjb21wb25lbnRcblxuaW1wb3J0IGxheW91dFBvaW50cyBmcm9tICcuLi8uLi9sYXlvdXQvcG9pbnRzJztcbmltcG9ydCBkYXRhU2FtcGxlIGZyb20gJy4uLy4uL3Byb2Nlc3Nvci9kYXRhU2FtcGxlJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDaGFydFZpZXcoTGluZVZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChMaW5lU2VyaWVzKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KGxheW91dFBvaW50cygnbGluZScsIHRydWUpKTsgLy8gRG93biBzYW1wbGUgYWZ0ZXIgZmlsdGVyXG5cbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJvY2Vzc29yKHJlZ2lzdGVycy5QUklPUklUWS5QUk9DRVNTT1IuU1RBVElTVElDLCBkYXRhU2FtcGxlKCdsaW5lJykpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBwcmVwYXJlRGF0YUNvb3JkSW5mbywgZ2V0U3RhY2tlZE9uUG9pbnQgfSBmcm9tICcuL2hlbHBlcic7XG5pbXBvcnQgeyBjcmVhdGVGbG9hdDMyQXJyYXkgfSBmcm9tICcuLi8uLi91dGlsL3ZlbmRvcic7XG5cbmZ1bmN0aW9uIGRpZmZEYXRhKG9sZERhdGEsIG5ld0RhdGEpIHtcbiAgdmFyIGRpZmZSZXN1bHQgPSBbXTtcbiAgbmV3RGF0YS5kaWZmKG9sZERhdGEpLmFkZChmdW5jdGlvbiAoaWR4KSB7XG4gICAgZGlmZlJlc3VsdC5wdXNoKHtcbiAgICAgIGNtZDogJysnLFxuICAgICAgaWR4OiBpZHhcbiAgICB9KTtcbiAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgIGRpZmZSZXN1bHQucHVzaCh7XG4gICAgICBjbWQ6ICc9JyxcbiAgICAgIGlkeDogb2xkSWR4LFxuICAgICAgaWR4MTogbmV3SWR4XG4gICAgfSk7XG4gIH0pLnJlbW92ZShmdW5jdGlvbiAoaWR4KSB7XG4gICAgZGlmZlJlc3VsdC5wdXNoKHtcbiAgICAgIGNtZDogJy0nLFxuICAgICAgaWR4OiBpZHhcbiAgICB9KTtcbiAgfSkuZXhlY3V0ZSgpO1xuICByZXR1cm4gZGlmZlJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGluZUFuaW1hdGlvbkRpZmYob2xkRGF0YSwgbmV3RGF0YSwgb2xkU3RhY2tlZE9uUG9pbnRzLCBuZXdTdGFja2VkT25Qb2ludHMsIG9sZENvb3JkU3lzLCBuZXdDb29yZFN5cywgb2xkVmFsdWVPcmlnaW4sIG5ld1ZhbHVlT3JpZ2luKSB7XG4gIHZhciBkaWZmID0gZGlmZkRhdGEob2xkRGF0YSwgbmV3RGF0YSk7IC8vIGxldCBuZXdJZExpc3QgPSBuZXdEYXRhLm1hcEFycmF5KG5ld0RhdGEuZ2V0SWQpO1xuICAvLyBsZXQgb2xkSWRMaXN0ID0gb2xkRGF0YS5tYXBBcnJheShvbGREYXRhLmdldElkKTtcbiAgLy8gY29udmVydFRvSW50SWQobmV3SWRMaXN0LCBvbGRJZExpc3QpO1xuICAvLyAvLyBGSVhNRSBPbmUgZGF0YSA/XG4gIC8vIGRpZmYgPSBhcnJheURpZmYob2xkSWRMaXN0LCBuZXdJZExpc3QpO1xuXG4gIHZhciBjdXJyUG9pbnRzID0gW107XG4gIHZhciBuZXh0UG9pbnRzID0gW107IC8vIFBvaW50cyBmb3Igc3RhY2tpbmcgYmFzZSBsaW5lXG5cbiAgdmFyIGN1cnJTdGFja2VkUG9pbnRzID0gW107XG4gIHZhciBuZXh0U3RhY2tlZFBvaW50cyA9IFtdO1xuICB2YXIgc3RhdHVzID0gW107XG4gIHZhciBzb3J0ZWRJbmRpY2VzID0gW107XG4gIHZhciByYXdJbmRpY2VzID0gW107XG4gIHZhciBuZXdEYXRhT2xkQ29vcmRJbmZvID0gcHJlcGFyZURhdGFDb29yZEluZm8ob2xkQ29vcmRTeXMsIG5ld0RhdGEsIG9sZFZhbHVlT3JpZ2luKTtcbiAgdmFyIG9sZERhdGFOZXdDb29yZEluZm8gPSBwcmVwYXJlRGF0YUNvb3JkSW5mbyhuZXdDb29yZFN5cywgb2xkRGF0YSwgbmV3VmFsdWVPcmlnaW4pO1xuICB2YXIgb2xkUG9pbnRzID0gb2xkRGF0YS5nZXRMYXlvdXQoJ3BvaW50cycpIHx8IFtdO1xuICB2YXIgbmV3UG9pbnRzID0gbmV3RGF0YS5nZXRMYXlvdXQoJ3BvaW50cycpIHx8IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaWZmSXRlbSA9IGRpZmZbaV07XG4gICAgdmFyIHBvaW50QWRkZWQgPSB0cnVlO1xuICAgIHZhciBvbGRJZHgyID0gdm9pZCAwO1xuICAgIHZhciBuZXdJZHgyID0gdm9pZCAwOyAvLyBGSVhNRSwgYW5pbWF0aW9uIGlzIG5vdCBzbyBwZXJmZWN0IHdoZW4gZGF0YVpvb20gd2luZG93IG1vdmVzIGZhc3RcbiAgICAvLyBXaGljaCBpcyBpbiBjYXNlIHJlbXZvaW5nIG9yIGFkZCBtb3JlIHRoYW4gb25lIGRhdGEgaW4gdGhlIHRhaWwgb3IgaGVhZFxuXG4gICAgc3dpdGNoIChkaWZmSXRlbS5jbWQpIHtcbiAgICAgIGNhc2UgJz0nOlxuICAgICAgICBvbGRJZHgyID0gZGlmZkl0ZW0uaWR4ICogMjtcbiAgICAgICAgbmV3SWR4MiA9IGRpZmZJdGVtLmlkeDEgKiAyO1xuICAgICAgICB2YXIgY3VycmVudFggPSBvbGRQb2ludHNbb2xkSWR4Ml07XG4gICAgICAgIHZhciBjdXJyZW50WSA9IG9sZFBvaW50c1tvbGRJZHgyICsgMV07XG4gICAgICAgIHZhciBuZXh0WCA9IG5ld1BvaW50c1tuZXdJZHgyXTtcbiAgICAgICAgdmFyIG5leHRZID0gbmV3UG9pbnRzW25ld0lkeDIgKyAxXTsgLy8gSWYgcHJldmlvdXMgZGF0YSBpcyBOYU4sIHVzZSBuZXh0IHBvaW50IGRpcmVjdGx5XG5cbiAgICAgICAgaWYgKGlzTmFOKGN1cnJlbnRYKSB8fCBpc05hTihjdXJyZW50WSkpIHtcbiAgICAgICAgICBjdXJyZW50WCA9IG5leHRYO1xuICAgICAgICAgIGN1cnJlbnRZID0gbmV4dFk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyUG9pbnRzLnB1c2goY3VycmVudFgsIGN1cnJlbnRZKTtcbiAgICAgICAgbmV4dFBvaW50cy5wdXNoKG5leHRYLCBuZXh0WSk7XG4gICAgICAgIGN1cnJTdGFja2VkUG9pbnRzLnB1c2gob2xkU3RhY2tlZE9uUG9pbnRzW29sZElkeDJdLCBvbGRTdGFja2VkT25Qb2ludHNbb2xkSWR4MiArIDFdKTtcbiAgICAgICAgbmV4dFN0YWNrZWRQb2ludHMucHVzaChuZXdTdGFja2VkT25Qb2ludHNbbmV3SWR4Ml0sIG5ld1N0YWNrZWRPblBvaW50c1tuZXdJZHgyICsgMV0pO1xuICAgICAgICByYXdJbmRpY2VzLnB1c2gobmV3RGF0YS5nZXRSYXdJbmRleChkaWZmSXRlbS5pZHgxKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcrJzpcbiAgICAgICAgdmFyIG5ld0lkeCA9IGRpZmZJdGVtLmlkeDtcbiAgICAgICAgdmFyIG5ld0RhdGFEaW1zRm9yUG9pbnQgPSBuZXdEYXRhT2xkQ29vcmRJbmZvLmRhdGFEaW1zRm9yUG9pbnQ7XG4gICAgICAgIHZhciBvbGRQdCA9IG9sZENvb3JkU3lzLmRhdGFUb1BvaW50KFtuZXdEYXRhLmdldChuZXdEYXRhRGltc0ZvclBvaW50WzBdLCBuZXdJZHgpLCBuZXdEYXRhLmdldChuZXdEYXRhRGltc0ZvclBvaW50WzFdLCBuZXdJZHgpXSk7XG4gICAgICAgIG5ld0lkeDIgPSBuZXdJZHggKiAyO1xuICAgICAgICBjdXJyUG9pbnRzLnB1c2gob2xkUHRbMF0sIG9sZFB0WzFdKTtcbiAgICAgICAgbmV4dFBvaW50cy5wdXNoKG5ld1BvaW50c1tuZXdJZHgyXSwgbmV3UG9pbnRzW25ld0lkeDIgKyAxXSk7XG4gICAgICAgIHZhciBzdGFja2VkT25Qb2ludCA9IGdldFN0YWNrZWRPblBvaW50KG5ld0RhdGFPbGRDb29yZEluZm8sIG9sZENvb3JkU3lzLCBuZXdEYXRhLCBuZXdJZHgpO1xuICAgICAgICBjdXJyU3RhY2tlZFBvaW50cy5wdXNoKHN0YWNrZWRPblBvaW50WzBdLCBzdGFja2VkT25Qb2ludFsxXSk7XG4gICAgICAgIG5leHRTdGFja2VkUG9pbnRzLnB1c2gobmV3U3RhY2tlZE9uUG9pbnRzW25ld0lkeDJdLCBuZXdTdGFja2VkT25Qb2ludHNbbmV3SWR4MiArIDFdKTtcbiAgICAgICAgcmF3SW5kaWNlcy5wdXNoKG5ld0RhdGEuZ2V0UmF3SW5kZXgobmV3SWR4KSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICctJzpcbiAgICAgICAgdmFyIG9sZElkeCA9IGRpZmZJdGVtLmlkeDtcbiAgICAgICAgdmFyIHJhd0luZGV4ID0gb2xkRGF0YS5nZXRSYXdJbmRleChvbGRJZHgpO1xuICAgICAgICB2YXIgb2xkRGF0YURpbXNGb3JQb2ludCA9IG9sZERhdGFOZXdDb29yZEluZm8uZGF0YURpbXNGb3JQb2ludDtcbiAgICAgICAgb2xkSWR4MiA9IG9sZElkeCAqIDI7IC8vIERhdGEgaXMgcmVwbGFjZWQuIEluIHRoZSBjYXNlIG9mIGR5bmFtaWMgZGF0YSBxdWV1ZVxuICAgICAgICAvLyBGSVhNRSBGSVhNRSBGSVhNRVxuXG4gICAgICAgIGlmIChyYXdJbmRleCAhPT0gb2xkSWR4KSB7XG4gICAgICAgICAgdmFyIG5ld1B0ID0gbmV3Q29vcmRTeXMuZGF0YVRvUG9pbnQoW29sZERhdGEuZ2V0KG9sZERhdGFEaW1zRm9yUG9pbnRbMF0sIG9sZElkeCksIG9sZERhdGEuZ2V0KG9sZERhdGFEaW1zRm9yUG9pbnRbMV0sIG9sZElkeCldKTtcbiAgICAgICAgICB2YXIgbmV3U3RhY2tlZE9uUHQgPSBnZXRTdGFja2VkT25Qb2ludChvbGREYXRhTmV3Q29vcmRJbmZvLCBuZXdDb29yZFN5cywgb2xkRGF0YSwgb2xkSWR4KTtcbiAgICAgICAgICBjdXJyUG9pbnRzLnB1c2gob2xkUG9pbnRzW29sZElkeDJdLCBvbGRQb2ludHNbb2xkSWR4MiArIDFdKTtcbiAgICAgICAgICBuZXh0UG9pbnRzLnB1c2gobmV3UHRbMF0sIG5ld1B0WzFdKTtcbiAgICAgICAgICBjdXJyU3RhY2tlZFBvaW50cy5wdXNoKG9sZFN0YWNrZWRPblBvaW50c1tvbGRJZHgyXSwgb2xkU3RhY2tlZE9uUG9pbnRzW29sZElkeDIgKyAxXSk7XG4gICAgICAgICAgbmV4dFN0YWNrZWRQb2ludHMucHVzaChuZXdTdGFja2VkT25QdFswXSwgbmV3U3RhY2tlZE9uUHRbMV0pO1xuICAgICAgICAgIHJhd0luZGljZXMucHVzaChyYXdJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnRBZGRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICB9IC8vIE9yaWdpbmFsIGluZGljZXNcblxuXG4gICAgaWYgKHBvaW50QWRkZWQpIHtcbiAgICAgIHN0YXR1cy5wdXNoKGRpZmZJdGVtKTtcbiAgICAgIHNvcnRlZEluZGljZXMucHVzaChzb3J0ZWRJbmRpY2VzLmxlbmd0aCk7XG4gICAgfVxuICB9IC8vIERpZmYgcmVzdWx0IG1heSBiZSBjcm9zc2VkIGlmIGFsbCBpdGVtcyBhcmUgY2hhbmdlZFxuICAvLyBTb3J0IGJ5IGRhdGEgaW5kZXhcblxuXG4gIHNvcnRlZEluZGljZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiByYXdJbmRpY2VzW2FdIC0gcmF3SW5kaWNlc1tiXTtcbiAgfSk7XG4gIHZhciBsZW4gPSBjdXJyUG9pbnRzLmxlbmd0aDtcbiAgdmFyIHNvcnRlZEN1cnJQb2ludHMgPSBjcmVhdGVGbG9hdDMyQXJyYXkobGVuKTtcbiAgdmFyIHNvcnRlZE5leHRQb2ludHMgPSBjcmVhdGVGbG9hdDMyQXJyYXkobGVuKTtcbiAgdmFyIHNvcnRlZEN1cnJTdGFja2VkUG9pbnRzID0gY3JlYXRlRmxvYXQzMkFycmF5KGxlbik7XG4gIHZhciBzb3J0ZWROZXh0U3RhY2tlZFBvaW50cyA9IGNyZWF0ZUZsb2F0MzJBcnJheShsZW4pO1xuICB2YXIgc29ydGVkU3RhdHVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWRJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlkeCA9IHNvcnRlZEluZGljZXNbaV07XG4gICAgdmFyIGkyID0gaSAqIDI7XG4gICAgdmFyIGlkeDIgPSBpZHggKiAyO1xuICAgIHNvcnRlZEN1cnJQb2ludHNbaTJdID0gY3VyclBvaW50c1tpZHgyXTtcbiAgICBzb3J0ZWRDdXJyUG9pbnRzW2kyICsgMV0gPSBjdXJyUG9pbnRzW2lkeDIgKyAxXTtcbiAgICBzb3J0ZWROZXh0UG9pbnRzW2kyXSA9IG5leHRQb2ludHNbaWR4Ml07XG4gICAgc29ydGVkTmV4dFBvaW50c1tpMiArIDFdID0gbmV4dFBvaW50c1tpZHgyICsgMV07XG4gICAgc29ydGVkQ3VyclN0YWNrZWRQb2ludHNbaTJdID0gY3VyclN0YWNrZWRQb2ludHNbaWR4Ml07XG4gICAgc29ydGVkQ3VyclN0YWNrZWRQb2ludHNbaTIgKyAxXSA9IGN1cnJTdGFja2VkUG9pbnRzW2lkeDIgKyAxXTtcbiAgICBzb3J0ZWROZXh0U3RhY2tlZFBvaW50c1tpMl0gPSBuZXh0U3RhY2tlZFBvaW50c1tpZHgyXTtcbiAgICBzb3J0ZWROZXh0U3RhY2tlZFBvaW50c1tpMiArIDFdID0gbmV4dFN0YWNrZWRQb2ludHNbaWR4MiArIDFdO1xuICAgIHNvcnRlZFN0YXR1c1tpXSA9IHN0YXR1c1tpZHhdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBzb3J0ZWRDdXJyUG9pbnRzLFxuICAgIG5leHQ6IHNvcnRlZE5leHRQb2ludHMsXG4gICAgc3RhY2tlZE9uQ3VycmVudDogc29ydGVkQ3VyclN0YWNrZWRQb2ludHMsXG4gICAgc3RhY2tlZE9uTmV4dDogc29ydGVkTmV4dFN0YWNrZWRQb2ludHMsXG4gICAgc3RhdHVzOiBzb3J0ZWRTdGF0dXNcbiAgfTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7IC8vIFBvbHkgcGF0aCBzdXBwb3J0IE5hTiBwb2ludFxuXG5pbXBvcnQgUGF0aCBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL1BhdGgnO1xuaW1wb3J0IFBhdGhQcm94eSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eSc7XG5pbXBvcnQgeyBjdWJpY1Jvb3RBdCwgY3ViaWNBdCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvY3VydmUnO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG5cbmZ1bmN0aW9uIGlzUG9pbnROdWxsKHgsIHkpIHtcbiAgcmV0dXJuIGlzTmFOKHgpIHx8IGlzTmFOKHkpO1xufVxuLyoqXG4gKiBEcmF3IHNtb290aGVkIGxpbmUgaW4gbm9uLW1vbm90b25lLCBpbiBtYXkgY2F1c2UgdW5kZXNpcmVkIGN1cnZlIGluIGV4dHJlbWVcbiAqIHNpdHVhdGlvbnMuIFRoaXMgc2hvdWxkIGJlIHVzZWQgd2hlbiBwb2ludHMgYXJlIG5vbi1tb25vdG9uZSBuZWl0aGVyIGluIHggb3JcbiAqIHkgZGltZW5zaW9uLlxuICovXG5cblxuZnVuY3Rpb24gZHJhd1NlZ21lbnQoY3R4LCBwb2ludHMsIHN0YXJ0LCBzZWdMZW4sIGFsbExlbiwgZGlyLCBzbW9vdGgsIHNtb290aE1vbm90b25lLCBjb25uZWN0TnVsbHMpIHtcbiAgdmFyIHByZXZYO1xuICB2YXIgcHJldlk7XG4gIHZhciBjcHgwO1xuICB2YXIgY3B5MDtcbiAgdmFyIGNweDE7XG4gIHZhciBjcHkxO1xuICB2YXIgaWR4ID0gc3RhcnQ7XG4gIHZhciBrID0gMDtcblxuICBmb3IgKDsgayA8IHNlZ0xlbjsgaysrKSB7XG4gICAgdmFyIHggPSBwb2ludHNbaWR4ICogMl07XG4gICAgdmFyIHkgPSBwb2ludHNbaWR4ICogMiArIDFdO1xuXG4gICAgaWYgKGlkeCA+PSBhbGxMZW4gfHwgaWR4IDwgMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGlzUG9pbnROdWxsKHgsIHkpKSB7XG4gICAgICBpZiAoY29ubmVjdE51bGxzKSB7XG4gICAgICAgIGlkeCArPSBkaXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaWR4ID09PSBzdGFydCkge1xuICAgICAgY3R4W2RpciA+IDAgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXSh4LCB5KTtcbiAgICAgIGNweDAgPSB4O1xuICAgICAgY3B5MCA9IHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkeCA9IHggLSBwcmV2WDtcbiAgICAgIHZhciBkeSA9IHkgLSBwcmV2WTsgLy8gSWdub3JlIHRpbnkgc2VnbWVudC5cblxuICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDwgMC41KSB7XG4gICAgICAgIGlkeCArPSBkaXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc21vb3RoID4gMCkge1xuICAgICAgICB2YXIgbmV4dElkeCA9IGlkeCArIGRpcjtcbiAgICAgICAgdmFyIG5leHRYID0gcG9pbnRzW25leHRJZHggKiAyXTtcbiAgICAgICAgdmFyIG5leHRZID0gcG9pbnRzW25leHRJZHggKiAyICsgMV07XG4gICAgICAgIHZhciB0bXBLID0gayArIDE7XG5cbiAgICAgICAgaWYgKGNvbm5lY3ROdWxscykge1xuICAgICAgICAgIC8vIEZpbmQgbmV4dCBwb2ludCBub3QgbnVsbFxuICAgICAgICAgIHdoaWxlIChpc1BvaW50TnVsbChuZXh0WCwgbmV4dFkpICYmIHRtcEsgPCBzZWdMZW4pIHtcbiAgICAgICAgICAgIHRtcEsrKztcbiAgICAgICAgICAgIG5leHRJZHggKz0gZGlyO1xuICAgICAgICAgICAgbmV4dFggPSBwb2ludHNbbmV4dElkeCAqIDJdO1xuICAgICAgICAgICAgbmV4dFkgPSBwb2ludHNbbmV4dElkeCAqIDIgKyAxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmF0aW9OZXh0U2VnID0gMC41O1xuICAgICAgICB2YXIgdnggPSAwO1xuICAgICAgICB2YXIgdnkgPSAwO1xuICAgICAgICB2YXIgbmV4dENweDAgPSB2b2lkIDA7XG4gICAgICAgIHZhciBuZXh0Q3B5MCA9IHZvaWQgMDsgLy8gSXMgbGFzdCBwb2ludFxuXG4gICAgICAgIGlmICh0bXBLID49IHNlZ0xlbiB8fCBpc1BvaW50TnVsbChuZXh0WCwgbmV4dFkpKSB7XG4gICAgICAgICAgY3B4MSA9IHg7XG4gICAgICAgICAgY3B5MSA9IHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdnggPSBuZXh0WCAtIHByZXZYO1xuICAgICAgICAgIHZ5ID0gbmV4dFkgLSBwcmV2WTtcbiAgICAgICAgICB2YXIgZHgwID0geCAtIHByZXZYO1xuICAgICAgICAgIHZhciBkeDEgPSBuZXh0WCAtIHg7XG4gICAgICAgICAgdmFyIGR5MCA9IHkgLSBwcmV2WTtcbiAgICAgICAgICB2YXIgZHkxID0gbmV4dFkgLSB5O1xuICAgICAgICAgIHZhciBsZW5QcmV2U2VnID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBsZW5OZXh0U2VnID0gdm9pZCAwO1xuXG4gICAgICAgICAgaWYgKHNtb290aE1vbm90b25lID09PSAneCcpIHtcbiAgICAgICAgICAgIGxlblByZXZTZWcgPSBNYXRoLmFicyhkeDApO1xuICAgICAgICAgICAgbGVuTmV4dFNlZyA9IE1hdGguYWJzKGR4MSk7XG4gICAgICAgICAgICBjcHgxID0geCAtIGxlblByZXZTZWcgKiBzbW9vdGg7XG4gICAgICAgICAgICBjcHkxID0geTtcbiAgICAgICAgICAgIG5leHRDcHgwID0geCArIGxlblByZXZTZWcgKiBzbW9vdGg7XG4gICAgICAgICAgICBuZXh0Q3B5MCA9IHk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzbW9vdGhNb25vdG9uZSA9PT0gJ3knKSB7XG4gICAgICAgICAgICBsZW5QcmV2U2VnID0gTWF0aC5hYnMoZHkwKTtcbiAgICAgICAgICAgIGxlbk5leHRTZWcgPSBNYXRoLmFicyhkeTEpO1xuICAgICAgICAgICAgY3B4MSA9IHg7XG4gICAgICAgICAgICBjcHkxID0geSAtIGxlblByZXZTZWcgKiBzbW9vdGg7XG4gICAgICAgICAgICBuZXh0Q3B4MCA9IHg7XG4gICAgICAgICAgICBuZXh0Q3B5MCA9IHkgKyBsZW5QcmV2U2VnICogc21vb3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW5QcmV2U2VnID0gTWF0aC5zcXJ0KGR4MCAqIGR4MCArIGR5MCAqIGR5MCk7XG4gICAgICAgICAgICBsZW5OZXh0U2VnID0gTWF0aC5zcXJ0KGR4MSAqIGR4MSArIGR5MSAqIGR5MSk7IC8vIFVzZSByYXRpbyBvZiBzZWcgbGVuZ3RoXG5cbiAgICAgICAgICAgIHJhdGlvTmV4dFNlZyA9IGxlbk5leHRTZWcgLyAobGVuTmV4dFNlZyArIGxlblByZXZTZWcpO1xuICAgICAgICAgICAgY3B4MSA9IHggLSB2eCAqIHNtb290aCAqICgxIC0gcmF0aW9OZXh0U2VnKTtcbiAgICAgICAgICAgIGNweTEgPSB5IC0gdnkgKiBzbW9vdGggKiAoMSAtIHJhdGlvTmV4dFNlZyk7IC8vIGNwMCBvZiBuZXh0IHNlZ21lbnRcblxuICAgICAgICAgICAgbmV4dENweDAgPSB4ICsgdnggKiBzbW9vdGggKiByYXRpb05leHRTZWc7XG4gICAgICAgICAgICBuZXh0Q3B5MCA9IHkgKyB2eSAqIHNtb290aCAqIHJhdGlvTmV4dFNlZzsgLy8gU21vb3RoIGNvbnN0cmFpbnQgYmV0d2VlbiBwb2ludCBhbmQgbmV4dCBwb2ludC5cbiAgICAgICAgICAgIC8vIEF2b2lkIGV4Y2VlZGluZyBleHRyZW1lIGFmdGVyIHNtb290aGluZy5cblxuICAgICAgICAgICAgbmV4dENweDAgPSBtYXRoTWluKG5leHRDcHgwLCBtYXRoTWF4KG5leHRYLCB4KSk7XG4gICAgICAgICAgICBuZXh0Q3B5MCA9IG1hdGhNaW4obmV4dENweTAsIG1hdGhNYXgobmV4dFksIHkpKTtcbiAgICAgICAgICAgIG5leHRDcHgwID0gbWF0aE1heChuZXh0Q3B4MCwgbWF0aE1pbihuZXh0WCwgeCkpO1xuICAgICAgICAgICAgbmV4dENweTAgPSBtYXRoTWF4KG5leHRDcHkwLCBtYXRoTWluKG5leHRZLCB5KSk7IC8vIFJlY2xhY3VsYXRlIGNwMSBiYXNlZCBvbiB0aGUgYWRqdXN0ZWQgY3AwIG9mIG5leHQgc2VnLlxuXG4gICAgICAgICAgICB2eCA9IG5leHRDcHgwIC0geDtcbiAgICAgICAgICAgIHZ5ID0gbmV4dENweTAgLSB5O1xuICAgICAgICAgICAgY3B4MSA9IHggLSB2eCAqIGxlblByZXZTZWcgLyBsZW5OZXh0U2VnO1xuICAgICAgICAgICAgY3B5MSA9IHkgLSB2eSAqIGxlblByZXZTZWcgLyBsZW5OZXh0U2VnOyAvLyBTbW9vdGggY29uc3RyYWludCBiZXR3ZWVuIHBvaW50IGFuZCBwcmV2IHBvaW50LlxuICAgICAgICAgICAgLy8gQXZvaWQgZXhjZWVkaW5nIGV4dHJlbWUgYWZ0ZXIgc21vb3RoaW5nLlxuXG4gICAgICAgICAgICBjcHgxID0gbWF0aE1pbihjcHgxLCBtYXRoTWF4KHByZXZYLCB4KSk7XG4gICAgICAgICAgICBjcHkxID0gbWF0aE1pbihjcHkxLCBtYXRoTWF4KHByZXZZLCB5KSk7XG4gICAgICAgICAgICBjcHgxID0gbWF0aE1heChjcHgxLCBtYXRoTWluKHByZXZYLCB4KSk7XG4gICAgICAgICAgICBjcHkxID0gbWF0aE1heChjcHkxLCBtYXRoTWluKHByZXZZLCB5KSk7IC8vIEFkanVzdCBuZXh0IGNwMCBhZ2Fpbi5cblxuICAgICAgICAgICAgdnggPSB4IC0gY3B4MTtcbiAgICAgICAgICAgIHZ5ID0geSAtIGNweTE7XG4gICAgICAgICAgICBuZXh0Q3B4MCA9IHggKyB2eCAqIGxlbk5leHRTZWcgLyBsZW5QcmV2U2VnO1xuICAgICAgICAgICAgbmV4dENweTAgPSB5ICsgdnkgKiBsZW5OZXh0U2VnIC8gbGVuUHJldlNlZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjcHgwLCBjcHkwLCBjcHgxLCBjcHkxLCB4LCB5KTtcbiAgICAgICAgY3B4MCA9IG5leHRDcHgwO1xuICAgICAgICBjcHkwID0gbmV4dENweTA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZYID0geDtcbiAgICBwcmV2WSA9IHk7XG4gICAgaWR4ICs9IGRpcjtcbiAgfVxuXG4gIHJldHVybiBrO1xufVxuXG52YXIgRUNQb2x5bGluZVNoYXBlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRUNQb2x5bGluZVNoYXBlKCkge1xuICAgIHRoaXMuc21vb3RoID0gMDtcbiAgICB0aGlzLnNtb290aENvbnN0cmFpbnQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIEVDUG9seWxpbmVTaGFwZTtcbn0oKTtcblxudmFyIEVDUG9seWxpbmUgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRUNQb2x5bGluZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBFQ1BvbHlsaW5lKG9wdHMpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9ICdlYy1wb2x5bGluZSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgRUNQb2x5bGluZS5wcm90b3R5cGUuZ2V0RGVmYXVsdFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgIGZpbGw6IG51bGxcbiAgICB9O1xuICB9O1xuXG4gIEVDUG9seWxpbmUucHJvdG90eXBlLmdldERlZmF1bHRTaGFwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEVDUG9seWxpbmVTaGFwZSgpO1xuICB9O1xuXG4gIEVDUG9seWxpbmUucHJvdG90eXBlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGggLyAyOyAvLyBjb25zdCByZXN1bHQgPSBnZXRCb3VuZGluZ0JveChwb2ludHMsIHNoYXBlLnNtb290aENvbnN0cmFpbnQpO1xuXG4gICAgaWYgKHNoYXBlLmNvbm5lY3ROdWxscykge1xuICAgICAgLy8gTXVzdCByZW1vdmUgZmlyc3QgYW5kIGxhc3QgbnVsbCB2YWx1ZXMgYXZvaWQgZHJhdyBlcnJvciBpbiBwb2x5Z29uXG4gICAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgaWYgKCFpc1BvaW50TnVsbChwb2ludHNbbGVuICogMiAtIDJdLCBwb2ludHNbbGVuICogMiAtIDFdKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc1BvaW50TnVsbChwb2ludHNbaSAqIDJdLCBwb2ludHNbaSAqIDIgKyAxXSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpICs9IGRyYXdTZWdtZW50KGN0eCwgcG9pbnRzLCBpLCBsZW4sIGxlbiwgMSwgc2hhcGUuc21vb3RoLCBzaGFwZS5zbW9vdGhNb25vdG9uZSwgc2hhcGUuY29ubmVjdE51bGxzKSArIDE7XG4gICAgfVxuICB9O1xuXG4gIEVDUG9seWxpbmUucHJvdG90eXBlLmdldFBvaW50T24gPSBmdW5jdGlvbiAoeE9yWSwgZGltKSB7XG4gICAgaWYgKCF0aGlzLnBhdGgpIHtcbiAgICAgIHRoaXMuY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgICB0aGlzLmJ1aWxkUGF0aCh0aGlzLnBhdGgsIHRoaXMuc2hhcGUpO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgIHZhciBkYXRhID0gcGF0aC5kYXRhO1xuICAgIHZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xuICAgIHZhciB4MDtcbiAgICB2YXIgeTA7XG4gICAgdmFyIGlzRGltWCA9IGRpbSA9PT0gJ3gnO1xuICAgIHZhciByb290cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgIHZhciBjbWQgPSBkYXRhW2krK107XG4gICAgICB2YXIgeCA9IHZvaWQgMDtcbiAgICAgIHZhciB5ID0gdm9pZCAwO1xuICAgICAgdmFyIHgyID0gdm9pZCAwO1xuICAgICAgdmFyIHkyID0gdm9pZCAwO1xuICAgICAgdmFyIHgzID0gdm9pZCAwO1xuICAgICAgdmFyIHkzID0gdm9pZCAwO1xuICAgICAgdmFyIHQgPSB2b2lkIDA7XG5cbiAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgeDAgPSBkYXRhW2krK107XG4gICAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICB4ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHkgPSBkYXRhW2krK107XG4gICAgICAgICAgdCA9IGlzRGltWCA/ICh4T3JZIC0geDApIC8gKHggLSB4MCkgOiAoeE9yWSAtIHkwKSAvICh5IC0geTApO1xuXG4gICAgICAgICAgaWYgKHQgPD0gMSAmJiB0ID49IDApIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBpc0RpbVggPyAoeSAtIHkwKSAqIHQgKyB5MCA6ICh4IC0geDApICogdCArIHgwO1xuICAgICAgICAgICAgcmV0dXJuIGlzRGltWCA/IFt4T3JZLCB2YWxdIDogW3ZhbCwgeE9yWV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDAgPSB4O1xuICAgICAgICAgIHkwID0geTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgIHggPSBkYXRhW2krK107XG4gICAgICAgICAgeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB4MiA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5MiA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB4MyA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5MyA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgblJvb3QgPSBpc0RpbVggPyBjdWJpY1Jvb3RBdCh4MCwgeCwgeDIsIHgzLCB4T3JZLCByb290cykgOiBjdWJpY1Jvb3RBdCh5MCwgeSwgeTIsIHkzLCB4T3JZLCByb290cyk7XG5cbiAgICAgICAgICBpZiAoblJvb3QgPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpXzEgPSAwOyBpXzEgPCBuUm9vdDsgaV8xKyspIHtcbiAgICAgICAgICAgICAgdmFyIHRfMSA9IHJvb3RzW2lfMV07XG5cbiAgICAgICAgICAgICAgaWYgKHRfMSA8PSAxICYmIHRfMSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGlzRGltWCA/IGN1YmljQXQoeTAsIHksIHkyLCB5MywgdF8xKSA6IGN1YmljQXQoeDAsIHgsIHgyLCB4MywgdF8xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNEaW1YID8gW3hPclksIHZhbF0gOiBbdmFsLCB4T3JZXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHgwID0geDM7XG4gICAgICAgICAgeTAgPSB5MztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEVDUG9seWxpbmU7XG59KFBhdGgpO1xuXG5leHBvcnQgeyBFQ1BvbHlsaW5lIH07XG5cbnZhciBFQ1BvbHlnb25TaGFwZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhFQ1BvbHlnb25TaGFwZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBFQ1BvbHlnb25TaGFwZSgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gRUNQb2x5Z29uU2hhcGU7XG59KEVDUG9seWxpbmVTaGFwZSk7XG5cbnZhciBFQ1BvbHlnb24gPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRUNQb2x5Z29uLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEVDUG9seWdvbihvcHRzKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSAnZWMtcG9seWdvbic7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgRUNQb2x5Z29uLnByb3RvdHlwZS5nZXREZWZhdWx0U2hhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBFQ1BvbHlnb25TaGFwZSgpO1xuICB9O1xuXG4gIEVDUG9seWdvbi5wcm90b3R5cGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgIHZhciBzdGFja2VkT25Qb2ludHMgPSBzaGFwZS5zdGFja2VkT25Qb2ludHM7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgICB2YXIgc21vb3RoTW9ub3RvbmUgPSBzaGFwZS5zbW9vdGhNb25vdG9uZTtcblxuICAgIGlmIChzaGFwZS5jb25uZWN0TnVsbHMpIHtcbiAgICAgIC8vIE11c3QgcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IG51bGwgdmFsdWVzIGF2b2lkIGRyYXcgZXJyb3IgaW4gcG9seWdvblxuICAgICAgZm9yICg7IGxlbiA+IDA7IGxlbi0tKSB7XG4gICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2xlbiAqIDIgLSAyXSwgcG9pbnRzW2xlbiAqIDIgLSAxXSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgdmFyIGsgPSBkcmF3U2VnbWVudChjdHgsIHBvaW50cywgaSwgbGVuLCBsZW4sIDEsIHNoYXBlLnNtb290aCwgc21vb3RoTW9ub3RvbmUsIHNoYXBlLmNvbm5lY3ROdWxscyk7XG4gICAgICBkcmF3U2VnbWVudChjdHgsIHN0YWNrZWRPblBvaW50cywgaSArIGsgLSAxLCBrLCBsZW4sIC0xLCBzaGFwZS5zdGFja2VkT25TbW9vdGgsIHNtb290aE1vbm90b25lLCBzaGFwZS5jb25uZWN0TnVsbHMpO1xuICAgICAgaSArPSBrICsgMTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEVDUG9seWdvbjtcbn0oUGF0aCk7XG5cbmV4cG9ydCB7IEVDUG9seWdvbiB9OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbi8qIGdsb2JhbCBVaW50MzJBcnJheSwgRmxvYXQ2NEFycmF5LCBGbG9hdDMyQXJyYXkgKi9cblxuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcyc7XG5pbXBvcnQgTGlzdCBmcm9tICcuLi8uLi9kYXRhL0xpc3QnO1xuaW1wb3J0IHsgY29uY2F0QXJyYXksIG1lcmdlQWxsLCBtYXAgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IENvb3JkaW5hdGVTeXN0ZW0gZnJvbSAnLi4vLi4vY29yZS9Db29yZGluYXRlU3lzdGVtJztcbmltcG9ydCB7IGNyZWF0ZVRvb2x0aXBNYXJrdXAgfSBmcm9tICcuLi8uLi9jb21wb25lbnQvdG9vbHRpcC90b29sdGlwTWFya3VwJztcbnZhciBVaW50MzJBcnIgPSB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gQXJyYXkgOiBVaW50MzJBcnJheTtcbnZhciBGbG9hdDY0QXJyID0gdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBBcnJheSA6IEZsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gY29tcGF0RWMyKHNlcmllc09wdCkge1xuICB2YXIgZGF0YSA9IHNlcmllc09wdC5kYXRhO1xuXG4gIGlmIChkYXRhICYmIGRhdGFbMF0gJiYgZGF0YVswXVswXSAmJiBkYXRhWzBdWzBdLmNvb3JkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUud2FybignTGluZXMgZGF0YSBjb25maWd1cmF0aW9uIGhhcyBiZWVuIGNoYW5nZWQgdG8nICsgJyB7IGNvb3JkczpbWzEsMl0sWzIsM11dIH0nKTtcbiAgICB9XG5cbiAgICBzZXJpZXNPcHQuZGF0YSA9IG1hcChkYXRhLCBmdW5jdGlvbiAoaXRlbU9wdCkge1xuICAgICAgdmFyIGNvb3JkcyA9IFtpdGVtT3B0WzBdLmNvb3JkLCBpdGVtT3B0WzFdLmNvb3JkXTtcbiAgICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICAgIGNvb3JkczogY29vcmRzXG4gICAgICB9O1xuXG4gICAgICBpZiAoaXRlbU9wdFswXS5uYW1lKSB7XG4gICAgICAgIHRhcmdldC5mcm9tTmFtZSA9IGl0ZW1PcHRbMF0ubmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1PcHRbMV0ubmFtZSkge1xuICAgICAgICB0YXJnZXQudG9OYW1lID0gaXRlbU9wdFsxXS5uYW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVyZ2VBbGwoW3RhcmdldCwgaXRlbU9wdFswXSwgaXRlbU9wdFsxXV0pO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBMaW5lc1Nlcmllc01vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKExpbmVzU2VyaWVzTW9kZWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gTGluZXNTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBMaW5lc1Nlcmllc01vZGVsLnR5cGU7XG4gICAgX3RoaXMudmlzdWFsU3R5bGVBY2Nlc3NQYXRoID0gJ2xpbmVTdHlsZSc7XG4gICAgX3RoaXMudmlzdWFsRHJhd1R5cGUgPSAnc3Ryb2tlJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBMaW5lc1Nlcmllc01vZGVsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIC8vIFRoZSBpbnB1dCBkYXRhIG1heSBiZSBudWxsL3VuZGVmaW5lZC5cbiAgICBvcHRpb24uZGF0YSA9IG9wdGlvbi5kYXRhIHx8IFtdOyAvLyBOb3QgdXNpbmcgcHJlcHJvY2Vzc29yIGJlY2F1c2UgbWVyZ2VPcHRpb24gbWF5IG5vdCBoYXZlIHNlcmllcy50eXBlXG5cbiAgICBjb21wYXRFYzIob3B0aW9uKTtcblxuICAgIHZhciByZXN1bHQgPSB0aGlzLl9wcm9jZXNzRmxhdENvb3Jkc0FycmF5KG9wdGlvbi5kYXRhKTtcblxuICAgIHRoaXMuX2ZsYXRDb29yZHMgPSByZXN1bHQuZmxhdENvb3JkcztcbiAgICB0aGlzLl9mbGF0Q29vcmRzT2Zmc2V0ID0gcmVzdWx0LmZsYXRDb29yZHNPZmZzZXQ7XG5cbiAgICBpZiAocmVzdWx0LmZsYXRDb29yZHMpIHtcbiAgICAgIG9wdGlvbi5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShyZXN1bHQuY291bnQpO1xuICAgIH1cblxuICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIExpbmVzU2VyaWVzTW9kZWwucHJvdG90eXBlLm1lcmdlT3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIGNvbXBhdEVjMihvcHRpb24pO1xuXG4gICAgaWYgKG9wdGlvbi5kYXRhKSB7XG4gICAgICAvLyBPbmx5IHVwZGF0ZSB3aGVuIGhhdmUgb3B0aW9uIGRhdGEgdG8gbWVyZ2UuXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcHJvY2Vzc0ZsYXRDb29yZHNBcnJheShvcHRpb24uZGF0YSk7XG5cbiAgICAgIHRoaXMuX2ZsYXRDb29yZHMgPSByZXN1bHQuZmxhdENvb3JkcztcbiAgICAgIHRoaXMuX2ZsYXRDb29yZHNPZmZzZXQgPSByZXN1bHQuZmxhdENvb3Jkc09mZnNldDtcblxuICAgICAgaWYgKHJlc3VsdC5mbGF0Q29vcmRzKSB7XG4gICAgICAgIG9wdGlvbi5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShyZXN1bHQuY291bnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9zdXBlci5wcm90b3R5cGUubWVyZ2VPcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICBMaW5lc1Nlcmllc01vZGVsLnByb3RvdHlwZS5hcHBlbmREYXRhID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLl9wcm9jZXNzRmxhdENvb3Jkc0FycmF5KHBhcmFtcy5kYXRhKTtcblxuICAgIGlmIChyZXN1bHQuZmxhdENvb3Jkcykge1xuICAgICAgaWYgKCF0aGlzLl9mbGF0Q29vcmRzKSB7XG4gICAgICAgIHRoaXMuX2ZsYXRDb29yZHMgPSByZXN1bHQuZmxhdENvb3JkcztcbiAgICAgICAgdGhpcy5fZmxhdENvb3Jkc09mZnNldCA9IHJlc3VsdC5mbGF0Q29vcmRzT2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZmxhdENvb3JkcyA9IGNvbmNhdEFycmF5KHRoaXMuX2ZsYXRDb29yZHMsIHJlc3VsdC5mbGF0Q29vcmRzKTtcbiAgICAgICAgdGhpcy5fZmxhdENvb3Jkc09mZnNldCA9IGNvbmNhdEFycmF5KHRoaXMuX2ZsYXRDb29yZHNPZmZzZXQsIHJlc3VsdC5mbGF0Q29vcmRzT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgcGFyYW1zLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdC5jb3VudCk7XG4gICAgfVxuXG4gICAgdGhpcy5nZXRSYXdEYXRhKCkuYXBwZW5kRGF0YShwYXJhbXMuZGF0YSk7XG4gIH07XG5cbiAgTGluZXNTZXJpZXNNb2RlbC5wcm90b3R5cGUuX2dldENvb3Jkc0Zyb21JdGVtTW9kZWwgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgdmFyIGl0ZW1Nb2RlbCA9IHRoaXMuZ2V0RGF0YSgpLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgIHZhciBjb29yZHMgPSBpdGVtTW9kZWwub3B0aW9uIGluc3RhbmNlb2YgQXJyYXkgPyBpdGVtTW9kZWwub3B0aW9uIDogaXRlbU1vZGVsLmdldFNoYWxsb3coJ2Nvb3JkcycpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghKGNvb3JkcyBpbnN0YW5jZW9mIEFycmF5ICYmIGNvb3Jkcy5sZW5ndGggPiAwICYmIGNvb3Jkc1swXSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29vcmRzICcgKyBKU09OLnN0cmluZ2lmeShjb29yZHMpICsgJy4gTGluZXMgbXVzdCBoYXZlIDJkIGNvb3JkcyBhcnJheSBpbiBkYXRhIGl0ZW0uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvb3JkcztcbiAgfTtcblxuICBMaW5lc1Nlcmllc01vZGVsLnByb3RvdHlwZS5nZXRMaW5lQ29vcmRzQ291bnQgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgaWYgKHRoaXMuX2ZsYXRDb29yZHNPZmZzZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mbGF0Q29vcmRzT2Zmc2V0W2lkeCAqIDIgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldENvb3Jkc0Zyb21JdGVtTW9kZWwoaWR4KS5sZW5ndGg7XG4gICAgfVxuICB9O1xuXG4gIExpbmVzU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldExpbmVDb29yZHMgPSBmdW5jdGlvbiAoaWR4LCBvdXQpIHtcbiAgICBpZiAodGhpcy5fZmxhdENvb3Jkc09mZnNldCkge1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2ZsYXRDb29yZHNPZmZzZXRbaWR4ICogMl07XG4gICAgICB2YXIgbGVuID0gdGhpcy5fZmxhdENvb3Jkc09mZnNldFtpZHggKiAyICsgMV07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gb3V0W2ldIHx8IFtdO1xuICAgICAgICBvdXRbaV1bMF0gPSB0aGlzLl9mbGF0Q29vcmRzW29mZnNldCArIGkgKiAyXTtcbiAgICAgICAgb3V0W2ldWzFdID0gdGhpcy5fZmxhdENvb3Jkc1tvZmZzZXQgKyBpICogMiArIDFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGVuO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5fZ2V0Q29vcmRzRnJvbUl0ZW1Nb2RlbChpZHgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBvdXRbaV0gfHwgW107XG4gICAgICAgIG91dFtpXVswXSA9IGNvb3Jkc1tpXVswXTtcbiAgICAgICAgb3V0W2ldWzFdID0gY29vcmRzW2ldWzFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29vcmRzLmxlbmd0aDtcbiAgICB9XG4gIH07XG5cbiAgTGluZXNTZXJpZXNNb2RlbC5wcm90b3R5cGUuX3Byb2Nlc3NGbGF0Q29vcmRzQXJyYXkgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzdGFydE9mZnNldCA9IDA7XG5cbiAgICBpZiAodGhpcy5fZmxhdENvb3Jkcykge1xuICAgICAgc3RhcnRPZmZzZXQgPSB0aGlzLl9mbGF0Q29vcmRzLmxlbmd0aDtcbiAgICB9IC8vIFN0b3JlZCBhcyBhIHR5cGVkIGFycmF5LiBJbiBmb3JtYXRcbiAgICAvLyBQb2ludHMgQ291bnQoMikgfCB4IHwgeSB8IHggfCB5IHwgUG9pbnRzIENvdW50KDMpIHwgeCB8ICB5IHwgeCB8IHkgfCB4IHwgeSB8XG5cblxuICAgIGlmICh0eXBlb2YgZGF0YVswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDsgLy8gU3RvcmUgb2Zmc2V0IGFuZCBsZW4gb2YgZWFjaCBzZWdtZW50XG5cbiAgICAgIHZhciBjb29yZHNPZmZzZXRBbmRMZW5TdG9yYWdlID0gbmV3IFVpbnQzMkFycihsZW4pO1xuICAgICAgdmFyIGNvb3Jkc1N0b3JhZ2UgPSBuZXcgRmxvYXQ2NEFycihsZW4pO1xuICAgICAgdmFyIGNvb3Jkc0N1cnNvciA9IDA7XG4gICAgICB2YXIgb2Zmc2V0Q3Vyc29yID0gMDtcbiAgICAgIHZhciBkYXRhQ291bnQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgZGF0YUNvdW50Kys7XG4gICAgICAgIHZhciBjb3VudCA9IGRhdGFbaSsrXTsgLy8gT2Zmc2V0XG5cbiAgICAgICAgY29vcmRzT2Zmc2V0QW5kTGVuU3RvcmFnZVtvZmZzZXRDdXJzb3IrK10gPSBjb29yZHNDdXJzb3IgKyBzdGFydE9mZnNldDsgLy8gTGVuXG5cbiAgICAgICAgY29vcmRzT2Zmc2V0QW5kTGVuU3RvcmFnZVtvZmZzZXRDdXJzb3IrK10gPSBjb3VudDtcblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGNvdW50OyBrKyspIHtcbiAgICAgICAgICB2YXIgeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBjb29yZHNTdG9yYWdlW2Nvb3Jkc0N1cnNvcisrXSA9IHg7XG4gICAgICAgICAgY29vcmRzU3RvcmFnZVtjb29yZHNDdXJzb3IrK10gPSB5O1xuXG4gICAgICAgICAgaWYgKGkgPiBsZW4pIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIGZvcm1hdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmxhdENvb3Jkc09mZnNldDogbmV3IFVpbnQzMkFycmF5KGNvb3Jkc09mZnNldEFuZExlblN0b3JhZ2UuYnVmZmVyLCAwLCBvZmZzZXRDdXJzb3IpLFxuICAgICAgICBmbGF0Q29vcmRzOiBjb29yZHNTdG9yYWdlLFxuICAgICAgICBjb3VudDogZGF0YUNvdW50XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmbGF0Q29vcmRzT2Zmc2V0OiBudWxsLFxuICAgICAgZmxhdENvb3JkczogbnVsbCxcbiAgICAgIGNvdW50OiBkYXRhLmxlbmd0aFxuICAgIH07XG4gIH07XG5cbiAgTGluZXNTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0SW5pdGlhbERhdGEgPSBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBDb29yZFN5cyA9IENvb3JkaW5hdGVTeXN0ZW0uZ2V0KG9wdGlvbi5jb29yZGluYXRlU3lzdGVtKTtcblxuICAgICAgaWYgKCFDb29yZFN5cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua293biBjb29yZGluYXRlIHN5c3RlbSAnICsgb3B0aW9uLmNvb3JkaW5hdGVTeXN0ZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsaW5lRGF0YSA9IG5ldyBMaXN0KFsndmFsdWUnXSwgdGhpcyk7XG4gICAgbGluZURhdGEuaGFzSXRlbU9wdGlvbiA9IGZhbHNlO1xuICAgIGxpbmVEYXRhLmluaXREYXRhKG9wdGlvbi5kYXRhLCBbXSwgZnVuY3Rpb24gKGRhdGFJdGVtLCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgICAvLyBkYXRhSXRlbSBpcyBzaW1wbHkgY29vcmRzXG4gICAgICBpZiAoZGF0YUl0ZW0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZURhdGEuaGFzSXRlbU9wdGlvbiA9IHRydWU7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRhdGFJdGVtLnZhbHVlO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgPyB2YWx1ZVtkaW1JbmRleF0gOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBsaW5lRGF0YTtcbiAgfTtcblxuICBMaW5lc1Nlcmllc01vZGVsLnByb3RvdHlwZS5mb3JtYXRUb29sdGlwID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgbXVsdGlwbGVTZXJpZXMsIGRhdGFUeXBlKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoKTtcbiAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KTtcbiAgICB2YXIgbmFtZSA9IGl0ZW1Nb2RlbC5nZXQoJ25hbWUnKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICB2YXIgZnJvbU5hbWUgPSBpdGVtTW9kZWwuZ2V0KCdmcm9tTmFtZScpO1xuICAgIHZhciB0b05hbWUgPSBpdGVtTW9kZWwuZ2V0KCd0b05hbWUnKTtcbiAgICB2YXIgbmFtZUFyciA9IFtdO1xuICAgIGZyb21OYW1lICE9IG51bGwgJiYgbmFtZUFyci5wdXNoKGZyb21OYW1lKTtcbiAgICB0b05hbWUgIT0gbnVsbCAmJiBuYW1lQXJyLnB1c2godG9OYW1lKTtcbiAgICByZXR1cm4gY3JlYXRlVG9vbHRpcE1hcmt1cCgnbmFtZVZhbHVlJywge1xuICAgICAgbmFtZTogbmFtZUFyci5qb2luKCcgPiAnKVxuICAgIH0pO1xuICB9O1xuXG4gIExpbmVzU2VyaWVzTW9kZWwucHJvdG90eXBlLnByZXZlbnRJbmNyZW1lbnRhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldChbJ2VmZmVjdCcsICdzaG93J10pO1xuICB9O1xuXG4gIExpbmVzU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldFByb2dyZXNzaXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9ncmVzc2l2ZSA9IHRoaXMub3B0aW9uLnByb2dyZXNzaXZlO1xuXG4gICAgaWYgKHByb2dyZXNzaXZlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbi5sYXJnZSA/IDFlNCA6IHRoaXMuZ2V0KCdwcm9ncmVzc2l2ZScpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9ncmVzc2l2ZTtcbiAgfTtcblxuICBMaW5lc1Nlcmllc01vZGVsLnByb3RvdHlwZS5nZXRQcm9ncmVzc2l2ZVRocmVzaG9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvZ3Jlc3NpdmVUaHJlc2hvbGQgPSB0aGlzLm9wdGlvbi5wcm9ncmVzc2l2ZVRocmVzaG9sZDtcblxuICAgIGlmIChwcm9ncmVzc2l2ZVRocmVzaG9sZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb24ubGFyZ2UgPyAyZTQgOiB0aGlzLmdldCgncHJvZ3Jlc3NpdmVUaHJlc2hvbGQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3Jlc3NpdmVUaHJlc2hvbGQ7XG4gIH07XG5cbiAgTGluZXNTZXJpZXNNb2RlbC50eXBlID0gJ3Nlcmllcy5saW5lcyc7XG4gIExpbmVzU2VyaWVzTW9kZWwuZGVwZW5kZW5jaWVzID0gWydncmlkJywgJ3BvbGFyJywgJ2dlbycsICdjYWxlbmRhciddO1xuICBMaW5lc1Nlcmllc01vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgY29vcmRpbmF0ZVN5c3RlbTogJ2dlbycsXG4gICAgemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIC8vIENhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbVxuICAgIHhBeGlzSW5kZXg6IDAsXG4gICAgeUF4aXNJbmRleDogMCxcbiAgICBzeW1ib2w6IFsnbm9uZScsICdub25lJ10sXG4gICAgc3ltYm9sU2l6ZTogWzEwLCAxMF0sXG4gICAgLy8gR2VvIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgZ2VvSW5kZXg6IDAsXG4gICAgZWZmZWN0OiB7XG4gICAgICBzaG93OiBmYWxzZSxcbiAgICAgIHBlcmlvZDogNCxcbiAgICAgIGNvbnN0YW50U3BlZWQ6IDAsXG4gICAgICBzeW1ib2w6ICdjaXJjbGUnLFxuICAgICAgc3ltYm9sU2l6ZTogMyxcbiAgICAgIGxvb3A6IHRydWUsXG4gICAgICB0cmFpbExlbmd0aDogMC4yXG4gICAgfSxcbiAgICBsYXJnZTogZmFsc2UsXG4gICAgLy8gQXZhaWxhYmxlIHdoZW4gbGFyZ2UgaXMgdHJ1ZVxuICAgIGxhcmdlVGhyZXNob2xkOiAyMDAwLFxuICAgIHBvbHlsaW5lOiBmYWxzZSxcbiAgICBjbGlwOiB0cnVlLFxuICAgIGxhYmVsOiB7XG4gICAgICBzaG93OiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uOiAnZW5kJyAvLyBkaXN0YW5jZTogNSxcbiAgICAgIC8vIGZvcm1hdHRlcjog5qCH562+5paH5pys5qC85byP5Zmo77yM5ZCMVG9vbHRpcC5mb3JtYXR0ZXLvvIzkuI3mlK/mjIHlvILmraXlm57osINcblxuICAgIH0sXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICBvcGFjaXR5OiAwLjVcbiAgICB9XG4gIH07XG4gIHJldHVybiBMaW5lc1Nlcmllc01vZGVsO1xufShTZXJpZXNNb2RlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IExpbmVzU2VyaWVzTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IExpbmVEcmF3IGZyb20gJy4uL2hlbHBlci9MaW5lRHJhdyc7XG5pbXBvcnQgRWZmZWN0TGluZSBmcm9tICcuLi9oZWxwZXIvRWZmZWN0TGluZSc7XG5pbXBvcnQgTGluZSBmcm9tICcuLi9oZWxwZXIvTGluZSc7XG5pbXBvcnQgUG9seWxpbmUgZnJvbSAnLi4vaGVscGVyL1BvbHlsaW5lJztcbmltcG9ydCBFZmZlY3RQb2x5bGluZSBmcm9tICcuLi9oZWxwZXIvRWZmZWN0UG9seWxpbmUnO1xuaW1wb3J0IExhcmdlTGluZURyYXcgZnJvbSAnLi4vaGVscGVyL0xhcmdlTGluZURyYXcnO1xuaW1wb3J0IGxpbmVzTGF5b3V0IGZyb20gJy4vbGluZXNMYXlvdXQnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpcFBhdGggfSBmcm9tICcuLi9oZWxwZXIvY3JlYXRlQ2xpcFBhdGhGcm9tQ29vcmRTeXMnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0JztcblxudmFyIExpbmVzVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhMaW5lc1ZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gTGluZXNWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IExpbmVzVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIExpbmVzVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcblxuICAgIHZhciBsaW5lRHJhdyA9IHRoaXMuX3VwZGF0ZUxpbmVEcmF3KGRhdGEsIHNlcmllc01vZGVsKTtcblxuICAgIHZhciB6bGV2ZWwgPSBzZXJpZXNNb2RlbC5nZXQoJ3psZXZlbCcpO1xuICAgIHZhciB0cmFpbExlbmd0aCA9IHNlcmllc01vZGVsLmdldChbJ2VmZmVjdCcsICd0cmFpbExlbmd0aCddKTtcbiAgICB2YXIgenIgPSBhcGkuZ2V0WnIoKTsgLy8gQXZvaWQgdGhlIGRyYWcgY2F1c2UgZ2hvc3Qgc2hhZG93XG4gICAgLy8gRklYTUUgQmV0dGVyIHdheSA/XG4gICAgLy8gU1ZHIGRvZXNuJ3Qgc3VwcG9ydFxuXG4gICAgdmFyIGlzU3ZnID0genIucGFpbnRlci5nZXRUeXBlKCkgPT09ICdzdmcnO1xuXG4gICAgaWYgKCFpc1N2Zykge1xuICAgICAgenIucGFpbnRlci5nZXRMYXllcih6bGV2ZWwpLmNsZWFyKHRydWUpO1xuICAgIH0gLy8gQ29uZmlnIGxheWVyIHdpdGggbW90aW9uIGJsdXJcblxuXG4gICAgaWYgKHRoaXMuX2xhc3RabGV2ZWwgIT0gbnVsbCAmJiAhaXNTdmcpIHtcbiAgICAgIHpyLmNvbmZpZ0xheWVyKHRoaXMuX2xhc3RabGV2ZWwsIHtcbiAgICAgICAgbW90aW9uQmx1cjogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zaG93RWZmZWN0KHNlcmllc01vZGVsKSAmJiB0cmFpbExlbmd0aCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIG5vdEluSW5kaXZpZHVhbF8xID0gZmFsc2U7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAob3RoZXJTZXJpZXNNb2RlbCkge1xuICAgICAgICAgIGlmIChvdGhlclNlcmllc01vZGVsICE9PSBzZXJpZXNNb2RlbCAmJiBvdGhlclNlcmllc01vZGVsLmdldCgnemxldmVsJykgPT09IHpsZXZlbCkge1xuICAgICAgICAgICAgbm90SW5JbmRpdmlkdWFsXzEgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG5vdEluSW5kaXZpZHVhbF8xICYmIGNvbnNvbGUud2FybignTGluZXMgd2l0aCB0cmFpbCBlZmZlY3Qgc2hvdWxkIGhhdmUgYW4gaW5kaXZpZHVhbCB6bGV2ZWwnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1N2Zykge1xuICAgICAgICB6ci5jb25maWdMYXllcih6bGV2ZWwsIHtcbiAgICAgICAgICBtb3Rpb25CbHVyOiB0cnVlLFxuICAgICAgICAgIGxhc3RGcmFtZUFscGhhOiBNYXRoLm1heChNYXRoLm1pbih0cmFpbExlbmd0aCAvIDEwICsgMC45LCAxKSwgMClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGluZURyYXcudXBkYXRlRGF0YShkYXRhKTtcbiAgICB2YXIgY2xpcFBhdGggPSBzZXJpZXNNb2RlbC5nZXQoJ2NsaXAnLCB0cnVlKSAmJiBjcmVhdGVDbGlwUGF0aChzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtLCBmYWxzZSwgc2VyaWVzTW9kZWwpO1xuXG4gICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICB0aGlzLmdyb3VwLnNldENsaXBQYXRoKGNsaXBQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ncm91cC5yZW1vdmVDbGlwUGF0aCgpO1xuICAgIH1cblxuICAgIHRoaXMuX2xhc3RabGV2ZWwgPSB6bGV2ZWw7XG4gICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICB9O1xuXG4gIExpbmVzVmlldy5wcm90b3R5cGUuaW5jcmVtZW50YWxQcmVwYXJlUmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcblxuICAgIHZhciBsaW5lRHJhdyA9IHRoaXMuX3VwZGF0ZUxpbmVEcmF3KGRhdGEsIHNlcmllc01vZGVsKTtcblxuICAgIGxpbmVEcmF3LmluY3JlbWVudGFsUHJlcGFyZVVwZGF0ZShkYXRhKTtcblxuICAgIHRoaXMuX2NsZWFyTGF5ZXIoYXBpKTtcblxuICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gIH07XG5cbiAgTGluZXNWaWV3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFJlbmRlciA9IGZ1bmN0aW9uICh0YXNrUGFyYW1zLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgIHRoaXMuX2xpbmVEcmF3LmluY3JlbWVudGFsVXBkYXRlKHRhc2tQYXJhbXMsIHNlcmllc01vZGVsLmdldERhdGEoKSk7XG5cbiAgICB0aGlzLl9maW5pc2hlZCA9IHRhc2tQYXJhbXMuZW5kID09PSBzZXJpZXNNb2RlbC5nZXREYXRhKCkuY291bnQoKTtcbiAgfTtcblxuICBMaW5lc1ZpZXcucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHBpcGVsaW5lQ29udGV4dCA9IHNlcmllc01vZGVsLnBpcGVsaW5lQ29udGV4dDtcblxuICAgIGlmICghdGhpcy5fZmluaXNoZWQgfHwgcGlwZWxpbmVDb250ZXh0LmxhcmdlIHx8IHBpcGVsaW5lQ29udGV4dC5wcm9ncmVzc2l2ZVJlbmRlcikge1xuICAgICAgLy8gVE9ETyBEb24ndCBoYXZlIHRvIGRvIHVwZGF0ZSBpbiBsYXJnZSBtb2RlLiBPbmx5IGRvIGl0IHdoZW4gdGhlcmUgYXJlIG1pbGxpb25zIG9mIGRhdGEuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGU6IHRydWVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE8gVXNlIHNhbWUgbG9naWMgd2l0aCBTY2F0dGVyVmlldy5cbiAgICAgIC8vIE1hbnVhbGx5IHVwZGF0ZSBsYXlvdXRcbiAgICAgIHZhciByZXMgPSBsaW5lc0xheW91dC5yZXNldChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKTtcblxuICAgICAgaWYgKHJlcy5wcm9ncmVzcykge1xuICAgICAgICByZXMucHJvZ3Jlc3Moe1xuICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgIGVuZDogZGF0YS5jb3VudCgpLFxuICAgICAgICAgIGNvdW50OiBkYXRhLmNvdW50KClcbiAgICAgICAgfSwgZGF0YSk7XG4gICAgICB9IC8vIE5vdCBpbiBsYXJnZSBtb2RlXG5cblxuICAgICAgdGhpcy5fbGluZURyYXcudXBkYXRlTGF5b3V0KCk7XG5cbiAgICAgIHRoaXMuX2NsZWFyTGF5ZXIoYXBpKTtcbiAgICB9XG4gIH07XG5cbiAgTGluZXNWaWV3LnByb3RvdHlwZS5fdXBkYXRlTGluZURyYXcgPSBmdW5jdGlvbiAoZGF0YSwgc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgbGluZURyYXcgPSB0aGlzLl9saW5lRHJhdztcblxuICAgIHZhciBoYXNFZmZlY3QgPSB0aGlzLl9zaG93RWZmZWN0KHNlcmllc01vZGVsKTtcblxuICAgIHZhciBpc1BvbHlsaW5lID0gISFzZXJpZXNNb2RlbC5nZXQoJ3BvbHlsaW5lJyk7XG4gICAgdmFyIHBpcGVsaW5lQ29udGV4dCA9IHNlcmllc01vZGVsLnBpcGVsaW5lQ29udGV4dDtcbiAgICB2YXIgaXNMYXJnZURyYXcgPSBwaXBlbGluZUNvbnRleHQubGFyZ2U7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGhhc0VmZmVjdCAmJiBpc0xhcmdlRHJhdykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0xhcmdlIGxpbmVzIG5vdCBzdXBwb3J0IGVmZmVjdCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbGluZURyYXcgfHwgaGFzRWZmZWN0ICE9PSB0aGlzLl9oYXNFZmZldCB8fCBpc1BvbHlsaW5lICE9PSB0aGlzLl9pc1BvbHlsaW5lIHx8IGlzTGFyZ2VEcmF3ICE9PSB0aGlzLl9pc0xhcmdlRHJhdykge1xuICAgICAgaWYgKGxpbmVEcmF3KSB7XG4gICAgICAgIGxpbmVEcmF3LnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBsaW5lRHJhdyA9IHRoaXMuX2xpbmVEcmF3ID0gaXNMYXJnZURyYXcgPyBuZXcgTGFyZ2VMaW5lRHJhdygpIDogbmV3IExpbmVEcmF3KGlzUG9seWxpbmUgPyBoYXNFZmZlY3QgPyBFZmZlY3RQb2x5bGluZSA6IFBvbHlsaW5lIDogaGFzRWZmZWN0ID8gRWZmZWN0TGluZSA6IExpbmUpO1xuICAgICAgdGhpcy5faGFzRWZmZXQgPSBoYXNFZmZlY3Q7XG4gICAgICB0aGlzLl9pc1BvbHlsaW5lID0gaXNQb2x5bGluZTtcbiAgICAgIHRoaXMuX2lzTGFyZ2VEcmF3ID0gaXNMYXJnZURyYXc7XG4gICAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIH1cblxuICAgIHRoaXMuZ3JvdXAuYWRkKGxpbmVEcmF3Lmdyb3VwKTtcbiAgICByZXR1cm4gbGluZURyYXc7XG4gIH07XG5cbiAgTGluZXNWaWV3LnByb3RvdHlwZS5fc2hvd0VmZmVjdCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHJldHVybiAhIXNlcmllc01vZGVsLmdldChbJ2VmZmVjdCcsICdzaG93J10pO1xuICB9O1xuXG4gIExpbmVzVmlldy5wcm90b3R5cGUuX2NsZWFyTGF5ZXIgPSBmdW5jdGlvbiAoYXBpKSB7XG4gICAgLy8gTm90IHVzZSBtb3Rpb24gd2hlbiBkcmFnZ2luZyBvciB6b29taW5nXG4gICAgdmFyIHpyID0gYXBpLmdldFpyKCk7XG4gICAgdmFyIGlzU3ZnID0genIucGFpbnRlci5nZXRUeXBlKCkgPT09ICdzdmcnO1xuXG4gICAgaWYgKCFpc1N2ZyAmJiB0aGlzLl9sYXN0WmxldmVsICE9IG51bGwpIHtcbiAgICAgIHpyLnBhaW50ZXIuZ2V0TGF5ZXIodGhpcy5fbGFzdFpsZXZlbCkuY2xlYXIodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIExpbmVzVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuX2xpbmVEcmF3ICYmIHRoaXMuX2xpbmVEcmF3LnJlbW92ZSgpO1xuICAgIHRoaXMuX2xpbmVEcmF3ID0gbnVsbDsgLy8gQ2xlYXIgbW90aW9uIHdoZW4gbGluZURyYXcgaXMgcmVtb3ZlZFxuXG4gICAgdGhpcy5fY2xlYXJMYXllcihhcGkpO1xuICB9O1xuXG4gIExpbmVzVmlldy50eXBlID0gJ2xpbmVzJztcbiAgcmV0dXJuIExpbmVzVmlldztcbn0oQ2hhcnRWaWV3KTtcblxuZXhwb3J0IGRlZmF1bHQgTGluZXNWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgTGluZXNWaWV3IGZyb20gJy4vTGluZXNWaWV3JztcbmltcG9ydCBMaW5lc1Nlcmllc01vZGVsIGZyb20gJy4vTGluZXNTZXJpZXMnO1xuaW1wb3J0IGxpbmVzTGF5b3V0IGZyb20gJy4vbGluZXNMYXlvdXQnO1xuaW1wb3J0IGxpbmVzVmlzdWFsIGZyb20gJy4vbGluZXNWaXN1YWwnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhMaW5lc1ZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChMaW5lc1Nlcmllc01vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KGxpbmVzTGF5b3V0KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyVmlzdWFsKGxpbmVzVmlzdWFsKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKiBnbG9iYWwgRmxvYXQzMkFycmF5ICovXG5pbXBvcnQgY3JlYXRlUmVuZGVyUGxhbm5lciBmcm9tICcuLi9oZWxwZXIvY3JlYXRlUmVuZGVyUGxhbm5lcic7XG52YXIgbGluZXNMYXlvdXQgPSB7XG4gIHNlcmllc1R5cGU6ICdsaW5lcycsXG4gIHBsYW46IGNyZWF0ZVJlbmRlclBsYW5uZXIoKSxcbiAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGlzUG9seWxpbmUgPSBzZXJpZXNNb2RlbC5nZXQoJ3BvbHlsaW5lJyk7XG4gICAgdmFyIGlzTGFyZ2UgPSBzZXJpZXNNb2RlbC5waXBlbGluZUNvbnRleHQubGFyZ2U7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2dyZXNzOiBmdW5jdGlvbiAocGFyYW1zLCBsaW5lRGF0YSkge1xuICAgICAgICB2YXIgbGluZUNvb3JkcyA9IFtdO1xuXG4gICAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgICAgdmFyIHBvaW50cyA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgc2VnQ291bnQgPSBwYXJhbXMuZW5kIC0gcGFyYW1zLnN0YXJ0O1xuXG4gICAgICAgICAgaWYgKGlzUG9seWxpbmUpIHtcbiAgICAgICAgICAgIHZhciB0b3RhbENvb3Jkc0NvdW50ID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHBhcmFtcy5zdGFydDsgaSA8IHBhcmFtcy5lbmQ7IGkrKykge1xuICAgICAgICAgICAgICB0b3RhbENvb3Jkc0NvdW50ICs9IHNlcmllc01vZGVsLmdldExpbmVDb29yZHNDb3VudChpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShzZWdDb3VudCArIHRvdGFsQ29vcmRzQ291bnQgKiAyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShzZWdDb3VudCAqIDQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgIHZhciBwdCA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IHBhcmFtcy5zdGFydDsgaSA8IHBhcmFtcy5lbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHNlcmllc01vZGVsLmdldExpbmVDb29yZHMoaSwgbGluZUNvb3Jkcyk7XG5cbiAgICAgICAgICAgIGlmIChpc1BvbHlsaW5lKSB7XG4gICAgICAgICAgICAgIHBvaW50c1tvZmZzZXQrK10gPSBsZW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgICAgcHQgPSBjb29yZFN5cy5kYXRhVG9Qb2ludChsaW5lQ29vcmRzW2tdLCBmYWxzZSwgcHQpO1xuICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0KytdID0gcHRbMF07XG4gICAgICAgICAgICAgIHBvaW50c1tvZmZzZXQrK10gPSBwdFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaW5lRGF0YS5zZXRMYXlvdXQoJ2xpbmVzUG9pbnRzJywgcG9pbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gcGFyYW1zLnN0YXJ0OyBpIDwgcGFyYW1zLmVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gbGluZURhdGEuZ2V0SXRlbU1vZGVsKGkpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHNlcmllc01vZGVsLmdldExpbmVDb29yZHMoaSwgbGluZUNvb3Jkcyk7XG4gICAgICAgICAgICB2YXIgcHRzID0gW107XG5cbiAgICAgICAgICAgIGlmIChpc1BvbHlsaW5lKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwdHMucHVzaChjb29yZFN5cy5kYXRhVG9Qb2ludChsaW5lQ29vcmRzW2pdKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHB0c1swXSA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KGxpbmVDb29yZHNbMF0pO1xuICAgICAgICAgICAgICBwdHNbMV0gPSBjb29yZFN5cy5kYXRhVG9Qb2ludChsaW5lQ29vcmRzWzFdKTtcbiAgICAgICAgICAgICAgdmFyIGN1cnZlbmVzcyA9IGl0ZW1Nb2RlbC5nZXQoWydsaW5lU3R5bGUnLCAnY3VydmVuZXNzJ10pO1xuXG4gICAgICAgICAgICAgIGlmICgrY3VydmVuZXNzKSB7XG4gICAgICAgICAgICAgICAgcHRzWzJdID0gWyhwdHNbMF1bMF0gKyBwdHNbMV1bMF0pIC8gMiAtIChwdHNbMF1bMV0gLSBwdHNbMV1bMV0pICogY3VydmVuZXNzLCAocHRzWzBdWzFdICsgcHRzWzFdWzFdKSAvIDIgLSAocHRzWzFdWzBdIC0gcHRzWzBdWzBdKSAqIGN1cnZlbmVzc107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZURhdGEuc2V0SXRlbUxheW91dChpLCBwdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBsaW5lc0xheW91dDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuZnVuY3Rpb24gbm9ybWFsaXplKGEpIHtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIGEgPSBbYSwgYV07XG4gIH1cblxuICByZXR1cm4gYTtcbn1cblxudmFyIGxpbmVzVmlzdWFsID0ge1xuICBzZXJpZXNUeXBlOiAnbGluZXMnLFxuICByZXNldDogZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIHN5bWJvbFR5cGUgPSBub3JtYWxpemUoc2VyaWVzTW9kZWwuZ2V0KCdzeW1ib2wnKSk7XG4gICAgdmFyIHN5bWJvbFNpemUgPSBub3JtYWxpemUoc2VyaWVzTW9kZWwuZ2V0KCdzeW1ib2xTaXplJykpO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIGRhdGEuc2V0VmlzdWFsKCdmcm9tU3ltYm9sJywgc3ltYm9sVHlwZSAmJiBzeW1ib2xUeXBlWzBdKTtcbiAgICBkYXRhLnNldFZpc3VhbCgndG9TeW1ib2wnLCBzeW1ib2xUeXBlICYmIHN5bWJvbFR5cGVbMV0pO1xuICAgIGRhdGEuc2V0VmlzdWFsKCdmcm9tU3ltYm9sU2l6ZScsIHN5bWJvbFNpemUgJiYgc3ltYm9sU2l6ZVswXSk7XG4gICAgZGF0YS5zZXRWaXN1YWwoJ3RvU3ltYm9sU2l6ZScsIHN5bWJvbFNpemUgJiYgc3ltYm9sU2l6ZVsxXSk7XG5cbiAgICBmdW5jdGlvbiBkYXRhRWFjaChkYXRhLCBpZHgpIHtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgdmFyIHN5bWJvbFR5cGUgPSBub3JtYWxpemUoaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbCcsIHRydWUpKTtcbiAgICAgIHZhciBzeW1ib2xTaXplID0gbm9ybWFsaXplKGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2xTaXplJywgdHJ1ZSkpO1xuICAgICAgc3ltYm9sVHlwZVswXSAmJiBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnZnJvbVN5bWJvbCcsIHN5bWJvbFR5cGVbMF0pO1xuICAgICAgc3ltYm9sVHlwZVsxXSAmJiBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAndG9TeW1ib2wnLCBzeW1ib2xUeXBlWzFdKTtcbiAgICAgIHN5bWJvbFNpemVbMF0gJiYgZGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwgJ2Zyb21TeW1ib2xTaXplJywgc3ltYm9sU2l6ZVswXSk7XG4gICAgICBzeW1ib2xTaXplWzFdICYmIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICd0b1N5bWJvbFNpemUnLCBzeW1ib2xTaXplWzFdKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YUVhY2g6IGRhdGEuaGFzSXRlbU9wdGlvbiA/IGRhdGFFYWNoIDogbnVsbFxuICAgIH07XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBsaW5lc1Zpc3VhbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBjcmVhdGVMaXN0U2ltcGx5IGZyb20gJy4uL2hlbHBlci9jcmVhdGVMaXN0U2ltcGx5JztcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9TZXJpZXMnO1xuaW1wb3J0IGdlb1NvdXJjZU1hbmFnZXIgZnJvbSAnLi4vLi4vY29vcmQvZ2VvL2dlb1NvdXJjZU1hbmFnZXInO1xuaW1wb3J0IHsgbWFrZVNlcmllc0VuY29kZUZvck5hbWVCYXNlZCB9IGZyb20gJy4uLy4uL2RhdGEvaGVscGVyL3NvdXJjZUhlbHBlcic7XG5pbXBvcnQgeyBjcmVhdGVUb29sdGlwTWFya3VwIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50L3Rvb2x0aXAvdG9vbHRpcE1hcmt1cCc7XG5cbnZhciBNYXBTZXJpZXMgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTWFwU2VyaWVzLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE1hcFNlcmllcygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBNYXBTZXJpZXMudHlwZTsgLy8gT25seSBmaXJzdCBtYXAgc2VyaWVzIG9mIHNhbWUgbWFwVHlwZSB3aWxsIGRyYXdNYXAuXG5cbiAgICBfdGhpcy5uZWVkc0RyYXdNYXAgPSBmYWxzZTsgLy8gR3JvdXAgb2YgYWxsIG1hcCBzZXJpZXMgd2l0aCBzYW1lIG1hcFR5cGVcblxuICAgIF90aGlzLnNlcmllc0dyb3VwID0gW107XG5cbiAgICBfdGhpcy5nZXRUb29sdGlwUG9zaXRpb24gPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICBpZiAoZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG5hbWVfMSA9IHRoaXMuZ2V0RGF0YSgpLmdldE5hbWUoZGF0YUluZGV4KTtcbiAgICAgICAgdmFyIGdlbyA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgdmFyIHJlZ2lvbiA9IGdlby5nZXRSZWdpb24obmFtZV8xKTtcbiAgICAgICAgcmV0dXJuIHJlZ2lvbiAmJiBnZW8uZGF0YVRvUG9pbnQocmVnaW9uLmNlbnRlcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIE1hcFNlcmllcy5wcm90b3R5cGUuZ2V0SW5pdGlhbERhdGEgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgdmFyIGRhdGEgPSBjcmVhdGVMaXN0U2ltcGx5KHRoaXMsIHtcbiAgICAgIGNvb3JkRGltZW5zaW9uczogWyd2YWx1ZSddLFxuICAgICAgZW5jb2RlRGVmYXVsdGVyOiB6clV0aWwuY3VycnkobWFrZVNlcmllc0VuY29kZUZvck5hbWVCYXNlZCwgdGhpcylcbiAgICB9KTtcbiAgICB2YXIgZGF0YU5hbWVNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICAgIHZhciB0b0FwcGVuZE5hbWVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBuYW1lXzIgPSBkYXRhLmdldE5hbWUoaSk7XG4gICAgICBkYXRhTmFtZU1hcC5zZXQobmFtZV8yLCB0cnVlKTtcbiAgICB9XG5cbiAgICB2YXIgZ2VvU291cmNlID0gZ2VvU291cmNlTWFuYWdlci5sb2FkKHRoaXMuZ2V0TWFwVHlwZSgpLCB0aGlzLm9wdGlvbi5uYW1lTWFwLCB0aGlzLm9wdGlvbi5uYW1lUHJvcGVydHkpO1xuICAgIHpyVXRpbC5lYWNoKGdlb1NvdXJjZS5yZWdpb25zLCBmdW5jdGlvbiAocmVnaW9uKSB7XG4gICAgICB2YXIgbmFtZSA9IHJlZ2lvbi5uYW1lO1xuXG4gICAgICBpZiAoIWRhdGFOYW1lTWFwLmdldChuYW1lKSkge1xuICAgICAgICB0b0FwcGVuZE5hbWVzLnB1c2gobmFtZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIENvbXBsZXRlIGRhdGEgd2l0aCBtaXNzaW5nIHJlZ2lvbnMuIFRoZSBjb25zZXF1ZW50IHByb2Nlc3NlcyAobGlrZSB2aXN1YWxcbiAgICAvLyBtYXAgYW5kIHJlbmRlcikgY2FuIG5vdCBiZSBwZXJmb3JtZWQgd2l0aG91dCBhIFwiZnVsbCBkYXRhXCIuIEZvciBleGFtcGxlLFxuICAgIC8vIGZpbmQgYGRhdGFJbmRleGAgYnkgbmFtZS5cblxuICAgIGRhdGEuYXBwZW5kVmFsdWVzKFtdLCB0b0FwcGVuZE5hbWVzKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbiAgLyoqXG4gICAqIElmIG5vIGhvc3QgZ2VvIG1vZGVsLCByZXR1cm4gbnVsbCwgd2hpY2ggbWVhbnMgdXNpbmcgYVxuICAgKiBpbm5lciBleGNsdXNpdmUgZ2VvIG1vZGVsLlxuICAgKi9cblxuXG4gIE1hcFNlcmllcy5wcm90b3R5cGUuZ2V0SG9zdEdlb01vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZW9JbmRleCA9IHRoaXMub3B0aW9uLmdlb0luZGV4O1xuICAgIHJldHVybiBnZW9JbmRleCAhPSBudWxsID8gdGhpcy5lY01vZGVsLmdldENvbXBvbmVudCgnZ2VvJywgZ2VvSW5kZXgpIDogbnVsbDtcbiAgfTtcblxuICBNYXBTZXJpZXMucHJvdG90eXBlLmdldE1hcFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmdldEhvc3RHZW9Nb2RlbCgpIHx8IHRoaXMpLm9wdGlvbi5tYXA7XG4gIH07IC8vIF9maWxsT3B0aW9uKG9wdGlvbiwgbWFwTmFtZSkge1xuICAvLyBTaGFsbG93IGNsb25lXG4gIC8vIG9wdGlvbiA9IHpyVXRpbC5leHRlbmQoe30sIG9wdGlvbik7XG4gIC8vIG9wdGlvbi5kYXRhID0gZ2VvQ3JlYXRvci5nZXRGaWxsZWRSZWdpb25zKG9wdGlvbi5kYXRhLCBtYXBOYW1lLCBvcHRpb24ubmFtZU1hcCk7XG4gIC8vIHJldHVybiBvcHRpb247XG4gIC8vIH1cblxuXG4gIE1hcFNlcmllcy5wcm90b3R5cGUuZ2V0UmF3VmFsdWUgPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgLy8gVXNlIHZhbHVlIHN0b3JlZCBpbiBkYXRhIGluc3RlYWQgYmVjYXVzZSBpdCBpcyBjYWxjdWxhdGVkIGZyb20gbXVsdGlwbGUgc2VyaWVzXG4gICAgLy8gRklYTUUgUHJvdmlkZSBhbGwgdmFsdWUgb2YgbXVsdGlwbGUgc2VyaWVzID9cbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgIHJldHVybiBkYXRhLmdldChkYXRhLm1hcERpbWVuc2lvbigndmFsdWUnKSwgZGF0YUluZGV4KTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldCBtb2RlbCBvZiByZWdpb25cbiAgICovXG5cblxuICBNYXBTZXJpZXMucHJvdG90eXBlLmdldFJlZ2lvbk1vZGVsID0gZnVuY3Rpb24gKHJlZ2lvbk5hbWUpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgIHJldHVybiBkYXRhLmdldEl0ZW1Nb2RlbChkYXRhLmluZGV4T2ZOYW1lKHJlZ2lvbk5hbWUpKTtcbiAgfTtcbiAgLyoqXG4gICAqIE1hcCB0b29sdGlwIGZvcm1hdHRlclxuICAgKi9cblxuXG4gIE1hcFNlcmllcy5wcm90b3R5cGUuZm9ybWF0VG9vbHRpcCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIG11bHRpcGxlU2VyaWVzLCBkYXRhVHlwZSkge1xuICAgIC8vIEZJWE1FIG9yaWduYWxEYXRhIGFuZCBkYXRhIGlzIGEgYml0IGNvbmZ1c2luZ1xuICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXRSYXdWYWx1ZShkYXRhSW5kZXgpO1xuICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCk7XG4gICAgdmFyIHNlcmllc0dyb3VwID0gdGhpcy5zZXJpZXNHcm91cDtcbiAgICB2YXIgc2VyaWVzTmFtZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyaWVzR3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlckluZGV4ID0gc2VyaWVzR3JvdXBbaV0ub3JpZ2luYWxEYXRhLmluZGV4T2ZOYW1lKG5hbWUpO1xuICAgICAgdmFyIHZhbHVlRGltID0gZGF0YS5tYXBEaW1lbnNpb24oJ3ZhbHVlJyk7XG5cbiAgICAgIGlmICghaXNOYU4oc2VyaWVzR3JvdXBbaV0ub3JpZ2luYWxEYXRhLmdldCh2YWx1ZURpbSwgb3RoZXJJbmRleCkpKSB7XG4gICAgICAgIHNlcmllc05hbWVzLnB1c2goc2VyaWVzR3JvdXBbaV0ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVRvb2x0aXBNYXJrdXAoJ3NlY3Rpb24nLCB7XG4gICAgICBoZWFkZXI6IHNlcmllc05hbWVzLmpvaW4oJywgJyksXG4gICAgICBub0hlYWRlcjogIXNlcmllc05hbWVzLmxlbmd0aCxcbiAgICAgIGJsb2NrczogW2NyZWF0ZVRvb2x0aXBNYXJrdXAoJ25hbWVWYWx1ZScsIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KV1cbiAgICB9KTtcbiAgfTtcblxuICBNYXBTZXJpZXMucHJvdG90eXBlLnNldFpvb20gPSBmdW5jdGlvbiAoem9vbSkge1xuICAgIHRoaXMub3B0aW9uLnpvb20gPSB6b29tO1xuICB9O1xuXG4gIE1hcFNlcmllcy5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGNlbnRlcikge1xuICAgIHRoaXMub3B0aW9uLmNlbnRlciA9IGNlbnRlcjtcbiAgfTtcblxuICBNYXBTZXJpZXMudHlwZSA9ICdzZXJpZXMubWFwJztcbiAgTWFwU2VyaWVzLmRlcGVuZGVuY2llcyA9IFsnZ2VvJ107XG4gIE1hcFNlcmllcy5sYXlvdXRNb2RlID0gJ2JveCc7XG4gIE1hcFNlcmllcy5kZWZhdWx0T3B0aW9uID0ge1xuICAgIC8vIOS4gOe6p+WxguWPoFxuICAgIHpsZXZlbDogMCxcbiAgICAvLyDkuoznuqflsYLlj6BcbiAgICB6OiAyLFxuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdnZW8nLFxuICAgIC8vIG1hcCBzaG91bGQgYmUgZXhwbGljaXRseSBzcGVjaWZpZWQgc2luY2UgZWMzLlxuICAgIG1hcDogJycsXG4gICAgLy8gSWYgYGdlb0luZGV4YCBpcyBub3Qgc3BlY2lmaWVkLCBhIGV4Y2x1c2l2ZSBnZW8gd2lsbCBiZVxuICAgIC8vIGNyZWF0ZWQuIE90aGVyd2lzZSB1c2UgdGhlIHNwZWNpZmllZCBnZW8gY29tcG9uZW50LCBhbmRcbiAgICAvLyBgbWFwYCBhbmQgYG1hcFR5cGVgIGFyZSBpZ25vcmVkLlxuICAgIC8vIGdlb0luZGV4OiAwLFxuICAgIC8vICdjZW50ZXInIHwgJ2xlZnQnIHwgJ3JpZ2h0JyB8ICd4JScgfCB7bnVtYmVyfVxuICAgIGxlZnQ6ICdjZW50ZXInLFxuICAgIC8vICdjZW50ZXInIHwgJ3RvcCcgfCAnYm90dG9tJyB8ICd4JScgfCB7bnVtYmVyfVxuICAgIHRvcDogJ2NlbnRlcicsXG4gICAgLy8gcmlnaHRcbiAgICAvLyBib3R0b21cbiAgICAvLyB3aWR0aDpcbiAgICAvLyBoZWlnaHRcbiAgICAvLyBBc3BlY3QgaXMgd2lkdGggLyBoZWlnaHQuIEluaXRlZCB0byBiZSBnZW9Kc29uIGJib3ggYXNwZWN0XG4gICAgLy8gVGhpcyBwYXJhbWV0ZXIgaXMgdXNlZCBmb3Igc2NhbGUgdGhpcyBhc3BlY3RcbiAgICBhc3BlY3RTY2FsZTogMC43NSxcbiAgICAvLy8vLyBMYXlvdXQgd2l0aCBjZW50ZXIgYW5kIHNpemVcbiAgICAvLyBJZiB5b3Ugd2FuJ3QgdG8gcHV0IG1hcCBpbiBhIGZpeGVkIHNpemUgYm94IHdpdGggcmlnaHQgYXNwZWN0IHJhdGlvXG4gICAgLy8gVGhpcyB0d28gcHJvcGVydGllcyBtYXkgbW9yZSBjb252ZW5pbmV0XG4gICAgLy8gbGF5b3V0Q2VudGVyOiBbNTAlLCA1MCVdXG4gICAgLy8gbGF5b3V0U2l6ZTogMTAwXG4gICAgc2hvd0xlZ2VuZFN5bWJvbDogdHJ1ZSxcbiAgICAvLyBEZWZpbmUgbGVmdC10b3AsIHJpZ2h0LWJvdHRvbSBjb29yZHMgdG8gY29udHJvbCB2aWV3XG4gICAgLy8gRm9yIGV4YW1wbGUsIFsgWzE4MCwgOTBdLCBbLTE4MCwgLTkwXSBdLFxuICAgIC8vIGhpZ2hlciBwcmlvcml0eSB0aGFuIGNlbnRlciBhbmQgem9vbVxuICAgIGJvdW5kaW5nQ29vcmRzOiBudWxsLFxuICAgIC8vIERlZmF1bHQgb24gY2VudGVyIG9mIG1hcFxuICAgIGNlbnRlcjogbnVsbCxcbiAgICB6b29tOiAxLFxuICAgIHNjYWxlTGltaXQ6IG51bGwsXG4gICAgc2VsZWN0ZWRNb2RlOiB0cnVlLFxuICAgIGxhYmVsOiB7XG4gICAgICBzaG93OiBmYWxzZSxcbiAgICAgIGNvbG9yOiAnIzAwMCdcbiAgICB9LFxuICAgIC8vIHNjYWxlTGltaXQ6IG51bGwsXG4gICAgaXRlbVN0eWxlOiB7XG4gICAgICBib3JkZXJXaWR0aDogMC41LFxuICAgICAgYm9yZGVyQ29sb3I6ICcjNDQ0JyxcbiAgICAgIGFyZWFDb2xvcjogJyNlZWUnXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgY29sb3I6ICdyZ2IoMTAwLDAsMCknXG4gICAgICB9LFxuICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgIGFyZWFDb2xvcjogJ3JnYmEoMjU1LDIxNSwwLDAuOCknXG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3Q6IHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIGNvbG9yOiAncmdiKDEwMCwwLDApJ1xuICAgICAgfSxcbiAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICBjb2xvcjogJ3JnYmEoMjU1LDIxNSwwLDAuOCknXG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lUHJvcGVydHk6ICduYW1lJ1xuICB9O1xuICByZXR1cm4gTWFwU2VyaWVzO1xufShTZXJpZXNNb2RlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcFNlcmllczsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgTWFwRHJhdyBmcm9tICcuLi8uLi9jb21wb25lbnQvaGVscGVyL01hcERyYXcnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0JztcbmltcG9ydCB7IHNldExhYmVsU3R5bGUsIGdldExhYmVsU3RhdGVzTW9kZWxzIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZSc7XG5pbXBvcnQgeyBaMl9FTVBIQVNJU19MSUZUIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMnO1xuO1xuXG52YXIgTWFwVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNYXBWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE1hcFZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gTWFwVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIE1hcFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChtYXBNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgLy8gTm90IHJlbmRlciBpZiBpdCBpcyBhbiB0b2dnbGVTZWxlY3QgYWN0aW9uIGZyb20gc2VsZlxuICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQudHlwZSA9PT0gJ21hcFRvZ2dsZVNlbGVjdCcgJiYgcGF5bG9hZC5mcm9tID09PSB0aGlzLnVpZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICBpZiAobWFwTW9kZWwuZ2V0SG9zdEdlb01vZGVsKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIE5vdCB1cGRhdGUgbWFwIGlmIGl0IGlzIGFuIHJvYW0gYWN0aW9uIGZyb20gc2VsZlxuXG5cbiAgICBpZiAoIShwYXlsb2FkICYmIHBheWxvYWQudHlwZSA9PT0gJ2dlb1JvYW0nICYmIHBheWxvYWQuY29tcG9uZW50VHlwZSA9PT0gJ3NlcmllcycgJiYgcGF5bG9hZC5zZXJpZXNJZCA9PT0gbWFwTW9kZWwuaWQpKSB7XG4gICAgICBpZiAobWFwTW9kZWwubmVlZHNEcmF3TWFwKSB7XG4gICAgICAgIHZhciBtYXBEcmF3ID0gdGhpcy5fbWFwRHJhdyB8fCBuZXcgTWFwRHJhdyhhcGkpO1xuICAgICAgICBncm91cC5hZGQobWFwRHJhdy5ncm91cCk7XG4gICAgICAgIG1hcERyYXcuZHJhdyhtYXBNb2RlbCwgZWNNb2RlbCwgYXBpLCB0aGlzLCBwYXlsb2FkKTtcbiAgICAgICAgdGhpcy5fbWFwRHJhdyA9IG1hcERyYXc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZW1vdmUgZHJhd2VkIG1hcFxuICAgICAgICB0aGlzLl9tYXBEcmF3ICYmIHRoaXMuX21hcERyYXcucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuX21hcERyYXcgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWFwRHJhdyA9IHRoaXMuX21hcERyYXc7XG4gICAgICBtYXBEcmF3ICYmIGdyb3VwLmFkZChtYXBEcmF3Lmdyb3VwKTtcbiAgICB9XG5cbiAgICBtYXBNb2RlbC5nZXQoJ3Nob3dMZWdlbmRTeW1ib2wnKSAmJiBlY01vZGVsLmdldENvbXBvbmVudCgnbGVnZW5kJykgJiYgdGhpcy5fcmVuZGVyU3ltYm9scyhtYXBNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgfTtcblxuICBNYXBWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbWFwRHJhdyAmJiB0aGlzLl9tYXBEcmF3LnJlbW92ZSgpO1xuICAgIHRoaXMuX21hcERyYXcgPSBudWxsO1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gIH07XG5cbiAgTWFwVmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9tYXBEcmF3ICYmIHRoaXMuX21hcERyYXcucmVtb3ZlKCk7XG4gICAgdGhpcy5fbWFwRHJhdyA9IG51bGw7XG4gIH07XG5cbiAgTWFwVmlldy5wcm90b3R5cGUuX3JlbmRlclN5bWJvbHMgPSBmdW5jdGlvbiAobWFwTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBvcmlnaW5hbERhdGEgPSBtYXBNb2RlbC5vcmlnaW5hbERhdGE7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICBvcmlnaW5hbERhdGEuZWFjaChvcmlnaW5hbERhdGEubWFwRGltZW5zaW9uKCd2YWx1ZScpLCBmdW5jdGlvbiAodmFsdWUsIG9yaWdpbmFsRGF0YUluZGV4KSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGxheW91dCA9IG9yaWdpbmFsRGF0YS5nZXRJdGVtTGF5b3V0KG9yaWdpbmFsRGF0YUluZGV4KTtcblxuICAgICAgaWYgKCFsYXlvdXQgfHwgIWxheW91dC5wb2ludCkge1xuICAgICAgICAvLyBOb3QgZXhpc3RzIGluIG1hcFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludCA9IGxheW91dC5wb2ludDtcbiAgICAgIHZhciBvZmZzZXQgPSBsYXlvdXQub2Zmc2V0O1xuICAgICAgdmFyIGNpcmNsZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgLy8gQmVjYXVzZSB0aGUgc3BlY2lhbCBvZiBtYXAgZHJhdy5cbiAgICAgICAgICAvLyBXaGljaCBuZWVkcyBzdGF0aXN0aWMgb2YgbXVsdGlwbGUgc2VyaWVzIGFuZCBkcmF3IG9uIG9uZSBtYXAuXG4gICAgICAgICAgLy8gQW5kIGVhY2ggc2VyaWVzIGFsc28gbmVlZCBhIHN5bWJvbCB3aXRoIGxlZ2VuZCBjb2xvclxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gTGF5b3V0IGFuZCB2aXN1YWwgYXJlIHB1dCBvbmUgdGhlIGRpZmZlcmVudCBkYXRhXG4gICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgIGZpbGw6IG1hcE1vZGVsLmdldERhdGEoKS5nZXRWaXN1YWwoJ3N0eWxlJykuZmlsbFxuICAgICAgICB9LFxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIGN4OiBwb2ludFswXSArIG9mZnNldCAqIDksXG4gICAgICAgICAgY3k6IHBvaW50WzFdLFxuICAgICAgICAgIHI6IDNcbiAgICAgICAgfSxcbiAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICAvLyBEbyBub3Qgb3ZlcmxhcCB0aGUgZmlyc3Qgc2VyaWVzLCBvbiB3aGljaCBsYWJlbHMgYXJlIGRpc3BsYXllZC5cbiAgICAgICAgejI6IDggKyAoIW9mZnNldCA/IFoyX0VNUEhBU0lTX0xJRlQgKyAxIDogMClcbiAgICAgIH0pOyAvLyBPbmx5IHRoZSBzZXJpZXMgdGhhdCBoYXMgdGhlIGZpcnN0IHZhbHVlIG9uIHRoZSBzYW1lIHJlZ2lvbiBpcyBpbiBjaGFyZ2Ugb2YgcmVuZGVyaW5nIHRoZSBsYWJlbC5cbiAgICAgIC8vIEJ1dCBjb25zaWRlciB0aGUgY2FzZTpcbiAgICAgIC8vIHNlcmllczogW1xuICAgICAgLy8gICAgIHtpZDogJ1gnLCB0eXBlOiAnbWFwJywgbWFwOiAnbScsIHtkYXRhOiBbe25hbWU6ICdBJywgdmFsdWU6IDExfSwge25hbWU6ICdCJywge3ZhbHVlOiAyMn1dfSxcbiAgICAgIC8vICAgICB7aWQ6ICdZJywgdHlwZTogJ21hcCcsIG1hcDogJ20nLCB7ZGF0YTogW3tuYW1lOiAnQScsIHZhbHVlOiAyMX0sIHtuYW1lOiAnQycsIHt2YWx1ZTogMzN9XX1cbiAgICAgIC8vIF1cbiAgICAgIC8vIFRoZSBvZmZzZXQgYDBgIG9mIGl0ZW0gYEFgIGlzIGF0IHNlcmllcyBgWGAsIGJ1dCBvZiBpdGVtIGBDYCBpcyBhdCBzZXJpZXMgYFlgLlxuICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHdlIGZvbGxvdyB0aGUgcnVsZSB0aGF0IHJlbmRlciBsYWJlbCBgQWAgYnkgdGhlXG4gICAgICAvLyBzZXR0aW5ncyBvbiBzZXJpZXMgYFhgIGJ1dCByZW5kZXIgbGFiZWwgYENgIGJ5IHRoZSBzZXR0aW5ncyBvbiBzZXJpZXMgYFlgLlxuXG4gICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICB2YXIgZnVsbERhdGEgPSBtYXBNb2RlbC5tYWluU2VyaWVzLmdldERhdGEoKTtcbiAgICAgICAgdmFyIG5hbWVfMSA9IG9yaWdpbmFsRGF0YS5nZXROYW1lKG9yaWdpbmFsRGF0YUluZGV4KTtcbiAgICAgICAgdmFyIGZ1bGxJbmRleF8xID0gZnVsbERhdGEuaW5kZXhPZk5hbWUobmFtZV8xKTtcbiAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IG9yaWdpbmFsRGF0YS5nZXRJdGVtTW9kZWwob3JpZ2luYWxEYXRhSW5kZXgpO1xuICAgICAgICB2YXIgbGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwnKTtcbiAgICAgICAgdmFyIHJlZ2lvbkdyb3VwID0gZnVsbERhdGEuZ2V0SXRlbUdyYXBoaWNFbChmdWxsSW5kZXhfMSk7IC8vIGBnZXRGb3JtYXR0ZWRMYWJlbGAgbmVlZHMgdG8gdXNlIGBnZXREYXRhYCBpbnNpZGUuIEhlcmVcbiAgICAgICAgLy8gYG1hcE1vZGVsLmdldERhdGEoKWAgaXMgc2hhbGxvdyBjbG9uZWQgZnJvbSBgbWFpblNlcmllcy5nZXREYXRhKClgLlxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCB0aGUgYG1haW5TZXJpZXNgLCB0aGUgaXRlbSBtb2RlbCAobGlrZSBsYWJlbCBmb3JtYXR0ZXIpXG4gICAgICAgIC8vIHNldCBvbiBvcmlnaW5hbCBkYXRhIGl0ZW0gd2lsbCBuZXZlciBnZXQuIEJ1dCBpdCBoYXMgYmVlbiB3b3JraW5nXG4gICAgICAgIC8vIGxpa2UgdGhhdCBmcm9tIHRoZSBiZWdpbmluZywgYW5kIHRoaXMgc2NlbmFyaW8gaXMgcmFyZWx5IGVuY291bnRlcmVkLlxuICAgICAgICAvLyBTbyBpdCB3b24ndCBiZSBmaXhlZCB1bnRpbCBoYXZlIHRvLlxuXG4gICAgICAgIHNldExhYmVsU3R5bGUoY2lyY2xlLCBnZXRMYWJlbFN0YXRlc01vZGVscyhpdGVtTW9kZWwpLCB7XG4gICAgICAgICAgbGFiZWxGZXRjaGVyOiB7XG4gICAgICAgICAgICBnZXRGb3JtYXR0ZWRMYWJlbDogZnVuY3Rpb24gKGlkeCwgc3RhdGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hcE1vZGVsLmdldEZvcm1hdHRlZExhYmVsKGZ1bGxJbmRleF8xLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2lyY2xlLmRpc2FibGVMYWJlbEFuaW1hdGlvbiA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFsYWJlbE1vZGVsLmdldCgncG9zaXRpb24nKSkge1xuICAgICAgICAgIGNpcmNsZS5zZXRUZXh0Q29uZmlnKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYm90dG9tJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaW9uR3JvdXAub25Ib3ZlclN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKHRvU3RhdGUpIHtcbiAgICAgICAgICBjaXJjbGUudXNlU3RhdGUodG9TdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGdyb3VwLmFkZChjaXJjbGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIE1hcFZpZXcudHlwZSA9ICdtYXAnO1xuICByZXR1cm4gTWFwVmlldztcbn0oQ2hhcnRWaWV3KTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgdXNlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9uJztcbmltcG9ydCBNYXBWaWV3IGZyb20gJy4vTWFwVmlldyc7XG5pbXBvcnQgTWFwU2VyaWVzIGZyb20gJy4vTWFwU2VyaWVzJztcbmltcG9ydCBtYXBEYXRhU3RhdGlzdGljIGZyb20gJy4vbWFwRGF0YVN0YXRpc3RpYyc7XG5pbXBvcnQgbWFwU3ltYm9sTGF5b3V0IGZyb20gJy4vbWFwU3ltYm9sTGF5b3V0JztcbmltcG9ydCB7IGNyZWF0ZUxlZ2FjeURhdGFTZWxlY3RBY3Rpb24gfSBmcm9tICcuLi8uLi9sZWdhY3kvZGF0YVNlbGVjdEFjdGlvbic7XG5pbXBvcnQgeyBpbnN0YWxsIGFzIGluc3RhbGxHZW8gfSBmcm9tICcuLi8uLi9jb21wb25lbnQvZ2VvL2luc3RhbGwnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHVzZShpbnN0YWxsR2VvKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ2hhcnRWaWV3KE1hcFZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChNYXBTZXJpZXMpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQobWFwU3ltYm9sTGF5b3V0KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJvY2Vzc29yKHJlZ2lzdGVycy5QUklPUklUWS5QUk9DRVNTT1IuU1RBVElTVElDLCBtYXBEYXRhU3RhdGlzdGljKTtcbiAgY3JlYXRlTGVnYWN5RGF0YVNlbGVjdEFjdGlvbignbWFwJywgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7IC8vIEZJWE1FIOWFrOeUqO+8n1xuXG5mdW5jdGlvbiBkYXRhU3RhdGlzdGljcyhkYXRhcywgc3RhdGlzdGljVHlwZSkge1xuICB2YXIgZGF0YU5hbWVNYXAgPSB7fTtcbiAgenJVdGlsLmVhY2goZGF0YXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGF0YS5lYWNoKGRhdGEubWFwRGltZW5zaW9uKCd2YWx1ZScpLCBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgLy8gQWRkIHByZWZpeCB0byBhdm9pZCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUuXG4gICAgICB2YXIgbWFwS2V5ID0gJ2VjLScgKyBkYXRhLmdldE5hbWUoaWR4KTtcbiAgICAgIGRhdGFOYW1lTWFwW21hcEtleV0gPSBkYXRhTmFtZU1hcFttYXBLZXldIHx8IFtdO1xuXG4gICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICBkYXRhTmFtZU1hcFttYXBLZXldLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGRhdGFzWzBdLm1hcChkYXRhc1swXS5tYXBEaW1lbnNpb24oJ3ZhbHVlJyksIGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgdmFyIG1hcEtleSA9ICdlYy0nICsgZGF0YXNbMF0uZ2V0TmFtZShpZHgpO1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgIHZhciBsZW4gPSBkYXRhTmFtZU1hcFttYXBLZXldLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgZGF0YU5hbWVNYXBbbWFwS2V5XVtpXSk7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFOYW1lTWFwW21hcEtleV1baV0pO1xuICAgICAgc3VtICs9IGRhdGFOYW1lTWFwW21hcEtleV1baV07XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChzdGF0aXN0aWNUeXBlID09PSAnbWluJykge1xuICAgICAgcmVzdWx0ID0gbWluO1xuICAgIH0gZWxzZSBpZiAoc3RhdGlzdGljVHlwZSA9PT0gJ21heCcpIHtcbiAgICAgIHJlc3VsdCA9IG1heDtcbiAgICB9IGVsc2UgaWYgKHN0YXRpc3RpY1R5cGUgPT09ICdhdmVyYWdlJykge1xuICAgICAgcmVzdWx0ID0gc3VtIC8gbGVuO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBzdW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlbiA9PT0gMCA/IE5hTiA6IHJlc3VsdDtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1hcERhdGFTdGF0aXN0aWMoZWNNb2RlbCkge1xuICB2YXIgc2VyaWVzR3JvdXBzID0ge307XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgnbWFwJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGhvc3RHZW9Nb2RlbCA9IHNlcmllc01vZGVsLmdldEhvc3RHZW9Nb2RlbCgpO1xuICAgIHZhciBrZXkgPSBob3N0R2VvTW9kZWwgPyAnbycgKyBob3N0R2VvTW9kZWwuaWQgOiAnaScgKyBzZXJpZXNNb2RlbC5nZXRNYXBUeXBlKCk7XG4gICAgKHNlcmllc0dyb3Vwc1trZXldID0gc2VyaWVzR3JvdXBzW2tleV0gfHwgW10pLnB1c2goc2VyaWVzTW9kZWwpO1xuICB9KTtcbiAgenJVdGlsLmVhY2goc2VyaWVzR3JvdXBzLCBmdW5jdGlvbiAoc2VyaWVzTGlzdCwga2V5KSB7XG4gICAgdmFyIGRhdGEgPSBkYXRhU3RhdGlzdGljcyh6clV0aWwubWFwKHNlcmllc0xpc3QsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgcmV0dXJuIHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB9KSwgc2VyaWVzTGlzdFswXS5nZXQoJ21hcFZhbHVlQ2FsY3VsYXRpb24nKSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmllc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlcmllc0xpc3RbaV0ub3JpZ2luYWxEYXRhID0gc2VyaWVzTGlzdFtpXS5nZXREYXRhKCk7XG4gICAgfSAvLyBGSVhNRSBQdXQgd2hlcmU/XG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyaWVzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgc2VyaWVzTGlzdFtpXS5zZXJpZXNHcm91cCA9IHNlcmllc0xpc3Q7XG4gICAgICBzZXJpZXNMaXN0W2ldLm5lZWRzRHJhd01hcCA9IGkgPT09IDAgJiYgIXNlcmllc0xpc3RbaV0uZ2V0SG9zdEdlb01vZGVsKCk7XG4gICAgICBzZXJpZXNMaXN0W2ldLnNldERhdGEoZGF0YS5jbG9uZVNoYWxsb3coKSk7XG4gICAgICBzZXJpZXNMaXN0W2ldLm1haW5TZXJpZXMgPSBzZXJpZXNMaXN0WzBdO1xuICAgIH1cbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWFwU3ltYm9sTGF5b3V0KGVjTW9kZWwpIHtcbiAgdmFyIHByb2Nlc3NlZE1hcFR5cGUgPSB7fTtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCdtYXAnLCBmdW5jdGlvbiAobWFwU2VyaWVzKSB7XG4gICAgdmFyIG1hcFR5cGUgPSBtYXBTZXJpZXMuZ2V0TWFwVHlwZSgpO1xuXG4gICAgaWYgKG1hcFNlcmllcy5nZXRIb3N0R2VvTW9kZWwoKSB8fCBwcm9jZXNzZWRNYXBUeXBlW21hcFR5cGVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1hcFN5bWJvbE9mZnNldHMgPSB7fTtcbiAgICB6clV0aWwuZWFjaChtYXBTZXJpZXMuc2VyaWVzR3JvdXAsIGZ1bmN0aW9uIChzdWJNYXBTZXJpZXMpIHtcbiAgICAgIHZhciBnZW8gPSBzdWJNYXBTZXJpZXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgIHZhciBkYXRhID0gc3ViTWFwU2VyaWVzLm9yaWdpbmFsRGF0YTtcblxuICAgICAgaWYgKHN1Yk1hcFNlcmllcy5nZXQoJ3Nob3dMZWdlbmRTeW1ib2wnKSAmJiBlY01vZGVsLmdldENvbXBvbmVudCgnbGVnZW5kJykpIHtcbiAgICAgICAgZGF0YS5lYWNoKGRhdGEubWFwRGltZW5zaW9uKCd2YWx1ZScpLCBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGlkeCk7XG4gICAgICAgICAgdmFyIHJlZ2lvbiA9IGdlby5nZXRSZWdpb24obmFtZSk7IC8vIElmIGlucHV0IHNlcmllcy5kYXRhIGlzIFsxMSwgMjIsICctJy9udWxsL3VuZGVmaW5lZCwgNDRdLFxuICAgICAgICAgIC8vIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggTmFOOiBbMTEsIDIyLCBOYU4sIDQ0XSBhbmQgTmFOIHdpbGxcbiAgICAgICAgICAvLyBub3QgYmUgZHJhd24uIFNvIGhlcmUgbXVzdCB2YWxpZGF0ZSBpZiB2YWx1ZSBpcyBOYU4uXG5cbiAgICAgICAgICBpZiAoIXJlZ2lvbiB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gbWFwU3ltYm9sT2Zmc2V0c1tuYW1lXSB8fCAwO1xuICAgICAgICAgIHZhciBwb2ludCA9IGdlby5kYXRhVG9Qb2ludChyZWdpb24uY2VudGVyKTtcbiAgICAgICAgICBtYXBTeW1ib2xPZmZzZXRzW25hbWVdID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCB7XG4gICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTsgLy8gU2hvdyBsYWJlbCBvZiB0aG9zZSByZWdpb24gbm90IGhhcyBsZWdlbmRTeW1ib2wod2hpY2ggaXMgb2Zmc2V0IDApXG5cbiAgICB2YXIgZGF0YSA9IG1hcFNlcmllcy5nZXREYXRhKCk7XG4gICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGlkeCk7XG4gICAgICB2YXIgbGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCkgfHwge307XG4gICAgICBsYXlvdXQuc2hvd0xhYmVsID0gIW1hcFN5bWJvbE9mZnNldHNbbmFtZV07XG4gICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBsYXlvdXQpO1xuICAgIH0pO1xuICAgIHByb2Nlc3NlZE1hcFR5cGVbbWFwVHlwZV0gPSB0cnVlO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBlYWNoLCBiaW5kIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9TZXJpZXMnO1xuaW1wb3J0IGNyZWF0ZUxpc3RGcm9tQXJyYXkgZnJvbSAnLi4vaGVscGVyL2NyZWF0ZUxpc3RGcm9tQXJyYXknO1xuXG52YXIgUGFyYWxsZWxTZXJpZXNNb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQYXJhbGxlbFNlcmllc01vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFBhcmFsbGVsU2VyaWVzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gUGFyYWxsZWxTZXJpZXNNb2RlbC50eXBlO1xuICAgIF90aGlzLnZpc3VhbFN0eWxlQWNjZXNzUGF0aCA9ICdsaW5lU3R5bGUnO1xuICAgIF90aGlzLnZpc3VhbERyYXdUeXBlID0gJ3N0cm9rZSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUGFyYWxsZWxTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0SW5pdGlhbERhdGEgPSBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxpc3RGcm9tQXJyYXkodGhpcy5nZXRTb3VyY2UoKSwgdGhpcywge1xuICAgICAgdXNlRW5jb2RlRGVmYXVsdGVyOiBiaW5kKG1ha2VEZWZhdWx0RW5jb2RlLCBudWxsLCB0aGlzKVxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogVXNlciBjYW4gZ2V0IGRhdGEgcmF3IGluZGljZXMgb24gJ2F4aXNBcmVhU2VsZWN0ZWQnIGV2ZW50IHJlY2VpdmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIFJhdyBpbmRpY2VzXG4gICAqL1xuXG5cbiAgUGFyYWxsZWxTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0UmF3SW5kaWNlc0J5QWN0aXZlU3RhdGUgPSBmdW5jdGlvbiAoYWN0aXZlU3RhdGUpIHtcbiAgICB2YXIgY29vcmRTeXMgPSB0aGlzLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoKTtcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIGNvb3JkU3lzLmVhY2hBY3RpdmVTdGF0ZShkYXRhLCBmdW5jdGlvbiAodGhlQWN0aXZlU3RhdGUsIGRhdGFJbmRleCkge1xuICAgICAgaWYgKGFjdGl2ZVN0YXRlID09PSB0aGVBY3RpdmVTdGF0ZSkge1xuICAgICAgICBpbmRpY2VzLnB1c2goZGF0YS5nZXRSYXdJbmRleChkYXRhSW5kZXgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfTtcblxuICBQYXJhbGxlbFNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLnBhcmFsbGVsJztcbiAgUGFyYWxsZWxTZXJpZXNNb2RlbC5kZXBlbmRlbmNpZXMgPSBbJ3BhcmFsbGVsJ107XG4gIFBhcmFsbGVsU2VyaWVzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogMixcbiAgICBjb29yZGluYXRlU3lzdGVtOiAncGFyYWxsZWwnLFxuICAgIHBhcmFsbGVsSW5kZXg6IDAsXG4gICAgbGFiZWw6IHtcbiAgICAgIHNob3c6IGZhbHNlXG4gICAgfSxcbiAgICBpbmFjdGl2ZU9wYWNpdHk6IDAuMDUsXG4gICAgYWN0aXZlT3BhY2l0eTogMSxcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgb3BhY2l0eTogMC40NSxcbiAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICB9LFxuICAgIGVtcGhhc2lzOiB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG4gICAgcHJvZ3Jlc3NpdmU6IDUwMCxcbiAgICBzbW9vdGg6IGZhbHNlLFxuICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcidcbiAgfTtcbiAgcmV0dXJuIFBhcmFsbGVsU2VyaWVzTW9kZWw7XG59KFNlcmllc01vZGVsKTtcblxuZnVuY3Rpb24gbWFrZURlZmF1bHRFbmNvZGUoc2VyaWVzTW9kZWwpIHtcbiAgLy8gVGhlIG1hcHBpbmcgb2YgcGFyYWxsZWxBeGlzIGRpbWVuc2lvbiB0byBkYXRhIGRpbWVuc2lvbiBjYW5cbiAgLy8gYmUgc3BlY2lmaWVkIGluIHBhcmFsbGVsQXhpcy5vcHRpb24uZGltLiBGb3IgZXhhbXBsZSwgaWZcbiAgLy8gcGFyYWxsZWxBeGlzLm9wdGlvbi5kaW0gaXMgJ2RpbTMnLCBpdCBtYXBwaW5nIHRvIHRoZSB0aGlyZFxuICAvLyBkaW1lbnNpb24gb2YgZGF0YS4gQnV0IGBkYXRhLmVuY29kZWAgaGFzIGhpZ2hlciBwcmlvcml0eS5cbiAgLy8gTW9yZW92ZXIsIHBhcmFsbGVsTW9kZWwuZGltZW5zaW9uIHNob3VsZCBub3QgYmUgcmVnYXJkZWQgYXMgZGF0YVxuICAvLyBkaW1lbnNpb25zLiBDb25zaWRlciBkaW1lbnNpb25zID0gWydkaW00JywgJ2RpbTInLCAnZGltNiddO1xuICB2YXIgcGFyYWxsZWxNb2RlbCA9IHNlcmllc01vZGVsLmVjTW9kZWwuZ2V0Q29tcG9uZW50KCdwYXJhbGxlbCcsIHNlcmllc01vZGVsLmdldCgncGFyYWxsZWxJbmRleCcpKTtcblxuICBpZiAoIXBhcmFsbGVsTW9kZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZW5jb2RlRGVmaW5lID0ge307XG4gIGVhY2gocGFyYWxsZWxNb2RlbC5kaW1lbnNpb25zLCBmdW5jdGlvbiAoYXhpc0RpbSkge1xuICAgIHZhciBkYXRhRGltSW5kZXggPSBjb252ZXJ0RGltTmFtZVRvTnVtYmVyKGF4aXNEaW0pO1xuICAgIGVuY29kZURlZmluZVtheGlzRGltXSA9IGRhdGFEaW1JbmRleDtcbiAgfSk7XG4gIHJldHVybiBlbmNvZGVEZWZpbmU7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnREaW1OYW1lVG9OdW1iZXIoZGltTmFtZSkge1xuICByZXR1cm4gK2RpbU5hbWUucmVwbGFjZSgnZGltJywgJycpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBQYXJhbGxlbFNlcmllc01vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCB7IHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbCwgZW5hYmxlSG92ZXJFbXBoYXNpcyB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdGVzJztcbmltcG9ydCBDaGFydFZpZXcgZnJvbSAnLi4vLi4vdmlldy9DaGFydCc7XG5pbXBvcnQgeyBudW1lcmljVG9OdW1iZXIgfSBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG5pbXBvcnQgeyBlcU5hTiB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG52YXIgREVGQVVMVF9TTU9PVEggPSAwLjM7XG5cbnZhciBQYXJhbGxlbFZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUGFyYWxsZWxWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFBhcmFsbGVsVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBQYXJhbGxlbFZpZXcudHlwZTtcbiAgICBfdGhpcy5fZGF0YUdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICBfdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBQYXJhbGxlbFZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5fZGF0YUdyb3VwKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIFBhcmFsbGVsVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB2YXIgZGF0YUdyb3VwID0gdGhpcy5fZGF0YUdyb3VwO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBkaW1lbnNpb25zID0gY29vcmRTeXMuZGltZW5zaW9ucztcbiAgICB2YXIgc2VyaWVzU2NvcGUgPSBtYWtlU2VyaWVzU2NvcGUoc2VyaWVzTW9kZWwpO1xuICAgIGRhdGEuZGlmZihvbGREYXRhKS5hZGQoYWRkKS51cGRhdGUodXBkYXRlKS5yZW1vdmUocmVtb3ZlKS5leGVjdXRlKCk7XG5cbiAgICBmdW5jdGlvbiBhZGQobmV3RGF0YUluZGV4KSB7XG4gICAgICB2YXIgbGluZSA9IGFkZEVsKGRhdGEsIGRhdGFHcm91cCwgbmV3RGF0YUluZGV4LCBkaW1lbnNpb25zLCBjb29yZFN5cyk7XG4gICAgICB1cGRhdGVFbENvbW1vbihsaW5lLCBkYXRhLCBuZXdEYXRhSW5kZXgsIHNlcmllc1Njb3BlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGUobmV3RGF0YUluZGV4LCBvbGREYXRhSW5kZXgpIHtcbiAgICAgIHZhciBsaW5lID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZERhdGFJbmRleCk7XG4gICAgICB2YXIgcG9pbnRzID0gY3JlYXRlTGluZVBvaW50cyhkYXRhLCBuZXdEYXRhSW5kZXgsIGRpbWVuc2lvbnMsIGNvb3JkU3lzKTtcbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdEYXRhSW5kZXgsIGxpbmUpO1xuICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhsaW5lLCB7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgICAgfVxuICAgICAgfSwgc2VyaWVzTW9kZWwsIG5ld0RhdGFJbmRleCk7XG4gICAgICB1cGRhdGVFbENvbW1vbihsaW5lLCBkYXRhLCBuZXdEYXRhSW5kZXgsIHNlcmllc1Njb3BlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUob2xkRGF0YUluZGV4KSB7XG4gICAgICB2YXIgbGluZSA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGREYXRhSW5kZXgpO1xuICAgICAgZGF0YUdyb3VwLnJlbW92ZShsaW5lKTtcbiAgICB9IC8vIEZpcnN0IGNyZWF0ZVxuXG5cbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB2YXIgY2xpcFBhdGggPSBjcmVhdGVHcmlkQ2xpcFNoYXBlKGNvb3JkU3lzLCBzZXJpZXNNb2RlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDYWxsYmFjayB3aWxsIGJlIGludm9rZWQgaW1tZWRpYXRlbHkgaWYgdGhlcmUgaXMgbm8gYW5pbWF0aW9uXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRhdGFHcm91cC5yZW1vdmVDbGlwUGF0aCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZGF0YUdyb3VwLnNldENsaXBQYXRoKGNsaXBQYXRoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfTtcblxuICBQYXJhbGxlbFZpZXcucHJvdG90eXBlLmluY3JlbWVudGFsUHJlcGFyZVJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuXG4gICAgdGhpcy5fZGF0YUdyb3VwLnJlbW92ZUFsbCgpO1xuICB9O1xuXG4gIFBhcmFsbGVsVmlldy5wcm90b3R5cGUuaW5jcmVtZW50YWxSZW5kZXIgPSBmdW5jdGlvbiAodGFza1BhcmFtcywgc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBkaW1lbnNpb25zID0gY29vcmRTeXMuZGltZW5zaW9ucztcbiAgICB2YXIgc2VyaWVzU2NvcGUgPSBtYWtlU2VyaWVzU2NvcGUoc2VyaWVzTW9kZWwpO1xuXG4gICAgZm9yICh2YXIgZGF0YUluZGV4ID0gdGFza1BhcmFtcy5zdGFydDsgZGF0YUluZGV4IDwgdGFza1BhcmFtcy5lbmQ7IGRhdGFJbmRleCsrKSB7XG4gICAgICB2YXIgbGluZSA9IGFkZEVsKGRhdGEsIHRoaXMuX2RhdGFHcm91cCwgZGF0YUluZGV4LCBkaW1lbnNpb25zLCBjb29yZFN5cyk7XG4gICAgICBsaW5lLmluY3JlbWVudGFsID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZUVsQ29tbW9uKGxpbmUsIGRhdGEsIGRhdGFJbmRleCwgc2VyaWVzU2NvcGUpO1xuICAgIH1cbiAgfTtcblxuICBQYXJhbGxlbFZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9kYXRhR3JvdXAgJiYgdGhpcy5fZGF0YUdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICB9O1xuXG4gIFBhcmFsbGVsVmlldy50eXBlID0gJ3BhcmFsbGVsJztcbiAgcmV0dXJuIFBhcmFsbGVsVmlldztcbn0oQ2hhcnRWaWV3KTtcblxuZnVuY3Rpb24gY3JlYXRlR3JpZENsaXBTaGFwZShjb29yZFN5cywgc2VyaWVzTW9kZWwsIGNiKSB7XG4gIHZhciBwYXJhbGxlbE1vZGVsID0gY29vcmRTeXMubW9kZWw7XG4gIHZhciByZWN0ID0gY29vcmRTeXMuZ2V0UmVjdCgpO1xuICB2YXIgcmVjdEVsID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgc2hhcGU6IHtcbiAgICAgIHg6IHJlY3QueCxcbiAgICAgIHk6IHJlY3QueSxcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgIH1cbiAgfSk7XG4gIHZhciBkaW0gPSBwYXJhbGxlbE1vZGVsLmdldCgnbGF5b3V0JykgPT09ICdob3Jpem9udGFsJyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgcmVjdEVsLnNldFNoYXBlKGRpbSwgMCk7XG4gIGdyYXBoaWMuaW5pdFByb3BzKHJlY3RFbCwge1xuICAgIHNoYXBlOiB7XG4gICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICB9XG4gIH0sIHNlcmllc01vZGVsLCBjYik7XG4gIHJldHVybiByZWN0RWw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmVQb2ludHMoZGF0YSwgZGF0YUluZGV4LCBkaW1lbnNpb25zLCBjb29yZFN5cykge1xuICB2YXIgcG9pbnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpbU5hbWUgPSBkaW1lbnNpb25zW2ldO1xuICAgIHZhciB2YWx1ZSA9IGRhdGEuZ2V0KGRhdGEubWFwRGltZW5zaW9uKGRpbU5hbWUpLCBkYXRhSW5kZXgpO1xuXG4gICAgaWYgKCFpc0VtcHR5VmFsdWUodmFsdWUsIGNvb3JkU3lzLmdldEF4aXMoZGltTmFtZSkudHlwZSkpIHtcbiAgICAgIHBvaW50cy5wdXNoKGNvb3JkU3lzLmRhdGFUb1BvaW50KHZhbHVlLCBkaW1OYW1lKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn1cblxuZnVuY3Rpb24gYWRkRWwoZGF0YSwgZGF0YUdyb3VwLCBkYXRhSW5kZXgsIGRpbWVuc2lvbnMsIGNvb3JkU3lzKSB7XG4gIHZhciBwb2ludHMgPSBjcmVhdGVMaW5lUG9pbnRzKGRhdGEsIGRhdGFJbmRleCwgZGltZW5zaW9ucywgY29vcmRTeXMpO1xuICB2YXIgbGluZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHtcbiAgICBzaGFwZToge1xuICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICB9LFxuICAgIC8vIHNpbGVudDogdHJ1ZSxcbiAgICB6MjogMTBcbiAgfSk7XG4gIGRhdGFHcm91cC5hZGQobGluZSk7XG4gIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIGxpbmUpO1xuICByZXR1cm4gbGluZTtcbn1cblxuZnVuY3Rpb24gbWFrZVNlcmllc1Njb3BlKHNlcmllc01vZGVsKSB7XG4gIHZhciBzbW9vdGggPSBzZXJpZXNNb2RlbC5nZXQoJ3Ntb290aCcsIHRydWUpO1xuICBzbW9vdGggPT09IHRydWUgJiYgKHNtb290aCA9IERFRkFVTFRfU01PT1RIKTtcbiAgc21vb3RoID0gbnVtZXJpY1RvTnVtYmVyKHNtb290aCk7XG4gIGVxTmFOKHNtb290aCkgJiYgKHNtb290aCA9IDApO1xuICByZXR1cm4ge1xuICAgIHNtb290aDogc21vb3RoXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVsQ29tbW9uKGVsLCBkYXRhLCBkYXRhSW5kZXgsIHNlcmllc1Njb3BlKSB7XG4gIGVsLnVzZVN0eWxlKGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdzdHlsZScpKTtcbiAgZWwuc3R5bGUuZmlsbCA9IG51bGw7XG4gIGVsLnNldFNoYXBlKCdzbW9vdGgnLCBzZXJpZXNTY29wZS5zbW9vdGgpO1xuICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KTtcbiAgdmFyIGVtcGhhc2lzTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJyk7XG4gIHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbChlbCwgaXRlbU1vZGVsLCAnbGluZVN0eWxlJyk7XG4gIGVuYWJsZUhvdmVyRW1waGFzaXMoZWwsIGVtcGhhc2lzTW9kZWwuZ2V0KCdmb2N1cycpLCBlbXBoYXNpc01vZGVsLmdldCgnYmx1clNjb3BlJykpO1xufSAvLyBmdW5jdGlvbiBzaW1wbGVEaWZmKG9sZERhdGEsIG5ld0RhdGEsIGRpbWVuc2lvbnMpIHtcbi8vICAgICBsZXQgb2xkTGVuO1xuLy8gICAgIGlmICghb2xkRGF0YVxuLy8gICAgICAgICB8fCAhb2xkRGF0YS5fX3BsUHJvZ3Jlc3NpdmVcbi8vICAgICAgICAgfHwgKG9sZExlbiA9IG9sZERhdGEuY291bnQoKSkgIT09IG5ld0RhdGEuY291bnQoKVxuLy8gICAgICkge1xuLy8gICAgICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgICB9XG4vLyAgICAgbGV0IGRpbUxlbiA9IGRpbWVuc2lvbnMubGVuZ3RoO1xuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2xkTGVuOyBpKyspIHtcbi8vICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaW1MZW47IGorKykge1xuLy8gICAgICAgICAgICAgaWYgKG9sZERhdGEuZ2V0KGRpbWVuc2lvbnNbal0sIGkpICE9PSBuZXdEYXRhLmdldChkaW1lbnNpb25zW2pdLCBpKSkge1xuLy8gICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiBmYWxzZTtcbi8vIH1cbi8vIEZJWE1FIHB1dCBpbiBjb21tb24gdXRpbD9cblxuXG5mdW5jdGlvbiBpc0VtcHR5VmFsdWUodmFsLCBheGlzVHlwZSkge1xuICByZXR1cm4gYXhpc1R5cGUgPT09ICdjYXRlZ29yeScgPyB2YWwgPT0gbnVsbCA6IHZhbCA9PSBudWxsIHx8IGlzTmFOKHZhbCk7IC8vIGF4aXNUeXBlID09PSAndmFsdWUnXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhcmFsbGVsVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgdXNlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9uJztcbmltcG9ydCBQYXJhbGxlbFZpZXcgZnJvbSAnLi9QYXJhbGxlbFZpZXcnO1xuaW1wb3J0IFBhcmFsbGVsU2VyaWVzTW9kZWwgZnJvbSAnLi9QYXJhbGxlbFNlcmllcyc7XG5pbXBvcnQgcGFyYWxsZWxWaXN1YWwgZnJvbSAnLi9wYXJhbGxlbFZpc3VhbCc7XG5pbXBvcnQgeyBpbnN0YWxsIGFzIGluc3RhbGxQYXJhbGxlbENvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NvbXBvbmVudC9wYXJhbGxlbC9pbnN0YWxsJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICB1c2UoaW5zdGFsbFBhcmFsbGVsQ29tcG9uZW50KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ2hhcnRWaWV3KFBhcmFsbGVsVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclNlcmllc01vZGVsKFBhcmFsbGVsU2VyaWVzTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJWaXN1YWwocmVnaXN0ZXJzLlBSSU9SSVRZLlZJU1VBTC5CUlVTSCwgcGFyYWxsZWxWaXN1YWwpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgb3BhY2l0eUFjY2Vzc1BhdGggPSBbJ2xpbmVTdHlsZScsICdvcGFjaXR5J107XG52YXIgcGFyYWxsZWxWaXN1YWwgPSB7XG4gIHNlcmllc1R5cGU6ICdwYXJhbGxlbCcsXG4gIHJlc2V0OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBvcGFjaXR5TWFwID0ge1xuICAgICAgbm9ybWFsOiBzZXJpZXNNb2RlbC5nZXQoWydsaW5lU3R5bGUnLCAnb3BhY2l0eSddKSxcbiAgICAgIGFjdGl2ZTogc2VyaWVzTW9kZWwuZ2V0KCdhY3RpdmVPcGFjaXR5JyksXG4gICAgICBpbmFjdGl2ZTogc2VyaWVzTW9kZWwuZ2V0KCdpbmFjdGl2ZU9wYWNpdHknKVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2dyZXNzOiBmdW5jdGlvbiAocGFyYW1zLCBkYXRhKSB7XG4gICAgICAgIGNvb3JkU3lzLmVhY2hBY3RpdmVTdGF0ZShkYXRhLCBmdW5jdGlvbiAoYWN0aXZlU3RhdGUsIGRhdGFJbmRleCkge1xuICAgICAgICAgIHZhciBvcGFjaXR5ID0gb3BhY2l0eU1hcFthY3RpdmVTdGF0ZV07XG5cbiAgICAgICAgICBpZiAoYWN0aXZlU3RhdGUgPT09ICdub3JtYWwnICYmIGRhdGEuaGFzSXRlbU9wdGlvbikge1xuICAgICAgICAgICAgdmFyIGl0ZW1PcGFjaXR5ID0gZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KS5nZXQob3BhY2l0eUFjY2Vzc1BhdGgsIHRydWUpO1xuICAgICAgICAgICAgaXRlbU9wYWNpdHkgIT0gbnVsbCAmJiAob3BhY2l0eSA9IGl0ZW1PcGFjaXR5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZXhpc3RzU3R5bGUgPSBkYXRhLmVuc3VyZVVuaXF1ZUl0ZW1WaXN1YWwoZGF0YUluZGV4LCAnc3R5bGUnKTtcbiAgICAgICAgICBleGlzdHNTdHlsZS5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgfSwgcGFyYW1zLnN0YXJ0LCBwYXJhbXMuZW5kKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgcGFyYWxsZWxWaXN1YWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IGNyZWF0ZUxpc3RTaW1wbHkgZnJvbSAnLi4vaGVscGVyL2NyZWF0ZUxpc3RTaW1wbHknO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgKiBhcyBtb2RlbFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG5pbXBvcnQgeyBnZXRQZXJjZW50V2l0aFByZWNpc2lvbiB9IGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyJztcbmltcG9ydCB7IG1ha2VTZXJpZXNFbmNvZGVGb3JOYW1lQmFzZWQgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9zb3VyY2VIZWxwZXInO1xuaW1wb3J0IExlZ2VuZFZpc3VhbFByb3ZpZGVyIGZyb20gJy4uLy4uL3Zpc3VhbC9MZWdlbmRWaXN1YWxQcm92aWRlcic7XG5pbXBvcnQgU2VyaWVzTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvU2VyaWVzJztcblxudmFyIFBpZVNlcmllc01vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBpZVNlcmllc01vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFBpZVNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudXNlQ29sb3JQYWxldHRlT25EYXRhID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVyd3JpdGVcbiAgICovXG5cblxuICBQaWVTZXJpZXNNb2RlbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gRW5hYmxlIGxlZ2VuZCBzZWxlY3Rpb24gZm9yIGVhY2ggZGF0YSBpdGVtXG4gICAgLy8gVXNlIGEgZnVuY3Rpb24gaW5zdGVhZCBvZiBkaXJlY3QgYWNjZXNzIGJlY2F1c2UgZGF0YSByZWZlcmVuY2UgbWF5IGNoYW5nZWRcblxuXG4gICAgdGhpcy5sZWdlbmRWaXN1YWxQcm92aWRlciA9IG5ldyBMZWdlbmRWaXN1YWxQcm92aWRlcih6clV0aWwuYmluZCh0aGlzLmdldERhdGEsIHRoaXMpLCB6clV0aWwuYmluZCh0aGlzLmdldFJhd0RhdGEsIHRoaXMpKTtcblxuICAgIHRoaXMuX2RlZmF1bHRMYWJlbExpbmUob3B0aW9uKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVyd3JpdGVcbiAgICovXG5cblxuICBQaWVTZXJpZXNNb2RlbC5wcm90b3R5cGUubWVyZ2VPcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5tZXJnZU9wdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICAvKipcbiAgICogQG92ZXJ3cml0ZVxuICAgKi9cblxuXG4gIFBpZVNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY3JlYXRlTGlzdFNpbXBseSh0aGlzLCB7XG4gICAgICBjb29yZERpbWVuc2lvbnM6IFsndmFsdWUnXSxcbiAgICAgIGVuY29kZURlZmF1bHRlcjogenJVdGlsLmN1cnJ5KG1ha2VTZXJpZXNFbmNvZGVGb3JOYW1lQmFzZWQsIHRoaXMpXG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcndyaXRlXG4gICAqL1xuXG5cbiAgUGllU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldERhdGFQYXJhbXMgPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoKTtcblxuICAgIHZhciBwYXJhbXMgPSBfc3VwZXIucHJvdG90eXBlLmdldERhdGFQYXJhbXMuY2FsbCh0aGlzLCBkYXRhSW5kZXgpOyAvLyBGSVhNRSB0b0ZpeGVkP1xuXG5cbiAgICB2YXIgdmFsdWVMaXN0ID0gW107XG4gICAgZGF0YS5lYWNoKGRhdGEubWFwRGltZW5zaW9uKCd2YWx1ZScpLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhbHVlTGlzdC5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICBwYXJhbXMucGVyY2VudCA9IGdldFBlcmNlbnRXaXRoUHJlY2lzaW9uKHZhbHVlTGlzdCwgZGF0YUluZGV4LCBkYXRhLmhvc3RNb2RlbC5nZXQoJ3BlcmNlbnRQcmVjaXNpb24nKSk7XG4gICAgcGFyYW1zLiR2YXJzLnB1c2goJ3BlcmNlbnQnKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9O1xuXG4gIFBpZVNlcmllc01vZGVsLnByb3RvdHlwZS5fZGVmYXVsdExhYmVsTGluZSA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAvLyBFeHRlbmQgbGFiZWxMaW5lIGVtcGhhc2lzXG4gICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyhvcHRpb24sICdsYWJlbExpbmUnLCBbJ3Nob3cnXSk7XG4gICAgdmFyIGxhYmVsTGluZU5vcm1hbE9wdCA9IG9wdGlvbi5sYWJlbExpbmU7XG4gICAgdmFyIGxhYmVsTGluZUVtcGhhc2lzT3B0ID0gb3B0aW9uLmVtcGhhc2lzLmxhYmVsTGluZTsgLy8gTm90IHNob3cgbGFiZWwgbGluZSBpZiBgbGFiZWwubm9ybWFsLnNob3cgPSBmYWxzZWBcblxuICAgIGxhYmVsTGluZU5vcm1hbE9wdC5zaG93ID0gbGFiZWxMaW5lTm9ybWFsT3B0LnNob3cgJiYgb3B0aW9uLmxhYmVsLnNob3c7XG4gICAgbGFiZWxMaW5lRW1waGFzaXNPcHQuc2hvdyA9IGxhYmVsTGluZUVtcGhhc2lzT3B0LnNob3cgJiYgb3B0aW9uLmVtcGhhc2lzLmxhYmVsLnNob3c7XG4gIH07XG5cbiAgUGllU2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMucGllJztcbiAgUGllU2VyaWVzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogMixcbiAgICBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG4gICAgLy8g6buY6K6k5YWo5bGA5bGF5LitXG4gICAgY2VudGVyOiBbJzUwJScsICc1MCUnXSxcbiAgICByYWRpdXM6IFswLCAnNzUlJ10sXG4gICAgLy8g6buY6K6k6aG65pe26ZKIXG4gICAgY2xvY2t3aXNlOiB0cnVlLFxuICAgIHN0YXJ0QW5nbGU6IDkwLFxuICAgIC8vIOacgOWwj+inkuW6puaUueS4ujBcbiAgICBtaW5BbmdsZTogMCxcbiAgICAvLyBJZiB0aGUgYW5nbGUgb2YgYSBzZWN0b3IgbGVzcyB0aGFuIGBtaW5TaG93TGFiZWxBbmdsZWAsXG4gICAgLy8gdGhlIGxhYmVsIHdpbGwgbm90IGJlIGRpc3BsYXllZC5cbiAgICBtaW5TaG93TGFiZWxBbmdsZTogMCxcbiAgICAvLyDpgInkuK3ml7bmiYfljLrlgY/np7vph49cbiAgICBzZWxlY3RlZE9mZnNldDogMTAsXG4gICAgLy8g6YCJ5oup5qih5byP77yM6buY6K6k5YWz6Zet77yM5Y+v6YCJc2luZ2xl77yMbXVsdGlwbGVcbiAgICAvLyBzZWxlY3RlZE1vZGU6IGZhbHNlLFxuICAgIC8vIOWNl+S4geagvOWwlOeOq+eRsOWbvuaooeW8j++8jCdyYWRpdXMn77yI5Y2K5b6E77yJIHwgJ2FyZWEn77yI6Z2i56ev77yJXG4gICAgLy8gcm9zZVR5cGU6IG51bGwsXG4gICAgcGVyY2VudFByZWNpc2lvbjogMixcbiAgICAvLyBJZiBzdGlsbCBzaG93IHdoZW4gYWxsIGRhdGEgemVyby5cbiAgICBzdGlsbFNob3daZXJvU3VtOiB0cnVlLFxuICAgIC8vIGN1cnNvcjogbnVsbCxcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgd2lkdGg6IG51bGwsXG4gICAgaGVpZ2h0OiBudWxsLFxuICAgIGxhYmVsOiB7XG4gICAgICAvLyBjb2xvcjogJ2luaGVyaXQnLFxuICAgICAgLy8gSWYgcm90YXRlIGFyb3VuZCBjaXJjbGVcbiAgICAgIHJvdGF0ZTogMCxcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBvdmVyZmxvdzogJ3RydW5jYXRlJyxcbiAgICAgIC8vICdvdXRlcicsICdpbnNpZGUnLCAnY2VudGVyJ1xuICAgICAgcG9zaXRpb246ICdvdXRlcicsXG4gICAgICAvLyAnbm9uZScsICdsYWJlbExpbmUnLCAnZWRnZScuIFdvcmtzIG9ubHkgd2hlbiBwb3NpdGlvbiBpcyAnb3V0ZXInXG4gICAgICBhbGlnblRvOiAnbm9uZScsXG4gICAgICAvLyBDbG9zZXN0IGRpc3RhbmNlIGJldHdlZW4gbGFiZWwgYW5kIGNoYXJ0IGVkZ2UuXG4gICAgICAvLyBXb3JrcyBvbmx5IHBvc2l0aW9uIGlzICdvdXRlcicgYW5kIGFsaWduVG8gaXMgJ2VkZ2UnLlxuICAgICAgZWRnZURpc3RhbmNlOiAnMjUlJyxcbiAgICAgIC8vIFdvcmtzIG9ubHkgcG9zaXRpb24gaXMgJ291dGVyJyBhbmQgYWxpZ25UbyBpcyBub3QgJ2VkZ2UnLlxuICAgICAgYmxlZWRNYXJnaW46IDEwLFxuICAgICAgLy8gRGlzdGFuY2UgYmV0d2VlbiB0ZXh0IGFuZCBsYWJlbCBsaW5lLlxuICAgICAgZGlzdGFuY2VUb0xhYmVsTGluZTogNSAvLyBmb3JtYXR0ZXI6IOagh+etvuaWh+acrOagvOW8j+WZqO+8jOWQjFRvb2x0aXAuZm9ybWF0dGVy77yM5LiN5pSv5oyB5byC5q2l5Zue6LCDXG4gICAgICAvLyDpu5jorqTkvb/nlKjlhajlsYDmlofmnKzmoLflvI/vvIzor6bop4FURVhUU1RZTEVcbiAgICAgIC8vIGRpc3RhbmNlOiDlvZNwb3NpdGlvbuS4umlubmVy5pe25pyJ5pWI77yM5Li6bGFiZWzkvY3nva7liLDlnIblv4PnmoTot53nprvkuI7lnIbljYrlvoQo546v54q25Zu+5Li65YaF5aSW5Y2K5b6E5ZKMKeeahOavlOS+i+ezu+aVsFxuXG4gICAgfSxcbiAgICAvLyBFbmFibGVkIHdoZW4gbGFiZWwubm9ybWFsLnBvc2l0aW9uIGlzICdvdXRlcidcbiAgICBsYWJlbExpbmU6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICAvLyDlvJXlr7znur/kuKTmrrXkuK3nmoTnrKzkuIDmrrXplb/luqZcbiAgICAgIGxlbmd0aDogMTUsXG4gICAgICAvLyDlvJXlr7znur/kuKTmrrXkuK3nmoTnrKzkuozmrrXplb/luqZcbiAgICAgIGxlbmd0aDI6IDE1LFxuICAgICAgc21vb3RoOiBmYWxzZSxcbiAgICAgIG1pblR1cm5BbmdsZTogOTAsXG4gICAgICBtYXhTdXJmYWNlQW5nbGU6IDkwLFxuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIC8vIGNvbG9yOiDlkITlvIIsXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICB0eXBlOiAnc29saWQnXG4gICAgICB9XG4gICAgfSxcbiAgICBpdGVtU3R5bGU6IHtcbiAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgfSxcbiAgICBsYWJlbExheW91dDoge1xuICAgICAgLy8gSGlkZSB0aGUgb3ZlcmxhcHBlZCBsYWJlbC5cbiAgICAgIGhpZGVPdmVybGFwOiB0cnVlXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgc2NhbGU6IHRydWUsXG4gICAgICBzY2FsZVNpemU6IDVcbiAgICB9LFxuICAgIC8vIElmIHVzZSBzdHJhdGVneSB0byBhdm9pZCBsYWJlbCBvdmVybGFwcGluZ1xuICAgIGF2b2lkTGFiZWxPdmVybGFwOiB0cnVlLFxuICAgIC8vIEFuaW1hdGlvbiB0eXBlLiBWYWxpZCB2YWx1ZXM6IGV4cGFuc2lvbiwgc2NhbGVcbiAgICBhbmltYXRpb25UeXBlOiAnZXhwYW5zaW9uJyxcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMTAwMCxcbiAgICAvLyBBbmltYXRpb24gdHlwZSB3aGVuIHVwZGF0ZS4gVmFsaWQgdmFsdWVzOiB0cmFuc2l0aW9uLCBleHBhbnNpb25cbiAgICBhbmltYXRpb25UeXBlVXBkYXRlOiAndHJhbnNpdGlvbicsXG4gICAgYW5pbWF0aW9uRWFzaW5nVXBkYXRlOiAnY3ViaWNJbk91dCcsXG4gICAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDUwMCxcbiAgICBhbmltYXRpb25FYXNpbmc6ICdjdWJpY0luT3V0J1xuICB9O1xuICByZXR1cm4gUGllU2VyaWVzTW9kZWw7XG59KFNlcmllc01vZGVsKTtcblxuZXhwb3J0IGRlZmF1bHQgUGllU2VyaWVzTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fYXNzaWduLCBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGV4dGVuZCwgcmV0cmlldmUzIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCB7IHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbCwgZW5hYmxlSG92ZXJFbXBoYXNpcyB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdGVzJztcbmltcG9ydCBDaGFydFZpZXcgZnJvbSAnLi4vLi4vdmlldy9DaGFydCc7XG5pbXBvcnQgbGFiZWxMYXlvdXQgZnJvbSAnLi9sYWJlbExheW91dCc7XG5pbXBvcnQgeyBzZXRMYWJlbExpbmVTdHlsZSwgZ2V0TGFiZWxMaW5lU3RhdGVzTW9kZWxzIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxHdWlkZUhlbHBlcic7XG5pbXBvcnQgeyBzZXRMYWJlbFN0eWxlLCBnZXRMYWJlbFN0YXRlc01vZGVscyB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUnO1xuaW1wb3J0IHsgZ2V0U2VjdG9yQ29ybmVyUmFkaXVzIH0gZnJvbSAnLi4vaGVscGVyL3BpZUhlbHBlcic7XG4vKipcbiAqIFBpZWNlIG9mIHBpZSBpbmNsdWRpbmcgU2VjdG9yLCBMYWJlbCwgTGFiZWxMaW5lXG4gKi9cblxudmFyIFBpZVBpZWNlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBpZVBpZWNlLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFBpZVBpZWNlKGRhdGEsIGlkeCwgc3RhcnRBbmdsZSkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy56MiA9IDI7XG4gICAgdmFyIHBvbHlsaW5lID0gbmV3IGdyYXBoaWMuUG9seWxpbmUoKTtcbiAgICB2YXIgdGV4dCA9IG5ldyBncmFwaGljLlRleHQoKTtcblxuICAgIF90aGlzLnNldFRleHRHdWlkZUxpbmUocG9seWxpbmUpO1xuXG4gICAgX3RoaXMuc2V0VGV4dENvbnRlbnQodGV4dCk7XG5cbiAgICBfdGhpcy51cGRhdGVEYXRhKGRhdGEsIGlkeCwgc3RhcnRBbmdsZSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBQaWVQaWVjZS5wcm90b3R5cGUudXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBpZHgsIHN0YXJ0QW5nbGUsIGZpcnN0Q3JlYXRlKSB7XG4gICAgdmFyIHNlY3RvciA9IHRoaXM7XG4gICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgdmFyIGVtcGhhc2lzTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJyk7XG4gICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgIHZhciBzZWN0b3JTaGFwZSA9IGV4dGVuZChnZXRTZWN0b3JDb3JuZXJSYWRpdXMoaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKSwgbGF5b3V0KSB8fCB7fSwgbGF5b3V0KTtcblxuICAgIGlmIChmaXJzdENyZWF0ZSkge1xuICAgICAgc2VjdG9yLnNldFNoYXBlKHNlY3RvclNoYXBlKTtcbiAgICAgIHZhciBhbmltYXRpb25UeXBlID0gc2VyaWVzTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uVHlwZScpO1xuXG4gICAgICBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gJ3NjYWxlJykge1xuICAgICAgICBzZWN0b3Iuc2hhcGUuciA9IGxheW91dC5yMDtcbiAgICAgICAgZ3JhcGhpYy5pbml0UHJvcHMoc2VjdG9yLCB7XG4gICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHI6IGxheW91dC5yXG4gICAgICAgICAgfVxuICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICAgIH0gLy8gRXhwYW5zaW9uXG4gICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoc3RhcnRBbmdsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZWN0b3Iuc2V0U2hhcGUoe1xuICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncmFwaGljLmluaXRQcm9wcyhzZWN0b3IsIHtcbiAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBsYXlvdXQuc3RhcnRBbmdsZSxcbiAgICAgICAgICAgICAgICBlbmRBbmdsZTogbGF5b3V0LmVuZEFuZ2xlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWN0b3Iuc2hhcGUuZW5kQW5nbGUgPSBsYXlvdXQuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoc2VjdG9yLCB7XG4gICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgZW5kQW5nbGU6IGxheW91dC5lbmRBbmdsZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJhbnNpdGlvbiBhbmltYXRpb24gZnJvbSB0aGUgb2xkIHNoYXBlXG4gICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHNlY3Rvciwge1xuICAgICAgICBzaGFwZTogc2VjdG9yU2hhcGVcbiAgICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICAgIH1cblxuICAgIHNlY3Rvci51c2VTdHlsZShkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3R5bGUnKSk7XG4gICAgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsKHNlY3RvciwgaXRlbU1vZGVsKTtcbiAgICB2YXIgbWlkQW5nbGUgPSAobGF5b3V0LnN0YXJ0QW5nbGUgKyBsYXlvdXQuZW5kQW5nbGUpIC8gMjtcbiAgICB2YXIgb2Zmc2V0ID0gc2VyaWVzTW9kZWwuZ2V0KCdzZWxlY3RlZE9mZnNldCcpO1xuICAgIHZhciBkeCA9IE1hdGguY29zKG1pZEFuZ2xlKSAqIG9mZnNldDtcbiAgICB2YXIgZHkgPSBNYXRoLnNpbihtaWRBbmdsZSkgKiBvZmZzZXQ7XG4gICAgdmFyIGN1cnNvclN0eWxlID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ2N1cnNvcicpO1xuICAgIGN1cnNvclN0eWxlICYmIHNlY3Rvci5hdHRyKCdjdXJzb3InLCBjdXJzb3JTdHlsZSk7XG5cbiAgICB0aGlzLl91cGRhdGVMYWJlbChzZXJpZXNNb2RlbCwgZGF0YSwgaWR4KTtcblxuICAgIHNlY3Rvci5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKS5zaGFwZSA9IF9fYXNzaWduKHtcbiAgICAgIHI6IGxheW91dC5yICsgKGVtcGhhc2lzTW9kZWwuZ2V0KCdzY2FsZScpID8gZW1waGFzaXNNb2RlbC5nZXQoJ3NjYWxlU2l6ZScpIHx8IDAgOiAwKVxuICAgIH0sIGdldFNlY3RvckNvcm5lclJhZGl1cyhlbXBoYXNpc01vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKSwgbGF5b3V0KSk7XG4gICAgZXh0ZW5kKHNlY3Rvci5lbnN1cmVTdGF0ZSgnc2VsZWN0JyksIHtcbiAgICAgIHg6IGR4LFxuICAgICAgeTogZHksXG4gICAgICBzaGFwZTogZ2V0U2VjdG9yQ29ybmVyUmFkaXVzKGl0ZW1Nb2RlbC5nZXRNb2RlbChbJ3NlbGVjdCcsICdpdGVtU3R5bGUnXSksIGxheW91dClcbiAgICB9KTtcbiAgICBleHRlbmQoc2VjdG9yLmVuc3VyZVN0YXRlKCdibHVyJyksIHtcbiAgICAgIHNoYXBlOiBnZXRTZWN0b3JDb3JuZXJSYWRpdXMoaXRlbU1vZGVsLmdldE1vZGVsKFsnYmx1cicsICdpdGVtU3R5bGUnXSksIGxheW91dClcbiAgICB9KTtcbiAgICB2YXIgbGFiZWxMaW5lID0gc2VjdG9yLmdldFRleHRHdWlkZUxpbmUoKTtcbiAgICB2YXIgbGFiZWxUZXh0ID0gc2VjdG9yLmdldFRleHRDb250ZW50KCk7XG4gICAgbGFiZWxMaW5lICYmIGV4dGVuZChsYWJlbExpbmUuZW5zdXJlU3RhdGUoJ3NlbGVjdCcpLCB7XG4gICAgICB4OiBkeCxcbiAgICAgIHk6IGR5XG4gICAgfSk7IC8vIFRPRE86IG5lZWRzIGR4LCBkeSBpbiB6cmVuZGVyP1xuXG4gICAgZXh0ZW5kKGxhYmVsVGV4dC5lbnN1cmVTdGF0ZSgnc2VsZWN0JyksIHtcbiAgICAgIHg6IGR4LFxuICAgICAgeTogZHlcbiAgICB9KTtcbiAgICBlbmFibGVIb3ZlckVtcGhhc2lzKHRoaXMsIGVtcGhhc2lzTW9kZWwuZ2V0KCdmb2N1cycpLCBlbXBoYXNpc01vZGVsLmdldCgnYmx1clNjb3BlJykpO1xuICB9O1xuXG4gIFBpZVBpZWNlLnByb3RvdHlwZS5fdXBkYXRlTGFiZWwgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGRhdGEsIGlkeCkge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBzZWN0b3IgPSB0aGlzO1xuICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgIHZhciBsYWJlbExpbmVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWxMaW5lJyk7XG4gICAgdmFyIHN0eWxlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJyk7XG4gICAgdmFyIHZpc3VhbENvbG9yID0gc3R5bGUgJiYgc3R5bGUuZmlsbDtcbiAgICB2YXIgdmlzdWFsT3BhY2l0eSA9IHN0eWxlICYmIHN0eWxlLm9wYWNpdHk7XG4gICAgc2V0TGFiZWxTdHlsZShzZWN0b3IsIGdldExhYmVsU3RhdGVzTW9kZWxzKGl0ZW1Nb2RlbCksIHtcbiAgICAgIGxhYmVsRmV0Y2hlcjogZGF0YS5ob3N0TW9kZWwsXG4gICAgICBsYWJlbERhdGFJbmRleDogaWR4LFxuICAgICAgaW5oZXJpdENvbG9yOiB2aXN1YWxDb2xvcixcbiAgICAgIGRlZmF1bHRPcGFjaXR5OiB2aXN1YWxPcGFjaXR5LFxuICAgICAgZGVmYXVsdFRleHQ6IHNlcmllc01vZGVsLmdldEZvcm1hdHRlZExhYmVsKGlkeCwgJ25vcm1hbCcpIHx8IGRhdGEuZ2V0TmFtZShpZHgpXG4gICAgfSk7XG4gICAgdmFyIGxhYmVsVGV4dCA9IHNlY3Rvci5nZXRUZXh0Q29udGVudCgpOyAvLyBTZXQgdGV4dENvbmZpZyBvbiBzZWN0b3IuXG5cbiAgICBzZWN0b3Iuc2V0VGV4dENvbmZpZyh7XG4gICAgICAvLyByZXNldCBwb3NpdGlvbiwgcm90YXRpb25cbiAgICAgIHBvc2l0aW9uOiBudWxsLFxuICAgICAgcm90YXRpb246IG51bGxcbiAgICB9KTsgLy8gTWFrZSBzdXJlIHVwZGF0ZSBzdHlsZSBvbiBsYWJlbFRleHQgYWZ0ZXIgc2V0TGFiZWxTdHlsZS5cbiAgICAvLyBCZWNhdXNlIHNldExhYmVsU3R5bGUgd2lsbCByZXBsYWNlIGEgbmV3IHN0eWxlIG9uIGl0LlxuXG4gICAgbGFiZWxUZXh0LmF0dHIoe1xuICAgICAgejI6IDEwXG4gICAgfSk7XG4gICAgdmFyIGxhYmVsUG9zaXRpb24gPSBzZXJpZXNNb2RlbC5nZXQoWydsYWJlbCcsICdwb3NpdGlvbiddKTtcblxuICAgIGlmIChsYWJlbFBvc2l0aW9uICE9PSAnb3V0c2lkZScgJiYgbGFiZWxQb3NpdGlvbiAhPT0gJ291dGVyJykge1xuICAgICAgKF9hID0gc2VjdG9yLmdldFRleHRHdWlkZUxpbmUoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhpZGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIERlZmF1bHQgdXNlIGl0ZW0gdmlzdWFsIGNvbG9yXG5cblxuICAgIHNldExhYmVsTGluZVN0eWxlKHRoaXMsIGdldExhYmVsTGluZVN0YXRlc01vZGVscyhpdGVtTW9kZWwpLCB7XG4gICAgICBzdHJva2U6IHZpc3VhbENvbG9yLFxuICAgICAgb3BhY2l0eTogcmV0cmlldmUzKGxhYmVsTGluZU1vZGVsLmdldChbJ2xpbmVTdHlsZScsICdvcGFjaXR5J10pLCB2aXN1YWxPcGFjaXR5LCAxKVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBQaWVQaWVjZTtcbn0oZ3JhcGhpYy5TZWN0b3IpOyAvLyBQaWUgdmlld1xuXG5cbnZhciBQaWVWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBpZVZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gUGllVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLmlnbm9yZUxhYmVsTGluZVVwZGF0ZSA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUGllVmlldy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VjdG9yR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIHRoaXMuX3NlY3Rvckdyb3VwID0gc2VjdG9yR3JvdXA7XG4gIH07XG5cbiAgUGllVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgc3RhcnRBbmdsZTsgLy8gRmlyc3QgcmVuZGVyXG5cbiAgICBpZiAoIW9sZERhdGEgJiYgZGF0YS5jb3VudCgpID4gMCkge1xuICAgICAgdmFyIHNoYXBlID0gZGF0YS5nZXRJdGVtTGF5b3V0KDApO1xuXG4gICAgICBmb3IgKHZhciBzID0gMTsgaXNOYU4oc2hhcGUgJiYgc2hhcGUuc3RhcnRBbmdsZSkgJiYgcyA8IGRhdGEuY291bnQoKTsgKytzKSB7XG4gICAgICAgIHNoYXBlID0gZGF0YS5nZXRJdGVtTGF5b3V0KHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGF0YS5kaWZmKG9sZERhdGEpLmFkZChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgcGllUGllY2UgPSBuZXcgUGllUGllY2UoZGF0YSwgaWR4LCBzdGFydEFuZ2xlKTtcbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIHBpZVBpZWNlKTtcbiAgICAgIGdyb3VwLmFkZChwaWVQaWVjZSk7XG4gICAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgdmFyIHBpZVBpZWNlID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgICBwaWVQaWVjZS51cGRhdGVEYXRhKGRhdGEsIG5ld0lkeCwgc3RhcnRBbmdsZSk7XG4gICAgICBwaWVQaWVjZS5vZmYoJ2NsaWNrJyk7XG4gICAgICBncm91cC5hZGQocGllUGllY2UpO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgcGllUGllY2UpO1xuICAgIH0pLnJlbW92ZShmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgcGllUGllY2UgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwoaWR4KTtcbiAgICAgIGdyYXBoaWMucmVtb3ZlRWxlbWVudFdpdGhGYWRlT3V0KHBpZVBpZWNlLCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICB9KS5leGVjdXRlKCk7XG4gICAgbGFiZWxMYXlvdXQoc2VyaWVzTW9kZWwpOyAvLyBBbHdheXMgdXNlIGluaXRpYWwgYW5pbWF0aW9uLlxuXG4gICAgaWYgKHNlcmllc01vZGVsLmdldCgnYW5pbWF0aW9uVHlwZVVwZGF0ZScpICE9PSAnZXhwYW5zaW9uJykge1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9O1xuXG4gIFBpZVZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBQaWVWaWV3LnByb3RvdHlwZS5jb250YWluUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQsIHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGl0ZW1MYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoMCk7XG5cbiAgICBpZiAoaXRlbUxheW91dCkge1xuICAgICAgdmFyIGR4ID0gcG9pbnRbMF0gLSBpdGVtTGF5b3V0LmN4O1xuICAgICAgdmFyIGR5ID0gcG9pbnRbMV0gLSBpdGVtTGF5b3V0LmN5O1xuICAgICAgdmFyIHJhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICByZXR1cm4gcmFkaXVzIDw9IGl0ZW1MYXlvdXQuciAmJiByYWRpdXMgPj0gaXRlbUxheW91dC5yMDtcbiAgICB9XG4gIH07XG5cbiAgUGllVmlldy50eXBlID0gJ3BpZSc7XG4gIHJldHVybiBQaWVWaWV3O1xufShDaGFydFZpZXcpO1xuXG5leHBvcnQgZGVmYXVsdCBQaWVWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBjcmVhdGVMZWdhY3lEYXRhU2VsZWN0QWN0aW9uIH0gZnJvbSAnLi4vLi4vbGVnYWN5L2RhdGFTZWxlY3RBY3Rpb24nO1xuaW1wb3J0IHBpZUxheW91dCBmcm9tICcuLi9waWUvcGllTGF5b3V0JztcbmltcG9ydCBkYXRhRmlsdGVyIGZyb20gJy4uLy4uL3Byb2Nlc3Nvci9kYXRhRmlsdGVyJztcbmltcG9ydCB7IGN1cnJ5IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBQaWVWaWV3IGZyb20gJy4vUGllVmlldyc7XG5pbXBvcnQgUGllU2VyaWVzTW9kZWwgZnJvbSAnLi9QaWVTZXJpZXMnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhQaWVWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU2VyaWVzTW9kZWwoUGllU2VyaWVzTW9kZWwpO1xuICBjcmVhdGVMZWdhY3lEYXRhU2VsZWN0QWN0aW9uKCdwaWUnLCByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24pO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQoY3VycnkocGllTGF5b3V0LCAncGllJykpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJQcm9jZXNzb3IoZGF0YUZpbHRlcigncGllJykpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBGSVhNRSBlbXBoYXNpcyBsYWJlbCBwb3NpdGlvbiBpcyBub3Qgc2FtZSB3aXRoIG5vcm1hbCBsYWJlbCBwb3NpdGlvblxuaW1wb3J0IHsgcGFyc2VQZXJjZW50IH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXInO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IHsgZWFjaCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBsaW1pdFR1cm5BbmdsZSwgbGltaXRTdXJmYWNlQW5nbGUgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbEd1aWRlSGVscGVyJztcbmltcG9ydCB7IHNoaWZ0TGF5b3V0T25ZIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxMYXlvdXRIZWxwZXInO1xudmFyIFJBRElBTiA9IE1hdGguUEkgLyAxODA7XG5cbmZ1bmN0aW9uIGFkanVzdFNpbmdsZVNpZGUobGlzdCwgY3gsIGN5LCByLCBkaXIsIHZpZXdXaWR0aCwgdmlld0hlaWdodCwgdmlld0xlZnQsIHZpZXdUb3AsIGZhcnRoZXN0WCkge1xuICBpZiAobGlzdC5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgO1xuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlWE9uU2VtaVRvQWxpZ25PbkVsbGlwc2VDdXJ2ZShzZW1pKSB7XG4gICAgdmFyIHJCID0gc2VtaS5yQjtcbiAgICB2YXIgckIyID0gckIgKiByQjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VtaS5saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHNlbWkubGlzdFtpXTtcbiAgICAgIHZhciBkeSA9IE1hdGguYWJzKGl0ZW0ubGFiZWwueSAtIGN5KTsgLy8gaG9yaXpvbnRhbCByIGlzIGFsd2F5cyBzYW1lIHdpdGggb3JpZ2luYWwgciBiZWNhdXNlIHggaXMgbm90IGNoYW5nZWQuXG5cbiAgICAgIHZhciByQSA9IHIgKyBpdGVtLmxlbjtcbiAgICAgIHZhciByQTIgPSByQSAqIHJBOyAvLyBVc2UgZWxsaXBzZSBpbXBsaWNpdCBmdW5jdGlvbiB0byBjYWxjdWxhdGUgeFxuXG4gICAgICB2YXIgZHggPSBNYXRoLnNxcnQoKDEgLSBNYXRoLmFicyhkeSAqIGR5IC8gckIyKSkgKiByQTIpO1xuICAgICAgaXRlbS5sYWJlbC54ID0gY3ggKyAoZHggKyBpdGVtLmxlbjIpICogZGlyO1xuICAgIH1cbiAgfSAvLyBBZGp1c3QgWCBiYXNlZCBvbiB0aGUgc2hpZnRlZCB5LiBNYWtlIHRpZ2h0IGxhYmVscyBhbGlnbmVkIG9uIGFuIGVsbGlwc2UgY3VydmUuXG5cblxuICBmdW5jdGlvbiByZWNhbGN1bGF0ZVgoaXRlbXMpIHtcbiAgICAvLyBFeHRyZW1lcyBvZlxuICAgIHZhciB0b3BTZW1pID0ge1xuICAgICAgbGlzdDogW10sXG4gICAgICBtYXhZOiAwXG4gICAgfTtcbiAgICB2YXIgYm90dG9tU2VtaSA9IHtcbiAgICAgIGxpc3Q6IFtdLFxuICAgICAgbWF4WTogMFxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaXRlbXNbaV0ubGFiZWxBbGlnblRvICE9PSAnbm9uZScpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICB2YXIgc2VtaSA9IGl0ZW0ubGFiZWwueSA+IGN5ID8gYm90dG9tU2VtaSA6IHRvcFNlbWk7XG4gICAgICB2YXIgZHkgPSBNYXRoLmFicyhpdGVtLmxhYmVsLnkgLSBjeSk7XG5cbiAgICAgIGlmIChkeSA+IHNlbWkubWF4WSkge1xuICAgICAgICB2YXIgZHggPSBpdGVtLmxhYmVsLnggLSBjeCAtIGl0ZW0ubGVuMiAqIGRpcjsgLy8gaG9yaXpvbnRhbCByIGlzIGFsd2F5cyBzYW1lIHdpdGggb3JpZ2luYWwgciBiZWNhdXNlIHggaXMgbm90IGNoYW5nZWQuXG5cbiAgICAgICAgdmFyIHJBID0gciArIGl0ZW0ubGVuOyAvLyBDYW5jdWxhdGUgckIgYmFzZWQgb24gdGhlIHRvcGVzdCAvIGJvdHRlbWVzdCBsYWJlbC5cblxuICAgICAgICB2YXIgckIgPSBNYXRoLmFicyhkeCkgPCByQSA/IE1hdGguc3FydChkeSAqIGR5IC8gKDEgLSBkeCAqIGR4IC8gckEgLyByQSkpIDogckE7XG4gICAgICAgIHNlbWkuckIgPSByQjtcbiAgICAgICAgc2VtaS5tYXhZID0gZHk7XG4gICAgICB9XG5cbiAgICAgIHNlbWkubGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cblxuICAgIHJlY2FsY3VsYXRlWE9uU2VtaVRvQWxpZ25PbkVsbGlwc2VDdXJ2ZSh0b3BTZW1pKTtcbiAgICByZWNhbGN1bGF0ZVhPblNlbWlUb0FsaWduT25FbGxpcHNlQ3VydmUoYm90dG9tU2VtaSk7XG4gIH1cblxuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChsaXN0W2ldLnBvc2l0aW9uID09PSAnb3V0ZXInICYmIGxpc3RbaV0ubGFiZWxBbGlnblRvID09PSAnbGFiZWxMaW5lJykge1xuICAgICAgdmFyIGR4ID0gbGlzdFtpXS5sYWJlbC54IC0gZmFydGhlc3RYO1xuICAgICAgbGlzdFtpXS5saW5lUG9pbnRzWzFdWzBdICs9IGR4O1xuICAgICAgbGlzdFtpXS5sYWJlbC54ID0gZmFydGhlc3RYO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzaGlmdExheW91dE9uWShsaXN0LCB2aWV3VG9wLCB2aWV3VG9wICsgdmlld0hlaWdodCkpIHtcbiAgICByZWNhbGN1bGF0ZVgobGlzdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXZvaWRPdmVybGFwKGxhYmVsTGF5b3V0TGlzdCwgY3gsIGN5LCByLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQsIHZpZXdMZWZ0LCB2aWV3VG9wKSB7XG4gIHZhciBsZWZ0TGlzdCA9IFtdO1xuICB2YXIgcmlnaHRMaXN0ID0gW107XG4gIHZhciBsZWZ0bW9zdFggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICB2YXIgcmlnaHRtb3N0WCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxMYXlvdXRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxhYmVsID0gbGFiZWxMYXlvdXRMaXN0W2ldLmxhYmVsO1xuXG4gICAgaWYgKGlzUG9zaXRpb25DZW50ZXIobGFiZWxMYXlvdXRMaXN0W2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhYmVsLnggPCBjeCkge1xuICAgICAgbGVmdG1vc3RYID0gTWF0aC5taW4obGVmdG1vc3RYLCBsYWJlbC54KTtcbiAgICAgIGxlZnRMaXN0LnB1c2gobGFiZWxMYXlvdXRMaXN0W2ldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmlnaHRtb3N0WCA9IE1hdGgubWF4KHJpZ2h0bW9zdFgsIGxhYmVsLngpO1xuICAgICAgcmlnaHRMaXN0LnB1c2gobGFiZWxMYXlvdXRMaXN0W2ldKTtcbiAgICB9XG4gIH1cblxuICBhZGp1c3RTaW5nbGVTaWRlKHJpZ2h0TGlzdCwgY3gsIGN5LCByLCAxLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQsIHZpZXdMZWZ0LCB2aWV3VG9wLCByaWdodG1vc3RYKTtcbiAgYWRqdXN0U2luZ2xlU2lkZShsZWZ0TGlzdCwgY3gsIGN5LCByLCAtMSwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0LCB2aWV3TGVmdCwgdmlld1RvcCwgbGVmdG1vc3RYKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVsTGF5b3V0TGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsYXlvdXQgPSBsYWJlbExheW91dExpc3RbaV07XG4gICAgdmFyIGxhYmVsID0gbGF5b3V0LmxhYmVsO1xuXG4gICAgaWYgKGlzUG9zaXRpb25DZW50ZXIobGF5b3V0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGxpbmVQb2ludHMgPSBsYXlvdXQubGluZVBvaW50cztcblxuICAgIGlmIChsaW5lUG9pbnRzKSB7XG4gICAgICB2YXIgaXNBbGlnblRvRWRnZSA9IGxheW91dC5sYWJlbEFsaWduVG8gPT09ICdlZGdlJztcbiAgICAgIHZhciByZWFsVGV4dFdpZHRoID0gbGF5b3V0LnJlY3Qud2lkdGg7XG4gICAgICB2YXIgdGFyZ2V0VGV4dFdpZHRoID0gdm9pZCAwO1xuXG4gICAgICBpZiAoaXNBbGlnblRvRWRnZSkge1xuICAgICAgICBpZiAobGFiZWwueCA8IGN4KSB7XG4gICAgICAgICAgdGFyZ2V0VGV4dFdpZHRoID0gbGluZVBvaW50c1syXVswXSAtIGxheW91dC5sYWJlbERpc3RhbmNlIC0gdmlld0xlZnQgLSBsYXlvdXQuZWRnZURpc3RhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFRleHRXaWR0aCA9IHZpZXdMZWZ0ICsgdmlld1dpZHRoIC0gbGF5b3V0LmVkZ2VEaXN0YW5jZSAtIGxpbmVQb2ludHNbMl1bMF0gLSBsYXlvdXQubGFiZWxEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxhYmVsLnggPCBjeCkge1xuICAgICAgICAgIHRhcmdldFRleHRXaWR0aCA9IGxhYmVsLnggLSB2aWV3TGVmdCAtIGxheW91dC5ibGVlZE1hcmdpbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRUZXh0V2lkdGggPSB2aWV3TGVmdCArIHZpZXdXaWR0aCAtIGxhYmVsLnggLSBsYXlvdXQuYmxlZWRNYXJnaW47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldFRleHRXaWR0aCA8IGxheW91dC5yZWN0LndpZHRoKSB7XG4gICAgICAgIC8vIFRPRE9UT0RPXG4gICAgICAgIC8vIGxheW91dC50ZXh0ID0gdGV4dENvbnRhaW4udHJ1bmNhdGVUZXh0KGxheW91dC50ZXh0LCB0YXJnZXRUZXh0V2lkdGgsIGxheW91dC5mb250KTtcbiAgICAgICAgbGF5b3V0LmxhYmVsLnN0eWxlLndpZHRoID0gdGFyZ2V0VGV4dFdpZHRoO1xuXG4gICAgICAgIGlmIChsYXlvdXQubGFiZWxBbGlnblRvID09PSAnZWRnZScpIHtcbiAgICAgICAgICByZWFsVGV4dFdpZHRoID0gdGFyZ2V0VGV4dFdpZHRoOyAvLyByZWFsVGV4dFdpZHRoID0gdGV4dENvbnRhaW4uZ2V0V2lkdGgobGF5b3V0LnRleHQsIGxheW91dC5mb250KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGlzdCA9IGxpbmVQb2ludHNbMV1bMF0gLSBsaW5lUG9pbnRzWzJdWzBdO1xuXG4gICAgICBpZiAoaXNBbGlnblRvRWRnZSkge1xuICAgICAgICBpZiAobGFiZWwueCA8IGN4KSB7XG4gICAgICAgICAgbGluZVBvaW50c1syXVswXSA9IHZpZXdMZWZ0ICsgbGF5b3V0LmVkZ2VEaXN0YW5jZSArIHJlYWxUZXh0V2lkdGggKyBsYXlvdXQubGFiZWxEaXN0YW5jZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lUG9pbnRzWzJdWzBdID0gdmlld0xlZnQgKyB2aWV3V2lkdGggLSBsYXlvdXQuZWRnZURpc3RhbmNlIC0gcmVhbFRleHRXaWR0aCAtIGxheW91dC5sYWJlbERpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGFiZWwueCA8IGN4KSB7XG4gICAgICAgICAgbGluZVBvaW50c1syXVswXSA9IGxhYmVsLnggKyBsYXlvdXQubGFiZWxEaXN0YW5jZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lUG9pbnRzWzJdWzBdID0gbGFiZWwueCAtIGxheW91dC5sYWJlbERpc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZVBvaW50c1sxXVswXSA9IGxpbmVQb2ludHNbMl1bMF0gKyBkaXN0O1xuICAgICAgfVxuXG4gICAgICBsaW5lUG9pbnRzWzFdWzFdID0gbGluZVBvaW50c1syXVsxXSA9IGxhYmVsLnk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzUG9zaXRpb25DZW50ZXIoc2VjdG9yU2hhcGUpIHtcbiAgLy8gTm90IGNoYW5nZSB4IGZvciBjZW50ZXIgbGFiZWxcbiAgcmV0dXJuIHNlY3RvclNoYXBlLnBvc2l0aW9uID09PSAnY2VudGVyJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGllTGFiZWxMYXlvdXQoc2VyaWVzTW9kZWwpIHtcbiAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gIHZhciBsYWJlbExheW91dExpc3QgPSBbXTtcbiAgdmFyIGN4O1xuICB2YXIgY3k7XG4gIHZhciBoYXNMYWJlbFJvdGF0ZSA9IGZhbHNlO1xuICB2YXIgbWluU2hvd0xhYmVsUmFkaWFuID0gKHNlcmllc01vZGVsLmdldCgnbWluU2hvd0xhYmVsQW5nbGUnKSB8fCAwKSAqIFJBRElBTjtcbiAgdmFyIHZpZXdSZWN0ID0gZGF0YS5nZXRMYXlvdXQoJ3ZpZXdSZWN0Jyk7XG4gIHZhciByID0gZGF0YS5nZXRMYXlvdXQoJ3InKTtcbiAgdmFyIHZpZXdXaWR0aCA9IHZpZXdSZWN0LndpZHRoO1xuICB2YXIgdmlld0xlZnQgPSB2aWV3UmVjdC54O1xuICB2YXIgdmlld1RvcCA9IHZpZXdSZWN0Lnk7XG4gIHZhciB2aWV3SGVpZ2h0ID0gdmlld1JlY3QuaGVpZ2h0O1xuXG4gIGZ1bmN0aW9uIHNldE5vdFNob3coZWwpIHtcbiAgICBlbC5pZ25vcmUgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMYWJlbFNob3duKGxhYmVsKSB7XG4gICAgaWYgKCFsYWJlbC5pZ25vcmUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGtleSBpbiBsYWJlbC5zdGF0ZXMpIHtcbiAgICAgIGlmIChsYWJlbC5zdGF0ZXNba2V5XS5pZ25vcmUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgdmFyIHNlY3RvciA9IGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpO1xuICAgIHZhciBzZWN0b3JTaGFwZSA9IHNlY3Rvci5zaGFwZTtcbiAgICB2YXIgbGFiZWwgPSBzZWN0b3IuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICB2YXIgbGFiZWxMaW5lID0gc2VjdG9yLmdldFRleHRHdWlkZUxpbmUoKTtcbiAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICB2YXIgbGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwnKTsgLy8gVXNlIHBvc2l0aW9uIGluIG5vcm1hbCBvciBlbXBoYXNpc1xuXG4gICAgdmFyIGxhYmVsUG9zaXRpb24gPSBsYWJlbE1vZGVsLmdldCgncG9zaXRpb24nKSB8fCBpdGVtTW9kZWwuZ2V0KFsnZW1waGFzaXMnLCAnbGFiZWwnLCAncG9zaXRpb24nXSk7XG4gICAgdmFyIGxhYmVsRGlzdGFuY2UgPSBsYWJlbE1vZGVsLmdldCgnZGlzdGFuY2VUb0xhYmVsTGluZScpO1xuICAgIHZhciBsYWJlbEFsaWduVG8gPSBsYWJlbE1vZGVsLmdldCgnYWxpZ25UbycpO1xuICAgIHZhciBlZGdlRGlzdGFuY2UgPSBwYXJzZVBlcmNlbnQobGFiZWxNb2RlbC5nZXQoJ2VkZ2VEaXN0YW5jZScpLCB2aWV3V2lkdGgpO1xuICAgIHZhciBibGVlZE1hcmdpbiA9IGxhYmVsTW9kZWwuZ2V0KCdibGVlZE1hcmdpbicpO1xuICAgIHZhciBsYWJlbExpbmVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWxMaW5lJyk7XG4gICAgdmFyIGxhYmVsTGluZUxlbiA9IGxhYmVsTGluZU1vZGVsLmdldCgnbGVuZ3RoJyk7XG4gICAgbGFiZWxMaW5lTGVuID0gcGFyc2VQZXJjZW50KGxhYmVsTGluZUxlbiwgdmlld1dpZHRoKTtcbiAgICB2YXIgbGFiZWxMaW5lTGVuMiA9IGxhYmVsTGluZU1vZGVsLmdldCgnbGVuZ3RoMicpO1xuICAgIGxhYmVsTGluZUxlbjIgPSBwYXJzZVBlcmNlbnQobGFiZWxMaW5lTGVuMiwgdmlld1dpZHRoKTtcblxuICAgIGlmIChNYXRoLmFicyhzZWN0b3JTaGFwZS5lbmRBbmdsZSAtIHNlY3RvclNoYXBlLnN0YXJ0QW5nbGUpIDwgbWluU2hvd0xhYmVsUmFkaWFuKSB7XG4gICAgICBlYWNoKGxhYmVsLnN0YXRlcywgc2V0Tm90U2hvdyk7XG4gICAgICBsYWJlbC5pZ25vcmUgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaXNMYWJlbFNob3duKGxhYmVsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtaWRBbmdsZSA9IChzZWN0b3JTaGFwZS5zdGFydEFuZ2xlICsgc2VjdG9yU2hhcGUuZW5kQW5nbGUpIC8gMjtcbiAgICB2YXIgbnggPSBNYXRoLmNvcyhtaWRBbmdsZSk7XG4gICAgdmFyIG55ID0gTWF0aC5zaW4obWlkQW5nbGUpO1xuICAgIHZhciB0ZXh0WDtcbiAgICB2YXIgdGV4dFk7XG4gICAgdmFyIGxpbmVQb2ludHM7XG4gICAgdmFyIHRleHRBbGlnbjtcbiAgICBjeCA9IHNlY3RvclNoYXBlLmN4O1xuICAgIGN5ID0gc2VjdG9yU2hhcGUuY3k7XG4gICAgdmFyIGlzTGFiZWxJbnNpZGUgPSBsYWJlbFBvc2l0aW9uID09PSAnaW5zaWRlJyB8fCBsYWJlbFBvc2l0aW9uID09PSAnaW5uZXInO1xuXG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0ZXh0WCA9IHNlY3RvclNoYXBlLmN4O1xuICAgICAgdGV4dFkgPSBzZWN0b3JTaGFwZS5jeTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeDEgPSAoaXNMYWJlbEluc2lkZSA/IChzZWN0b3JTaGFwZS5yICsgc2VjdG9yU2hhcGUucjApIC8gMiAqIG54IDogc2VjdG9yU2hhcGUuciAqIG54KSArIGN4O1xuICAgICAgdmFyIHkxID0gKGlzTGFiZWxJbnNpZGUgPyAoc2VjdG9yU2hhcGUuciArIHNlY3RvclNoYXBlLnIwKSAvIDIgKiBueSA6IHNlY3RvclNoYXBlLnIgKiBueSkgKyBjeTtcbiAgICAgIHRleHRYID0geDEgKyBueCAqIDM7XG4gICAgICB0ZXh0WSA9IHkxICsgbnkgKiAzO1xuXG4gICAgICBpZiAoIWlzTGFiZWxJbnNpZGUpIHtcbiAgICAgICAgLy8gRm9yIHJvc2VUeXBlXG4gICAgICAgIHZhciB4MiA9IHgxICsgbnggKiAobGFiZWxMaW5lTGVuICsgciAtIHNlY3RvclNoYXBlLnIpO1xuICAgICAgICB2YXIgeTIgPSB5MSArIG55ICogKGxhYmVsTGluZUxlbiArIHIgLSBzZWN0b3JTaGFwZS5yKTtcbiAgICAgICAgdmFyIHgzID0geDIgKyAobnggPCAwID8gLTEgOiAxKSAqIGxhYmVsTGluZUxlbjI7XG4gICAgICAgIHZhciB5MyA9IHkyO1xuXG4gICAgICAgIGlmIChsYWJlbEFsaWduVG8gPT09ICdlZGdlJykge1xuICAgICAgICAgIC8vIEFkanVzdCB0ZXh0WCBiZWNhdXNlIHRleHQgYWxpZ24gb2YgZWRnZSBpcyBvcHBvc2l0ZVxuICAgICAgICAgIHRleHRYID0gbnggPCAwID8gdmlld0xlZnQgKyBlZGdlRGlzdGFuY2UgOiB2aWV3TGVmdCArIHZpZXdXaWR0aCAtIGVkZ2VEaXN0YW5jZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0WCA9IHgzICsgKG54IDwgMCA/IC1sYWJlbERpc3RhbmNlIDogbGFiZWxEaXN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0WSA9IHkzO1xuICAgICAgICBsaW5lUG9pbnRzID0gW1t4MSwgeTFdLCBbeDIsIHkyXSwgW3gzLCB5M11dO1xuICAgICAgfVxuXG4gICAgICB0ZXh0QWxpZ24gPSBpc0xhYmVsSW5zaWRlID8gJ2NlbnRlcicgOiBsYWJlbEFsaWduVG8gPT09ICdlZGdlJyA/IG54ID4gMCA/ICdyaWdodCcgOiAnbGVmdCcgOiBueCA+IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cblxuICAgIHZhciBsYWJlbFJvdGF0ZTtcbiAgICB2YXIgcm90YXRlID0gbGFiZWxNb2RlbC5nZXQoJ3JvdGF0ZScpO1xuXG4gICAgaWYgKHR5cGVvZiByb3RhdGUgPT09ICdudW1iZXInKSB7XG4gICAgICBsYWJlbFJvdGF0ZSA9IHJvdGF0ZSAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFiZWxSb3RhdGUgPSByb3RhdGUgPyBueCA8IDAgPyAtbWlkQW5nbGUgKyBNYXRoLlBJIDogLW1pZEFuZ2xlIDogMDtcbiAgICB9XG5cbiAgICBoYXNMYWJlbFJvdGF0ZSA9ICEhbGFiZWxSb3RhdGU7XG4gICAgbGFiZWwueCA9IHRleHRYO1xuICAgIGxhYmVsLnkgPSB0ZXh0WTtcbiAgICBsYWJlbC5yb3RhdGlvbiA9IGxhYmVsUm90YXRlO1xuICAgIGxhYmVsLnNldFN0eWxlKHtcbiAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gICAgfSk7IC8vIE5vdCBzZWN0b3JTaGFwZSB0aGUgaW5zaWRlIGxhYmVsXG5cbiAgICBpZiAoIWlzTGFiZWxJbnNpZGUpIHtcbiAgICAgIHZhciB0ZXh0UmVjdCA9IGxhYmVsLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgICB0ZXh0UmVjdC5hcHBseVRyYW5zZm9ybShsYWJlbC5nZXRDb21wdXRlZFRyYW5zZm9ybSgpKTsgLy8gVGV4dCBoYXMgYSBkZWZhdWx0IDFweCBzdHJva2UuIEV4Y2x1ZGUgdGhpcy5cblxuICAgICAgdmFyIG1hcmdpbiA9IChsYWJlbC5zdHlsZS5tYXJnaW4gfHwgMCkgKyAyLjE7XG4gICAgICB0ZXh0UmVjdC55IC09IG1hcmdpbiAvIDI7XG4gICAgICB0ZXh0UmVjdC5oZWlnaHQgKz0gbWFyZ2luO1xuICAgICAgbGFiZWxMYXlvdXRMaXN0LnB1c2goe1xuICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgIGxhYmVsTGluZTogbGFiZWxMaW5lLFxuICAgICAgICBwb3NpdGlvbjogbGFiZWxQb3NpdGlvbixcbiAgICAgICAgbGVuOiBsYWJlbExpbmVMZW4sXG4gICAgICAgIGxlbjI6IGxhYmVsTGluZUxlbjIsXG4gICAgICAgIG1pblR1cm5BbmdsZTogbGFiZWxMaW5lTW9kZWwuZ2V0KCdtaW5UdXJuQW5nbGUnKSxcbiAgICAgICAgbWF4U3VyZmFjZUFuZ2xlOiBsYWJlbExpbmVNb2RlbC5nZXQoJ21heFN1cmZhY2VBbmdsZScpLFxuICAgICAgICBzdXJmYWNlTm9ybWFsOiBuZXcgUG9pbnQobngsIG55KSxcbiAgICAgICAgbGluZVBvaW50czogbGluZVBvaW50cyxcbiAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgIGxhYmVsRGlzdGFuY2U6IGxhYmVsRGlzdGFuY2UsXG4gICAgICAgIGxhYmVsQWxpZ25UbzogbGFiZWxBbGlnblRvLFxuICAgICAgICBlZGdlRGlzdGFuY2U6IGVkZ2VEaXN0YW5jZSxcbiAgICAgICAgYmxlZWRNYXJnaW46IGJsZWVkTWFyZ2luLFxuICAgICAgICByZWN0OiB0ZXh0UmVjdFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsLnNldFN0eWxlKHtcbiAgICAgICAgYWxpZ246IHRleHRBbGlnblxuICAgICAgfSk7XG4gICAgICB2YXIgc2VsZWN0U3RhdGUgPSBsYWJlbC5zdGF0ZXMuc2VsZWN0O1xuXG4gICAgICBpZiAoc2VsZWN0U3RhdGUpIHtcbiAgICAgICAgc2VsZWN0U3RhdGUueCArPSBsYWJlbC54O1xuICAgICAgICBzZWxlY3RTdGF0ZS55ICs9IGxhYmVsLnk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VjdG9yLnNldFRleHRDb25maWcoe1xuICAgICAgaW5zaWRlOiBpc0xhYmVsSW5zaWRlXG4gICAgfSk7XG4gIH0pO1xuXG4gIGlmICghaGFzTGFiZWxSb3RhdGUgJiYgc2VyaWVzTW9kZWwuZ2V0KCdhdm9pZExhYmVsT3ZlcmxhcCcpKSB7XG4gICAgYXZvaWRPdmVybGFwKGxhYmVsTGF5b3V0TGlzdCwgY3gsIGN5LCByLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQsIHZpZXdMZWZ0LCB2aWV3VG9wKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxMYXlvdXRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxheW91dCA9IGxhYmVsTGF5b3V0TGlzdFtpXTtcbiAgICB2YXIgbGFiZWwgPSBsYXlvdXQubGFiZWw7XG4gICAgdmFyIGxhYmVsTGluZSA9IGxheW91dC5sYWJlbExpbmU7XG4gICAgdmFyIG5vdFNob3dMYWJlbCA9IGlzTmFOKGxhYmVsLngpIHx8IGlzTmFOKGxhYmVsLnkpO1xuXG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICBsYWJlbC5zZXRTdHlsZSh7XG4gICAgICAgIGFsaWduOiBsYXlvdXQudGV4dEFsaWduXG4gICAgICB9KTtcblxuICAgICAgaWYgKG5vdFNob3dMYWJlbCkge1xuICAgICAgICBlYWNoKGxhYmVsLnN0YXRlcywgc2V0Tm90U2hvdyk7XG4gICAgICAgIGxhYmVsLmlnbm9yZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxlY3RTdGF0ZSA9IGxhYmVsLnN0YXRlcy5zZWxlY3Q7XG5cbiAgICAgIGlmIChzZWxlY3RTdGF0ZSkge1xuICAgICAgICBzZWxlY3RTdGF0ZS54ICs9IGxhYmVsLng7XG4gICAgICAgIHNlbGVjdFN0YXRlLnkgKz0gbGFiZWwueTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGFiZWxMaW5lKSB7XG4gICAgICB2YXIgbGluZVBvaW50cyA9IGxheW91dC5saW5lUG9pbnRzO1xuXG4gICAgICBpZiAobm90U2hvd0xhYmVsIHx8ICFsaW5lUG9pbnRzKSB7XG4gICAgICAgIGVhY2gobGFiZWxMaW5lLnN0YXRlcywgc2V0Tm90U2hvdyk7XG4gICAgICAgIGxhYmVsTGluZS5pZ25vcmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGltaXRUdXJuQW5nbGUobGluZVBvaW50cywgbGF5b3V0Lm1pblR1cm5BbmdsZSk7XG4gICAgICAgIGxpbWl0U3VyZmFjZUFuZ2xlKGxpbmVQb2ludHMsIGxheW91dC5zdXJmYWNlTm9ybWFsLCBsYXlvdXQubWF4U3VyZmFjZUFuZ2xlKTtcbiAgICAgICAgbGFiZWxMaW5lLnNldFNoYXBlKHtcbiAgICAgICAgICBwb2ludHM6IGxpbmVQb2ludHNcbiAgICAgICAgfSk7IC8vIFNldCB0aGUgYW5jaG9yIHRvIHRoZSBtaWRwb2ludCBvZiBzZWN0b3JcblxuICAgICAgICBsYWJlbC5fX2hvc3RUYXJnZXQudGV4dEd1aWRlTGluZUNvbmZpZyA9IHtcbiAgICAgICAgICBhbmNob3I6IG5ldyBQb2ludChsaW5lUG9pbnRzWzBdWzBdLCBsaW5lUG9pbnRzWzBdWzFdKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBwYXJzZVBlcmNlbnQsIGxpbmVhck1hcCB9IGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyJztcbmltcG9ydCAqIGFzIGxheW91dCBmcm9tICcuLi8uLi91dGlsL2xheW91dCc7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbnZhciBSQURJQU4gPSBNYXRoLlBJIC8gMTgwO1xuXG5mdW5jdGlvbiBnZXRWaWV3UmVjdChzZXJpZXNNb2RlbCwgYXBpKSB7XG4gIHJldHVybiBsYXlvdXQuZ2V0TGF5b3V0UmVjdChzZXJpZXNNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKSwge1xuICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGllTGF5b3V0KHNlcmllc1R5cGUsIGVjTW9kZWwsIGFwaSkge1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoc2VyaWVzVHlwZSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHZhbHVlRGltID0gZGF0YS5tYXBEaW1lbnNpb24oJ3ZhbHVlJyk7XG4gICAgdmFyIHZpZXdSZWN0ID0gZ2V0Vmlld1JlY3Qoc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgdmFyIGNlbnRlciA9IHNlcmllc01vZGVsLmdldCgnY2VudGVyJyk7XG4gICAgdmFyIHJhZGl1cyA9IHNlcmllc01vZGVsLmdldCgncmFkaXVzJyk7XG5cbiAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHJhZGl1cykpIHtcbiAgICAgIHJhZGl1cyA9IFswLCByYWRpdXNdO1xuICAgIH1cblxuICAgIGlmICghenJVdGlsLmlzQXJyYXkoY2VudGVyKSkge1xuICAgICAgY2VudGVyID0gW2NlbnRlciwgY2VudGVyXTtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSBwYXJzZVBlcmNlbnQodmlld1JlY3Qud2lkdGgsIGFwaS5nZXRXaWR0aCgpKTtcbiAgICB2YXIgaGVpZ2h0ID0gcGFyc2VQZXJjZW50KHZpZXdSZWN0LmhlaWdodCwgYXBpLmdldEhlaWdodCgpKTtcbiAgICB2YXIgc2l6ZSA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciBjeCA9IHBhcnNlUGVyY2VudChjZW50ZXJbMF0sIHdpZHRoKSArIHZpZXdSZWN0Lng7XG4gICAgdmFyIGN5ID0gcGFyc2VQZXJjZW50KGNlbnRlclsxXSwgaGVpZ2h0KSArIHZpZXdSZWN0Lnk7XG4gICAgdmFyIHIwID0gcGFyc2VQZXJjZW50KHJhZGl1c1swXSwgc2l6ZSAvIDIpO1xuICAgIHZhciByID0gcGFyc2VQZXJjZW50KHJhZGl1c1sxXSwgc2l6ZSAvIDIpO1xuICAgIHZhciBzdGFydEFuZ2xlID0gLXNlcmllc01vZGVsLmdldCgnc3RhcnRBbmdsZScpICogUkFESUFOO1xuICAgIHZhciBtaW5BbmdsZSA9IHNlcmllc01vZGVsLmdldCgnbWluQW5nbGUnKSAqIFJBRElBTjtcbiAgICB2YXIgdmFsaWREYXRhQ291bnQgPSAwO1xuICAgIGRhdGEuZWFjaCh2YWx1ZURpbSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAhaXNOYU4odmFsdWUpICYmIHZhbGlkRGF0YUNvdW50Kys7XG4gICAgfSk7XG4gICAgdmFyIHN1bSA9IGRhdGEuZ2V0U3VtKHZhbHVlRGltKTsgLy8gU3VtIG1heSBiZSAwXG5cbiAgICB2YXIgdW5pdFJhZGlhbiA9IE1hdGguUEkgLyAoc3VtIHx8IHZhbGlkRGF0YUNvdW50KSAqIDI7XG4gICAgdmFyIGNsb2Nrd2lzZSA9IHNlcmllc01vZGVsLmdldCgnY2xvY2t3aXNlJyk7XG4gICAgdmFyIHJvc2VUeXBlID0gc2VyaWVzTW9kZWwuZ2V0KCdyb3NlVHlwZScpO1xuICAgIHZhciBzdGlsbFNob3daZXJvU3VtID0gc2VyaWVzTW9kZWwuZ2V0KCdzdGlsbFNob3daZXJvU3VtJyk7IC8vIFswLi4ubWF4XVxuXG4gICAgdmFyIGV4dGVudCA9IGRhdGEuZ2V0RGF0YUV4dGVudCh2YWx1ZURpbSk7XG4gICAgZXh0ZW50WzBdID0gMDsgLy8gSW4gdGhlIGNhc2Ugc29tZSBzZWN0b3IgYW5nbGUgaXMgc21hbGxlciB0aGFuIG1pbkFuZ2xlXG5cbiAgICB2YXIgcmVzdEFuZ2xlID0gUEkyO1xuICAgIHZhciB2YWx1ZVN1bUxhcmdlclRoYW5NaW5BbmdsZSA9IDA7XG4gICAgdmFyIGN1cnJlbnRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgdmFyIGRpciA9IGNsb2Nrd2lzZSA/IDEgOiAtMTtcbiAgICBkYXRhLnNldExheW91dCh7XG4gICAgICB2aWV3UmVjdDogdmlld1JlY3QsXG4gICAgICByOiByXG4gICAgfSk7XG4gICAgZGF0YS5lYWNoKHZhbHVlRGltLCBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgdmFyIGFuZ2xlO1xuXG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHtcbiAgICAgICAgICBhbmdsZTogTmFOLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IE5hTixcbiAgICAgICAgICBlbmRBbmdsZTogTmFOLFxuICAgICAgICAgIGNsb2Nrd2lzZTogY2xvY2t3aXNlLFxuICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgcjA6IHIwLFxuICAgICAgICAgIHI6IHJvc2VUeXBlID8gTmFOIDogclxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBGSVhNRSDlhbzlrrkgMi4wIOS9huaYryByb3NlVHlwZSDmmK8gYXJlYSDnmoTml7blgJnmiY3mmK/ov5nmoLfvvJ9cblxuXG4gICAgICBpZiAocm9zZVR5cGUgIT09ICdhcmVhJykge1xuICAgICAgICBhbmdsZSA9IHN1bSA9PT0gMCAmJiBzdGlsbFNob3daZXJvU3VtID8gdW5pdFJhZGlhbiA6IHZhbHVlICogdW5pdFJhZGlhbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuZ2xlID0gUEkyIC8gdmFsaWREYXRhQ291bnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmdsZSA8IG1pbkFuZ2xlKSB7XG4gICAgICAgIGFuZ2xlID0gbWluQW5nbGU7XG4gICAgICAgIHJlc3RBbmdsZSAtPSBtaW5BbmdsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlU3VtTGFyZ2VyVGhhbk1pbkFuZ2xlICs9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZW5kQW5nbGUgPSBjdXJyZW50QW5nbGUgKyBkaXIgKiBhbmdsZTtcbiAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHtcbiAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICBzdGFydEFuZ2xlOiBjdXJyZW50QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcbiAgICAgICAgY2xvY2t3aXNlOiBjbG9ja3dpc2UsXG4gICAgICAgIGN4OiBjeCxcbiAgICAgICAgY3k6IGN5LFxuICAgICAgICByMDogcjAsXG4gICAgICAgIHI6IHJvc2VUeXBlID8gbGluZWFyTWFwKHZhbHVlLCBleHRlbnQsIFtyMCwgcl0pIDogclxuICAgICAgfSk7XG4gICAgICBjdXJyZW50QW5nbGUgPSBlbmRBbmdsZTtcbiAgICB9KTsgLy8gU29tZSBzZWN0b3IgaXMgY29uc3RyYWluZWQgYnkgbWluQW5nbGVcbiAgICAvLyBSZXN0IHNlY3RvcnMgbmVlZHMgcmVjYWxjdWxhdGUgYW5nbGVcblxuICAgIGlmIChyZXN0QW5nbGUgPCBQSTIgJiYgdmFsaWREYXRhQ291bnQpIHtcbiAgICAgIC8vIEF2ZXJhZ2UgdGhlIGFuZ2xlIGlmIHJlc3QgYW5nbGUgaXMgbm90IGVub3VnaCBhZnRlciBhbGwgYW5nbGVzIGlzXG4gICAgICAvLyBDb25zdHJhaW5lZCBieSBtaW5BbmdsZVxuICAgICAgaWYgKHJlc3RBbmdsZSA8PSAxZS0zKSB7XG4gICAgICAgIHZhciBhbmdsZV8xID0gUEkyIC8gdmFsaWREYXRhQ291bnQ7XG4gICAgICAgIGRhdGEuZWFjaCh2YWx1ZURpbSwgZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcbiAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIGxheW91dF8xID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgICAgICAgICBsYXlvdXRfMS5hbmdsZSA9IGFuZ2xlXzE7XG4gICAgICAgICAgICBsYXlvdXRfMS5zdGFydEFuZ2xlID0gc3RhcnRBbmdsZSArIGRpciAqIGlkeCAqIGFuZ2xlXzE7XG4gICAgICAgICAgICBsYXlvdXRfMS5lbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBkaXIgKiAoaWR4ICsgMSkgKiBhbmdsZV8xO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bml0UmFkaWFuID0gcmVzdEFuZ2xlIC8gdmFsdWVTdW1MYXJnZXJUaGFuTWluQW5nbGU7XG4gICAgICAgIGN1cnJlbnRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgICAgIGRhdGEuZWFjaCh2YWx1ZURpbSwgZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcbiAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIGxheW91dF8yID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBsYXlvdXRfMi5hbmdsZSA9PT0gbWluQW5nbGUgPyBtaW5BbmdsZSA6IHZhbHVlICogdW5pdFJhZGlhbjtcbiAgICAgICAgICAgIGxheW91dF8yLnN0YXJ0QW5nbGUgPSBjdXJyZW50QW5nbGU7XG4gICAgICAgICAgICBsYXlvdXRfMi5lbmRBbmdsZSA9IGN1cnJlbnRBbmdsZSArIGRpciAqIGFuZ2xlO1xuICAgICAgICAgICAgY3VycmVudEFuZ2xlICs9IGRpciAqIGFuZ2xlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgU2VyaWVzTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvU2VyaWVzJztcbmltcG9ydCBjcmVhdGVMaXN0U2ltcGx5IGZyb20gJy4uL2hlbHBlci9jcmVhdGVMaXN0U2ltcGx5JztcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IExlZ2VuZFZpc3VhbFByb3ZpZGVyIGZyb20gJy4uLy4uL3Zpc3VhbC9MZWdlbmRWaXN1YWxQcm92aWRlcic7XG5pbXBvcnQgeyBjcmVhdGVUb29sdGlwTWFya3VwLCByZXRyaWV2ZVZpc3VhbENvbG9yRm9yVG9vbHRpcE1hcmtlciB9IGZyb20gJy4uLy4uL2NvbXBvbmVudC90b29sdGlwL3Rvb2x0aXBNYXJrdXAnO1xuXG52YXIgUmFkYXJTZXJpZXNNb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhSYWRhclNlcmllc01vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFJhZGFyU2VyaWVzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gUmFkYXJTZXJpZXNNb2RlbC50eXBlO1xuICAgIF90aGlzLnVzZUNvbG9yUGFsZXR0ZU9uRGF0YSA9IHRydWU7XG4gICAgX3RoaXMuaGFzU3ltYm9sVmlzdWFsID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH0gLy8gT3ZlcndyaXRlXG5cblxuICBSYWRhclNlcmllc01vZGVsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBFbmFibGUgbGVnZW5kIHNlbGVjdGlvbiBmb3IgZWFjaCBkYXRhIGl0ZW1cbiAgICAvLyBVc2UgYSBmdW5jdGlvbiBpbnN0ZWFkIG9mIGRpcmVjdCBhY2Nlc3MgYmVjYXVzZSBkYXRhIHJlZmVyZW5jZSBtYXkgY2hhbmdlZFxuXG5cbiAgICB0aGlzLmxlZ2VuZFZpc3VhbFByb3ZpZGVyID0gbmV3IExlZ2VuZFZpc3VhbFByb3ZpZGVyKHpyVXRpbC5iaW5kKHRoaXMuZ2V0RGF0YSwgdGhpcyksIHpyVXRpbC5iaW5kKHRoaXMuZ2V0UmF3RGF0YSwgdGhpcykpO1xuICB9O1xuXG4gIFJhZGFyU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIHJldHVybiBjcmVhdGVMaXN0U2ltcGx5KHRoaXMsIHtcbiAgICAgIGdlbmVyYXRlQ29vcmQ6ICdpbmRpY2F0b3JfJyxcbiAgICAgIGdlbmVyYXRlQ29vcmRDb3VudDogSW5maW5pdHlcbiAgICB9KTtcbiAgfTtcblxuICBSYWRhclNlcmllc01vZGVsLnByb3RvdHlwZS5mb3JtYXRUb29sdGlwID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgbXVsdGlwbGVTZXJpZXMsIGRhdGFUeXBlKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoKTtcbiAgICB2YXIgY29vcmRTeXMgPSB0aGlzLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGluZGljYXRvckF4ZXMgPSBjb29yZFN5cy5nZXRJbmRpY2F0b3JBeGVzKCk7XG4gICAgdmFyIG5hbWUgPSB0aGlzLmdldERhdGEoKS5nZXROYW1lKGRhdGFJbmRleCk7XG4gICAgdmFyIG5hbWVUb0Rpc3BsYXkgPSBuYW1lID09PSAnJyA/IHRoaXMubmFtZSA6IG5hbWU7XG4gICAgdmFyIG1hcmtlckNvbG9yID0gcmV0cmlldmVWaXN1YWxDb2xvckZvclRvb2x0aXBNYXJrZXIodGhpcywgZGF0YUluZGV4KTtcbiAgICByZXR1cm4gY3JlYXRlVG9vbHRpcE1hcmt1cCgnc2VjdGlvbicsIHtcbiAgICAgIGhlYWRlcjogbmFtZVRvRGlzcGxheSxcbiAgICAgIHNvcnRCbG9ja3M6IHRydWUsXG4gICAgICBibG9ja3M6IHpyVXRpbC5tYXAoaW5kaWNhdG9yQXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRhdGEuZ2V0KGRhdGEubWFwRGltZW5zaW9uKGF4aXMuZGltKSwgZGF0YUluZGV4KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRvb2x0aXBNYXJrdXAoJ25hbWVWYWx1ZScsIHtcbiAgICAgICAgICBtYXJrZXJUeXBlOiAnc3ViSXRlbScsXG4gICAgICAgICAgbWFya2VyQ29sb3I6IG1hcmtlckNvbG9yLFxuICAgICAgICAgIG5hbWU6IGF4aXMubmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgIHNvcnRQYXJhbTogdmFsXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICB9KTtcbiAgfTtcblxuICBSYWRhclNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRUb29sdGlwUG9zaXRpb24gPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgaWYgKGRhdGFJbmRleCAhPSBudWxsKSB7XG4gICAgICB2YXIgZGF0YV8xID0gdGhpcy5nZXREYXRhKCk7XG4gICAgICB2YXIgY29vcmRTeXMgPSB0aGlzLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICB2YXIgdmFsdWVzID0gZGF0YV8xLmdldFZhbHVlcyh6clV0aWwubWFwKGNvb3JkU3lzLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfMS5tYXBEaW1lbnNpb24oZGltKTtcbiAgICAgIH0pLCBkYXRhSW5kZXgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghaXNOYU4odmFsdWVzW2ldKSkge1xuICAgICAgICAgIHZhciBpbmRpY2F0b3JBeGVzID0gY29vcmRTeXMuZ2V0SW5kaWNhdG9yQXhlcygpO1xuICAgICAgICAgIHJldHVybiBjb29yZFN5cy5jb29yZFRvUG9pbnQoaW5kaWNhdG9yQXhlc1tpXS5kYXRhVG9Db29yZCh2YWx1ZXNbaV0pLCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBSYWRhclNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLnJhZGFyJztcbiAgUmFkYXJTZXJpZXNNb2RlbC5kZXBlbmRlbmNpZXMgPSBbJ3JhZGFyJ107XG4gIFJhZGFyU2VyaWVzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogMixcbiAgICBjb29yZGluYXRlU3lzdGVtOiAncmFkYXInLFxuICAgIGxlZ2VuZEhvdmVyTGluazogdHJ1ZSxcbiAgICByYWRhckluZGV4OiAwLFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgd2lkdGg6IDIsXG4gICAgICB0eXBlOiAnc29saWQnXG4gICAgfSxcbiAgICBsYWJlbDoge1xuICAgICAgcG9zaXRpb246ICd0b3AnXG4gICAgfSxcbiAgICAvLyBhcmVhU3R5bGU6IHtcbiAgICAvLyB9LFxuICAgIC8vIGl0ZW1TdHlsZToge31cbiAgICBzeW1ib2w6ICdlbXB0eUNpcmNsZScsXG4gICAgc3ltYm9sU2l6ZTogNCAvLyBzeW1ib2xSb3RhdGU6IG51bGxcblxuICB9O1xuICByZXR1cm4gUmFkYXJTZXJpZXNNb2RlbDtcbn0oU2VyaWVzTW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBSYWRhclNlcmllc01vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCB7IHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbCwgZW5hYmxlSG92ZXJFbXBoYXNpcyB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdGVzJztcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgc3ltYm9sVXRpbCBmcm9tICcuLi8uLi91dGlsL3N5bWJvbCc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ2hhcnQnO1xuaW1wb3J0IHsgc2V0TGFiZWxTdHlsZSwgZ2V0TGFiZWxTdGF0ZXNNb2RlbHMgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlJztcbmltcG9ydCBaUkltYWdlIGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UnO1xuXG5mdW5jdGlvbiBub3JtYWxpemVTeW1ib2xTaXplKHN5bWJvbFNpemUpIHtcbiAgaWYgKCF6clV0aWwuaXNBcnJheShzeW1ib2xTaXplKSkge1xuICAgIHN5bWJvbFNpemUgPSBbK3N5bWJvbFNpemUsICtzeW1ib2xTaXplXTtcbiAgfVxuXG4gIHJldHVybiBzeW1ib2xTaXplO1xufVxuXG52YXIgUmFkYXJWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFJhZGFyVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBSYWRhclZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gUmFkYXJWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUmFkYXJWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBwb2xhciA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVTeW1ib2woZGF0YSwgaWR4KSB7XG4gICAgICB2YXIgc3ltYm9sVHlwZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKSB8fCAnY2lyY2xlJztcblxuICAgICAgaWYgKHN5bWJvbFR5cGUgPT09ICdub25lJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzeW1ib2xTaXplID0gbm9ybWFsaXplU3ltYm9sU2l6ZShkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScpKTtcbiAgICAgIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woc3ltYm9sVHlwZSwgLTEsIC0xLCAyLCAyKTtcbiAgICAgIHZhciBzeW1ib2xSb3RhdGUgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sUm90YXRlJykgfHwgMDtcbiAgICAgIHN5bWJvbFBhdGguYXR0cih7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgc3Ryb2tlTm9TY2FsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB6MjogMTAwLFxuICAgICAgICBzY2FsZVg6IHN5bWJvbFNpemVbMF0gLyAyLFxuICAgICAgICBzY2FsZVk6IHN5bWJvbFNpemVbMV0gLyAyLFxuICAgICAgICByb3RhdGlvbjogc3ltYm9sUm90YXRlICogTWF0aC5QSSAvIDE4MCB8fCAwXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzeW1ib2xQYXRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN5bWJvbHMob2xkUG9pbnRzLCBuZXdQb2ludHMsIHN5bWJvbEdyb3VwLCBkYXRhLCBpZHgsIGlzSW5pdCkge1xuICAgICAgLy8gU2ltcGx5IHJlcmVuZGVyIGFsbFxuICAgICAgc3ltYm9sR3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3UG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2YXIgc3ltYm9sUGF0aCA9IGNyZWF0ZVN5bWJvbChkYXRhLCBpZHgpO1xuXG4gICAgICAgIGlmIChzeW1ib2xQYXRoKSB7XG4gICAgICAgICAgc3ltYm9sUGF0aC5fX2RpbUlkeCA9IGk7XG5cbiAgICAgICAgICBpZiAob2xkUG9pbnRzW2ldKSB7XG4gICAgICAgICAgICBzeW1ib2xQYXRoLnNldFBvc2l0aW9uKG9sZFBvaW50c1tpXSk7XG4gICAgICAgICAgICBncmFwaGljW2lzSW5pdCA/ICdpbml0UHJvcHMnIDogJ3VwZGF0ZVByb3BzJ10oc3ltYm9sUGF0aCwge1xuICAgICAgICAgICAgICB4OiBuZXdQb2ludHNbaV1bMF0sXG4gICAgICAgICAgICAgIHk6IG5ld1BvaW50c1tpXVsxXVxuICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN5bWJvbFBhdGguc2V0UG9zaXRpb24obmV3UG9pbnRzW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzeW1ib2xHcm91cC5hZGQoc3ltYm9sUGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsUG9pbnRzKHBvaW50cykge1xuICAgICAgcmV0dXJuIHpyVXRpbC5tYXAocG9pbnRzLCBmdW5jdGlvbiAocHQpIHtcbiAgICAgICAgcmV0dXJuIFtwb2xhci5jeCwgcG9sYXIuY3ldO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGF0YS5kaWZmKG9sZERhdGEpLmFkZChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgcG9pbnRzID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG5cbiAgICAgIGlmICghcG9pbnRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvbHlnb24gPSBuZXcgZ3JhcGhpYy5Qb2x5Z29uKCk7XG4gICAgICB2YXIgcG9seWxpbmUgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSgpO1xuICAgICAgdmFyIHRhcmdldCA9IHtcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcG9seWdvbi5zaGFwZS5wb2ludHMgPSBnZXRJbml0aWFsUG9pbnRzKHBvaW50cyk7XG4gICAgICBwb2x5bGluZS5zaGFwZS5wb2ludHMgPSBnZXRJbml0aWFsUG9pbnRzKHBvaW50cyk7XG4gICAgICBncmFwaGljLmluaXRQcm9wcyhwb2x5Z29uLCB0YXJnZXQsIHNlcmllc01vZGVsLCBpZHgpO1xuICAgICAgZ3JhcGhpYy5pbml0UHJvcHMocG9seWxpbmUsIHRhcmdldCwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgICB2YXIgaXRlbUdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICAgIHZhciBzeW1ib2xHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgICBpdGVtR3JvdXAuYWRkKHBvbHlsaW5lKTtcbiAgICAgIGl0ZW1Hcm91cC5hZGQocG9seWdvbik7XG4gICAgICBpdGVtR3JvdXAuYWRkKHN5bWJvbEdyb3VwKTtcbiAgICAgIHVwZGF0ZVN5bWJvbHMocG9seWxpbmUuc2hhcGUucG9pbnRzLCBwb2ludHMsIHN5bWJvbEdyb3VwLCBkYXRhLCBpZHgsIHRydWUpO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgaXRlbUdyb3VwKTtcbiAgICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgICB2YXIgaXRlbUdyb3VwID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgICB2YXIgcG9seWxpbmUgPSBpdGVtR3JvdXAuY2hpbGRBdCgwKTtcbiAgICAgIHZhciBwb2x5Z29uID0gaXRlbUdyb3VwLmNoaWxkQXQoMSk7XG4gICAgICB2YXIgc3ltYm9sR3JvdXAgPSBpdGVtR3JvdXAuY2hpbGRBdCgyKTtcbiAgICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgcG9pbnRzOiBkYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoIXRhcmdldC5zaGFwZS5wb2ludHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVTeW1ib2xzKHBvbHlsaW5lLnNoYXBlLnBvaW50cywgdGFyZ2V0LnNoYXBlLnBvaW50cywgc3ltYm9sR3JvdXAsIGRhdGEsIG5ld0lkeCwgZmFsc2UpO1xuICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2x5bGluZSwgdGFyZ2V0LCBzZXJpZXNNb2RlbCk7XG4gICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHBvbHlnb24sIHRhcmdldCwgc2VyaWVzTW9kZWwpO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgaXRlbUdyb3VwKTtcbiAgICB9KS5yZW1vdmUoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgZ3JvdXAucmVtb3ZlKG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpKTtcbiAgICB9KS5leGVjdXRlKCk7XG4gICAgZGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoaXRlbUdyb3VwLCBpZHgpIHtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgdmFyIHBvbHlsaW5lID0gaXRlbUdyb3VwLmNoaWxkQXQoMCk7XG4gICAgICB2YXIgcG9seWdvbiA9IGl0ZW1Hcm91cC5jaGlsZEF0KDEpO1xuICAgICAgdmFyIHN5bWJvbEdyb3VwID0gaXRlbUdyb3VwLmNoaWxkQXQoMik7IC8vIFJhZGFyIHVzZXMgdGhlIHZpc3VhbCBlbmNvZGVkIGZyb20gaXRlbVN0eWxlLlxuXG4gICAgICB2YXIgaXRlbVN0eWxlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJyk7XG4gICAgICB2YXIgY29sb3IgPSBpdGVtU3R5bGUuZmlsbDtcbiAgICAgIGdyb3VwLmFkZChpdGVtR3JvdXApO1xuICAgICAgcG9seWxpbmUudXNlU3R5bGUoenJVdGlsLmRlZmF1bHRzKGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCksIHtcbiAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICBzdHJva2U6IGNvbG9yXG4gICAgICB9KSk7XG4gICAgICBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwocG9seWxpbmUsIGl0ZW1Nb2RlbCwgJ2xpbmVTdHlsZScpO1xuICAgICAgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsKHBvbHlnb24sIGl0ZW1Nb2RlbCwgJ2FyZWFTdHlsZScpO1xuICAgICAgdmFyIGFyZWFTdHlsZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdhcmVhU3R5bGUnKTtcbiAgICAgIHZhciBwb2x5Z29uSWdub3JlID0gYXJlYVN0eWxlTW9kZWwuaXNFbXB0eSgpICYmIGFyZWFTdHlsZU1vZGVsLnBhcmVudE1vZGVsLmlzRW1wdHkoKTtcbiAgICAgIHBvbHlnb24uaWdub3JlID0gcG9seWdvbklnbm9yZTtcbiAgICAgIHpyVXRpbC5lYWNoKFsnZW1waGFzaXMnLCAnc2VsZWN0JywgJ2JsdXInXSwgZnVuY3Rpb24gKHN0YXRlTmFtZSkge1xuICAgICAgICB2YXIgc3RhdGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChbc3RhdGVOYW1lLCAnYXJlYVN0eWxlJ10pO1xuICAgICAgICB2YXIgc3RhdGVJZ25vcmUgPSBzdGF0ZU1vZGVsLmlzRW1wdHkoKSAmJiBzdGF0ZU1vZGVsLnBhcmVudE1vZGVsLmlzRW1wdHkoKTsgLy8gV29uJ3QgYmUgaWdub3JlIGlmIG5vcm1hbCBzdGF0ZSBpcyBub3QgaWdub3JlLlxuXG4gICAgICAgIHBvbHlnb24uZW5zdXJlU3RhdGUoc3RhdGVOYW1lKS5pZ25vcmUgPSBzdGF0ZUlnbm9yZSAmJiBwb2x5Z29uSWdub3JlO1xuICAgICAgfSk7XG4gICAgICBwb2x5Z29uLnVzZVN0eWxlKHpyVXRpbC5kZWZhdWx0cyhhcmVhU3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKSwge1xuICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgb3BhY2l0eTogMC43LFxuICAgICAgICBkZWNhbDogaXRlbVN0eWxlLmRlY2FsXG4gICAgICB9KSk7XG4gICAgICB2YXIgZW1waGFzaXNNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKTtcbiAgICAgIHZhciBpdGVtSG92ZXJTdHlsZSA9IGVtcGhhc2lzTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgc3ltYm9sR3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChzeW1ib2xQYXRoKSB7XG4gICAgICAgIGlmIChzeW1ib2xQYXRoIGluc3RhbmNlb2YgWlJJbWFnZSkge1xuICAgICAgICAgIHZhciBwYXRoU3R5bGUgPSBzeW1ib2xQYXRoLnN0eWxlO1xuICAgICAgICAgIHN5bWJvbFBhdGgudXNlU3R5bGUoenJVdGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAvLyBUT0RPIG90aGVyIHByb3BlcnRpZXMgbGlrZSB4LCB5ID9cbiAgICAgICAgICAgIGltYWdlOiBwYXRoU3R5bGUuaW1hZ2UsXG4gICAgICAgICAgICB4OiBwYXRoU3R5bGUueCxcbiAgICAgICAgICAgIHk6IHBhdGhTdHlsZS55LFxuICAgICAgICAgICAgd2lkdGg6IHBhdGhTdHlsZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogcGF0aFN0eWxlLmhlaWdodFxuICAgICAgICAgIH0sIGl0ZW1TdHlsZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN5bWJvbFBhdGgudXNlU3R5bGUoaXRlbVN0eWxlKTtcbiAgICAgICAgICBzeW1ib2xQYXRoLnNldENvbG9yKGNvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXRoRW1waGFzaXNTdGF0ZSA9IHN5bWJvbFBhdGguZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJyk7XG4gICAgICAgIHBhdGhFbXBoYXNpc1N0YXRlLnN0eWxlID0genJVdGlsLmNsb25lKGl0ZW1Ib3ZlclN0eWxlKTtcbiAgICAgICAgdmFyIGRlZmF1bHRUZXh0ID0gZGF0YS5nZXQoZGF0YS5kaW1lbnNpb25zW3N5bWJvbFBhdGguX19kaW1JZHhdLCBpZHgpO1xuICAgICAgICAoZGVmYXVsdFRleHQgPT0gbnVsbCB8fCBpc05hTihkZWZhdWx0VGV4dCkpICYmIChkZWZhdWx0VGV4dCA9ICcnKTtcbiAgICAgICAgc2V0TGFiZWxTdHlsZShzeW1ib2xQYXRoLCBnZXRMYWJlbFN0YXRlc01vZGVscyhpdGVtTW9kZWwpLCB7XG4gICAgICAgICAgbGFiZWxGZXRjaGVyOiBkYXRhLmhvc3RNb2RlbCxcbiAgICAgICAgICBsYWJlbERhdGFJbmRleDogaWR4LFxuICAgICAgICAgIGxhYmVsRGltSW5kZXg6IHN5bWJvbFBhdGguX19kaW1JZHgsXG4gICAgICAgICAgZGVmYXVsdFRleHQ6IGRlZmF1bHRUZXh0LFxuICAgICAgICAgIGluaGVyaXRDb2xvcjogY29sb3IsXG4gICAgICAgICAgZGVmYXVsdE9wYWNpdHk6IGl0ZW1TdHlsZS5vcGFjaXR5XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBlbmFibGVIb3ZlckVtcGhhc2lzKGl0ZW1Hcm91cCwgZW1waGFzaXNNb2RlbC5nZXQoJ2ZvY3VzJyksIGVtcGhhc2lzTW9kZWwuZ2V0KCdibHVyU2NvcGUnKSk7XG4gICAgfSk7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH07XG5cbiAgUmFkYXJWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgfTtcblxuICBSYWRhclZpZXcudHlwZSA9ICdyYWRhcic7XG4gIHJldHVybiBSYWRhclZpZXc7XG59KENoYXJ0Vmlldyk7XG5cbmV4cG9ydCBkZWZhdWx0IFJhZGFyVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gQHRzLW5vY2hlY2tcbi8vIEJhY2t3YXJkIGNvbXBhdCBmb3IgcmFkYXIgY2hhcnQgaW4gMlxuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByYWRhckJhY2t3YXJkQ29tcGF0KG9wdGlvbikge1xuICB2YXIgcG9sYXJPcHRBcnIgPSBvcHRpb24ucG9sYXI7XG5cbiAgaWYgKHBvbGFyT3B0QXJyKSB7XG4gICAgaWYgKCF6clV0aWwuaXNBcnJheShwb2xhck9wdEFycikpIHtcbiAgICAgIHBvbGFyT3B0QXJyID0gW3BvbGFyT3B0QXJyXTtcbiAgICB9XG5cbiAgICB2YXIgcG9sYXJOb3RSYWRhcl8xID0gW107XG4gICAgenJVdGlsLmVhY2gocG9sYXJPcHRBcnIsIGZ1bmN0aW9uIChwb2xhck9wdCwgaWR4KSB7XG4gICAgICBpZiAocG9sYXJPcHQuaW5kaWNhdG9yKSB7XG4gICAgICAgIGlmIChwb2xhck9wdC50eXBlICYmICFwb2xhck9wdC5zaGFwZSkge1xuICAgICAgICAgIHBvbGFyT3B0LnNoYXBlID0gcG9sYXJPcHQudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbi5yYWRhciA9IG9wdGlvbi5yYWRhciB8fCBbXTtcblxuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KG9wdGlvbi5yYWRhcikpIHtcbiAgICAgICAgICBvcHRpb24ucmFkYXIgPSBbb3B0aW9uLnJhZGFyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbi5yYWRhci5wdXNoKHBvbGFyT3B0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvbGFyTm90UmFkYXJfMS5wdXNoKHBvbGFyT3B0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvcHRpb24ucG9sYXIgPSBwb2xhck5vdFJhZGFyXzE7XG4gIH1cblxuICB6clV0aWwuZWFjaChvcHRpb24uc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzT3B0KSB7XG4gICAgaWYgKHNlcmllc09wdCAmJiBzZXJpZXNPcHQudHlwZSA9PT0gJ3JhZGFyJyAmJiBzZXJpZXNPcHQucG9sYXJJbmRleCkge1xuICAgICAgc2VyaWVzT3B0LnJhZGFySW5kZXggPSBzZXJpZXNPcHQucG9sYXJJbmRleDtcbiAgICB9XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyB1c2UgfSBmcm9tICcuLi8uLi9leHRlbnNpb24nO1xuaW1wb3J0IHJhZGFyTGF5b3V0IGZyb20gJy4uL3JhZGFyL3JhZGFyTGF5b3V0JztcbmltcG9ydCBkYXRhRmlsdGVyIGZyb20gJy4uLy4uL3Byb2Nlc3Nvci9kYXRhRmlsdGVyJztcbmltcG9ydCBiYWNrd2FyZENvbXBhdCBmcm9tICcuLi9yYWRhci9iYWNrd2FyZENvbXBhdCc7XG5pbXBvcnQgUmFkYXJWaWV3IGZyb20gJy4vUmFkYXJWaWV3JztcbmltcG9ydCBSYWRhclNlcmllc01vZGVsIGZyb20gJy4vUmFkYXJTZXJpZXMnO1xuaW1wb3J0IHsgaW5zdGFsbCBhcyBpbnN0YWxsUmFkYXJDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jb21wb25lbnQvcmFkYXIvaW5zdGFsbCc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgdXNlKGluc3RhbGxSYWRhckNvbXBvbmVudCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhSYWRhclZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChSYWRhclNlcmllc01vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KHJhZGFyTGF5b3V0KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJvY2Vzc29yKGRhdGFGaWx0ZXIoJ3JhZGFyJykpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJQcmVwcm9jZXNzb3IoYmFja3dhcmRDb21wYXQpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJhZGFyTGF5b3V0KGVjTW9kZWwpIHtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCdyYWRhcicsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgaWYgKCFjb29yZFN5cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBheGVzID0gY29vcmRTeXMuZ2V0SW5kaWNhdG9yQXhlcygpO1xuICAgIHpyVXRpbC5lYWNoKGF4ZXMsIGZ1bmN0aW9uIChheGlzLCBheGlzSW5kZXgpIHtcbiAgICAgIGRhdGEuZWFjaChkYXRhLm1hcERpbWVuc2lvbihheGVzW2F4aXNJbmRleF0uZGltKSwgZnVuY3Rpb24gKHZhbCwgZGF0YUluZGV4KSB7XG4gICAgICAgIHBvaW50c1tkYXRhSW5kZXhdID0gcG9pbnRzW2RhdGFJbmRleF0gfHwgW107XG4gICAgICAgIHZhciBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KHZhbCwgYXhpc0luZGV4KTtcbiAgICAgICAgcG9pbnRzW2RhdGFJbmRleF1bYXhpc0luZGV4XSA9IGlzVmFsaWRQb2ludChwb2ludCkgPyBwb2ludCA6IGdldFZhbHVlTWlzc2luZ1BvaW50KGNvb3JkU3lzKTtcbiAgICAgIH0pO1xuICAgIH0pOyAvLyBDbG9zZSBwb2x5Z29uXG5cbiAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgLy8gVE9ET1xuICAgICAgLy8gSXMgaXQgYXBwcm9wcmlhdGUgdG8gY29ubmVjdCB0byB0aGUgbmV4dCBkYXRhIHdoZW4gc29tZSBkYXRhIGlzIG1pc3Npbmc/XG4gICAgICAvLyBPciwgc2hvdWxkIHRyYWRlIGl0IGxpa2UgYGNvbm5lY3ROdWxsYCBpbiBsaW5lIGNoYXJ0P1xuICAgICAgdmFyIGZpcnN0UG9pbnQgPSB6clV0aWwuZmluZChwb2ludHNbaWR4XSwgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkUG9pbnQocG9pbnQpO1xuICAgICAgfSkgfHwgZ2V0VmFsdWVNaXNzaW5nUG9pbnQoY29vcmRTeXMpOyAvLyBDb3B5IHRoZSBmaXJzdCBhY3R1YWwgcG9pbnQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXlcblxuICAgICAgcG9pbnRzW2lkeF0ucHVzaChmaXJzdFBvaW50LnNsaWNlKCkpO1xuICAgICAgZGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwgcG9pbnRzW2lkeF0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBvaW50KHBvaW50KSB7XG4gIHJldHVybiAhaXNOYU4ocG9pbnRbMF0pICYmICFpc05hTihwb2ludFsxXSk7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlTWlzc2luZ1BvaW50KGNvb3JkU3lzKSB7XG4gIC8vIEl0IGlzIGVycm9yLXByb25lIHRvIGlucHV0IFtOYU4sIE5hTl0gaW50byBwb2x5Z29uLCBwb2x5Z29uLlxuICAvLyAocHJvYmFibHkgY2F1c2UgcHJvYmxlbSB3aGVuIHJlZnJlc2hpbmcgb3IgYW5pbWF0aW5nKVxuICByZXR1cm4gW2Nvb3JkU3lzLmN4LCBjb29yZFN5cy5jeV07XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcyc7XG5pbXBvcnQgY3JlYXRlR3JhcGhGcm9tTm9kZUVkZ2UgZnJvbSAnLi4vaGVscGVyL2NyZWF0ZUdyYXBoRnJvbU5vZGVFZGdlJztcbmltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Nb2RlbCc7XG5pbXBvcnQgeyBjcmVhdGVUb29sdGlwTWFya3VwIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50L3Rvb2x0aXAvdG9vbHRpcE1hcmt1cCc7XG5cbnZhciBTYW5rZXlTZXJpZXNNb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTYW5rZXlTZXJpZXNNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTYW5rZXlTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBTYW5rZXlTZXJpZXNNb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogSW5pdCBhIGdyYXBoIGRhdGEgc3RydWN0dXJlIGZyb20gZGF0YSBpbiBvcHRpb24gc2VyaWVzXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uICB0aGUgb2JqZWN0IHVzZWQgdG8gY29uZmlnIGVjaGFydHMgdmlld1xuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IHN0b3JhZ2UgaW5pdGlhbCBkYXRhXG4gICAqL1xuXG5cbiAgU2Fua2V5U2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIHZhciBsaW5rcyA9IG9wdGlvbi5lZGdlcyB8fCBvcHRpb24ubGlua3M7XG4gICAgdmFyIG5vZGVzID0gb3B0aW9uLmRhdGEgfHwgb3B0aW9uLm5vZGVzO1xuICAgIHZhciBsZXZlbHMgPSBvcHRpb24ubGV2ZWxzO1xuICAgIHRoaXMubGV2ZWxNb2RlbHMgPSBbXTtcbiAgICB2YXIgbGV2ZWxNb2RlbHMgPSB0aGlzLmxldmVsTW9kZWxzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsZXZlbHNbaV0uZGVwdGggIT0gbnVsbCAmJiBsZXZlbHNbaV0uZGVwdGggPj0gMCkge1xuICAgICAgICBsZXZlbE1vZGVsc1tsZXZlbHNbaV0uZGVwdGhdID0gbmV3IE1vZGVsKGxldmVsc1tpXSwgdGhpcywgZWNNb2RlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGV2ZWxzW2ldLmRlcHRoIGlzIG1hbmRhdG9yeSBhbmQgc2hvdWxkIGJlIG5hdHVyYWwgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZXMgJiYgbGlua3MpIHtcbiAgICAgIHZhciBncmFwaCA9IGNyZWF0ZUdyYXBoRnJvbU5vZGVFZGdlKG5vZGVzLCBsaW5rcywgdGhpcywgdHJ1ZSwgYmVmb3JlTGluayk7XG4gICAgICByZXR1cm4gZ3JhcGguZGF0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiZWZvcmVMaW5rKG5vZGVEYXRhLCBlZGdlRGF0YSkge1xuICAgICAgbm9kZURhdGEud3JhcE1ldGhvZCgnZ2V0SXRlbU1vZGVsJywgZnVuY3Rpb24gKG1vZGVsLCBpZHgpIHtcbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gbW9kZWwucGFyZW50TW9kZWw7XG4gICAgICAgIHZhciBsYXlvdXQgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCkuZ2V0SXRlbUxheW91dChpZHgpO1xuXG4gICAgICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgICB2YXIgbm9kZURlcHRoID0gbGF5b3V0LmRlcHRoO1xuICAgICAgICAgIHZhciBsZXZlbE1vZGVsID0gc2VyaWVzTW9kZWwubGV2ZWxNb2RlbHNbbm9kZURlcHRoXTtcblxuICAgICAgICAgIGlmIChsZXZlbE1vZGVsKSB7XG4gICAgICAgICAgICBtb2RlbC5wYXJlbnRNb2RlbCA9IGxldmVsTW9kZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgfSk7XG4gICAgICBlZGdlRGF0YS53cmFwTWV0aG9kKCdnZXRJdGVtTW9kZWwnLCBmdW5jdGlvbiAobW9kZWwsIGlkeCkge1xuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBtb2RlbC5wYXJlbnRNb2RlbDtcbiAgICAgICAgdmFyIGVkZ2UgPSBzZXJpZXNNb2RlbC5nZXRHcmFwaCgpLmdldEVkZ2VCeUluZGV4KGlkeCk7XG4gICAgICAgIHZhciBsYXlvdXQgPSBlZGdlLm5vZGUxLmdldExheW91dCgpO1xuXG4gICAgICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgICB2YXIgZGVwdGggPSBsYXlvdXQuZGVwdGg7XG4gICAgICAgICAgdmFyIGxldmVsTW9kZWwgPSBzZXJpZXNNb2RlbC5sZXZlbE1vZGVsc1tkZXB0aF07XG5cbiAgICAgICAgICBpZiAobGV2ZWxNb2RlbCkge1xuICAgICAgICAgICAgbW9kZWwucGFyZW50TW9kZWwgPSBsZXZlbE1vZGVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBTYW5rZXlTZXJpZXNNb2RlbC5wcm90b3R5cGUuc2V0Tm9kZVBvc2l0aW9uID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgbG9jYWxQb3NpdGlvbikge1xuICAgIHZhciBkYXRhSXRlbSA9IHRoaXMub3B0aW9uLmRhdGFbZGF0YUluZGV4XTtcbiAgICBkYXRhSXRlbS5sb2NhbFggPSBsb2NhbFBvc2l0aW9uWzBdO1xuICAgIGRhdGFJdGVtLmxvY2FsWSA9IGxvY2FsUG9zaXRpb25bMV07XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGdyYXBoaWMgZGF0YSBzdHJ1Y3R1cmVcbiAgICpcbiAgICogQHJldHVybiBncmFwaGljIGRhdGEgc3RydWN0dXJlXG4gICAqL1xuXG5cbiAgU2Fua2V5U2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEdyYXBoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldERhdGEoKS5ncmFwaDtcbiAgfTtcbiAgLyoqXG4gICAqIEdldCBlZGdlIGRhdGEgb2YgZ3JhcGhpYyBkYXRhIHN0cnVjdHVyZVxuICAgKlxuICAgKiBAcmV0dXJuIGRhdGEgc3RydWN0dXJlIG9mIGxpc3RcbiAgICovXG5cblxuICBTYW5rZXlTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0RWRnZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0R3JhcGgoKS5lZGdlRGF0YTtcbiAgfTtcblxuICBTYW5rZXlTZXJpZXNNb2RlbC5wcm90b3R5cGUuZm9ybWF0VG9vbHRpcCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIG11bHRpcGxlU2VyaWVzLCBkYXRhVHlwZSkge1xuICAgIGZ1bmN0aW9uIG5vVmFsdWUodmFsKSB7XG4gICAgICByZXR1cm4gaXNOYU4odmFsKSB8fCB2YWwgPT0gbnVsbDtcbiAgICB9IC8vIGRhdGFUeXBlID09PSAnbm9kZScgb3IgZW1wdHkgZG8gbm90IHNob3cgdG9vbHRpcCBieSBkZWZhdWx0XG5cblxuICAgIGlmIChkYXRhVHlwZSA9PT0gJ2VkZ2UnKSB7XG4gICAgICB2YXIgcGFyYW1zID0gdGhpcy5nZXREYXRhUGFyYW1zKGRhdGFJbmRleCwgZGF0YVR5cGUpO1xuICAgICAgdmFyIHJhd0RhdGFPcHQgPSBwYXJhbXMuZGF0YTtcbiAgICAgIHZhciBlZGdlVmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICB2YXIgZWRnZU5hbWUgPSByYXdEYXRhT3B0LnNvdXJjZSArICcgLS0gJyArIHJhd0RhdGFPcHQudGFyZ2V0O1xuICAgICAgcmV0dXJuIGNyZWF0ZVRvb2x0aXBNYXJrdXAoJ25hbWVWYWx1ZScsIHtcbiAgICAgICAgbmFtZTogZWRnZU5hbWUsXG4gICAgICAgIHZhbHVlOiBlZGdlVmFsdWUsXG4gICAgICAgIG5vVmFsdWU6IG5vVmFsdWUoZWRnZVZhbHVlKVxuICAgICAgfSk7XG4gICAgfSAvLyBkYXRhVHlwZSA9PT0gJ25vZGUnXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5nZXRHcmFwaCgpLmdldE5vZGVCeUluZGV4KGRhdGFJbmRleCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0TGF5b3V0KCkudmFsdWU7XG4gICAgICAgIHZhciBuYW1lXzEgPSB0aGlzLmdldERhdGFQYXJhbXMoZGF0YUluZGV4LCBkYXRhVHlwZSkuZGF0YS5uYW1lO1xuICAgICAgICByZXR1cm4gY3JlYXRlVG9vbHRpcE1hcmt1cCgnbmFtZVZhbHVlJywge1xuICAgICAgICAgIG5hbWU6IG5hbWVfMSAhPSBudWxsID8gbmFtZV8xICsgJycgOiBudWxsLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBub1ZhbHVlOiBub1ZhbHVlKHZhbHVlKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgfTtcblxuICBTYW5rZXlTZXJpZXNNb2RlbC5wcm90b3R5cGUub3B0aW9uVXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gIH07IC8vIE92ZXJyaWRlIFNlcmllcy5nZXREYXRhUGFyYW1zKClcblxuXG4gIFNhbmtleVNlcmllc01vZGVsLnByb3RvdHlwZS5nZXREYXRhUGFyYW1zID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgZGF0YVR5cGUpIHtcbiAgICB2YXIgcGFyYW1zID0gX3N1cGVyLnByb3RvdHlwZS5nZXREYXRhUGFyYW1zLmNhbGwodGhpcywgZGF0YUluZGV4LCBkYXRhVHlwZSk7XG5cbiAgICBpZiAocGFyYW1zLnZhbHVlID09IG51bGwgJiYgZGF0YVR5cGUgPT09ICdub2RlJykge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldEdyYXBoKCkuZ2V0Tm9kZUJ5SW5kZXgoZGF0YUluZGV4KTtcbiAgICAgIHZhciBub2RlVmFsdWUgPSBub2RlLmdldExheW91dCgpLnZhbHVlO1xuICAgICAgcGFyYW1zLnZhbHVlID0gbm9kZVZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH07XG5cbiAgU2Fua2V5U2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMuc2Fua2V5JztcbiAgU2Fua2V5U2VyaWVzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogMixcbiAgICBjb29yZGluYXRlU3lzdGVtOiAndmlldycsXG4gICAgbGVmdDogJzUlJyxcbiAgICB0b3A6ICc1JScsXG4gICAgcmlnaHQ6ICcyMCUnLFxuICAgIGJvdHRvbTogJzUlJyxcbiAgICBvcmllbnQ6ICdob3Jpem9udGFsJyxcbiAgICBub2RlV2lkdGg6IDIwLFxuICAgIG5vZGVHYXA6IDgsXG4gICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgIGxheW91dEl0ZXJhdGlvbnM6IDMyLFxuICAgIGxhYmVsOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgICBmb250U2l6ZTogMTJcbiAgICB9LFxuICAgIGxldmVsczogW10sXG4gICAgbm9kZUFsaWduOiAnanVzdGlmeScsXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyMzMTQ2NTYnLFxuICAgICAgb3BhY2l0eTogMC4yLFxuICAgICAgY3VydmVuZXNzOiAwLjVcbiAgICB9LFxuICAgIGVtcGhhc2lzOiB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICBzaG93OiB0cnVlXG4gICAgICB9LFxuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIG9wYWNpdHk6IDAuNVxuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0OiB7XG4gICAgICBpdGVtU3R5bGU6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMjEyMTIxJ1xuICAgICAgfVxuICAgIH0sXG4gICAgYW5pbWF0aW9uRWFzaW5nOiAnbGluZWFyJyxcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMTAwMFxuICB9O1xuICByZXR1cm4gU2Fua2V5U2VyaWVzTW9kZWw7XG59KFNlcmllc01vZGVsKTtcblxuZXhwb3J0IGRlZmF1bHQgU2Fua2V5U2VyaWVzTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IHsgZW50ZXJFbXBoYXNpcywgbGVhdmVFbXBoYXNpcywgZW5hYmxlSG92ZXJFbXBoYXNpcywgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0JztcbmltcG9ydCB7IHNldExhYmVsU3R5bGUsIGdldExhYmVsU3RhdGVzTW9kZWxzIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZSc7XG5pbXBvcnQgeyBnZXRFQ0RhdGEgfSBmcm9tICcuLi8uLi91dGlsL2lubmVyU3RvcmUnO1xuXG52YXIgU2Fua2V5UGF0aFNoYXBlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2Fua2V5UGF0aFNoYXBlKCkge1xuICAgIHRoaXMueDEgPSAwO1xuICAgIHRoaXMueTEgPSAwO1xuICAgIHRoaXMueDIgPSAwO1xuICAgIHRoaXMueTIgPSAwO1xuICAgIHRoaXMuY3B4MSA9IDA7XG4gICAgdGhpcy5jcHkxID0gMDtcbiAgICB0aGlzLmNweDIgPSAwO1xuICAgIHRoaXMuY3B5MiA9IDA7XG4gICAgdGhpcy5leHRlbnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIFNhbmtleVBhdGhTaGFwZTtcbn0oKTtcblxudmFyIFNhbmtleVBhdGggPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2Fua2V5UGF0aCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTYW5rZXlQYXRoKG9wdHMpIHtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcbiAgfVxuXG4gIFNhbmtleVBhdGgucHJvdG90eXBlLmdldERlZmF1bHRTaGFwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNhbmtleVBhdGhTaGFwZSgpO1xuICB9O1xuXG4gIFNhbmtleVBhdGgucHJvdG90eXBlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIGV4dGVudCA9IHNoYXBlLmV4dGVudDtcbiAgICBjdHgubW92ZVRvKHNoYXBlLngxLCBzaGFwZS55MSk7XG4gICAgY3R4LmJlemllckN1cnZlVG8oc2hhcGUuY3B4MSwgc2hhcGUuY3B5MSwgc2hhcGUuY3B4Miwgc2hhcGUuY3B5Miwgc2hhcGUueDIsIHNoYXBlLnkyKTtcblxuICAgIGlmIChzaGFwZS5vcmllbnQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIGN0eC5saW5lVG8oc2hhcGUueDIgKyBleHRlbnQsIHNoYXBlLnkyKTtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHNoYXBlLmNweDIgKyBleHRlbnQsIHNoYXBlLmNweTIsIHNoYXBlLmNweDEgKyBleHRlbnQsIHNoYXBlLmNweTEsIHNoYXBlLngxICsgZXh0ZW50LCBzaGFwZS55MSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8oc2hhcGUueDIsIHNoYXBlLnkyICsgZXh0ZW50KTtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHNoYXBlLmNweDIsIHNoYXBlLmNweTIgKyBleHRlbnQsIHNoYXBlLmNweDEsIHNoYXBlLmNweTEgKyBleHRlbnQsIHNoYXBlLngxLCBzaGFwZS55MSArIGV4dGVudCk7XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIFNhbmtleVBhdGgucHJvdG90eXBlLmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbnRlckVtcGhhc2lzKHRoaXMpO1xuICB9O1xuXG4gIFNhbmtleVBhdGgucHJvdG90eXBlLmRvd25wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIGxlYXZlRW1waGFzaXModGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIFNhbmtleVBhdGg7XG59KGdyYXBoaWMuUGF0aCk7XG5cbnZhciBTYW5rZXlWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNhbmtleVZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU2Fua2V5VmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBTYW5rZXlWaWV3LnR5cGU7XG4gICAgX3RoaXMuX2ZvY3VzQWRqYWNlbmN5RGlzYWJsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBTYW5rZXlWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBzYW5rZXlWaWV3ID0gdGhpcztcbiAgICB2YXIgZ3JhcGggPSBzZXJpZXNNb2RlbC5nZXRHcmFwaCgpO1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGxheW91dEluZm8gPSBzZXJpZXNNb2RlbC5sYXlvdXRJbmZvOyAvLyB2aWV3IHdpZHRoXG5cbiAgICB2YXIgd2lkdGggPSBsYXlvdXRJbmZvLndpZHRoOyAvLyB2aWV3IGhlaWdodFxuXG4gICAgdmFyIGhlaWdodCA9IGxheW91dEluZm8uaGVpZ2h0O1xuICAgIHZhciBub2RlRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgZWRnZURhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCdlZGdlJyk7XG4gICAgdmFyIG9yaWVudCA9IHNlcmllc01vZGVsLmdldCgnb3JpZW50Jyk7XG4gICAgdGhpcy5fbW9kZWwgPSBzZXJpZXNNb2RlbDtcbiAgICBncm91cC5yZW1vdmVBbGwoKTtcbiAgICBncm91cC54ID0gbGF5b3V0SW5mby54O1xuICAgIGdyb3VwLnkgPSBsYXlvdXRJbmZvLnk7IC8vIGdlbmVyYXRlIGEgYmV6aXJlIEN1cnZlIGZvciBlYWNoIGVkZ2VcblxuICAgIGdyYXBoLmVhY2hFZGdlKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICB2YXIgY3VydmUgPSBuZXcgU2Fua2V5UGF0aCgpO1xuICAgICAgdmFyIGVjRGF0YSA9IGdldEVDRGF0YShjdXJ2ZSk7XG4gICAgICBlY0RhdGEuZGF0YUluZGV4ID0gZWRnZS5kYXRhSW5kZXg7XG4gICAgICBlY0RhdGEuc2VyaWVzSW5kZXggPSBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleDtcbiAgICAgIGVjRGF0YS5kYXRhVHlwZSA9ICdlZGdlJztcbiAgICAgIHZhciBlZGdlTW9kZWwgPSBlZGdlLmdldE1vZGVsKCk7XG4gICAgICB2YXIgbGluZVN0eWxlTW9kZWwgPSBlZGdlTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICAgICAgdmFyIGN1cnZhdHVyZSA9IGxpbmVTdHlsZU1vZGVsLmdldCgnY3VydmVuZXNzJyk7XG4gICAgICB2YXIgbjFMYXlvdXQgPSBlZGdlLm5vZGUxLmdldExheW91dCgpO1xuICAgICAgdmFyIG5vZGUxTW9kZWwgPSBlZGdlLm5vZGUxLmdldE1vZGVsKCk7XG4gICAgICB2YXIgZHJhZ1gxID0gbm9kZTFNb2RlbC5nZXQoJ2xvY2FsWCcpO1xuICAgICAgdmFyIGRyYWdZMSA9IG5vZGUxTW9kZWwuZ2V0KCdsb2NhbFknKTtcbiAgICAgIHZhciBuMkxheW91dCA9IGVkZ2Uubm9kZTIuZ2V0TGF5b3V0KCk7XG4gICAgICB2YXIgbm9kZTJNb2RlbCA9IGVkZ2Uubm9kZTIuZ2V0TW9kZWwoKTtcbiAgICAgIHZhciBkcmFnWDIgPSBub2RlMk1vZGVsLmdldCgnbG9jYWxYJyk7XG4gICAgICB2YXIgZHJhZ1kyID0gbm9kZTJNb2RlbC5nZXQoJ2xvY2FsWScpO1xuICAgICAgdmFyIGVkZ2VMYXlvdXQgPSBlZGdlLmdldExheW91dCgpO1xuICAgICAgdmFyIHgxO1xuICAgICAgdmFyIHkxO1xuICAgICAgdmFyIHgyO1xuICAgICAgdmFyIHkyO1xuICAgICAgdmFyIGNweDE7XG4gICAgICB2YXIgY3B5MTtcbiAgICAgIHZhciBjcHgyO1xuICAgICAgdmFyIGNweTI7XG4gICAgICBjdXJ2ZS5zaGFwZS5leHRlbnQgPSBNYXRoLm1heCgxLCBlZGdlTGF5b3V0LmR5KTtcbiAgICAgIGN1cnZlLnNoYXBlLm9yaWVudCA9IG9yaWVudDtcblxuICAgICAgaWYgKG9yaWVudCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICB4MSA9IChkcmFnWDEgIT0gbnVsbCA/IGRyYWdYMSAqIHdpZHRoIDogbjFMYXlvdXQueCkgKyBlZGdlTGF5b3V0LnN5O1xuICAgICAgICB5MSA9IChkcmFnWTEgIT0gbnVsbCA/IGRyYWdZMSAqIGhlaWdodCA6IG4xTGF5b3V0LnkpICsgbjFMYXlvdXQuZHk7XG4gICAgICAgIHgyID0gKGRyYWdYMiAhPSBudWxsID8gZHJhZ1gyICogd2lkdGggOiBuMkxheW91dC54KSArIGVkZ2VMYXlvdXQudHk7XG4gICAgICAgIHkyID0gZHJhZ1kyICE9IG51bGwgPyBkcmFnWTIgKiBoZWlnaHQgOiBuMkxheW91dC55O1xuICAgICAgICBjcHgxID0geDE7XG4gICAgICAgIGNweTEgPSB5MSAqICgxIC0gY3VydmF0dXJlKSArIHkyICogY3VydmF0dXJlO1xuICAgICAgICBjcHgyID0geDI7XG4gICAgICAgIGNweTIgPSB5MSAqIGN1cnZhdHVyZSArIHkyICogKDEgLSBjdXJ2YXR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDEgPSAoZHJhZ1gxICE9IG51bGwgPyBkcmFnWDEgKiB3aWR0aCA6IG4xTGF5b3V0LngpICsgbjFMYXlvdXQuZHg7XG4gICAgICAgIHkxID0gKGRyYWdZMSAhPSBudWxsID8gZHJhZ1kxICogaGVpZ2h0IDogbjFMYXlvdXQueSkgKyBlZGdlTGF5b3V0LnN5O1xuICAgICAgICB4MiA9IGRyYWdYMiAhPSBudWxsID8gZHJhZ1gyICogd2lkdGggOiBuMkxheW91dC54O1xuICAgICAgICB5MiA9IChkcmFnWTIgIT0gbnVsbCA/IGRyYWdZMiAqIGhlaWdodCA6IG4yTGF5b3V0LnkpICsgZWRnZUxheW91dC50eTtcbiAgICAgICAgY3B4MSA9IHgxICogKDEgLSBjdXJ2YXR1cmUpICsgeDIgKiBjdXJ2YXR1cmU7XG4gICAgICAgIGNweTEgPSB5MTtcbiAgICAgICAgY3B4MiA9IHgxICogY3VydmF0dXJlICsgeDIgKiAoMSAtIGN1cnZhdHVyZSk7XG4gICAgICAgIGNweTIgPSB5MjtcbiAgICAgIH1cblxuICAgICAgY3VydmUuc2V0U2hhcGUoe1xuICAgICAgICB4MTogeDEsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeDI6IHgyLFxuICAgICAgICB5MjogeTIsXG4gICAgICAgIGNweDE6IGNweDEsXG4gICAgICAgIGNweTE6IGNweTEsXG4gICAgICAgIGNweDI6IGNweDIsXG4gICAgICAgIGNweTI6IGNweTJcbiAgICAgIH0pO1xuICAgICAgY3VydmUudXNlU3R5bGUobGluZVN0eWxlTW9kZWwuZ2V0SXRlbVN0eWxlKCkpOyAvLyBTcGVjaWFsIGNvbG9yLCB1c2Ugc291cmNlIG5vZGUgY29sb3Igb3IgdGFyZ2V0IG5vZGUgY29sb3JcblxuICAgICAgc3dpdGNoIChjdXJ2ZS5zdHlsZS5maWxsKSB7XG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgY3VydmUuc3R5bGUuZmlsbCA9IGVkZ2Uubm9kZTEuZ2V0VmlzdWFsKCdjb2xvcicpO1xuICAgICAgICAgIGN1cnZlLnN0eWxlLmRlY2FsID0gZWRnZS5ub2RlMS5nZXRWaXN1YWwoJ3N0eWxlJykuZGVjYWw7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBjdXJ2ZS5zdHlsZS5maWxsID0gZWRnZS5ub2RlMi5nZXRWaXN1YWwoJ2NvbG9yJyk7XG4gICAgICAgICAgY3VydmUuc3R5bGUuZGVjYWwgPSBlZGdlLm5vZGUyLmdldFZpc3VhbCgnc3R5bGUnKS5kZWNhbDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdncmFkaWVudCc6XG4gICAgICAgICAgdmFyIHNvdXJjZUNvbG9yID0gZWRnZS5ub2RlMS5nZXRWaXN1YWwoJ2NvbG9yJyk7XG4gICAgICAgICAgdmFyIHRhcmdldENvbG9yID0gZWRnZS5ub2RlMi5nZXRWaXN1YWwoJ2NvbG9yJyk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZUNvbG9yID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdGFyZ2V0Q29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjdXJ2ZS5zdHlsZS5maWxsID0gbmV3IGdyYXBoaWMuTGluZWFyR3JhZGllbnQoMCwgMCwgMSwgMCwgW3tcbiAgICAgICAgICAgICAgY29sb3I6IHNvdXJjZUNvbG9yLFxuICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgY29sb3I6IHRhcmdldENvbG9yLFxuICAgICAgICAgICAgICBvZmZzZXQ6IDFcbiAgICAgICAgICAgIH1dKTtcbiAgICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdmFyIGVtcGhhc2lzTW9kZWwgPSBlZGdlTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJyk7XG4gICAgICBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwoY3VydmUsIGVkZ2VNb2RlbCwgJ2xpbmVTdHlsZScsIGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICByZXR1cm4gbW9kZWwuZ2V0SXRlbVN0eWxlKCk7XG4gICAgICB9KTtcbiAgICAgIGdyb3VwLmFkZChjdXJ2ZSk7XG4gICAgICBlZGdlRGF0YS5zZXRJdGVtR3JhcGhpY0VsKGVkZ2UuZGF0YUluZGV4LCBjdXJ2ZSk7XG4gICAgICB2YXIgZm9jdXMgPSBlbXBoYXNpc01vZGVsLmdldCgnZm9jdXMnKTtcbiAgICAgIGVuYWJsZUhvdmVyRW1waGFzaXMoY3VydmUsIGZvY3VzID09PSAnYWRqYWNlbmN5JyA/IGVkZ2UuZ2V0QWRqYWNlbnREYXRhSW5kaWNlcygpIDogZm9jdXMsIGVtcGhhc2lzTW9kZWwuZ2V0KCdibHVyU2NvcGUnKSk7XG4gICAgICBnZXRFQ0RhdGEoY3VydmUpLmRhdGFUeXBlID0gJ2VkZ2UnO1xuICAgIH0pOyAvLyBHZW5lcmF0ZSBhIHJlY3QgZm9yIGVhY2ggbm9kZVxuXG4gICAgZ3JhcGguZWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBsYXlvdXQgPSBub2RlLmdldExheW91dCgpO1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IG5vZGUuZ2V0TW9kZWwoKTtcbiAgICAgIHZhciBkcmFnWCA9IGl0ZW1Nb2RlbC5nZXQoJ2xvY2FsWCcpO1xuICAgICAgdmFyIGRyYWdZID0gaXRlbU1vZGVsLmdldCgnbG9jYWxZJyk7XG4gICAgICB2YXIgZW1waGFzaXNNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKTtcbiAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgeDogZHJhZ1ggIT0gbnVsbCA/IGRyYWdYICogd2lkdGggOiBsYXlvdXQueCxcbiAgICAgICAgICB5OiBkcmFnWSAhPSBudWxsID8gZHJhZ1kgKiBoZWlnaHQgOiBsYXlvdXQueSxcbiAgICAgICAgICB3aWR0aDogbGF5b3V0LmR4LFxuICAgICAgICAgIGhlaWdodDogbGF5b3V0LmR5XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZSgpXG4gICAgICB9KTtcbiAgICAgIHNldExhYmVsU3R5bGUocmVjdCwgZ2V0TGFiZWxTdGF0ZXNNb2RlbHMoaXRlbU1vZGVsKSwge1xuICAgICAgICBsYWJlbEZldGNoZXI6IHNlcmllc01vZGVsLFxuICAgICAgICBsYWJlbERhdGFJbmRleDogbm9kZS5kYXRhSW5kZXgsXG4gICAgICAgIGRlZmF1bHRUZXh0OiBub2RlLmlkXG4gICAgICB9KTtcbiAgICAgIHJlY3QuZGlzYWJsZUxhYmVsQW5pbWF0aW9uID0gdHJ1ZTtcbiAgICAgIHJlY3Quc2V0U3R5bGUoJ2ZpbGwnLCBub2RlLmdldFZpc3VhbCgnY29sb3InKSk7XG4gICAgICByZWN0LnNldFN0eWxlKCdkZWNhbCcsIG5vZGUuZ2V0VmlzdWFsKCdzdHlsZScpLmRlY2FsKTtcbiAgICAgIHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbChyZWN0LCBpdGVtTW9kZWwpO1xuICAgICAgZ3JvdXAuYWRkKHJlY3QpO1xuICAgICAgbm9kZURhdGEuc2V0SXRlbUdyYXBoaWNFbChub2RlLmRhdGFJbmRleCwgcmVjdCk7XG4gICAgICBnZXRFQ0RhdGEocmVjdCkuZGF0YVR5cGUgPSAnbm9kZSc7XG4gICAgICB2YXIgZm9jdXMgPSBlbXBoYXNpc01vZGVsLmdldCgnZm9jdXMnKTtcbiAgICAgIGVuYWJsZUhvdmVyRW1waGFzaXMocmVjdCwgZm9jdXMgPT09ICdhZGphY2VuY3knID8gbm9kZS5nZXRBZGphY2VudERhdGFJbmRpY2VzKCkgOiBmb2N1cywgZW1waGFzaXNNb2RlbC5nZXQoJ2JsdXJTY29wZScpKTtcbiAgICB9KTtcbiAgICBub2RlRGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwsIGRhdGFJbmRleCkge1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IG5vZGVEYXRhLmdldEl0ZW1Nb2RlbChkYXRhSW5kZXgpO1xuXG4gICAgICBpZiAoaXRlbU1vZGVsLmdldCgnZHJhZ2dhYmxlJykpIHtcbiAgICAgICAgZWwuZHJpZnQgPSBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICAgICAgc2Fua2V5Vmlldy5fZm9jdXNBZGphY2VuY3lEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zaGFwZS54ICs9IGR4O1xuICAgICAgICAgIHRoaXMuc2hhcGUueSArPSBkeTtcbiAgICAgICAgICB0aGlzLmRpcnR5KCk7XG4gICAgICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdkcmFnTm9kZScsXG4gICAgICAgICAgICBzZXJpZXNJZDogc2VyaWVzTW9kZWwuaWQsXG4gICAgICAgICAgICBkYXRhSW5kZXg6IG5vZGVEYXRhLmdldFJhd0luZGV4KGRhdGFJbmRleCksXG4gICAgICAgICAgICBsb2NhbFg6IHRoaXMuc2hhcGUueCAvIHdpZHRoLFxuICAgICAgICAgICAgbG9jYWxZOiB0aGlzLnNoYXBlLnkgLyBoZWlnaHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBlbC5vbmRyYWdlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2Fua2V5Vmlldy5fZm9jdXNBZGphY2VuY3lEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGVsLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIGVsLmN1cnNvciA9ICdtb3ZlJztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghdGhpcy5fZGF0YSAmJiBzZXJpZXNNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKSkge1xuICAgICAgZ3JvdXAuc2V0Q2xpcFBhdGgoY3JlYXRlR3JpZENsaXBTaGFwZShncm91cC5nZXRCb3VuZGluZ1JlY3QoKSwgc2VyaWVzTW9kZWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZ3JvdXAucmVtb3ZlQ2xpcFBhdGgoKTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICB9O1xuXG4gIFNhbmtleVZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBTYW5rZXlWaWV3LnR5cGUgPSAnc2Fua2V5JztcbiAgcmV0dXJuIFNhbmtleVZpZXc7XG59KENoYXJ0Vmlldyk7IC8vIEFkZCBhbmltYXRpb24gdG8gdGhlIHZpZXdcblxuXG5mdW5jdGlvbiBjcmVhdGVHcmlkQ2xpcFNoYXBlKHJlY3QsIHNlcmllc01vZGVsLCBjYikge1xuICB2YXIgcmVjdEVsID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgc2hhcGU6IHtcbiAgICAgIHg6IHJlY3QueCAtIDEwLFxuICAgICAgeTogcmVjdC55IC0gMTAsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKyAyMFxuICAgIH1cbiAgfSk7XG4gIGdyYXBoaWMuaW5pdFByb3BzKHJlY3RFbCwge1xuICAgIHNoYXBlOiB7XG4gICAgICB3aWR0aDogcmVjdC53aWR0aCArIDIwXG4gICAgfVxuICB9LCBzZXJpZXNNb2RlbCwgY2IpO1xuICByZXR1cm4gcmVjdEVsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTYW5rZXlWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgU2Fua2V5VmlldyBmcm9tICcuL1NhbmtleVZpZXcnO1xuaW1wb3J0IFNhbmtleVNlcmllc01vZGVsIGZyb20gJy4vU2Fua2V5U2VyaWVzJztcbmltcG9ydCBzYW5rZXlMYXlvdXQgZnJvbSAnLi9zYW5rZXlMYXlvdXQnO1xuaW1wb3J0IHNhbmtleVZpc3VhbCBmcm9tICcuL3NhbmtleVZpc3VhbCc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ2hhcnRWaWV3KFNhbmtleVZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChTYW5rZXlTZXJpZXNNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckxheW91dChzYW5rZXlMYXlvdXQpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJWaXN1YWwoc2Fua2V5VmlzdWFsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgICB0eXBlOiAnZHJhZ05vZGUnLFxuICAgIGV2ZW50OiAnZHJhZ25vZGUnLFxuICAgIC8vIGhlcmUgY2FuIG9ubHkgdXNlICd1cGRhdGUnIG5vdywgb3RoZXIgdmFsdWUgaXMgbm90IHN1cHBvcnQgaW4gZWNoYXJ0cy5cbiAgICB1cGRhdGU6ICd1cGRhdGUnXG4gIH0sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgIG1haW5UeXBlOiAnc2VyaWVzJyxcbiAgICAgIHN1YlR5cGU6ICdzYW5rZXknLFxuICAgICAgcXVlcnk6IHBheWxvYWRcbiAgICB9LCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHNlcmllc01vZGVsLnNldE5vZGVQb3NpdGlvbihwYXlsb2FkLmRhdGFJbmRleCwgW3BheWxvYWQubG9jYWxYLCBwYXlsb2FkLmxvY2FsWV0pO1xuICAgIH0pO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgbGF5b3V0IGZyb20gJy4uLy4uL3V0aWwvbGF5b3V0JztcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgZ3JvdXBEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzYW5rZXlMYXlvdXQoZWNNb2RlbCwgYXBpKSB7XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgnc2Fua2V5JywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIG5vZGVXaWR0aCA9IHNlcmllc01vZGVsLmdldCgnbm9kZVdpZHRoJyk7XG4gICAgdmFyIG5vZGVHYXAgPSBzZXJpZXNNb2RlbC5nZXQoJ25vZGVHYXAnKTtcbiAgICB2YXIgbGF5b3V0SW5mbyA9IGdldFZpZXdSZWN0KHNlcmllc01vZGVsLCBhcGkpO1xuICAgIHNlcmllc01vZGVsLmxheW91dEluZm8gPSBsYXlvdXRJbmZvO1xuICAgIHZhciB3aWR0aCA9IGxheW91dEluZm8ud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGxheW91dEluZm8uaGVpZ2h0O1xuICAgIHZhciBncmFwaCA9IHNlcmllc01vZGVsLmdldEdyYXBoKCk7XG4gICAgdmFyIG5vZGVzID0gZ3JhcGgubm9kZXM7XG4gICAgdmFyIGVkZ2VzID0gZ3JhcGguZWRnZXM7XG4gICAgY29tcHV0ZU5vZGVWYWx1ZXMobm9kZXMpO1xuICAgIHZhciBmaWx0ZXJlZE5vZGVzID0genJVdGlsLmZpbHRlcihub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmdldExheW91dCgpLnZhbHVlID09PSAwO1xuICAgIH0pO1xuICAgIHZhciBpdGVyYXRpb25zID0gZmlsdGVyZWROb2Rlcy5sZW5ndGggIT09IDAgPyAwIDogc2VyaWVzTW9kZWwuZ2V0KCdsYXlvdXRJdGVyYXRpb25zJyk7XG4gICAgdmFyIG9yaWVudCA9IHNlcmllc01vZGVsLmdldCgnb3JpZW50Jyk7XG4gICAgdmFyIG5vZGVBbGlnbiA9IHNlcmllc01vZGVsLmdldCgnbm9kZUFsaWduJyk7XG4gICAgbGF5b3V0U2Fua2V5KG5vZGVzLCBlZGdlcywgbm9kZVdpZHRoLCBub2RlR2FwLCB3aWR0aCwgaGVpZ2h0LCBpdGVyYXRpb25zLCBvcmllbnQsIG5vZGVBbGlnbik7XG4gIH0pO1xufVxuLyoqXG4gKiBHZXQgdGhlIGxheW91dCBwb3NpdGlvbiBvZiB0aGUgd2hvbGUgdmlld1xuICovXG5cbmZ1bmN0aW9uIGdldFZpZXdSZWN0KHNlcmllc01vZGVsLCBhcGkpIHtcbiAgcmV0dXJuIGxheW91dC5nZXRMYXlvdXRSZWN0KHNlcmllc01vZGVsLmdldEJveExheW91dFBhcmFtcygpLCB7XG4gICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsYXlvdXRTYW5rZXkobm9kZXMsIGVkZ2VzLCBub2RlV2lkdGgsIG5vZGVHYXAsIHdpZHRoLCBoZWlnaHQsIGl0ZXJhdGlvbnMsIG9yaWVudCwgbm9kZUFsaWduKSB7XG4gIGNvbXB1dGVOb2RlQnJlYWR0aHMobm9kZXMsIGVkZ2VzLCBub2RlV2lkdGgsIHdpZHRoLCBoZWlnaHQsIG9yaWVudCwgbm9kZUFsaWduKTtcbiAgY29tcHV0ZU5vZGVEZXB0aHMobm9kZXMsIGVkZ2VzLCBoZWlnaHQsIHdpZHRoLCBub2RlR2FwLCBpdGVyYXRpb25zLCBvcmllbnQpO1xuICBjb21wdXRlRWRnZURlcHRocyhub2Rlcywgb3JpZW50KTtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgdmFsdWUgb2YgZWFjaCBub2RlIGJ5IHN1bW1pbmcgdGhlIGFzc29jaWF0ZWQgZWRnZSdzIHZhbHVlXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wdXRlTm9kZVZhbHVlcyhub2Rlcykge1xuICB6clV0aWwuZWFjaChub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgdmFsdWUxID0gc3VtKG5vZGUub3V0RWRnZXMsIGdldEVkZ2VWYWx1ZSk7XG4gICAgdmFyIHZhbHVlMiA9IHN1bShub2RlLmluRWRnZXMsIGdldEVkZ2VWYWx1ZSk7XG4gICAgdmFyIG5vZGVSYXdWYWx1ZSA9IG5vZGUuZ2V0VmFsdWUoKSB8fCAwO1xuICAgIHZhciB2YWx1ZSA9IE1hdGgubWF4KHZhbHVlMSwgdmFsdWUyLCBub2RlUmF3VmFsdWUpO1xuICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0sIHRydWUpO1xuICB9KTtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgeC1wb3NpdGlvbiBmb3IgZWFjaCBub2RlLlxuICpcbiAqIEhlcmUgd2UgdXNlIEthaG4gYWxnb3JpdGhtIHRvIGRldGVjdCBjeWNsZSB3aGVuIHdlIHRyYXZlcnNlXG4gKiB0aGUgbm9kZSB0byBjb21wdXRlciB0aGUgaW5pdGlhbCB4IHBvc2l0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gY29tcHV0ZU5vZGVCcmVhZHRocyhub2RlcywgZWRnZXMsIG5vZGVXaWR0aCwgd2lkdGgsIGhlaWdodCwgb3JpZW50LCBub2RlQWxpZ24pIHtcbiAgLy8gVXNlZCB0byBtYXJrIHdoZXRoZXIgdGhlIGVkZ2UgaXMgZGVsZXRlZC4gaWYgaXQgaXMgZGVsZXRlZCxcbiAgLy8gdGhlIHZhbHVlIGlzIDAsIG90aGVyd2lzZSBpdCBpcyAxLlxuICB2YXIgcmVtYWluRWRnZXMgPSBbXTsgLy8gU3RvcmFnZSBlYWNoIG5vZGUncyBpbmRlZ3JlZS5cblxuICB2YXIgaW5kZWdyZWVBcnIgPSBbXTsgLy9Vc2VkIHRvIHN0b3JhZ2UgdGhlIG5vZGUgd2l0aCBpbmRlZ3JlZSBpcyBlcXVhbCB0byAwLlxuXG4gIHZhciB6ZXJvSW5kZWdyZWVzID0gW107XG4gIHZhciBuZXh0VGFyZ2V0Tm9kZSA9IFtdO1xuICB2YXIgeCA9IDA7IC8vIGxldCBreCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHJlbWFpbkVkZ2VzW2ldID0gMTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpbmRlZ3JlZUFycltpXSA9IG5vZGVzW2ldLmluRWRnZXMubGVuZ3RoO1xuXG4gICAgaWYgKGluZGVncmVlQXJyW2ldID09PSAwKSB7XG4gICAgICB6ZXJvSW5kZWdyZWVzLnB1c2gobm9kZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtYXhOb2RlRGVwdGggPSAtMTsgLy8gVHJhdmVyc2luZyBub2RlcyB1c2luZyB0b3BvbG9naWNhbCBzb3J0aW5nIHRvIGNhbGN1bGF0ZSB0aGVcbiAgLy8gaG9yaXpvbnRhbChpZiBvcmllbnQgPT09ICdob3Jpem9udGFsJykgb3IgdmVydGljYWwoaWYgb3JpZW50ID09PSAndmVydGljYWwnKVxuICAvLyBwb3NpdGlvbiBvZiB0aGUgbm9kZXMuXG5cbiAgd2hpbGUgKHplcm9JbmRlZ3JlZXMubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgemVyb0luZGVncmVlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICB2YXIgbm9kZSA9IHplcm9JbmRlZ3JlZXNbaWR4XTtcbiAgICAgIHZhciBpdGVtID0gbm9kZS5ob3N0R3JhcGguZGF0YS5nZXRSYXdEYXRhSXRlbShub2RlLmRhdGFJbmRleCk7XG4gICAgICB2YXIgaXNJdGVtRGVwdGggPSBpdGVtLmRlcHRoICE9IG51bGwgJiYgaXRlbS5kZXB0aCA+PSAwO1xuXG4gICAgICBpZiAoaXNJdGVtRGVwdGggJiYgaXRlbS5kZXB0aCA+IG1heE5vZGVEZXB0aCkge1xuICAgICAgICBtYXhOb2RlRGVwdGggPSBpdGVtLmRlcHRoO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNldExheW91dCh7XG4gICAgICAgIGRlcHRoOiBpc0l0ZW1EZXB0aCA/IGl0ZW0uZGVwdGggOiB4XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/IG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgZHk6IG5vZGVXaWR0aFxuICAgICAgfSwgdHJ1ZSkgOiBub2RlLnNldExheW91dCh7XG4gICAgICAgIGR4OiBub2RlV2lkdGhcbiAgICAgIH0sIHRydWUpO1xuXG4gICAgICBmb3IgKHZhciBlZGdlSWR4ID0gMDsgZWRnZUlkeCA8IG5vZGUub3V0RWRnZXMubGVuZ3RoOyBlZGdlSWR4KyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBub2RlLm91dEVkZ2VzW2VkZ2VJZHhdO1xuICAgICAgICB2YXIgaW5kZXhFZGdlID0gZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICAgICAgcmVtYWluRWRnZXNbaW5kZXhFZGdlXSA9IDA7XG4gICAgICAgIHZhciB0YXJnZXROb2RlID0gZWRnZS5ub2RlMjtcbiAgICAgICAgdmFyIG5vZGVJbmRleCA9IG5vZGVzLmluZGV4T2YodGFyZ2V0Tm9kZSk7XG5cbiAgICAgICAgaWYgKC0taW5kZWdyZWVBcnJbbm9kZUluZGV4XSA9PT0gMCAmJiBuZXh0VGFyZ2V0Tm9kZS5pbmRleE9mKHRhcmdldE5vZGUpIDwgMCkge1xuICAgICAgICAgIG5leHRUYXJnZXROb2RlLnB1c2godGFyZ2V0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICArK3g7XG4gICAgemVyb0luZGVncmVlcyA9IG5leHRUYXJnZXROb2RlO1xuICAgIG5leHRUYXJnZXROb2RlID0gW107XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbWFpbkVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlbWFpbkVkZ2VzW2ldID09PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NhbmtleSBpcyBhIERBRywgdGhlIG9yaWdpbmFsIGRhdGEgaGFzIGN5Y2xlIScpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtYXhEZXB0aCA9IG1heE5vZGVEZXB0aCA+IHggLSAxID8gbWF4Tm9kZURlcHRoIDogeCAtIDE7XG5cbiAgaWYgKG5vZGVBbGlnbiAmJiBub2RlQWxpZ24gIT09ICdsZWZ0Jykge1xuICAgIGFkanVzdE5vZGVXaXRoTm9kZUFsaWduKG5vZGVzLCBub2RlQWxpZ24sIG9yaWVudCwgbWF4RGVwdGgpO1xuICB9XG5cbiAgdmFyIGt4ID0gb3JpZW50ID09PSAndmVydGljYWwnID8gKGhlaWdodCAtIG5vZGVXaWR0aCkgLyBtYXhEZXB0aCA6ICh3aWR0aCAtIG5vZGVXaWR0aCkgLyBtYXhEZXB0aDtcbiAgc2NhbGVOb2RlQnJlYWR0aHMobm9kZXMsIGt4LCBvcmllbnQpO1xufVxuXG5mdW5jdGlvbiBpc05vZGVEZXB0aChub2RlKSB7XG4gIHZhciBpdGVtID0gbm9kZS5ob3N0R3JhcGguZGF0YS5nZXRSYXdEYXRhSXRlbShub2RlLmRhdGFJbmRleCk7XG4gIHJldHVybiBpdGVtLmRlcHRoICE9IG51bGwgJiYgaXRlbS5kZXB0aCA+PSAwO1xufVxuXG5mdW5jdGlvbiBhZGp1c3ROb2RlV2l0aE5vZGVBbGlnbihub2Rlcywgbm9kZUFsaWduLCBvcmllbnQsIG1heERlcHRoKSB7XG4gIGlmIChub2RlQWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB2YXIgbmV4dFNvdXJjZU5vZGUgPSBbXTtcbiAgICB2YXIgcmVtYWluTm9kZXMgPSBub2RlcztcbiAgICB2YXIgbm9kZUhlaWdodCA9IDA7XG5cbiAgICB3aGlsZSAocmVtYWluTm9kZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbWFpbk5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gcmVtYWluTm9kZXNbaV07XG4gICAgICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgICBza05vZGVIZWlnaHQ6IG5vZGVIZWlnaHRcbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLmluRWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IG5vZGUuaW5FZGdlc1tqXTtcblxuICAgICAgICAgIGlmIChuZXh0U291cmNlTm9kZS5pbmRleE9mKGVkZ2Uubm9kZTEpIDwgMCkge1xuICAgICAgICAgICAgbmV4dFNvdXJjZU5vZGUucHVzaChlZGdlLm5vZGUxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVtYWluTm9kZXMgPSBuZXh0U291cmNlTm9kZTtcbiAgICAgIG5leHRTb3VyY2VOb2RlID0gW107XG4gICAgICArK25vZGVIZWlnaHQ7XG4gICAgfVxuXG4gICAgenJVdGlsLmVhY2gobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoIWlzTm9kZURlcHRoKG5vZGUpKSB7XG4gICAgICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgICBkZXB0aDogTWF0aC5tYXgoMCwgbWF4RGVwdGggLSBub2RlLmdldExheW91dCgpLnNrTm9kZUhlaWdodClcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobm9kZUFsaWduID09PSAnanVzdGlmeScpIHtcbiAgICBtb3ZlU2lua3NSaWdodChub2RlcywgbWF4RGVwdGgpO1xuICB9XG59XG4vKipcbiAqIEFsbCB0aGUgbm9kZSB3aXRob3V0IG91dEVnZGVzIGFyZSBhc3NpZ25lZCBtYXhpbXVtIHgtcG9zaXRpb24gYW5kXG4gKiAgICAgYmUgYWxpZ25lZCBpbiB0aGUgbGFzdCBjb2x1bW4uXG4gKlxuICogQHBhcmFtIG5vZGVzLiAgbm9kZSBvZiBzYW5rZXkgdmlldy5cbiAqIEBwYXJhbSBtYXhEZXB0aC4gIHVzZSB0byBhc3NpZ24gdG8gbm9kZSB3aXRob3V0IG91dEVkZ2VzIGFzIHgtcG9zaXRpb24uXG4gKi9cblxuXG5mdW5jdGlvbiBtb3ZlU2lua3NSaWdodChub2RlcywgbWF4RGVwdGgpIHtcbiAgenJVdGlsLmVhY2gobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKCFpc05vZGVEZXB0aChub2RlKSAmJiAhbm9kZS5vdXRFZGdlcy5sZW5ndGgpIHtcbiAgICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgZGVwdGg6IG1heERlcHRoXG4gICAgICB9LCB0cnVlKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBTY2FsZSBub2RlIHgtcG9zaXRpb24gdG8gdGhlIHdpZHRoXG4gKlxuICogQHBhcmFtIG5vZGVzICBub2RlIG9mIHNhbmtleSB2aWV3XG4gKiBAcGFyYW0ga3ggICBtdWx0aXBsZSB1c2VkIHRvIHNjYWxlIG5vZGVzXG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZU5vZGVCcmVhZHRocyhub2Rlcywga3gsIG9yaWVudCkge1xuICB6clV0aWwuZWFjaChub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgbm9kZURlcHRoID0gbm9kZS5nZXRMYXlvdXQoKS5kZXB0aCAqIGt4O1xuICAgIG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/IG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgIHk6IG5vZGVEZXB0aFxuICAgIH0sIHRydWUpIDogbm9kZS5zZXRMYXlvdXQoe1xuICAgICAgeDogbm9kZURlcHRoXG4gICAgfSwgdHJ1ZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBVc2luZyBHYXVzcy1TZWlkZWwgaXRlcmF0aW9ucyBtZXRob2QgdG8gY29tcHV0ZSB0aGUgbm9kZSBkZXB0aCh5LXBvc2l0aW9uKVxuICpcbiAqIEBwYXJhbSBub2RlcyAgbm9kZSBvZiBzYW5rZXkgdmlld1xuICogQHBhcmFtIGVkZ2VzICBlZGdlIG9mIHNhbmtleSB2aWV3XG4gKiBAcGFyYW0gaGVpZ2h0ICB0aGUgd2hvbGUgaGVpZ2h0IG9mIHRoZSBhcmVhIHRvIGRyYXcgdGhlIHZpZXdcbiAqIEBwYXJhbSBub2RlR2FwICB0aGUgdmVydGljYWwgZGlzdGFuY2UgYmV0d2VlbiB0d28gbm9kZXNcbiAqICAgICBpbiB0aGUgc2FtZSBjb2x1bW4uXG4gKiBAcGFyYW0gaXRlcmF0aW9ucyAgdGhlIG51bWJlciBvZiBpdGVyYXRpb25zIGZvciB0aGUgYWxnb3JpdGhtXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wdXRlTm9kZURlcHRocyhub2RlcywgZWRnZXMsIGhlaWdodCwgd2lkdGgsIG5vZGVHYXAsIGl0ZXJhdGlvbnMsIG9yaWVudCkge1xuICB2YXIgbm9kZXNCeUJyZWFkdGggPSBwcmVwYXJlTm9kZXNCeUJyZWFkdGgobm9kZXMsIG9yaWVudCk7XG4gIGluaXRpYWxpemVOb2RlRGVwdGgobm9kZXNCeUJyZWFkdGgsIGVkZ2VzLCBoZWlnaHQsIHdpZHRoLCBub2RlR2FwLCBvcmllbnQpO1xuICByZXNvbHZlQ29sbGlzaW9ucyhub2Rlc0J5QnJlYWR0aCwgbm9kZUdhcCwgaGVpZ2h0LCB3aWR0aCwgb3JpZW50KTtcblxuICBmb3IgKHZhciBhbHBoYSA9IDE7IGl0ZXJhdGlvbnMgPiAwOyBpdGVyYXRpb25zLS0pIHtcbiAgICAvLyAwLjk5IGlzIGEgZXhwZXJpZW5jZSBwYXJhbWV0ZXIsIGVuc3VyZSB0aGF0IGVhY2ggaXRlcmF0aW9ucyBvZlxuICAgIC8vIGNoYW5nZXMgYXMgc21hbGwgYXMgcG9zc2libGUuXG4gICAgYWxwaGEgKj0gMC45OTtcbiAgICByZWxheFJpZ2h0VG9MZWZ0KG5vZGVzQnlCcmVhZHRoLCBhbHBoYSwgb3JpZW50KTtcbiAgICByZXNvbHZlQ29sbGlzaW9ucyhub2Rlc0J5QnJlYWR0aCwgbm9kZUdhcCwgaGVpZ2h0LCB3aWR0aCwgb3JpZW50KTtcbiAgICByZWxheExlZnRUb1JpZ2h0KG5vZGVzQnlCcmVhZHRoLCBhbHBoYSwgb3JpZW50KTtcbiAgICByZXNvbHZlQ29sbGlzaW9ucyhub2Rlc0J5QnJlYWR0aCwgbm9kZUdhcCwgaGVpZ2h0LCB3aWR0aCwgb3JpZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlTm9kZXNCeUJyZWFkdGgobm9kZXMsIG9yaWVudCkge1xuICB2YXIgbm9kZXNCeUJyZWFkdGggPSBbXTtcbiAgdmFyIGtleUF0dHIgPSBvcmllbnQgPT09ICd2ZXJ0aWNhbCcgPyAneScgOiAneCc7XG4gIHZhciBncm91cFJlc3VsdCA9IGdyb3VwRGF0YShub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5nZXRMYXlvdXQoKVtrZXlBdHRyXTtcbiAgfSk7XG4gIGdyb3VwUmVzdWx0LmtleXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSk7XG4gIHpyVXRpbC5lYWNoKGdyb3VwUmVzdWx0LmtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBub2Rlc0J5QnJlYWR0aC5wdXNoKGdyb3VwUmVzdWx0LmJ1Y2tldHMuZ2V0KGtleSkpO1xuICB9KTtcbiAgcmV0dXJuIG5vZGVzQnlCcmVhZHRoO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBvcmlnaW5hbCB5LXBvc2l0aW9uIGZvciBlYWNoIG5vZGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGluaXRpYWxpemVOb2RlRGVwdGgobm9kZXNCeUJyZWFkdGgsIGVkZ2VzLCBoZWlnaHQsIHdpZHRoLCBub2RlR2FwLCBvcmllbnQpIHtcbiAgdmFyIG1pbkt5ID0gSW5maW5pdHk7XG4gIHpyVXRpbC5lYWNoKG5vZGVzQnlCcmVhZHRoLCBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICB2YXIgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB6clV0aWwuZWFjaChub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHN1bSArPSBub2RlLmdldExheW91dCgpLnZhbHVlO1xuICAgIH0pO1xuICAgIHZhciBreSA9IG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/ICh3aWR0aCAtIChuIC0gMSkgKiBub2RlR2FwKSAvIHN1bSA6IChoZWlnaHQgLSAobiAtIDEpICogbm9kZUdhcCkgLyBzdW07XG5cbiAgICBpZiAoa3kgPCBtaW5LeSkge1xuICAgICAgbWluS3kgPSBreTtcbiAgICB9XG4gIH0pO1xuICB6clV0aWwuZWFjaChub2Rlc0J5QnJlYWR0aCwgZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgenJVdGlsLmVhY2gobm9kZXMsIGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgICB2YXIgbm9kZUR5ID0gbm9kZS5nZXRMYXlvdXQoKS52YWx1ZSAqIG1pbkt5O1xuXG4gICAgICBpZiAob3JpZW50ID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgICB4OiBpXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBub2RlLnNldExheW91dCh7XG4gICAgICAgICAgZHg6IG5vZGVEeVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgICB5OiBpXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBub2RlLnNldExheW91dCh7XG4gICAgICAgICAgZHk6IG5vZGVEeVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHpyVXRpbC5lYWNoKGVkZ2VzLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHZhciBlZGdlRHkgPSArZWRnZS5nZXRWYWx1ZSgpICogbWluS3k7XG4gICAgZWRnZS5zZXRMYXlvdXQoe1xuICAgICAgZHk6IGVkZ2VEeVxuICAgIH0sIHRydWUpO1xuICB9KTtcbn1cbi8qKlxuICogUmVzb2x2ZSB0aGUgY29sbGlzaW9uIG9mIGluaXRpYWxpemVkIGRlcHRoICh5LXBvc2l0aW9uKVxuICovXG5cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbGxpc2lvbnMobm9kZXNCeUJyZWFkdGgsIG5vZGVHYXAsIGhlaWdodCwgd2lkdGgsIG9yaWVudCkge1xuICB2YXIga2V5QXR0ciA9IG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/ICd4JyA6ICd5JztcbiAgenJVdGlsLmVhY2gobm9kZXNCeUJyZWFkdGgsIGZ1bmN0aW9uIChub2Rlcykge1xuICAgIG5vZGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmdldExheW91dCgpW2tleUF0dHJdIC0gYi5nZXRMYXlvdXQoKVtrZXlBdHRyXTtcbiAgICB9KTtcbiAgICB2YXIgbm9kZVg7XG4gICAgdmFyIG5vZGU7XG4gICAgdmFyIGR5O1xuICAgIHZhciB5MCA9IDA7XG4gICAgdmFyIG4gPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIG5vZGVEeUF0dHIgPSBvcmllbnQgPT09ICd2ZXJ0aWNhbCcgPyAnZHgnIDogJ2R5JztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICBkeSA9IHkwIC0gbm9kZS5nZXRMYXlvdXQoKVtrZXlBdHRyXTtcblxuICAgICAgaWYgKGR5ID4gMCkge1xuICAgICAgICBub2RlWCA9IG5vZGUuZ2V0TGF5b3V0KClba2V5QXR0cl0gKyBkeTtcbiAgICAgICAgb3JpZW50ID09PSAndmVydGljYWwnID8gbm9kZS5zZXRMYXlvdXQoe1xuICAgICAgICAgIHg6IG5vZGVYXG4gICAgICAgIH0sIHRydWUpIDogbm9kZS5zZXRMYXlvdXQoe1xuICAgICAgICAgIHk6IG5vZGVYXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB5MCA9IG5vZGUuZ2V0TGF5b3V0KClba2V5QXR0cl0gKyBub2RlLmdldExheW91dCgpW25vZGVEeUF0dHJdICsgbm9kZUdhcDtcbiAgICB9XG5cbiAgICB2YXIgdmlld1dpZHRoID0gb3JpZW50ID09PSAndmVydGljYWwnID8gd2lkdGggOiBoZWlnaHQ7IC8vIElmIHRoZSBib3R0b21tb3N0IG5vZGUgZ29lcyBvdXRzaWRlIHRoZSBib3VuZHMsIHB1c2ggaXQgYmFjayB1cFxuXG4gICAgZHkgPSB5MCAtIG5vZGVHYXAgLSB2aWV3V2lkdGg7XG5cbiAgICBpZiAoZHkgPiAwKSB7XG4gICAgICBub2RlWCA9IG5vZGUuZ2V0TGF5b3V0KClba2V5QXR0cl0gLSBkeTtcbiAgICAgIG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/IG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgeDogbm9kZVhcbiAgICAgIH0sIHRydWUpIDogbm9kZS5zZXRMYXlvdXQoe1xuICAgICAgICB5OiBub2RlWFxuICAgICAgfSwgdHJ1ZSk7XG4gICAgICB5MCA9IG5vZGVYO1xuXG4gICAgICBmb3IgKHZhciBpID0gbiAtIDI7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgZHkgPSBub2RlLmdldExheW91dCgpW2tleUF0dHJdICsgbm9kZS5nZXRMYXlvdXQoKVtub2RlRHlBdHRyXSArIG5vZGVHYXAgLSB5MDtcblxuICAgICAgICBpZiAoZHkgPiAwKSB7XG4gICAgICAgICAgbm9kZVggPSBub2RlLmdldExheW91dCgpW2tleUF0dHJdIC0gZHk7XG4gICAgICAgICAgb3JpZW50ID09PSAndmVydGljYWwnID8gbm9kZS5zZXRMYXlvdXQoe1xuICAgICAgICAgICAgeDogbm9kZVhcbiAgICAgICAgICB9LCB0cnVlKSA6IG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgICAgIHk6IG5vZGVYXG4gICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB5MCA9IG5vZGUuZ2V0TGF5b3V0KClba2V5QXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQ2hhbmdlIHRoZSB5LXBvc2l0aW9uIG9mIHRoZSBub2RlcywgZXhjZXB0IG1vc3QgdGhlIHJpZ2h0IHNpZGUgbm9kZXNcbiAqIEBwYXJhbSBub2Rlc0J5QnJlYWR0aFxuICogQHBhcmFtIGFscGhhICBwYXJhbWV0ZXIgdXNlZCB0byBhZGp1c3QgdGhlIG5vZGVzIHktcG9zaXRpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbGF4UmlnaHRUb0xlZnQobm9kZXNCeUJyZWFkdGgsIGFscGhhLCBvcmllbnQpIHtcbiAgenJVdGlsLmVhY2gobm9kZXNCeUJyZWFkdGguc2xpY2UoKS5yZXZlcnNlKCksIGZ1bmN0aW9uIChub2Rlcykge1xuICAgIHpyVXRpbC5lYWNoKG5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKG5vZGUub3V0RWRnZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB5ID0gc3VtKG5vZGUub3V0RWRnZXMsIHdlaWdodGVkVGFyZ2V0LCBvcmllbnQpIC8gc3VtKG5vZGUub3V0RWRnZXMsIGdldEVkZ2VWYWx1ZSk7XG5cbiAgICAgICAgaWYgKGlzTmFOKHkpKSB7XG4gICAgICAgICAgdmFyIGxlbiA9IG5vZGUub3V0RWRnZXMubGVuZ3RoO1xuICAgICAgICAgIHkgPSBsZW4gPyBzdW0obm9kZS5vdXRFZGdlcywgY2VudGVyVGFyZ2V0LCBvcmllbnQpIC8gbGVuIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcmllbnQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICB2YXIgbm9kZVggPSBub2RlLmdldExheW91dCgpLnggKyAoeSAtIGNlbnRlcihub2RlLCBvcmllbnQpKSAqIGFscGhhO1xuICAgICAgICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgICAgIHg6IG5vZGVYXG4gICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5vZGVZID0gbm9kZS5nZXRMYXlvdXQoKS55ICsgKHkgLSBjZW50ZXIobm9kZSwgb3JpZW50KSkgKiBhbHBoYTtcbiAgICAgICAgICBub2RlLnNldExheW91dCh7XG4gICAgICAgICAgICB5OiBub2RlWVxuICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3ZWlnaHRlZFRhcmdldChlZGdlLCBvcmllbnQpIHtcbiAgcmV0dXJuIGNlbnRlcihlZGdlLm5vZGUyLCBvcmllbnQpICogZWRnZS5nZXRWYWx1ZSgpO1xufVxuXG5mdW5jdGlvbiBjZW50ZXJUYXJnZXQoZWRnZSwgb3JpZW50KSB7XG4gIHJldHVybiBjZW50ZXIoZWRnZS5ub2RlMiwgb3JpZW50KTtcbn1cblxuZnVuY3Rpb24gd2VpZ2h0ZWRTb3VyY2UoZWRnZSwgb3JpZW50KSB7XG4gIHJldHVybiBjZW50ZXIoZWRnZS5ub2RlMSwgb3JpZW50KSAqIGVkZ2UuZ2V0VmFsdWUoKTtcbn1cblxuZnVuY3Rpb24gY2VudGVyU291cmNlKGVkZ2UsIG9yaWVudCkge1xuICByZXR1cm4gY2VudGVyKGVkZ2Uubm9kZTEsIG9yaWVudCk7XG59XG5cbmZ1bmN0aW9uIGNlbnRlcihub2RlLCBvcmllbnQpIHtcbiAgcmV0dXJuIG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/IG5vZGUuZ2V0TGF5b3V0KCkueCArIG5vZGUuZ2V0TGF5b3V0KCkuZHggLyAyIDogbm9kZS5nZXRMYXlvdXQoKS55ICsgbm9kZS5nZXRMYXlvdXQoKS5keSAvIDI7XG59XG5cbmZ1bmN0aW9uIGdldEVkZ2VWYWx1ZShlZGdlKSB7XG4gIHJldHVybiBlZGdlLmdldFZhbHVlKCk7XG59XG5cbmZ1bmN0aW9uIHN1bShhcnJheSwgY2IsIG9yaWVudCkge1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIGkgPSAtMTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgdmFyIHZhbHVlID0gK2NiKGFycmF5W2ldLCBvcmllbnQpO1xuXG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VtO1xufVxuLyoqXG4gKiBDaGFuZ2UgdGhlIHktcG9zaXRpb24gb2YgdGhlIG5vZGVzLCBleGNlcHQgbW9zdCB0aGUgbGVmdCBzaWRlIG5vZGVzXG4gKi9cblxuXG5mdW5jdGlvbiByZWxheExlZnRUb1JpZ2h0KG5vZGVzQnlCcmVhZHRoLCBhbHBoYSwgb3JpZW50KSB7XG4gIHpyVXRpbC5lYWNoKG5vZGVzQnlCcmVhZHRoLCBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICB6clV0aWwuZWFjaChub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmluRWRnZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB5ID0gc3VtKG5vZGUuaW5FZGdlcywgd2VpZ2h0ZWRTb3VyY2UsIG9yaWVudCkgLyBzdW0obm9kZS5pbkVkZ2VzLCBnZXRFZGdlVmFsdWUpO1xuXG4gICAgICAgIGlmIChpc05hTih5KSkge1xuICAgICAgICAgIHZhciBsZW4gPSBub2RlLmluRWRnZXMubGVuZ3RoO1xuICAgICAgICAgIHkgPSBsZW4gPyBzdW0obm9kZS5pbkVkZ2VzLCBjZW50ZXJTb3VyY2UsIG9yaWVudCkgLyBsZW4gOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9yaWVudCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgIHZhciBub2RlWCA9IG5vZGUuZ2V0TGF5b3V0KCkueCArICh5IC0gY2VudGVyKG5vZGUsIG9yaWVudCkpICogYWxwaGE7XG4gICAgICAgICAgbm9kZS5zZXRMYXlvdXQoe1xuICAgICAgICAgICAgeDogbm9kZVhcbiAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbm9kZVkgPSBub2RlLmdldExheW91dCgpLnkgKyAoeSAtIGNlbnRlcihub2RlLCBvcmllbnQpKSAqIGFscGhhO1xuICAgICAgICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgICAgIHk6IG5vZGVZXG4gICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG4vKipcbiAqIENvbXB1dGUgdGhlIGRlcHRoKHktcG9zaXRpb24pIG9mIGVhY2ggZWRnZVxuICovXG5cblxuZnVuY3Rpb24gY29tcHV0ZUVkZ2VEZXB0aHMobm9kZXMsIG9yaWVudCkge1xuICB2YXIga2V5QXR0ciA9IG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/ICd4JyA6ICd5JztcbiAgenJVdGlsLmVhY2gobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbm9kZS5vdXRFZGdlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5ub2RlMi5nZXRMYXlvdXQoKVtrZXlBdHRyXSAtIGIubm9kZTIuZ2V0TGF5b3V0KClba2V5QXR0cl07XG4gICAgfSk7XG4gICAgbm9kZS5pbkVkZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm5vZGUxLmdldExheW91dCgpW2tleUF0dHJdIC0gYi5ub2RlMS5nZXRMYXlvdXQoKVtrZXlBdHRyXTtcbiAgICB9KTtcbiAgfSk7XG4gIHpyVXRpbC5lYWNoKG5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBzeSA9IDA7XG4gICAgdmFyIHR5ID0gMDtcbiAgICB6clV0aWwuZWFjaChub2RlLm91dEVkZ2VzLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgZWRnZS5zZXRMYXlvdXQoe1xuICAgICAgICBzeTogc3lcbiAgICAgIH0sIHRydWUpO1xuICAgICAgc3kgKz0gZWRnZS5nZXRMYXlvdXQoKS5keTtcbiAgICB9KTtcbiAgICB6clV0aWwuZWFjaChub2RlLmluRWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICBlZGdlLnNldExheW91dCh7XG4gICAgICAgIHR5OiB0eVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgICB0eSArPSBlZGdlLmdldExheW91dCgpLmR5O1xuICAgIH0pO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgVmlzdWFsTWFwcGluZyBmcm9tICcuLi8uLi92aXN1YWwvVmlzdWFsTWFwcGluZyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzYW5rZXlWaXN1YWwoZWNNb2RlbCkge1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ3NhbmtleScsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBncmFwaCA9IHNlcmllc01vZGVsLmdldEdyYXBoKCk7XG4gICAgdmFyIG5vZGVzID0gZ3JhcGgubm9kZXM7XG5cbiAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgbWluVmFsdWVfMSA9IEluZmluaXR5O1xuICAgICAgdmFyIG1heFZhbHVlXzEgPSAtSW5maW5pdHk7XG4gICAgICB6clV0aWwuZWFjaChub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIG5vZGVWYWx1ZSA9IG5vZGUuZ2V0TGF5b3V0KCkudmFsdWU7XG5cbiAgICAgICAgaWYgKG5vZGVWYWx1ZSA8IG1pblZhbHVlXzEpIHtcbiAgICAgICAgICBtaW5WYWx1ZV8xID0gbm9kZVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGVWYWx1ZSA+IG1heFZhbHVlXzEpIHtcbiAgICAgICAgICBtYXhWYWx1ZV8xID0gbm9kZVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHpyVXRpbC5lYWNoKG5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IG5ldyBWaXN1YWxNYXBwaW5nKHtcbiAgICAgICAgICB0eXBlOiAnY29sb3InLFxuICAgICAgICAgIG1hcHBpbmdNZXRob2Q6ICdsaW5lYXInLFxuICAgICAgICAgIGRhdGFFeHRlbnQ6IFttaW5WYWx1ZV8xLCBtYXhWYWx1ZV8xXSxcbiAgICAgICAgICB2aXN1YWw6IHNlcmllc01vZGVsLmdldCgnY29sb3InKVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1hcFZhbHVlVG9Db2xvciA9IG1hcHBpbmcubWFwVmFsdWVUb1Zpc3VhbChub2RlLmdldExheW91dCgpLnZhbHVlKTtcbiAgICAgICAgdmFyIGN1c3RvbUNvbG9yID0gbm9kZS5nZXRNb2RlbCgpLmdldChbJ2l0ZW1TdHlsZScsICdjb2xvciddKTtcblxuICAgICAgICBpZiAoY3VzdG9tQ29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuc2V0VmlzdWFsKCdjb2xvcicsIGN1c3RvbUNvbG9yKTtcbiAgICAgICAgICBub2RlLnNldFZpc3VhbCgnc3R5bGUnLCB7XG4gICAgICAgICAgICBmaWxsOiBjdXN0b21Db2xvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0VmlzdWFsKCdjb2xvcicsIG1hcFZhbHVlVG9Db2xvcik7XG4gICAgICAgICAgbm9kZS5zZXRWaXN1YWwoJ3N0eWxlJywge1xuICAgICAgICAgICAgZmlsbDogbWFwVmFsdWVUb0NvbG9yXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IGNyZWF0ZUxpc3RGcm9tQXJyYXkgZnJvbSAnLi4vaGVscGVyL2NyZWF0ZUxpc3RGcm9tQXJyYXknO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcyc7XG5cbnZhciBTY2F0dGVyU2VyaWVzTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2NhdHRlclNlcmllc01vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFNjYXR0ZXJTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBTY2F0dGVyU2VyaWVzTW9kZWwudHlwZTtcbiAgICBfdGhpcy5oYXNTeW1ib2xWaXN1YWwgPSB0cnVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFNjYXR0ZXJTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0SW5pdGlhbERhdGEgPSBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxpc3RGcm9tQXJyYXkodGhpcy5nZXRTb3VyY2UoKSwgdGhpcywge1xuICAgICAgdXNlRW5jb2RlRGVmYXVsdGVyOiB0cnVlXG4gICAgfSk7XG4gIH07XG5cbiAgU2NhdHRlclNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRQcm9ncmVzc2l2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvZ3Jlc3NpdmUgPSB0aGlzLm9wdGlvbi5wcm9ncmVzc2l2ZTtcblxuICAgIGlmIChwcm9ncmVzc2l2ZSA9PSBudWxsKSB7XG4gICAgICAvLyBQRU5ESU5HXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb24ubGFyZ2UgPyA1ZTMgOiB0aGlzLmdldCgncHJvZ3Jlc3NpdmUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3Jlc3NpdmU7XG4gIH07XG5cbiAgU2NhdHRlclNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRQcm9ncmVzc2l2ZVRocmVzaG9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvZ3Jlc3NpdmVUaHJlc2hvbGQgPSB0aGlzLm9wdGlvbi5wcm9ncmVzc2l2ZVRocmVzaG9sZDtcblxuICAgIGlmIChwcm9ncmVzc2l2ZVRocmVzaG9sZCA9PSBudWxsKSB7XG4gICAgICAvLyBQRU5ESU5HXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb24ubGFyZ2UgPyAxZTQgOiB0aGlzLmdldCgncHJvZ3Jlc3NpdmVUaHJlc2hvbGQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3Jlc3NpdmVUaHJlc2hvbGQ7XG4gIH07XG5cbiAgU2NhdHRlclNlcmllc01vZGVsLnByb3RvdHlwZS5icnVzaFNlbGVjdG9yID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgZGF0YSwgc2VsZWN0b3JzKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9ycy5wb2ludChkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KSk7XG4gIH07XG5cbiAgU2NhdHRlclNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLnNjYXR0ZXInO1xuICBTY2F0dGVyU2VyaWVzTW9kZWwuZGVwZW5kZW5jaWVzID0gWydncmlkJywgJ3BvbGFyJywgJ2dlbycsICdzaW5nbGVBeGlzJywgJ2NhbGVuZGFyJ107XG4gIFNjYXR0ZXJTZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdjYXJ0ZXNpYW4yZCcsXG4gICAgemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIHN5bWJvbFNpemU6IDEwLFxuICAgIC8vIHN5bWJvbFJvdGF0ZTogbnVsbCwgIC8vIOWbvuW9ouaXi+i9rOaOp+WItlxuICAgIGxhcmdlOiBmYWxzZSxcbiAgICAvLyBBdmFpbGFibGUgd2hlbiBsYXJnZSBpcyB0cnVlXG4gICAgbGFyZ2VUaHJlc2hvbGQ6IDIwMDAsXG4gICAgLy8gY3Vyc29yOiBudWxsLFxuICAgIGl0ZW1TdHlsZToge1xuICAgICAgb3BhY2l0eTogMC44IC8vIGNvbG9yOiDlkITlvIJcblxuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIHNjYWxlOiB0cnVlXG4gICAgfSxcbiAgICAvLyBJZiBjbGlwIHRoZSBvdmVyZmxvdyBncmFwaGljc1xuICAgIC8vIFdvcmtzIG9uIGNhcnRlc2lhbiAvIHBvbGFyIHNlcmllc1xuICAgIGNsaXA6IHRydWUsXG4gICAgc2VsZWN0OiB7XG4gICAgICBpdGVtU3R5bGU6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMjEyMTIxJ1xuICAgICAgfVxuICAgIH0gLy8gcHJvZ3Jlc3NpdmU6IG51bGxcblxuICB9O1xuICByZXR1cm4gU2NhdHRlclNlcmllc01vZGVsO1xufShTZXJpZXNNb2RlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IFNjYXR0ZXJTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgU3ltYm9sRHJhdyBmcm9tICcuLi9oZWxwZXIvU3ltYm9sRHJhdyc7XG5pbXBvcnQgTGFyZ2VTeW1ib2xEcmF3IGZyb20gJy4uL2hlbHBlci9MYXJnZVN5bWJvbERyYXcnO1xuaW1wb3J0IHBvaW50c0xheW91dCBmcm9tICcuLi8uLi9sYXlvdXQvcG9pbnRzJztcbmltcG9ydCBDaGFydFZpZXcgZnJvbSAnLi4vLi4vdmlldy9DaGFydCc7XG5cbnZhciBTY2F0dGVyVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTY2F0dGVyVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTY2F0dGVyVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBTY2F0dGVyVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFNjYXR0ZXJWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgdmFyIHN5bWJvbERyYXcgPSB0aGlzLl91cGRhdGVTeW1ib2xEcmF3KGRhdGEsIHNlcmllc01vZGVsKTtcblxuICAgIHN5bWJvbERyYXcudXBkYXRlRGF0YShkYXRhLCB7XG4gICAgICAvLyBUT0RPXG4gICAgICAvLyBJZiB0aGlzIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzaGFwZSBvciBhIGJvdW5kaW5nIHZvbHVtZVxuICAgICAgLy8gc2hhcGUgd2lsbCBiZSBtb3JlIGdlbmVyYWwuXG4gICAgICAvLyBCdXQgYm91bmRpbmcgdm9sdW1lIGxpa2UgYm91bmRpbmcgcmVjdCB3aWxsIGJlIG11Y2ggZmFzdGVyIGluIHRoZSBjb250YWluIGNhbGN1bGF0aW9uXG4gICAgICBjbGlwU2hhcGU6IHRoaXMuX2dldENsaXBTaGFwZShzZXJpZXNNb2RlbClcbiAgICB9KTtcbiAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XG4gIH07XG5cbiAgU2NhdHRlclZpZXcucHJvdG90eXBlLmluY3JlbWVudGFsUHJlcGFyZVJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG5cbiAgICB2YXIgc3ltYm9sRHJhdyA9IHRoaXMuX3VwZGF0ZVN5bWJvbERyYXcoZGF0YSwgc2VyaWVzTW9kZWwpO1xuXG4gICAgc3ltYm9sRHJhdy5pbmNyZW1lbnRhbFByZXBhcmVVcGRhdGUoZGF0YSk7XG4gICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgfTtcblxuICBTY2F0dGVyVmlldy5wcm90b3R5cGUuaW5jcmVtZW50YWxSZW5kZXIgPSBmdW5jdGlvbiAodGFza1BhcmFtcywgc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICB0aGlzLl9zeW1ib2xEcmF3LmluY3JlbWVudGFsVXBkYXRlKHRhc2tQYXJhbXMsIHNlcmllc01vZGVsLmdldERhdGEoKSwge1xuICAgICAgY2xpcFNoYXBlOiB0aGlzLl9nZXRDbGlwU2hhcGUoc2VyaWVzTW9kZWwpXG4gICAgfSk7XG5cbiAgICB0aGlzLl9maW5pc2hlZCA9IHRhc2tQYXJhbXMuZW5kID09PSBzZXJpZXNNb2RlbC5nZXREYXRhKCkuY291bnQoKTtcbiAgfTtcblxuICBTY2F0dGVyVmlldy5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTsgLy8gTXVzdCBtYXJrIGdyb3VwIGRpcnR5IGFuZCBtYWtlIHN1cmUgdGhlIGluY3JlbWVudGFsIGxheWVyIHdpbGwgYmUgY2xlYXJlZFxuICAgIC8vIFBFTkRJTkdcblxuICAgIHRoaXMuZ3JvdXAuZGlydHkoKTtcblxuICAgIGlmICghdGhpcy5fZmluaXNoZWQgfHwgZGF0YS5jb3VudCgpID4gMWU0IHx8ICF0aGlzLl9zeW1ib2xEcmF3LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGU6IHRydWVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXMgPSBwb2ludHNMYXlvdXQoJycpLnJlc2V0KHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpO1xuXG4gICAgICBpZiAocmVzLnByb2dyZXNzKSB7XG4gICAgICAgIHJlcy5wcm9ncmVzcyh7XG4gICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgZW5kOiBkYXRhLmNvdW50KCksXG4gICAgICAgICAgY291bnQ6IGRhdGEuY291bnQoKVxuICAgICAgICB9LCBkYXRhKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3ltYm9sRHJhdy51cGRhdGVMYXlvdXQoZGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIFNjYXR0ZXJWaWV3LnByb3RvdHlwZS5fZ2V0Q2xpcFNoYXBlID0gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgY2xpcEFyZWEgPSBjb29yZFN5cyAmJiBjb29yZFN5cy5nZXRBcmVhICYmIGNvb3JkU3lzLmdldEFyZWEoKTtcbiAgICByZXR1cm4gc2VyaWVzTW9kZWwuZ2V0KCdjbGlwJywgdHJ1ZSkgPyBjbGlwQXJlYSA6IG51bGw7XG4gIH07XG5cbiAgU2NhdHRlclZpZXcucHJvdG90eXBlLl91cGRhdGVTeW1ib2xEcmF3ID0gZnVuY3Rpb24gKGRhdGEsIHNlcmllc01vZGVsKSB7XG4gICAgdmFyIHN5bWJvbERyYXcgPSB0aGlzLl9zeW1ib2xEcmF3O1xuICAgIHZhciBwaXBlbGluZUNvbnRleHQgPSBzZXJpZXNNb2RlbC5waXBlbGluZUNvbnRleHQ7XG4gICAgdmFyIGlzTGFyZ2VEcmF3ID0gcGlwZWxpbmVDb250ZXh0LmxhcmdlO1xuXG4gICAgaWYgKCFzeW1ib2xEcmF3IHx8IGlzTGFyZ2VEcmF3ICE9PSB0aGlzLl9pc0xhcmdlRHJhdykge1xuICAgICAgc3ltYm9sRHJhdyAmJiBzeW1ib2xEcmF3LnJlbW92ZSgpO1xuICAgICAgc3ltYm9sRHJhdyA9IHRoaXMuX3N5bWJvbERyYXcgPSBpc0xhcmdlRHJhdyA/IG5ldyBMYXJnZVN5bWJvbERyYXcoKSA6IG5ldyBTeW1ib2xEcmF3KCk7XG4gICAgICB0aGlzLl9pc0xhcmdlRHJhdyA9IGlzTGFyZ2VEcmF3O1xuICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICB9XG5cbiAgICB0aGlzLmdyb3VwLmFkZChzeW1ib2xEcmF3Lmdyb3VwKTtcbiAgICByZXR1cm4gc3ltYm9sRHJhdztcbiAgfTtcblxuICBTY2F0dGVyVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuX3N5bWJvbERyYXcgJiYgdGhpcy5fc3ltYm9sRHJhdy5yZW1vdmUodHJ1ZSk7XG4gICAgdGhpcy5fc3ltYm9sRHJhdyA9IG51bGw7XG4gIH07XG5cbiAgU2NhdHRlclZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBTY2F0dGVyVmlldy50eXBlID0gJ3NjYXR0ZXInO1xuICByZXR1cm4gU2NhdHRlclZpZXc7XG59KENoYXJ0Vmlldyk7XG5cbmV4cG9ydCBkZWZhdWx0IFNjYXR0ZXJWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyB1c2UgfSBmcm9tICcuLi8uLi9leHRlbnNpb24nO1xuaW1wb3J0IFNjYXR0ZXJTZXJpZXNNb2RlbCBmcm9tICcuL1NjYXR0ZXJTZXJpZXMnO1xuaW1wb3J0IFNjYXR0ZXJWaWV3IGZyb20gJy4vU2NhdHRlclZpZXcnO1xuaW1wb3J0IHsgaW5zdGFsbCBhcyBpbnN0YWxsR3JpZFNpbXBsZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudC9ncmlkL2luc3RhbGxTaW1wbGUnO1xuaW1wb3J0IGxheW91dFBvaW50cyBmcm9tICcuLi8uLi9sYXlvdXQvcG9pbnRzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICAvLyBJbiBjYXNlIGRldmVsb3BlciBmb3JnZXQgdG8gaW5jbHVkZSBncmlkIGNvbXBvbmVudFxuICB1c2UoaW5zdGFsbEdyaWRTaW1wbGUpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChTY2F0dGVyU2VyaWVzTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDaGFydFZpZXcoU2NhdHRlclZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQobGF5b3V0UG9pbnRzKCdzY2F0dGVyJykpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IHsgZW5hYmxlSG92ZXJFbXBoYXNpcywgU1BFQ0lBTF9TVEFURVMsIERJU1BMQVlfU1RBVEVTIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMnO1xuaW1wb3J0IHsgY3JlYXRlVGV4dFN0eWxlIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZSc7XG5pbXBvcnQgeyBnZXRFQ0RhdGEgfSBmcm9tICcuLi8uLi91dGlsL2lubmVyU3RvcmUnO1xuaW1wb3J0IHsgZ2V0U2VjdG9yQ29ybmVyUmFkaXVzIH0gZnJvbSAnLi4vaGVscGVyL3BpZUhlbHBlcic7XG5pbXBvcnQgeyBjcmVhdGVPclVwZGF0ZVBhdHRlcm5Gcm9tRGVjYWwgfSBmcm9tICcuLi8uLi91dGlsL2RlY2FsJztcbnZhciBERUZBVUxUX1NFQ1RPUl9aID0gMjtcbnZhciBERUZBVUxUX1RFWFRfWiA9IDQ7XG4vKipcbiAqIFN1bmJ1cnN0Y2Ugb2YgU3VuYnVyc3QgaW5jbHVkaW5nIFNlY3RvciwgTGFiZWwsIExhYmVsTGluZVxuICovXG5cbnZhciBTdW5idXJzdFBpZWNlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFN1bmJ1cnN0UGllY2UsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU3VuYnVyc3RQaWVjZShub2RlLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF90aGlzLnoyID0gREVGQVVMVF9TRUNUT1JfWjtcbiAgICBfdGhpcy50ZXh0Q29uZmlnID0ge1xuICAgICAgaW5zaWRlOiB0cnVlXG4gICAgfTtcbiAgICBnZXRFQ0RhdGEoX3RoaXMpLnNlcmllc0luZGV4ID0gc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXg7XG4gICAgdmFyIHRleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIHoyOiBERUZBVUxUX1RFWFRfWixcbiAgICAgIHNpbGVudDogbm9kZS5nZXRNb2RlbCgpLmdldChbJ2xhYmVsJywgJ3NpbGVudCddKVxuICAgIH0pO1xuXG4gICAgX3RoaXMuc2V0VGV4dENvbnRlbnQodGV4dCk7XG5cbiAgICBfdGhpcy51cGRhdGVEYXRhKHRydWUsIG5vZGUsIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU3VuYnVyc3RQaWVjZS5wcm90b3R5cGUudXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChmaXJzdENyZWF0ZSwgbm9kZSwgLy8gc3RhdGU6ICdlbXBoYXNpcycgfCAnbm9ybWFsJyB8ICdoaWdobGlnaHQnIHwgJ2Rvd25wbGF5JyxcbiAgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgbm9kZS5waWVjZSA9IHRoaXM7XG4gICAgc2VyaWVzTW9kZWwgPSBzZXJpZXNNb2RlbCB8fCB0aGlzLl9zZXJpZXNNb2RlbDtcbiAgICBlY01vZGVsID0gZWNNb2RlbCB8fCB0aGlzLl9lY01vZGVsO1xuICAgIHZhciBzZWN0b3IgPSB0aGlzO1xuICAgIGdldEVDRGF0YShzZWN0b3IpLmRhdGFJbmRleCA9IG5vZGUuZGF0YUluZGV4O1xuICAgIHZhciBpdGVtTW9kZWwgPSBub2RlLmdldE1vZGVsKCk7XG4gICAgdmFyIGVtcGhhc2lzTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJyk7XG4gICAgdmFyIGxheW91dCA9IG5vZGUuZ2V0TGF5b3V0KCk7XG4gICAgdmFyIHNlY3RvclNoYXBlID0genJVdGlsLmV4dGVuZCh7fSwgbGF5b3V0KTtcbiAgICBzZWN0b3JTaGFwZS5sYWJlbCA9IG51bGw7XG4gICAgdmFyIG5vcm1hbFN0eWxlID0gbm9kZS5nZXRWaXN1YWwoJ3N0eWxlJyk7XG4gICAgbm9ybWFsU3R5bGUubGluZUpvaW4gPSAnYmV2ZWwnO1xuICAgIHZhciBkZWNhbCA9IG5vZGUuZ2V0VmlzdWFsKCdkZWNhbCcpO1xuXG4gICAgaWYgKGRlY2FsKSB7XG4gICAgICBub3JtYWxTdHlsZS5kZWNhbCA9IGNyZWF0ZU9yVXBkYXRlUGF0dGVybkZyb21EZWNhbChkZWNhbCwgYXBpKTtcbiAgICB9XG5cbiAgICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0U2VjdG9yQ29ybmVyUmFkaXVzKGl0ZW1Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJyksIHNlY3RvclNoYXBlKTtcbiAgICB6clV0aWwuZXh0ZW5kKHNlY3RvclNoYXBlLCBjb3JuZXJSYWRpdXMpO1xuICAgIHpyVXRpbC5lYWNoKFNQRUNJQUxfU1RBVEVTLCBmdW5jdGlvbiAoc3RhdGVOYW1lKSB7XG4gICAgICB2YXIgc3RhdGUgPSBzZWN0b3IuZW5zdXJlU3RhdGUoc3RhdGVOYW1lKTtcbiAgICAgIHZhciBpdGVtU3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChbc3RhdGVOYW1lLCAnaXRlbVN0eWxlJ10pO1xuICAgICAgc3RhdGUuc3R5bGUgPSBpdGVtU3R5bGVNb2RlbC5nZXRJdGVtU3R5bGUoKTsgLy8gYm9yZGVyIHJhZGl1c1xuXG4gICAgICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0U2VjdG9yQ29ybmVyUmFkaXVzKGl0ZW1TdHlsZU1vZGVsLCBzZWN0b3JTaGFwZSk7XG5cbiAgICAgIGlmIChjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgc3RhdGUuc2hhcGUgPSBjb3JuZXJSYWRpdXM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoZmlyc3RDcmVhdGUpIHtcbiAgICAgIHNlY3Rvci5zZXRTaGFwZShzZWN0b3JTaGFwZSk7XG4gICAgICBzZWN0b3Iuc2hhcGUuciA9IGxheW91dC5yMDtcbiAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoc2VjdG9yLCB7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgcjogbGF5b3V0LnJcbiAgICAgICAgfVxuICAgICAgfSwgc2VyaWVzTW9kZWwsIG5vZGUuZGF0YUluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGlzYWJsZSBhbmltYXRpb24gZm9yIGdyYWRpZW50IHNpbmNlIG5vIGludGVycG9sYXRpb24gbWV0aG9kXG4gICAgICAvLyBpcyBzdXBwb3J0ZWQgZm9yIGdyYWRpZW50XG4gICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHNlY3Rvciwge1xuICAgICAgICBzaGFwZTogc2VjdG9yU2hhcGVcbiAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICB9XG5cbiAgICBzZWN0b3IudXNlU3R5bGUobm9ybWFsU3R5bGUpO1xuXG4gICAgdGhpcy5fdXBkYXRlTGFiZWwoc2VyaWVzTW9kZWwpO1xuXG4gICAgdmFyIGN1cnNvclN0eWxlID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ2N1cnNvcicpO1xuICAgIGN1cnNvclN0eWxlICYmIHNlY3Rvci5hdHRyKCdjdXJzb3InLCBjdXJzb3JTdHlsZSk7XG4gICAgdGhpcy5fc2VyaWVzTW9kZWwgPSBzZXJpZXNNb2RlbCB8fCB0aGlzLl9zZXJpZXNNb2RlbDtcbiAgICB0aGlzLl9lY01vZGVsID0gZWNNb2RlbCB8fCB0aGlzLl9lY01vZGVsO1xuICAgIHZhciBmb2N1cyA9IGVtcGhhc2lzTW9kZWwuZ2V0KCdmb2N1cycpO1xuICAgIHZhciBmb2N1c0RhdGFJbmRpY2VzID0gZm9jdXMgPT09ICdhbmNlc3RvcicgPyBub2RlLmdldEFuY2VzdG9yc0luZGljZXMoKSA6IGZvY3VzID09PSAnZGVzY2VuZGFudCcgPyBub2RlLmdldERlc2NlbmRhbnRJbmRpY2VzKCkgOiBudWxsO1xuICAgIGVuYWJsZUhvdmVyRW1waGFzaXModGhpcywgZm9jdXNEYXRhSW5kaWNlcyB8fCBmb2N1cywgZW1waGFzaXNNb2RlbC5nZXQoJ2JsdXJTY29wZScpKTtcbiAgfTtcblxuICBTdW5idXJzdFBpZWNlLnByb3RvdHlwZS5fdXBkYXRlTGFiZWwgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGl0ZW1Nb2RlbCA9IHRoaXMubm9kZS5nZXRNb2RlbCgpO1xuICAgIHZhciBub3JtYWxMYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbCcpO1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLm5vZGUuZ2V0TGF5b3V0KCk7XG4gICAgdmFyIGFuZ2xlID0gbGF5b3V0LmVuZEFuZ2xlIC0gbGF5b3V0LnN0YXJ0QW5nbGU7XG4gICAgdmFyIG1pZEFuZ2xlID0gKGxheW91dC5zdGFydEFuZ2xlICsgbGF5b3V0LmVuZEFuZ2xlKSAvIDI7XG4gICAgdmFyIGR4ID0gTWF0aC5jb3MobWlkQW5nbGUpO1xuICAgIHZhciBkeSA9IE1hdGguc2luKG1pZEFuZ2xlKTtcbiAgICB2YXIgc2VjdG9yID0gdGhpcztcbiAgICB2YXIgbGFiZWwgPSBzZWN0b3IuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICB2YXIgZGF0YUluZGV4ID0gdGhpcy5ub2RlLmRhdGFJbmRleDtcbiAgICB2YXIgbGFiZWxNaW5BbmdsZSA9IG5vcm1hbExhYmVsTW9kZWwuZ2V0KCdtaW5BbmdsZScpIC8gMTgwICogTWF0aC5QSTtcbiAgICB2YXIgaXNOb3JtYWxTaG93biA9IG5vcm1hbExhYmVsTW9kZWwuZ2V0KCdzaG93JykgJiYgIShsYWJlbE1pbkFuZ2xlICE9IG51bGwgJiYgTWF0aC5hYnMoYW5nbGUpIDwgbGFiZWxNaW5BbmdsZSk7XG4gICAgbGFiZWwuaWdub3JlID0gIWlzTm9ybWFsU2hvd247IC8vIFRPRE8gdXNlIHNldExhYmVsU3R5bGVcblxuICAgIHpyVXRpbC5lYWNoKERJU1BMQVlfU1RBVEVTLCBmdW5jdGlvbiAoc3RhdGVOYW1lKSB7XG4gICAgICB2YXIgbGFiZWxTdGF0ZU1vZGVsID0gc3RhdGVOYW1lID09PSAnbm9ybWFsJyA/IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwnKSA6IGl0ZW1Nb2RlbC5nZXRNb2RlbChbc3RhdGVOYW1lLCAnbGFiZWwnXSk7XG4gICAgICB2YXIgaXNOb3JtYWwgPSBzdGF0ZU5hbWUgPT09ICdub3JtYWwnO1xuICAgICAgdmFyIHN0YXRlID0gaXNOb3JtYWwgPyBsYWJlbCA6IGxhYmVsLmVuc3VyZVN0YXRlKHN0YXRlTmFtZSk7XG4gICAgICB2YXIgdGV4dCA9IHNlcmllc01vZGVsLmdldEZvcm1hdHRlZExhYmVsKGRhdGFJbmRleCwgc3RhdGVOYW1lKTtcblxuICAgICAgaWYgKGlzTm9ybWFsKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0IHx8IF90aGlzLm5vZGUubmFtZTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUuc3R5bGUgPSBjcmVhdGVUZXh0U3R5bGUobGFiZWxTdGF0ZU1vZGVsLCB7fSwgbnVsbCwgc3RhdGVOYW1lICE9PSAnbm9ybWFsJywgdHJ1ZSk7XG5cbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHN0YXRlLnN0eWxlLnRleHQgPSB0ZXh0O1xuICAgICAgfSAvLyBOb3QgZGlzcGxheWluZyB0ZXh0IHdoZW4gYW5nbGUgaXMgdG9vIHNtYWxsXG5cblxuICAgICAgdmFyIGlzU2hvd24gPSBsYWJlbFN0YXRlTW9kZWwuZ2V0KCdzaG93Jyk7XG5cbiAgICAgIGlmIChpc1Nob3duICE9IG51bGwgJiYgIWlzTm9ybWFsKSB7XG4gICAgICAgIHN0YXRlLmlnbm9yZSA9ICFpc1Nob3duO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGdldExhYmVsQXR0cihsYWJlbFN0YXRlTW9kZWwsICdwb3NpdGlvbicpO1xuICAgICAgdmFyIHNlY3RvclN0YXRlID0gaXNOb3JtYWwgPyBzZWN0b3IgOiBzZWN0b3Iuc3RhdGVzW3N0YXRlTmFtZV07XG4gICAgICB2YXIgbGFiZWxDb2xvciA9IHNlY3RvclN0YXRlLnN0eWxlLmZpbGw7XG4gICAgICBzZWN0b3JTdGF0ZS50ZXh0Q29uZmlnID0ge1xuICAgICAgICBvdXRzaWRlRmlsbDogbGFiZWxTdGF0ZU1vZGVsLmdldCgnY29sb3InKSA9PT0gJ2luaGVyaXQnID8gbGFiZWxDb2xvciA6IG51bGwsXG4gICAgICAgIGluc2lkZTogbGFiZWxQb3NpdGlvbiAhPT0gJ291dHNpZGUnXG4gICAgICB9O1xuICAgICAgdmFyIHI7XG4gICAgICB2YXIgbGFiZWxQYWRkaW5nID0gZ2V0TGFiZWxBdHRyKGxhYmVsU3RhdGVNb2RlbCwgJ2Rpc3RhbmNlJykgfHwgMDtcbiAgICAgIHZhciB0ZXh0QWxpZ24gPSBnZXRMYWJlbEF0dHIobGFiZWxTdGF0ZU1vZGVsLCAnYWxpZ24nKTtcblxuICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT09ICdvdXRzaWRlJykge1xuICAgICAgICByID0gbGF5b3V0LnIgKyBsYWJlbFBhZGRpbmc7XG4gICAgICAgIHRleHRBbGlnbiA9IG1pZEFuZ2xlID4gTWF0aC5QSSAvIDIgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0ZXh0QWxpZ24gfHwgdGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHIgPSAobGF5b3V0LnIgKyBsYXlvdXQucjApIC8gMjtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHIgPSBsYXlvdXQucjAgKyBsYWJlbFBhZGRpbmc7XG5cbiAgICAgICAgICBpZiAobWlkQW5nbGUgPiBNYXRoLlBJIC8gMikge1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgciA9IGxheW91dC5yIC0gbGFiZWxQYWRkaW5nO1xuXG4gICAgICAgICAgaWYgKG1pZEFuZ2xlID4gTWF0aC5QSSAvIDIpIHtcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhdGUuc3R5bGUuYWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICBzdGF0ZS5zdHlsZS52ZXJ0aWNhbEFsaWduID0gZ2V0TGFiZWxBdHRyKGxhYmVsU3RhdGVNb2RlbCwgJ3ZlcnRpY2FsQWxpZ24nKSB8fCAnbWlkZGxlJztcbiAgICAgIHN0YXRlLnggPSByICogZHggKyBsYXlvdXQuY3g7XG4gICAgICBzdGF0ZS55ID0gciAqIGR5ICsgbGF5b3V0LmN5O1xuICAgICAgdmFyIHJvdGF0ZVR5cGUgPSBnZXRMYWJlbEF0dHIobGFiZWxTdGF0ZU1vZGVsLCAncm90YXRlJyk7XG4gICAgICB2YXIgcm90YXRlID0gMDtcblxuICAgICAgaWYgKHJvdGF0ZVR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIHJvdGF0ZSA9IC1taWRBbmdsZTtcblxuICAgICAgICBpZiAocm90YXRlIDwgLU1hdGguUEkgLyAyKSB7XG4gICAgICAgICAgcm90YXRlICs9IE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocm90YXRlVHlwZSA9PT0gJ3RhbmdlbnRpYWwnKSB7XG4gICAgICAgIHJvdGF0ZSA9IE1hdGguUEkgLyAyIC0gbWlkQW5nbGU7XG5cbiAgICAgICAgaWYgKHJvdGF0ZSA+IE1hdGguUEkgLyAyKSB7XG4gICAgICAgICAgcm90YXRlIC09IE1hdGguUEk7XG4gICAgICAgIH0gZWxzZSBpZiAocm90YXRlIDwgLU1hdGguUEkgLyAyKSB7XG4gICAgICAgICAgcm90YXRlICs9IE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJvdGF0ZVR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJvdGF0ZSA9IHJvdGF0ZVR5cGUgKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5yb3RhdGlvbiA9IHJvdGF0ZTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdldExhYmVsQXR0cihtb2RlbCwgbmFtZSkge1xuICAgICAgdmFyIHN0YXRlQXR0ciA9IG1vZGVsLmdldChuYW1lKTtcblxuICAgICAgaWYgKHN0YXRlQXR0ciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxMYWJlbE1vZGVsLmdldChuYW1lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXRlQXR0cjtcbiAgICB9XG5cbiAgICBsYWJlbC5kaXJ0eVN0eWxlKCk7XG4gIH07XG5cbiAgcmV0dXJuIFN1bmJ1cnN0UGllY2U7XG59KGdyYXBoaWMuU2VjdG9yKTtcblxuZXhwb3J0IGRlZmF1bHQgU3VuYnVyc3RQaWVjZTsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9TZXJpZXMnO1xuaW1wb3J0IFRyZWUgZnJvbSAnLi4vLi4vZGF0YS9UcmVlJztcbmltcG9ydCB7IHdyYXBUcmVlUGF0aEluZm8gfSBmcm9tICcuLi9oZWxwZXIvdHJlZUhlbHBlcic7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvTW9kZWwnO1xuaW1wb3J0IGVuYWJsZUFyaWFEZWNhbEZvclRyZWUgZnJvbSAnLi4vaGVscGVyL2VuYWJsZUFyaWFEZWNhbEZvclRyZWUnO1xuXG52YXIgU3VuYnVyc3RTZXJpZXNNb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTdW5idXJzdFNlcmllc01vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFN1bmJ1cnN0U2VyaWVzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gU3VuYnVyc3RTZXJpZXNNb2RlbC50eXBlO1xuICAgIF90aGlzLmlnbm9yZVN0eWxlT25EYXRhID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBTdW5idXJzdFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YSA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICAvLyBDcmVhdGUgYSB2aXJ0dWFsIHJvb3QuXG4gICAgdmFyIHJvb3QgPSB7XG4gICAgICBuYW1lOiBvcHRpb24ubmFtZSxcbiAgICAgIGNoaWxkcmVuOiBvcHRpb24uZGF0YVxuICAgIH07XG4gICAgY29tcGxldGVUcmVlVmFsdWUocm9vdCk7XG4gICAgdmFyIGxldmVsTW9kZWxzID0genJVdGlsLm1hcChvcHRpb24ubGV2ZWxzIHx8IFtdLCBmdW5jdGlvbiAobGV2ZWxEZWZpbmUpIHtcbiAgICAgIHJldHVybiBuZXcgTW9kZWwobGV2ZWxEZWZpbmUsIHRoaXMsIGVjTW9kZWwpO1xuICAgIH0sIHRoaXMpOyAvLyBNYWtlIHN1cmUgYWx3YXlzIGEgbmV3IHRyZWUgaXMgY3JlYXRlZCB3aGVuIHNldE9wdGlvbixcbiAgICAvLyBpbiBUcmVlbWFwVmlldywgd2UgY2hlY2sgd2hldGhlciBvbGRUcmVlID09PSBuZXdUcmVlXG4gICAgLy8gdG8gY2hvb3NlIG1hcHBpbmdzIGFwcHJvYWNoIGFtb25nIG9sZCBzaGFwZXMgYW5kIG5ldyBzaGFwZXMuXG5cbiAgICB2YXIgdHJlZSA9IFRyZWUuY3JlYXRlVHJlZShyb290LCB0aGlzLCBiZWZvcmVMaW5rKTtcblxuICAgIGZ1bmN0aW9uIGJlZm9yZUxpbmsobm9kZURhdGEpIHtcbiAgICAgIG5vZGVEYXRhLndyYXBNZXRob2QoJ2dldEl0ZW1Nb2RlbCcsIGZ1bmN0aW9uIChtb2RlbCwgaWR4KSB7XG4gICAgICAgIHZhciBub2RlID0gdHJlZS5nZXROb2RlQnlEYXRhSW5kZXgoaWR4KTtcbiAgICAgICAgdmFyIGxldmVsTW9kZWwgPSBsZXZlbE1vZGVsc1tub2RlLmRlcHRoXTtcbiAgICAgICAgbGV2ZWxNb2RlbCAmJiAobW9kZWwucGFyZW50TW9kZWwgPSBsZXZlbE1vZGVsKTtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyZWUuZGF0YTtcbiAgfTtcblxuICBTdW5idXJzdFNlcmllc01vZGVsLnByb3RvdHlwZS5vcHRpb25VcGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzZXRWaWV3Um9vdCgpO1xuICB9O1xuICAvKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBTdW5idXJzdFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXREYXRhUGFyYW1zID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgIHZhciBwYXJhbXMgPSBfc3VwZXIucHJvdG90eXBlLmdldERhdGFQYXJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHZhciBub2RlID0gdGhpcy5nZXREYXRhKCkudHJlZS5nZXROb2RlQnlEYXRhSW5kZXgoZGF0YUluZGV4KTtcbiAgICBwYXJhbXMudHJlZVBhdGhJbmZvID0gd3JhcFRyZWVQYXRoSW5mbyhub2RlLCB0aGlzKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9O1xuXG4gIFN1bmJ1cnN0U2VyaWVzTW9kZWwucHJvdG90eXBlLmdldFZpZXdSb290ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3Um9vdDtcbiAgfTtcblxuICBTdW5idXJzdFNlcmllc01vZGVsLnByb3RvdHlwZS5yZXNldFZpZXdSb290ID0gZnVuY3Rpb24gKHZpZXdSb290KSB7XG4gICAgdmlld1Jvb3QgPyB0aGlzLl92aWV3Um9vdCA9IHZpZXdSb290IDogdmlld1Jvb3QgPSB0aGlzLl92aWV3Um9vdDtcbiAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0UmF3RGF0YSgpLnRyZWUucm9vdDtcblxuICAgIGlmICghdmlld1Jvb3QgfHwgdmlld1Jvb3QgIT09IHJvb3QgJiYgIXJvb3QuY29udGFpbnModmlld1Jvb3QpKSB7XG4gICAgICB0aGlzLl92aWV3Um9vdCA9IHJvb3Q7XG4gICAgfVxuICB9O1xuXG4gIFN1bmJ1cnN0U2VyaWVzTW9kZWwucHJvdG90eXBlLmVuYWJsZUFyaWFEZWNhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbmFibGVBcmlhRGVjYWxGb3JUcmVlKHRoaXMpO1xuICB9O1xuXG4gIFN1bmJ1cnN0U2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMuc3VuYnVyc3QnO1xuICBTdW5idXJzdFNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgLy8g6buY6K6k5YWo5bGA5bGF5LitXG4gICAgY2VudGVyOiBbJzUwJScsICc1MCUnXSxcbiAgICByYWRpdXM6IFswLCAnNzUlJ10sXG4gICAgLy8g6buY6K6k6aG65pe26ZKIXG4gICAgY2xvY2t3aXNlOiB0cnVlLFxuICAgIHN0YXJ0QW5nbGU6IDkwLFxuICAgIC8vIOacgOWwj+inkuW6puaUueS4ujBcbiAgICBtaW5BbmdsZTogMCxcbiAgICAvLyBJZiBzdGlsbCBzaG93IHdoZW4gYWxsIGRhdGEgemVyby5cbiAgICBzdGlsbFNob3daZXJvU3VtOiB0cnVlLFxuICAgIC8vICdyb290VG9Ob2RlJywgJ2xpbmsnLCBvciBmYWxzZVxuICAgIG5vZGVDbGljazogJ3Jvb3RUb05vZGUnLFxuICAgIHJlbmRlckxhYmVsRm9yWmVyb0RhdGE6IGZhbHNlLFxuICAgIGxhYmVsOiB7XG4gICAgICAvLyBjb3VsZCBiZTogJ3JhZGlhbCcsICd0YW5nZW50aWFsJywgb3IgJ25vbmUnXG4gICAgICByb3RhdGU6ICdyYWRpYWwnLFxuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAvLyAnbGVmdCcgaXMgZm9yIGlubmVyIHNpZGUgb2YgaW5zaWRlLCBhbmQgJ3JpZ2h0JyBpcyBmb3Igb3V0dGVyXG4gICAgICAvLyBzaWRlIGZvciBpbnNpZGVcbiAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgIHBvc2l0aW9uOiAnaW5zaWRlJyxcbiAgICAgIGRpc3RhbmNlOiA1LFxuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSxcbiAgICBpdGVtU3R5bGU6IHtcbiAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgYm9yZGVyQ29sb3I6ICd3aGl0ZScsXG4gICAgICBib3JkZXJUeXBlOiAnc29saWQnLFxuICAgICAgc2hhZG93Qmx1cjogMCxcbiAgICAgIHNoYWRvd0NvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjIpJyxcbiAgICAgIHNoYWRvd09mZnNldFg6IDAsXG4gICAgICBzaGFkb3dPZmZzZXRZOiAwLFxuICAgICAgb3BhY2l0eTogMVxuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIGZvY3VzOiAnZGVzY2VuZGFudCdcbiAgICB9LFxuICAgIGJsdXI6IHtcbiAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICBvcGFjaXR5OiAwLjJcbiAgICAgIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBvcGFjaXR5OiAwLjFcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFuaW1hdGlvbiB0eXBlIGNhbmJlIGV4cGFuc2lvbiwgc2NhbGVcbiAgICBhbmltYXRpb25UeXBlOiAnZXhwYW5zaW9uJyxcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMTAwMCxcbiAgICBhbmltYXRpb25EdXJhdGlvblVwZGF0ZTogNTAwLFxuICAgIGRhdGE6IFtdLFxuICAgIGxldmVsczogW10sXG5cbiAgICAvKipcbiAgICAgKiBTb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogVmFsaWQgdmFsdWVzOiAnZGVzYycsICdhc2MnLCBudWxsLCBvciBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiAnZGVzYycgYW5kICdhc2MnIGZvciBkZXNjZW5kIGFuZCBhc2NlbmRhbnQgb3JkZXI7XG4gICAgICogbnVsbCBmb3Igbm90IHNvcnRpbmc7XG4gICAgICogZXhhbXBsZSBvZiBjYWxsYmFjayBmdW5jdGlvbjpcbiAgICAgKiBmdW5jdGlvbihub2RlQSwgbm9kZUIpIHtcbiAgICAgKiAgICAgcmV0dXJuIG5vZGVBLmdldFZhbHVlKCkgLSBub2RlQi5nZXRWYWx1ZSgpO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICBzb3J0OiAnZGVzYydcbiAgfTtcbiAgcmV0dXJuIFN1bmJ1cnN0U2VyaWVzTW9kZWw7XG59KFNlcmllc01vZGVsKTtcblxuZnVuY3Rpb24gY29tcGxldGVUcmVlVmFsdWUoZGF0YU5vZGUpIHtcbiAgLy8gUG9zdG9yZGVyIHRyYXZlbCB0cmVlLlxuICAvLyBJZiB2YWx1ZSBvZiBub25lLWxlYWYgbm9kZSBpcyBub3Qgc2V0LFxuICAvLyBjYWxjdWxhdGUgaXQgYnkgc3VtaW5nIHVwIHRoZSB2YWx1ZSBvZiBhbGwgY2hpbGRyZW4uXG4gIHZhciBzdW0gPSAwO1xuICB6clV0aWwuZWFjaChkYXRhTm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgY29tcGxldGVUcmVlVmFsdWUoY2hpbGQpO1xuICAgIHZhciBjaGlsZFZhbHVlID0gY2hpbGQudmFsdWU7IC8vIFRPRE8gRmlyc3QgdmFsdWUgb2YgYXJyYXkgbXVzdCBiZSBhIG51bWJlclxuXG4gICAgenJVdGlsLmlzQXJyYXkoY2hpbGRWYWx1ZSkgJiYgKGNoaWxkVmFsdWUgPSBjaGlsZFZhbHVlWzBdKTtcbiAgICBzdW0gKz0gY2hpbGRWYWx1ZTtcbiAgfSk7XG4gIHZhciB0aGlzVmFsdWUgPSBkYXRhTm9kZS52YWx1ZTtcblxuICBpZiAoenJVdGlsLmlzQXJyYXkodGhpc1ZhbHVlKSkge1xuICAgIHRoaXNWYWx1ZSA9IHRoaXNWYWx1ZVswXTtcbiAgfVxuXG4gIGlmICh0aGlzVmFsdWUgPT0gbnVsbCB8fCBpc05hTih0aGlzVmFsdWUpKSB7XG4gICAgdGhpc1ZhbHVlID0gc3VtO1xuICB9IC8vIFZhbHVlIHNob3VsZCBub3QgbGVzcyB0aGFuIDAuXG5cblxuICBpZiAodGhpc1ZhbHVlIDwgMCkge1xuICAgIHRoaXNWYWx1ZSA9IDA7XG4gIH1cblxuICB6clV0aWwuaXNBcnJheShkYXRhTm9kZS52YWx1ZSkgPyBkYXRhTm9kZS52YWx1ZVswXSA9IHRoaXNWYWx1ZSA6IGRhdGFOb2RlLnZhbHVlID0gdGhpc1ZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTdW5idXJzdFNlcmllc01vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0JztcbmltcG9ydCBTdW5idXJzdFBpZWNlIGZyb20gJy4vU3VuYnVyc3RQaWVjZSc7XG5pbXBvcnQgRGF0YURpZmZlciBmcm9tICcuLi8uLi9kYXRhL0RhdGFEaWZmZXInO1xuaW1wb3J0IHsgUk9PVF9UT19OT0RFX0FDVElPTiB9IGZyb20gJy4vc3VuYnVyc3RBY3Rpb24nO1xuaW1wb3J0IHsgd2luZG93T3BlbiB9IGZyb20gJy4uLy4uL3V0aWwvZm9ybWF0JztcblxudmFyIFN1bmJ1cnN0VmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTdW5idXJzdFZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU3VuYnVyc3RWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IFN1bmJ1cnN0Vmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFN1bmJ1cnN0Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIC8vIEB0cy1pZ25vcmVcbiAgcGF5bG9hZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnNlcmllc01vZGVsID0gc2VyaWVzTW9kZWw7XG4gICAgdGhpcy5hcGkgPSBhcGk7XG4gICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgdmlydHVhbFJvb3QgPSBkYXRhLnRyZWUucm9vdDtcbiAgICB2YXIgbmV3Um9vdCA9IHNlcmllc01vZGVsLmdldFZpZXdSb290KCk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgcmVuZGVyTGFiZWxGb3JaZXJvRGF0YSA9IHNlcmllc01vZGVsLmdldCgncmVuZGVyTGFiZWxGb3JaZXJvRGF0YScpO1xuICAgIHZhciBuZXdDaGlsZHJlbiA9IFtdO1xuICAgIG5ld1Jvb3QuZWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgfSk7XG4gICAgdmFyIG9sZENoaWxkcmVuID0gdGhpcy5fb2xkQ2hpbGRyZW4gfHwgW107XG4gICAgZHVhbFRyYXZlbChuZXdDaGlsZHJlbiwgb2xkQ2hpbGRyZW4pO1xuICAgIHJlbmRlclJvbGxVcCh2aXJ0dWFsUm9vdCwgbmV3Um9vdCk7XG5cbiAgICB0aGlzLl9pbml0RXZlbnRzKCk7XG5cbiAgICB0aGlzLl9vbGRDaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuXG4gICAgZnVuY3Rpb24gZHVhbFRyYXZlbChuZXdDaGlsZHJlbiwgb2xkQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChuZXdDaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgb2xkQ2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbmV3IERhdGFEaWZmZXIob2xkQ2hpbGRyZW4sIG5ld0NoaWxkcmVuLCBnZXRLZXksIGdldEtleSkuYWRkKHByb2Nlc3NOb2RlKS51cGRhdGUocHJvY2Vzc05vZGUpLnJlbW92ZSh6clV0aWwuY3VycnkocHJvY2Vzc05vZGUsIG51bGwpKS5leGVjdXRlKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldEtleShub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmdldElkKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHByb2Nlc3NOb2RlKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgICAgIHZhciBuZXdOb2RlID0gbmV3SWR4ID09IG51bGwgPyBudWxsIDogbmV3Q2hpbGRyZW5bbmV3SWR4XTtcbiAgICAgICAgdmFyIG9sZE5vZGUgPSBvbGRJZHggPT0gbnVsbCA/IG51bGwgOiBvbGRDaGlsZHJlbltvbGRJZHhdO1xuICAgICAgICBkb1JlbmRlck5vZGUobmV3Tm9kZSwgb2xkTm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9SZW5kZXJOb2RlKG5ld05vZGUsIG9sZE5vZGUpIHtcbiAgICAgIGlmICghcmVuZGVyTGFiZWxGb3JaZXJvRGF0YSAmJiBuZXdOb2RlICYmICFuZXdOb2RlLmdldFZhbHVlKCkpIHtcbiAgICAgICAgLy8gTm90IHJlbmRlciBkYXRhIHdpdGggdmFsdWUgMFxuICAgICAgICBuZXdOb2RlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld05vZGUgIT09IHZpcnR1YWxSb290ICYmIG9sZE5vZGUgIT09IHZpcnR1YWxSb290KSB7XG4gICAgICAgIGlmIChvbGROb2RlICYmIG9sZE5vZGUucGllY2UpIHtcbiAgICAgICAgICBpZiAobmV3Tm9kZSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlXG4gICAgICAgICAgICBvbGROb2RlLnBpZWNlLnVwZGF0ZURhdGEoZmFsc2UsIG5ld05vZGUsIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpOyAvLyBGb3IgdG9vbHRpcFxuXG4gICAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3Tm9kZS5kYXRhSW5kZXgsIG9sZE5vZGUucGllY2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZW1vdmVcbiAgICAgICAgICAgIHJlbW92ZU5vZGUob2xkTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5ld05vZGUpIHtcbiAgICAgICAgICAvLyBBZGRcbiAgICAgICAgICB2YXIgcGllY2UgPSBuZXcgU3VuYnVyc3RQaWVjZShuZXdOb2RlLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgICBncm91cC5hZGQocGllY2UpOyAvLyBGb3IgdG9vbHRpcFxuXG4gICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld05vZGUuZGF0YUluZGV4LCBwaWVjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnBpZWNlKSB7XG4gICAgICAgIGdyb3VwLnJlbW92ZShub2RlLnBpZWNlKTtcbiAgICAgICAgbm9kZS5waWVjZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyUm9sbFVwKHZpcnR1YWxSb290LCB2aWV3Um9vdCkge1xuICAgICAgaWYgKHZpZXdSb290LmRlcHRoID4gMCkge1xuICAgICAgICAvLyBSZW5kZXJcbiAgICAgICAgaWYgKHNlbGYudmlydHVhbFBpZWNlKSB7XG4gICAgICAgICAgLy8gVXBkYXRlXG4gICAgICAgICAgc2VsZi52aXJ0dWFsUGllY2UudXBkYXRlRGF0YShmYWxzZSwgdmlydHVhbFJvb3QsIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFkZFxuICAgICAgICAgIHNlbGYudmlydHVhbFBpZWNlID0gbmV3IFN1bmJ1cnN0UGllY2UodmlydHVhbFJvb3QsIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgICAgICAgIGdyb3VwLmFkZChzZWxmLnZpcnR1YWxQaWVjZSk7XG4gICAgICAgIH0gLy8gVE9ETyBldmVudCBzY29wZVxuXG5cbiAgICAgICAgdmlld1Jvb3QucGllY2Uub2ZmKCdjbGljaycpO1xuICAgICAgICBzZWxmLnZpcnR1YWxQaWVjZS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHNlbGYuX3Jvb3RUb05vZGUodmlld1Jvb3QucGFyZW50Tm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChzZWxmLnZpcnR1YWxQaWVjZSkge1xuICAgICAgICAvLyBSZW1vdmVcbiAgICAgICAgZ3JvdXAucmVtb3ZlKHNlbGYudmlydHVhbFBpZWNlKTtcbiAgICAgICAgc2VsZi52aXJ0dWFsUGllY2UgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgU3VuYnVyc3RWaWV3LnByb3RvdHlwZS5faW5pdEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5ncm91cC5vZmYoJ2NsaWNrJyk7XG4gICAgdGhpcy5ncm91cC5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHRhcmdldEZvdW5kID0gZmFsc2U7XG5cbiAgICAgIHZhciB2aWV3Um9vdCA9IF90aGlzLnNlcmllc01vZGVsLmdldFZpZXdSb290KCk7XG5cbiAgICAgIHZpZXdSb290LmVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghdGFyZ2V0Rm91bmQgJiYgbm9kZS5waWVjZSAmJiBub2RlLnBpZWNlID09PSBlLnRhcmdldCkge1xuICAgICAgICAgIHZhciBub2RlQ2xpY2sgPSBub2RlLmdldE1vZGVsKCkuZ2V0KCdub2RlQ2xpY2snKTtcblxuICAgICAgICAgIGlmIChub2RlQ2xpY2sgPT09ICdyb290VG9Ob2RlJykge1xuICAgICAgICAgICAgX3RoaXMuX3Jvb3RUb05vZGUobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlQ2xpY2sgPT09ICdsaW5rJykge1xuICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IG5vZGUuZ2V0TW9kZWwoKTtcbiAgICAgICAgICAgIHZhciBsaW5rID0gaXRlbU1vZGVsLmdldCgnbGluaycpO1xuXG4gICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICB2YXIgbGlua1RhcmdldCA9IGl0ZW1Nb2RlbC5nZXQoJ3RhcmdldCcsIHRydWUpIHx8ICdfYmxhbmsnO1xuICAgICAgICAgICAgICB3aW5kb3dPcGVuKGxpbmssIGxpbmtUYXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhcmdldEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFN1bmJ1cnN0Vmlldy5wcm90b3R5cGUuX3Jvb3RUb05vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlICE9PSB0aGlzLnNlcmllc01vZGVsLmdldFZpZXdSb290KCkpIHtcbiAgICAgIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgdHlwZTogUk9PVF9UT19OT0RFX0FDVElPTixcbiAgICAgICAgZnJvbTogdGhpcy51aWQsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLnNlcmllc01vZGVsLmlkLFxuICAgICAgICB0YXJnZXROb2RlOiBub2RlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAaW1wbGVtZW50XG4gICAqL1xuXG5cbiAgU3VuYnVyc3RWaWV3LnByb3RvdHlwZS5jb250YWluUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQsIHNlcmllc01vZGVsKSB7XG4gICAgdmFyIHRyZWVSb290ID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBpdGVtTGF5b3V0ID0gdHJlZVJvb3QuZ2V0SXRlbUxheW91dCgwKTtcblxuICAgIGlmIChpdGVtTGF5b3V0KSB7XG4gICAgICB2YXIgZHggPSBwb2ludFswXSAtIGl0ZW1MYXlvdXQuY3g7XG4gICAgICB2YXIgZHkgPSBwb2ludFsxXSAtIGl0ZW1MYXlvdXQuY3k7XG4gICAgICB2YXIgcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIHJldHVybiByYWRpdXMgPD0gaXRlbUxheW91dC5yICYmIHJhZGl1cyA+PSBpdGVtTGF5b3V0LnIwO1xuICAgIH1cbiAgfTtcblxuICBTdW5idXJzdFZpZXcudHlwZSA9ICdzdW5idXJzdCc7XG4gIHJldHVybiBTdW5idXJzdFZpZXc7XG59KENoYXJ0Vmlldyk7XG5cbmV4cG9ydCBkZWZhdWx0IFN1bmJ1cnN0VmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IFN1bmJ1cnN0VmlldyBmcm9tICcuL1N1bmJ1cnN0Vmlldyc7XG5pbXBvcnQgU3VuYnVyc3RTZXJpZXNNb2RlbCBmcm9tICcuL1N1bmJ1cnN0U2VyaWVzJztcbmltcG9ydCBzdW5idXJzdExheW91dCBmcm9tICcuL3N1bmJ1cnN0TGF5b3V0JztcbmltcG9ydCBzdW5idXJzdFZpc3VhbCBmcm9tICcuL3N1bmJ1cnN0VmlzdWFsJztcbmltcG9ydCBkYXRhRmlsdGVyIGZyb20gJy4uLy4uL3Byb2Nlc3Nvci9kYXRhRmlsdGVyJztcbmltcG9ydCB7IGN1cnJ5IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCB7IGluc3RhbGxTdW5idXJzdEFjdGlvbiB9IGZyb20gJy4vc3VuYnVyc3RBY3Rpb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhTdW5idXJzdFZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChTdW5idXJzdFNlcmllc01vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KGN1cnJ5KHN1bmJ1cnN0TGF5b3V0LCAnc3VuYnVyc3QnKSk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByb2Nlc3NvcihjdXJyeShkYXRhRmlsdGVyLCAnc3VuYnVyc3QnKSk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclZpc3VhbChzdW5idXJzdFZpc3VhbCk7XG4gIGluc3RhbGxTdW5idXJzdEFjdGlvbihyZWdpc3RlcnMpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgZGVwcmVjYXRlUmVwbGFjZUxvZyB9IGZyb20gJy4uLy4uL3V0aWwvbG9nJztcbmltcG9ydCB7IHJldHJpZXZlVGFyZ2V0SW5mbywgYWJvdmVWaWV3Um9vdCB9IGZyb20gJy4uL2hlbHBlci90cmVlSGVscGVyJztcbmV4cG9ydCB2YXIgUk9PVF9UT19OT0RFX0FDVElPTiA9ICdzdW5idXJzdFJvb3RUb05vZGUnO1xudmFyIEhJR0hMSUdIVF9BQ1RJT04gPSAnc3VuYnVyc3RIaWdobGlnaHQnO1xudmFyIFVOSElHSExJR0hUX0FDVElPTiA9ICdzdW5idXJzdFVuaGlnaGxpZ2h0JztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsU3VuYnVyc3RBY3Rpb24ocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbih7XG4gICAgdHlwZTogUk9PVF9UT19OT0RFX0FDVElPTixcbiAgICB1cGRhdGU6ICd1cGRhdGVWaWV3J1xuICB9LCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgICBtYWluVHlwZTogJ3NlcmllcycsXG4gICAgICBzdWJUeXBlOiAnc3VuYnVyc3QnLFxuICAgICAgcXVlcnk6IHBheWxvYWRcbiAgICB9LCBoYW5kbGVSb290VG9Ob2RlKTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZVJvb3RUb05vZGUobW9kZWwsIGluZGV4KSB7XG4gICAgICB2YXIgdGFyZ2V0SW5mbyA9IHJldHJpZXZlVGFyZ2V0SW5mbyhwYXlsb2FkLCBbUk9PVF9UT19OT0RFX0FDVElPTl0sIG1vZGVsKTtcblxuICAgICAgaWYgKHRhcmdldEluZm8pIHtcbiAgICAgICAgdmFyIG9yaWdpblZpZXdSb290ID0gbW9kZWwuZ2V0Vmlld1Jvb3QoKTtcblxuICAgICAgICBpZiAob3JpZ2luVmlld1Jvb3QpIHtcbiAgICAgICAgICBwYXlsb2FkLmRpcmVjdGlvbiA9IGFib3ZlVmlld1Jvb3Qob3JpZ2luVmlld1Jvb3QsIHRhcmdldEluZm8ubm9kZSkgPyAncm9sbFVwJyA6ICdkcmlsbERvd24nO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kZWwucmVzZXRWaWV3Um9vdCh0YXJnZXRJbmZvLm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbih7XG4gICAgdHlwZTogSElHSExJR0hUX0FDVElPTixcbiAgICB1cGRhdGU6ICdub25lJ1xuICB9LCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgLy8gQ2xvbmVcbiAgICBwYXlsb2FkID0gZXh0ZW5kKHt9LCBwYXlsb2FkKTtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6ICdzZXJpZXMnLFxuICAgICAgc3ViVHlwZTogJ3N1bmJ1cnN0JyxcbiAgICAgIHF1ZXJ5OiBwYXlsb2FkXG4gICAgfSwgaGFuZGxlSGlnaGxpZ2h0KTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUhpZ2hsaWdodChtb2RlbCkge1xuICAgICAgdmFyIHRhcmdldEluZm8gPSByZXRyaWV2ZVRhcmdldEluZm8ocGF5bG9hZCwgW0hJR0hMSUdIVF9BQ1RJT05dLCBtb2RlbCk7XG5cbiAgICAgIGlmICh0YXJnZXRJbmZvKSB7XG4gICAgICAgIHBheWxvYWQuZGF0YUluZGV4ID0gdGFyZ2V0SW5mby5ub2RlLmRhdGFJbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVwcmVjYXRlUmVwbGFjZUxvZygnaGlnaGxpZ2h0JywgJ3N1bmJ1cnN0SGlnaGxpZ2h0Jyk7XG4gICAgfSAvLyBGYXN0IGZvcndhcmQgYWN0aW9uXG5cblxuICAgIGFwaS5kaXNwYXRjaEFjdGlvbihleHRlbmQocGF5bG9hZCwge1xuICAgICAgdHlwZTogJ2hpZ2hsaWdodCdcbiAgICB9KSk7XG4gIH0pO1xuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oe1xuICAgIHR5cGU6IFVOSElHSExJR0hUX0FDVElPTixcbiAgICB1cGRhdGU6ICd1cGRhdGVWaWV3J1xuICB9LCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgcGF5bG9hZCA9IGV4dGVuZCh7fSwgcGF5bG9hZCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVwcmVjYXRlUmVwbGFjZUxvZygnZG93bnBsYXknLCAnc3VuYnVyc3RVbmhpZ2hsaWdodCcpO1xuICAgIH1cblxuICAgIGFwaS5kaXNwYXRjaEFjdGlvbihleHRlbmQocGF5bG9hZCwge1xuICAgICAgdHlwZTogJ2Rvd25wbGF5J1xuICAgIH0pKTtcbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IHBhcnNlUGVyY2VudCB9IGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyJztcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnOyAvLyBsZXQgUEkyID0gTWF0aC5QSSAqIDI7XG5cbnZhciBSQURJQU4gPSBNYXRoLlBJIC8gMTgwO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3VuYnVyc3RMYXlvdXQoc2VyaWVzVHlwZSwgZWNNb2RlbCwgYXBpKSB7XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgY2VudGVyID0gc2VyaWVzTW9kZWwuZ2V0KCdjZW50ZXInKTtcbiAgICB2YXIgcmFkaXVzID0gc2VyaWVzTW9kZWwuZ2V0KCdyYWRpdXMnKTtcblxuICAgIGlmICghenJVdGlsLmlzQXJyYXkocmFkaXVzKSkge1xuICAgICAgcmFkaXVzID0gWzAsIHJhZGl1c107XG4gICAgfVxuXG4gICAgaWYgKCF6clV0aWwuaXNBcnJheShjZW50ZXIpKSB7XG4gICAgICBjZW50ZXIgPSBbY2VudGVyLCBjZW50ZXJdO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IGFwaS5nZXRXaWR0aCgpO1xuICAgIHZhciBoZWlnaHQgPSBhcGkuZ2V0SGVpZ2h0KCk7XG4gICAgdmFyIHNpemUgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgY3ggPSBwYXJzZVBlcmNlbnQoY2VudGVyWzBdLCB3aWR0aCk7XG4gICAgdmFyIGN5ID0gcGFyc2VQZXJjZW50KGNlbnRlclsxXSwgaGVpZ2h0KTtcbiAgICB2YXIgcjAgPSBwYXJzZVBlcmNlbnQocmFkaXVzWzBdLCBzaXplIC8gMik7XG4gICAgdmFyIHIgPSBwYXJzZVBlcmNlbnQocmFkaXVzWzFdLCBzaXplIC8gMik7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSAtc2VyaWVzTW9kZWwuZ2V0KCdzdGFydEFuZ2xlJykgKiBSQURJQU47XG4gICAgdmFyIG1pbkFuZ2xlID0gc2VyaWVzTW9kZWwuZ2V0KCdtaW5BbmdsZScpICogUkFESUFOO1xuICAgIHZhciB2aXJ0dWFsUm9vdCA9IHNlcmllc01vZGVsLmdldERhdGEoKS50cmVlLnJvb3Q7XG4gICAgdmFyIHRyZWVSb290ID0gc2VyaWVzTW9kZWwuZ2V0Vmlld1Jvb3QoKTtcbiAgICB2YXIgcm9vdERlcHRoID0gdHJlZVJvb3QuZGVwdGg7XG4gICAgdmFyIHNvcnQgPSBzZXJpZXNNb2RlbC5nZXQoJ3NvcnQnKTtcblxuICAgIGlmIChzb3J0ICE9IG51bGwpIHtcbiAgICAgIGluaXRDaGlsZHJlbih0cmVlUm9vdCwgc29ydCk7XG4gICAgfVxuXG4gICAgdmFyIHZhbGlkRGF0YUNvdW50ID0gMDtcbiAgICB6clV0aWwuZWFjaCh0cmVlUm9vdC5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAhaXNOYU4oY2hpbGQuZ2V0VmFsdWUoKSkgJiYgdmFsaWREYXRhQ291bnQrKztcbiAgICB9KTtcbiAgICB2YXIgc3VtID0gdHJlZVJvb3QuZ2V0VmFsdWUoKTsgLy8gU3VtIG1heSBiZSAwXG5cbiAgICB2YXIgdW5pdFJhZGlhbiA9IE1hdGguUEkgLyAoc3VtIHx8IHZhbGlkRGF0YUNvdW50KSAqIDI7XG4gICAgdmFyIHJlbmRlclJvbGx1cE5vZGUgPSB0cmVlUm9vdC5kZXB0aCA+IDA7XG4gICAgdmFyIGxldmVscyA9IHRyZWVSb290LmhlaWdodCAtIChyZW5kZXJSb2xsdXBOb2RlID8gLTEgOiAxKTtcbiAgICB2YXIgclBlckxldmVsID0gKHIgLSByMCkgLyAobGV2ZWxzIHx8IDEpO1xuICAgIHZhciBjbG9ja3dpc2UgPSBzZXJpZXNNb2RlbC5nZXQoJ2Nsb2Nrd2lzZScpO1xuICAgIHZhciBzdGlsbFNob3daZXJvU3VtID0gc2VyaWVzTW9kZWwuZ2V0KCdzdGlsbFNob3daZXJvU3VtJyk7IC8vIEluIHRoZSBjYXNlIHNvbWUgc2VjdG9yIGFuZ2xlIGlzIHNtYWxsZXIgdGhhbiBtaW5BbmdsZVxuICAgIC8vIGxldCByZXN0QW5nbGUgPSBQSTI7XG4gICAgLy8gbGV0IHZhbHVlU3VtTGFyZ2VyVGhhbk1pbkFuZ2xlID0gMDtcblxuICAgIHZhciBkaXIgPSBjbG9ja3dpc2UgPyAxIDogLTE7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgdHJlZVxuICAgICAqIEByZXR1cm4gaW5jcmVhc2VkIGFuZ2xlXG4gICAgICovXG5cbiAgICB2YXIgcmVuZGVyTm9kZSA9IGZ1bmN0aW9uIChub2RlLCBzdGFydEFuZ2xlKSB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZW5kQW5nbGUgPSBzdGFydEFuZ2xlOyAvLyBSZW5kZXIgc2VsZlxuXG4gICAgICBpZiAobm9kZSAhPT0gdmlydHVhbFJvb3QpIHtcbiAgICAgICAgLy8gVHJlZSBub2RlIGlzIHZpcnR1YWwsIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBkcmF3blxuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmdldFZhbHVlKCk7XG4gICAgICAgIHZhciBhbmdsZSA9IHN1bSA9PT0gMCAmJiBzdGlsbFNob3daZXJvU3VtID8gdW5pdFJhZGlhbiA6IHZhbHVlICogdW5pdFJhZGlhbjtcblxuICAgICAgICBpZiAoYW5nbGUgPCBtaW5BbmdsZSkge1xuICAgICAgICAgIGFuZ2xlID0gbWluQW5nbGU7IC8vIHJlc3RBbmdsZSAtPSBtaW5BbmdsZTtcbiAgICAgICAgfSAvLyBlbHNlIHtcbiAgICAgICAgLy8gICAgIHZhbHVlU3VtTGFyZ2VyVGhhbk1pbkFuZ2xlICs9IHZhbHVlO1xuICAgICAgICAvLyB9XG5cblxuICAgICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBkaXIgKiBhbmdsZTtcbiAgICAgICAgdmFyIGRlcHRoID0gbm9kZS5kZXB0aCAtIHJvb3REZXB0aCAtIChyZW5kZXJSb2xsdXBOb2RlID8gLTEgOiAxKTtcbiAgICAgICAgdmFyIHJTdGFydCA9IHIwICsgclBlckxldmVsICogZGVwdGg7XG4gICAgICAgIHZhciByRW5kID0gcjAgKyByUGVyTGV2ZWwgKiAoZGVwdGggKyAxKTtcbiAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IG5vZGUuZ2V0TW9kZWwoKTsgLy8gQHRzLWlnbm9yZS4gVE9ETyB0aGlzIGlzIG5vdCBwcm92aWRlZCB0byBkZXZlbG9wZXIgeWV0LiBSZW5hbWUgaXQuXG5cbiAgICAgICAgaWYgKGl0ZW1Nb2RlbC5nZXQoJ3IwJykgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICByU3RhcnQgPSBwYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldCgncjAnKSwgc2l6ZSAvIDIpO1xuICAgICAgICB9IC8vIEB0cy1pZ25vcmVcblxuXG4gICAgICAgIGlmIChpdGVtTW9kZWwuZ2V0KCdyJykgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICByRW5kID0gcGFyc2VQZXJjZW50KGl0ZW1Nb2RlbC5nZXQoJ3InKSwgc2l6ZSAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5zZXRMYXlvdXQoe1xuICAgICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcbiAgICAgICAgICBjbG9ja3dpc2U6IGNsb2Nrd2lzZSxcbiAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgIHIwOiByU3RhcnQsXG4gICAgICAgICAgcjogckVuZFxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gUmVuZGVyIGNoaWxkcmVuXG5cblxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4gJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gY3VycmVudEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICAgICAgdmFyIHNpYmxpbmdBbmdsZV8xID0gMDtcbiAgICAgICAgenJVdGlsLmVhY2gobm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBzaWJsaW5nQW5nbGVfMSArPSByZW5kZXJOb2RlKG5vZGUsIHN0YXJ0QW5nbGUgKyBzaWJsaW5nQW5nbGVfMSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgIH07IC8vIFZpcnR1YWwgcm9vdCBub2RlIGZvciByb2xsIHVwXG5cblxuICAgIGlmIChyZW5kZXJSb2xsdXBOb2RlKSB7XG4gICAgICB2YXIgclN0YXJ0ID0gcjA7XG4gICAgICB2YXIgckVuZCA9IHIwICsgclBlckxldmVsO1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5QSSAqIDI7XG4gICAgICB2aXJ0dWFsUm9vdC5zZXRMYXlvdXQoe1xuICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlICsgYW5nbGUsXG4gICAgICAgIGNsb2Nrd2lzZTogY2xvY2t3aXNlLFxuICAgICAgICBjeDogY3gsXG4gICAgICAgIGN5OiBjeSxcbiAgICAgICAgcjA6IHJTdGFydCxcbiAgICAgICAgcjogckVuZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyTm9kZSh0cmVlUm9vdCwgc3RhcnRBbmdsZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBJbml0IG5vZGUgY2hpbGRyZW4gYnkgb3JkZXIgYW5kIHVwZGF0ZSB2aXN1YWxcbiAqL1xuXG5mdW5jdGlvbiBpbml0Q2hpbGRyZW4obm9kZSwgc29ydE9yZGVyKSB7XG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4gfHwgW107XG4gIG5vZGUuY2hpbGRyZW4gPSBzb3J0KGNoaWxkcmVuLCBzb3J0T3JkZXIpOyAvLyBJbml0IGNoaWxkcmVuIHJlY3Vyc2l2ZWx5XG5cbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHpyVXRpbC5lYWNoKG5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaW5pdENoaWxkcmVuKGNoaWxkLCBzb3J0T3JkZXIpO1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIFNvcnQgY2hpbGRyZW4gbm9kZXNcbiAqXG4gKiBAcGFyYW0ge1RyZWVOb2RlW119ICAgICAgICAgICAgICAgY2hpbGRyZW4gY2hpbGRyZW4gb2Ygbm9kZSB0byBiZSBzb3J0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgZnVuY3Rpb24gfCBudWxsfSBzb3J0IHNvcnQgbWV0aG9kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIFN1bmJ1cnN0U2VyaWVzLmpzIGZvciBkZXRhaWxzLlxuICovXG5cblxuZnVuY3Rpb24gc29ydChjaGlsZHJlbiwgc29ydE9yZGVyKSB7XG4gIGlmICh0eXBlb2Ygc29ydE9yZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvcnRUYXJnZXRzID0genJVdGlsLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBpZHgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGNoaWxkLmdldFZhbHVlKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBkZXB0aDogY2hpbGQuZGVwdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjaGlsZC5oZWlnaHQsXG4gICAgICAgICAgZGF0YUluZGV4OiBjaGlsZC5kYXRhSW5kZXgsXG4gICAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGluZGV4OiBpZHhcbiAgICAgIH07XG4gICAgfSk7XG4gICAgc29ydFRhcmdldHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIHNvcnRPcmRlcihhLnBhcmFtcywgYi5wYXJhbXMpO1xuICAgIH0pO1xuICAgIHJldHVybiB6clV0aWwubWFwKHNvcnRUYXJnZXRzLCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5bdGFyZ2V0LmluZGV4XTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaXNBc2NfMSA9IHNvcnRPcmRlciA9PT0gJ2FzYyc7XG4gICAgcmV0dXJuIGNoaWxkcmVuLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBkaWZmID0gKGEuZ2V0VmFsdWUoKSAtIGIuZ2V0VmFsdWUoKSkgKiAoaXNBc2NfMSA/IDEgOiAtMSk7XG4gICAgICByZXR1cm4gZGlmZiA9PT0gMCA/IChhLmRhdGFJbmRleCAtIGIuZGF0YUluZGV4KSAqIChpc0FzY18xID8gLTEgOiAxKSA6IGRpZmY7XG4gICAgfSk7XG4gIH1cbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCB7IGxpZnQgfSBmcm9tICd6cmVuZGVyL2xpYi90b29sL2NvbG9yJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN1bmJ1cnN0VmlzdWFsKGVjTW9kZWwpIHtcbiAgdmFyIHBhbGV0dGVTY29wZSA9IHt9OyAvLyBEZWZhdWx0IGNvbG9yIHN0cmF0ZWd5XG5cbiAgZnVuY3Rpb24gcGlja0NvbG9yKG5vZGUsIHNlcmllc01vZGVsLCB0cmVlSGVpZ2h0KSB7XG4gICAgLy8gQ2hvb3NlIGNvbG9yIGZyb20gcGFsZXR0ZSBiYXNlZCBvbiB0aGUgZmlyc3QgbGV2ZWwuXG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xuXG4gICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5kZXB0aCA+IDEpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgdmFyIGNvbG9yID0gc2VyaWVzTW9kZWwuZ2V0Q29sb3JGcm9tUGFsZXR0ZShjdXJyZW50Lm5hbWUgfHwgY3VycmVudC5kYXRhSW5kZXggKyAnJywgcGFsZXR0ZVNjb3BlKTtcblxuICAgIGlmIChub2RlLmRlcHRoID4gMSAmJiB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBMaWdodGVyIG9uIHRoZSBkZWVwZXIgbGV2ZWwuXG4gICAgICBjb2xvciA9IGxpZnQoY29sb3IsIChub2RlLmRlcHRoIC0gMSkgLyAodHJlZUhlaWdodCAtIDEpICogMC41KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ3N1bmJ1cnN0JywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHRyZWUgPSBkYXRhLnRyZWU7XG4gICAgdHJlZS5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIG1vZGVsID0gbm9kZS5nZXRNb2RlbCgpO1xuICAgICAgdmFyIHN0eWxlID0gbW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZSgpO1xuXG4gICAgICBpZiAoIXN0eWxlLmZpbGwpIHtcbiAgICAgICAgc3R5bGUuZmlsbCA9IHBpY2tDb2xvcihub2RlLCBzZXJpZXNNb2RlbCwgdHJlZS5yb290LmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBleGlzdHNTdHlsZSA9IGRhdGEuZW5zdXJlVW5pcXVlSXRlbVZpc3VhbChub2RlLmRhdGFJbmRleCwgJ3N0eWxlJyk7XG4gICAgICBleHRlbmQoZXhpc3RzU3R5bGUsIHN0eWxlKTtcbiAgICB9KTtcbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcyc7XG5pbXBvcnQgY3JlYXRlRGltZW5zaW9ucyBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9jcmVhdGVEaW1lbnNpb25zJztcbmltcG9ydCB7IGdldERpbWVuc2lvblR5cGVCeUF4aXMgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9kaW1lbnNpb25IZWxwZXInO1xuaW1wb3J0IExpc3QgZnJvbSAnLi4vLi4vZGF0YS9MaXN0JztcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgZ3JvdXBEYXRhLCBTSU5HTEVfUkVGRVJSSU5HIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG5pbXBvcnQgTGVnZW5kVmlzdWFsUHJvdmlkZXIgZnJvbSAnLi4vLi4vdmlzdWFsL0xlZ2VuZFZpc3VhbFByb3ZpZGVyJztcbmltcG9ydCB7IGNyZWF0ZVRvb2x0aXBNYXJrdXAgfSBmcm9tICcuLi8uLi9jb21wb25lbnQvdG9vbHRpcC90b29sdGlwTWFya3VwJztcbnZhciBEQVRBX05BTUVfSU5ERVggPSAyO1xuXG52YXIgVGhlbWVSaXZlclNlcmllc01vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRoZW1lUml2ZXJTZXJpZXNNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBUaGVtZVJpdmVyU2VyaWVzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gVGhlbWVSaXZlclNlcmllc01vZGVsLnR5cGU7XG4gICAgX3RoaXMudXNlQ29sb3JQYWxldHRlT25EYXRhID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIFRoZW1lUml2ZXJTZXJpZXNNb2RlbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBfc3VwZXIucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gUHV0IHRoaXMgZnVuY3Rpb24gaGVyZSBpcyBmb3IgdGhlIHNha2Ugb2YgY29uc2lzdGVuY3kgb2YgY29kZSBzdHlsZS5cbiAgICAvLyBFbmFibGUgbGVnZW5kIHNlbGVjdGlvbiBmb3IgZWFjaCBkYXRhIGl0ZW1cbiAgICAvLyBVc2UgYSBmdW5jdGlvbiBpbnN0ZWFkIG9mIGRpcmVjdCBhY2Nlc3MgYmVjYXVzZSBkYXRhIHJlZmVyZW5jZSBtYXkgY2hhbmdlZFxuXG5cbiAgICB0aGlzLmxlZ2VuZFZpc3VhbFByb3ZpZGVyID0gbmV3IExlZ2VuZFZpc3VhbFByb3ZpZGVyKHpyVXRpbC5iaW5kKHRoaXMuZ2V0RGF0YSwgdGhpcyksIHpyVXRpbC5iaW5kKHRoaXMuZ2V0UmF3RGF0YSwgdGhpcykpO1xuICB9O1xuICAvKipcbiAgICogSWYgdGhlcmUgaXMgbm8gdmFsdWUgb2YgYSBjZXJ0YWluIHBvaW50IGluIHRoZSB0aW1lIGZvciBzb21lIGV2ZW50LHNldCBpdCB2YWx1ZSB0byAwLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhICBpbml0aWFsIGRhdGEgaW4gdGhlIG9wdGlvblxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG5cblxuICBUaGVtZVJpdmVyU2VyaWVzTW9kZWwucHJvdG90eXBlLmZpeERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciByYXdEYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgLyoqXG4gICAgICogTWFrZSBzdXJlIGV2ZXJ5IGxheWVyIGRhdGEgZ2V0IHRoZSBzYW1lIGtleXMuXG4gICAgICogVGhlIHZhbHVlIGluZGV4IHRlbGxzIHdoaWNoIGxheWVyIGhhcyB2aXNpdGVkLlxuICAgICAqIHtcbiAgICAgKiAgMjAxNC8wMS8wMTogLTFcbiAgICAgKiB9XG4gICAgICovXG5cbiAgICB2YXIgdGltZVZhbHVlS2V5cyA9IHt9OyAvLyBncm91cGVkIGRhdGEgYnkgbmFtZVxuXG4gICAgdmFyIGdyb3VwUmVzdWx0ID0gZ3JvdXBEYXRhKGRhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoIXRpbWVWYWx1ZUtleXMuaGFzT3duUHJvcGVydHkoaXRlbVswXSArICcnKSkge1xuICAgICAgICB0aW1lVmFsdWVLZXlzW2l0ZW1bMF0gKyAnJ10gPSAtMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW1bMl07XG4gICAgfSk7XG4gICAgdmFyIGxheWVyRGF0YSA9IFtdO1xuICAgIGdyb3VwUmVzdWx0LmJ1Y2tldHMuZWFjaChmdW5jdGlvbiAoaXRlbXMsIGtleSkge1xuICAgICAgbGF5ZXJEYXRhLnB1c2goe1xuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIGRhdGFMaXN0OiBpdGVtc1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGxheWVyTnVtID0gbGF5ZXJEYXRhLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGF5ZXJOdW07ICsraykge1xuICAgICAgdmFyIG5hbWVfMSA9IGxheWVyRGF0YVtrXS5uYW1lO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxheWVyRGF0YVtrXS5kYXRhTGlzdC5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgdGltZVZhbHVlID0gbGF5ZXJEYXRhW2tdLmRhdGFMaXN0W2pdWzBdICsgJyc7XG4gICAgICAgIHRpbWVWYWx1ZUtleXNbdGltZVZhbHVlXSA9IGs7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHRpbWVWYWx1ZSBpbiB0aW1lVmFsdWVLZXlzKSB7XG4gICAgICAgIGlmICh0aW1lVmFsdWVLZXlzLmhhc093blByb3BlcnR5KHRpbWVWYWx1ZSkgJiYgdGltZVZhbHVlS2V5c1t0aW1lVmFsdWVdICE9PSBrKSB7XG4gICAgICAgICAgdGltZVZhbHVlS2V5c1t0aW1lVmFsdWVdID0gaztcbiAgICAgICAgICBkYXRhW3Jhd0RhdGFMZW5ndGhdID0gW3RpbWVWYWx1ZSwgMCwgbmFtZV8xXTtcbiAgICAgICAgICByYXdEYXRhTGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0gIG9wdGlvbiAgdGhlIGluaXRpYWwgb3B0aW9uIHRoYXQgdXNlciBnaXZlZFxuICAgKiBAcGFyYW0gIGVjTW9kZWwgIHRoZSBtb2RlbCBvYmplY3QgZm9yIHRoZW1lUml2ZXIgb3B0aW9uXG4gICAqL1xuXG5cbiAgVGhlbWVSaXZlclNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YSA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICB2YXIgc2luZ2xlQXhpc01vZGVsID0gdGhpcy5nZXRSZWZlcnJpbmdDb21wb25lbnRzKCdzaW5nbGVBeGlzJywgU0lOR0xFX1JFRkVSUklORykubW9kZWxzWzBdO1xuICAgIHZhciBheGlzVHlwZSA9IHNpbmdsZUF4aXNNb2RlbC5nZXQoJ3R5cGUnKTsgLy8gZmlsdGVyIHRoZSBkYXRhIGl0ZW0gd2l0aCB0aGUgdmFsdWUgb2YgbGFiZWwgaXMgdW5kZWZpbmVkXG5cbiAgICB2YXIgZmlsdGVyRGF0YSA9IHpyVXRpbC5maWx0ZXIob3B0aW9uLmRhdGEsIGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgcmV0dXJuIGRhdGFJdGVtWzJdICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7IC8vID8/PyBUT0RPIGRlc2lnbiBhIHN0YWdlIHRvIHRyYW5zZmVyIGRhdGEgZm9yIHRoZW1lUml2ZXIgYW5kIGxpbmVzP1xuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmZpeERhdGEoZmlsdGVyRGF0YSB8fCBbXSk7XG4gICAgdmFyIG5hbWVMaXN0ID0gW107XG4gICAgdmFyIG5hbWVNYXAgPSB0aGlzLm5hbWVNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIG5hbWVMaXN0LnB1c2goZGF0YVtpXVtEQVRBX05BTUVfSU5ERVhdKTtcblxuICAgICAgaWYgKCFuYW1lTWFwLmdldChkYXRhW2ldW0RBVEFfTkFNRV9JTkRFWF0pKSB7XG4gICAgICAgIG5hbWVNYXAuc2V0KGRhdGFbaV1bREFUQV9OQU1FX0lOREVYXSwgY291bnQpO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaW1lbnNpb25zSW5mbyA9IGNyZWF0ZURpbWVuc2lvbnMoZGF0YSwge1xuICAgICAgY29vcmREaW1lbnNpb25zOiBbJ3NpbmdsZSddLFxuICAgICAgZGltZW5zaW9uc0RlZmluZTogW3tcbiAgICAgICAgbmFtZTogJ3RpbWUnLFxuICAgICAgICB0eXBlOiBnZXREaW1lbnNpb25UeXBlQnlBeGlzKGF4aXNUeXBlKVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgICB0eXBlOiAnZmxvYXQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgICAgdHlwZTogJ29yZGluYWwnXG4gICAgICB9XSxcbiAgICAgIGVuY29kZURlZmluZToge1xuICAgICAgICBzaW5nbGU6IDAsXG4gICAgICAgIHZhbHVlOiAxLFxuICAgICAgICBpdGVtTmFtZTogMlxuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBsaXN0ID0gbmV3IExpc3QoZGltZW5zaW9uc0luZm8sIHRoaXMpO1xuICAgIGxpc3QuaW5pdERhdGEoZGF0YSk7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH07XG4gIC8qKlxuICAgKiBUaGUgcmF3IGRhdGEgaXMgZGl2aWRlZCBpbnRvIG11bHRpcGxlIGxheWVycyBhbmQgZWFjaCBsYXllclxuICAgKiAgICAgaGFzIHNhbWUgbmFtZS5cbiAgICovXG5cblxuICBUaGVtZVJpdmVyU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldExheWVyU2VyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgdmFyIGxlbkNvdW50ID0gZGF0YS5jb3VudCgpO1xuICAgIHZhciBpbmRleEFyciA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5Db3VudDsgKytpKSB7XG4gICAgICBpbmRleEFycltpXSA9IGk7XG4gICAgfVxuXG4gICAgdmFyIHRpbWVEaW0gPSBkYXRhLm1hcERpbWVuc2lvbignc2luZ2xlJyk7IC8vIGRhdGEgZ3JvdXAgYnkgbmFtZVxuXG4gICAgdmFyIGdyb3VwUmVzdWx0ID0gZ3JvdXBEYXRhKGluZGV4QXJyLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiBkYXRhLmdldCgnbmFtZScsIGluZGV4KTtcbiAgICB9KTtcbiAgICB2YXIgbGF5ZXJTZXJpZXMgPSBbXTtcbiAgICBncm91cFJlc3VsdC5idWNrZXRzLmVhY2goZnVuY3Rpb24gKGl0ZW1zLCBrZXkpIHtcbiAgICAgIGl0ZW1zLnNvcnQoZnVuY3Rpb24gKGluZGV4MSwgaW5kZXgyKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmdldCh0aW1lRGltLCBpbmRleDEpIC0gZGF0YS5nZXQodGltZURpbSwgaW5kZXgyKTtcbiAgICAgIH0pO1xuICAgICAgbGF5ZXJTZXJpZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgaW5kaWNlczogaXRlbXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBsYXllclNlcmllcztcbiAgfTtcbiAgLyoqXG4gICAqIEdldCBkYXRhIGluZGljZXMgZm9yIHNob3cgdG9vbHRpcCBjb250ZW50XG4gICAqL1xuXG5cbiAgVGhlbWVSaXZlclNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRBeGlzVG9vbHRpcERhdGEgPSBmdW5jdGlvbiAoZGltLCB2YWx1ZSwgYmFzZUF4aXMpIHtcbiAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGRpbSkpIHtcbiAgICAgIGRpbSA9IGRpbSA/IFtkaW1dIDogW107XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoKTtcbiAgICB2YXIgbGF5ZXJTZXJpZXMgPSB0aGlzLmdldExheWVyU2VyaWVzKCk7XG4gICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICB2YXIgbGF5ZXJOdW0gPSBsYXllclNlcmllcy5sZW5ndGg7XG4gICAgdmFyIG5lc3Rlc3RWYWx1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJOdW07ICsraSkge1xuICAgICAgdmFyIG1pbkRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgdmFyIG5lYXJlc3RJZHggPSAtMTtcbiAgICAgIHZhciBwb2ludE51bSA9IGxheWVyU2VyaWVzW2ldLmluZGljZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvaW50TnVtOyArK2opIHtcbiAgICAgICAgdmFyIHRoZVZhbHVlID0gZGF0YS5nZXQoZGltWzBdLCBsYXllclNlcmllc1tpXS5pbmRpY2VzW2pdKTtcbiAgICAgICAgdmFyIGRpc3QgPSBNYXRoLmFicyh0aGVWYWx1ZSAtIHZhbHVlKTtcblxuICAgICAgICBpZiAoZGlzdCA8PSBtaW5EaXN0KSB7XG4gICAgICAgICAgbmVzdGVzdFZhbHVlID0gdGhlVmFsdWU7XG4gICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgbmVhcmVzdElkeCA9IGxheWVyU2VyaWVzW2ldLmluZGljZXNbal07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5kaWNlcy5wdXNoKG5lYXJlc3RJZHgpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhSW5kaWNlczogaW5kaWNlcyxcbiAgICAgIG5lc3Rlc3RWYWx1ZTogbmVzdGVzdFZhbHVlXG4gICAgfTtcbiAgfTtcblxuICBUaGVtZVJpdmVyU2VyaWVzTW9kZWwucHJvdG90eXBlLmZvcm1hdFRvb2x0aXAgPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBtdWx0aXBsZVNlcmllcywgZGF0YVR5cGUpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCk7XG4gICAgdmFyIHZhbHVlID0gZGF0YS5nZXQoZGF0YS5tYXBEaW1lbnNpb24oJ3ZhbHVlJyksIGRhdGFJbmRleCk7XG4gICAgcmV0dXJuIGNyZWF0ZVRvb2x0aXBNYXJrdXAoJ25hbWVWYWx1ZScsIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgfTtcblxuICBUaGVtZVJpdmVyU2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMudGhlbWVSaXZlcic7XG4gIFRoZW1lUml2ZXJTZXJpZXNNb2RlbC5kZXBlbmRlbmNpZXMgPSBbJ3NpbmdsZUF4aXMnXTtcbiAgVGhlbWVSaXZlclNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgY29vcmRpbmF0ZVN5c3RlbTogJ3NpbmdsZUF4aXMnLFxuICAgIC8vIGdhcCBpbiBheGlzJ3Mgb3J0aG9nb25hbCBvcmllbnRhdGlvblxuICAgIGJvdW5kYXJ5R2FwOiBbJzEwJScsICcxMCUnXSxcbiAgICAvLyBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG4gICAgc2luZ2xlQXhpc0luZGV4OiAwLFxuICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcicsXG4gICAgbGFiZWw6IHtcbiAgICAgIG1hcmdpbjogNCxcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBwb3NpdGlvbjogJ2xlZnQnLFxuICAgICAgZm9udFNpemU6IDExXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFRoZW1lUml2ZXJTZXJpZXNNb2RlbDtcbn0oU2VyaWVzTW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBUaGVtZVJpdmVyU2VyaWVzTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgRUNQb2x5Z29uIH0gZnJvbSAnLi4vbGluZS9wb2x5JztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCB7IHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbCwgZW5hYmxlSG92ZXJFbXBoYXNpcyB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdGVzJztcbmltcG9ydCB7IHNldExhYmVsU3R5bGUsIGdldExhYmVsU3RhdGVzTW9kZWxzIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZSc7XG5pbXBvcnQgeyBiaW5kIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBEYXRhRGlmZmVyIGZyb20gJy4uLy4uL2RhdGEvRGF0YURpZmZlcic7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ2hhcnQnO1xuXG52YXIgVGhlbWVSaXZlclZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVGhlbWVSaXZlclZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gVGhlbWVSaXZlclZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gVGhlbWVSaXZlclZpZXcudHlwZTtcbiAgICBfdGhpcy5fbGF5ZXJzID0gW107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgVGhlbWVSaXZlclZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGxheWVyc1NlcmllcyA9IHNlcmllc01vZGVsLmdldExheWVyU2VyaWVzKCk7XG4gICAgdmFyIGxheW91dEluZm8gPSBkYXRhLmdldExheW91dCgnbGF5b3V0SW5mbycpO1xuICAgIHZhciByZWN0ID0gbGF5b3V0SW5mby5yZWN0O1xuICAgIHZhciBib3VuZGFyeUdhcCA9IGxheW91dEluZm8uYm91bmRhcnlHYXA7XG4gICAgZ3JvdXAueCA9IDA7XG4gICAgZ3JvdXAueSA9IHJlY3QueSArIGJvdW5kYXJ5R2FwWzBdO1xuXG4gICAgZnVuY3Rpb24ga2V5R2V0dGVyKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLm5hbWU7XG4gICAgfVxuXG4gICAgdmFyIGRhdGFEaWZmZXIgPSBuZXcgRGF0YURpZmZlcih0aGlzLl9sYXllcnNTZXJpZXMgfHwgW10sIGxheWVyc1Nlcmllcywga2V5R2V0dGVyLCBrZXlHZXR0ZXIpO1xuICAgIHZhciBuZXdMYXllcnNHcm91cHMgPSBbXTtcbiAgICBkYXRhRGlmZmVyLmFkZChiaW5kKHByb2Nlc3MsIHRoaXMsICdhZGQnKSkudXBkYXRlKGJpbmQocHJvY2VzcywgdGhpcywgJ3VwZGF0ZScpKS5yZW1vdmUoYmluZChwcm9jZXNzLCB0aGlzLCAncmVtb3ZlJykpLmV4ZWN1dGUoKTtcblxuICAgIGZ1bmN0aW9uIHByb2Nlc3Moc3RhdHVzLCBpZHgsIG9sZElkeCkge1xuICAgICAgdmFyIG9sZExheWVyc0dyb3VwcyA9IHNlbGYuX2xheWVycztcblxuICAgICAgaWYgKHN0YXR1cyA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgZ3JvdXAucmVtb3ZlKG9sZExheWVyc0dyb3Vwc1tpZHhdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRzMCA9IFtdO1xuICAgICAgdmFyIHBvaW50czEgPSBbXTtcbiAgICAgIHZhciBzdHlsZTtcbiAgICAgIHZhciBpbmRpY2VzID0gbGF5ZXJzU2VyaWVzW2lkeF0uaW5kaWNlcztcbiAgICAgIHZhciBqID0gMDtcblxuICAgICAgZm9yICg7IGogPCBpbmRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaW5kaWNlc1tqXSk7XG4gICAgICAgIHZhciB4ID0gbGF5b3V0Lng7XG4gICAgICAgIHZhciB5MCA9IGxheW91dC55MDtcbiAgICAgICAgdmFyIHkgPSBsYXlvdXQueTtcbiAgICAgICAgcG9pbnRzMC5wdXNoKHgsIHkwKTtcbiAgICAgICAgcG9pbnRzMS5wdXNoKHgsIHkwICsgeSk7XG4gICAgICAgIHN0eWxlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGluZGljZXNbal0sICdzdHlsZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9seWdvbjtcbiAgICAgIHZhciB0ZXh0TGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGluZGljZXNbMF0pO1xuICAgICAgdmFyIGxhYmVsTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnbGFiZWwnKTtcbiAgICAgIHZhciBtYXJnaW4gPSBsYWJlbE1vZGVsLmdldCgnbWFyZ2luJyk7XG4gICAgICB2YXIgZW1waGFzaXNNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdlbXBoYXNpcycpO1xuXG4gICAgICBpZiAoc3RhdHVzID09PSAnYWRkJykge1xuICAgICAgICB2YXIgbGF5ZXJHcm91cCA9IG5ld0xheWVyc0dyb3Vwc1tpZHhdID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICAgICAgcG9seWdvbiA9IG5ldyBFQ1BvbHlnb24oe1xuICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBwb2ludHM6IHBvaW50czAsXG4gICAgICAgICAgICBzdGFja2VkT25Qb2ludHM6IHBvaW50czEsXG4gICAgICAgICAgICBzbW9vdGg6IDAuNCxcbiAgICAgICAgICAgIHN0YWNrZWRPblNtb290aDogMC40LFxuICAgICAgICAgICAgc21vb3RoQ29uc3RyYWludDogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHoyOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBsYXllckdyb3VwLmFkZChwb2x5Z29uKTtcbiAgICAgICAgZ3JvdXAuYWRkKGxheWVyR3JvdXApO1xuXG4gICAgICAgIGlmIChzZXJpZXNNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICAgIHBvbHlnb24uc2V0Q2xpcFBhdGgoY3JlYXRlR3JpZENsaXBTaGFwZShwb2x5Z29uLmdldEJvdW5kaW5nUmVjdCgpLCBzZXJpZXNNb2RlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcG9seWdvbi5yZW1vdmVDbGlwUGF0aCgpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxheWVyR3JvdXAgPSBvbGRMYXllcnNHcm91cHNbb2xkSWR4XTtcbiAgICAgICAgcG9seWdvbiA9IGxheWVyR3JvdXAuY2hpbGRBdCgwKTtcbiAgICAgICAgZ3JvdXAuYWRkKGxheWVyR3JvdXApO1xuICAgICAgICBuZXdMYXllcnNHcm91cHNbaWR4XSA9IGxheWVyR3JvdXA7XG4gICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocG9seWdvbiwge1xuICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBwb2ludHM6IHBvaW50czAsXG4gICAgICAgICAgICBzdGFja2VkT25Qb2ludHM6IHBvaW50czFcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgIH1cblxuICAgICAgc2V0TGFiZWxTdHlsZShwb2x5Z29uLCBnZXRMYWJlbFN0YXRlc01vZGVscyhzZXJpZXNNb2RlbCksIHtcbiAgICAgICAgbGFiZWxEYXRhSW5kZXg6IGluZGljZXNbaiAtIDFdLFxuICAgICAgICBkZWZhdWx0VGV4dDogZGF0YS5nZXROYW1lKGluZGljZXNbaiAtIDFdKSxcbiAgICAgICAgaW5oZXJpdENvbG9yOiBzdHlsZS5maWxsXG4gICAgICB9LCB7XG4gICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnIC8vIGFsaWduOiAncmlnaHQnXG5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBwb2x5Z29uLnNldFRleHRDb25maWcoe1xuICAgICAgICBwb3NpdGlvbjogbnVsbCxcbiAgICAgICAgbG9jYWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdmFyIGxhYmVsRWwgPSBwb2x5Z29uLmdldFRleHRDb250ZW50KCk7IC8vIFRPRE8gTW9yZSBsYWJlbCBwb3NpdGlvbiBvcHRpb25zLlxuXG4gICAgICBpZiAobGFiZWxFbCkge1xuICAgICAgICBsYWJlbEVsLnggPSB0ZXh0TGF5b3V0LnggLSBtYXJnaW47XG4gICAgICAgIGxhYmVsRWwueSA9IHRleHRMYXlvdXQueTAgKyB0ZXh0TGF5b3V0LnkgLyAyO1xuICAgICAgfVxuXG4gICAgICBwb2x5Z29uLnVzZVN0eWxlKHN0eWxlKTtcbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIHBvbHlnb24pO1xuICAgICAgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsKHBvbHlnb24sIHNlcmllc01vZGVsKTtcbiAgICAgIGVuYWJsZUhvdmVyRW1waGFzaXMocG9seWdvbiwgZW1waGFzaXNNb2RlbC5nZXQoJ2ZvY3VzJyksIGVtcGhhc2lzTW9kZWwuZ2V0KCdibHVyU2NvcGUnKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbGF5ZXJzU2VyaWVzID0gbGF5ZXJzU2VyaWVzO1xuICAgIHRoaXMuX2xheWVycyA9IG5ld0xheWVyc0dyb3VwcztcbiAgfTtcblxuICBUaGVtZVJpdmVyVmlldy50eXBlID0gJ3RoZW1lUml2ZXInO1xuICByZXR1cm4gVGhlbWVSaXZlclZpZXc7XG59KENoYXJ0Vmlldyk7XG5cbjsgLy8gYWRkIGFuaW1hdGlvbiB0byB0aGUgdmlld1xuXG5mdW5jdGlvbiBjcmVhdGVHcmlkQ2xpcFNoYXBlKHJlY3QsIHNlcmllc01vZGVsLCBjYikge1xuICB2YXIgcmVjdEVsID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgc2hhcGU6IHtcbiAgICAgIHg6IHJlY3QueCAtIDEwLFxuICAgICAgeTogcmVjdC55IC0gMTAsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKyAyMFxuICAgIH1cbiAgfSk7XG4gIGdyYXBoaWMuaW5pdFByb3BzKHJlY3RFbCwge1xuICAgIHNoYXBlOiB7XG4gICAgICB4OiByZWN0LnggLSA1MCxcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoICsgMTAwLFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCArIDIwXG4gICAgfVxuICB9LCBzZXJpZXNNb2RlbCwgY2IpO1xuICByZXR1cm4gcmVjdEVsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBUaGVtZVJpdmVyVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuaW1wb3J0IFRoZW1lUml2ZXJWaWV3IGZyb20gJy4vVGhlbWVSaXZlclZpZXcnO1xuaW1wb3J0IFRoZW1lUml2ZXJTZXJpZXNNb2RlbCBmcm9tICcuL1RoZW1lUml2ZXJTZXJpZXMnO1xuaW1wb3J0IHRoZW1lUml2ZXJMYXlvdXQgZnJvbSAnLi90aGVtZVJpdmVyTGF5b3V0JztcbmltcG9ydCBkYXRhRmlsdGVyIGZyb20gJy4uLy4uL3Byb2Nlc3Nvci9kYXRhRmlsdGVyJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDaGFydFZpZXcoVGhlbWVSaXZlclZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChUaGVtZVJpdmVyU2VyaWVzTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQodGhlbWVSaXZlckxheW91dCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByb2Nlc3NvcihkYXRhRmlsdGVyKCd0aGVtZVJpdmVyJykpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCAqIGFzIG51bWJlclV0aWwgZnJvbSAnLi4vLi4vdXRpbC9udW1iZXInO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGhlbWVSaXZlckxheW91dChlY01vZGVsLCBhcGkpIHtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCd0aGVtZVJpdmVyJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHNpbmdsZSA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGxheW91dEluZm8gPSB7fTsgLy8gdXNlIHRoZSBheGlzIGJvdW5kaW5nUmVjdCBmb3Igdmlld1xuXG4gICAgdmFyIHJlY3QgPSBzaW5nbGUuZ2V0UmVjdCgpO1xuICAgIGxheW91dEluZm8ucmVjdCA9IHJlY3Q7XG4gICAgdmFyIGJvdW5kYXJ5R2FwID0gc2VyaWVzTW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpO1xuICAgIHZhciBheGlzID0gc2luZ2xlLmdldEF4aXMoKTtcbiAgICBsYXlvdXRJbmZvLmJvdW5kYXJ5R2FwID0gYm91bmRhcnlHYXA7XG5cbiAgICBpZiAoYXhpcy5vcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgYm91bmRhcnlHYXBbMF0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFswXSwgcmVjdC5oZWlnaHQpO1xuICAgICAgYm91bmRhcnlHYXBbMV0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFsxXSwgcmVjdC5oZWlnaHQpO1xuICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0IC0gYm91bmRhcnlHYXBbMF0gLSBib3VuZGFyeUdhcFsxXTtcbiAgICAgIGRvVGhlbWVSaXZlckxheW91dChkYXRhLCBzZXJpZXNNb2RlbCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRhcnlHYXBbMF0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFswXSwgcmVjdC53aWR0aCk7XG4gICAgICBib3VuZGFyeUdhcFsxXSA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGJvdW5kYXJ5R2FwWzFdLCByZWN0LndpZHRoKTtcbiAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGggLSBib3VuZGFyeUdhcFswXSAtIGJvdW5kYXJ5R2FwWzFdO1xuICAgICAgZG9UaGVtZVJpdmVyTGF5b3V0KGRhdGEsIHNlcmllc01vZGVsLCB3aWR0aCk7XG4gICAgfVxuXG4gICAgZGF0YS5zZXRMYXlvdXQoJ2xheW91dEluZm8nLCBsYXlvdXRJbmZvKTtcbiAgfSk7XG59XG4vKipcbiAqIFRoZSBsYXlvdXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlbWVyaXZlclxuICpcbiAqIEBwYXJhbSBkYXRhICBkYXRhIGluIHRoZSBzZXJpZXNcbiAqIEBwYXJhbSBzZXJpZXNNb2RlbCAgdGhlIG1vZGVsIG9iamVjdCBvZiB0aGVtZVJpdmVyIHNlcmllc1xuICogQHBhcmFtIGhlaWdodCAgdmFsdWUgdXNlZCB0byBjb21wdXRlIGV2ZXJ5IHNlcmllcyBoZWlnaHRcbiAqL1xuXG5mdW5jdGlvbiBkb1RoZW1lUml2ZXJMYXlvdXQoZGF0YSwgc2VyaWVzTW9kZWwsIGhlaWdodCkge1xuICBpZiAoIWRhdGEuY291bnQoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07IC8vIHRoZSBkYXRhIGluIGVhY2ggbGF5ZXIgYXJlIG9yZ2FuaXplZCBpbnRvIGEgc2VyaWVzLlxuXG4gIHZhciBsYXllclNlcmllcyA9IHNlcmllc01vZGVsLmdldExheWVyU2VyaWVzKCk7IC8vIHRoZSBwb2ludHMgaW4gZWFjaCBsYXllci5cblxuICB2YXIgdGltZURpbSA9IGRhdGEubWFwRGltZW5zaW9uKCdzaW5nbGUnKTtcbiAgdmFyIHZhbHVlRGltID0gZGF0YS5tYXBEaW1lbnNpb24oJ3ZhbHVlJyk7XG4gIHZhciBsYXllclBvaW50cyA9IHpyVXRpbC5tYXAobGF5ZXJTZXJpZXMsIGZ1bmN0aW9uIChzaW5nbGVMYXllcikge1xuICAgIHJldHVybiB6clV0aWwubWFwKHNpbmdsZUxheWVyLmluZGljZXMsIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBwdCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KGRhdGEuZ2V0KHRpbWVEaW0sIGlkeCkpO1xuICAgICAgcHRbMV0gPSBkYXRhLmdldCh2YWx1ZURpbSwgaWR4KTtcbiAgICAgIHJldHVybiBwdDtcbiAgICB9KTtcbiAgfSk7XG4gIHZhciBiYXNlID0gY29tcHV0ZUJhc2VsaW5lKGxheWVyUG9pbnRzKTtcbiAgdmFyIGJhc2VMaW5lID0gYmFzZS55MDtcbiAgdmFyIGt5ID0gaGVpZ2h0IC8gYmFzZS5tYXg7IC8vIHNldCBsYXlvdXQgaW5mb3JtYXRpb24gZm9yIGVhY2ggaXRlbS5cblxuICB2YXIgbiA9IGxheWVyU2VyaWVzLmxlbmd0aDtcbiAgdmFyIG0gPSBsYXllclNlcmllc1swXS5pbmRpY2VzLmxlbmd0aDtcbiAgdmFyIGJhc2VZMDtcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGJhc2VZMCA9IGJhc2VMaW5lW2pdICoga3k7XG4gICAgZGF0YS5zZXRJdGVtTGF5b3V0KGxheWVyU2VyaWVzWzBdLmluZGljZXNbal0sIHtcbiAgICAgIGxheWVySW5kZXg6IDAsXG4gICAgICB4OiBsYXllclBvaW50c1swXVtqXVswXSxcbiAgICAgIHkwOiBiYXNlWTAsXG4gICAgICB5OiBsYXllclBvaW50c1swXVtqXVsxXSAqIGt5XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG47ICsraSkge1xuICAgICAgYmFzZVkwICs9IGxheWVyUG9pbnRzW2kgLSAxXVtqXVsxXSAqIGt5O1xuICAgICAgZGF0YS5zZXRJdGVtTGF5b3V0KGxheWVyU2VyaWVzW2ldLmluZGljZXNbal0sIHtcbiAgICAgICAgbGF5ZXJJbmRleDogaSxcbiAgICAgICAgeDogbGF5ZXJQb2ludHNbaV1bal1bMF0sXG4gICAgICAgIHkwOiBiYXNlWTAsXG4gICAgICAgIHk6IGxheWVyUG9pbnRzW2ldW2pdWzFdICoga3lcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBiYXNlTGluZSBvZiB0aGUgcmF3ZGF0YVxuICogSW5zcGlyZWQgYnkgTGVlIEJ5cm9uJ3MgcGFwZXIgU3RhY2tlZCBHcmFwaHMgLSBHZW9tZXRyeSAmIEFlc3RoZXRpY3NcbiAqXG4gKiBAcGFyYW0gIGRhdGEgIHRoZSBwb2ludHMgaW4gZWFjaCBsYXllclxuICovXG5cblxuZnVuY3Rpb24gY29tcHV0ZUJhc2VsaW5lKGRhdGEpIHtcbiAgdmFyIGxheWVyTnVtID0gZGF0YS5sZW5ndGg7XG4gIHZhciBwb2ludE51bSA9IGRhdGFbMF0ubGVuZ3RoO1xuICB2YXIgc3VtcyA9IFtdO1xuICB2YXIgeTAgPSBbXTtcbiAgdmFyIG1heCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludE51bTsgKytpKSB7XG4gICAgdmFyIHRlbXAgPSAwO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsYXllck51bTsgKytqKSB7XG4gICAgICB0ZW1wICs9IGRhdGFbal1baV1bMV07XG4gICAgfVxuXG4gICAgaWYgKHRlbXAgPiBtYXgpIHtcbiAgICAgIG1heCA9IHRlbXA7XG4gICAgfVxuXG4gICAgc3Vtcy5wdXNoKHRlbXApO1xuICB9XG5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBwb2ludE51bTsgKytrKSB7XG4gICAgeTBba10gPSAobWF4IC0gc3Vtc1trXSkgLyAyO1xuICB9XG5cbiAgbWF4ID0gMDtcblxuICBmb3IgKHZhciBsID0gMDsgbCA8IHBvaW50TnVtOyArK2wpIHtcbiAgICB2YXIgc3VtID0gc3Vtc1tsXSArIHkwW2xdO1xuXG4gICAgaWYgKHN1bSA+IG1heCkge1xuICAgICAgbWF4ID0gc3VtO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeTA6IHkwLFxuICAgIG1heDogbWF4XG4gIH07XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcyc7XG5pbXBvcnQgVHJlZSBmcm9tICcuLi8uLi9kYXRhL1RyZWUnO1xuaW1wb3J0IE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL01vZGVsJztcbmltcG9ydCB7IGNyZWF0ZVRvb2x0aXBNYXJrdXAgfSBmcm9tICcuLi8uLi9jb21wb25lbnQvdG9vbHRpcC90b29sdGlwTWFya3VwJztcblxudmFyIFRyZWVTZXJpZXNNb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUcmVlU2VyaWVzTW9kZWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gVHJlZVNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuaGFzU3ltYm9sVmlzdWFsID0gdHJ1ZTsgLy8gRG8gaXQgc2VsZi5cblxuICAgIF90aGlzLmlnbm9yZVN0eWxlT25EYXRhID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEluaXQgYSB0cmVlIGRhdGEgc3RydWN0dXJlIGZyb20gZGF0YSBpbiBvcHRpb24gc2VyaWVzXG4gICAqIEBwYXJhbSAgb3B0aW9uICB0aGUgb2JqZWN0IHVzZWQgdG8gY29uZmlnIGVjaGFydHMgdmlld1xuICAgKiBAcmV0dXJuIHN0b3JhZ2UgaW5pdGlhbCBkYXRhXG4gICAqL1xuXG5cbiAgVHJlZVNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YSA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAvL2NyZWF0ZSBhbiB2aXJ0dWFsIHJvb3RcbiAgICB2YXIgcm9vdCA9IHtcbiAgICAgIG5hbWU6IG9wdGlvbi5uYW1lLFxuICAgICAgY2hpbGRyZW46IG9wdGlvbi5kYXRhXG4gICAgfTtcbiAgICB2YXIgbGVhdmVzID0gb3B0aW9uLmxlYXZlcyB8fCB7fTtcbiAgICB2YXIgbGVhdmVzTW9kZWwgPSBuZXcgTW9kZWwobGVhdmVzLCB0aGlzLCB0aGlzLmVjTW9kZWwpO1xuICAgIHZhciB0cmVlID0gVHJlZS5jcmVhdGVUcmVlKHJvb3QsIHRoaXMsIGJlZm9yZUxpbmspO1xuXG4gICAgZnVuY3Rpb24gYmVmb3JlTGluayhub2RlRGF0YSkge1xuICAgICAgbm9kZURhdGEud3JhcE1ldGhvZCgnZ2V0SXRlbU1vZGVsJywgZnVuY3Rpb24gKG1vZGVsLCBpZHgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0cmVlLmdldE5vZGVCeURhdGFJbmRleChpZHgpO1xuXG4gICAgICAgIGlmICghbm9kZS5jaGlsZHJlbi5sZW5ndGggfHwgIW5vZGUuaXNFeHBhbmQpIHtcbiAgICAgICAgICBtb2RlbC5wYXJlbnRNb2RlbCA9IGxlYXZlc01vZGVsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHRyZWVEZXB0aCA9IDA7XG4gICAgdHJlZS5lYWNoTm9kZSgncHJlb3JkZXInLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKG5vZGUuZGVwdGggPiB0cmVlRGVwdGgpIHtcbiAgICAgICAgdHJlZURlcHRoID0gbm9kZS5kZXB0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgZXhwYW5kQW5kQ29sbGFwc2UgPSBvcHRpb24uZXhwYW5kQW5kQ29sbGFwc2U7XG4gICAgdmFyIGV4cGFuZFRyZWVEZXB0aCA9IGV4cGFuZEFuZENvbGxhcHNlICYmIG9wdGlvbi5pbml0aWFsVHJlZURlcHRoID49IDAgPyBvcHRpb24uaW5pdGlhbFRyZWVEZXB0aCA6IHRyZWVEZXB0aDtcbiAgICB0cmVlLnJvb3QuZWFjaE5vZGUoJ3ByZW9yZGVyJywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBpdGVtID0gbm9kZS5ob3N0VHJlZS5kYXRhLmdldFJhd0RhdGFJdGVtKG5vZGUuZGF0YUluZGV4KTsgLy8gQWRkIGl0ZW0uY29sbGFwc2VkICE9IG51bGwsIGJlY2F1c2UgdXNlcnMgY2FuIGNvbGxhcHNlIG5vZGUgb3JpZ2luYWwgaW4gdGhlIHNlcmllcy5kYXRhLlxuXG4gICAgICBub2RlLmlzRXhwYW5kID0gaXRlbSAmJiBpdGVtLmNvbGxhcHNlZCAhPSBudWxsID8gIWl0ZW0uY29sbGFwc2VkIDogbm9kZS5kZXB0aCA8PSBleHBhbmRUcmVlRGVwdGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRyZWUuZGF0YTtcbiAgfTtcbiAgLyoqXG4gICAqIE1ha2UgdGhlIGNvbmZpZ3VyYXRpb24gJ29yaWVudCcgYmFja3dhcmQgY29tcGF0aWJseSwgd2l0aCAnaG9yaXpvbnRhbCA9IExSJywgJ3ZlcnRpY2FsID0gVEInLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBvcmllbnRcbiAgICovXG5cblxuICBUcmVlU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldE9yaWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JpZW50ID0gdGhpcy5nZXQoJ29yaWVudCcpO1xuXG4gICAgaWYgKG9yaWVudCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICBvcmllbnQgPSAnTFInO1xuICAgIH0gZWxzZSBpZiAob3JpZW50ID09PSAndmVydGljYWwnKSB7XG4gICAgICBvcmllbnQgPSAnVEInO1xuICAgIH1cblxuICAgIHJldHVybiBvcmllbnQ7XG4gIH07XG5cbiAgVHJlZVNlcmllc01vZGVsLnByb3RvdHlwZS5zZXRab29tID0gZnVuY3Rpb24gKHpvb20pIHtcbiAgICB0aGlzLm9wdGlvbi56b29tID0gem9vbTtcbiAgfTtcblxuICBUcmVlU2VyaWVzTW9kZWwucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uIChjZW50ZXIpIHtcbiAgICB0aGlzLm9wdGlvbi5jZW50ZXIgPSBjZW50ZXI7XG4gIH07XG5cbiAgVHJlZVNlcmllc01vZGVsLnByb3RvdHlwZS5mb3JtYXRUb29sdGlwID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgbXVsdGlwbGVTZXJpZXMsIGRhdGFUeXBlKSB7XG4gICAgdmFyIHRyZWUgPSB0aGlzLmdldERhdGEoKS50cmVlO1xuICAgIHZhciByZWFsUm9vdCA9IHRyZWUucm9vdC5jaGlsZHJlblswXTtcbiAgICB2YXIgbm9kZSA9IHRyZWUuZ2V0Tm9kZUJ5RGF0YUluZGV4KGRhdGFJbmRleCk7XG4gICAgdmFyIHZhbHVlID0gbm9kZS5nZXRWYWx1ZSgpO1xuICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuXG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gcmVhbFJvb3QpIHtcbiAgICAgIG5hbWUgPSBub2RlLnBhcmVudE5vZGUubmFtZSArICcuJyArIG5hbWU7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVUb29sdGlwTWFya3VwKCduYW1lVmFsdWUnLCB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgbm9WYWx1ZTogaXNOYU4odmFsdWUpIHx8IHZhbHVlID09IG51bGxcbiAgICB9KTtcbiAgfTtcblxuICBUcmVlU2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMudHJlZSc7IC8vIGNhbiBzdXBwb3J0IHRoZSBwb3NpdGlvbiBwYXJhbWV0ZXJzICdsZWZ0JywgJ3RvcCcsJ3JpZ2h0JywnYm90dG9tJywgJ3dpZHRoJyxcbiAgLy8gJ2hlaWdodCcgaW4gdGhlIHNldE9wdGlvbigpIHdpdGggJ21lcmdlJyBtb2RlIG5vcm1hbC5cblxuICBUcmVlU2VyaWVzTW9kZWwubGF5b3V0TW9kZSA9ICdib3gnO1xuICBUcmVlU2VyaWVzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogMixcbiAgICBjb29yZGluYXRlU3lzdGVtOiAndmlldycsXG4gICAgLy8gdGhlIHBvc2l0aW9uIG9mIHRoZSB3aG9sZSB2aWV3XG4gICAgbGVmdDogJzEyJScsXG4gICAgdG9wOiAnMTIlJyxcbiAgICByaWdodDogJzEyJScsXG4gICAgYm90dG9tOiAnMTIlJyxcbiAgICAvLyB0aGUgbGF5b3V0IG9mIHRoZSB0cmVlLCB0d28gdmFsdWUgY2FuIGJlIHNlbGVjdGVkLCAnb3J0aG9nb25hbCcgb3IgJ3JhZGlhbCdcbiAgICBsYXlvdXQ6ICdvcnRob2dvbmFsJyxcbiAgICAvLyB2YWx1ZSBjYW4gYmUgJ3BvbHlsaW5lJ1xuICAgIGVkZ2VTaGFwZTogJ2N1cnZlJyxcbiAgICBlZGdlRm9ya1Bvc2l0aW9uOiAnNTAlJyxcbiAgICAvLyB0cnVlIHwgZmFsc2UgfCAnbW92ZScgfCAnc2NhbGUnLCBzZWUgbW9kdWxlOmNvbXBvbmVudC9oZWxwZXIvUm9hbUNvbnRyb2xsZXIuXG4gICAgcm9hbTogZmFsc2UsXG4gICAgLy8gU3ltYm9sIHNpemUgc2NhbGUgcmF0aW8gaW4gcm9hbVxuICAgIG5vZGVTY2FsZVJhdGlvOiAwLjQsXG4gICAgLy8gRGVmYXVsdCBvbiBjZW50ZXIgb2YgZ3JhcGhcbiAgICBjZW50ZXI6IG51bGwsXG4gICAgem9vbTogMSxcbiAgICBvcmllbnQ6ICdMUicsXG4gICAgc3ltYm9sOiAnZW1wdHlDaXJjbGUnLFxuICAgIHN5bWJvbFNpemU6IDcsXG4gICAgZXhwYW5kQW5kQ29sbGFwc2U6IHRydWUsXG4gICAgaW5pdGlhbFRyZWVEZXB0aDogMixcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnI2NjYycsXG4gICAgICB3aWR0aDogMS41LFxuICAgICAgY3VydmVuZXNzOiAwLjVcbiAgICB9LFxuICAgIGl0ZW1TdHlsZToge1xuICAgICAgY29sb3I6ICdsaWdodHN0ZWVsYmx1ZScsXG4gICAgICBib3JkZXJDb2xvcjogJyNjMjM1MzEnLFxuICAgICAgYm9yZGVyV2lkdGg6IDEuNVxuICAgIH0sXG4gICAgbGFiZWw6IHtcbiAgICAgIHNob3c6IHRydWVcbiAgICB9LFxuICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcicsXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDcwMCxcbiAgICBhbmltYXRpb25EdXJhdGlvblVwZGF0ZTogNTAwXG4gIH07XG4gIHJldHVybiBUcmVlU2VyaWVzTW9kZWw7XG59KFNlcmllc01vZGVsKTtcblxuZXhwb3J0IGRlZmF1bHQgVHJlZVNlcmllc01vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlJztcbmltcG9ydCBTeW1ib2xDbHogZnJvbSAnLi4vaGVscGVyL1N5bWJvbCc7XG5pbXBvcnQgeyByYWRpYWxDb29yZGluYXRlIH0gZnJvbSAnLi9sYXlvdXRIZWxwZXInO1xuaW1wb3J0ICogYXMgYmJveCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL2Jib3gnO1xuaW1wb3J0IFZpZXcgZnJvbSAnLi4vLi4vY29vcmQvVmlldyc7XG5pbXBvcnQgKiBhcyByb2FtSGVscGVyIGZyb20gJy4uLy4uL2NvbXBvbmVudC9oZWxwZXIvcm9hbUhlbHBlcic7XG5pbXBvcnQgUm9hbUNvbnRyb2xsZXIgZnJvbSAnLi4vLi4vY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlcic7XG5pbXBvcnQgeyBvbklycmVsZXZhbnRFbGVtZW50IH0gZnJvbSAnLi4vLi4vY29tcG9uZW50L2hlbHBlci9jdXJzb3JIZWxwZXInO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50IH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXInO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0JztcbmltcG9ydCBQYXRoIGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aCc7XG5pbXBvcnQgeyBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwsIHNldFN0YXRlc0ZsYWcsIHNldERlZmF1bHRTdGF0ZVByb3h5LCBIT1ZFUl9TVEFURV9CTFVSIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMnO1xuXG52YXIgVHJlZUVkZ2VTaGFwZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyZWVFZGdlU2hhcGUoKSB7XG4gICAgdGhpcy5wYXJlbnRQb2ludCA9IFtdO1xuICAgIHRoaXMuY2hpbGRQb2ludHMgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBUcmVlRWRnZVNoYXBlO1xufSgpO1xuXG52YXIgVHJlZVBhdGggPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVHJlZVBhdGgsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gVHJlZVBhdGgob3B0cykge1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICB9XG5cbiAgVHJlZVBhdGgucHJvdG90eXBlLmdldERlZmF1bHRTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgICBmaWxsOiBudWxsXG4gICAgfTtcbiAgfTtcblxuICBUcmVlUGF0aC5wcm90b3R5cGUuZ2V0RGVmYXVsdFNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgVHJlZUVkZ2VTaGFwZSgpO1xuICB9O1xuXG4gIFRyZWVQYXRoLnByb3RvdHlwZS5idWlsZFBhdGggPSBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciBjaGlsZFBvaW50cyA9IHNoYXBlLmNoaWxkUG9pbnRzO1xuICAgIHZhciBjaGlsZExlbiA9IGNoaWxkUG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgcGFyZW50UG9pbnQgPSBzaGFwZS5wYXJlbnRQb2ludDtcbiAgICB2YXIgZmlyc3RDaGlsZFBvcyA9IGNoaWxkUG9pbnRzWzBdO1xuICAgIHZhciBsYXN0Q2hpbGRQb3MgPSBjaGlsZFBvaW50c1tjaGlsZExlbiAtIDFdO1xuXG4gICAgaWYgKGNoaWxkTGVuID09PSAxKSB7XG4gICAgICBjdHgubW92ZVRvKHBhcmVudFBvaW50WzBdLCBwYXJlbnRQb2ludFsxXSk7XG4gICAgICBjdHgubGluZVRvKGZpcnN0Q2hpbGRQb3NbMF0sIGZpcnN0Q2hpbGRQb3NbMV0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvcmllbnQgPSBzaGFwZS5vcmllbnQ7XG4gICAgdmFyIGZvcmtEaW0gPSBvcmllbnQgPT09ICdUQicgfHwgb3JpZW50ID09PSAnQlQnID8gMCA6IDE7XG4gICAgdmFyIG90aGVyRGltID0gMSAtIGZvcmtEaW07XG4gICAgdmFyIGZvcmtQb3NpdGlvbiA9IHBhcnNlUGVyY2VudChzaGFwZS5mb3JrUG9zaXRpb24sIDEpO1xuICAgIHZhciB0bXBQb2ludCA9IFtdO1xuICAgIHRtcFBvaW50W2ZvcmtEaW1dID0gcGFyZW50UG9pbnRbZm9ya0RpbV07XG4gICAgdG1wUG9pbnRbb3RoZXJEaW1dID0gcGFyZW50UG9pbnRbb3RoZXJEaW1dICsgKGxhc3RDaGlsZFBvc1tvdGhlckRpbV0gLSBwYXJlbnRQb2ludFtvdGhlckRpbV0pICogZm9ya1Bvc2l0aW9uO1xuICAgIGN0eC5tb3ZlVG8ocGFyZW50UG9pbnRbMF0sIHBhcmVudFBvaW50WzFdKTtcbiAgICBjdHgubGluZVRvKHRtcFBvaW50WzBdLCB0bXBQb2ludFsxXSk7XG4gICAgY3R4Lm1vdmVUbyhmaXJzdENoaWxkUG9zWzBdLCBmaXJzdENoaWxkUG9zWzFdKTtcbiAgICB0bXBQb2ludFtmb3JrRGltXSA9IGZpcnN0Q2hpbGRQb3NbZm9ya0RpbV07XG4gICAgY3R4LmxpbmVUbyh0bXBQb2ludFswXSwgdG1wUG9pbnRbMV0pO1xuICAgIHRtcFBvaW50W2ZvcmtEaW1dID0gbGFzdENoaWxkUG9zW2ZvcmtEaW1dO1xuICAgIGN0eC5saW5lVG8odG1wUG9pbnRbMF0sIHRtcFBvaW50WzFdKTtcbiAgICBjdHgubGluZVRvKGxhc3RDaGlsZFBvc1swXSwgbGFzdENoaWxkUG9zWzFdKTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY2hpbGRMZW4gLSAxOyBpKyspIHtcbiAgICAgIHZhciBwb2ludCA9IGNoaWxkUG9pbnRzW2ldO1xuICAgICAgY3R4Lm1vdmVUbyhwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgdG1wUG9pbnRbZm9ya0RpbV0gPSBwb2ludFtmb3JrRGltXTtcbiAgICAgIGN0eC5saW5lVG8odG1wUG9pbnRbMF0sIHRtcFBvaW50WzFdKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRyZWVQYXRoO1xufShQYXRoKTtcblxudmFyIFRyZWVWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRyZWVWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFRyZWVWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IFRyZWVWaWV3LnR5cGU7XG4gICAgX3RoaXMuX21haW5Hcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgVHJlZVZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5fY29udHJvbGxlciA9IG5ldyBSb2FtQ29udHJvbGxlcihhcGkuZ2V0WnIoKSk7XG4gICAgdGhpcy5fY29udHJvbGxlckhvc3QgPSB7XG4gICAgICB0YXJnZXQ6IHRoaXMuZ3JvdXBcbiAgICB9O1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX21haW5Hcm91cCk7XG4gIH07XG5cbiAgVHJlZVZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGxheW91dEluZm8gPSBzZXJpZXNNb2RlbC5sYXlvdXRJbmZvO1xuICAgIHZhciBncm91cCA9IHRoaXMuX21haW5Hcm91cDtcbiAgICB2YXIgbGF5b3V0ID0gc2VyaWVzTW9kZWwuZ2V0KCdsYXlvdXQnKTtcblxuICAgIGlmIChsYXlvdXQgPT09ICdyYWRpYWwnKSB7XG4gICAgICBncm91cC54ID0gbGF5b3V0SW5mby54ICsgbGF5b3V0SW5mby53aWR0aCAvIDI7XG4gICAgICBncm91cC55ID0gbGF5b3V0SW5mby55ICsgbGF5b3V0SW5mby5oZWlnaHQgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cC54ID0gbGF5b3V0SW5mby54O1xuICAgICAgZ3JvdXAueSA9IGxheW91dEluZm8ueTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVWaWV3Q29vcmRTeXMoc2VyaWVzTW9kZWwpO1xuXG4gICAgdGhpcy5fdXBkYXRlQ29udHJvbGxlcihzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKTtcblxuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICBkYXRhLmRpZmYob2xkRGF0YSkuYWRkKGZ1bmN0aW9uIChuZXdJZHgpIHtcbiAgICAgIGlmIChzeW1ib2xOZWVkc0RyYXcoZGF0YSwgbmV3SWR4KSkge1xuICAgICAgICAvLyBDcmVhdGUgbm9kZSBhbmQgZWRnZVxuICAgICAgICB1cGRhdGVOb2RlKGRhdGEsIG5ld0lkeCwgbnVsbCwgZ3JvdXAsIHNlcmllc01vZGVsKTtcbiAgICAgIH1cbiAgICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgICB2YXIgc3ltYm9sRWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcblxuICAgICAgaWYgKCFzeW1ib2xOZWVkc0RyYXcoZGF0YSwgbmV3SWR4KSkge1xuICAgICAgICBzeW1ib2xFbCAmJiByZW1vdmVOb2RlKG9sZERhdGEsIG9sZElkeCwgc3ltYm9sRWwsIGdyb3VwLCBzZXJpZXNNb2RlbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gVXBkYXRlIG5vZGUgYW5kIGVkZ2VcblxuXG4gICAgICB1cGRhdGVOb2RlKGRhdGEsIG5ld0lkeCwgc3ltYm9sRWwsIGdyb3VwLCBzZXJpZXNNb2RlbCk7XG4gICAgfSkucmVtb3ZlKGZ1bmN0aW9uIChvbGRJZHgpIHtcbiAgICAgIHZhciBzeW1ib2xFbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpOyAvLyBXaGVuIHJlbW92ZSBhIGNvbGxhcHNlZCBub2RlIG9mIHN1YnRyZWUsIHNpbmNlIHRoZSBjb2xsYXBzZWRcbiAgICAgIC8vIG5vZGUgaGF2ZW4ndCBiZWVuIGluaXRpYWxpemVkIHdpdGggYSBzeW1ib2wgZWxlbWVudCxcbiAgICAgIC8vIHlvdSBjYW4ndCBmb3VuZCBpdCdzIHN5bWJvbCBlbGVtZW50IHRocm91Z2ggaW5kZXguXG4gICAgICAvLyBzbyBpZiB3ZSB3YW50IHRvIHJlbW92ZSB0aGUgc3ltYm9sIGVsZW1lbnQgd2Ugc2hvdWxkIGluc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgc3ltYm9sIGVsZW1lbnQgaXMgbm90IG51bGwuXG5cbiAgICAgIGlmIChzeW1ib2xFbCkge1xuICAgICAgICByZW1vdmVOb2RlKG9sZERhdGEsIG9sZElkeCwgc3ltYm9sRWwsIGdyb3VwLCBzZXJpZXNNb2RlbCk7XG4gICAgICB9XG4gICAgfSkuZXhlY3V0ZSgpO1xuICAgIHRoaXMuX25vZGVTY2FsZVJhdGlvID0gc2VyaWVzTW9kZWwuZ2V0KCdub2RlU2NhbGVSYXRpbycpO1xuXG4gICAgdGhpcy5fdXBkYXRlTm9kZUFuZExpbmtTY2FsZShzZXJpZXNNb2RlbCk7XG5cbiAgICBpZiAoc2VyaWVzTW9kZWwuZ2V0KCdleHBhbmRBbmRDb2xsYXBzZScpID09PSB0cnVlKSB7XG4gICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgZGF0YUluZGV4KSB7XG4gICAgICAgIGVsLm9mZignY2xpY2snKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICd0cmVlRXhwYW5kQW5kQ29sbGFwc2UnLFxuICAgICAgICAgICAgc2VyaWVzSWQ6IHNlcmllc01vZGVsLmlkLFxuICAgICAgICAgICAgZGF0YUluZGV4OiBkYXRhSW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfTtcblxuICBUcmVlVmlldy5wcm90b3R5cGUuX3VwZGF0ZVZpZXdDb29yZFN5cyA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuXG4gICAgICBpZiAobGF5b3V0ICYmICFpc05hTihsYXlvdXQueCkgJiYgIWlzTmFOKGxheW91dC55KSkge1xuICAgICAgICBwb2ludHMucHVzaChbK2xheW91dC54LCArbGF5b3V0LnldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbWluID0gW107XG4gICAgdmFyIG1heCA9IFtdO1xuICAgIGJib3guZnJvbVBvaW50cyhwb2ludHMsIG1pbiwgbWF4KTsgLy8gSWYgZG9uJ3QgU3RvcmUgbWluIG1heCB3aGVuIGNvbGxhcHNlIHRoZSByb290IG5vZGUgYWZ0ZXIgcm9hbSxcbiAgICAvLyB0aGUgcm9vdCBub2RlIHdpbGwgZGlzYXBwZWFyLlxuXG4gICAgdmFyIG9sZE1pbiA9IHRoaXMuX21pbjtcbiAgICB2YXIgb2xkTWF4ID0gdGhpcy5fbWF4OyAvLyBJZiB3aWR0aCBvciBoZWlnaHQgaXMgMFxuXG4gICAgaWYgKG1heFswXSAtIG1pblswXSA9PT0gMCkge1xuICAgICAgbWluWzBdID0gb2xkTWluID8gb2xkTWluWzBdIDogbWluWzBdIC0gMTtcbiAgICAgIG1heFswXSA9IG9sZE1heCA/IG9sZE1heFswXSA6IG1heFswXSArIDE7XG4gICAgfVxuXG4gICAgaWYgKG1heFsxXSAtIG1pblsxXSA9PT0gMCkge1xuICAgICAgbWluWzFdID0gb2xkTWluID8gb2xkTWluWzFdIDogbWluWzFdIC0gMTtcbiAgICAgIG1heFsxXSA9IG9sZE1heCA/IG9sZE1heFsxXSA6IG1heFsxXSArIDE7XG4gICAgfVxuXG4gICAgdmFyIHZpZXdDb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSBuZXcgVmlldygpO1xuICAgIHZpZXdDb29yZFN5cy56b29tTGltaXQgPSBzZXJpZXNNb2RlbC5nZXQoJ3NjYWxlTGltaXQnKTtcbiAgICB2aWV3Q29vcmRTeXMuc2V0Qm91bmRpbmdSZWN0KG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG4gICAgdmlld0Nvb3JkU3lzLnNldENlbnRlcihzZXJpZXNNb2RlbC5nZXQoJ2NlbnRlcicpKTtcbiAgICB2aWV3Q29vcmRTeXMuc2V0Wm9vbShzZXJpZXNNb2RlbC5nZXQoJ3pvb20nKSk7IC8vIEhlcmUgd2UgdXNlIHZpZXdDb29yZFN5cyBqdXN0IGZvciBjb21wdXRpbmcgdGhlICdwb3NpdGlvbicgYW5kICdzY2FsZScgb2YgdGhlIGdyb3VwXG5cbiAgICB0aGlzLmdyb3VwLmF0dHIoe1xuICAgICAgeDogdmlld0Nvb3JkU3lzLngsXG4gICAgICB5OiB2aWV3Q29vcmRTeXMueSxcbiAgICAgIHNjYWxlWDogdmlld0Nvb3JkU3lzLnNjYWxlWCxcbiAgICAgIHNjYWxlWTogdmlld0Nvb3JkU3lzLnNjYWxlWVxuICAgIH0pO1xuICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICB0aGlzLl9tYXggPSBtYXg7XG4gIH07XG5cbiAgVHJlZVZpZXcucHJvdG90eXBlLl91cGRhdGVDb250cm9sbGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVyO1xuICAgIHZhciBjb250cm9sbGVySG9zdCA9IHRoaXMuX2NvbnRyb2xsZXJIb3N0O1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgY29udHJvbGxlci5zZXRQb2ludGVyQ2hlY2tlcihmdW5jdGlvbiAoZSwgeCwgeSkge1xuICAgICAgdmFyIHJlY3QgPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgIHJlY3QuYXBwbHlUcmFuc2Zvcm0oZ3JvdXAudHJhbnNmb3JtKTtcbiAgICAgIHJldHVybiByZWN0LmNvbnRhaW4oeCwgeSkgJiYgIW9uSXJyZWxldmFudEVsZW1lbnQoZSwgYXBpLCBzZXJpZXNNb2RlbCk7XG4gICAgfSk7XG4gICAgY29udHJvbGxlci5lbmFibGUoc2VyaWVzTW9kZWwuZ2V0KCdyb2FtJykpO1xuICAgIGNvbnRyb2xsZXJIb3N0Lnpvb21MaW1pdCA9IHNlcmllc01vZGVsLmdldCgnc2NhbGVMaW1pdCcpO1xuICAgIGNvbnRyb2xsZXJIb3N0Lnpvb20gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFpvb20oKTtcbiAgICBjb250cm9sbGVyLm9mZigncGFuJykub2ZmKCd6b29tJykub24oJ3BhbicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICByb2FtSGVscGVyLnVwZGF0ZVZpZXdPblBhbihjb250cm9sbGVySG9zdCwgZS5keCwgZS5keSk7XG4gICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICBzZXJpZXNJZDogc2VyaWVzTW9kZWwuaWQsXG4gICAgICAgIHR5cGU6ICd0cmVlUm9hbScsXG4gICAgICAgIGR4OiBlLmR4LFxuICAgICAgICBkeTogZS5keVxuICAgICAgfSk7XG4gICAgfSkub24oJ3pvb20nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcm9hbUhlbHBlci51cGRhdGVWaWV3T25ab29tKGNvbnRyb2xsZXJIb3N0LCBlLnNjYWxlLCBlLm9yaWdpblgsIGUub3JpZ2luWSk7XG4gICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICBzZXJpZXNJZDogc2VyaWVzTW9kZWwuaWQsXG4gICAgICAgIHR5cGU6ICd0cmVlUm9hbScsXG4gICAgICAgIHpvb206IGUuc2NhbGUsXG4gICAgICAgIG9yaWdpblg6IGUub3JpZ2luWCxcbiAgICAgICAgb3JpZ2luWTogZS5vcmlnaW5ZXG4gICAgICB9KTtcblxuICAgICAgX3RoaXMuX3VwZGF0ZU5vZGVBbmRMaW5rU2NhbGUoc2VyaWVzTW9kZWwpOyAvLyBPbmx5IHVwZGF0ZSBsYWJlbCBsYXlvdXQgb24gem9vbVxuXG5cbiAgICAgIGFwaS51cGRhdGVMYWJlbExheW91dCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIFRyZWVWaWV3LnByb3RvdHlwZS5fdXBkYXRlTm9kZUFuZExpbmtTY2FsZSA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgdmFyIG5vZGVTY2FsZSA9IHRoaXMuX2dldE5vZGVHbG9iYWxTY2FsZShzZXJpZXNNb2RlbCk7XG5cbiAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICBlbC5zZXRTeW1ib2xTY2FsZShub2RlU2NhbGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIFRyZWVWaWV3LnByb3RvdHlwZS5fZ2V0Tm9kZUdsb2JhbFNjYWxlID0gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgIGlmIChjb29yZFN5cy50eXBlICE9PSAndmlldycpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHZhciBub2RlU2NhbGVSYXRpbyA9IHRoaXMuX25vZGVTY2FsZVJhdGlvO1xuICAgIHZhciBncm91cFpvb20gPSBjb29yZFN5cy5zY2FsZVggfHwgMTsgLy8gU2NhbGUgbm9kZSB3aGVuIHpvb20gY2hhbmdlc1xuXG4gICAgdmFyIHJvYW1ab29tID0gY29vcmRTeXMuZ2V0Wm9vbSgpO1xuICAgIHZhciBub2RlU2NhbGUgPSAocm9hbVpvb20gLSAxKSAqIG5vZGVTY2FsZVJhdGlvICsgMTtcbiAgICByZXR1cm4gbm9kZVNjYWxlIC8gZ3JvdXBab29tO1xuICB9O1xuXG4gIFRyZWVWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NvbnRyb2xsZXIgJiYgdGhpcy5fY29udHJvbGxlci5kaXNwb3NlKCk7XG4gICAgdGhpcy5fY29udHJvbGxlckhvc3QgPSBudWxsO1xuICB9O1xuXG4gIFRyZWVWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbWFpbkdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgdGhpcy5fZGF0YSA9IG51bGw7XG4gIH07XG5cbiAgVHJlZVZpZXcudHlwZSA9ICd0cmVlJztcbiAgcmV0dXJuIFRyZWVWaWV3O1xufShDaGFydFZpZXcpO1xuXG5mdW5jdGlvbiBzeW1ib2xOZWVkc0RyYXcoZGF0YSwgZGF0YUluZGV4KSB7XG4gIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KTtcbiAgcmV0dXJuIGxheW91dCAmJiAhaXNOYU4obGF5b3V0LngpICYmICFpc05hTihsYXlvdXQueSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5vZGUoZGF0YSwgZGF0YUluZGV4LCBzeW1ib2xFbCwgZ3JvdXAsIHNlcmllc01vZGVsKSB7XG4gIHZhciBpc0luaXQgPSAhc3ltYm9sRWw7XG4gIHZhciBub2RlID0gZGF0YS50cmVlLmdldE5vZGVCeURhdGFJbmRleChkYXRhSW5kZXgpO1xuICB2YXIgaXRlbU1vZGVsID0gbm9kZS5nZXRNb2RlbCgpO1xuICB2YXIgdmlzdWFsQ29sb3IgPSBub2RlLmdldFZpc3VhbCgnc3R5bGUnKS5maWxsO1xuICB2YXIgc3ltYm9sSW5uZXJDb2xvciA9IG5vZGUuaXNFeHBhbmQgPT09IGZhbHNlICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwID8gdmlzdWFsQ29sb3IgOiAnI2ZmZic7XG4gIHZhciB2aXJ0dWFsUm9vdCA9IGRhdGEudHJlZS5yb290O1xuICB2YXIgc291cmNlID0gbm9kZS5wYXJlbnROb2RlID09PSB2aXJ0dWFsUm9vdCA/IG5vZGUgOiBub2RlLnBhcmVudE5vZGUgfHwgbm9kZTtcbiAgdmFyIHNvdXJjZVN5bWJvbEVsID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKHNvdXJjZS5kYXRhSW5kZXgpO1xuICB2YXIgc291cmNlTGF5b3V0ID0gc291cmNlLmdldExheW91dCgpO1xuICB2YXIgc291cmNlT2xkTGF5b3V0ID0gc291cmNlU3ltYm9sRWwgPyB7XG4gICAgeDogc291cmNlU3ltYm9sRWwuX19vbGRYLFxuICAgIHk6IHNvdXJjZVN5bWJvbEVsLl9fb2xkWSxcbiAgICByYXdYOiBzb3VyY2VTeW1ib2xFbC5fX3JhZGlhbE9sZFJhd1gsXG4gICAgcmF3WTogc291cmNlU3ltYm9sRWwuX19yYWRpYWxPbGRSYXdZXG4gIH0gOiBzb3VyY2VMYXlvdXQ7XG4gIHZhciB0YXJnZXRMYXlvdXQgPSBub2RlLmdldExheW91dCgpO1xuXG4gIGlmIChpc0luaXQpIHtcbiAgICBzeW1ib2xFbCA9IG5ldyBTeW1ib2xDbHooZGF0YSwgZGF0YUluZGV4LCBudWxsLCB7XG4gICAgICBzeW1ib2xJbm5lckNvbG9yOiBzeW1ib2xJbm5lckNvbG9yLFxuICAgICAgdXNlTmFtZUxhYmVsOiB0cnVlXG4gICAgfSk7XG4gICAgc3ltYm9sRWwueCA9IHNvdXJjZU9sZExheW91dC54O1xuICAgIHN5bWJvbEVsLnkgPSBzb3VyY2VPbGRMYXlvdXQueTtcbiAgfSBlbHNlIHtcbiAgICBzeW1ib2xFbC51cGRhdGVEYXRhKGRhdGEsIGRhdGFJbmRleCwgbnVsbCwge1xuICAgICAgc3ltYm9sSW5uZXJDb2xvcjogc3ltYm9sSW5uZXJDb2xvcixcbiAgICAgIHVzZU5hbWVMYWJlbDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgc3ltYm9sRWwuX19yYWRpYWxPbGRSYXdYID0gc3ltYm9sRWwuX19yYWRpYWxSYXdYO1xuICBzeW1ib2xFbC5fX3JhZGlhbE9sZFJhd1kgPSBzeW1ib2xFbC5fX3JhZGlhbFJhd1k7XG4gIHN5bWJvbEVsLl9fcmFkaWFsUmF3WCA9IHRhcmdldExheW91dC5yYXdYO1xuICBzeW1ib2xFbC5fX3JhZGlhbFJhd1kgPSB0YXJnZXRMYXlvdXQucmF3WTtcbiAgZ3JvdXAuYWRkKHN5bWJvbEVsKTtcbiAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCwgc3ltYm9sRWwpO1xuICBzeW1ib2xFbC5fX29sZFggPSBzeW1ib2xFbC54O1xuICBzeW1ib2xFbC5fX29sZFkgPSBzeW1ib2xFbC55O1xuICBncmFwaGljLnVwZGF0ZVByb3BzKHN5bWJvbEVsLCB7XG4gICAgeDogdGFyZ2V0TGF5b3V0LngsXG4gICAgeTogdGFyZ2V0TGF5b3V0LnlcbiAgfSwgc2VyaWVzTW9kZWwpO1xuICB2YXIgc3ltYm9sUGF0aCA9IHN5bWJvbEVsLmdldFN5bWJvbFBhdGgoKTtcblxuICBpZiAoc2VyaWVzTW9kZWwuZ2V0KCdsYXlvdXQnKSA9PT0gJ3JhZGlhbCcpIHtcbiAgICB2YXIgcmVhbFJvb3QgPSB2aXJ0dWFsUm9vdC5jaGlsZHJlblswXTtcbiAgICB2YXIgcm9vdExheW91dCA9IHJlYWxSb290LmdldExheW91dCgpO1xuICAgIHZhciBsZW5ndGhfMSA9IHJlYWxSb290LmNoaWxkcmVuLmxlbmd0aDtcbiAgICB2YXIgcmFkID0gdm9pZCAwO1xuICAgIHZhciBpc0xlZnQgPSB2b2lkIDA7XG5cbiAgICBpZiAodGFyZ2V0TGF5b3V0LnggPT09IHJvb3RMYXlvdXQueCAmJiBub2RlLmlzRXhwYW5kID09PSB0cnVlKSB7XG4gICAgICB2YXIgY2VudGVyID0ge1xuICAgICAgICB4OiAocmVhbFJvb3QuY2hpbGRyZW5bMF0uZ2V0TGF5b3V0KCkueCArIHJlYWxSb290LmNoaWxkcmVuW2xlbmd0aF8xIC0gMV0uZ2V0TGF5b3V0KCkueCkgLyAyLFxuICAgICAgICB5OiAocmVhbFJvb3QuY2hpbGRyZW5bMF0uZ2V0TGF5b3V0KCkueSArIHJlYWxSb290LmNoaWxkcmVuW2xlbmd0aF8xIC0gMV0uZ2V0TGF5b3V0KCkueSkgLyAyXG4gICAgICB9O1xuICAgICAgcmFkID0gTWF0aC5hdGFuMihjZW50ZXIueSAtIHJvb3RMYXlvdXQueSwgY2VudGVyLnggLSByb290TGF5b3V0LngpO1xuXG4gICAgICBpZiAocmFkIDwgMCkge1xuICAgICAgICByYWQgPSBNYXRoLlBJICogMiArIHJhZDtcbiAgICAgIH1cblxuICAgICAgaXNMZWZ0ID0gY2VudGVyLnggPCByb290TGF5b3V0Lng7XG5cbiAgICAgIGlmIChpc0xlZnQpIHtcbiAgICAgICAgcmFkID0gcmFkIC0gTWF0aC5QSTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmFkID0gTWF0aC5hdGFuMih0YXJnZXRMYXlvdXQueSAtIHJvb3RMYXlvdXQueSwgdGFyZ2V0TGF5b3V0LnggLSByb290TGF5b3V0LngpO1xuXG4gICAgICBpZiAocmFkIDwgMCkge1xuICAgICAgICByYWQgPSBNYXRoLlBJICogMiArIHJhZDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIG5vZGUuaXNFeHBhbmQgPT09IGZhbHNlKSB7XG4gICAgICAgIGlzTGVmdCA9IHRhcmdldExheW91dC54IDwgcm9vdExheW91dC54O1xuXG4gICAgICAgIGlmIChpc0xlZnQpIHtcbiAgICAgICAgICByYWQgPSByYWQgLSBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0xlZnQgPSB0YXJnZXRMYXlvdXQueCA+IHJvb3RMYXlvdXQueDtcblxuICAgICAgICBpZiAoIWlzTGVmdCkge1xuICAgICAgICAgIHJhZCA9IHJhZCAtIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGV4dFBvc2l0aW9uID0gaXNMZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB2YXIgbm9ybWFsTGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwnKTtcbiAgICB2YXIgcm90YXRlID0gbm9ybWFsTGFiZWxNb2RlbC5nZXQoJ3JvdGF0ZScpO1xuICAgIHZhciBsYWJlbFJvdGF0ZVJhZGlhbiA9IHJvdGF0ZSAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICB2YXIgdGV4dENvbnRlbnQgPSBzeW1ib2xQYXRoLmdldFRleHRDb250ZW50KCk7XG5cbiAgICBpZiAodGV4dENvbnRlbnQpIHtcbiAgICAgIHN5bWJvbFBhdGguc2V0VGV4dENvbmZpZyh7XG4gICAgICAgIHBvc2l0aW9uOiBub3JtYWxMYWJlbE1vZGVsLmdldCgncG9zaXRpb24nKSB8fCB0ZXh0UG9zaXRpb24sXG4gICAgICAgIHJvdGF0aW9uOiByb3RhdGUgPT0gbnVsbCA/IC1yYWQgOiBsYWJlbFJvdGF0ZVJhZGlhbixcbiAgICAgICAgb3JpZ2luOiAnY2VudGVyJ1xuICAgICAgfSk7XG4gICAgICB0ZXh0Q29udGVudC5zZXRTdHlsZSgndmVydGljYWxBbGlnbicsICdtaWRkbGUnKTtcbiAgICB9XG4gIH0gLy8gSGFuZGxlIHN0YXR1c1xuXG5cbiAgdmFyIGZvY3VzID0gaXRlbU1vZGVsLmdldChbJ2VtcGhhc2lzJywgJ2ZvY3VzJ10pO1xuICB2YXIgZm9jdXNEYXRhSW5kaWNlcyA9IGZvY3VzID09PSAnYW5jZXN0b3InID8gbm9kZS5nZXRBbmNlc3RvcnNJbmRpY2VzKCkgOiBmb2N1cyA9PT0gJ2Rlc2NlbmRhbnQnID8gbm9kZS5nZXREZXNjZW5kYW50SW5kaWNlcygpIDogbnVsbDtcblxuICBpZiAoZm9jdXNEYXRhSW5kaWNlcykge1xuICAgIC8vIE1vZGlmeSB0aGUgZm9jdXMgdG8gZGF0YSBpbmRpY2VzLlxuICAgIGdldEVDRGF0YShzeW1ib2xFbCkuZm9jdXMgPSBmb2N1c0RhdGFJbmRpY2VzO1xuICB9XG5cbiAgZHJhd0VkZ2Uoc2VyaWVzTW9kZWwsIG5vZGUsIHZpcnR1YWxSb290LCBzeW1ib2xFbCwgc291cmNlT2xkTGF5b3V0LCBzb3VyY2VMYXlvdXQsIHRhcmdldExheW91dCwgZ3JvdXApO1xuXG4gIGlmIChzeW1ib2xFbC5fX2VkZ2UpIHtcbiAgICBzeW1ib2xFbC5vbkhvdmVyU3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAodG9TdGF0ZSkge1xuICAgICAgaWYgKHRvU3RhdGUgIT09ICdibHVyJykge1xuICAgICAgICAvLyBOT1RFOiBFbnN1cmUgdGhlIHBhcmVudCBlbGVtZW50cyB3aWxsIGJlZW4gYmx1cnJlZCBmaXJzdGx5LlxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHJldHVybiBvZiBnZXRBbmNlc3RvcnNJbmRpY2VzIGFuZCBnZXREZXNjZW5kYW50SW5kaWNlc1xuICAgICAgICAvLyBUT0RPOiBBIGJpdCB0cmlja3kuXG4gICAgICAgIHZhciBwYXJlbnRFbCA9IG5vZGUucGFyZW50Tm9kZSAmJiBkYXRhLmdldEl0ZW1HcmFwaGljRWwobm9kZS5wYXJlbnROb2RlLmRhdGFJbmRleCk7XG5cbiAgICAgICAgaWYgKCEocGFyZW50RWwgJiYgcGFyZW50RWwuaG92ZXJTdGF0ZSA9PT0gSE9WRVJfU1RBVEVfQkxVUikpIHtcbiAgICAgICAgICBzZXRTdGF0ZXNGbGFnKHN5bWJvbEVsLl9fZWRnZSwgdG9TdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdFZGdlKHNlcmllc01vZGVsLCBub2RlLCB2aXJ0dWFsUm9vdCwgc3ltYm9sRWwsIHNvdXJjZU9sZExheW91dCwgc291cmNlTGF5b3V0LCB0YXJnZXRMYXlvdXQsIGdyb3VwKSB7XG4gIHZhciBpdGVtTW9kZWwgPSBub2RlLmdldE1vZGVsKCk7XG4gIHZhciBlZGdlU2hhcGUgPSBzZXJpZXNNb2RlbC5nZXQoJ2VkZ2VTaGFwZScpO1xuICB2YXIgbGF5b3V0ID0gc2VyaWVzTW9kZWwuZ2V0KCdsYXlvdXQnKTtcbiAgdmFyIG9yaWVudCA9IHNlcmllc01vZGVsLmdldE9yaWVudCgpO1xuICB2YXIgY3VydmF0dXJlID0gc2VyaWVzTW9kZWwuZ2V0KFsnbGluZVN0eWxlJywgJ2N1cnZlbmVzcyddKTtcbiAgdmFyIGVkZ2VGb3JrUG9zaXRpb24gPSBzZXJpZXNNb2RlbC5nZXQoJ2VkZ2VGb3JrUG9zaXRpb24nKTtcbiAgdmFyIGxpbmVTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCk7XG4gIHZhciBlZGdlID0gc3ltYm9sRWwuX19lZGdlO1xuXG4gIGlmIChlZGdlU2hhcGUgPT09ICdjdXJ2ZScpIHtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlICYmIG5vZGUucGFyZW50Tm9kZSAhPT0gdmlydHVhbFJvb3QpIHtcbiAgICAgIGlmICghZWRnZSkge1xuICAgICAgICBlZGdlID0gc3ltYm9sRWwuX19lZGdlID0gbmV3IGdyYXBoaWMuQmV6aWVyQ3VydmUoe1xuICAgICAgICAgIHNoYXBlOiBnZXRFZGdlU2hhcGUobGF5b3V0LCBvcmllbnQsIGN1cnZhdHVyZSwgc291cmNlT2xkTGF5b3V0LCBzb3VyY2VPbGRMYXlvdXQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGVkZ2UsIHtcbiAgICAgICAgc2hhcGU6IGdldEVkZ2VTaGFwZShsYXlvdXQsIG9yaWVudCwgY3VydmF0dXJlLCBzb3VyY2VMYXlvdXQsIHRhcmdldExheW91dClcbiAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZWRnZVNoYXBlID09PSAncG9seWxpbmUnKSB7XG4gICAgaWYgKGxheW91dCA9PT0gJ29ydGhvZ29uYWwnKSB7XG4gICAgICBpZiAobm9kZSAhPT0gdmlydHVhbFJvb3QgJiYgbm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCAmJiBub2RlLmlzRXhwYW5kID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgIHZhciBjaGlsZFBvaW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGRMYXlvdXQgPSBjaGlsZHJlbltpXS5nZXRMYXlvdXQoKTtcbiAgICAgICAgICBjaGlsZFBvaW50cy5wdXNoKFtjaGlsZExheW91dC54LCBjaGlsZExheW91dC55XSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVkZ2UpIHtcbiAgICAgICAgICBlZGdlID0gc3ltYm9sRWwuX19lZGdlID0gbmV3IFRyZWVQYXRoKHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgIHBhcmVudFBvaW50OiBbdGFyZ2V0TGF5b3V0LngsIHRhcmdldExheW91dC55XSxcbiAgICAgICAgICAgICAgY2hpbGRQb2ludHM6IFtbdGFyZ2V0TGF5b3V0LngsIHRhcmdldExheW91dC55XV0sXG4gICAgICAgICAgICAgIG9yaWVudDogb3JpZW50LFxuICAgICAgICAgICAgICBmb3JrUG9zaXRpb246IGVkZ2VGb3JrUG9zaXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZWRnZSwge1xuICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBwYXJlbnRQb2ludDogW3RhcmdldExheW91dC54LCB0YXJnZXRMYXlvdXQueV0sXG4gICAgICAgICAgICBjaGlsZFBvaW50czogY2hpbGRQb2ludHNcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcG9seWxpbmUgZWRnZVNoYXBlIGNhbiBvbmx5IGJlIHVzZWQgaW4gb3J0aG9nb25hbCBsYXlvdXQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZWRnZSkge1xuICAgIGVkZ2UudXNlU3R5bGUoenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgIHN0cm9rZU5vU2NhbGU6IHRydWUsXG4gICAgICBmaWxsOiBudWxsXG4gICAgfSwgbGluZVN0eWxlKSk7XG4gICAgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsKGVkZ2UsIGl0ZW1Nb2RlbCwgJ2xpbmVTdHlsZScpO1xuICAgIHNldERlZmF1bHRTdGF0ZVByb3h5KGVkZ2UpO1xuICAgIGdyb3VwLmFkZChlZGdlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKGRhdGEsIGRhdGFJbmRleCwgc3ltYm9sRWwsIGdyb3VwLCBzZXJpZXNNb2RlbCkge1xuICB2YXIgbm9kZSA9IGRhdGEudHJlZS5nZXROb2RlQnlEYXRhSW5kZXgoZGF0YUluZGV4KTtcbiAgdmFyIHZpcnR1YWxSb290ID0gZGF0YS50cmVlLnJvb3Q7XG4gIHZhciBzb3VyY2UgPSBub2RlLnBhcmVudE5vZGUgPT09IHZpcnR1YWxSb290ID8gbm9kZSA6IG5vZGUucGFyZW50Tm9kZSB8fCBub2RlOyAvLyBsZXQgZWRnZVNoYXBlID0gc2VyaWVzU2NvcGUuZWRnZVNoYXBlO1xuXG4gIHZhciBzb3VyY2VMYXlvdXQ7XG5cbiAgd2hpbGUgKHNvdXJjZUxheW91dCA9IHNvdXJjZS5nZXRMYXlvdXQoKSwgc291cmNlTGF5b3V0ID09IG51bGwpIHtcbiAgICBzb3VyY2UgPSBzb3VyY2UucGFyZW50Tm9kZSA9PT0gdmlydHVhbFJvb3QgPyBzb3VyY2UgOiBzb3VyY2UucGFyZW50Tm9kZSB8fCBzb3VyY2U7XG4gIH0gLy8gVXNlIHNhbWUgZHVyYXRpb24gYW5kIGVhc2luZyB3aXRoIHVwZGF0ZSB0byBoYXZlIG1vcmUgY29uc2lzdGVudCBhbmltYXRpb24uXG5cblxuICB2YXIgcmVtb3ZlQW5pbWF0aW9uT3B0ID0ge1xuICAgIGR1cmF0aW9uOiBzZXJpZXNNb2RlbC5nZXQoJ2FuaW1hdGlvbkR1cmF0aW9uVXBkYXRlJyksXG4gICAgZWFzaW5nOiBzZXJpZXNNb2RlbC5nZXQoJ2FuaW1hdGlvbkVhc2luZ1VwZGF0ZScpXG4gIH07XG4gIGdyYXBoaWMucmVtb3ZlRWxlbWVudChzeW1ib2xFbCwge1xuICAgIHg6IHNvdXJjZUxheW91dC54ICsgMSxcbiAgICB5OiBzb3VyY2VMYXlvdXQueSArIDFcbiAgfSwgc2VyaWVzTW9kZWwsIHtcbiAgICBjYjogZnVuY3Rpb24gKCkge1xuICAgICAgZ3JvdXAucmVtb3ZlKHN5bWJvbEVsKTtcbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIG51bGwpO1xuICAgIH0sXG4gICAgcmVtb3ZlT3B0OiByZW1vdmVBbmltYXRpb25PcHRcbiAgfSk7XG4gIHN5bWJvbEVsLmZhZGVPdXQobnVsbCwge1xuICAgIGZhZGVMYWJlbDogdHJ1ZSxcbiAgICBhbmltYXRpb246IHJlbW92ZUFuaW1hdGlvbk9wdFxuICB9KTtcbiAgdmFyIHNvdXJjZVN5bWJvbEVsID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKHNvdXJjZS5kYXRhSW5kZXgpO1xuICB2YXIgc291cmNlRWRnZSA9IHNvdXJjZVN5bWJvbEVsLl9fZWRnZTsgLy8gMS4gd2hlbiBleHBhbmQgdGhlIHN1YiB0cmVlLCBkZWxldGUgdGhlIGNoaWxkcmVuIG5vZGUgc2hvdWxkIGRlbGV0ZSB0aGUgZWRnZSBvZlxuICAvLyB0aGUgc291cmNlIGF0IHRoZSBzYW1lIHRpbWUuIGJlY2F1c2UgdGhlIHBvbHlsaW5lIGVkZ2Ugc2hhcGUgaXMgb25seSBvd25lZCBieSB0aGUgc291cmNlLlxuICAvLyAyLndoZW4gdGhlIG5vZGUgaXMgdGhlIG9ubHkgY2hpbGRyZW4gb2YgdGhlIHNvdXJjZSwgZGVsZXRlIHRoZSBub2RlIHNob3VsZCBkZWxldGUgdGhlIGVkZ2Ugb2ZcbiAgLy8gdGhlIHNvdXJjZSBhdCB0aGUgc2FtZSB0aW1lLiB0aGUgc2FtZSByZWFzb24gYXMgYWJvdmUuXG5cbiAgdmFyIGVkZ2UgPSBzeW1ib2xFbC5fX2VkZ2UgfHwgKHNvdXJjZS5pc0V4cGFuZCA9PT0gZmFsc2UgfHwgc291cmNlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSA/IHNvdXJjZUVkZ2UgOiB1bmRlZmluZWQpO1xuICB2YXIgZWRnZVNoYXBlID0gc2VyaWVzTW9kZWwuZ2V0KCdlZGdlU2hhcGUnKTtcbiAgdmFyIGxheW91dE9wdCA9IHNlcmllc01vZGVsLmdldCgnbGF5b3V0Jyk7XG4gIHZhciBvcmllbnQgPSBzZXJpZXNNb2RlbC5nZXQoJ29yaWVudCcpO1xuICB2YXIgY3VydmF0dXJlID0gc2VyaWVzTW9kZWwuZ2V0KFsnbGluZVN0eWxlJywgJ2N1cnZlbmVzcyddKTtcblxuICBpZiAoZWRnZSkge1xuICAgIGlmIChlZGdlU2hhcGUgPT09ICdjdXJ2ZScpIHtcbiAgICAgIGdyYXBoaWMucmVtb3ZlRWxlbWVudChlZGdlLCB7XG4gICAgICAgIHNoYXBlOiBnZXRFZGdlU2hhcGUobGF5b3V0T3B0LCBvcmllbnQsIGN1cnZhdHVyZSwgc291cmNlTGF5b3V0LCBzb3VyY2VMYXlvdXQpLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfVxuICAgICAgfSwgc2VyaWVzTW9kZWwsIHtcbiAgICAgICAgY2I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBncm91cC5yZW1vdmUoZWRnZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZU9wdDogcmVtb3ZlQW5pbWF0aW9uT3B0XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGVkZ2VTaGFwZSA9PT0gJ3BvbHlsaW5lJyAmJiBzZXJpZXNNb2RlbC5nZXQoJ2xheW91dCcpID09PSAnb3J0aG9nb25hbCcpIHtcbiAgICAgIGdyYXBoaWMucmVtb3ZlRWxlbWVudChlZGdlLCB7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgcGFyZW50UG9pbnQ6IFtzb3VyY2VMYXlvdXQueCwgc291cmNlTGF5b3V0LnldLFxuICAgICAgICAgIGNoaWxkUG9pbnRzOiBbW3NvdXJjZUxheW91dC54LCBzb3VyY2VMYXlvdXQueV1dXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9XG4gICAgICB9LCBzZXJpZXNNb2RlbCwge1xuICAgICAgICBjYjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGdyb3VwLnJlbW92ZShlZGdlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlT3B0OiByZW1vdmVBbmltYXRpb25PcHRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFZGdlU2hhcGUobGF5b3V0T3B0LCBvcmllbnQsIGN1cnZhdHVyZSwgc291cmNlTGF5b3V0LCB0YXJnZXRMYXlvdXQpIHtcbiAgdmFyIGNweDE7XG4gIHZhciBjcHkxO1xuICB2YXIgY3B4MjtcbiAgdmFyIGNweTI7XG4gIHZhciB4MTtcbiAgdmFyIHgyO1xuICB2YXIgeTE7XG4gIHZhciB5MjtcblxuICBpZiAobGF5b3V0T3B0ID09PSAncmFkaWFsJykge1xuICAgIHgxID0gc291cmNlTGF5b3V0LnJhd1g7XG4gICAgeTEgPSBzb3VyY2VMYXlvdXQucmF3WTtcbiAgICB4MiA9IHRhcmdldExheW91dC5yYXdYO1xuICAgIHkyID0gdGFyZ2V0TGF5b3V0LnJhd1k7XG4gICAgdmFyIHJhZGlhbENvb3IxID0gcmFkaWFsQ29vcmRpbmF0ZSh4MSwgeTEpO1xuICAgIHZhciByYWRpYWxDb29yMiA9IHJhZGlhbENvb3JkaW5hdGUoeDEsIHkxICsgKHkyIC0geTEpICogY3VydmF0dXJlKTtcbiAgICB2YXIgcmFkaWFsQ29vcjMgPSByYWRpYWxDb29yZGluYXRlKHgyLCB5MiArICh5MSAtIHkyKSAqIGN1cnZhdHVyZSk7XG4gICAgdmFyIHJhZGlhbENvb3I0ID0gcmFkaWFsQ29vcmRpbmF0ZSh4MiwgeTIpO1xuICAgIHJldHVybiB7XG4gICAgICB4MTogcmFkaWFsQ29vcjEueCB8fCAwLFxuICAgICAgeTE6IHJhZGlhbENvb3IxLnkgfHwgMCxcbiAgICAgIHgyOiByYWRpYWxDb29yNC54IHx8IDAsXG4gICAgICB5MjogcmFkaWFsQ29vcjQueSB8fCAwLFxuICAgICAgY3B4MTogcmFkaWFsQ29vcjIueCB8fCAwLFxuICAgICAgY3B5MTogcmFkaWFsQ29vcjIueSB8fCAwLFxuICAgICAgY3B4MjogcmFkaWFsQ29vcjMueCB8fCAwLFxuICAgICAgY3B5MjogcmFkaWFsQ29vcjMueSB8fCAwXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB4MSA9IHNvdXJjZUxheW91dC54O1xuICAgIHkxID0gc291cmNlTGF5b3V0Lnk7XG4gICAgeDIgPSB0YXJnZXRMYXlvdXQueDtcbiAgICB5MiA9IHRhcmdldExheW91dC55O1xuXG4gICAgaWYgKG9yaWVudCA9PT0gJ0xSJyB8fCBvcmllbnQgPT09ICdSTCcpIHtcbiAgICAgIGNweDEgPSB4MSArICh4MiAtIHgxKSAqIGN1cnZhdHVyZTtcbiAgICAgIGNweTEgPSB5MTtcbiAgICAgIGNweDIgPSB4MiArICh4MSAtIHgyKSAqIGN1cnZhdHVyZTtcbiAgICAgIGNweTIgPSB5MjtcbiAgICB9XG5cbiAgICBpZiAob3JpZW50ID09PSAnVEInIHx8IG9yaWVudCA9PT0gJ0JUJykge1xuICAgICAgY3B4MSA9IHgxO1xuICAgICAgY3B5MSA9IHkxICsgKHkyIC0geTEpICogY3VydmF0dXJlO1xuICAgICAgY3B4MiA9IHgyO1xuICAgICAgY3B5MiA9IHkyICsgKHkxIC0geTIpICogY3VydmF0dXJlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDE6IHgxLFxuICAgIHkxOiB5MSxcbiAgICB4MjogeDIsXG4gICAgeTI6IHkyLFxuICAgIGNweDE6IGNweDEsXG4gICAgY3B5MTogY3B5MSxcbiAgICBjcHgyOiBjcHgyLFxuICAgIGNweTI6IGNweTJcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVHJlZVZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCBUcmVlVmlldyBmcm9tICcuL1RyZWVWaWV3JztcbmltcG9ydCBUcmVlU2VyaWVzTW9kZWwgZnJvbSAnLi9UcmVlU2VyaWVzJztcbmltcG9ydCB0cmVlTGF5b3V0IGZyb20gJy4vdHJlZUxheW91dCc7XG5pbXBvcnQgdHJlZVZpc3VhbCBmcm9tICcuL3RyZWVWaXN1YWwnO1xuaW1wb3J0IHsgaW5zdGFsbFRyZWVBY3Rpb24gfSBmcm9tICcuL3RyZWVBY3Rpb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhUcmVlVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclNlcmllc01vZGVsKFRyZWVTZXJpZXNNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckxheW91dCh0cmVlTGF5b3V0KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyVmlzdWFsKHRyZWVWaXN1YWwpO1xuICBpbnN0YWxsVHJlZUFjdGlvbihyZWdpc3RlcnMpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qXG4qIEEgdGhpcmQtcGFydHkgbGljZW5zZSBpcyBlbWJlZGVkIGZvciBzb21lIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZTpcbiogVGhlIHRyZWUgbGF5b3V0SGVscGVyIGltcGxlbWVudGF0aW9uIHdhcyBvcmlnaW5hbGx5IGNvcGllZCBmcm9tXG4qIFwiZDMuanNcIihodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtaGllcmFyY2h5KSB3aXRoXG4qIHNvbWUgbW9kaWZpY2F0aW9ucyBtYWRlIGZvciB0aGlzIHByb2plY3QuXG4qIChzZWUgbW9yZSBkZXRhaWxzIGluIHRoZSBjb21tZW50IG9mIHRoZSBzcGVjaWZpYyBtZXRob2QgYmVsb3cuKVxuKiBUaGUgdXNlIG9mIHRoZSBzb3VyY2UgY29kZSBvZiB0aGlzIGZpbGUgaXMgYWxzbyBzdWJqZWN0IHRvIHRoZSB0ZXJtc1xuKiBhbmQgY29uc2l0aW9ucyBvZiB0aGUgbGljZW5jZSBvZiBcImQzLmpzXCIgKEJTRC0zQ2xhdXNlLCBzZWVcbiogPC9saWNlbnNlcy9MSUNFTlNFLWQzPikuXG4qL1xuXG4vKipcbiAqIEBmaWxlIFRoZSBsYXlvdXQgYWxnb3JpdGhtIG9mIG5vZGUtbGluayB0cmVlIGRpYWdyYW1zLiBIZXJlIHdlIHVzaW5nIFJlaW5nb2xkLVRpbGZvcmQgYWxnb3JpdGhtIHRvIGRyYXdpbmdcbiAqICAgICAgIHRoZSB0cmVlLlxuICovXG5pbXBvcnQgKiBhcyBsYXlvdXQgZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQnO1xuLyoqXG4gKiBJbml0aWFsaXplIGFsbCBjb21wdXRhdGlvbmFsIG1lc3NhZ2UgZm9yIGZvbGxvd2luZyBhbGdvcml0aG0uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoaW5Sb290KSB7XG4gIHZhciByb290ID0gaW5Sb290O1xuICByb290LmhpZXJOb2RlID0ge1xuICAgIGRlZmF1bHRBbmNlc3RvcjogbnVsbCxcbiAgICBhbmNlc3Rvcjogcm9vdCxcbiAgICBwcmVsaW06IDAsXG4gICAgbW9kaWZpZXI6IDAsXG4gICAgY2hhbmdlOiAwLFxuICAgIHNoaWZ0OiAwLFxuICAgIGk6IDAsXG4gICAgdGhyZWFkOiBudWxsXG4gIH07XG4gIHZhciBub2RlcyA9IFtyb290XTtcbiAgdmFyIG5vZGU7XG4gIHZhciBjaGlsZHJlbjtcblxuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuXG4gICAgaWYgKG5vZGUuaXNFeHBhbmQgJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgbiA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IG4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgY2hpbGQuaGllck5vZGUgPSB7XG4gICAgICAgICAgZGVmYXVsdEFuY2VzdG9yOiBudWxsLFxuICAgICAgICAgIGFuY2VzdG9yOiBjaGlsZCxcbiAgICAgICAgICBwcmVsaW06IDAsXG4gICAgICAgICAgbW9kaWZpZXI6IDAsXG4gICAgICAgICAgY2hhbmdlOiAwLFxuICAgICAgICAgIHNoaWZ0OiAwLFxuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgdGhyZWFkOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIG5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiB3YXMgb3JpZ2luYWxseSBjb3BpZWQgZnJvbSBcImQzLmpzXCJcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtaGllcmFyY2h5L2Jsb2IvNGMxZjAzOGYyNzI1ZDZlYWUyZTQ5YjYxZDAxNDU2NDAwNjk0YmFjNC9zcmMvdHJlZS5qcz5cbiAqIHdpdGggc29tZSBtb2RpZmljYXRpb25zIG1hZGUgZm9yIHRoaXMgcHJvZ3JhbS5cbiAqIFNlZSB0aGUgbGljZW5zZSBzdGF0ZW1lbnQgYXQgdGhlIGhlYWQgb2YgdGhpcyBmaWxlLlxuICpcbiAqIENvbXB1dGVzIGEgcHJlbGltaW5hcnkgeCBjb29yZGluYXRlIGZvciBub2RlLiBCZWZvcmUgdGhhdCwgdGhpcyBmdW5jdGlvbiBpc1xuICogYXBwbGllZCByZWN1cnNpdmVseSB0byB0aGUgY2hpbGRyZW4gb2Ygbm9kZSwgYXMgd2VsbCBhcyB0aGUgZnVuY3Rpb25cbiAqIGFwcG9ydGlvbigpLiBBZnRlciBzcGFjaW5nIG91dCB0aGUgY2hpbGRyZW4gYnkgY2FsbGluZyBleGVjdXRlU2hpZnRzKCksIHRoZVxuICogbm9kZSBpcyBwbGFjZWQgdG8gdGhlIG1pZHBvaW50IG9mIGl0cyBvdXRlcm1vc3QgY2hpbGRyZW4uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0V2Fsayhub2RlLCBzZXBhcmF0aW9uKSB7XG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuaXNFeHBhbmQgPyBub2RlLmNoaWxkcmVuIDogW107XG4gIHZhciBzaWJsaW5ncyA9IG5vZGUucGFyZW50Tm9kZS5jaGlsZHJlbjtcbiAgdmFyIHN1YnRyZWVXID0gbm9kZS5oaWVyTm9kZS5pID8gc2libGluZ3Nbbm9kZS5oaWVyTm9kZS5pIC0gMV0gOiBudWxsO1xuXG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBleGVjdXRlU2hpZnRzKG5vZGUpO1xuICAgIHZhciBtaWRQb2ludCA9IChjaGlsZHJlblswXS5oaWVyTm9kZS5wcmVsaW0gKyBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS5oaWVyTm9kZS5wcmVsaW0pIC8gMjtcblxuICAgIGlmIChzdWJ0cmVlVykge1xuICAgICAgbm9kZS5oaWVyTm9kZS5wcmVsaW0gPSBzdWJ0cmVlVy5oaWVyTm9kZS5wcmVsaW0gKyBzZXBhcmF0aW9uKG5vZGUsIHN1YnRyZWVXKTtcbiAgICAgIG5vZGUuaGllck5vZGUubW9kaWZpZXIgPSBub2RlLmhpZXJOb2RlLnByZWxpbSAtIG1pZFBvaW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmhpZXJOb2RlLnByZWxpbSA9IG1pZFBvaW50O1xuICAgIH1cbiAgfSBlbHNlIGlmIChzdWJ0cmVlVykge1xuICAgIG5vZGUuaGllck5vZGUucHJlbGltID0gc3VidHJlZVcuaGllck5vZGUucHJlbGltICsgc2VwYXJhdGlvbihub2RlLCBzdWJ0cmVlVyk7XG4gIH1cblxuICBub2RlLnBhcmVudE5vZGUuaGllck5vZGUuZGVmYXVsdEFuY2VzdG9yID0gYXBwb3J0aW9uKG5vZGUsIHN1YnRyZWVXLCBub2RlLnBhcmVudE5vZGUuaGllck5vZGUuZGVmYXVsdEFuY2VzdG9yIHx8IHNpYmxpbmdzWzBdLCBzZXBhcmF0aW9uKTtcbn1cbi8qKlxuICogVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gd2FzIG9yaWdpbmFsbHkgY29waWVkIGZyb20gXCJkMy5qc1wiXG4gKiA8aHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWhpZXJhcmNoeS9ibG9iLzRjMWYwMzhmMjcyNWQ2ZWFlMmU0OWI2MWQwMTQ1NjQwMDY5NGJhYzQvc3JjL3RyZWUuanM+XG4gKiB3aXRoIHNvbWUgbW9kaWZpY2F0aW9ucyBtYWRlIGZvciB0aGlzIHByb2dyYW0uXG4gKiBTZWUgdGhlIGxpY2Vuc2Ugc3RhdGVtZW50IGF0IHRoZSBoZWFkIG9mIHRoaXMgZmlsZS5cbiAqXG4gKiBDb21wdXRlcyBhbGwgcmVhbCB4LWNvb3JkaW5hdGVzIGJ5IHN1bW1pbmcgdXAgdGhlIG1vZGlmaWVycyByZWN1cnNpdmVseS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2Vjb25kV2Fsayhub2RlKSB7XG4gIHZhciBub2RlWCA9IG5vZGUuaGllck5vZGUucHJlbGltICsgbm9kZS5wYXJlbnROb2RlLmhpZXJOb2RlLm1vZGlmaWVyO1xuICBub2RlLnNldExheW91dCh7XG4gICAgeDogbm9kZVhcbiAgfSwgdHJ1ZSk7XG4gIG5vZGUuaGllck5vZGUubW9kaWZpZXIgKz0gbm9kZS5wYXJlbnROb2RlLmhpZXJOb2RlLm1vZGlmaWVyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlcGFyYXRpb24oY2IpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjYiA6IGRlZmF1bHRTZXBhcmF0aW9uO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGNvbW1vbiBjb29yZGluYXRlIHRvIHJhZGlhbCBjb29yZGluYXRlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByYWRpYWxDb29yZGluYXRlKHJhZCwgcikge1xuICByYWQgLT0gTWF0aC5QSSAvIDI7XG4gIHJldHVybiB7XG4gICAgeDogciAqIE1hdGguY29zKHJhZCksXG4gICAgeTogciAqIE1hdGguc2luKHJhZClcbiAgfTtcbn1cbi8qKlxuICogR2V0IHRoZSBsYXlvdXQgcG9zaXRpb24gb2YgdGhlIHdob2xlIHZpZXcuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZpZXdSZWN0KHNlcmllc01vZGVsLCBhcGkpIHtcbiAgcmV0dXJuIGxheW91dC5nZXRMYXlvdXRSZWN0KHNlcmllc01vZGVsLmdldEJveExheW91dFBhcmFtcygpLCB7XG4gICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gIH0pO1xufVxuLyoqXG4gKiBBbGwgb3RoZXIgc2hpZnRzLCBhcHBsaWVkIHRvIHRoZSBzbWFsbGVyIHN1YnRyZWVzIGJldHdlZW4gdy0gYW5kIHcrLCBhcmVcbiAqIHBlcmZvcm1lZCBieSB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIHdhcyBvcmlnaW5hbGx5IGNvcGllZCBmcm9tIFwiZDMuanNcIlxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1oaWVyYXJjaHkvYmxvYi80YzFmMDM4ZjI3MjVkNmVhZTJlNDliNjFkMDE0NTY0MDA2OTRiYWM0L3NyYy90cmVlLmpzPlxuICogd2l0aCBzb21lIG1vZGlmaWNhdGlvbnMgbWFkZSBmb3IgdGhpcyBwcm9ncmFtLlxuICogU2VlIHRoZSBsaWNlbnNlIHN0YXRlbWVudCBhdCB0aGUgaGVhZCBvZiB0aGlzIGZpbGUuXG4gKi9cblxuZnVuY3Rpb24gZXhlY3V0ZVNoaWZ0cyhub2RlKSB7XG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gIHZhciBuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB2YXIgc2hpZnQgPSAwO1xuICB2YXIgY2hhbmdlID0gMDtcblxuICB3aGlsZSAoLS1uID49IDApIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltuXTtcbiAgICBjaGlsZC5oaWVyTm9kZS5wcmVsaW0gKz0gc2hpZnQ7XG4gICAgY2hpbGQuaGllck5vZGUubW9kaWZpZXIgKz0gc2hpZnQ7XG4gICAgY2hhbmdlICs9IGNoaWxkLmhpZXJOb2RlLmNoYW5nZTtcbiAgICBzaGlmdCArPSBjaGlsZC5oaWVyTm9kZS5zaGlmdCArIGNoYW5nZTtcbiAgfVxufVxuLyoqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiB3YXMgb3JpZ2luYWxseSBjb3BpZWQgZnJvbSBcImQzLmpzXCJcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtaGllcmFyY2h5L2Jsb2IvNGMxZjAzOGYyNzI1ZDZlYWUyZTQ5YjYxZDAxNDU2NDAwNjk0YmFjNC9zcmMvdHJlZS5qcz5cbiAqIHdpdGggc29tZSBtb2RpZmljYXRpb25zIG1hZGUgZm9yIHRoaXMgcHJvZ3JhbS5cbiAqIFNlZSB0aGUgbGljZW5zZSBzdGF0ZW1lbnQgYXQgdGhlIGhlYWQgb2YgdGhpcyBmaWxlLlxuICpcbiAqIFRoZSBjb3JlIG9mIHRoZSBhbGdvcml0aG0uIEhlcmUsIGEgbmV3IHN1YnRyZWUgaXMgY29tYmluZWQgd2l0aCB0aGVcbiAqIHByZXZpb3VzIHN1YnRyZWVzLiBUaHJlYWRzIGFyZSB1c2VkIHRvIHRyYXZlcnNlIHRoZSBpbnNpZGUgYW5kIG91dHNpZGVcbiAqIGNvbnRvdXJzIG9mIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlIHVwIHRvIHRoZSBoaWdoZXN0IGNvbW1vbiBsZXZlbC5cbiAqIFdoZW5ldmVyIHR3byBub2RlcyBvZiB0aGUgaW5zaWRlIGNvbnRvdXJzIGNvbmZsaWN0LCB3ZSBjb21wdXRlIHRoZSBsZWZ0XG4gKiBvbmUgb2YgdGhlIGdyZWF0ZXN0IHVuY29tbW9uIGFuY2VzdG9ycyB1c2luZyB0aGUgZnVuY3Rpb24gbmV4dEFuY2VzdG9yKClcbiAqIGFuZCBjYWxsIG1vdmVTdWJ0cmVlKCkgdG8gc2hpZnQgdGhlIHN1YnRyZWUgYW5kIHByZXBhcmUgdGhlIHNoaWZ0cyBvZlxuICogc21hbGxlciBzdWJ0cmVlcy4gRmluYWxseSwgd2UgYWRkIGEgbmV3IHRocmVhZCAoaWYgbmVjZXNzYXJ5KS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFwcG9ydGlvbihzdWJ0cmVlViwgc3VidHJlZVcsIGFuY2VzdG9yLCBzZXBhcmF0aW9uKSB7XG4gIGlmIChzdWJ0cmVlVykge1xuICAgIHZhciBub2RlT3V0UmlnaHQgPSBzdWJ0cmVlVjtcbiAgICB2YXIgbm9kZUluUmlnaHQgPSBzdWJ0cmVlVjtcbiAgICB2YXIgbm9kZU91dExlZnQgPSBub2RlSW5SaWdodC5wYXJlbnROb2RlLmNoaWxkcmVuWzBdO1xuICAgIHZhciBub2RlSW5MZWZ0ID0gc3VidHJlZVc7XG4gICAgdmFyIHN1bU91dFJpZ2h0ID0gbm9kZU91dFJpZ2h0LmhpZXJOb2RlLm1vZGlmaWVyO1xuICAgIHZhciBzdW1JblJpZ2h0ID0gbm9kZUluUmlnaHQuaGllck5vZGUubW9kaWZpZXI7XG4gICAgdmFyIHN1bU91dExlZnQgPSBub2RlT3V0TGVmdC5oaWVyTm9kZS5tb2RpZmllcjtcbiAgICB2YXIgc3VtSW5MZWZ0ID0gbm9kZUluTGVmdC5oaWVyTm9kZS5tb2RpZmllcjtcblxuICAgIHdoaWxlIChub2RlSW5MZWZ0ID0gbmV4dFJpZ2h0KG5vZGVJbkxlZnQpLCBub2RlSW5SaWdodCA9IG5leHRMZWZ0KG5vZGVJblJpZ2h0KSwgbm9kZUluTGVmdCAmJiBub2RlSW5SaWdodCkge1xuICAgICAgbm9kZU91dFJpZ2h0ID0gbmV4dFJpZ2h0KG5vZGVPdXRSaWdodCk7XG4gICAgICBub2RlT3V0TGVmdCA9IG5leHRMZWZ0KG5vZGVPdXRMZWZ0KTtcbiAgICAgIG5vZGVPdXRSaWdodC5oaWVyTm9kZS5hbmNlc3RvciA9IHN1YnRyZWVWO1xuICAgICAgdmFyIHNoaWZ0ID0gbm9kZUluTGVmdC5oaWVyTm9kZS5wcmVsaW0gKyBzdW1JbkxlZnQgLSBub2RlSW5SaWdodC5oaWVyTm9kZS5wcmVsaW0gLSBzdW1JblJpZ2h0ICsgc2VwYXJhdGlvbihub2RlSW5MZWZ0LCBub2RlSW5SaWdodCk7XG5cbiAgICAgIGlmIChzaGlmdCA+IDApIHtcbiAgICAgICAgbW92ZVN1YnRyZWUobmV4dEFuY2VzdG9yKG5vZGVJbkxlZnQsIHN1YnRyZWVWLCBhbmNlc3RvciksIHN1YnRyZWVWLCBzaGlmdCk7XG4gICAgICAgIHN1bUluUmlnaHQgKz0gc2hpZnQ7XG4gICAgICAgIHN1bU91dFJpZ2h0ICs9IHNoaWZ0O1xuICAgICAgfVxuXG4gICAgICBzdW1JbkxlZnQgKz0gbm9kZUluTGVmdC5oaWVyTm9kZS5tb2RpZmllcjtcbiAgICAgIHN1bUluUmlnaHQgKz0gbm9kZUluUmlnaHQuaGllck5vZGUubW9kaWZpZXI7XG4gICAgICBzdW1PdXRSaWdodCArPSBub2RlT3V0UmlnaHQuaGllck5vZGUubW9kaWZpZXI7XG4gICAgICBzdW1PdXRMZWZ0ICs9IG5vZGVPdXRMZWZ0LmhpZXJOb2RlLm1vZGlmaWVyO1xuICAgIH1cblxuICAgIGlmIChub2RlSW5MZWZ0ICYmICFuZXh0UmlnaHQobm9kZU91dFJpZ2h0KSkge1xuICAgICAgbm9kZU91dFJpZ2h0LmhpZXJOb2RlLnRocmVhZCA9IG5vZGVJbkxlZnQ7XG4gICAgICBub2RlT3V0UmlnaHQuaGllck5vZGUubW9kaWZpZXIgKz0gc3VtSW5MZWZ0IC0gc3VtT3V0UmlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG5vZGVJblJpZ2h0ICYmICFuZXh0TGVmdChub2RlT3V0TGVmdCkpIHtcbiAgICAgIG5vZGVPdXRMZWZ0LmhpZXJOb2RlLnRocmVhZCA9IG5vZGVJblJpZ2h0O1xuICAgICAgbm9kZU91dExlZnQuaGllck5vZGUubW9kaWZpZXIgKz0gc3VtSW5SaWdodCAtIHN1bU91dExlZnQ7XG4gICAgICBhbmNlc3RvciA9IHN1YnRyZWVWO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhbmNlc3Rvcjtcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHRyYXZlcnNlIHRoZSByaWdodCBjb250b3VyIG9mIGEgc3VidHJlZS5cbiAqIEl0IHJldHVybnMgdGhlIHJpZ2h0bW9zdCBjaGlsZCBvZiBub2RlIG9yIHRoZSB0aHJlYWQgb2Ygbm9kZS4gVGhlIGZ1bmN0aW9uXG4gKiByZXR1cm5zIG51bGwgaWYgYW5kIG9ubHkgaWYgbm9kZSBpcyBvbiB0aGUgaGlnaGVzdCBkZXB0aCBvZiBpdHMgc3VidHJlZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG5leHRSaWdodChub2RlKSB7XG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gIHJldHVybiBjaGlsZHJlbi5sZW5ndGggJiYgbm9kZS5pc0V4cGFuZCA/IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdIDogbm9kZS5oaWVyTm9kZS50aHJlYWQ7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byB0cmF2ZXJzZSB0aGUgbGVmdCBjb250b3VyIG9mIGEgc3VidHJlZSAob3IgYSBzdWJmb3Jlc3QpLlxuICogSXQgcmV0dXJucyB0aGUgbGVmdG1vc3QgY2hpbGQgb2Ygbm9kZSBvciB0aGUgdGhyZWFkIG9mIG5vZGUuIFRoZSBmdW5jdGlvblxuICogcmV0dXJucyBudWxsIGlmIGFuZCBvbmx5IGlmIG5vZGUgaXMgb24gdGhlIGhpZ2hlc3QgZGVwdGggb2YgaXRzIHN1YnRyZWUuXG4gKi9cblxuXG5mdW5jdGlvbiBuZXh0TGVmdChub2RlKSB7XG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gIHJldHVybiBjaGlsZHJlbi5sZW5ndGggJiYgbm9kZS5pc0V4cGFuZCA/IGNoaWxkcmVuWzBdIDogbm9kZS5oaWVyTm9kZS50aHJlYWQ7XG59XG4vKipcbiAqIElmIG5vZGVJbkxlZnTigJlzIGFuY2VzdG9yIGlzIGEgc2libGluZyBvZiBub2RlLCByZXR1cm5zIG5vZGVJbkxlZnTigJlzIGFuY2VzdG9yLlxuICogT3RoZXJ3aXNlLCByZXR1cm5zIHRoZSBzcGVjaWZpZWQgYW5jZXN0b3IuXG4gKi9cblxuXG5mdW5jdGlvbiBuZXh0QW5jZXN0b3Iobm9kZUluTGVmdCwgbm9kZSwgYW5jZXN0b3IpIHtcbiAgcmV0dXJuIG5vZGVJbkxlZnQuaGllck5vZGUuYW5jZXN0b3IucGFyZW50Tm9kZSA9PT0gbm9kZS5wYXJlbnROb2RlID8gbm9kZUluTGVmdC5oaWVyTm9kZS5hbmNlc3RvciA6IGFuY2VzdG9yO1xufVxuLyoqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiB3YXMgb3JpZ2luYWxseSBjb3BpZWQgZnJvbSBcImQzLmpzXCJcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtaGllcmFyY2h5L2Jsb2IvNGMxZjAzOGYyNzI1ZDZlYWUyZTQ5YjYxZDAxNDU2NDAwNjk0YmFjNC9zcmMvdHJlZS5qcz5cbiAqIHdpdGggc29tZSBtb2RpZmljYXRpb25zIG1hZGUgZm9yIHRoaXMgcHJvZ3JhbS5cbiAqIFNlZSB0aGUgbGljZW5zZSBzdGF0ZW1lbnQgYXQgdGhlIGhlYWQgb2YgdGhpcyBmaWxlLlxuICpcbiAqIFNoaWZ0cyB0aGUgY3VycmVudCBzdWJ0cmVlIHJvb3RlZCBhdCB3ci5cbiAqIFRoaXMgaXMgZG9uZSBieSBpbmNyZWFzaW5nIHByZWxpbSh3KykgYW5kIG1vZGlmaWVyKHcrKSBieSBzaGlmdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1vdmVTdWJ0cmVlKHdsLCB3ciwgc2hpZnQpIHtcbiAgdmFyIGNoYW5nZSA9IHNoaWZ0IC8gKHdyLmhpZXJOb2RlLmkgLSB3bC5oaWVyTm9kZS5pKTtcbiAgd3IuaGllck5vZGUuY2hhbmdlIC09IGNoYW5nZTtcbiAgd3IuaGllck5vZGUuc2hpZnQgKz0gc2hpZnQ7XG4gIHdyLmhpZXJOb2RlLm1vZGlmaWVyICs9IHNoaWZ0O1xuICB3ci5oaWVyTm9kZS5wcmVsaW0gKz0gc2hpZnQ7XG4gIHdsLmhpZXJOb2RlLmNoYW5nZSArPSBjaGFuZ2U7XG59XG4vKipcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIHdhcyBvcmlnaW5hbGx5IGNvcGllZCBmcm9tIFwiZDMuanNcIlxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1oaWVyYXJjaHkvYmxvYi80YzFmMDM4ZjI3MjVkNmVhZTJlNDliNjFkMDE0NTY0MDA2OTRiYWM0L3NyYy90cmVlLmpzPlxuICogd2l0aCBzb21lIG1vZGlmaWNhdGlvbnMgbWFkZSBmb3IgdGhpcyBwcm9ncmFtLlxuICogU2VlIHRoZSBsaWNlbnNlIHN0YXRlbWVudCBhdCB0aGUgaGVhZCBvZiB0aGlzIGZpbGUuXG4gKi9cblxuXG5mdW5jdGlvbiBkZWZhdWx0U2VwYXJhdGlvbihub2RlMSwgbm9kZTIpIHtcbiAgcmV0dXJuIG5vZGUxLnBhcmVudE5vZGUgPT09IG5vZGUyLnBhcmVudE5vZGUgPyAxIDogMjtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIFRyYXZlcnNlIHRoZSB0cmVlIGZyb20gYm90dG9tIHRvIHRvcCBhbmQgZG8gc29tZXRoaW5nXG4gKi9cbmZ1bmN0aW9uIGVhY2hBZnRlcihyb290LCBjYWxsYmFjaywgc2VwYXJhdGlvbikge1xuICB2YXIgbm9kZXMgPSBbcm9vdF07XG4gIHZhciBuZXh0ID0gW107XG4gIHZhciBub2RlO1xuXG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBuZXh0LnB1c2gobm9kZSk7XG5cbiAgICBpZiAobm9kZS5pc0V4cGFuZCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3aGlsZSAobm9kZSA9IG5leHQucG9wKCkpIHtcbiAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBjYWxsYmFjayhub2RlLCBzZXBhcmF0aW9uKTtcbiAgfVxufVxuLyoqXG4gKiBUcmF2ZXJzZSB0aGUgdHJlZSBmcm9tIHRvcCB0byBib3R0b20gYW5kIGRvIHNvbWV0aGluZ1xuICovXG5cblxuZnVuY3Rpb24gZWFjaEJlZm9yZShyb290LCBjYWxsYmFjaykge1xuICB2YXIgbm9kZXMgPSBbcm9vdF07XG4gIHZhciBub2RlO1xuXG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBjYWxsYmFjayhub2RlKTtcblxuICAgIGlmIChub2RlLmlzRXhwYW5kKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIG5vZGVzLnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IGVhY2hBZnRlciwgZWFjaEJlZm9yZSB9OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyB1cGRhdGVDZW50ZXJBbmRab29tIH0gZnJvbSAnLi4vLi4vYWN0aW9uL3JvYW1IZWxwZXInO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGxUcmVlQWN0aW9uKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oe1xuICAgIHR5cGU6ICd0cmVlRXhwYW5kQW5kQ29sbGFwc2UnLFxuICAgIGV2ZW50OiAndHJlZUV4cGFuZEFuZENvbGxhcHNlJyxcbiAgICB1cGRhdGU6ICd1cGRhdGUnXG4gIH0sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgIG1haW5UeXBlOiAnc2VyaWVzJyxcbiAgICAgIHN1YlR5cGU6ICd0cmVlJyxcbiAgICAgIHF1ZXJ5OiBwYXlsb2FkXG4gICAgfSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgZGF0YUluZGV4ID0gcGF5bG9hZC5kYXRhSW5kZXg7XG4gICAgICB2YXIgdHJlZSA9IHNlcmllc01vZGVsLmdldERhdGEoKS50cmVlO1xuICAgICAgdmFyIG5vZGUgPSB0cmVlLmdldE5vZGVCeURhdGFJbmRleChkYXRhSW5kZXgpO1xuICAgICAgbm9kZS5pc0V4cGFuZCA9ICFub2RlLmlzRXhwYW5kO1xuICAgIH0pO1xuICB9KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgICB0eXBlOiAndHJlZVJvYW0nLFxuICAgIGV2ZW50OiAndHJlZVJvYW0nLFxuICAgIC8vIEhlcmUgd2Ugc2V0ICdub25lJyBpbnN0ZWFkIG9mICd1cGRhdGUnLCBiZWNhdXNlIHJvYW0gYWN0aW9uXG4gICAgLy8ganVzdCBuZWVkIHRvIHVwZGF0ZSB0aGUgdHJhbnNmb3JtIG1hdHJpeCB3aXRob3V0IGhhdmluZyB0byByZWNhbGN1bGF0ZVxuICAgIC8vIHRoZSBsYXlvdXQuIFNvIGRvbid0IG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgdXBkYXRlIHByb2Nlc3MsIHN1Y2hcbiAgICAvLyBhcyAnZGF0YVByY29jZXNzJywgJ2Nvb3JkU3lzdGVtVXBkYXRlJywgJ2xheW91dCcgYW5kIHNvIG9uLlxuICAgIHVwZGF0ZTogJ25vbmUnXG4gIH0sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgIG1haW5UeXBlOiAnc2VyaWVzJyxcbiAgICAgIHN1YlR5cGU6ICd0cmVlJyxcbiAgICAgIHF1ZXJ5OiBwYXlsb2FkXG4gICAgfSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgdmFyIHJlcyA9IHVwZGF0ZUNlbnRlckFuZFpvb20oY29vcmRTeXMsIHBheWxvYWQpO1xuICAgICAgc2VyaWVzTW9kZWwuc2V0Q2VudGVyICYmIHNlcmllc01vZGVsLnNldENlbnRlcihyZXMuY2VudGVyKTtcbiAgICAgIHNlcmllc01vZGVsLnNldFpvb20gJiYgc2VyaWVzTW9kZWwuc2V0Wm9vbShyZXMuem9vbSk7XG4gICAgfSk7XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBlYWNoQWZ0ZXIsIGVhY2hCZWZvcmUgfSBmcm9tICcuL3RyYXZlcnNhbEhlbHBlcic7XG5pbXBvcnQgeyBpbml0LCBmaXJzdFdhbGssIHNlY29uZFdhbGssIHNlcGFyYXRpb24gYXMgc2VwLCByYWRpYWxDb29yZGluYXRlLCBnZXRWaWV3UmVjdCB9IGZyb20gJy4vbGF5b3V0SGVscGVyJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyZWVMYXlvdXQoZWNNb2RlbCwgYXBpKSB7XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgndHJlZScsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIGNvbW1vbkxheW91dChzZXJpZXNNb2RlbCwgYXBpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbW1vbkxheW91dChzZXJpZXNNb2RlbCwgYXBpKSB7XG4gIHZhciBsYXlvdXRJbmZvID0gZ2V0Vmlld1JlY3Qoc2VyaWVzTW9kZWwsIGFwaSk7XG4gIHNlcmllc01vZGVsLmxheW91dEluZm8gPSBsYXlvdXRJbmZvO1xuICB2YXIgbGF5b3V0ID0gc2VyaWVzTW9kZWwuZ2V0KCdsYXlvdXQnKTtcbiAgdmFyIHdpZHRoID0gMDtcbiAgdmFyIGhlaWdodCA9IDA7XG4gIHZhciBzZXBhcmF0aW9uID0gbnVsbDtcblxuICBpZiAobGF5b3V0ID09PSAncmFkaWFsJykge1xuICAgIHdpZHRoID0gMiAqIE1hdGguUEk7XG4gICAgaGVpZ2h0ID0gTWF0aC5taW4obGF5b3V0SW5mby5oZWlnaHQsIGxheW91dEluZm8ud2lkdGgpIC8gMjtcbiAgICBzZXBhcmF0aW9uID0gc2VwKGZ1bmN0aW9uIChub2RlMSwgbm9kZTIpIHtcbiAgICAgIHJldHVybiAobm9kZTEucGFyZW50Tm9kZSA9PT0gbm9kZTIucGFyZW50Tm9kZSA/IDEgOiAyKSAvIG5vZGUxLmRlcHRoO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gbGF5b3V0SW5mby53aWR0aDtcbiAgICBoZWlnaHQgPSBsYXlvdXRJbmZvLmhlaWdodDtcbiAgICBzZXBhcmF0aW9uID0gc2VwKCk7XG4gIH1cblxuICB2YXIgdmlydHVhbFJvb3QgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCkudHJlZS5yb290O1xuICB2YXIgcmVhbFJvb3QgPSB2aXJ0dWFsUm9vdC5jaGlsZHJlblswXTtcblxuICBpZiAocmVhbFJvb3QpIHtcbiAgICBpbml0KHZpcnR1YWxSb290KTtcbiAgICBlYWNoQWZ0ZXIocmVhbFJvb3QsIGZpcnN0V2Fsaywgc2VwYXJhdGlvbik7XG4gICAgdmlydHVhbFJvb3QuaGllck5vZGUubW9kaWZpZXIgPSAtcmVhbFJvb3QuaGllck5vZGUucHJlbGltO1xuICAgIGVhY2hCZWZvcmUocmVhbFJvb3QsIHNlY29uZFdhbGspO1xuICAgIHZhciBsZWZ0XzEgPSByZWFsUm9vdDtcbiAgICB2YXIgcmlnaHRfMSA9IHJlYWxSb290O1xuICAgIHZhciBib3R0b21fMSA9IHJlYWxSb290O1xuICAgIGVhY2hCZWZvcmUocmVhbFJvb3QsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgeCA9IG5vZGUuZ2V0TGF5b3V0KCkueDtcblxuICAgICAgaWYgKHggPCBsZWZ0XzEuZ2V0TGF5b3V0KCkueCkge1xuICAgICAgICBsZWZ0XzEgPSBub2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA+IHJpZ2h0XzEuZ2V0TGF5b3V0KCkueCkge1xuICAgICAgICByaWdodF8xID0gbm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuZGVwdGggPiBib3R0b21fMS5kZXB0aCkge1xuICAgICAgICBib3R0b21fMSA9IG5vZGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGRlbHRhID0gbGVmdF8xID09PSByaWdodF8xID8gMSA6IHNlcGFyYXRpb24obGVmdF8xLCByaWdodF8xKSAvIDI7XG4gICAgdmFyIHR4XzEgPSBkZWx0YSAtIGxlZnRfMS5nZXRMYXlvdXQoKS54O1xuICAgIHZhciBreF8xID0gMDtcbiAgICB2YXIga3lfMSA9IDA7XG4gICAgdmFyIGNvb3JYXzEgPSAwO1xuICAgIHZhciBjb29yWV8xID0gMDtcblxuICAgIGlmIChsYXlvdXQgPT09ICdyYWRpYWwnKSB7XG4gICAgICBreF8xID0gd2lkdGggLyAocmlnaHRfMS5nZXRMYXlvdXQoKS54ICsgZGVsdGEgKyB0eF8xKTsgLy8gaGVyZSB3ZSB1c2UgKG5vZGUuZGVwdGggLSAxKSwgYnVjYXVzZSB0aGUgcmVhbCByb290J3MgZGVwdGggaXMgMVxuXG4gICAgICBreV8xID0gaGVpZ2h0IC8gKGJvdHRvbV8xLmRlcHRoIC0gMSB8fCAxKTtcbiAgICAgIGVhY2hCZWZvcmUocmVhbFJvb3QsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGNvb3JYXzEgPSAobm9kZS5nZXRMYXlvdXQoKS54ICsgdHhfMSkgKiBreF8xO1xuICAgICAgICBjb29yWV8xID0gKG5vZGUuZGVwdGggLSAxKSAqIGt5XzE7XG4gICAgICAgIHZhciBmaW5hbENvb3IgPSByYWRpYWxDb29yZGluYXRlKGNvb3JYXzEsIGNvb3JZXzEpO1xuICAgICAgICBub2RlLnNldExheW91dCh7XG4gICAgICAgICAgeDogZmluYWxDb29yLngsXG4gICAgICAgICAgeTogZmluYWxDb29yLnksXG4gICAgICAgICAgcmF3WDogY29vclhfMSxcbiAgICAgICAgICByYXdZOiBjb29yWV8xXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvcmllbnRfMSA9IHNlcmllc01vZGVsLmdldE9yaWVudCgpO1xuXG4gICAgICBpZiAob3JpZW50XzEgPT09ICdSTCcgfHwgb3JpZW50XzEgPT09ICdMUicpIHtcbiAgICAgICAga3lfMSA9IGhlaWdodCAvIChyaWdodF8xLmdldExheW91dCgpLnggKyBkZWx0YSArIHR4XzEpO1xuICAgICAgICBreF8xID0gd2lkdGggLyAoYm90dG9tXzEuZGVwdGggLSAxIHx8IDEpO1xuICAgICAgICBlYWNoQmVmb3JlKHJlYWxSb290LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGNvb3JZXzEgPSAobm9kZS5nZXRMYXlvdXQoKS54ICsgdHhfMSkgKiBreV8xO1xuICAgICAgICAgIGNvb3JYXzEgPSBvcmllbnRfMSA9PT0gJ0xSJyA/IChub2RlLmRlcHRoIC0gMSkgKiBreF8xIDogd2lkdGggLSAobm9kZS5kZXB0aCAtIDEpICoga3hfMTtcbiAgICAgICAgICBub2RlLnNldExheW91dCh7XG4gICAgICAgICAgICB4OiBjb29yWF8xLFxuICAgICAgICAgICAgeTogY29vcllfMVxuICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob3JpZW50XzEgPT09ICdUQicgfHwgb3JpZW50XzEgPT09ICdCVCcpIHtcbiAgICAgICAga3hfMSA9IHdpZHRoIC8gKHJpZ2h0XzEuZ2V0TGF5b3V0KCkueCArIGRlbHRhICsgdHhfMSk7XG4gICAgICAgIGt5XzEgPSBoZWlnaHQgLyAoYm90dG9tXzEuZGVwdGggLSAxIHx8IDEpO1xuICAgICAgICBlYWNoQmVmb3JlKHJlYWxSb290LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGNvb3JYXzEgPSAobm9kZS5nZXRMYXlvdXQoKS54ICsgdHhfMSkgKiBreF8xO1xuICAgICAgICAgIGNvb3JZXzEgPSBvcmllbnRfMSA9PT0gJ1RCJyA/IChub2RlLmRlcHRoIC0gMSkgKiBreV8xIDogaGVpZ2h0IC0gKG5vZGUuZGVwdGggLSAxKSAqIGt5XzE7XG4gICAgICAgICAgbm9kZS5zZXRMYXlvdXQoe1xuICAgICAgICAgICAgeDogY29vclhfMSxcbiAgICAgICAgICAgIHk6IGNvb3JZXzFcbiAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmVlVmlzdWFsKGVjTW9kZWwpIHtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCd0cmVlJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHRyZWUgPSBkYXRhLnRyZWU7XG4gICAgdHJlZS5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIG1vZGVsID0gbm9kZS5nZXRNb2RlbCgpOyAvLyBUT0RPIE9wdGltaXplXG5cbiAgICAgIHZhciBzdHlsZSA9IG1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgIHZhciBleGlzdHNTdHlsZSA9IGRhdGEuZW5zdXJlVW5pcXVlSXRlbVZpc3VhbChub2RlLmRhdGFJbmRleCwgJ3N0eWxlJyk7XG4gICAgICBleHRlbmQoZXhpc3RzU3R5bGUsIHN0eWxlKTtcbiAgICB9KTtcbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZSc7XG5pbXBvcnQgKiBhcyBsYXlvdXQgZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQnO1xuaW1wb3J0IHsgd3JhcFRyZWVQYXRoSW5mbyB9IGZyb20gJy4uL2hlbHBlci90cmVlSGVscGVyJztcbmltcG9ydCB7IGN1cnJ5LCBkZWZhdWx0cyB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBjb252ZXJ0T3B0aW9uSWROYW1lIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG52YXIgVEVYVF9QQURESU5HID0gODtcbnZhciBJVEVNX0dBUCA9IDg7XG52YXIgQVJSQVlfTEVOR1RIID0gNTtcblxudmFyIEJyZWFkY3J1bWIgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCcmVhZGNydW1iKGNvbnRhaW5lckdyb3VwKSB7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgY29udGFpbmVyR3JvdXAuYWRkKHRoaXMuZ3JvdXApO1xuICB9XG5cbiAgQnJlYWRjcnVtYi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBhcGksIHRhcmdldE5vZGUsIG9uU2VsZWN0KSB7XG4gICAgdmFyIG1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2JyZWFkY3J1bWInKTtcbiAgICB2YXIgdGhpc0dyb3VwID0gdGhpcy5ncm91cDtcbiAgICB0aGlzR3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICBpZiAoIW1vZGVsLmdldCgnc2hvdycpIHx8ICF0YXJnZXROb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vcm1hbFN0eWxlTW9kZWwgPSBtb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJyk7IC8vIGxldCBlbXBoYXNpc1N0eWxlTW9kZWwgPSBtb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMuaXRlbVN0eWxlJyk7XG5cbiAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBub3JtYWxTdHlsZU1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICB2YXIgbGF5b3V0UGFyYW0gPSB7XG4gICAgICBwb3M6IHtcbiAgICAgICAgbGVmdDogbW9kZWwuZ2V0KCdsZWZ0JyksXG4gICAgICAgIHJpZ2h0OiBtb2RlbC5nZXQoJ3JpZ2h0JyksXG4gICAgICAgIHRvcDogbW9kZWwuZ2V0KCd0b3AnKSxcbiAgICAgICAgYm90dG9tOiBtb2RlbC5nZXQoJ2JvdHRvbScpXG4gICAgICB9LFxuICAgICAgYm94OiB7XG4gICAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICAgIH0sXG4gICAgICBlbXB0eUl0ZW1XaWR0aDogbW9kZWwuZ2V0KCdlbXB0eUl0ZW1XaWR0aCcpLFxuICAgICAgdG90YWxXaWR0aDogMCxcbiAgICAgIHJlbmRlckxpc3Q6IFtdXG4gICAgfTtcblxuICAgIHRoaXMuX3ByZXBhcmUodGFyZ2V0Tm9kZSwgbGF5b3V0UGFyYW0sIHRleHRTdHlsZU1vZGVsKTtcblxuICAgIHRoaXMuX3JlbmRlckNvbnRlbnQoc2VyaWVzTW9kZWwsIGxheW91dFBhcmFtLCBub3JtYWxTdHlsZU1vZGVsLCB0ZXh0U3R5bGVNb2RlbCwgb25TZWxlY3QpO1xuXG4gICAgbGF5b3V0LnBvc2l0aW9uRWxlbWVudCh0aGlzR3JvdXAsIGxheW91dFBhcmFtLnBvcywgbGF5b3V0UGFyYW0uYm94KTtcbiAgfTtcbiAgLyoqXG4gICAqIFByZXBhcmUgcmVuZGVyIGxpc3QgYW5kIHRvdGFsIHdpZHRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQnJlYWRjcnVtYi5wcm90b3R5cGUuX3ByZXBhcmUgPSBmdW5jdGlvbiAodGFyZ2V0Tm9kZSwgbGF5b3V0UGFyYW0sIHRleHRTdHlsZU1vZGVsKSB7XG4gICAgZm9yICh2YXIgbm9kZSA9IHRhcmdldE5vZGU7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIHZhciB0ZXh0ID0gY29udmVydE9wdGlvbklkTmFtZShub2RlLmdldE1vZGVsKCkuZ2V0KCduYW1lJyksICcnKTtcbiAgICAgIHZhciB0ZXh0UmVjdCA9IHRleHRTdHlsZU1vZGVsLmdldFRleHRSZWN0KHRleHQpO1xuICAgICAgdmFyIGl0ZW1XaWR0aCA9IE1hdGgubWF4KHRleHRSZWN0LndpZHRoICsgVEVYVF9QQURESU5HICogMiwgbGF5b3V0UGFyYW0uZW1wdHlJdGVtV2lkdGgpO1xuICAgICAgbGF5b3V0UGFyYW0udG90YWxXaWR0aCArPSBpdGVtV2lkdGggKyBJVEVNX0dBUDtcbiAgICAgIGxheW91dFBhcmFtLnJlbmRlckxpc3QucHVzaCh7XG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIHdpZHRoOiBpdGVtV2lkdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQnJlYWRjcnVtYi5wcm90b3R5cGUuX3JlbmRlckNvbnRlbnQgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGxheW91dFBhcmFtLCBub3JtYWxTdHlsZU1vZGVsLCB0ZXh0U3R5bGVNb2RlbCwgb25TZWxlY3QpIHtcbiAgICAvLyBTdGFydCByZW5kZXJpbmcuXG4gICAgdmFyIGxhc3RYID0gMDtcbiAgICB2YXIgZW1wdHlJdGVtV2lkdGggPSBsYXlvdXRQYXJhbS5lbXB0eUl0ZW1XaWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gc2VyaWVzTW9kZWwuZ2V0KFsnYnJlYWRjcnVtYicsICdoZWlnaHQnXSk7XG4gICAgdmFyIGF2YWlsYWJsZVNpemUgPSBsYXlvdXQuZ2V0QXZhaWxhYmxlU2l6ZShsYXlvdXRQYXJhbS5wb3MsIGxheW91dFBhcmFtLmJveCk7XG4gICAgdmFyIHRvdGFsV2lkdGggPSBsYXlvdXRQYXJhbS50b3RhbFdpZHRoO1xuICAgIHZhciByZW5kZXJMaXN0ID0gbGF5b3V0UGFyYW0ucmVuZGVyTGlzdDtcblxuICAgIGZvciAodmFyIGkgPSByZW5kZXJMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgaXRlbSA9IHJlbmRlckxpc3RbaV07XG4gICAgICB2YXIgaXRlbU5vZGUgPSBpdGVtLm5vZGU7XG4gICAgICB2YXIgaXRlbVdpZHRoID0gaXRlbS53aWR0aDtcbiAgICAgIHZhciB0ZXh0ID0gaXRlbS50ZXh0OyAvLyBIZGllIHRleHQgYW5kIHNob3J0ZW4gd2lkdGggaWYgbmVjZXNzYXJ5LlxuXG4gICAgICBpZiAodG90YWxXaWR0aCA+IGF2YWlsYWJsZVNpemUud2lkdGgpIHtcbiAgICAgICAgdG90YWxXaWR0aCAtPSBpdGVtV2lkdGggLSBlbXB0eUl0ZW1XaWR0aDtcbiAgICAgICAgaXRlbVdpZHRoID0gZW1wdHlJdGVtV2lkdGg7XG4gICAgICAgIHRleHQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWwgPSBuZXcgZ3JhcGhpYy5Qb2x5Z29uKHtcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICBwb2ludHM6IG1ha2VJdGVtUG9pbnRzKGxhc3RYLCAwLCBpdGVtV2lkdGgsIGhlaWdodCwgaSA9PT0gcmVuZGVyTGlzdC5sZW5ndGggLSAxLCBpID09PSAwKVxuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogZGVmYXVsdHMobm9ybWFsU3R5bGVNb2RlbC5nZXRJdGVtU3R5bGUoKSwge1xuICAgICAgICAgIGxpbmVKb2luOiAnYmV2ZWwnXG4gICAgICAgIH0pLFxuICAgICAgICB0ZXh0Q29udGVudDogbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICBmaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSxcbiAgICAgICAgICAgIGZvbnQ6IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIHRleHRDb25maWc6IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2luc2lkZSdcbiAgICAgICAgfSxcbiAgICAgICAgejogMTAsXG4gICAgICAgIG9uY2xpY2s6IGN1cnJ5KG9uU2VsZWN0LCBpdGVtTm9kZSlcbiAgICAgIH0pO1xuICAgICAgZWwuZGlzYWJsZUxhYmVsQW5pbWF0aW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuZ3JvdXAuYWRkKGVsKTtcbiAgICAgIHBhY2tFdmVudERhdGEoZWwsIHNlcmllc01vZGVsLCBpdGVtTm9kZSk7XG4gICAgICBsYXN0WCArPSBpdGVtV2lkdGggKyBJVEVNX0dBUDtcbiAgICB9XG4gIH07XG5cbiAgQnJlYWRjcnVtYi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gIH07XG5cbiAgcmV0dXJuIEJyZWFkY3J1bWI7XG59KCk7XG5cbmZ1bmN0aW9uIG1ha2VJdGVtUG9pbnRzKHgsIHksIGl0ZW1XaWR0aCwgaXRlbUhlaWdodCwgaGVhZCwgdGFpbCkge1xuICB2YXIgcG9pbnRzID0gW1toZWFkID8geCA6IHggLSBBUlJBWV9MRU5HVEgsIHldLCBbeCArIGl0ZW1XaWR0aCwgeV0sIFt4ICsgaXRlbVdpZHRoLCB5ICsgaXRlbUhlaWdodF0sIFtoZWFkID8geCA6IHggLSBBUlJBWV9MRU5HVEgsIHkgKyBpdGVtSGVpZ2h0XV07XG4gICF0YWlsICYmIHBvaW50cy5zcGxpY2UoMiwgMCwgW3ggKyBpdGVtV2lkdGggKyBBUlJBWV9MRU5HVEgsIHkgKyBpdGVtSGVpZ2h0IC8gMl0pO1xuICAhaGVhZCAmJiBwb2ludHMucHVzaChbeCwgeSArIGl0ZW1IZWlnaHQgLyAyXSk7XG4gIHJldHVybiBwb2ludHM7XG59IC8vIFBhY2thZ2UgY3VzdG9tIG1vdXNlIGV2ZW50LlxuXG5cbmZ1bmN0aW9uIHBhY2tFdmVudERhdGEoZWwsIHNlcmllc01vZGVsLCBpdGVtTm9kZSkge1xuICBnZXRFQ0RhdGEoZWwpLmV2ZW50RGF0YSA9IHtcbiAgICBjb21wb25lbnRUeXBlOiAnc2VyaWVzJyxcbiAgICBjb21wb25lbnRTdWJUeXBlOiAndHJlZW1hcCcsXG4gICAgY29tcG9uZW50SW5kZXg6IHNlcmllc01vZGVsLmNvbXBvbmVudEluZGV4LFxuICAgIHNlcmllc0luZGV4OiBzZXJpZXNNb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICBzZXJpZXNOYW1lOiBzZXJpZXNNb2RlbC5uYW1lLFxuICAgIHNlcmllc1R5cGU6ICd0cmVlbWFwJyxcbiAgICBzZWxmVHlwZTogJ2JyZWFkY3J1bWInLFxuICAgIG5vZGVEYXRhOiB7XG4gICAgICBkYXRhSW5kZXg6IGl0ZW1Ob2RlICYmIGl0ZW1Ob2RlLmRhdGFJbmRleCxcbiAgICAgIG5hbWU6IGl0ZW1Ob2RlICYmIGl0ZW1Ob2RlLm5hbWVcbiAgICB9LFxuICAgIHRyZWVQYXRoSW5mbzogaXRlbU5vZGUgJiYgd3JhcFRyZWVQYXRoSW5mbyhpdGVtTm9kZSwgc2VyaWVzTW9kZWwpXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJyZWFkY3J1bWI7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgU2VyaWVzTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvU2VyaWVzJztcbmltcG9ydCBUcmVlIGZyb20gJy4uLy4uL2RhdGEvVHJlZSc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvTW9kZWwnO1xuaW1wb3J0IHsgd3JhcFRyZWVQYXRoSW5mbyB9IGZyb20gJy4uL2hlbHBlci90cmVlSGVscGVyJztcbmltcG9ydCB7IG5vcm1hbGl6ZVRvQXJyYXkgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbmltcG9ydCB7IGNyZWF0ZVRvb2x0aXBNYXJrdXAgfSBmcm9tICcuLi8uLi9jb21wb25lbnQvdG9vbHRpcC90b29sdGlwTWFya3VwJztcbmltcG9ydCBlbmFibGVBcmlhRGVjYWxGb3JUcmVlIGZyb20gJy4uL2hlbHBlci9lbmFibGVBcmlhRGVjYWxGb3JUcmVlJztcblxudmFyIFRyZWVtYXBTZXJpZXNNb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUcmVlbWFwU2VyaWVzTW9kZWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gVHJlZW1hcFNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IFRyZWVtYXBTZXJpZXNNb2RlbC50eXBlO1xuICAgIF90aGlzLnByZXZlbnRVc2luZ0hvdmVyTGF5ZXIgPSB0cnVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgVHJlZW1hcFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YSA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICAvLyBDcmVhdGUgYSB2aXJ0dWFsIHJvb3QuXG4gICAgdmFyIHJvb3QgPSB7XG4gICAgICBuYW1lOiBvcHRpb24ubmFtZSxcbiAgICAgIGNoaWxkcmVuOiBvcHRpb24uZGF0YVxuICAgIH07XG4gICAgY29tcGxldGVUcmVlVmFsdWUocm9vdCk7XG4gICAgdmFyIGxldmVscyA9IG9wdGlvbi5sZXZlbHMgfHwgW107IC8vIFVzZWQgaW4gXCJ2aXN1YWwgcHJpb3JpdHlcIiBpbiBgdHJlZW1hcFZpc3VhbC5qc2AuXG4gICAgLy8gVGhpcyB3YXkgaXMgYSBsaXR0bGUgdHJpY2t5LCBtdXN0IHNhdGlzZnkgdGhlIHByZWNvbmRpdGlvbjpcbiAgICAvLyAgIDEuIFRoZXJlIGlzIG5vIGB0cmVlTm9kZS5nZXRNb2RlbCgnaXRlbVN0eWxlLnh4eCcpYCB1c2VkLlxuICAgIC8vICAgMi4gVGhlIGBNb2RlbC5wcm90b3R5cGUuZ2V0TW9kZWwoKWAgd2lsbCBub3QgdXNlIGFueSBjbG9uZS1saWtlIHdheS5cblxuICAgIHZhciBkZXNpZ25hdGVkVmlzdWFsSXRlbVN0eWxlID0gdGhpcy5kZXNpZ25hdGVkVmlzdWFsSXRlbVN0eWxlID0ge307XG4gICAgdmFyIGRlc2lnbmF0ZWRWaXN1YWxNb2RlbCA9IG5ldyBNb2RlbCh7XG4gICAgICBpdGVtU3R5bGU6IGRlc2lnbmF0ZWRWaXN1YWxJdGVtU3R5bGVcbiAgICB9LCB0aGlzLCBlY01vZGVsKTtcbiAgICBsZXZlbHMgPSBvcHRpb24ubGV2ZWxzID0gc2V0RGVmYXVsdChsZXZlbHMsIGVjTW9kZWwpO1xuICAgIHZhciBsZXZlbE1vZGVscyA9IHpyVXRpbC5tYXAobGV2ZWxzIHx8IFtdLCBmdW5jdGlvbiAobGV2ZWxEZWZpbmUpIHtcbiAgICAgIHJldHVybiBuZXcgTW9kZWwobGV2ZWxEZWZpbmUsIGRlc2lnbmF0ZWRWaXN1YWxNb2RlbCwgZWNNb2RlbCk7XG4gICAgfSwgdGhpcyk7IC8vIE1ha2Ugc3VyZSBhbHdheXMgYSBuZXcgdHJlZSBpcyBjcmVhdGVkIHdoZW4gc2V0T3B0aW9uLFxuICAgIC8vIGluIFRyZWVtYXBWaWV3LCB3ZSBjaGVjayB3aGV0aGVyIG9sZFRyZWUgPT09IG5ld1RyZWVcbiAgICAvLyB0byBjaG9vc2UgbWFwcGluZ3MgYXBwcm9hY2ggYW1vbmcgb2xkIHNoYXBlcyBhbmQgbmV3IHNoYXBlcy5cblxuICAgIHZhciB0cmVlID0gVHJlZS5jcmVhdGVUcmVlKHJvb3QsIHRoaXMsIGJlZm9yZUxpbmspO1xuXG4gICAgZnVuY3Rpb24gYmVmb3JlTGluayhub2RlRGF0YSkge1xuICAgICAgbm9kZURhdGEud3JhcE1ldGhvZCgnZ2V0SXRlbU1vZGVsJywgZnVuY3Rpb24gKG1vZGVsLCBpZHgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0cmVlLmdldE5vZGVCeURhdGFJbmRleChpZHgpO1xuICAgICAgICB2YXIgbGV2ZWxNb2RlbCA9IGxldmVsTW9kZWxzW25vZGUuZGVwdGhdOyAvLyBJZiBubyBsZXZlbE1vZGVsLCB3ZSBhbHNvIG5lZWQgYGRlc2lnbmF0ZWRWaXN1YWxNb2RlbGAuXG5cbiAgICAgICAgbW9kZWwucGFyZW50TW9kZWwgPSBsZXZlbE1vZGVsIHx8IGRlc2lnbmF0ZWRWaXN1YWxNb2RlbDtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyZWUuZGF0YTtcbiAgfTtcblxuICBUcmVlbWFwU2VyaWVzTW9kZWwucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXNldFZpZXdSb290KCk7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttdXRpcGxlU2VyaWVzPWZhbHNlXVxuICAgKi9cblxuXG4gIFRyZWVtYXBTZXJpZXNNb2RlbC5wcm90b3R5cGUuZm9ybWF0VG9vbHRpcCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIG11bHRpcGxlU2VyaWVzLCBkYXRhVHlwZSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXRSYXdWYWx1ZShkYXRhSW5kZXgpO1xuICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCk7XG4gICAgcmV0dXJuIGNyZWF0ZVRvb2x0aXBNYXJrdXAoJ25hbWVWYWx1ZScsIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIEFkZCB0cmVlIHBhdGggdG8gdG9vbHRpcCBwYXJhbVxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG5cbiAgVHJlZW1hcFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXREYXRhUGFyYW1zID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgIHZhciBwYXJhbXMgPSBfc3VwZXIucHJvdG90eXBlLmdldERhdGFQYXJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHZhciBub2RlID0gdGhpcy5nZXREYXRhKCkudHJlZS5nZXROb2RlQnlEYXRhSW5kZXgoZGF0YUluZGV4KTtcbiAgICBwYXJhbXMudHJlZVBhdGhJbmZvID0gd3JhcFRyZWVQYXRoSW5mbyhub2RlLCB0aGlzKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9O1xuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gbGF5b3V0SW5mbyB7XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjb250YWluZXJHcm91cCB4XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBjb250YWluZXJHcm91cCB5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29udGFpbmVyR3JvdXAgd2lkdGhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY29udGFpbmVyR3JvdXAgaGVpZ2h0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICovXG5cblxuICBUcmVlbWFwU2VyaWVzTW9kZWwucHJvdG90eXBlLnNldExheW91dEluZm8gPSBmdW5jdGlvbiAobGF5b3V0SW5mbykge1xuICAgIC8qKlxuICAgICAqIEByZWFkT25seVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5sYXlvdXRJbmZvID0gdGhpcy5sYXlvdXRJbmZvIHx8IHt9O1xuICAgIHpyVXRpbC5leHRlbmQodGhpcy5sYXlvdXRJbmZvLCBsYXlvdXRJbmZvKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWRcbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmRleFxuICAgKi9cblxuXG4gIFRyZWVtYXBTZXJpZXNNb2RlbC5wcm90b3R5cGUubWFwSWRUb0luZGV4ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgLy8gQSBmZWF0dXJlIGlzIGltcGxlbWVudGVkOlxuICAgIC8vIGluZGV4IGlzIG1vbm90b25lIGluY3JlYXNpbmcgd2l0aCB0aGUgc2VxdWVuY2Ugb2ZcbiAgICAvLyBpbnB1dCBpZCBhdCB0aGUgZmlyc3QgdGltZS5cbiAgICAvLyBUaGlzIGZlYXR1cmUgY2FuIG1ha2Ugc3VyZSB0aGF0IGVhY2ggZGF0YSBpdGVtIGFuZCBpdHNcbiAgICAvLyBtYXBwZWQgY29sb3IgaGF2ZSB0aGUgc2FtZSBpbmRleCBiZXR3ZWVuIGRhdGEgbGlzdCBhbmRcbiAgICAvLyBjb2xvciBsaXN0IGF0IHRoZSBiZWdpbm5pbmcsIHdoaWNoIGlzIHVzZWZ1bCBmb3IgdXNlclxuICAgIC8vIHRvIGFkanVzdCBkYXRhLWNvbG9yIG1hcHBpbmcuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIGlkSW5kZXhNYXAgPSB0aGlzLl9pZEluZGV4TWFwO1xuXG4gICAgaWYgKCFpZEluZGV4TWFwKSB7XG4gICAgICBpZEluZGV4TWFwID0gdGhpcy5faWRJbmRleE1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG5cbiAgICAgIHRoaXMuX2lkSW5kZXhNYXBDb3VudCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gaWRJbmRleE1hcC5nZXQoaWQpO1xuXG4gICAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICAgIGlkSW5kZXhNYXAuc2V0KGlkLCBpbmRleCA9IHRoaXMuX2lkSW5kZXhNYXBDb3VudCsrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG5cbiAgVHJlZW1hcFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRWaWV3Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld1Jvb3Q7XG4gIH07XG5cbiAgVHJlZW1hcFNlcmllc01vZGVsLnByb3RvdHlwZS5yZXNldFZpZXdSb290ID0gZnVuY3Rpb24gKHZpZXdSb290KSB7XG4gICAgdmlld1Jvb3QgPyB0aGlzLl92aWV3Um9vdCA9IHZpZXdSb290IDogdmlld1Jvb3QgPSB0aGlzLl92aWV3Um9vdDtcbiAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0UmF3RGF0YSgpLnRyZWUucm9vdDtcblxuICAgIGlmICghdmlld1Jvb3QgfHwgdmlld1Jvb3QgIT09IHJvb3QgJiYgIXJvb3QuY29udGFpbnModmlld1Jvb3QpKSB7XG4gICAgICB0aGlzLl92aWV3Um9vdCA9IHJvb3Q7XG4gICAgfVxuICB9O1xuXG4gIFRyZWVtYXBTZXJpZXNNb2RlbC5wcm90b3R5cGUuZW5hYmxlQXJpYURlY2FsID0gZnVuY3Rpb24gKCkge1xuICAgIGVuYWJsZUFyaWFEZWNhbEZvclRyZWUodGhpcyk7XG4gIH07XG5cbiAgVHJlZW1hcFNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLnRyZWVtYXAnO1xuICBUcmVlbWFwU2VyaWVzTW9kZWwubGF5b3V0TW9kZSA9ICdib3gnO1xuICBUcmVlbWFwU2VyaWVzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAvLyBEaXNhYmxlIHByb2dyZXNzaXZlIHJlbmRlcmluZ1xuICAgIHByb2dyZXNzaXZlOiAwLFxuICAgIC8vIHNpemU6IFsnODAlJywgJzgwJSddLCAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQsIGNvbXBhdGlibGUgd2l0aCBlYzIuXG4gICAgbGVmdDogJ2NlbnRlcicsXG4gICAgdG9wOiAnbWlkZGxlJyxcbiAgICB3aWR0aDogJzgwJScsXG4gICAgaGVpZ2h0OiAnODAlJyxcbiAgICBzb3J0OiB0cnVlLFxuICAgIGNsaXBXaW5kb3c6ICdvcmlnaW4nLFxuICAgIHNxdWFyZVJhdGlvOiAwLjUgKiAoMSArIE1hdGguc3FydCg1KSksXG4gICAgbGVhZkRlcHRoOiBudWxsLFxuICAgIGRyaWxsRG93bkljb246ICfilrYnLFxuICAgIC8vIHRvIGFsaWduIHNwZWNpYWxpemVkIGljb24uIOKWt+KWtuKdkuKdkOKWvOKcmlxuICAgIHpvb21Ub05vZGVSYXRpbzogMC4zMiAqIDAuMzIsXG4gICAgcm9hbTogdHJ1ZSxcbiAgICBub2RlQ2xpY2s6ICd6b29tVG9Ob2RlJyxcbiAgICBhbmltYXRpb246IHRydWUsXG4gICAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDkwMCxcbiAgICBhbmltYXRpb25FYXNpbmc6ICdxdWludGljSW5PdXQnLFxuICAgIGJyZWFkY3J1bWI6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBoZWlnaHQ6IDIyLFxuICAgICAgbGVmdDogJ2NlbnRlcicsXG4gICAgICB0b3A6ICdib3R0b20nLFxuICAgICAgLy8gcmlnaHRcbiAgICAgIC8vIGJvdHRvbVxuICAgICAgZW1wdHlJdGVtV2lkdGg6IDI1LFxuICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAncmdiYSgwLDAsMCwwLjcpJyxcbiAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6ICcjZmZmJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsYWJlbDoge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIC8vIERvIG5vdCB1c2UgdGV4dERpc3RhbmNlLCBmb3IgZWxsaXBzaXMgcmVjdCBqdXN0IHRoZSBzYW1lIGFzIHRyZWVtYXAgbm9kZSByZWN0LlxuICAgICAgZGlzdGFuY2U6IDAsXG4gICAgICBwYWRkaW5nOiA1LFxuICAgICAgcG9zaXRpb246ICdpbnNpZGUnLFxuICAgICAgLy8gZm9ybWF0dGVyOiBudWxsLFxuICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgIG92ZXJmbG93OiAndHJ1bmNhdGUnIC8vIGFsaWduXG4gICAgICAvLyB2ZXJ0aWNhbEFsaWduXG5cbiAgICB9LFxuICAgIHVwcGVyTGFiZWw6IHtcbiAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgcG9zaXRpb246IFswLCAnNTAlJ10sXG4gICAgICBoZWlnaHQ6IDIwLFxuICAgICAgLy8gZm9ybWF0dGVyOiBudWxsLFxuICAgICAgLy8gY29sb3I6ICcjZmZmJyxcbiAgICAgIG92ZXJmbG93OiAndHJ1bmNhdGUnLFxuICAgICAgLy8gYWxpZ246IG51bGwsXG4gICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJ1xuICAgIH0sXG4gICAgaXRlbVN0eWxlOiB7XG4gICAgICBjb2xvcjogbnVsbCxcbiAgICAgIGNvbG9yQWxwaGE6IG51bGwsXG4gICAgICBjb2xvclNhdHVyYXRpb246IG51bGwsXG4gICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgIGdhcFdpZHRoOiAwLFxuICAgICAgYm9yZGVyQ29sb3I6ICcjZmZmJyxcbiAgICAgIGJvcmRlckNvbG9yU2F0dXJhdGlvbjogbnVsbCAvLyBJZiBzcGVjaWZpZWQsIGJvcmRlckNvbG9yIHdpbGwgYmUgaW5lZmZlY3RpdmUsIGFuZCB0aGVcbiAgICAgIC8vIGJvcmRlciBjb2xvciBpcyBldmFsdWF0ZWQgYnkgY29sb3Igb2YgY3VycmVudCBub2RlIGFuZFxuICAgICAgLy8gYm9yZGVyQ29sb3JTYXR1cmF0aW9uLlxuXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgdXBwZXJMYWJlbDoge1xuICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICBwb3NpdGlvbjogWzAsICc1MCUnXSxcbiAgICAgICAgZWxsaXBzaXM6IHRydWUsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gICAgICB9XG4gICAgfSxcbiAgICB2aXN1YWxEaW1lbnNpb246IDAsXG4gICAgdmlzdWFsTWluOiBudWxsLFxuICAgIHZpc3VhbE1heDogbnVsbCxcbiAgICBjb2xvcjogW10sXG4gICAgLy8gbGV2ZWxbbl0uY29sb3IgKGlmIG5lY2Vzc2FyeSkuXG4gICAgLy8gKyBTcGVjaWZ5IGNvbG9yIGxpc3Qgb2YgZWFjaCBsZXZlbC4gbGV2ZWxbMF0uY29sb3Igd291bGQgYmUgZ2xvYmFsXG4gICAgLy8gY29sb3IgbGlzdCBpZiBub3Qgc3BlY2lmaWVkLiAoc2VlIG1ldGhvZCBgc2V0RGVmYXVsdGApLlxuICAgIC8vICsgQnV0IHNldCBhcyBhIGVtcHR5IGFycmF5IHRvIGZvcmJpZCBmZXRjaCBjb2xvciBmcm9tIGdsb2JhbCBwYWxldHRlXG4gICAgLy8gd2hlbiB1c2luZyBub2RlTW9kZWwuZ2V0KCdjb2xvcicpLCBvdGhlcndpc2Ugbm9kZXMgb24gZGVlcCBsZXZlbFxuICAgIC8vIHdpbGwgYWx3YXlzIGhhcyBjb2xvciBwYWxldHRlIHNldCBhbmQgYXJlIG5vdCBhYmxlIHRvIGluaGVyaXQgY29sb3JcbiAgICAvLyBmcm9tIHBhcmVudCBub2RlLlxuICAgIC8vICsgVHJlZW1hcFNlcmllcy5jb2xvciBjYW4gbm90IGJlIHNldCBhcyAnbm9uZScsIG90aGVyd2lzZSBlZmZlY3RcbiAgICAvLyBsZWdlbmQgY29sb3IgZmV0Y2hpbmcgKHNlZSBzZXJpZXNDb2xvci5qcykuXG4gICAgY29sb3JBbHBoYTogbnVsbCxcbiAgICBjb2xvclNhdHVyYXRpb246IG51bGwsXG4gICAgY29sb3JNYXBwaW5nQnk6ICdpbmRleCcsXG4gICAgdmlzaWJsZU1pbjogMTAsXG4gICAgLy8gYmUgcmVuZGVyZWQuIE9ubHkgd29ya3Mgd2hlbiBzb3J0IGlzICdhc2MnIG9yICdkZXNjJy5cbiAgICBjaGlsZHJlblZpc2libGVNaW46IG51bGwsXG4gICAgLy8gZ3JhbmRjaGlsZHJlbiB3aWxsIG5vdCBzaG93LlxuICAgIC8vIFdoeSBncmFuZGNoaWxkcmVuPyBJZiBub3QgZ3JhbmRjaGlsZHJlbiBidXQgY2hpbGRyZW4sXG4gICAgLy8gc29tZSBzaWJsaW5ncyBzaG93IGNoaWxkcmVuIGFuZCBzb21lIG5vdCxcbiAgICAvLyB0aGUgYXBwZWFyYW5jZSBtYXkgYmUgbWVzcyBhbmQgbm90IGNvbnNpc3RlbnQsXG4gICAgbGV2ZWxzOiBbXSAvLyBFYWNoIGl0ZW06IHtcbiAgICAvLyAgICAgdmlzaWJsZU1pbiwgaXRlbVN0eWxlLCB2aXN1YWxEaW1lbnNpb24sIGxhYmVsXG4gICAgLy8gfVxuICAgIC8vIGRhdGE6IHtcbiAgICAvLyAgICAgIHZhbHVlOiBbXSxcbiAgICAvLyAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAvLyAgICAgIGxpbms6ICdodHRwOi8veHh4Lnh4eC54eHgnLFxuICAgIC8vICAgICAgdGFyZ2V0OiAnYmxhbmsnIG9yICdzZWxmJ1xuICAgIC8vIH1cblxuICB9O1xuICByZXR1cm4gVHJlZW1hcFNlcmllc01vZGVsO1xufShTZXJpZXNNb2RlbCk7XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhTm9kZVxuICovXG5cblxuZnVuY3Rpb24gY29tcGxldGVUcmVlVmFsdWUoZGF0YU5vZGUpIHtcbiAgLy8gUG9zdG9yZGVyIHRyYXZlbCB0cmVlLlxuICAvLyBJZiB2YWx1ZSBvZiBub25lLWxlYWYgbm9kZSBpcyBub3Qgc2V0LFxuICAvLyBjYWxjdWxhdGUgaXQgYnkgc3VtaW5nIHVwIHRoZSB2YWx1ZSBvZiBhbGwgY2hpbGRyZW4uXG4gIHZhciBzdW0gPSAwO1xuICB6clV0aWwuZWFjaChkYXRhTm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgY29tcGxldGVUcmVlVmFsdWUoY2hpbGQpO1xuICAgIHZhciBjaGlsZFZhbHVlID0gY2hpbGQudmFsdWU7XG4gICAgenJVdGlsLmlzQXJyYXkoY2hpbGRWYWx1ZSkgJiYgKGNoaWxkVmFsdWUgPSBjaGlsZFZhbHVlWzBdKTtcbiAgICBzdW0gKz0gY2hpbGRWYWx1ZTtcbiAgfSk7XG4gIHZhciB0aGlzVmFsdWUgPSBkYXRhTm9kZS52YWx1ZTtcblxuICBpZiAoenJVdGlsLmlzQXJyYXkodGhpc1ZhbHVlKSkge1xuICAgIHRoaXNWYWx1ZSA9IHRoaXNWYWx1ZVswXTtcbiAgfVxuXG4gIGlmICh0aGlzVmFsdWUgPT0gbnVsbCB8fCBpc05hTih0aGlzVmFsdWUpKSB7XG4gICAgdGhpc1ZhbHVlID0gc3VtO1xuICB9IC8vIFZhbHVlIHNob3VsZCBub3QgbGVzcyB0aGFuIDAuXG5cblxuICBpZiAodGhpc1ZhbHVlIDwgMCkge1xuICAgIHRoaXNWYWx1ZSA9IDA7XG4gIH1cblxuICB6clV0aWwuaXNBcnJheShkYXRhTm9kZS52YWx1ZSkgPyBkYXRhTm9kZS52YWx1ZVswXSA9IHRoaXNWYWx1ZSA6IGRhdGFOb2RlLnZhbHVlID0gdGhpc1ZhbHVlO1xufVxuLyoqXG4gKiBzZXQgZGVmYXVsdCB0byBsZXZlbCBjb25maWd1cmF0aW9uXG4gKi9cblxuXG5mdW5jdGlvbiBzZXREZWZhdWx0KGxldmVscywgZWNNb2RlbCkge1xuICB2YXIgZ2xvYmFsQ29sb3JMaXN0ID0gbm9ybWFsaXplVG9BcnJheShlY01vZGVsLmdldCgnY29sb3InKSk7XG4gIHZhciBnbG9iYWxEZWNhbExpc3QgPSBub3JtYWxpemVUb0FycmF5KGVjTW9kZWwuZ2V0KFsnYXJpYScsICdkZWNhbCcsICdkZWNhbHMnXSkpO1xuXG4gIGlmICghZ2xvYmFsQ29sb3JMaXN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV2ZWxzID0gbGV2ZWxzIHx8IFtdO1xuICB2YXIgaGFzQ29sb3JEZWZpbmU7XG4gIHZhciBoYXNEZWNhbERlZmluZTtcbiAgenJVdGlsLmVhY2gobGV2ZWxzLCBmdW5jdGlvbiAobGV2ZWxEZWZpbmUpIHtcbiAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwobGV2ZWxEZWZpbmUpO1xuICAgIHZhciBtb2RlbENvbG9yID0gbW9kZWwuZ2V0KCdjb2xvcicpO1xuICAgIHZhciBtb2RlbERlY2FsID0gbW9kZWwuZ2V0KCdkZWNhbCcpO1xuXG4gICAgaWYgKG1vZGVsLmdldChbJ2l0ZW1TdHlsZScsICdjb2xvciddKSB8fCBtb2RlbENvbG9yICYmIG1vZGVsQ29sb3IgIT09ICdub25lJykge1xuICAgICAgaGFzQ29sb3JEZWZpbmUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChtb2RlbC5nZXQoWydpdGVtU3R5bGUnLCAnZGVjYWwnXSkgfHwgbW9kZWxEZWNhbCAmJiBtb2RlbERlY2FsICE9PSAnbm9uZScpIHtcbiAgICAgIGhhc0RlY2FsRGVmaW5lID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICB2YXIgbGV2ZWwwID0gbGV2ZWxzWzBdIHx8IChsZXZlbHNbMF0gPSB7fSk7XG5cbiAgaWYgKCFoYXNDb2xvckRlZmluZSkge1xuICAgIGxldmVsMC5jb2xvciA9IGdsb2JhbENvbG9yTGlzdC5zbGljZSgpO1xuICB9XG5cbiAgaWYgKCFoYXNEZWNhbERlZmluZSAmJiBnbG9iYWxEZWNhbExpc3QpIHtcbiAgICBsZXZlbDAuZGVjYWwgPSBnbG9iYWxEZWNhbExpc3Quc2xpY2UoKTtcbiAgfVxuXG4gIHJldHVybiBsZXZlbHM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyZWVtYXBTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBiaW5kLCBlYWNoLCBpbmRleE9mLCBjdXJyeSwgZXh0ZW5kLCByZXRyaWV2ZSwgbm9ybWFsaXplQ3NzQXJyYXksIGlzRnVuY3Rpb24gfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlJztcbmltcG9ydCB7IGlzSGlnaERvd25EaXNwYXRjaGVyLCBzZXRBc0hpZ2hEb3duRGlzcGF0Y2hlciwgc2V0RGVmYXVsdFN0YXRlUHJveHksIGVuYWJsZUhvdmVyRm9jdXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcyc7XG5pbXBvcnQgRGF0YURpZmZlciBmcm9tICcuLi8uLi9kYXRhL0RhdGFEaWZmZXInO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4uL2hlbHBlci90cmVlSGVscGVyJztcbmltcG9ydCBCcmVhZGNydW1iIGZyb20gJy4vQnJlYWRjcnVtYic7XG5pbXBvcnQgUm9hbUNvbnRyb2xsZXIgZnJvbSAnLi4vLi4vY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlcic7XG5pbXBvcnQgQm91bmRpbmdSZWN0IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0JztcbmltcG9ydCAqIGFzIG1hdHJpeCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeCc7XG5pbXBvcnQgKiBhcyBhbmltYXRpb25VdGlsIGZyb20gJy4uLy4uL3V0aWwvYW5pbWF0aW9uJztcbmltcG9ydCBtYWtlU3R5bGVNYXBwZXIgZnJvbSAnLi4vLi4vbW9kZWwvbWl4aW4vbWFrZVN0eWxlTWFwcGVyJztcbmltcG9ydCBDaGFydFZpZXcgZnJvbSAnLi4vLi4vdmlldy9DaGFydCc7XG5pbXBvcnQgRGlzcGxheWFibGUgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZSc7XG5pbXBvcnQgeyBtYWtlSW5uZXIsIGNvbnZlcnRPcHRpb25JZE5hbWUgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbmltcG9ydCB7IHdpbmRvd09wZW4gfSBmcm9tICcuLi8uLi91dGlsL2Zvcm1hdCc7XG5pbXBvcnQgeyBzZXRMYWJlbFN0eWxlLCBnZXRMYWJlbFN0YXRlc01vZGVscyB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUnO1xudmFyIEdyb3VwID0gZ3JhcGhpYy5Hcm91cDtcbnZhciBSZWN0ID0gZ3JhcGhpYy5SZWN0O1xudmFyIERSQUdfVEhSRVNIT0xEID0gMztcbnZhciBQQVRIX0xBQkVMX05PQU1BTCA9ICdsYWJlbCc7XG52YXIgUEFUSF9VUFBFUkxBQkVMX05PUk1BTCA9ICd1cHBlckxhYmVsJztcbnZhciBaX0JBU0UgPSAxMDsgLy8gU2hvdWxkIGJpZ2dlciB0aGFuIGV2ZXJ5IHouXG5cbnZhciBaX0JHID0gMTtcbnZhciBaX0NPTlRFTlQgPSAyO1xudmFyIGdldFN0YXRlSXRlbVN0eWxlID0gbWFrZVN0eWxlTWFwcGVyKFtbJ2ZpbGwnLCAnY29sb3InXSwgLy8gYGJvcmRlckNvbG9yYCBhbmQgYGJvcmRlcldpZHRoYCBoYXMgYmVlbiBvY2N1cGllZCxcbi8vIHNvIHVzZSBgc3Ryb2tlYCB0byBpbmRpY2F0ZSB0aGUgc3Ryb2tlIG9mIHRoZSByZWN0LlxuWydzdHJva2UnLCAnc3Ryb2tlQ29sb3InXSwgWydsaW5lV2lkdGgnLCAnc3Ryb2tlV2lkdGgnXSwgWydzaGFkb3dCbHVyJ10sIFsnc2hhZG93T2Zmc2V0WCddLCBbJ3NoYWRvd09mZnNldFknXSwgWydzaGFkb3dDb2xvciddIC8vIE9wdGlvbiBkZWNhbCBpcyBpbiBgRGVjYWxPYmplY3RgIGJ1dCBzdHlsZS5kZWNhbCBpcyBpbiBgUGF0dGVybk9iamVjdGAuXG4vLyBTbyBkbyBub3QgdHJhbnNmZXIgZGVjYWwgZGlyZWN0bHkuXG5dKTtcblxudmFyIGdldEl0ZW1TdHlsZU5vcm1hbCA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAvLyBOb3JtYWwgc3R5bGUgcHJvcHMgc2hvdWxkIGluY2x1ZGUgZW1waGFzaXMgc3R5bGUgcHJvcHMuXG4gIHZhciBpdGVtU3R5bGUgPSBnZXRTdGF0ZUl0ZW1TdHlsZShtb2RlbCk7IC8vIENsZWFyIHN0eWxlcyBzZXQgYnkgZW1waGFzaXMuXG5cbiAgaXRlbVN0eWxlLnN0cm9rZSA9IGl0ZW1TdHlsZS5maWxsID0gaXRlbVN0eWxlLmxpbmVXaWR0aCA9IG51bGw7XG4gIHJldHVybiBpdGVtU3R5bGU7XG59O1xuXG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcblxudmFyIFRyZWVtYXBWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRyZWVtYXBWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFRyZWVtYXBWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IFRyZWVtYXBWaWV3LnR5cGU7XG4gICAgX3RoaXMuX3N0YXRlID0gJ3JlYWR5JztcbiAgICBfdGhpcy5fc3RvcmFnZSA9IGNyZWF0ZVN0b3JhZ2UoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIFRyZWVtYXBWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHZhciBtb2RlbHMgPSBlY01vZGVsLmZpbmRDb21wb25lbnRzKHtcbiAgICAgIG1haW5UeXBlOiAnc2VyaWVzJyxcbiAgICAgIHN1YlR5cGU6ICd0cmVlbWFwJyxcbiAgICAgIHF1ZXJ5OiBwYXlsb2FkXG4gICAgfSk7XG5cbiAgICBpZiAoaW5kZXhPZihtb2RlbHMsIHNlcmllc01vZGVsKSA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNlcmllc01vZGVsID0gc2VyaWVzTW9kZWw7XG4gICAgdGhpcy5hcGkgPSBhcGk7XG4gICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgICB2YXIgdHlwZXMgPSBbJ3RyZWVtYXBab29tVG9Ob2RlJywgJ3RyZWVtYXBSb290VG9Ob2RlJ107XG4gICAgdmFyIHRhcmdldEluZm8gPSBoZWxwZXIucmV0cmlldmVUYXJnZXRJbmZvKHBheWxvYWQsIHR5cGVzLCBzZXJpZXNNb2RlbCk7XG4gICAgdmFyIHBheWxvYWRUeXBlID0gcGF5bG9hZCAmJiBwYXlsb2FkLnR5cGU7XG4gICAgdmFyIGxheW91dEluZm8gPSBzZXJpZXNNb2RlbC5sYXlvdXRJbmZvO1xuICAgIHZhciBpc0luaXQgPSAhdGhpcy5fb2xkVHJlZTtcbiAgICB2YXIgdGhpc1N0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlOyAvLyBNYXJrIG5ldyByb290IHdoZW4gYWN0aW9uIGlzIHRyZWVtYXBSb290VG9Ob2RlLlxuXG4gICAgdmFyIHJlUm9vdCA9IHBheWxvYWRUeXBlID09PSAndHJlZW1hcFJvb3RUb05vZGUnICYmIHRhcmdldEluZm8gJiYgdGhpc1N0b3JhZ2UgPyB7XG4gICAgICByb290Tm9kZUdyb3VwOiB0aGlzU3RvcmFnZS5ub2RlR3JvdXBbdGFyZ2V0SW5mby5ub2RlLmdldFJhd0luZGV4KCldLFxuICAgICAgZGlyZWN0aW9uOiBwYXlsb2FkLmRpcmVjdGlvblxuICAgIH0gOiBudWxsO1xuXG4gICAgdmFyIGNvbnRhaW5lckdyb3VwID0gdGhpcy5fZ2l2ZUNvbnRhaW5lckdyb3VwKGxheW91dEluZm8pO1xuXG4gICAgdmFyIHJlbmRlclJlc3VsdCA9IHRoaXMuX2RvUmVuZGVyKGNvbnRhaW5lckdyb3VwLCBzZXJpZXNNb2RlbCwgcmVSb290KTtcblxuICAgICFpc0luaXQgJiYgKCFwYXlsb2FkVHlwZSB8fCBwYXlsb2FkVHlwZSA9PT0gJ3RyZWVtYXBab29tVG9Ob2RlJyB8fCBwYXlsb2FkVHlwZSA9PT0gJ3RyZWVtYXBSb290VG9Ob2RlJykgPyB0aGlzLl9kb0FuaW1hdGlvbihjb250YWluZXJHcm91cCwgcmVuZGVyUmVzdWx0LCBzZXJpZXNNb2RlbCwgcmVSb290KSA6IHJlbmRlclJlc3VsdC5yZW5kZXJGaW5hbGx5KCk7XG5cbiAgICB0aGlzLl9yZXNldENvbnRyb2xsZXIoYXBpKTtcblxuICAgIHRoaXMuX3JlbmRlckJyZWFkY3J1bWIoc2VyaWVzTW9kZWwsIGFwaSwgdGFyZ2V0SW5mbyk7XG4gIH07XG5cbiAgVHJlZW1hcFZpZXcucHJvdG90eXBlLl9naXZlQ29udGFpbmVyR3JvdXAgPSBmdW5jdGlvbiAobGF5b3V0SW5mbykge1xuICAgIHZhciBjb250YWluZXJHcm91cCA9IHRoaXMuX2NvbnRhaW5lckdyb3VwO1xuXG4gICAgaWYgKCFjb250YWluZXJHcm91cCkge1xuICAgICAgLy8gRklYTUVcbiAgICAgIC8vIOWKoOS4gOWxgmNvbnRhaW5lckdyb3Vw5piv5Li65LqGY2xpcO+8jOS9huaYr+eOsOWcqGNsaXDlip/og73lubbmsqHmnInlrp7njrDjgIJcbiAgICAgIGNvbnRhaW5lckdyb3VwID0gdGhpcy5fY29udGFpbmVyR3JvdXAgPSBuZXcgR3JvdXAoKTtcblxuICAgICAgdGhpcy5faW5pdEV2ZW50cyhjb250YWluZXJHcm91cCk7XG5cbiAgICAgIHRoaXMuZ3JvdXAuYWRkKGNvbnRhaW5lckdyb3VwKTtcbiAgICB9XG5cbiAgICBjb250YWluZXJHcm91cC54ID0gbGF5b3V0SW5mby54O1xuICAgIGNvbnRhaW5lckdyb3VwLnkgPSBsYXlvdXRJbmZvLnk7XG4gICAgcmV0dXJuIGNvbnRhaW5lckdyb3VwO1xuICB9O1xuXG4gIFRyZWVtYXBWaWV3LnByb3RvdHlwZS5fZG9SZW5kZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyR3JvdXAsIHNlcmllc01vZGVsLCByZVJvb3QpIHtcbiAgICB2YXIgdGhpc1RyZWUgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCkudHJlZTtcbiAgICB2YXIgb2xkVHJlZSA9IHRoaXMuX29sZFRyZWU7IC8vIENsZWFyIGxhc3Qgc2hhcGUgcmVjb3Jkcy5cblxuICAgIHZhciBsYXN0c0ZvckFuaW1hdGlvbiA9IGNyZWF0ZVN0b3JhZ2UoKTtcbiAgICB2YXIgdGhpc1N0b3JhZ2UgPSBjcmVhdGVTdG9yYWdlKCk7XG4gICAgdmFyIG9sZFN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlO1xuICAgIHZhciB3aWxsSW52aXNpYmxlRWxzID0gW107XG5cbiAgICBmdW5jdGlvbiBkb1JlbmRlck5vZGUodGhpc05vZGUsIG9sZE5vZGUsIHBhcmVudEdyb3VwLCBkZXB0aCkge1xuICAgICAgcmV0dXJuIHJlbmRlck5vZGUoc2VyaWVzTW9kZWwsIHRoaXNTdG9yYWdlLCBvbGRTdG9yYWdlLCByZVJvb3QsIGxhc3RzRm9yQW5pbWF0aW9uLCB3aWxsSW52aXNpYmxlRWxzLCB0aGlzTm9kZSwgb2xkTm9kZSwgcGFyZW50R3JvdXAsIGRlcHRoKTtcbiAgICB9IC8vIE5vdGljZTogd2hlbiB0aGlzVHJlZSBhbmQgb2xkVHJlZSBhcmUgdGhlIHNhbWUgdHJlZSAoc2VlIGxpc3QuY2xvbmVTaGFsbG93KSxcbiAgICAvLyB0aGUgb2xkVHJlZSBpcyBhY3R1YWxseSBsb3N0ZWQsIHNvIHdlIGNhbiBub3QgZmluZCBhbGwgb2YgdGhlIG9sZCBncmFwaGljXG4gICAgLy8gZWxlbWVudHMgZnJvbSB0cmVlLiBTbyB3ZSB1c2UgdGhpcyBzdHJhZ2VneTogbWFrZSBlbGVtZW50IHN0b3JhZ2UsIG1vdmVcbiAgICAvLyBmcm9tIG9sZCBzdG9yYWdlIHRvIG5ldyBzdG9yYWdlLCBjbGVhciBvbGQgc3RvcmFnZS5cblxuXG4gICAgZHVhbFRyYXZlbCh0aGlzVHJlZS5yb290ID8gW3RoaXNUcmVlLnJvb3RdIDogW10sIG9sZFRyZWUgJiYgb2xkVHJlZS5yb290ID8gW29sZFRyZWUucm9vdF0gOiBbXSwgY29udGFpbmVyR3JvdXAsIHRoaXNUcmVlID09PSBvbGRUcmVlIHx8ICFvbGRUcmVlLCAwKTsgLy8gUHJvY2VzcyBhbGwgcmVtb3ZpbmcuXG5cbiAgICB2YXIgd2lsbERlbGV0ZUVscyA9IGNsZWFyU3RvcmFnZShvbGRTdG9yYWdlKTtcbiAgICB0aGlzLl9vbGRUcmVlID0gdGhpc1RyZWU7XG4gICAgdGhpcy5fc3RvcmFnZSA9IHRoaXNTdG9yYWdlO1xuICAgIHJldHVybiB7XG4gICAgICBsYXN0c0ZvckFuaW1hdGlvbjogbGFzdHNGb3JBbmltYXRpb24sXG4gICAgICB3aWxsRGVsZXRlRWxzOiB3aWxsRGVsZXRlRWxzLFxuICAgICAgcmVuZGVyRmluYWxseTogcmVuZGVyRmluYWxseVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkdWFsVHJhdmVsKHRoaXNWaWV3Q2hpbGRyZW4sIG9sZFZpZXdDaGlsZHJlbiwgcGFyZW50R3JvdXAsIHNhbWVUcmVlLCBkZXB0aCkge1xuICAgICAgLy8gV2hlbiAncmVuZGVyJyBpcyB0cmlnZ2VyZWQgYnkgYWN0aW9uLFxuICAgICAgLy8gJ3RoaXMnIGFuZCAnb2xkJyBtYXkgYmUgdGhlIHNhbWUgdHJlZSxcbiAgICAgIC8vIHdlIHVzZSByYXdJbmRleCBpbiB0aGF0IGNhc2UuXG4gICAgICBpZiAoc2FtZVRyZWUpIHtcbiAgICAgICAgb2xkVmlld0NoaWxkcmVuID0gdGhpc1ZpZXdDaGlsZHJlbjtcbiAgICAgICAgZWFjaCh0aGlzVmlld0NoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgIWNoaWxkLmlzUmVtb3ZlZCgpICYmIHByb2Nlc3NOb2RlKGluZGV4LCBpbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBEaWZmIGhpZXJhcmNoaWNhbGx5IChkaWZmIG9ubHkgaW4gZWFjaCBzdWJ0cmVlLCBidXQgbm90IHdob2xlKS5cbiAgICAgIC8vIGJlY2F1c2UsIGNvbnNpc3RlbmN5IG9mIHZpZXcgaXMgaW1wb3J0YW50LlxuICAgICAgZWxzZSB7XG4gICAgICAgICAgbmV3IERhdGFEaWZmZXIob2xkVmlld0NoaWxkcmVuLCB0aGlzVmlld0NoaWxkcmVuLCBnZXRLZXksIGdldEtleSkuYWRkKHByb2Nlc3NOb2RlKS51cGRhdGUocHJvY2Vzc05vZGUpLnJlbW92ZShjdXJyeShwcm9jZXNzTm9kZSwgbnVsbCkpLmV4ZWN1dGUoKTtcbiAgICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRLZXkobm9kZSkge1xuICAgICAgICAvLyBJZGVudGlmeSBieSBuYW1lIG9yIHJhdyBpbmRleC5cbiAgICAgICAgcmV0dXJuIG5vZGUuZ2V0SWQoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHJvY2Vzc05vZGUobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gICAgICAgIHZhciB0aGlzTm9kZSA9IG5ld0luZGV4ICE9IG51bGwgPyB0aGlzVmlld0NoaWxkcmVuW25ld0luZGV4XSA6IG51bGw7XG4gICAgICAgIHZhciBvbGROb2RlID0gb2xkSW5kZXggIT0gbnVsbCA/IG9sZFZpZXdDaGlsZHJlbltvbGRJbmRleF0gOiBudWxsO1xuICAgICAgICB2YXIgZ3JvdXAgPSBkb1JlbmRlck5vZGUodGhpc05vZGUsIG9sZE5vZGUsIHBhcmVudEdyb3VwLCBkZXB0aCk7XG4gICAgICAgIGdyb3VwICYmIGR1YWxUcmF2ZWwodGhpc05vZGUgJiYgdGhpc05vZGUudmlld0NoaWxkcmVuIHx8IFtdLCBvbGROb2RlICYmIG9sZE5vZGUudmlld0NoaWxkcmVuIHx8IFtdLCBncm91cCwgc2FtZVRyZWUsIGRlcHRoICsgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJTdG9yYWdlKHN0b3JhZ2UpIHtcbiAgICAgIHZhciB3aWxsRGVsZXRlRWxzID0gY3JlYXRlU3RvcmFnZSgpO1xuICAgICAgc3RvcmFnZSAmJiBlYWNoKHN0b3JhZ2UsIGZ1bmN0aW9uIChzdG9yZSwgc3RvcmFnZU5hbWUpIHtcbiAgICAgICAgdmFyIGRlbEVscyA9IHdpbGxEZWxldGVFbHNbc3RvcmFnZU5hbWVdO1xuICAgICAgICBlYWNoKHN0b3JlLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBlbCAmJiAoZGVsRWxzLnB1c2goZWwpLCBpbm5lcihlbCkud2lsbERlbGV0ZSA9IHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHdpbGxEZWxldGVFbHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyRmluYWxseSgpIHtcbiAgICAgIGVhY2god2lsbERlbGV0ZUVscywgZnVuY3Rpb24gKGVscykge1xuICAgICAgICBlYWNoKGVscywgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgZWwucGFyZW50ICYmIGVsLnBhcmVudC5yZW1vdmUoZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZWFjaCh3aWxsSW52aXNpYmxlRWxzLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwuaW52aXNpYmxlID0gdHJ1ZTsgLy8gU2V0dGluZyBpbnZpc2libGUgaXMgZm9yIG9wdGltaXppbmcsIHNvIG5vIG5lZWQgdG8gc2V0IGRpcnR5LFxuICAgICAgICAvLyBqdXN0IG1hcmsgYXMgaW52aXNpYmxlLlxuXG4gICAgICAgIGVsLmRpcnR5KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgVHJlZW1hcFZpZXcucHJvdG90eXBlLl9kb0FuaW1hdGlvbiA9IGZ1bmN0aW9uIChjb250YWluZXJHcm91cCwgcmVuZGVyUmVzdWx0LCBzZXJpZXNNb2RlbCwgcmVSb290KSB7XG4gICAgaWYgKCFzZXJpZXNNb2RlbC5nZXQoJ2FuaW1hdGlvbicpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGR1cmF0aW9uT3B0aW9uID0gc2VyaWVzTW9kZWwuZ2V0KCdhbmltYXRpb25EdXJhdGlvblVwZGF0ZScpO1xuICAgIHZhciBlYXNpbmdPcHRpb24gPSBzZXJpZXNNb2RlbC5nZXQoJ2FuaW1hdGlvbkVhc2luZycpOyAvLyBUT0RPOiBkbyBub3Qgc3VwcG9ydCBmdW5jdGlvbiB1bnRpbCBuZWNlc3NhcnkuXG5cbiAgICB2YXIgZHVyYXRpb24gPSAoaXNGdW5jdGlvbihkdXJhdGlvbk9wdGlvbikgPyAwIDogZHVyYXRpb25PcHRpb24pIHx8IDA7XG4gICAgdmFyIGVhc2luZyA9IChpc0Z1bmN0aW9uKGVhc2luZ09wdGlvbikgPyBudWxsIDogZWFzaW5nT3B0aW9uKSB8fCAnY3ViaWNPdXQnO1xuICAgIHZhciBhbmltYXRpb25XcmFwID0gYW5pbWF0aW9uVXRpbC5jcmVhdGVXcmFwKCk7IC8vIE1ha2UgZGVsZXRlIGFuaW1hdGlvbnMuXG5cbiAgICBlYWNoKHJlbmRlclJlc3VsdC53aWxsRGVsZXRlRWxzLCBmdW5jdGlvbiAoc3RvcmUsIHN0b3JhZ2VOYW1lKSB7XG4gICAgICBlYWNoKHN0b3JlLCBmdW5jdGlvbiAoZWwsIHJhd0luZGV4KSB7XG4gICAgICAgIGlmIChlbC5pbnZpc2libGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50OyAvLyBBbHdheXMgaGFzIHBhcmVudCwgYW5kIHBhcmVudCBpcyBub2RlR3JvdXAuXG5cbiAgICAgICAgdmFyIHRhcmdldDtcbiAgICAgICAgdmFyIGlubmVyU3RvcmUgPSBpbm5lcihwYXJlbnQpO1xuXG4gICAgICAgIGlmIChyZVJvb3QgJiYgcmVSb290LmRpcmVjdGlvbiA9PT0gJ2RyaWxsRG93bicpIHtcbiAgICAgICAgICB0YXJnZXQgPSBwYXJlbnQgPT09IHJlUm9vdC5yb290Tm9kZUdyb3VwIC8vIFRoaXMgaXMgdGhlIGNvbnRlbnQgZWxlbWVudCBvZiB2aWV3IHJvb3QuXG4gICAgICAgICAgLy8gT25seSBgY29udGVudGAgd2lsbCBlbnRlciB0aGlzIGJyYW5jaCwgYmVjYXVzZVxuICAgICAgICAgIC8vIGBiYWNrZ3JvdW5kYCBhbmQgYG5vZGVHcm91cGAgd2lsbCBub3QgYmUgZGVsZXRlZC5cbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgIHdpZHRoOiBpbm5lclN0b3JlLm5vZGVXaWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBpbm5lclN0b3JlLm5vZGVIZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBPdGhlcnMuXG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0WCA9IDA7XG4gICAgICAgICAgdmFyIHRhcmdldFkgPSAwO1xuXG4gICAgICAgICAgaWYgKCFpbm5lclN0b3JlLndpbGxEZWxldGUpIHtcbiAgICAgICAgICAgIC8vIExldCBub2RlIGFuaW1hdGUgdG8gcmlnaHQtYm90dG9tIGNvcm5lciwgY29vcGVyYXRpbmcgd2l0aCBmYWRlb3V0LFxuICAgICAgICAgICAgLy8gd2hpY2ggaXMgYXBwcm9wcmlhdGUgZm9yIHVzZXIgdW5kZXJzdGFuZGluZy5cbiAgICAgICAgICAgIC8vIERpdmlkZWQgYnkgMiBmb3IgcmVSb290IHJvbGxpbmcgdXAgZWZmZWN0LlxuICAgICAgICAgICAgdGFyZ2V0WCA9IGlubmVyU3RvcmUubm9kZVdpZHRoIC8gMjtcbiAgICAgICAgICAgIHRhcmdldFkgPSBpbm5lclN0b3JlLm5vZGVIZWlnaHQgLyAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhcmdldCA9IHN0b3JhZ2VOYW1lID09PSAnbm9kZUdyb3VwJyA/IHtcbiAgICAgICAgICAgIHg6IHRhcmdldFgsXG4gICAgICAgICAgICB5OiB0YXJnZXRZLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICB4OiB0YXJnZXRYLFxuICAgICAgICAgICAgICB5OiB0YXJnZXRZLFxuICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gVE9ETzogZG8gbm90IHN1cHBvcnQgZGVsYXkgdW50aWwgbmVjZXNzYXJ5LlxuXG5cbiAgICAgICAgdGFyZ2V0ICYmIGFuaW1hdGlvbldyYXAuYWRkKGVsLCB0YXJnZXQsIGR1cmF0aW9uLCAwLCBlYXNpbmcpO1xuICAgICAgfSk7XG4gICAgfSk7IC8vIE1ha2Ugb3RoZXIgYW5pbWF0aW9uc1xuXG4gICAgZWFjaCh0aGlzLl9zdG9yYWdlLCBmdW5jdGlvbiAoc3RvcmUsIHN0b3JhZ2VOYW1lKSB7XG4gICAgICBlYWNoKHN0b3JlLCBmdW5jdGlvbiAoZWwsIHJhd0luZGV4KSB7XG4gICAgICAgIHZhciBsYXN0ID0gcmVuZGVyUmVzdWx0Lmxhc3RzRm9yQW5pbWF0aW9uW3N0b3JhZ2VOYW1lXVtyYXdJbmRleF07XG4gICAgICAgIHZhciB0YXJnZXQgPSB7fTtcblxuICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBncmFwaGljLkdyb3VwKSB7XG4gICAgICAgICAgaWYgKGxhc3Qub2xkWCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0YXJnZXQueCA9IGVsLng7XG4gICAgICAgICAgICB0YXJnZXQueSA9IGVsLnk7XG4gICAgICAgICAgICBlbC54ID0gbGFzdC5vbGRYO1xuICAgICAgICAgICAgZWwueSA9IGxhc3Qub2xkWTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGxhc3Qub2xkU2hhcGUpIHtcbiAgICAgICAgICAgIHRhcmdldC5zaGFwZSA9IGV4dGVuZCh7fSwgZWwuc2hhcGUpO1xuICAgICAgICAgICAgZWwuc2V0U2hhcGUobGFzdC5vbGRTaGFwZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxhc3QuZmFkZWluKSB7XG4gICAgICAgICAgICBlbC5zZXRTdHlsZSgnb3BhY2l0eScsIDApO1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlID0ge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gLy8gV2hlbiBhbmltYXRpb24gaXMgc3RvcHBlZCBmb3Igc3VjY2VkZW50IGFuaW1hdGlvbiBzdGFydGluZyxcbiAgICAgICAgICAvLyBlbC5zdHlsZS5vcGFjaXR5IG1pZ2h0IG5vdCBiZSAxXG4gICAgICAgICAgZWxzZSBpZiAoZWwuc3R5bGUub3BhY2l0eSAhPT0gMSkge1xuICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYW5pbWF0aW9uV3JhcC5hZGQoZWwsIHRhcmdldCwgZHVyYXRpb24sIDAsIGVhc2luZyk7XG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9zdGF0ZSA9ICdhbmltYXRpbmcnO1xuICAgIGFuaW1hdGlvbldyYXAuZmluaXNoZWQoYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9ICdyZWFkeSc7XG4gICAgICByZW5kZXJSZXN1bHQucmVuZGVyRmluYWxseSgpO1xuICAgIH0sIHRoaXMpKS5zdGFydCgpO1xuICB9O1xuXG4gIFRyZWVtYXBWaWV3LnByb3RvdHlwZS5fcmVzZXRDb250cm9sbGVyID0gZnVuY3Rpb24gKGFwaSkge1xuICAgIHZhciBjb250cm9sbGVyID0gdGhpcy5fY29udHJvbGxlcjsgLy8gSW5pdCBjb250cm9sbGVyLlxuXG4gICAgaWYgKCFjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyID0gdGhpcy5fY29udHJvbGxlciA9IG5ldyBSb2FtQ29udHJvbGxlcihhcGkuZ2V0WnIoKSk7XG4gICAgICBjb250cm9sbGVyLmVuYWJsZSh0aGlzLnNlcmllc01vZGVsLmdldCgncm9hbScpKTtcbiAgICAgIGNvbnRyb2xsZXIub24oJ3BhbicsIGJpbmQodGhpcy5fb25QYW4sIHRoaXMpKTtcbiAgICAgIGNvbnRyb2xsZXIub24oJ3pvb20nLCBiaW5kKHRoaXMuX29uWm9vbSwgdGhpcykpO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCBhcGkuZ2V0V2lkdGgoKSwgYXBpLmdldEhlaWdodCgpKTtcbiAgICBjb250cm9sbGVyLnNldFBvaW50ZXJDaGVja2VyKGZ1bmN0aW9uIChlLCB4LCB5KSB7XG4gICAgICByZXR1cm4gcmVjdC5jb250YWluKHgsIHkpO1xuICAgIH0pO1xuICB9O1xuXG4gIFRyZWVtYXBWaWV3LnByb3RvdHlwZS5fY2xlYXJDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250cm9sbGVyID0gdGhpcy5fY29udHJvbGxlcjtcblxuICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmRpc3Bvc2UoKTtcbiAgICAgIGNvbnRyb2xsZXIgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBUcmVlbWFwVmlldy5wcm90b3R5cGUuX29uUGFuID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgIT09ICdhbmltYXRpbmcnICYmIChNYXRoLmFicyhlLmR4KSA+IERSQUdfVEhSRVNIT0xEIHx8IE1hdGguYWJzKGUuZHkpID4gRFJBR19USFJFU0hPTEQpKSB7XG4gICAgICAvLyBUaGVzZSBwYXJhbSBtdXN0IG5vdCBiZSBjYWNoZWQuXG4gICAgICB2YXIgcm9vdCA9IHRoaXMuc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLnRyZWUucm9vdDtcblxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJvb3RMYXlvdXQgPSByb290LmdldExheW91dCgpO1xuXG4gICAgICBpZiAoIXJvb3RMYXlvdXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgIHR5cGU6ICd0cmVlbWFwTW92ZScsXG4gICAgICAgIGZyb206IHRoaXMudWlkLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5zZXJpZXNNb2RlbC5pZCxcbiAgICAgICAgcm9vdFJlY3Q6IHtcbiAgICAgICAgICB4OiByb290TGF5b3V0LnggKyBlLmR4LFxuICAgICAgICAgIHk6IHJvb3RMYXlvdXQueSArIGUuZHksXG4gICAgICAgICAgd2lkdGg6IHJvb3RMYXlvdXQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiByb290TGF5b3V0LmhlaWdodFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgVHJlZW1hcFZpZXcucHJvdG90eXBlLl9vblpvb20gPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVggPSBlLm9yaWdpblg7XG4gICAgdmFyIG1vdXNlWSA9IGUub3JpZ2luWTtcblxuICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gJ2FuaW1hdGluZycpIHtcbiAgICAgIC8vIFRoZXNlIHBhcmFtIG11c3Qgbm90IGJlIGNhY2hlZC5cbiAgICAgIHZhciByb290ID0gdGhpcy5zZXJpZXNNb2RlbC5nZXREYXRhKCkudHJlZS5yb290O1xuXG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcm9vdExheW91dCA9IHJvb3QuZ2V0TGF5b3V0KCk7XG5cbiAgICAgIGlmICghcm9vdExheW91dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChyb290TGF5b3V0LngsIHJvb3RMYXlvdXQueSwgcm9vdExheW91dC53aWR0aCwgcm9vdExheW91dC5oZWlnaHQpO1xuICAgICAgdmFyIGxheW91dEluZm8gPSB0aGlzLnNlcmllc01vZGVsLmxheW91dEluZm87IC8vIFRyYW5zZm9ybSBtb3VzZSBjb29yZCBmcm9tIGdsb2JhbCB0byBjb250YWluZXJHcm91cC5cblxuICAgICAgbW91c2VYIC09IGxheW91dEluZm8ueDtcbiAgICAgIG1vdXNlWSAtPSBsYXlvdXRJbmZvLnk7IC8vIFNjYWxlIHJvb3QgYm91bmRpbmcgcmVjdC5cblxuICAgICAgdmFyIG0gPSBtYXRyaXguY3JlYXRlKCk7XG4gICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstbW91c2VYLCAtbW91c2VZXSk7XG4gICAgICBtYXRyaXguc2NhbGUobSwgbSwgW2Uuc2NhbGUsIGUuc2NhbGVdKTtcbiAgICAgIG1hdHJpeC50cmFuc2xhdGUobSwgbSwgW21vdXNlWCwgbW91c2VZXSk7XG4gICAgICByZWN0LmFwcGx5VHJhbnNmb3JtKG0pO1xuICAgICAgdGhpcy5hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICB0eXBlOiAndHJlZW1hcFJlbmRlcicsXG4gICAgICAgIGZyb206IHRoaXMudWlkLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5zZXJpZXNNb2RlbC5pZCxcbiAgICAgICAgcm9vdFJlY3Q6IHtcbiAgICAgICAgICB4OiByZWN0LngsXG4gICAgICAgICAgeTogcmVjdC55LFxuICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIFRyZWVtYXBWaWV3LnByb3RvdHlwZS5faW5pdEV2ZW50cyA9IGZ1bmN0aW9uIChjb250YWluZXJHcm91cCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBjb250YWluZXJHcm91cC5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKF90aGlzLl9zdGF0ZSAhPT0gJ3JlYWR5Jykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlQ2xpY2sgPSBfdGhpcy5zZXJpZXNNb2RlbC5nZXQoJ25vZGVDbGljaycsIHRydWUpO1xuXG4gICAgICBpZiAoIW5vZGVDbGljaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnZXRJbmZvID0gX3RoaXMuZmluZFRhcmdldChlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG5cbiAgICAgIGlmICghdGFyZ2V0SW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gdGFyZ2V0SW5mby5ub2RlO1xuXG4gICAgICBpZiAobm9kZS5nZXRMYXlvdXQoKS5pc0xlYWZSb290KSB7XG4gICAgICAgIF90aGlzLl9yb290VG9Ob2RlKHRhcmdldEluZm8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5vZGVDbGljayA9PT0gJ3pvb21Ub05vZGUnKSB7XG4gICAgICAgICAgX3RoaXMuX3pvb21Ub05vZGUodGFyZ2V0SW5mbyk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZUNsaWNrID09PSAnbGluaycpIHtcbiAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gbm9kZS5ob3N0VHJlZS5kYXRhLmdldEl0ZW1Nb2RlbChub2RlLmRhdGFJbmRleCk7XG4gICAgICAgICAgdmFyIGxpbmsgPSBpdGVtTW9kZWwuZ2V0KCdsaW5rJywgdHJ1ZSk7XG4gICAgICAgICAgdmFyIGxpbmtUYXJnZXQgPSBpdGVtTW9kZWwuZ2V0KCd0YXJnZXQnLCB0cnVlKSB8fCAnYmxhbmsnO1xuICAgICAgICAgIGxpbmsgJiYgd2luZG93T3BlbihsaW5rLCBsaW5rVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4gIFRyZWVtYXBWaWV3LnByb3RvdHlwZS5fcmVuZGVyQnJlYWRjcnVtYiA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgYXBpLCB0YXJnZXRJbmZvKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICghdGFyZ2V0SW5mbykge1xuICAgICAgdGFyZ2V0SW5mbyA9IHNlcmllc01vZGVsLmdldCgnbGVhZkRlcHRoJywgdHJ1ZSkgIT0gbnVsbCA/IHtcbiAgICAgICAgbm9kZTogc2VyaWVzTW9kZWwuZ2V0Vmlld1Jvb3QoKVxuICAgICAgfSAvLyBGSVhNRVxuICAgICAgLy8gYmV0dGVyIHdheT9cbiAgICAgIC8vIEZpbmQgYnJlYWRjcnVtYiB0YWlsIG9uIGNlbnRlciBvZiBjb250YWluZXJHcm91cC5cbiAgICAgIDogdGhpcy5maW5kVGFyZ2V0KGFwaS5nZXRXaWR0aCgpIC8gMiwgYXBpLmdldEhlaWdodCgpIC8gMik7XG5cbiAgICAgIGlmICghdGFyZ2V0SW5mbykge1xuICAgICAgICB0YXJnZXRJbmZvID0ge1xuICAgICAgICAgIG5vZGU6IHNlcmllc01vZGVsLmdldERhdGEoKS50cmVlLnJvb3RcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAodGhpcy5fYnJlYWRjcnVtYiB8fCAodGhpcy5fYnJlYWRjcnVtYiA9IG5ldyBCcmVhZGNydW1iKHRoaXMuZ3JvdXApKSkucmVuZGVyKHNlcmllc01vZGVsLCBhcGksIHRhcmdldEluZm8ubm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChfdGhpcy5fc3RhdGUgIT09ICdhbmltYXRpbmcnKSB7XG4gICAgICAgIGhlbHBlci5hYm92ZVZpZXdSb290KHNlcmllc01vZGVsLmdldFZpZXdSb290KCksIG5vZGUpID8gX3RoaXMuX3Jvb3RUb05vZGUoe1xuICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgfSkgOiBfdGhpcy5fem9vbVRvTm9kZSh7XG4gICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIFRyZWVtYXBWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xlYXJDb250cm9sbGVyKCk7XG5cbiAgICB0aGlzLl9jb250YWluZXJHcm91cCAmJiB0aGlzLl9jb250YWluZXJHcm91cC5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLl9zdG9yYWdlID0gY3JlYXRlU3RvcmFnZSgpO1xuICAgIHRoaXMuX3N0YXRlID0gJ3JlYWR5JztcbiAgICB0aGlzLl9icmVhZGNydW1iICYmIHRoaXMuX2JyZWFkY3J1bWIucmVtb3ZlKCk7XG4gIH07XG5cbiAgVHJlZW1hcFZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xlYXJDb250cm9sbGVyKCk7XG4gIH07XG5cbiAgVHJlZW1hcFZpZXcucHJvdG90eXBlLl96b29tVG9Ob2RlID0gZnVuY3Rpb24gKHRhcmdldEluZm8pIHtcbiAgICB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAndHJlZW1hcFpvb21Ub05vZGUnLFxuICAgICAgZnJvbTogdGhpcy51aWQsXG4gICAgICBzZXJpZXNJZDogdGhpcy5zZXJpZXNNb2RlbC5pZCxcbiAgICAgIHRhcmdldE5vZGU6IHRhcmdldEluZm8ubm9kZVxuICAgIH0pO1xuICB9O1xuXG4gIFRyZWVtYXBWaWV3LnByb3RvdHlwZS5fcm9vdFRvTm9kZSA9IGZ1bmN0aW9uICh0YXJnZXRJbmZvKSB7XG4gICAgdGhpcy5hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ3RyZWVtYXBSb290VG9Ob2RlJyxcbiAgICAgIGZyb206IHRoaXMudWlkLFxuICAgICAgc2VyaWVzSWQ6IHRoaXMuc2VyaWVzTW9kZWwuaWQsXG4gICAgICB0YXJnZXROb2RlOiB0YXJnZXRJbmZvLm5vZGVcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggR2xvYmFsIGNvb3JkIHguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IEdsb2JhbCBjb29yZCB5LlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluZm8gSWYgbm90IGZvdW5kLCByZXR1cm4gdW5kZWZpbmVkO1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZm8ubm9kZSBUYXJnZXQgbm9kZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmZvLm9mZnNldFggeCByZWZlciB0byB0YXJnZXQgbm9kZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmZvLm9mZnNldFkgeSByZWZlciB0byB0YXJnZXQgbm9kZS5cbiAgICovXG5cblxuICBUcmVlbWFwVmlldy5wcm90b3R5cGUuZmluZFRhcmdldCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIHRhcmdldEluZm87XG4gICAgdmFyIHZpZXdSb290ID0gdGhpcy5zZXJpZXNNb2RlbC5nZXRWaWV3Um9vdCgpO1xuICAgIHZpZXdSb290LmVhY2hOb2RlKHtcbiAgICAgIGF0dHI6ICd2aWV3Q2hpbGRyZW4nLFxuICAgICAgb3JkZXI6ICdwcmVvcmRlcidcbiAgICB9LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGJnRWwgPSB0aGlzLl9zdG9yYWdlLmJhY2tncm91bmRbbm9kZS5nZXRSYXdJbmRleCgpXTsgLy8gSWYgaW52aXNpYmxlLCB0aGVyZSBtaWdodCBiZSBubyBlbGVtZW50LlxuXG5cbiAgICAgIGlmIChiZ0VsKSB7XG4gICAgICAgIHZhciBwb2ludCA9IGJnRWwudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgICAgICB2YXIgc2hhcGUgPSBiZ0VsLnNoYXBlOyAvLyBGb3IgcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbiwgZG9udCB1c2UgJ2dldEJvdW5kaW5nUmVjdCcuXG5cbiAgICAgICAgaWYgKHNoYXBlLnggPD0gcG9pbnRbMF0gJiYgcG9pbnRbMF0gPD0gc2hhcGUueCArIHNoYXBlLndpZHRoICYmIHNoYXBlLnkgPD0gcG9pbnRbMV0gJiYgcG9pbnRbMV0gPD0gc2hhcGUueSArIHNoYXBlLmhlaWdodCkge1xuICAgICAgICAgIHRhcmdldEluZm8gPSB7XG4gICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgb2Zmc2V0WDogcG9pbnRbMF0sXG4gICAgICAgICAgICBvZmZzZXRZOiBwb2ludFsxXVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBTdXBwcmVzcyB2aXNpdCBzdWJ0cmVlLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRhcmdldEluZm87XG4gIH07XG5cbiAgVHJlZW1hcFZpZXcudHlwZSA9ICd0cmVlbWFwJztcbiAgcmV0dXJuIFRyZWVtYXBWaWV3O1xufShDaGFydFZpZXcpO1xuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JhZ2UoKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZUdyb3VwOiBbXSxcbiAgICBiYWNrZ3JvdW5kOiBbXSxcbiAgICBjb250ZW50OiBbXVxuICB9O1xufVxuLyoqXG4gKiBAaW5uZXJcbiAqIEByZXR1cm4gUmV0dXJuIHVuZGVmaW5lZCBtZWFucyBkbyBub3QgdHJhdmVsIGZ1cnRoZXIuXG4gKi9cblxuXG5mdW5jdGlvbiByZW5kZXJOb2RlKHNlcmllc01vZGVsLCB0aGlzU3RvcmFnZSwgb2xkU3RvcmFnZSwgcmVSb290LCBsYXN0c0ZvckFuaW1hdGlvbiwgd2lsbEludmlzaWJsZUVscywgdGhpc05vZGUsIG9sZE5vZGUsIHBhcmVudEdyb3VwLCBkZXB0aCkge1xuICAvLyBXaGV0aGVyIHVuZGVyIHZpZXdSb290LlxuICBpZiAoIXRoaXNOb2RlKSB7XG4gICAgLy8gRGVsZXRpbmcgbm9kZXMgd2lsbCBiZSBwZXJmb3JtZWQgZmluYWxseS4gVGhpcyBtZXRob2QganVzdCBmaW5kXG4gICAgLy8gZWxlbWVudCBmcm9tIG9sZCBzdG9yYWdlLCBvciBjcmVhdGUgbmV3IGVsZW1lbnQsIHNldCB0aGVtIHRvIG5ld1xuICAgIC8vIHN0b3JhZ2UsIGFuZCBzZXQgc3R5bGVzLlxuICAgIHJldHVybjtcbiAgfSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFN0YXJ0IG9mIGNsb3N1cmUgdmFyaWFibGVzIGF2YWlsYWJsZSBpbiBcIlByb2NlZHVyZXMgaW4gcmVuZGVyTm9kZVwiLlxuXG5cbiAgdmFyIHRoaXNMYXlvdXQgPSB0aGlzTm9kZS5nZXRMYXlvdXQoKTtcbiAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gIHZhciBub2RlTW9kZWwgPSB0aGlzTm9kZS5nZXRNb2RlbCgpOyAvLyBPbmx5IGZvciBlbmFibGluZyBoaWdobGlnaHQvZG93bnBsYXkuIENsZWFyIGZpcnN0bHkuXG4gIC8vIEJlY2F1c2Ugc29tZSBub2RlIHdpbGwgbm90IGJlIHJlbmRlcmVkLlxuXG4gIGRhdGEuc2V0SXRlbUdyYXBoaWNFbCh0aGlzTm9kZS5kYXRhSW5kZXgsIG51bGwpO1xuXG4gIGlmICghdGhpc0xheW91dCB8fCAhdGhpc0xheW91dC5pc0luVmlldykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0aGlzV2lkdGggPSB0aGlzTGF5b3V0LndpZHRoO1xuICB2YXIgdGhpc0hlaWdodCA9IHRoaXNMYXlvdXQuaGVpZ2h0O1xuICB2YXIgYm9yZGVyV2lkdGggPSB0aGlzTGF5b3V0LmJvcmRlcldpZHRoO1xuICB2YXIgdGhpc0ludmlzaWJsZSA9IHRoaXNMYXlvdXQuaW52aXNpYmxlO1xuICB2YXIgdGhpc1Jhd0luZGV4ID0gdGhpc05vZGUuZ2V0UmF3SW5kZXgoKTtcbiAgdmFyIG9sZFJhd0luZGV4ID0gb2xkTm9kZSAmJiBvbGROb2RlLmdldFJhd0luZGV4KCk7XG4gIHZhciB0aGlzVmlld0NoaWxkcmVuID0gdGhpc05vZGUudmlld0NoaWxkcmVuO1xuICB2YXIgdXBwZXJIZWlnaHQgPSB0aGlzTGF5b3V0LnVwcGVySGVpZ2h0O1xuICB2YXIgaXNQYXJlbnQgPSB0aGlzVmlld0NoaWxkcmVuICYmIHRoaXNWaWV3Q2hpbGRyZW4ubGVuZ3RoO1xuICB2YXIgaXRlbVN0eWxlTm9ybWFsTW9kZWwgPSBub2RlTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpO1xuICB2YXIgaXRlbVN0eWxlRW1waGFzaXNNb2RlbCA9IG5vZGVNb2RlbC5nZXRNb2RlbChbJ2VtcGhhc2lzJywgJ2l0ZW1TdHlsZSddKTtcbiAgdmFyIGl0ZW1TdHlsZUJsdXJNb2RlbCA9IG5vZGVNb2RlbC5nZXRNb2RlbChbJ2JsdXInLCAnaXRlbVN0eWxlJ10pO1xuICB2YXIgaXRlbVN0eWxlU2VsZWN0TW9kZWwgPSBub2RlTW9kZWwuZ2V0TW9kZWwoWydzZWxlY3QnLCAnaXRlbVN0eWxlJ10pO1xuICB2YXIgYm9yZGVyUmFkaXVzID0gaXRlbVN0eWxlTm9ybWFsTW9kZWwuZ2V0KCdib3JkZXJSYWRpdXMnKSB8fCAwOyAvLyBFbmQgb2YgY2xvc3VyZSBhcmlhYmxlcyBhdmFpbGFibGUgaW4gXCJQcm9jZWR1cmVzIGluIHJlbmRlck5vZGVcIi5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gTm9kZSBncm91cFxuXG4gIHZhciBncm91cCA9IGdpdmVHcmFwaGljKCdub2RlR3JvdXAnLCBHcm91cCk7XG5cbiAgaWYgKCFncm91cCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBhcmVudEdyb3VwLmFkZChncm91cCk7IC8vIHgseSBhcmUgbm90IHNldCB3aGVuIGVsIGlzIGFib3ZlIHZpZXcgcm9vdC5cblxuICBncm91cC54ID0gdGhpc0xheW91dC54IHx8IDA7XG4gIGdyb3VwLnkgPSB0aGlzTGF5b3V0LnkgfHwgMDtcbiAgZ3JvdXAubWFya1JlZHJhdygpO1xuICBpbm5lcihncm91cCkubm9kZVdpZHRoID0gdGhpc1dpZHRoO1xuICBpbm5lcihncm91cCkubm9kZUhlaWdodCA9IHRoaXNIZWlnaHQ7XG5cbiAgaWYgKHRoaXNMYXlvdXQuaXNBYm92ZVZpZXdSb290KSB7XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9IC8vIEJhY2tncm91bmRcblxuXG4gIHZhciBiZyA9IGdpdmVHcmFwaGljKCdiYWNrZ3JvdW5kJywgUmVjdCwgZGVwdGgsIFpfQkcpO1xuICBiZyAmJiByZW5kZXJCYWNrZ3JvdW5kKGdyb3VwLCBiZywgaXNQYXJlbnQgJiYgdGhpc0xheW91dC51cHBlckxhYmVsSGVpZ2h0KTtcbiAgdmFyIGZvY3VzID0gbm9kZU1vZGVsLmdldChbJ2VtcGhhc2lzJywgJ2ZvY3VzJ10pO1xuICB2YXIgYmx1clNjb3BlID0gbm9kZU1vZGVsLmdldChbJ2VtcGhhc2lzJywgJ2JsdXJTY29wZSddKTtcbiAgdmFyIGZvY3VzRGF0YUluZGljZXMgPSBmb2N1cyA9PT0gJ2FuY2VzdG9yJyA/IHRoaXNOb2RlLmdldEFuY2VzdG9yc0luZGljZXMoKSA6IGZvY3VzID09PSAnZGVzY2VuZGFudCcgPyB0aGlzTm9kZS5nZXREZXNjZW5kYW50SW5kaWNlcygpIDogbnVsbDsgLy8gTm8gY2hpbGRyZW4sIHJlbmRlciBjb250ZW50LlxuXG4gIGlmIChpc1BhcmVudCkge1xuICAgIC8vIEJlY2F1c2Ugb2YgdGhlIGltcGxlbWVudGF0aW9uIGFib3V0IFwidHJhdmVyc2VcIiBpbiBncmFwaGljIGhvdmVyIHN0eWxlLCB3ZVxuICAgIC8vIGNhbiBub3Qgc2V0IGhvdmVyIGxpc3RlbmVyIG9uIHRoZSBcImdyb3VwXCIgb2Ygbm9uLWxlYWYgbm9kZS4gT3RoZXJ3aXNlIHRoZVxuICAgIC8vIGhvdmVyIGV2ZW50IGZyb20gdGhlIGRlc2NlbmRlbnRzIHdpbGwgYmUgbGlzdGVuZXJlZC5cbiAgICBpZiAoaXNIaWdoRG93bkRpc3BhdGNoZXIoZ3JvdXApKSB7XG4gICAgICBzZXRBc0hpZ2hEb3duRGlzcGF0Y2hlcihncm91cCwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChiZykge1xuICAgICAgc2V0QXNIaWdoRG93bkRpc3BhdGNoZXIoYmcsIHRydWUpOyAvLyBPbmx5IGZvciBlbmFibGluZyBoaWdobGlnaHQvZG93bnBsYXkuXG5cbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbCh0aGlzTm9kZS5kYXRhSW5kZXgsIGJnKTtcbiAgICAgIGVuYWJsZUhvdmVyRm9jdXMoYmcsIGZvY3VzRGF0YUluZGljZXMgfHwgZm9jdXMsIGJsdXJTY29wZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZW50ID0gZ2l2ZUdyYXBoaWMoJ2NvbnRlbnQnLCBSZWN0LCBkZXB0aCwgWl9DT05URU5UKTtcbiAgICBjb250ZW50ICYmIHJlbmRlckNvbnRlbnQoZ3JvdXAsIGNvbnRlbnQpO1xuXG4gICAgaWYgKGJnICYmIGlzSGlnaERvd25EaXNwYXRjaGVyKGJnKSkge1xuICAgICAgc2V0QXNIaWdoRG93bkRpc3BhdGNoZXIoYmcsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBzZXRBc0hpZ2hEb3duRGlzcGF0Y2hlcihncm91cCwgdHJ1ZSk7IC8vIE9ubHkgZm9yIGVuYWJsaW5nIGhpZ2hsaWdodC9kb3ducGxheS5cblxuICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbCh0aGlzTm9kZS5kYXRhSW5kZXgsIGdyb3VwKTtcbiAgICBlbmFibGVIb3ZlckZvY3VzKGdyb3VwLCBmb2N1c0RhdGFJbmRpY2VzIHx8IGZvY3VzLCBibHVyU2NvcGUpO1xuICB9XG5cbiAgcmV0dXJuIGdyb3VwOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgUHJvY2VkdXJlcyBpbiByZW5kZXJOb2RlIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGZ1bmN0aW9uIHJlbmRlckJhY2tncm91bmQoZ3JvdXAsIGJnLCB1c2VVcHBlckxhYmVsKSB7XG4gICAgdmFyIGVjRGF0YSA9IGdldEVDRGF0YShiZyk7IC8vIEZvciB0b29sdGlwLlxuXG4gICAgZWNEYXRhLmRhdGFJbmRleCA9IHRoaXNOb2RlLmRhdGFJbmRleDtcbiAgICBlY0RhdGEuc2VyaWVzSW5kZXggPSBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleDtcbiAgICBiZy5zZXRTaGFwZSh7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiB0aGlzV2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXNIZWlnaHQsXG4gICAgICByOiBib3JkZXJSYWRpdXNcbiAgICB9KTtcblxuICAgIGlmICh0aGlzSW52aXNpYmxlKSB7XG4gICAgICAvLyBJZiBpbnZpc2libGUsIGRvIG5vdCBzZXQgdmlzdWFsLCBvdGhlcndpc2UgdGhlIGVsZW1lbnQgd2lsbFxuICAgICAgLy8gY2hhbmdlIGltbWVkaWF0ZWx5IGJlZm9yZSBhbmltYXRpb24uIFdlIHRoaW5rIGl0IGlzIE9LIHRvXG4gICAgICAvLyByZW1haW4gaXRzIG9yaWdpbiBjb2xvciB3aGVuIG1vdmluZyBvdXQgb2YgdGhlIHZpZXcgd2luZG93LlxuICAgICAgcHJvY2Vzc0ludmlzaWJsZShiZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJnLmludmlzaWJsZSA9IGZhbHNlO1xuICAgICAgdmFyIHN0eWxlID0gdGhpc05vZGUuZ2V0VmlzdWFsKCdzdHlsZScpO1xuICAgICAgdmFyIHZpc3VhbEJvcmRlckNvbG9yID0gc3R5bGUuc3Ryb2tlO1xuICAgICAgdmFyIG5vcm1hbFN0eWxlID0gZ2V0SXRlbVN0eWxlTm9ybWFsKGl0ZW1TdHlsZU5vcm1hbE1vZGVsKTtcbiAgICAgIG5vcm1hbFN0eWxlLmZpbGwgPSB2aXN1YWxCb3JkZXJDb2xvcjtcbiAgICAgIHZhciBlbXBoYXNpc1N0eWxlID0gZ2V0U3RhdGVJdGVtU3R5bGUoaXRlbVN0eWxlRW1waGFzaXNNb2RlbCk7XG4gICAgICBlbXBoYXNpc1N0eWxlLmZpbGwgPSBpdGVtU3R5bGVFbXBoYXNpc01vZGVsLmdldCgnYm9yZGVyQ29sb3InKTtcbiAgICAgIHZhciBibHVyU3R5bGUgPSBnZXRTdGF0ZUl0ZW1TdHlsZShpdGVtU3R5bGVCbHVyTW9kZWwpO1xuICAgICAgYmx1clN0eWxlLmZpbGwgPSBpdGVtU3R5bGVCbHVyTW9kZWwuZ2V0KCdib3JkZXJDb2xvcicpO1xuICAgICAgdmFyIHNlbGVjdFN0eWxlID0gZ2V0U3RhdGVJdGVtU3R5bGUoaXRlbVN0eWxlU2VsZWN0TW9kZWwpO1xuICAgICAgc2VsZWN0U3R5bGUuZmlsbCA9IGl0ZW1TdHlsZVNlbGVjdE1vZGVsLmdldCgnYm9yZGVyQ29sb3InKTtcblxuICAgICAgaWYgKHVzZVVwcGVyTGFiZWwpIHtcbiAgICAgICAgdmFyIHVwcGVyTGFiZWxXaWR0aCA9IHRoaXNXaWR0aCAtIDIgKiBib3JkZXJXaWR0aDtcbiAgICAgICAgcHJlcGFyZVRleHQoYmcsIHZpc3VhbEJvcmRlckNvbG9yLCB1cHBlckxhYmVsV2lkdGgsIHVwcGVySGVpZ2h0LCBzdHlsZS5vcGFjaXR5LCB7XG4gICAgICAgICAgeDogYm9yZGVyV2lkdGgsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogdXBwZXJMYWJlbFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogdXBwZXJIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIEZvciBvbGQgYmcuXG4gICAgICBlbHNlIHtcbiAgICAgICAgICBiZy5yZW1vdmVUZXh0Q29udGVudCgpO1xuICAgICAgICB9XG5cbiAgICAgIGJnLnNldFN0eWxlKG5vcm1hbFN0eWxlKTtcbiAgICAgIGJnLmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpLnN0eWxlID0gZW1waGFzaXNTdHlsZTtcbiAgICAgIGJnLmVuc3VyZVN0YXRlKCdibHVyJykuc3R5bGUgPSBibHVyU3R5bGU7XG4gICAgICBiZy5lbnN1cmVTdGF0ZSgnc2VsZWN0Jykuc3R5bGUgPSBzZWxlY3RTdHlsZTtcbiAgICAgIHNldERlZmF1bHRTdGF0ZVByb3h5KGJnKTtcbiAgICB9XG5cbiAgICBncm91cC5hZGQoYmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyQ29udGVudChncm91cCwgY29udGVudCkge1xuICAgIHZhciBlY0RhdGEgPSBnZXRFQ0RhdGEoY29udGVudCk7IC8vIEZvciB0b29sdGlwLlxuXG4gICAgZWNEYXRhLmRhdGFJbmRleCA9IHRoaXNOb2RlLmRhdGFJbmRleDtcbiAgICBlY0RhdGEuc2VyaWVzSW5kZXggPSBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleDtcbiAgICB2YXIgY29udGVudFdpZHRoID0gTWF0aC5tYXgodGhpc1dpZHRoIC0gMiAqIGJvcmRlcldpZHRoLCAwKTtcbiAgICB2YXIgY29udGVudEhlaWdodCA9IE1hdGgubWF4KHRoaXNIZWlnaHQgLSAyICogYm9yZGVyV2lkdGgsIDApO1xuICAgIGNvbnRlbnQuY3VsbGluZyA9IHRydWU7XG4gICAgY29udGVudC5zZXRTaGFwZSh7XG4gICAgICB4OiBib3JkZXJXaWR0aCxcbiAgICAgIHk6IGJvcmRlcldpZHRoLFxuICAgICAgd2lkdGg6IGNvbnRlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogY29udGVudEhlaWdodCxcbiAgICAgIHI6IGJvcmRlclJhZGl1c1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXNJbnZpc2libGUpIHtcbiAgICAgIC8vIElmIGludmlzaWJsZSwgZG8gbm90IHNldCB2aXN1YWwsIG90aGVyd2lzZSB0aGUgZWxlbWVudCB3aWxsXG4gICAgICAvLyBjaGFuZ2UgaW1tZWRpYXRlbHkgYmVmb3JlIGFuaW1hdGlvbi4gV2UgdGhpbmsgaXQgaXMgT0sgdG9cbiAgICAgIC8vIHJlbWFpbiBpdHMgb3JpZ2luIGNvbG9yIHdoZW4gbW92aW5nIG91dCBvZiB0aGUgdmlldyB3aW5kb3cuXG4gICAgICBwcm9jZXNzSW52aXNpYmxlKGNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50LmludmlzaWJsZSA9IGZhbHNlO1xuICAgICAgdmFyIG5vZGVTdHlsZSA9IHRoaXNOb2RlLmdldFZpc3VhbCgnc3R5bGUnKTtcbiAgICAgIHZhciB2aXN1YWxDb2xvciA9IG5vZGVTdHlsZS5maWxsO1xuICAgICAgdmFyIG5vcm1hbFN0eWxlID0gZ2V0SXRlbVN0eWxlTm9ybWFsKGl0ZW1TdHlsZU5vcm1hbE1vZGVsKTtcbiAgICAgIG5vcm1hbFN0eWxlLmZpbGwgPSB2aXN1YWxDb2xvcjtcbiAgICAgIG5vcm1hbFN0eWxlLmRlY2FsID0gbm9kZVN0eWxlLmRlY2FsO1xuICAgICAgdmFyIGVtcGhhc2lzU3R5bGUgPSBnZXRTdGF0ZUl0ZW1TdHlsZShpdGVtU3R5bGVFbXBoYXNpc01vZGVsKTtcbiAgICAgIHZhciBibHVyU3R5bGUgPSBnZXRTdGF0ZUl0ZW1TdHlsZShpdGVtU3R5bGVCbHVyTW9kZWwpO1xuICAgICAgdmFyIHNlbGVjdFN0eWxlID0gZ2V0U3RhdGVJdGVtU3R5bGUoaXRlbVN0eWxlU2VsZWN0TW9kZWwpO1xuICAgICAgcHJlcGFyZVRleHQoY29udGVudCwgdmlzdWFsQ29sb3IsIGNvbnRlbnRXaWR0aCwgbm9kZVN0eWxlLm9wYWNpdHksIGNvbnRlbnRIZWlnaHQpO1xuICAgICAgY29udGVudC5zZXRTdHlsZShub3JtYWxTdHlsZSk7XG4gICAgICBjb250ZW50LmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpLnN0eWxlID0gZW1waGFzaXNTdHlsZTtcbiAgICAgIGNvbnRlbnQuZW5zdXJlU3RhdGUoJ2JsdXInKS5zdHlsZSA9IGJsdXJTdHlsZTtcbiAgICAgIGNvbnRlbnQuZW5zdXJlU3RhdGUoJ3NlbGVjdCcpLnN0eWxlID0gc2VsZWN0U3R5bGU7XG4gICAgICBzZXREZWZhdWx0U3RhdGVQcm94eShjb250ZW50KTtcbiAgICB9XG5cbiAgICBncm91cC5hZGQoY29udGVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzSW52aXNpYmxlKGVsZW1lbnQpIHtcbiAgICAvLyBEZWxheSBpbnZpc2libGUgc2V0dGluZyB1dGlsbCBhbmltYXRpb24gZmluaXNoZWQsXG4gICAgLy8gYXZvaWQgZWxlbWVudCB2YW5pc2ggc3VkZGVubHkgYmVmb3JlIGFuaW1hdGlvbi5cbiAgICAhZWxlbWVudC5pbnZpc2libGUgJiYgd2lsbEludmlzaWJsZUVscy5wdXNoKGVsZW1lbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRleHQocmVjdEVsLCB2aXN1YWxDb2xvciwgdmlzdWFsT3BhY2l0eSwgd2lkdGgsIGhlaWdodCwgdXBwZXJMYWJlbFJlY3QpIHtcbiAgICB2YXIgbm9ybWFsTGFiZWxNb2RlbCA9IG5vZGVNb2RlbC5nZXRNb2RlbCh1cHBlckxhYmVsUmVjdCA/IFBBVEhfVVBQRVJMQUJFTF9OT1JNQUwgOiBQQVRIX0xBQkVMX05PQU1BTCk7XG4gICAgdmFyIHRleHQgPSByZXRyaWV2ZShzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbCh0aGlzTm9kZS5kYXRhSW5kZXgsICdub3JtYWwnLCBudWxsLCBudWxsLCBub3JtYWxMYWJlbE1vZGVsLmdldCgnZm9ybWF0dGVyJykpLCBjb252ZXJ0T3B0aW9uSWROYW1lKG5vZGVNb2RlbC5nZXQoJ25hbWUnKSwgbnVsbCkpO1xuXG4gICAgaWYgKCF1cHBlckxhYmVsUmVjdCAmJiB0aGlzTGF5b3V0LmlzTGVhZlJvb3QpIHtcbiAgICAgIHZhciBpY29uQ2hhciA9IHNlcmllc01vZGVsLmdldCgnZHJpbGxEb3duSWNvbicsIHRydWUpO1xuICAgICAgdGV4dCA9IGljb25DaGFyID8gaWNvbkNoYXIgKyAnICcgKyB0ZXh0IDogdGV4dDtcbiAgICB9XG5cbiAgICB2YXIgaXNTaG93ID0gbm9ybWFsTGFiZWxNb2RlbC5nZXRTaGFsbG93KCdzaG93Jyk7XG4gICAgc2V0TGFiZWxTdHlsZShyZWN0RWwsIGdldExhYmVsU3RhdGVzTW9kZWxzKG5vZGVNb2RlbCwgdXBwZXJMYWJlbFJlY3QgPyBQQVRIX1VQUEVSTEFCRUxfTk9STUFMIDogUEFUSF9MQUJFTF9OT0FNQUwpLCB7XG4gICAgICBkZWZhdWx0VGV4dDogaXNTaG93ID8gdGV4dCA6IG51bGwsXG4gICAgICBpbmhlcml0Q29sb3I6IHZpc3VhbENvbG9yLFxuICAgICAgZGVmYXVsdE9wYWNpdHk6IHZpc3VhbE9wYWNpdHksXG4gICAgICBsYWJlbEZldGNoZXI6IHNlcmllc01vZGVsLFxuICAgICAgbGFiZWxEYXRhSW5kZXg6IHRoaXNOb2RlLmRhdGFJbmRleFxuICAgIH0pO1xuICAgIHZhciB0ZXh0RWwgPSByZWN0RWwuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICB2YXIgdGV4dFN0eWxlID0gdGV4dEVsLnN0eWxlO1xuICAgIHZhciB0ZXh0UGFkZGluZyA9IG5vcm1hbGl6ZUNzc0FycmF5KHRleHRTdHlsZS5wYWRkaW5nIHx8IDApO1xuXG4gICAgaWYgKHVwcGVyTGFiZWxSZWN0KSB7XG4gICAgICByZWN0RWwuc2V0VGV4dENvbmZpZyh7XG4gICAgICAgIGxheW91dFJlY3Q6IHVwcGVyTGFiZWxSZWN0XG4gICAgICB9KTtcbiAgICAgIHRleHRFbC5kaXNhYmxlTGFiZWxMYXlvdXQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRleHRFbC5iZWZvcmVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgd2lkdGggPSBNYXRoLm1heCgodXBwZXJMYWJlbFJlY3QgPyB1cHBlckxhYmVsUmVjdC53aWR0aCA6IHJlY3RFbC5zaGFwZS53aWR0aCkgLSB0ZXh0UGFkZGluZ1sxXSAtIHRleHRQYWRkaW5nWzNdLCAwKTtcbiAgICAgIHZhciBoZWlnaHQgPSBNYXRoLm1heCgodXBwZXJMYWJlbFJlY3QgPyB1cHBlckxhYmVsUmVjdC5oZWlnaHQgOiByZWN0RWwuc2hhcGUuaGVpZ2h0KSAtIHRleHRQYWRkaW5nWzBdIC0gdGV4dFBhZGRpbmdbMl0sIDApO1xuXG4gICAgICBpZiAodGV4dFN0eWxlLndpZHRoICE9PSB3aWR0aCB8fCB0ZXh0U3R5bGUuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgdGV4dEVsLnNldFN0eWxlKHtcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRleHRTdHlsZS50cnVuY2F0ZU1pbkNoYXIgPSAyO1xuICAgIHRleHRTdHlsZS5saW5lT3ZlcmZsb3cgPSAndHJ1bmNhdGUnO1xuICAgIGFkZERyaWxsRG93bkljb24odGV4dFN0eWxlLCB1cHBlckxhYmVsUmVjdCwgdGhpc0xheW91dCk7XG4gICAgdmFyIHRleHRFbXBoYXNpc1N0YXRlID0gdGV4dEVsLmdldFN0YXRlKCdlbXBoYXNpcycpO1xuICAgIGFkZERyaWxsRG93bkljb24odGV4dEVtcGhhc2lzU3RhdGUgPyB0ZXh0RW1waGFzaXNTdGF0ZS5zdHlsZSA6IG51bGwsIHVwcGVyTGFiZWxSZWN0LCB0aGlzTGF5b3V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZERyaWxsRG93bkljb24oc3R5bGUsIHVwcGVyTGFiZWxSZWN0LCB0aGlzTGF5b3V0KSB7XG4gICAgdmFyIHRleHQgPSBzdHlsZSA/IHN0eWxlLnRleHQgOiBudWxsO1xuXG4gICAgaWYgKCF1cHBlckxhYmVsUmVjdCAmJiB0aGlzTGF5b3V0LmlzTGVhZlJvb3QgJiYgdGV4dCAhPSBudWxsKSB7XG4gICAgICB2YXIgaWNvbkNoYXIgPSBzZXJpZXNNb2RlbC5nZXQoJ2RyaWxsRG93bkljb24nLCB0cnVlKTtcbiAgICAgIHN0eWxlLnRleHQgPSBpY29uQ2hhciA/IGljb25DaGFyICsgJyAnICsgdGV4dCA6IHRleHQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2l2ZUdyYXBoaWMoc3RvcmFnZU5hbWUsIEN0b3IsIGRlcHRoLCB6KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBvbGRSYXdJbmRleCAhPSBudWxsICYmIG9sZFN0b3JhZ2Vbc3RvcmFnZU5hbWVdW29sZFJhd0luZGV4XTtcbiAgICB2YXIgbGFzdHMgPSBsYXN0c0ZvckFuaW1hdGlvbltzdG9yYWdlTmFtZV07XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgLy8gUmVtb3ZlIGZyb20gb2xkU3RvcmFnZVxuICAgICAgb2xkU3RvcmFnZVtzdG9yYWdlTmFtZV1bb2xkUmF3SW5kZXhdID0gbnVsbDtcbiAgICAgIHByZXBhcmVBbmltYXRpb25XaGVuSGFzT2xkKGxhc3RzLCBlbGVtZW50KTtcbiAgICB9IC8vIElmIGludmlzaWJsZSBhbmQgbm8gb2xkIGVsZW1lbnQsIGRvIG5vdCBjcmVhdGUgbmV3IGVsZW1lbnQgKGZvciBvcHRpbWl6aW5nKS5cbiAgICBlbHNlIGlmICghdGhpc0ludmlzaWJsZSkge1xuICAgICAgICBlbGVtZW50ID0gbmV3IEN0b3IoKTtcblxuICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIERpc3BsYXlhYmxlKSB7XG4gICAgICAgICAgZWxlbWVudC56ID0gY2FsY3VsYXRlWihkZXB0aCwgeik7XG4gICAgICAgIH1cblxuICAgICAgICBwcmVwYXJlQW5pbWF0aW9uV2hlbk5vT2xkKGxhc3RzLCBlbGVtZW50KTtcbiAgICAgIH0gLy8gU2V0IHRvIHRoaXNTdG9yYWdlXG5cblxuICAgIHJldHVybiB0aGlzU3RvcmFnZVtzdG9yYWdlTmFtZV1bdGhpc1Jhd0luZGV4XSA9IGVsZW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlQW5pbWF0aW9uV2hlbkhhc09sZChsYXN0cywgZWxlbWVudCkge1xuICAgIHZhciBsYXN0Q2ZnID0gbGFzdHNbdGhpc1Jhd0luZGV4XSA9IHt9O1xuXG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgbGFzdENmZy5vbGRYID0gZWxlbWVudC54O1xuICAgICAgbGFzdENmZy5vbGRZID0gZWxlbWVudC55O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0Q2ZnLm9sZFNoYXBlID0gZXh0ZW5kKHt9LCBlbGVtZW50LnNoYXBlKTtcbiAgICB9XG4gIH0gLy8gSWYgYSBlbGVtZW50IGlzIG5ldywgd2UgbmVlZCB0byBmaW5kIHRoZSBhbmltYXRpb24gc3RhcnQgcG9pbnQgY2FyZWZ1bGx5LFxuICAvLyBvdGhlcndpc2UgaXQgd2lsbCBsb29rcyBzdHJhbmdlIHdoZW4gJ3pvb21Ub05vZGUnLlxuXG5cbiAgZnVuY3Rpb24gcHJlcGFyZUFuaW1hdGlvbldoZW5Ob09sZChsYXN0cywgZWxlbWVudCkge1xuICAgIHZhciBsYXN0Q2ZnID0gbGFzdHNbdGhpc1Jhd0luZGV4XSA9IHt9O1xuICAgIHZhciBwYXJlbnROb2RlID0gdGhpc05vZGUucGFyZW50Tm9kZTtcbiAgICB2YXIgaXNHcm91cCA9IGVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaGljLkdyb3VwO1xuXG4gICAgaWYgKHBhcmVudE5vZGUgJiYgKCFyZVJvb3QgfHwgcmVSb290LmRpcmVjdGlvbiA9PT0gJ2RyaWxsRG93bicpKSB7XG4gICAgICB2YXIgcGFyZW50T2xkWCA9IDA7XG4gICAgICB2YXIgcGFyZW50T2xkWSA9IDA7IC8vIE5ldyBub2RlcyBhcHBlYXIgZnJvbSByaWdodC1ib3R0b20gY29ybmVyIGluICd6b29tVG9Ob2RlJyBhbmltYXRpb24uXG4gICAgICAvLyBGb3IgY29udmVuaWVuY2UsIGdldCBvbGQgYm91bmRpbmcgcmVjdCBmcm9tIGJhY2tncm91bmQuXG5cbiAgICAgIHZhciBwYXJlbnRPbGRCZyA9IGxhc3RzRm9yQW5pbWF0aW9uLmJhY2tncm91bmRbcGFyZW50Tm9kZS5nZXRSYXdJbmRleCgpXTtcblxuICAgICAgaWYgKCFyZVJvb3QgJiYgcGFyZW50T2xkQmcgJiYgcGFyZW50T2xkQmcub2xkU2hhcGUpIHtcbiAgICAgICAgcGFyZW50T2xkWCA9IHBhcmVudE9sZEJnLm9sZFNoYXBlLndpZHRoO1xuICAgICAgICBwYXJlbnRPbGRZID0gcGFyZW50T2xkQmcub2xkU2hhcGUuaGVpZ2h0O1xuICAgICAgfSAvLyBXaGVuIG5vIHBhcmVudCBvbGQgc2hhcGUgZm91bmQsIGl0cyBwYXJlbnQgaXMgbmV3IHRvbyxcbiAgICAgIC8vIHNvIHdlIGNhbiBqdXN0IHVzZSB7eDowLCB5OjB9LlxuXG5cbiAgICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgIGxhc3RDZmcub2xkWCA9IDA7XG4gICAgICAgIGxhc3RDZmcub2xkWSA9IHBhcmVudE9sZFk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0Q2ZnLm9sZFNoYXBlID0ge1xuICAgICAgICAgIHg6IHBhcmVudE9sZFgsXG4gICAgICAgICAgeTogcGFyZW50T2xkWSxcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IC8vIEZhZGUgaW4sIHVzZXIgY2FuIGJlIGF3YXJlIHRoYXQgdGhlc2Ugbm9kZXMgYXJlIG5ldy5cblxuXG4gICAgbGFzdENmZy5mYWRlaW4gPSAhaXNHcm91cDtcbiAgfVxufSAvLyBXZSBjYW4gbm90IHNldCBhbGwgYmFja2dyb3VkIHdpdGggdGhlIHNhbWUgeiwgQmVjYXVzZSB0aGUgYmVoYXZpb3VyIG9mXG4vLyBkcmlsbCBkb3duIGFuZCByb2xsIHVwIGRpZmZlciBiYWNrZ3JvdW5kIGNyZWF0aW9uIHNlcXVlbmNlIGZyb20gdHJlZVxuLy8gaGllcmFyY2h5IHNlcXVlbmNlLCB3aGljaCBjYXVzZSB0aGF0IGxvd3NlciBiYWNrZ3JvdW5kIGVsZW1lbnQgb3ZlcmxhcFxuLy8gdXBwZXIgb25lcy4gU28gd2UgY2FsY3VsYXRlIHogYmFzZWQgb24gZGVwdGguXG4vLyBNb3Jlb3Zlciwgd2UgdHJ5IHRvIHNocmluayBkb3duIHogaW50ZXJ2YWwgdG8gWzAsIDFdIHRvIGF2b2lkIHRoYXRcbi8vIHRyZWVtYXAgd2l0aCBsYXJnZSB6IG92ZXJsYXBzIG90aGVyIGNvbXBvbmVudHMuXG5cblxuZnVuY3Rpb24gY2FsY3VsYXRlWihkZXB0aCwgekluTGV2ZWwpIHtcbiAgdmFyIHpiID0gZGVwdGggKiBaX0JBU0UgKyB6SW5MZXZlbDtcbiAgcmV0dXJuICh6YiAtIDEpIC8gemI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyZWVtYXBWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBpbnN0YWxsVHJlZW1hcEFjdGlvbiB9IGZyb20gJy4vdHJlZW1hcEFjdGlvbic7XG5pbXBvcnQgVHJlZW1hcFNlcmllc01vZGVsIGZyb20gJy4vVHJlZW1hcFNlcmllcyc7XG5pbXBvcnQgVHJlZW1hcFZpZXcgZnJvbSAnLi9UcmVlbWFwVmlldyc7XG5pbXBvcnQgdHJlZW1hcFZpc3VhbCBmcm9tICcuL3RyZWVtYXBWaXN1YWwnO1xuaW1wb3J0IHRyZWVtYXBMYXlvdXQgZnJvbSAnLi90cmVlbWFwTGF5b3V0JztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChUcmVlbWFwU2VyaWVzTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDaGFydFZpZXcoVHJlZW1hcFZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJWaXN1YWwodHJlZW1hcFZpc3VhbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckxheW91dCh0cmVlbWFwTGF5b3V0KTtcbiAgaW5zdGFsbFRyZWVtYXBBY3Rpb24ocmVnaXN0ZXJzKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4uL2hlbHBlci90cmVlSGVscGVyJztcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIGFjdGlvblR5cGVzID0gWyd0cmVlbWFwWm9vbVRvTm9kZScsICd0cmVlbWFwUmVuZGVyJywgJ3RyZWVtYXBNb3ZlJ107XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbFRyZWVtYXBBY3Rpb24ocmVnaXN0ZXJzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aW9uVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oe1xuICAgICAgdHlwZTogYWN0aW9uVHlwZXNbaV0sXG4gICAgICB1cGRhdGU6ICd1cGRhdGVWaWV3J1xuICAgIH0sIG5vb3ApO1xuICB9XG5cbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgICB0eXBlOiAndHJlZW1hcFJvb3RUb05vZGUnLFxuICAgIHVwZGF0ZTogJ3VwZGF0ZVZpZXcnXG4gIH0sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgIG1haW5UeXBlOiAnc2VyaWVzJyxcbiAgICAgIHN1YlR5cGU6ICd0cmVlbWFwJyxcbiAgICAgIHF1ZXJ5OiBwYXlsb2FkXG4gICAgfSwgaGFuZGxlUm9vdFRvTm9kZSk7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVSb290VG9Ob2RlKG1vZGVsLCBpbmRleCkge1xuICAgICAgdmFyIHR5cGVzID0gWyd0cmVlbWFwWm9vbVRvTm9kZScsICd0cmVlbWFwUm9vdFRvTm9kZSddO1xuICAgICAgdmFyIHRhcmdldEluZm8gPSBoZWxwZXIucmV0cmlldmVUYXJnZXRJbmZvKHBheWxvYWQsIHR5cGVzLCBtb2RlbCk7XG5cbiAgICAgIGlmICh0YXJnZXRJbmZvKSB7XG4gICAgICAgIHZhciBvcmlnaW5WaWV3Um9vdCA9IG1vZGVsLmdldFZpZXdSb290KCk7XG5cbiAgICAgICAgaWYgKG9yaWdpblZpZXdSb290KSB7XG4gICAgICAgICAgcGF5bG9hZC5kaXJlY3Rpb24gPSBoZWxwZXIuYWJvdmVWaWV3Um9vdChvcmlnaW5WaWV3Um9vdCwgdGFyZ2V0SW5mby5ub2RlKSA/ICdyb2xsVXAnIDogJ2RyaWxsRG93bic7XG4gICAgICAgIH1cblxuICAgICAgICBtb2RlbC5yZXNldFZpZXdSb290KHRhcmdldEluZm8ubm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKlxuKiBBIHRoaXJkLXBhcnR5IGxpY2Vuc2UgaXMgZW1iZWRlZCBmb3Igc29tZSBvZiB0aGUgY29kZSBpbiB0aGlzIGZpbGU6XG4qIFRoZSB0cmVlbWFwIGxheW91dCBpbXBsZW1lbnRhdGlvbiB3YXMgb3JpZ2luYWxseSBjb3BpZWQgZnJvbVxuKiBcImQzLmpzXCIgd2l0aCBzb21lIG1vZGlmaWNhdGlvbnMgbWFkZSBmb3IgdGhpcyBwcm9qZWN0LlxuKiAoU2VlIG1vcmUgZGV0YWlscyBpbiB0aGUgY29tbWVudCBvZiB0aGUgbWV0aG9kIFwic3F1YXJpZnlcIiBiZWxvdy4pXG4qIFRoZSB1c2Ugb2YgdGhlIHNvdXJjZSBjb2RlIG9mIHRoaXMgZmlsZSBpcyBhbHNvIHN1YmplY3QgdG8gdGhlIHRlcm1zXG4qIGFuZCBjb25zaXRpb25zIG9mIHRoZSBsaWNlbnNlIG9mIFwiZDMuanNcIiAoQlNELTNDbGF1c2UsIHNlZVxuKiA8L2xpY2Vuc2VzL0xJQ0VOU0UtZDM+KS5cbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBCb3VuZGluZ1JlY3QgZnJvbSAnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50LCBNQVhfU0FGRV9JTlRFR0VSIH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXInO1xuaW1wb3J0ICogYXMgbGF5b3V0IGZyb20gJy4uLy4uL3V0aWwvbGF5b3V0JztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi9oZWxwZXIvdHJlZUhlbHBlcic7XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciByZXRyaWV2ZVZhbHVlID0genJVdGlsLnJldHJpZXZlO1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBQQVRIX0JPUkRFUl9XSURUSCA9IFsnaXRlbVN0eWxlJywgJ2JvcmRlcldpZHRoJ107XG52YXIgUEFUSF9HQVBfV0lEVEggPSBbJ2l0ZW1TdHlsZScsICdnYXBXaWR0aCddO1xudmFyIFBBVEhfVVBQRVJfTEFCRUxfU0hPVyA9IFsndXBwZXJMYWJlbCcsICdzaG93J107XG52YXIgUEFUSF9VUFBFUl9MQUJFTF9IRUlHSFQgPSBbJ3VwcGVyTGFiZWwnLCAnaGVpZ2h0J107XG47XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNlcmllc1R5cGU6ICd0cmVlbWFwJyxcbiAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgLy8gTGF5b3V0IHJlc3VsdCBpbiBlYWNoIG5vZGU6XG4gICAgLy8ge3gsIHksIHdpZHRoLCBoZWlnaHQsIGFyZWEsIGJvcmRlcldpZHRofVxuICAgIHZhciBlY1dpZHRoID0gYXBpLmdldFdpZHRoKCk7XG4gICAgdmFyIGVjSGVpZ2h0ID0gYXBpLmdldEhlaWdodCgpO1xuICAgIHZhciBzZXJpZXNPcHRpb24gPSBzZXJpZXNNb2RlbC5vcHRpb247XG4gICAgdmFyIGxheW91dEluZm8gPSBsYXlvdXQuZ2V0TGF5b3V0UmVjdChzZXJpZXNNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKSwge1xuICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICB9KTtcbiAgICB2YXIgc2l6ZSA9IHNlcmllc09wdGlvbi5zaXplIHx8IFtdOyAvLyBDb21wYXRpYmxlIHdpdGggZWMyLlxuXG4gICAgdmFyIGNvbnRhaW5lcldpZHRoID0gcGFyc2VQZXJjZW50KHJldHJpZXZlVmFsdWUobGF5b3V0SW5mby53aWR0aCwgc2l6ZVswXSksIGVjV2lkdGgpO1xuICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBwYXJzZVBlcmNlbnQocmV0cmlldmVWYWx1ZShsYXlvdXRJbmZvLmhlaWdodCwgc2l6ZVsxXSksIGVjSGVpZ2h0KTsgLy8gRmV0Y2ggcGF5bG9hZCBpbmZvLlxuXG4gICAgdmFyIHBheWxvYWRUeXBlID0gcGF5bG9hZCAmJiBwYXlsb2FkLnR5cGU7XG4gICAgdmFyIHR5cGVzID0gWyd0cmVlbWFwWm9vbVRvTm9kZScsICd0cmVlbWFwUm9vdFRvTm9kZSddO1xuICAgIHZhciB0YXJnZXRJbmZvID0gaGVscGVyLnJldHJpZXZlVGFyZ2V0SW5mbyhwYXlsb2FkLCB0eXBlcywgc2VyaWVzTW9kZWwpO1xuICAgIHZhciByb290UmVjdCA9IHBheWxvYWRUeXBlID09PSAndHJlZW1hcFJlbmRlcicgfHwgcGF5bG9hZFR5cGUgPT09ICd0cmVlbWFwTW92ZScgPyBwYXlsb2FkLnJvb3RSZWN0IDogbnVsbDtcbiAgICB2YXIgdmlld1Jvb3QgPSBzZXJpZXNNb2RlbC5nZXRWaWV3Um9vdCgpO1xuICAgIHZhciB2aWV3QWJvdmVQYXRoID0gaGVscGVyLmdldFBhdGhUb1Jvb3Qodmlld1Jvb3QpO1xuXG4gICAgaWYgKHBheWxvYWRUeXBlICE9PSAndHJlZW1hcE1vdmUnKSB7XG4gICAgICB2YXIgcm9vdFNpemUgPSBwYXlsb2FkVHlwZSA9PT0gJ3RyZWVtYXBab29tVG9Ob2RlJyA/IGVzdGltYXRlUm9vdFNpemUoc2VyaWVzTW9kZWwsIHRhcmdldEluZm8sIHZpZXdSb290LCBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KSA6IHJvb3RSZWN0ID8gW3Jvb3RSZWN0LndpZHRoLCByb290UmVjdC5oZWlnaHRdIDogW2NvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHRdO1xuICAgICAgdmFyIHNvcnRfMSA9IHNlcmllc09wdGlvbi5zb3J0O1xuXG4gICAgICBpZiAoc29ydF8xICYmIHNvcnRfMSAhPT0gJ2FzYycgJiYgc29ydF8xICE9PSAnZGVzYycpIHtcbiAgICAgICAgLy8gRGVmYXVsdCB0byBiZSBkZXNjIG9yZGVyLlxuICAgICAgICBzb3J0XzEgPSAnZGVzYyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBzcXVhcmVSYXRpbzogc2VyaWVzT3B0aW9uLnNxdWFyZVJhdGlvLFxuICAgICAgICBzb3J0OiBzb3J0XzEsXG4gICAgICAgIGxlYWZEZXB0aDogc2VyaWVzT3B0aW9uLmxlYWZEZXB0aFxuICAgICAgfTsgLy8gbGF5b3V0IHNob3VsZCBiZSBjbGVhcmVkIGJlY2F1c2UgdXNpbmcgdXBkYXRlVmlldyBidXQgbm90IHVwZGF0ZS5cblxuICAgICAgdmlld1Jvb3QuaG9zdFRyZWUuY2xlYXJMYXlvdXRzKCk7IC8vIFRPRE9cbiAgICAgIC8vIG9wdGltaXplOiBpZiBvdXQgb2YgdmlldyBjbGlwLCBkbyBub3QgbGF5b3V0LlxuICAgICAgLy8gQnV0IHRha2UgY2FyZSB0aGF0IGlmIGRvIG5vdCByZW5kZXIgbm9kZSBvdXQgb2YgdmlldyBjbGlwLFxuICAgICAgLy8gaG93IHRvIGNhbGN1bGF0ZSBzdGFydCBwb1xuXG4gICAgICB2YXIgdmlld1Jvb3RMYXlvdXRfMSA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IHJvb3RTaXplWzBdLFxuICAgICAgICBoZWlnaHQ6IHJvb3RTaXplWzFdLFxuICAgICAgICBhcmVhOiByb290U2l6ZVswXSAqIHJvb3RTaXplWzFdXG4gICAgICB9O1xuICAgICAgdmlld1Jvb3Quc2V0TGF5b3V0KHZpZXdSb290TGF5b3V0XzEpO1xuICAgICAgc3F1YXJpZnkodmlld1Jvb3QsIG9wdGlvbnMsIGZhbHNlLCAwKTsgLy8gU3VwcGxlbWVudCBsYXlvdXQuXG5cbiAgICAgIHZpZXdSb290TGF5b3V0XzEgPSB2aWV3Um9vdC5nZXRMYXlvdXQoKTtcbiAgICAgIGVhY2godmlld0Fib3ZlUGF0aCwgZnVuY3Rpb24gKG5vZGUsIGluZGV4KSB7XG4gICAgICAgIHZhciBjaGlsZFZhbHVlID0gKHZpZXdBYm92ZVBhdGhbaW5kZXggKyAxXSB8fCB2aWV3Um9vdCkuZ2V0VmFsdWUoKTtcbiAgICAgICAgbm9kZS5zZXRMYXlvdXQoenJVdGlsLmV4dGVuZCh7XG4gICAgICAgICAgZGF0YUV4dGVudDogW2NoaWxkVmFsdWUsIGNoaWxkVmFsdWVdLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgICAgIHVwcGVySGVpZ2h0OiAwXG4gICAgICAgIH0sIHZpZXdSb290TGF5b3V0XzEpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB0cmVlUm9vdCA9IHNlcmllc01vZGVsLmdldERhdGEoKS50cmVlLnJvb3Q7XG4gICAgdHJlZVJvb3Quc2V0TGF5b3V0KGNhbGN1bGF0ZVJvb3RQb3NpdGlvbihsYXlvdXRJbmZvLCByb290UmVjdCwgdGFyZ2V0SW5mbyksIHRydWUpO1xuICAgIHNlcmllc01vZGVsLnNldExheW91dEluZm8obGF5b3V0SW5mbyk7IC8vIEZJWE1FXG4gICAgLy8g546w5Zyo5rKh5pyJY2xpcOWKn+iDve+8jOaaguaXtuWPlmVj6auY5a6944CCXG5cbiAgICBwcnVubmluZyh0cmVlUm9vdCwgLy8gVHJhbnNmb3JtIHRvIGJhc2UgZWxlbWVudCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICBuZXcgQm91bmRpbmdSZWN0KC1sYXlvdXRJbmZvLngsIC1sYXlvdXRJbmZvLnksIGVjV2lkdGgsIGVjSGVpZ2h0KSwgdmlld0Fib3ZlUGF0aCwgdmlld1Jvb3QsIDApO1xuICB9XG59O1xuLyoqXG4gKiBMYXlvdXQgdHJlZW1hcCB3aXRoIHNxdWFyaWZ5IGFsZ29yaXRobS5cbiAqIFRoZSBvcmlnaW5hbCBwcmVzZW50YXRpb24gb2YgdGhpcyBhbGdvcml0aG1cbiAqIHdhcyBtYWRlIGJ5IE1hcmsgQnJ1bHMsIEtlZXMgSHVpemluZywgYW5kIEphcmtlIEouIHZhbiBXaWprXG4gKiA8aHR0cHM6Ly9ncmFwaGljcy5ldGh6LmNoL3RlYWNoaW5nL3NjaXZpc19jb21tb24vTGl0ZXJhdHVyZS9zcXVhcmlmaWVkVHJlZU1hcHMucGRmPi5cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGFsZ29yaXRobSB3YXMgb3JpZ2luYWxseSBjb3BpZWQgZnJvbSBcImQzLmpzXCJcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vZDMvZDMvYmxvYi85Y2M5YTg3NWU2MzZhMWRjZjM2Y2MxZTA3YmRmNzdlMWFkNmUyYzc0L3NyYy9sYXlvdXQvdHJlZW1hcC5qcz5cbiAqIHdpdGggc29tZSBtb2RpZmljYXRpb25zIG1hZGUgZm9yIHRoaXMgcHJvZ3JhbS5cbiAqIFNlZSB0aGUgbGljZW5zZSBzdGF0ZW1lbnQgYXQgdGhlIGhlYWQgb2YgdGhpcyBmaWxlLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9UcmVlflRyZWVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc29ydCAnYXNjJyBvciAnZGVzYydcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnNxdWFyZVJhdGlvXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhpZGVDaGlsZHJlblxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoXG4gKi9cblxuZnVuY3Rpb24gc3F1YXJpZnkobm9kZSwgb3B0aW9ucywgaGlkZUNoaWxkcmVuLCBkZXB0aCkge1xuICB2YXIgd2lkdGg7XG4gIHZhciBoZWlnaHQ7XG5cbiAgaWYgKG5vZGUuaXNSZW1vdmVkKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGhpc0xheW91dCA9IG5vZGUuZ2V0TGF5b3V0KCk7XG4gIHdpZHRoID0gdGhpc0xheW91dC53aWR0aDtcbiAgaGVpZ2h0ID0gdGhpc0xheW91dC5oZWlnaHQ7IC8vIENvbnNpZGVyaW5nIGJvcmRlciBhbmQgZ2FwXG5cbiAgdmFyIG5vZGVNb2RlbCA9IG5vZGUuZ2V0TW9kZWwoKTtcbiAgdmFyIGJvcmRlcldpZHRoID0gbm9kZU1vZGVsLmdldChQQVRIX0JPUkRFUl9XSURUSCk7XG4gIHZhciBoYWxmR2FwV2lkdGggPSBub2RlTW9kZWwuZ2V0KFBBVEhfR0FQX1dJRFRIKSAvIDI7XG4gIHZhciB1cHBlckxhYmVsSGVpZ2h0ID0gZ2V0VXBwZXJMYWJlbEhlaWdodChub2RlTW9kZWwpO1xuICB2YXIgdXBwZXJIZWlnaHQgPSBNYXRoLm1heChib3JkZXJXaWR0aCwgdXBwZXJMYWJlbEhlaWdodCk7XG4gIHZhciBsYXlvdXRPZmZzZXQgPSBib3JkZXJXaWR0aCAtIGhhbGZHYXBXaWR0aDtcbiAgdmFyIGxheW91dE9mZnNldFVwcGVyID0gdXBwZXJIZWlnaHQgLSBoYWxmR2FwV2lkdGg7XG4gIG5vZGUuc2V0TGF5b3V0KHtcbiAgICBib3JkZXJXaWR0aDogYm9yZGVyV2lkdGgsXG4gICAgdXBwZXJIZWlnaHQ6IHVwcGVySGVpZ2h0LFxuICAgIHVwcGVyTGFiZWxIZWlnaHQ6IHVwcGVyTGFiZWxIZWlnaHRcbiAgfSwgdHJ1ZSk7XG4gIHdpZHRoID0gbWF0aE1heCh3aWR0aCAtIDIgKiBsYXlvdXRPZmZzZXQsIDApO1xuICBoZWlnaHQgPSBtYXRoTWF4KGhlaWdodCAtIGxheW91dE9mZnNldCAtIGxheW91dE9mZnNldFVwcGVyLCAwKTtcbiAgdmFyIHRvdGFsQXJlYSA9IHdpZHRoICogaGVpZ2h0O1xuICB2YXIgdmlld0NoaWxkcmVuID0gaW5pdENoaWxkcmVuKG5vZGUsIG5vZGVNb2RlbCwgdG90YWxBcmVhLCBvcHRpb25zLCBoaWRlQ2hpbGRyZW4sIGRlcHRoKTtcblxuICBpZiAoIXZpZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVjdCA9IHtcbiAgICB4OiBsYXlvdXRPZmZzZXQsXG4gICAgeTogbGF5b3V0T2Zmc2V0VXBwZXIsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG4gIHZhciByb3dGaXhlZExlbmd0aCA9IG1hdGhNaW4od2lkdGgsIGhlaWdodCk7XG4gIHZhciBiZXN0ID0gSW5maW5pdHk7IC8vIHRoZSBiZXN0IHJvdyBzY29yZSBzbyBmYXJcblxuICB2YXIgcm93ID0gW107XG4gIHJvdy5hcmVhID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmlld0NoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjspIHtcbiAgICB2YXIgY2hpbGQgPSB2aWV3Q2hpbGRyZW5baV07XG4gICAgcm93LnB1c2goY2hpbGQpO1xuICAgIHJvdy5hcmVhICs9IGNoaWxkLmdldExheW91dCgpLmFyZWE7XG4gICAgdmFyIHNjb3JlID0gd29yc3Qocm93LCByb3dGaXhlZExlbmd0aCwgb3B0aW9ucy5zcXVhcmVSYXRpbyk7IC8vIGNvbnRpbnVlIHdpdGggdGhpcyBvcmllbnRhdGlvblxuXG4gICAgaWYgKHNjb3JlIDw9IGJlc3QpIHtcbiAgICAgIGkrKztcbiAgICAgIGJlc3QgPSBzY29yZTtcbiAgICB9IC8vIGFib3J0LCBhbmQgdHJ5IGEgZGlmZmVyZW50IG9yaWVudGF0aW9uXG4gICAgZWxzZSB7XG4gICAgICAgIHJvdy5hcmVhIC09IHJvdy5wb3AoKS5nZXRMYXlvdXQoKS5hcmVhO1xuICAgICAgICBwb3NpdGlvbihyb3csIHJvd0ZpeGVkTGVuZ3RoLCByZWN0LCBoYWxmR2FwV2lkdGgsIGZhbHNlKTtcbiAgICAgICAgcm93Rml4ZWRMZW5ndGggPSBtYXRoTWluKHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgcm93Lmxlbmd0aCA9IHJvdy5hcmVhID0gMDtcbiAgICAgICAgYmVzdCA9IEluZmluaXR5O1xuICAgICAgfVxuICB9XG5cbiAgaWYgKHJvdy5sZW5ndGgpIHtcbiAgICBwb3NpdGlvbihyb3csIHJvd0ZpeGVkTGVuZ3RoLCByZWN0LCBoYWxmR2FwV2lkdGgsIHRydWUpO1xuICB9XG5cbiAgaWYgKCFoaWRlQ2hpbGRyZW4pIHtcbiAgICB2YXIgY2hpbGRyZW5WaXNpYmxlTWluID0gbm9kZU1vZGVsLmdldCgnY2hpbGRyZW5WaXNpYmxlTWluJyk7XG5cbiAgICBpZiAoY2hpbGRyZW5WaXNpYmxlTWluICE9IG51bGwgJiYgdG90YWxBcmVhIDwgY2hpbGRyZW5WaXNpYmxlTWluKSB7XG4gICAgICBoaWRlQ2hpbGRyZW4gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2aWV3Q2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzcXVhcmlmeSh2aWV3Q2hpbGRyZW5baV0sIG9wdGlvbnMsIGhpZGVDaGlsZHJlbiwgZGVwdGggKyAxKTtcbiAgfVxufVxuLyoqXG4gKiBTZXQgYXJlYSB0byBlYWNoIGNoaWxkLCBhbmQgY2FsY3VsYXRlIGRhdGEgZXh0ZW50IGZvciB2aXN1YWwgY29kaW5nLlxuICovXG5cblxuZnVuY3Rpb24gaW5pdENoaWxkcmVuKG5vZGUsIG5vZGVNb2RlbCwgdG90YWxBcmVhLCBvcHRpb25zLCBoaWRlQ2hpbGRyZW4sIGRlcHRoKSB7XG4gIHZhciB2aWV3Q2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuIHx8IFtdO1xuICB2YXIgb3JkZXJCeSA9IG9wdGlvbnMuc29ydDtcbiAgb3JkZXJCeSAhPT0gJ2FzYycgJiYgb3JkZXJCeSAhPT0gJ2Rlc2MnICYmIChvcmRlckJ5ID0gbnVsbCk7XG4gIHZhciBvdmVyTGVhZkRlcHRoID0gb3B0aW9ucy5sZWFmRGVwdGggIT0gbnVsbCAmJiBvcHRpb25zLmxlYWZEZXB0aCA8PSBkZXB0aDsgLy8gbGVhZkRlcHRoIGhhcyBoaWdoZXIgcHJpb3JpdHkuXG5cbiAgaWYgKGhpZGVDaGlsZHJlbiAmJiAhb3ZlckxlYWZEZXB0aCkge1xuICAgIHJldHVybiBub2RlLnZpZXdDaGlsZHJlbiA9IFtdO1xuICB9IC8vIFNvcnQgY2hpbGRyZW4sIG9yZGVyIGJ5IGRlc2MuXG5cblxuICB2aWV3Q2hpbGRyZW4gPSB6clV0aWwuZmlsdGVyKHZpZXdDaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuICFjaGlsZC5pc1JlbW92ZWQoKTtcbiAgfSk7XG4gIHNvcnQodmlld0NoaWxkcmVuLCBvcmRlckJ5KTtcbiAgdmFyIGluZm8gPSBzdGF0aXN0aWMobm9kZU1vZGVsLCB2aWV3Q2hpbGRyZW4sIG9yZGVyQnkpO1xuXG4gIGlmIChpbmZvLnN1bSA9PT0gMCkge1xuICAgIHJldHVybiBub2RlLnZpZXdDaGlsZHJlbiA9IFtdO1xuICB9XG5cbiAgaW5mby5zdW0gPSBmaWx0ZXJCeVRocmVzaG9sZChub2RlTW9kZWwsIHRvdGFsQXJlYSwgaW5mby5zdW0sIG9yZGVyQnksIHZpZXdDaGlsZHJlbik7XG5cbiAgaWYgKGluZm8uc3VtID09PSAwKSB7XG4gICAgcmV0dXJuIG5vZGUudmlld0NoaWxkcmVuID0gW107XG4gIH0gLy8gU2V0IGFyZWEgdG8gZWFjaCBjaGlsZC5cblxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2aWV3Q2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYXJlYSA9IHZpZXdDaGlsZHJlbltpXS5nZXRWYWx1ZSgpIC8gaW5mby5zdW0gKiB0b3RhbEFyZWE7IC8vIERvIG5vdCB1c2Ugc2V0TGF5b3V0KHsuLi59LCB0cnVlKSwgYmVjYXVzZSBpdCBpcyBuZWVkZWQgdG8gY2xlYXIgbGFzdCBsYXlvdXQuXG5cbiAgICB2aWV3Q2hpbGRyZW5baV0uc2V0TGF5b3V0KHtcbiAgICAgIGFyZWE6IGFyZWFcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChvdmVyTGVhZkRlcHRoKSB7XG4gICAgdmlld0NoaWxkcmVuLmxlbmd0aCAmJiBub2RlLnNldExheW91dCh7XG4gICAgICBpc0xlYWZSb290OiB0cnVlXG4gICAgfSwgdHJ1ZSk7XG4gICAgdmlld0NoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cblxuICBub2RlLnZpZXdDaGlsZHJlbiA9IHZpZXdDaGlsZHJlbjtcbiAgbm9kZS5zZXRMYXlvdXQoe1xuICAgIGRhdGFFeHRlbnQ6IGluZm8uZGF0YUV4dGVudFxuICB9LCB0cnVlKTtcbiAgcmV0dXJuIHZpZXdDaGlsZHJlbjtcbn1cbi8qKlxuICogQ29uc2lkZXIgJ3Zpc2libGVNaW4nLiBNb2RpZnkgdmlld0NoaWxkcmVuIGFuZCBnZXQgbmV3IHN1bS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbHRlckJ5VGhyZXNob2xkKG5vZGVNb2RlbCwgdG90YWxBcmVhLCBzdW0sIG9yZGVyQnksIG9yZGVyZWRDaGlsZHJlbikge1xuICAvLyB2aXNpYmxlTWluIGlzIG5vdCBzdXBwb3J0ZWQgeWV0IHdoZW4gbm8gb3B0aW9uLnNvcnQuXG4gIGlmICghb3JkZXJCeSkge1xuICAgIHJldHVybiBzdW07XG4gIH1cblxuICB2YXIgdmlzaWJsZU1pbiA9IG5vZGVNb2RlbC5nZXQoJ3Zpc2libGVNaW4nKTtcbiAgdmFyIGxlbiA9IG9yZGVyZWRDaGlsZHJlbi5sZW5ndGg7XG4gIHZhciBkZWxldGVQb2ludCA9IGxlbjsgLy8gQWx3YXlzIHRyYXZlbCBmcm9tIGxpdHRsZSB2YWx1ZSB0byBiaWcgdmFsdWUuXG5cbiAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHZhbHVlID0gb3JkZXJlZENoaWxkcmVuW29yZGVyQnkgPT09ICdhc2MnID8gbGVuIC0gaSAtIDEgOiBpXS5nZXRWYWx1ZSgpO1xuXG4gICAgaWYgKHZhbHVlIC8gc3VtICogdG90YWxBcmVhIDwgdmlzaWJsZU1pbikge1xuICAgICAgZGVsZXRlUG9pbnQgPSBpO1xuICAgICAgc3VtIC09IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIG9yZGVyQnkgPT09ICdhc2MnID8gb3JkZXJlZENoaWxkcmVuLnNwbGljZSgwLCBsZW4gLSBkZWxldGVQb2ludCkgOiBvcmRlcmVkQ2hpbGRyZW4uc3BsaWNlKGRlbGV0ZVBvaW50LCBsZW4gLSBkZWxldGVQb2ludCk7XG4gIHJldHVybiBzdW07XG59XG4vKipcbiAqIFNvcnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHNvcnQodmlld0NoaWxkcmVuLCBvcmRlckJ5KSB7XG4gIGlmIChvcmRlckJ5KSB7XG4gICAgdmlld0NoaWxkcmVuLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBkaWZmID0gb3JkZXJCeSA9PT0gJ2FzYycgPyBhLmdldFZhbHVlKCkgLSBiLmdldFZhbHVlKCkgOiBiLmdldFZhbHVlKCkgLSBhLmdldFZhbHVlKCk7XG4gICAgICByZXR1cm4gZGlmZiA9PT0gMCA/IG9yZGVyQnkgPT09ICdhc2MnID8gYS5kYXRhSW5kZXggLSBiLmRhdGFJbmRleCA6IGIuZGF0YUluZGV4IC0gYS5kYXRhSW5kZXggOiBkaWZmO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZpZXdDaGlsZHJlbjtcbn1cbi8qKlxuICogU3RhdGlzdGljXG4gKi9cblxuXG5mdW5jdGlvbiBzdGF0aXN0aWMobm9kZU1vZGVsLCBjaGlsZHJlbiwgb3JkZXJCeSkge1xuICAvLyBDYWxjdWxhdGUgc3VtLlxuICB2YXIgc3VtID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzdW0gKz0gY2hpbGRyZW5baV0uZ2V0VmFsdWUoKTtcbiAgfSAvLyBTdGF0aXN0aWMgZGF0YSBleHRlbnQgZm9yIGxhdHRlciB2aXN1YWwgY29kaW5nLlxuICAvLyBOb3RpY2U6IGRhdGEgZXh0ZW50IHNob3VsZCBiZSBjYWxjdWxhdGUgYmFzZWQgb24gcmF3IGNoaWxkcmVuXG4gIC8vIGJ1dCBub3QgZmlsdGVyZWQgdmlldyBjaGlsZHJlbiwgb3RoZXJ3aXNlIHZpc3VhbCBtYXBwaW5nIHdpbGwgbm90XG4gIC8vIGJlIHN0YWJsZSB3aGVuIHpvb20gKHdoZXJlIGNoaWxkcmVuIGlzIGZpbHRlcmVkIGJ5IHZpc2libGVNaW4pLlxuXG5cbiAgdmFyIGRpbWVuc2lvbiA9IG5vZGVNb2RlbC5nZXQoJ3Zpc3VhbERpbWVuc2lvbicpO1xuICB2YXIgZGF0YUV4dGVudDsgLy8gVGhlIHNhbWUgYXMgYXJlYSBkaW1lbnNpb24uXG5cbiAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgZGF0YUV4dGVudCA9IFtOYU4sIE5hTl07XG4gIH0gZWxzZSBpZiAoZGltZW5zaW9uID09PSAndmFsdWUnICYmIG9yZGVyQnkpIHtcbiAgICBkYXRhRXh0ZW50ID0gW2NoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLmdldFZhbHVlKCksIGNoaWxkcmVuWzBdLmdldFZhbHVlKCldO1xuICAgIG9yZGVyQnkgPT09ICdhc2MnICYmIGRhdGFFeHRlbnQucmV2ZXJzZSgpO1xuICB9IC8vIE90aGVyIGRpbWVuc2lvbi5cbiAgZWxzZSB7XG4gICAgICBkYXRhRXh0ZW50ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICAgICAgZWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGNoaWxkLmdldFZhbHVlKGRpbWVuc2lvbik7XG4gICAgICAgIHZhbHVlIDwgZGF0YUV4dGVudFswXSAmJiAoZGF0YUV4dGVudFswXSA9IHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPiBkYXRhRXh0ZW50WzFdICYmIChkYXRhRXh0ZW50WzFdID0gdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIHJldHVybiB7XG4gICAgc3VtOiBzdW0sXG4gICAgZGF0YUV4dGVudDogZGF0YUV4dGVudFxuICB9O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgc2NvcmUgZm9yIHRoZSBzcGVjaWZpZWQgcm93LFxuICogYXMgdGhlIHdvcnN0IGFzcGVjdCByYXRpby5cbiAqL1xuXG5cbmZ1bmN0aW9uIHdvcnN0KHJvdywgcm93Rml4ZWRMZW5ndGgsIHJhdGlvKSB7XG4gIHZhciBhcmVhTWF4ID0gMDtcbiAgdmFyIGFyZWFNaW4gPSBJbmZpbml0eTtcblxuICBmb3IgKHZhciBpID0gMCwgYXJlYSA9IHZvaWQgMCwgbGVuID0gcm93Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJlYSA9IHJvd1tpXS5nZXRMYXlvdXQoKS5hcmVhO1xuXG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIGFyZWEgPCBhcmVhTWluICYmIChhcmVhTWluID0gYXJlYSk7XG4gICAgICBhcmVhID4gYXJlYU1heCAmJiAoYXJlYU1heCA9IGFyZWEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzcXVhcmVBcmVhID0gcm93LmFyZWEgKiByb3cuYXJlYTtcbiAgdmFyIGYgPSByb3dGaXhlZExlbmd0aCAqIHJvd0ZpeGVkTGVuZ3RoICogcmF0aW87XG4gIHJldHVybiBzcXVhcmVBcmVhID8gbWF0aE1heChmICogYXJlYU1heCAvIHNxdWFyZUFyZWEsIHNxdWFyZUFyZWEgLyAoZiAqIGFyZWFNaW4pKSA6IEluZmluaXR5O1xufVxuLyoqXG4gKiBQb3NpdGlvbnMgdGhlIHNwZWNpZmllZCByb3cgb2Ygbm9kZXMuIE1vZGlmaWVzIGByZWN0YC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBvc2l0aW9uKHJvdywgcm93Rml4ZWRMZW5ndGgsIHJlY3QsIGhhbGZHYXBXaWR0aCwgZmx1c2gpIHtcbiAgLy8gV2hlbiByb3dGaXhlZExlbmd0aCA9PT0gcmVjdC53aWR0aCxcbiAgLy8gaXQgaXMgaG9yaXpvbnRhbCBzdWJkaXZpc2lvbixcbiAgLy8gcm93Rml4ZWRMZW5ndGggaXMgdGhlIHdpZHRoIG9mIHRoZSBzdWJkaXZpc2lvbixcbiAgLy8gcm93T3RoZXJMZW5ndGggaXMgdGhlIGhlaWdodCBvZiB0aGUgc3ViZGl2aXNpb24sXG4gIC8vIGFuZCBub2RlcyB3aWxsIGJlIHBvc2l0aW9uZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAvLyB3aFtpZHgwV2hlbkhdIG1lYW5zOiB3aGVuIGhvcml6b250YWwsXG4gIC8vICAgICAgd2hbaWR4MFdoZW5IXSA9PiB3aFswXSA9PiAnd2lkdGgnLlxuICAvLyAgICAgIHh5W2lkeDFXaGVuSF0gPT4geHlbMV0gPT4gJ3knLlxuICB2YXIgaWR4MFdoZW5IID0gcm93Rml4ZWRMZW5ndGggPT09IHJlY3Qud2lkdGggPyAwIDogMTtcbiAgdmFyIGlkeDFXaGVuSCA9IDEgLSBpZHgwV2hlbkg7XG4gIHZhciB4eSA9IFsneCcsICd5J107XG4gIHZhciB3aCA9IFsnd2lkdGgnLCAnaGVpZ2h0J107XG4gIHZhciBsYXN0ID0gcmVjdFt4eVtpZHgwV2hlbkhdXTtcbiAgdmFyIHJvd090aGVyTGVuZ3RoID0gcm93Rml4ZWRMZW5ndGggPyByb3cuYXJlYSAvIHJvd0ZpeGVkTGVuZ3RoIDogMDtcblxuICBpZiAoZmx1c2ggfHwgcm93T3RoZXJMZW5ndGggPiByZWN0W3doW2lkeDFXaGVuSF1dKSB7XG4gICAgcm93T3RoZXJMZW5ndGggPSByZWN0W3doW2lkeDFXaGVuSF1dOyAvLyBvdmVyK3VuZGVyZmxvd1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIHJvd0xlbiA9IHJvdy5sZW5ndGg7IGkgPCByb3dMZW47IGkrKykge1xuICAgIHZhciBub2RlID0gcm93W2ldO1xuICAgIHZhciBub2RlTGF5b3V0ID0ge307XG4gICAgdmFyIHN0ZXAgPSByb3dPdGhlckxlbmd0aCA/IG5vZGUuZ2V0TGF5b3V0KCkuYXJlYSAvIHJvd090aGVyTGVuZ3RoIDogMDtcbiAgICB2YXIgd2gxID0gbm9kZUxheW91dFt3aFtpZHgxV2hlbkhdXSA9IG1hdGhNYXgocm93T3RoZXJMZW5ndGggLSAyICogaGFsZkdhcFdpZHRoLCAwKTsgLy8gV2UgdXNlIE1hdGgubWF4L21pbiB0byBhdm9pZCBuZWdhdGl2ZSB3aWR0aC9oZWlnaHQgd2hlbiBjb25zaWRlcmluZyBnYXAgd2lkdGguXG5cbiAgICB2YXIgcmVtYWluID0gcmVjdFt4eVtpZHgwV2hlbkhdXSArIHJlY3Rbd2hbaWR4MFdoZW5IXV0gLSBsYXN0O1xuICAgIHZhciBtb2RXSCA9IGkgPT09IHJvd0xlbiAtIDEgfHwgcmVtYWluIDwgc3RlcCA/IHJlbWFpbiA6IHN0ZXA7XG4gICAgdmFyIHdoMCA9IG5vZGVMYXlvdXRbd2hbaWR4MFdoZW5IXV0gPSBtYXRoTWF4KG1vZFdIIC0gMiAqIGhhbGZHYXBXaWR0aCwgMCk7XG4gICAgbm9kZUxheW91dFt4eVtpZHgxV2hlbkhdXSA9IHJlY3RbeHlbaWR4MVdoZW5IXV0gKyBtYXRoTWluKGhhbGZHYXBXaWR0aCwgd2gxIC8gMik7XG4gICAgbm9kZUxheW91dFt4eVtpZHgwV2hlbkhdXSA9IGxhc3QgKyBtYXRoTWluKGhhbGZHYXBXaWR0aCwgd2gwIC8gMik7XG4gICAgbGFzdCArPSBtb2RXSDtcbiAgICBub2RlLnNldExheW91dChub2RlTGF5b3V0LCB0cnVlKTtcbiAgfVxuXG4gIHJlY3RbeHlbaWR4MVdoZW5IXV0gKz0gcm93T3RoZXJMZW5ndGg7XG4gIHJlY3Rbd2hbaWR4MVdoZW5IXV0gLT0gcm93T3RoZXJMZW5ndGg7XG59IC8vIFJldHVybiBbY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodF0gYXMgZGVmYXVsdC5cblxuXG5mdW5jdGlvbiBlc3RpbWF0ZVJvb3RTaXplKHNlcmllc01vZGVsLCB0YXJnZXRJbmZvLCB2aWV3Um9vdCwgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCkge1xuICAvLyBJZiB0YXJnZXRJbmZvLm5vZGUgZXhpc3RzLCB3ZSB6b29tIHRvIHRoZSBub2RlLFxuICAvLyBzbyBlc3RpbWF0ZSB3aG9sZCB3aWR0aCBhbmQgaGVpZ3RoIGJ5IHRhcmdldCBub2RlLlxuICB2YXIgY3Vyck5vZGUgPSAodGFyZ2V0SW5mbyB8fCB7fSkubm9kZTtcbiAgdmFyIGRlZmF1bHRTaXplID0gW2NvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHRdO1xuXG4gIGlmICghY3Vyck5vZGUgfHwgY3Vyck5vZGUgPT09IHZpZXdSb290KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRTaXplO1xuICB9XG5cbiAgdmFyIHBhcmVudDtcbiAgdmFyIHZpZXdBcmVhID0gY29udGFpbmVyV2lkdGggKiBjb250YWluZXJIZWlnaHQ7XG4gIHZhciBhcmVhID0gdmlld0FyZWEgKiBzZXJpZXNNb2RlbC5vcHRpb24uem9vbVRvTm9kZVJhdGlvO1xuXG4gIHdoaWxlIChwYXJlbnQgPSBjdXJyTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIHNpYmxpbmdzID0gcGFyZW50LmNoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNpYmxpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzdW0gKz0gc2libGluZ3NbaV0uZ2V0VmFsdWUoKTtcbiAgICB9XG5cbiAgICB2YXIgY3Vyck5vZGVWYWx1ZSA9IGN1cnJOb2RlLmdldFZhbHVlKCk7XG5cbiAgICBpZiAoY3Vyck5vZGVWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRTaXplO1xuICAgIH1cblxuICAgIGFyZWEgKj0gc3VtIC8gY3Vyck5vZGVWYWx1ZTsgLy8gQ29uc2lkZXJpbmcgYm9yZGVyLCBzdXBwb3NlIGFzcGVjdCByYXRpbyBpcyAxLlxuXG4gICAgdmFyIHBhcmVudE1vZGVsID0gcGFyZW50LmdldE1vZGVsKCk7XG4gICAgdmFyIGJvcmRlcldpZHRoID0gcGFyZW50TW9kZWwuZ2V0KFBBVEhfQk9SREVSX1dJRFRIKTtcbiAgICB2YXIgdXBwZXJIZWlnaHQgPSBNYXRoLm1heChib3JkZXJXaWR0aCwgZ2V0VXBwZXJMYWJlbEhlaWdodChwYXJlbnRNb2RlbCkpO1xuICAgIGFyZWEgKz0gNCAqIGJvcmRlcldpZHRoICogYm9yZGVyV2lkdGggKyAoMyAqIGJvcmRlcldpZHRoICsgdXBwZXJIZWlnaHQpICogTWF0aC5wb3coYXJlYSwgMC41KTtcbiAgICBhcmVhID4gTUFYX1NBRkVfSU5URUdFUiAmJiAoYXJlYSA9IE1BWF9TQUZFX0lOVEVHRVIpO1xuICAgIGN1cnJOb2RlID0gcGFyZW50O1xuICB9XG5cbiAgYXJlYSA8IHZpZXdBcmVhICYmIChhcmVhID0gdmlld0FyZWEpO1xuICB2YXIgc2NhbGUgPSBNYXRoLnBvdyhhcmVhIC8gdmlld0FyZWEsIDAuNSk7XG4gIHJldHVybiBbY29udGFpbmVyV2lkdGggKiBzY2FsZSwgY29udGFpbmVySGVpZ2h0ICogc2NhbGVdO1xufSAvLyBSb290IHBvc3Rpb24gYmFzZSBvbiBjb29yZCBvZiBjb250YWluZXJHcm91cFxuXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJvb3RQb3NpdGlvbihsYXlvdXRJbmZvLCByb290UmVjdCwgdGFyZ2V0SW5mbykge1xuICBpZiAocm9vdFJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcm9vdFJlY3QueCxcbiAgICAgIHk6IHJvb3RSZWN0LnlcbiAgICB9O1xuICB9XG5cbiAgdmFyIGRlZmF1bHRQb3NpdGlvbiA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoIXRhcmdldEluZm8pIHtcbiAgICByZXR1cm4gZGVmYXVsdFBvc2l0aW9uO1xuICB9IC8vIElmIHRhcmdldEluZm8gaXMgZmV0Y2hlZCBieSAncmV0cmlldmVUYXJnZXRJbmZvJyxcbiAgLy8gb2xkIHRyZWUgYW5kIG5ldyB0cmVlIGFyZSB0aGUgc2FtZSB0cmVlLFxuICAvLyBzbyB0aGUgbm9kZSBzdGlsbCBleGlzdHMgYW5kIHdlIGNhbiB2aXNpdCBpdC5cblxuXG4gIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5mby5ub2RlO1xuICB2YXIgbGF5b3V0ID0gdGFyZ2V0Tm9kZS5nZXRMYXlvdXQoKTtcblxuICBpZiAoIWxheW91dCkge1xuICAgIHJldHVybiBkZWZhdWx0UG9zaXRpb247XG4gIH0gLy8gVHJhbnNmb3JtIGNvb3JkIGZyb20gbG9jYWwgdG8gY29udGFpbmVyLlxuXG5cbiAgdmFyIHRhcmdldENlbnRlciA9IFtsYXlvdXQud2lkdGggLyAyLCBsYXlvdXQuaGVpZ2h0IC8gMl07XG4gIHZhciBub2RlID0gdGFyZ2V0Tm9kZTtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIHZhciBub2RlTGF5b3V0ID0gbm9kZS5nZXRMYXlvdXQoKTtcbiAgICB0YXJnZXRDZW50ZXJbMF0gKz0gbm9kZUxheW91dC54O1xuICAgIHRhcmdldENlbnRlclsxXSArPSBub2RlTGF5b3V0Lnk7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogbGF5b3V0SW5mby53aWR0aCAvIDIgLSB0YXJnZXRDZW50ZXJbMF0sXG4gICAgeTogbGF5b3V0SW5mby5oZWlnaHQgLyAyIC0gdGFyZ2V0Q2VudGVyWzFdXG4gIH07XG59IC8vIE1hcmsgbm9kZXMgdmlzaWJsZSBmb3IgcHJ1bm5pbmcgd2hlbiB2aXN1YWwgY29kaW5nIGFuZCByZW5kZXJpbmcuXG4vLyBQcnVubmluZyBkZXBlbmRzIG9uIGxheW91dCBhbmQgcm9vdCBwb3NpdGlvbiwgc28gd2UgaGF2ZSB0byBkbyBpdCBhZnRlciBsYXlvdXQuXG5cblxuZnVuY3Rpb24gcHJ1bm5pbmcobm9kZSwgY2xpcFJlY3QsIHZpZXdBYm92ZVBhdGgsIHZpZXdSb290LCBkZXB0aCkge1xuICB2YXIgbm9kZUxheW91dCA9IG5vZGUuZ2V0TGF5b3V0KCk7XG4gIHZhciBub2RlSW5WaWV3QWJvdmVQYXRoID0gdmlld0Fib3ZlUGF0aFtkZXB0aF07XG4gIHZhciBpc0Fib3ZlVmlld1Jvb3QgPSBub2RlSW5WaWV3QWJvdmVQYXRoICYmIG5vZGVJblZpZXdBYm92ZVBhdGggPT09IG5vZGU7XG5cbiAgaWYgKG5vZGVJblZpZXdBYm92ZVBhdGggJiYgIWlzQWJvdmVWaWV3Um9vdCB8fCBkZXB0aCA9PT0gdmlld0Fib3ZlUGF0aC5sZW5ndGggJiYgbm9kZSAhPT0gdmlld1Jvb3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBub2RlLnNldExheW91dCh7XG4gICAgLy8gaXNJblZpZXcgbWVhbnM6IHZpZXdSb290IHN1YiB0cmVlICsgdmlld0Fib3ZlUGF0aFxuICAgIGlzSW5WaWV3OiB0cnVlLFxuICAgIC8vIGludmlzaWJsZSBvbmx5IG1lYW5zOiBvdXRzaWRlIHZpZXcgY2xpcCBzbyB0aGF0IHRoZSBub2RlIGNhbiBub3RcbiAgICAvLyBzZWUgYnV0IHN0aWxsIGxheW91dCBmb3IgYW5pbWF0aW9uIHByZXBhcmF0aW9uIGJ1dCBub3QgcmVuZGVyLlxuICAgIGludmlzaWJsZTogIWlzQWJvdmVWaWV3Um9vdCAmJiAhY2xpcFJlY3QuaW50ZXJzZWN0KG5vZGVMYXlvdXQpLFxuICAgIGlzQWJvdmVWaWV3Um9vdDogaXNBYm92ZVZpZXdSb290XG4gIH0sIHRydWUpOyAvLyBUcmFuc2Zvcm0gdG8gY2hpbGQgY29vcmRpbmF0ZS5cblxuICB2YXIgY2hpbGRDbGlwUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoY2xpcFJlY3QueCAtIG5vZGVMYXlvdXQueCwgY2xpcFJlY3QueSAtIG5vZGVMYXlvdXQueSwgY2xpcFJlY3Qud2lkdGgsIGNsaXBSZWN0LmhlaWdodCk7XG4gIGVhY2gobm9kZS52aWV3Q2hpbGRyZW4gfHwgW10sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHBydW5uaW5nKGNoaWxkLCBjaGlsZENsaXBSZWN0LCB2aWV3QWJvdmVQYXRoLCB2aWV3Um9vdCwgZGVwdGggKyAxKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFVwcGVyTGFiZWxIZWlnaHQobW9kZWwpIHtcbiAgcmV0dXJuIG1vZGVsLmdldChQQVRIX1VQUEVSX0xBQkVMX1NIT1cpID8gbW9kZWwuZ2V0KFBBVEhfVVBQRVJfTEFCRUxfSEVJR0hUKSA6IDA7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCBWaXN1YWxNYXBwaW5nIGZyb20gJy4uLy4uL3Zpc3VhbC9WaXN1YWxNYXBwaW5nJztcbmltcG9ydCB7IGVhY2gsIGV4dGVuZCwgaXNBcnJheSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBtb2RpZnlIU0wsIG1vZGlmeUFscGhhIH0gZnJvbSAnenJlbmRlci9saWIvdG9vbC9jb2xvcic7XG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbnZhciBJVEVNX1NUWUxFX05PUk1BTCA9ICdpdGVtU3R5bGUnO1xudmFyIGlubmVyID0gbWFrZUlubmVyKCk7XG5leHBvcnQgZGVmYXVsdCB7XG4gIHNlcmllc1R5cGU6ICd0cmVlbWFwJyxcbiAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciB0cmVlID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLnRyZWU7XG4gICAgdmFyIHJvb3QgPSB0cmVlLnJvb3Q7XG5cbiAgICBpZiAocm9vdC5pc1JlbW92ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyYXZlbFRyZWUocm9vdCwgLy8gVmlzdWFsIHNob3VsZCBjYWxjdWxhdGUgZnJvbSB0cmVlIHJvb3QgYnV0IG5vdCB2aWV3IHJvb3QuXG4gICAge30sIHNlcmllc01vZGVsLmdldFZpZXdSb290KCkuZ2V0QW5jZXN0b3JzKCksIHNlcmllc01vZGVsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdHJhdmVsVHJlZShub2RlLCBkZXNpZ25hdGVkVmlzdWFsLCB2aWV3Um9vdEFuY2VzdG9ycywgc2VyaWVzTW9kZWwpIHtcbiAgdmFyIG5vZGVNb2RlbCA9IG5vZGUuZ2V0TW9kZWwoKTtcbiAgdmFyIG5vZGVMYXlvdXQgPSBub2RlLmdldExheW91dCgpO1xuICB2YXIgZGF0YSA9IG5vZGUuaG9zdFRyZWUuZGF0YTsgLy8gT3B0aW1pemVcblxuICBpZiAoIW5vZGVMYXlvdXQgfHwgbm9kZUxheW91dC5pbnZpc2libGUgfHwgIW5vZGVMYXlvdXQuaXNJblZpZXcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbm9kZUl0ZW1TdHlsZU1vZGVsID0gbm9kZU1vZGVsLmdldE1vZGVsKElURU1fU1RZTEVfTk9STUFMKTtcbiAgdmFyIHZpc3VhbHMgPSBidWlsZFZpc3VhbHMobm9kZUl0ZW1TdHlsZU1vZGVsLCBkZXNpZ25hdGVkVmlzdWFsLCBzZXJpZXNNb2RlbCk7XG4gIHZhciBleGlzdHNTdHlsZSA9IGRhdGEuZW5zdXJlVW5pcXVlSXRlbVZpc3VhbChub2RlLmRhdGFJbmRleCwgJ3N0eWxlJyk7IC8vIGNhbGN1bGF0ZSBib3JkZXIgY29sb3JcblxuICB2YXIgYm9yZGVyQ29sb3IgPSBub2RlSXRlbVN0eWxlTW9kZWwuZ2V0KCdib3JkZXJDb2xvcicpO1xuICB2YXIgYm9yZGVyQ29sb3JTYXR1cmF0aW9uID0gbm9kZUl0ZW1TdHlsZU1vZGVsLmdldCgnYm9yZGVyQ29sb3JTYXR1cmF0aW9uJyk7XG4gIHZhciB0aGlzTm9kZUNvbG9yO1xuXG4gIGlmIChib3JkZXJDb2xvclNhdHVyYXRpb24gIT0gbnVsbCkge1xuICAgIC8vIEZvciBwZXJmb3JtYW5jZSwgZG8gbm90IGFsd2F5cyBleGVjdXRlICdjYWxjdWxhdGVDb2xvcicuXG4gICAgdGhpc05vZGVDb2xvciA9IGNhbGN1bGF0ZUNvbG9yKHZpc3VhbHMpO1xuICAgIGJvcmRlckNvbG9yID0gY2FsY3VsYXRlQm9yZGVyQ29sb3IoYm9yZGVyQ29sb3JTYXR1cmF0aW9uLCB0aGlzTm9kZUNvbG9yKTtcbiAgfVxuXG4gIGV4aXN0c1N0eWxlLnN0cm9rZSA9IGJvcmRlckNvbG9yO1xuICB2YXIgdmlld0NoaWxkcmVuID0gbm9kZS52aWV3Q2hpbGRyZW47XG5cbiAgaWYgKCF2aWV3Q2hpbGRyZW4gfHwgIXZpZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB0aGlzTm9kZUNvbG9yID0gY2FsY3VsYXRlQ29sb3IodmlzdWFscyk7IC8vIEFwcGx5IHZpc3VhbCB0byB0aGlzIG5vZGUuXG5cbiAgICBleGlzdHNTdHlsZS5maWxsID0gdGhpc05vZGVDb2xvcjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWFwcGluZ18xID0gYnVpbGRWaXN1YWxNYXBwaW5nKG5vZGUsIG5vZGVNb2RlbCwgbm9kZUxheW91dCwgbm9kZUl0ZW1TdHlsZU1vZGVsLCB2aXN1YWxzLCB2aWV3Q2hpbGRyZW4pOyAvLyBEZXNpZ25hdGUgdmlzdWFsIHRvIGNoaWxkcmVuLlxuXG4gICAgZWFjaCh2aWV3Q2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICAgIC8vIElmIGhpZ2hlciB0aGFuIHZpZXdSb290LCBvbmx5IGFuY2VzdG9ycyBvZiB2aWV3Um9vdCBpcyBuZWVkZWQgdG8gdmlzaXQuXG4gICAgICBpZiAoY2hpbGQuZGVwdGggPj0gdmlld1Jvb3RBbmNlc3RvcnMubGVuZ3RoIHx8IGNoaWxkID09PSB2aWV3Um9vdEFuY2VzdG9yc1tjaGlsZC5kZXB0aF0pIHtcbiAgICAgICAgdmFyIGNoaWxkVmlzdWFsID0gbWFwVmlzdWFsKG5vZGVNb2RlbCwgdmlzdWFscywgY2hpbGQsIGluZGV4LCBtYXBwaW5nXzEsIHNlcmllc01vZGVsKTtcbiAgICAgICAgdHJhdmVsVHJlZShjaGlsZCwgY2hpbGRWaXN1YWwsIHZpZXdSb290QW5jZXN0b3JzLCBzZXJpZXNNb2RlbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRWaXN1YWxzKG5vZGVJdGVtU3R5bGVNb2RlbCwgZGVzaWduYXRlZFZpc3VhbCwgc2VyaWVzTW9kZWwpIHtcbiAgdmFyIHZpc3VhbHMgPSBleHRlbmQoe30sIGRlc2lnbmF0ZWRWaXN1YWwpO1xuICB2YXIgZGVzaWduYXRlZFZpc3VhbEl0ZW1TdHlsZSA9IHNlcmllc01vZGVsLmRlc2lnbmF0ZWRWaXN1YWxJdGVtU3R5bGU7XG4gIGVhY2goWydjb2xvcicsICdjb2xvckFscGhhJywgJ2NvbG9yU2F0dXJhdGlvbiddLCBmdW5jdGlvbiAodmlzdWFsTmFtZSkge1xuICAgIC8vIFByaW9yaXR5OiB0aGlzTm9kZSA+IHRoaXNMZXZlbCA+IHBhcmVudE5vZGVEZXNpZ25hdGVkID4gc2VyaWVzTW9kZWxcbiAgICBkZXNpZ25hdGVkVmlzdWFsSXRlbVN0eWxlW3Zpc3VhbE5hbWVdID0gZGVzaWduYXRlZFZpc3VhbFt2aXN1YWxOYW1lXTtcbiAgICB2YXIgdmFsID0gbm9kZUl0ZW1TdHlsZU1vZGVsLmdldCh2aXN1YWxOYW1lKTtcbiAgICBkZXNpZ25hdGVkVmlzdWFsSXRlbVN0eWxlW3Zpc3VhbE5hbWVdID0gbnVsbDtcbiAgICB2YWwgIT0gbnVsbCAmJiAodmlzdWFsc1t2aXN1YWxOYW1lXSA9IHZhbCk7XG4gIH0pO1xuICByZXR1cm4gdmlzdWFscztcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQ29sb3IodmlzdWFscykge1xuICB2YXIgY29sb3IgPSBnZXRWYWx1ZVZpc3VhbERlZmluZSh2aXN1YWxzLCAnY29sb3InKTtcblxuICBpZiAoY29sb3IpIHtcbiAgICB2YXIgY29sb3JBbHBoYSA9IGdldFZhbHVlVmlzdWFsRGVmaW5lKHZpc3VhbHMsICdjb2xvckFscGhhJyk7XG4gICAgdmFyIGNvbG9yU2F0dXJhdGlvbiA9IGdldFZhbHVlVmlzdWFsRGVmaW5lKHZpc3VhbHMsICdjb2xvclNhdHVyYXRpb24nKTtcblxuICAgIGlmIChjb2xvclNhdHVyYXRpb24pIHtcbiAgICAgIGNvbG9yID0gbW9kaWZ5SFNMKGNvbG9yLCBudWxsLCBudWxsLCBjb2xvclNhdHVyYXRpb24pO1xuICAgIH1cblxuICAgIGlmIChjb2xvckFscGhhKSB7XG4gICAgICBjb2xvciA9IG1vZGlmeUFscGhhKGNvbG9yLCBjb2xvckFscGhhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQm9yZGVyQ29sb3IoYm9yZGVyQ29sb3JTYXR1cmF0aW9uLCB0aGlzTm9kZUNvbG9yKSB7XG4gIHJldHVybiB0aGlzTm9kZUNvbG9yICE9IG51bGwgLy8gQ2FuIG9ubHkgYmUgc3RyaW5nXG4gID8gbW9kaWZ5SFNMKHRoaXNOb2RlQ29sb3IsIG51bGwsIG51bGwsIGJvcmRlckNvbG9yU2F0dXJhdGlvbikgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZVZpc3VhbERlZmluZSh2aXN1YWxzLCBuYW1lKSB7XG4gIHZhciB2YWx1ZSA9IHZpc3VhbHNbbmFtZV07XG5cbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09ICdub25lJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFZpc3VhbE1hcHBpbmcobm9kZSwgbm9kZU1vZGVsLCBub2RlTGF5b3V0LCBub2RlSXRlbVN0eWxlTW9kZWwsIHZpc3VhbHMsIHZpZXdDaGlsZHJlbikge1xuICBpZiAoIXZpZXdDaGlsZHJlbiB8fCAhdmlld0NoaWxkcmVuLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByYW5nZVZpc3VhbCA9IGdldFJhbmdlVmlzdWFsKG5vZGVNb2RlbCwgJ2NvbG9yJykgfHwgdmlzdWFscy5jb2xvciAhPSBudWxsICYmIHZpc3VhbHMuY29sb3IgIT09ICdub25lJyAmJiAoZ2V0UmFuZ2VWaXN1YWwobm9kZU1vZGVsLCAnY29sb3JBbHBoYScpIHx8IGdldFJhbmdlVmlzdWFsKG5vZGVNb2RlbCwgJ2NvbG9yU2F0dXJhdGlvbicpKTtcblxuICBpZiAoIXJhbmdlVmlzdWFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHZpc3VhbE1pbiA9IG5vZGVNb2RlbC5nZXQoJ3Zpc3VhbE1pbicpO1xuICB2YXIgdmlzdWFsTWF4ID0gbm9kZU1vZGVsLmdldCgndmlzdWFsTWF4Jyk7XG4gIHZhciBkYXRhRXh0ZW50ID0gbm9kZUxheW91dC5kYXRhRXh0ZW50LnNsaWNlKCk7XG4gIHZpc3VhbE1pbiAhPSBudWxsICYmIHZpc3VhbE1pbiA8IGRhdGFFeHRlbnRbMF0gJiYgKGRhdGFFeHRlbnRbMF0gPSB2aXN1YWxNaW4pO1xuICB2aXN1YWxNYXggIT0gbnVsbCAmJiB2aXN1YWxNYXggPiBkYXRhRXh0ZW50WzFdICYmIChkYXRhRXh0ZW50WzFdID0gdmlzdWFsTWF4KTtcbiAgdmFyIGNvbG9yTWFwcGluZ0J5ID0gbm9kZU1vZGVsLmdldCgnY29sb3JNYXBwaW5nQnknKTtcbiAgdmFyIG9wdCA9IHtcbiAgICB0eXBlOiByYW5nZVZpc3VhbC5uYW1lLFxuICAgIGRhdGFFeHRlbnQ6IGRhdGFFeHRlbnQsXG4gICAgdmlzdWFsOiByYW5nZVZpc3VhbC5yYW5nZVxuICB9O1xuXG4gIGlmIChvcHQudHlwZSA9PT0gJ2NvbG9yJyAmJiAoY29sb3JNYXBwaW5nQnkgPT09ICdpbmRleCcgfHwgY29sb3JNYXBwaW5nQnkgPT09ICdpZCcpKSB7XG4gICAgb3B0Lm1hcHBpbmdNZXRob2QgPSAnY2F0ZWdvcnknO1xuICAgIG9wdC5sb29wID0gdHJ1ZTsgLy8gY2F0ZWdvcmllcyBpcyBvcmRpbmFsLCBzbyBkbyBub3Qgc2V0IG9wdC5jYXRlZ29yaWVzLlxuICB9IGVsc2Uge1xuICAgIG9wdC5tYXBwaW5nTWV0aG9kID0gJ2xpbmVhcic7XG4gIH1cblxuICB2YXIgbWFwcGluZyA9IG5ldyBWaXN1YWxNYXBwaW5nKG9wdCk7XG4gIGlubmVyKG1hcHBpbmcpLmRyQ29sb3JNYXBwaW5nQnkgPSBjb2xvck1hcHBpbmdCeTtcbiAgcmV0dXJuIG1hcHBpbmc7XG59IC8vIE5vdGljZTogSWYgd2UgZG9udCBoYXZlIHRoZSBhdHRyaWJ1dGUgJ2NvbG9yUmFuZ2UnLCBidXQgb25seSB1c2Vcbi8vIGF0dHJpYnV0ZSAnY29sb3InIHRvIHJlcHJlc2VudCBib3RoIGNvbmNlcHRzIG9mICdjb2xvclJhbmdlJyBhbmQgJ2NvbG9yJyxcbi8vIChJdCBtZWFucyAnY29sb3JSYW5nZScgd2hlbiAnY29sb3InIGlzIEFycmF5LCBtZWFucyAnY29sb3InIHdoZW4gbm90IGFycmF5KSxcbi8vIHRoaXMgcHJvYmxlbSB3aWxsIGJlIGVuY291bnRlcmVkOlxuLy8gSWYgYSBsZXZlbC0xIG5vZGUgZG9udCBoYXZlIGNoaWxkcmVuLCBhbmQgaXRzIHNpYmxpbmdzIGhhcyBjaGlsZHJlbixcbi8vIGFuZCBjb2xvclJhbmdlIGlzIHNldCBvbiBsZXZlbC0xLCB0aGVuIHRoZSBub2RlIGNhbiBub3QgYmUgY29sb3JlZC5cbi8vIFNvIHdlIHNlcGFyYXRlICdjb2xvclJhbmdlJyBhbmQgJ2NvbG9yJyB0byBkaWZmZXJlbnQgYXR0cmlidXRlcy5cblxuXG5mdW5jdGlvbiBnZXRSYW5nZVZpc3VhbChub2RlTW9kZWwsIG5hbWUpIHtcbiAgLy8gJ2NvbG9yUmFuZ2UnLCAnY29sb3JBUmFuZ2UnLCAnY29sb3JTUmFuZ2UnLlxuICAvLyBJZiBub3QgZXhzaXRzIG9uIHRoaXMgbm9kZSwgZmV0Y2ggZnJvbSBsZXZlbHMgYW5kIHNlcmllcy5cbiAgdmFyIHJhbmdlID0gbm9kZU1vZGVsLmdldChuYW1lKTtcbiAgcmV0dXJuIGlzQXJyYXkocmFuZ2UpICYmIHJhbmdlLmxlbmd0aCA/IHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHJhbmdlOiByYW5nZVxuICB9IDogbnVsbDtcbn1cblxuZnVuY3Rpb24gbWFwVmlzdWFsKG5vZGVNb2RlbCwgdmlzdWFscywgY2hpbGQsIGluZGV4LCBtYXBwaW5nLCBzZXJpZXNNb2RlbCkge1xuICB2YXIgY2hpbGRWaXN1YWxzID0gZXh0ZW5kKHt9LCB2aXN1YWxzKTtcblxuICBpZiAobWFwcGluZykge1xuICAgIC8vIE9ubHkgc3VwcG9ydCBjb2xvciwgY29sb3JBbHBoYSwgY29sb3JTYXR1cmF0aW9uLlxuICAgIHZhciBtYXBwaW5nVHlwZSA9IG1hcHBpbmcudHlwZTtcbiAgICB2YXIgY29sb3JNYXBwaW5nQnkgPSBtYXBwaW5nVHlwZSA9PT0gJ2NvbG9yJyAmJiBpbm5lcihtYXBwaW5nKS5kckNvbG9yTWFwcGluZ0J5O1xuICAgIHZhciB2YWx1ZSA9IGNvbG9yTWFwcGluZ0J5ID09PSAnaW5kZXgnID8gaW5kZXggOiBjb2xvck1hcHBpbmdCeSA9PT0gJ2lkJyA/IHNlcmllc01vZGVsLm1hcElkVG9JbmRleChjaGlsZC5nZXRJZCgpKSA6IGNoaWxkLmdldFZhbHVlKG5vZGVNb2RlbC5nZXQoJ3Zpc3VhbERpbWVuc2lvbicpKTtcbiAgICBjaGlsZFZpc3VhbHNbbWFwcGluZ1R5cGVdID0gbWFwcGluZy5tYXBWYWx1ZVRvVmlzdWFsKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZFZpc3VhbHM7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhbGVuZGFyUHJlcGFyZUN1c3RvbShjb29yZFN5cykge1xuICB2YXIgcmVjdCA9IGNvb3JkU3lzLmdldFJlY3QoKTtcbiAgdmFyIHJhbmdlSW5mbyA9IGNvb3JkU3lzLmdldFJhbmdlSW5mbygpO1xuICByZXR1cm4ge1xuICAgIGNvb3JkU3lzOiB7XG4gICAgICB0eXBlOiAnY2FsZW5kYXInLFxuICAgICAgeDogcmVjdC54LFxuICAgICAgeTogcmVjdC55LFxuICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgICAgY2VsbFdpZHRoOiBjb29yZFN5cy5nZXRDZWxsV2lkdGgoKSxcbiAgICAgIGNlbGxIZWlnaHQ6IGNvb3JkU3lzLmdldENlbGxIZWlnaHQoKSxcbiAgICAgIHJhbmdlSW5mbzoge1xuICAgICAgICBzdGFydDogcmFuZ2VJbmZvLnN0YXJ0LFxuICAgICAgICBlbmQ6IHJhbmdlSW5mby5lbmQsXG4gICAgICAgIHdlZWtzOiByYW5nZUluZm8ud2Vla3MsXG4gICAgICAgIGRheUNvdW50OiByYW5nZUluZm8uYWxsRGF5XG4gICAgICB9XG4gICAgfSxcbiAgICBhcGk6IHtcbiAgICAgIGNvb3JkOiBmdW5jdGlvbiAoZGF0YSwgY2xhbXApIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkU3lzLmRhdGFUb1BvaW50KGRhdGEsIGNsYW1wKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuXG5mdW5jdGlvbiBkYXRhVG9Db29yZFNpemUoZGF0YVNpemUsIGRhdGFJdGVtKSB7XG4gIC8vIGRhdGFJdGVtIGlzIG5lY2Vzc2FyeSBpbiBsb2cgYXhpcy5cbiAgZGF0YUl0ZW0gPSBkYXRhSXRlbSB8fCBbMCwgMF07XG4gIHJldHVybiB6clV0aWwubWFwKFsneCcsICd5J10sIGZ1bmN0aW9uIChkaW0sIGRpbUlkeCkge1xuICAgIHZhciBheGlzID0gdGhpcy5nZXRBeGlzKGRpbSk7XG4gICAgdmFyIHZhbCA9IGRhdGFJdGVtW2RpbUlkeF07XG4gICAgdmFyIGhhbGZTaXplID0gZGF0YVNpemVbZGltSWR4XSAvIDI7XG4gICAgcmV0dXJuIGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyA/IGF4aXMuZ2V0QmFuZFdpZHRoKCkgOiBNYXRoLmFicyhheGlzLmRhdGFUb0Nvb3JkKHZhbCAtIGhhbGZTaXplKSAtIGF4aXMuZGF0YVRvQ29vcmQodmFsICsgaGFsZlNpemUpKTtcbiAgfSwgdGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhcnRlc2lhblByZXBhcmVDdXN0b20oY29vcmRTeXMpIHtcbiAgdmFyIHJlY3QgPSBjb29yZFN5cy5tYXN0ZXIuZ2V0UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIGNvb3JkU3lzOiB7XG4gICAgICAvLyBUaGUgbmFtZSBleHBvc2VkIHRvIHVzZXIgaXMgYWx3YXlzICdjYXJ0ZXNpYW4yZCcgYnV0IG5vdCAnZ3JpZCcuXG4gICAgICB0eXBlOiAnY2FydGVzaWFuMmQnLFxuICAgICAgeDogcmVjdC54LFxuICAgICAgeTogcmVjdC55LFxuICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gICAgfSxcbiAgICBhcGk6IHtcbiAgICAgIGNvb3JkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBkbyBub3QgcHJvdmlkZSBcIm91dFwiIHBhcmFtXG4gICAgICAgIHJldHVybiBjb29yZFN5cy5kYXRhVG9Qb2ludChkYXRhKTtcbiAgICAgIH0sXG4gICAgICBzaXplOiB6clV0aWwuYmluZChkYXRhVG9Db29yZFNpemUsIGNvb3JkU3lzKVxuICAgIH1cbiAgfTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5cbmZ1bmN0aW9uIGRhdGFUb0Nvb3JkU2l6ZShkYXRhU2l6ZSwgZGF0YUl0ZW0pIHtcbiAgZGF0YUl0ZW0gPSBkYXRhSXRlbSB8fCBbMCwgMF07XG4gIHJldHVybiB6clV0aWwubWFwKFswLCAxXSwgZnVuY3Rpb24gKGRpbUlkeCkge1xuICAgIHZhciB2YWwgPSBkYXRhSXRlbVtkaW1JZHhdO1xuICAgIHZhciBoYWxmU2l6ZSA9IGRhdGFTaXplW2RpbUlkeF0gLyAyO1xuICAgIHZhciBwMSA9IFtdO1xuICAgIHZhciBwMiA9IFtdO1xuICAgIHAxW2RpbUlkeF0gPSB2YWwgLSBoYWxmU2l6ZTtcbiAgICBwMltkaW1JZHhdID0gdmFsICsgaGFsZlNpemU7XG4gICAgcDFbMSAtIGRpbUlkeF0gPSBwMlsxIC0gZGltSWR4XSA9IGRhdGFJdGVtWzEgLSBkaW1JZHhdO1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmRhdGFUb1BvaW50KHAxKVtkaW1JZHhdIC0gdGhpcy5kYXRhVG9Qb2ludChwMilbZGltSWR4XSk7XG4gIH0sIHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZW9QcmVwYXJlQ3VzdG9tKGNvb3JkU3lzKSB7XG4gIHZhciByZWN0ID0gY29vcmRTeXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgY29vcmRTeXM6IHtcbiAgICAgIHR5cGU6ICdnZW8nLFxuICAgICAgeDogcmVjdC54LFxuICAgICAgeTogcmVjdC55LFxuICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgICAgem9vbTogY29vcmRTeXMuZ2V0Wm9vbSgpXG4gICAgfSxcbiAgICBhcGk6IHtcbiAgICAgIGNvb3JkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBkbyBub3QgcHJvdmlkZSBcIm91dFwiIGFuZCBub1JvYW0gcGFyYW0sXG4gICAgICAgIC8vIENvbXBhdGlibGUgd2l0aCB0aGlzIHVzYWdlOlxuICAgICAgICAvLyBlY2hhcnRzLnV0aWwubWFwKGl0ZW0ucG9pbnRzLCBhcGkuY29vcmQpXG4gICAgICAgIHJldHVybiBjb29yZFN5cy5kYXRhVG9Qb2ludChkYXRhKTtcbiAgICAgIH0sXG4gICAgICBzaXplOiB6clV0aWwuYmluZChkYXRhVG9Db29yZFNpemUsIGNvb3JkU3lzKVxuICAgIH1cbiAgfTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7IC8vIGltcG9ydCBBbmdsZUF4aXMgZnJvbSAnLi9BbmdsZUF4aXMnO1xuXG5mdW5jdGlvbiBkYXRhVG9Db29yZFNpemUoZGF0YVNpemUsIGRhdGFJdGVtKSB7XG4gIC8vIGRhdGFJdGVtIGlzIG5lY2Vzc2FyeSBpbiBsb2cgYXhpcy5cbiAgZGF0YUl0ZW0gPSBkYXRhSXRlbSB8fCBbMCwgMF07XG4gIHJldHVybiB6clV0aWwubWFwKFsnUmFkaXVzJywgJ0FuZ2xlJ10sIGZ1bmN0aW9uIChkaW0sIGRpbUlkeCkge1xuICAgIHZhciBnZXR0ZXJOYW1lID0gJ2dldCcgKyBkaW0gKyAnQXhpcyc7IC8vIFRPRE86IFRZUEUgQ2hlY2sgQW5nbGUgQXhpc1xuXG4gICAgdmFyIGF4aXMgPSB0aGlzW2dldHRlck5hbWVdKCk7XG4gICAgdmFyIHZhbCA9IGRhdGFJdGVtW2RpbUlkeF07XG4gICAgdmFyIGhhbGZTaXplID0gZGF0YVNpemVbZGltSWR4XSAvIDI7XG4gICAgdmFyIHJlc3VsdCA9IGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyA/IGF4aXMuZ2V0QmFuZFdpZHRoKCkgOiBNYXRoLmFicyhheGlzLmRhdGFUb0Nvb3JkKHZhbCAtIGhhbGZTaXplKSAtIGF4aXMuZGF0YVRvQ29vcmQodmFsICsgaGFsZlNpemUpKTtcblxuICAgIGlmIChkaW0gPT09ICdBbmdsZScpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCAqIE1hdGguUEkgLyAxODA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgdGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBvbGFyUHJlcGFyZUN1c3RvbShjb29yZFN5cykge1xuICB2YXIgcmFkaXVzQXhpcyA9IGNvb3JkU3lzLmdldFJhZGl1c0F4aXMoKTtcbiAgdmFyIGFuZ2xlQXhpcyA9IGNvb3JkU3lzLmdldEFuZ2xlQXhpcygpO1xuICB2YXIgcmFkaXVzID0gcmFkaXVzQXhpcy5nZXRFeHRlbnQoKTtcbiAgcmFkaXVzWzBdID4gcmFkaXVzWzFdICYmIHJhZGl1cy5yZXZlcnNlKCk7XG4gIHJldHVybiB7XG4gICAgY29vcmRTeXM6IHtcbiAgICAgIHR5cGU6ICdwb2xhcicsXG4gICAgICBjeDogY29vcmRTeXMuY3gsXG4gICAgICBjeTogY29vcmRTeXMuY3ksXG4gICAgICByOiByYWRpdXNbMV0sXG4gICAgICByMDogcmFkaXVzWzBdXG4gICAgfSxcbiAgICBhcGk6IHtcbiAgICAgIGNvb3JkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmFkaXVzID0gcmFkaXVzQXhpcy5kYXRhVG9SYWRpdXMoZGF0YVswXSk7XG4gICAgICAgIHZhciBhbmdsZSA9IGFuZ2xlQXhpcy5kYXRhVG9BbmdsZShkYXRhWzFdKTtcbiAgICAgICAgdmFyIGNvb3JkID0gY29vcmRTeXMuY29vcmRUb1BvaW50KFtyYWRpdXMsIGFuZ2xlXSk7XG4gICAgICAgIGNvb3JkLnB1c2gocmFkaXVzLCBhbmdsZSAqIE1hdGguUEkgLyAxODApO1xuICAgICAgICByZXR1cm4gY29vcmQ7XG4gICAgICB9LFxuICAgICAgc2l6ZTogenJVdGlsLmJpbmQoZGF0YVRvQ29vcmRTaXplLCBjb29yZFN5cylcbiAgICB9XG4gIH07XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IGJpbmQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuXG5mdW5jdGlvbiBkYXRhVG9Db29yZFNpemUoZGF0YVNpemUsIGRhdGFJdGVtKSB7XG4gIC8vIGRhdGFJdGVtIGlzIG5lY2Vzc2FyeSBpbiBsb2cgYXhpcy5cbiAgdmFyIGF4aXMgPSB0aGlzLmdldEF4aXMoKTtcbiAgdmFyIHZhbCA9IGRhdGFJdGVtIGluc3RhbmNlb2YgQXJyYXkgPyBkYXRhSXRlbVswXSA6IGRhdGFJdGVtO1xuICB2YXIgaGFsZlNpemUgPSAoZGF0YVNpemUgaW5zdGFuY2VvZiBBcnJheSA/IGRhdGFTaXplWzBdIDogZGF0YVNpemUpIC8gMjtcbiAgcmV0dXJuIGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyA/IGF4aXMuZ2V0QmFuZFdpZHRoKCkgOiBNYXRoLmFicyhheGlzLmRhdGFUb0Nvb3JkKHZhbCAtIGhhbGZTaXplKSAtIGF4aXMuZGF0YVRvQ29vcmQodmFsICsgaGFsZlNpemUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2luZ2xlUHJlcGFyZUN1c3RvbShjb29yZFN5cykge1xuICB2YXIgcmVjdCA9IGNvb3JkU3lzLmdldFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICBjb29yZFN5czoge1xuICAgICAgdHlwZTogJ3NpbmdsZUF4aXMnLFxuICAgICAgeDogcmVjdC54LFxuICAgICAgeTogcmVjdC55LFxuICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gICAgfSxcbiAgICBhcGk6IHtcbiAgICAgIGNvb3JkOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIC8vIGRvIG5vdCBwcm92aWRlIFwib3V0XCIgcGFyYW1cbiAgICAgICAgcmV0dXJuIGNvb3JkU3lzLmRhdGFUb1BvaW50KHZhbCk7XG4gICAgICB9LFxuICAgICAgc2l6ZTogYmluZChkYXRhVG9Db29yZFNpemUsIGNvb3JkU3lzKVxuICAgIH1cbiAgfTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7IC8vIGlkIG1heSBiZSBmdW5jdGlvbiBuYW1lIG9mIE9iamVjdCwgYWRkIGEgcHJlZml4IHRvIGF2b2lkIHRoaXMgcHJvYmxlbS5cblxuZnVuY3Rpb24gZ2VuZXJhdGVOb2RlS2V5KGlkKSB7XG4gIHJldHVybiAnX0VDXycgKyBpZDtcbn1cblxudmFyIEdyYXBoID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR3JhcGgoZGlyZWN0ZWQpIHtcbiAgICB0aGlzLnR5cGUgPSAnZ3JhcGgnO1xuICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB0aGlzLmVkZ2VzID0gW107XG4gICAgdGhpcy5fbm9kZXNNYXAgPSB7fTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTplY2hhcnRzL2RhdGEvR3JhcGguRWRnZT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2VkZ2VzTWFwID0ge307XG4gICAgdGhpcy5fZGlyZWN0ZWQgPSBkaXJlY3RlZCB8fCBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogSWYgaXMgZGlyZWN0ZWQgZ3JhcGhcbiAgICovXG5cblxuICBHcmFwaC5wcm90b3R5cGUuaXNEaXJlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlyZWN0ZWQ7XG4gIH07XG5cbiAgO1xuICAvKipcbiAgICogQWRkIGEgbmV3IG5vZGVcbiAgICovXG5cbiAgR3JhcGgucHJvdG90eXBlLmFkZE5vZGUgPSBmdW5jdGlvbiAoaWQsIGRhdGFJbmRleCkge1xuICAgIGlkID0gaWQgPT0gbnVsbCA/ICcnICsgZGF0YUluZGV4IDogJycgKyBpZDtcbiAgICB2YXIgbm9kZXNNYXAgPSB0aGlzLl9ub2Rlc01hcDtcblxuICAgIGlmIChub2Rlc01hcFtnZW5lcmF0ZU5vZGVLZXkoaWQpXSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignR3JhcGggbm9kZXMgaGF2ZSBkdXBsaWNhdGUgbmFtZSBvciBpZCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBuZXcgR3JhcGhOb2RlKGlkLCBkYXRhSW5kZXgpO1xuICAgIG5vZGUuaG9zdEdyYXBoID0gdGhpcztcbiAgICB0aGlzLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgbm9kZXNNYXBbZ2VuZXJhdGVOb2RlS2V5KGlkKV0gPSBub2RlO1xuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIDtcbiAgLyoqXG4gICAqIEdldCBub2RlIGJ5IGRhdGEgaW5kZXhcbiAgICovXG5cbiAgR3JhcGgucHJvdG90eXBlLmdldE5vZGVCeUluZGV4ID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgIHZhciByYXdJZHggPSB0aGlzLmRhdGEuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KTtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc1tyYXdJZHhdO1xuICB9O1xuXG4gIDtcbiAgLyoqXG4gICAqIEdldCBub2RlIGJ5IGlkXG4gICAqL1xuXG4gIEdyYXBoLnByb3RvdHlwZS5nZXROb2RlQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiB0aGlzLl9ub2Rlc01hcFtnZW5lcmF0ZU5vZGVLZXkoaWQpXTtcbiAgfTtcblxuICA7XG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgZWRnZVxuICAgKi9cblxuICBHcmFwaC5wcm90b3R5cGUuYWRkRWRnZSA9IGZ1bmN0aW9uIChuMSwgbjIsIGRhdGFJbmRleCkge1xuICAgIHZhciBub2Rlc01hcCA9IHRoaXMuX25vZGVzTWFwO1xuICAgIHZhciBlZGdlc01hcCA9IHRoaXMuX2VkZ2VzTWFwOyAvLyBQTkVESU5HXG5cbiAgICBpZiAodHlwZW9mIG4xID09PSAnbnVtYmVyJykge1xuICAgICAgbjEgPSB0aGlzLm5vZGVzW24xXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG4yID09PSAnbnVtYmVyJykge1xuICAgICAgbjIgPSB0aGlzLm5vZGVzW24yXTtcbiAgICB9XG5cbiAgICBpZiAoIShuMSBpbnN0YW5jZW9mIEdyYXBoTm9kZSkpIHtcbiAgICAgIG4xID0gbm9kZXNNYXBbZ2VuZXJhdGVOb2RlS2V5KG4xKV07XG4gICAgfVxuXG4gICAgaWYgKCEobjIgaW5zdGFuY2VvZiBHcmFwaE5vZGUpKSB7XG4gICAgICBuMiA9IG5vZGVzTWFwW2dlbmVyYXRlTm9kZUtleShuMildO1xuICAgIH1cblxuICAgIGlmICghbjEgfHwgIW4yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IG4xLmlkICsgJy0nICsgbjIuaWQ7XG4gICAgdmFyIGVkZ2UgPSBuZXcgR3JhcGhFZGdlKG4xLCBuMiwgZGF0YUluZGV4KTtcbiAgICBlZGdlLmhvc3RHcmFwaCA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5fZGlyZWN0ZWQpIHtcbiAgICAgIG4xLm91dEVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICBuMi5pbkVkZ2VzLnB1c2goZWRnZSk7XG4gICAgfVxuXG4gICAgbjEuZWRnZXMucHVzaChlZGdlKTtcblxuICAgIGlmIChuMSAhPT0gbjIpIHtcbiAgICAgIG4yLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgfVxuXG4gICAgdGhpcy5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgIGVkZ2VzTWFwW2tleV0gPSBlZGdlO1xuICAgIHJldHVybiBlZGdlO1xuICB9O1xuXG4gIDtcbiAgLyoqXG4gICAqIEdldCBlZGdlIGJ5IGRhdGEgaW5kZXhcbiAgICovXG5cbiAgR3JhcGgucHJvdG90eXBlLmdldEVkZ2VCeUluZGV4ID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgIHZhciByYXdJZHggPSB0aGlzLmVkZ2VEYXRhLmdldFJhd0luZGV4KGRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHRoaXMuZWRnZXNbcmF3SWR4XTtcbiAgfTtcblxuICA7XG4gIC8qKlxuICAgKiBHZXQgZWRnZSBieSB0d28gbGlua2VkIG5vZGVzXG4gICAqL1xuXG4gIEdyYXBoLnByb3RvdHlwZS5nZXRFZGdlID0gZnVuY3Rpb24gKG4xLCBuMikge1xuICAgIGlmIChuMSBpbnN0YW5jZW9mIEdyYXBoTm9kZSkge1xuICAgICAgbjEgPSBuMS5pZDtcbiAgICB9XG5cbiAgICBpZiAobjIgaW5zdGFuY2VvZiBHcmFwaE5vZGUpIHtcbiAgICAgIG4yID0gbjIuaWQ7XG4gICAgfVxuXG4gICAgdmFyIGVkZ2VzTWFwID0gdGhpcy5fZWRnZXNNYXA7XG5cbiAgICBpZiAodGhpcy5fZGlyZWN0ZWQpIHtcbiAgICAgIHJldHVybiBlZGdlc01hcFtuMSArICctJyArIG4yXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVkZ2VzTWFwW24xICsgJy0nICsgbjJdIHx8IGVkZ2VzTWFwW24yICsgJy0nICsgbjFdO1xuICAgIH1cbiAgfTtcblxuICA7XG4gIC8qKlxuICAgKiBJdGVyYXRlIGFsbCBub2Rlc1xuICAgKi9cblxuICBHcmFwaC5wcm90b3R5cGUuZWFjaE5vZGUgPSBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgIHZhciBsZW4gPSBub2Rlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAobm9kZXNbaV0uZGF0YUluZGV4ID49IDApIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBub2Rlc1tpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIDtcbiAgLyoqXG4gICAqIEl0ZXJhdGUgYWxsIGVkZ2VzXG4gICAqL1xuXG4gIEdyYXBoLnByb3RvdHlwZS5lYWNoRWRnZSA9IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXM7XG4gICAgdmFyIGxlbiA9IGVkZ2VzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChlZGdlc1tpXS5kYXRhSW5kZXggPj0gMCAmJiBlZGdlc1tpXS5ub2RlMS5kYXRhSW5kZXggPj0gMCAmJiBlZGdlc1tpXS5ub2RlMi5kYXRhSW5kZXggPj0gMCkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGVkZ2VzW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgO1xuICAvKipcbiAgICogQnJlYWR0aCBmaXJzdCB0cmF2ZXJzZVxuICAgKiBSZXR1cm4gdHJ1ZSB0byBzdG9wIHRyYXZlcnNpbmdcbiAgICovXG5cbiAgR3JhcGgucHJvdG90eXBlLmJyZWFkdGhGaXJzdFRyYXZlcnNlID0gZnVuY3Rpb24gKGNiLCBzdGFydE5vZGUsIGRpcmVjdGlvbiwgY29udGV4dCkge1xuICAgIGlmICghKHN0YXJ0Tm9kZSBpbnN0YW5jZW9mIEdyYXBoTm9kZSkpIHtcbiAgICAgIHN0YXJ0Tm9kZSA9IHRoaXMuX25vZGVzTWFwW2dlbmVyYXRlTm9kZUtleShzdGFydE5vZGUpXTtcbiAgICB9XG5cbiAgICBpZiAoIXN0YXJ0Tm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlZGdlVHlwZSA9IGRpcmVjdGlvbiA9PT0gJ291dCcgPyAnb3V0RWRnZXMnIDogZGlyZWN0aW9uID09PSAnaW4nID8gJ2luRWRnZXMnIDogJ2VkZ2VzJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5ub2Rlc1tpXS5fX3Zpc2l0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBzdGFydE5vZGUsIG51bGwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHF1ZXVlID0gW3N0YXJ0Tm9kZV07XG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICB2YXIgY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgdmFyIGVkZ2VzID0gY3VycmVudE5vZGVbZWRnZVR5cGVdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgICAgIHZhciBvdGhlck5vZGUgPSBlLm5vZGUxID09PSBjdXJyZW50Tm9kZSA/IGUubm9kZTIgOiBlLm5vZGUxO1xuXG4gICAgICAgIGlmICghb3RoZXJOb2RlLl9fdmlzaXRlZCkge1xuICAgICAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG90aGVyTm9kZSwgY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgICAvLyBTdG9wIHRyYXZlcnNpbmdcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBxdWV1ZS5wdXNoKG90aGVyTm9kZSk7XG4gICAgICAgICAgb3RoZXJOb2RlLl9fdmlzaXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgOyAvLyBUT0RPXG4gIC8vIGRlcHRoRmlyc3RUcmF2ZXJzZShcbiAgLy8gICAgIGNiLCBzdGFydE5vZGUsIGRpcmVjdGlvbiwgY29udGV4dFxuICAvLyApIHtcbiAgLy8gfTtcbiAgLy8gRmlsdGVyIHVwZGF0ZVxuXG4gIEdyYXBoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGVkZ2VEYXRhID0gdGhpcy5lZGdlRGF0YTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5vZGVzW2ldLmRhdGFJbmRleCA9IC0xO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmNvdW50KCk7IGkgPCBsZW47IGkrKykge1xuICAgICAgbm9kZXNbZGF0YS5nZXRSYXdJbmRleChpKV0uZGF0YUluZGV4ID0gaTtcbiAgICB9XG5cbiAgICBlZGdlRGF0YS5maWx0ZXJTZWxmKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZURhdGEuZ2V0UmF3SW5kZXgoaWR4KV07XG4gICAgICByZXR1cm4gZWRnZS5ub2RlMS5kYXRhSW5kZXggPj0gMCAmJiBlZGdlLm5vZGUyLmRhdGFJbmRleCA+PSAwO1xuICAgIH0pOyAvLyBVcGRhdGUgZWRnZVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVkZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBlZGdlc1tpXS5kYXRhSW5kZXggPSAtMTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWRnZURhdGEuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBlZGdlc1tlZGdlRGF0YS5nZXRSYXdJbmRleChpKV0uZGF0YUluZGV4ID0gaTtcbiAgICB9XG4gIH07XG5cbiAgO1xuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvZGF0YS9HcmFwaH1cbiAgICovXG5cbiAgR3JhcGgucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBncmFwaCA9IG5ldyBHcmFwaCh0aGlzLl9kaXJlY3RlZCk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZ3JhcGguYWRkTm9kZShub2Rlc1tpXS5pZCwgbm9kZXNbaV0uZGF0YUluZGV4KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgICAgZ3JhcGguYWRkRWRnZShlLm5vZGUxLmlkLCBlLm5vZGUyLmlkLCBlLmRhdGFJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyYXBoO1xuICB9O1xuXG4gIDtcbiAgcmV0dXJuIEdyYXBoO1xufSgpO1xuXG52YXIgR3JhcGhOb2RlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR3JhcGhOb2RlKGlkLCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLmluRWRnZXMgPSBbXTtcbiAgICB0aGlzLm91dEVkZ2VzID0gW107XG4gICAgdGhpcy5lZGdlcyA9IFtdO1xuICAgIHRoaXMuZGF0YUluZGV4ID0gLTE7XG4gICAgdGhpcy5pZCA9IGlkID09IG51bGwgPyAnJyA6IGlkO1xuICAgIHRoaXMuZGF0YUluZGV4ID0gZGF0YUluZGV4ID09IG51bGwgPyAtMSA6IGRhdGFJbmRleDtcbiAgfVxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cblxuXG4gIEdyYXBoTm9kZS5wcm90b3R5cGUuZGVncmVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVkZ2VzLmxlbmd0aDtcbiAgfTtcbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG5cblxuICBHcmFwaE5vZGUucHJvdG90eXBlLmluRGVncmVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluRWRnZXMubGVuZ3RoO1xuICB9O1xuICAvKipcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG5cblxuICBHcmFwaE5vZGUucHJvdG90eXBlLm91dERlZ3JlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRFZGdlcy5sZW5ndGg7XG4gIH07XG5cbiAgR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRNb2RlbCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHRoaXMuZGF0YUluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBncmFwaCA9IHRoaXMuaG9zdEdyYXBoO1xuICAgIHZhciBpdGVtTW9kZWwgPSBncmFwaC5kYXRhLmdldEl0ZW1Nb2RlbCh0aGlzLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIGl0ZW1Nb2RlbC5nZXRNb2RlbChwYXRoKTtcbiAgfTtcblxuICBHcmFwaE5vZGUucHJvdG90eXBlLmdldEFkamFjZW50RGF0YUluZGljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGFJbmRpY2VzID0ge1xuICAgICAgZWRnZTogW10sXG4gICAgICBub2RlOiBbXVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhZGphY2VudEVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xuXG4gICAgICBpZiAoYWRqYWNlbnRFZGdlLmRhdGFJbmRleCA8IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGRhdGFJbmRpY2VzLmVkZ2UucHVzaChhZGphY2VudEVkZ2UuZGF0YUluZGV4KTtcbiAgICAgIGRhdGFJbmRpY2VzLm5vZGUucHVzaChhZGphY2VudEVkZ2Uubm9kZTEuZGF0YUluZGV4LCBhZGphY2VudEVkZ2Uubm9kZTIuZGF0YUluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YUluZGljZXM7XG4gIH07XG5cbiAgcmV0dXJuIEdyYXBoTm9kZTtcbn0oKTtcblxudmFyIEdyYXBoRWRnZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdyYXBoRWRnZShuMSwgbjIsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuZGF0YUluZGV4ID0gLTE7XG4gICAgdGhpcy5ub2RlMSA9IG4xO1xuICAgIHRoaXMubm9kZTIgPSBuMjtcbiAgICB0aGlzLmRhdGFJbmRleCA9IGRhdGFJbmRleCA9PSBudWxsID8gLTEgOiBkYXRhSW5kZXg7XG4gIH1cblxuICBHcmFwaEVkZ2UucHJvdG90eXBlLmdldE1vZGVsID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAodGhpcy5kYXRhSW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdyYXBoID0gdGhpcy5ob3N0R3JhcGg7XG4gICAgdmFyIGl0ZW1Nb2RlbCA9IGdyYXBoLmVkZ2VEYXRhLmdldEl0ZW1Nb2RlbCh0aGlzLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIGl0ZW1Nb2RlbC5nZXRNb2RlbChwYXRoKTtcbiAgfTtcblxuICBHcmFwaEVkZ2UucHJvdG90eXBlLmdldEFkamFjZW50RGF0YUluZGljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVkZ2U6IFt0aGlzLmRhdGFJbmRleF0sXG4gICAgICBub2RlOiBbdGhpcy5ub2RlMS5kYXRhSW5kZXgsIHRoaXMubm9kZTIuZGF0YUluZGV4XVxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIEdyYXBoRWRnZTtcbn0oKTtcblxuZnVuY3Rpb24gY3JlYXRlR3JhcGhEYXRhUHJveHlNaXhpbihob3N0TmFtZSwgZGF0YU5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gRGVmYXVsdCAndmFsdWUnLiBjYW4gYmUgJ2EnLCAnYicsICdjJywgJ2QnLCAnZScuXG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChkaW1lbnNpb24pIHtcbiAgICAgIHZhciBkYXRhID0gdGhpc1tob3N0TmFtZV1bZGF0YU5hbWVdO1xuICAgICAgcmV0dXJuIGRhdGEuZ2V0KGRhdGEuZ2V0RGltZW5zaW9uKGRpbWVuc2lvbiB8fCAndmFsdWUnKSwgdGhpcy5kYXRhSW5kZXgpO1xuICAgIH0sXG4gICAgLy8gVE9ETzogVFlQRSBzdHJpY3RlciB0eXBlLlxuICAgIHNldFZpc3VhbDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuZGF0YUluZGV4ID49IDAgJiYgdGhpc1tob3N0TmFtZV1bZGF0YU5hbWVdLnNldEl0ZW1WaXN1YWwodGhpcy5kYXRhSW5kZXgsIGtleSwgdmFsdWUpO1xuICAgIH0sXG4gICAgZ2V0VmlzdWFsOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpc1tob3N0TmFtZV1bZGF0YU5hbWVdLmdldEl0ZW1WaXN1YWwodGhpcy5kYXRhSW5kZXgsIGtleSk7XG4gICAgfSxcbiAgICBzZXRMYXlvdXQ6IGZ1bmN0aW9uIChsYXlvdXQsIG1lcmdlKSB7XG4gICAgICB0aGlzLmRhdGFJbmRleCA+PSAwICYmIHRoaXNbaG9zdE5hbWVdW2RhdGFOYW1lXS5zZXRJdGVtTGF5b3V0KHRoaXMuZGF0YUluZGV4LCBsYXlvdXQsIG1lcmdlKTtcbiAgICB9LFxuICAgIGdldExheW91dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXNbaG9zdE5hbWVdW2RhdGFOYW1lXS5nZXRJdGVtTGF5b3V0KHRoaXMuZGF0YUluZGV4KTtcbiAgICB9LFxuICAgIGdldEdyYXBoaWNFbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXNbaG9zdE5hbWVdW2RhdGFOYW1lXS5nZXRJdGVtR3JhcGhpY0VsKHRoaXMuZGF0YUluZGV4KTtcbiAgICB9LFxuICAgIGdldFJhd0luZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpc1tob3N0TmFtZV1bZGF0YU5hbWVdLmdldFJhd0luZGV4KHRoaXMuZGF0YUluZGV4KTtcbiAgICB9XG4gIH07XG59XG5cbjtcbjtcbjtcbnpyVXRpbC5taXhpbihHcmFwaE5vZGUsIGNyZWF0ZUdyYXBoRGF0YVByb3h5TWl4aW4oJ2hvc3RHcmFwaCcsICdkYXRhJykpO1xuenJVdGlsLm1peGluKEdyYXBoRWRnZSwgY3JlYXRlR3JhcGhEYXRhUHJveHlNaXhpbignaG9zdEdyYXBoJywgJ2VkZ2VEYXRhJykpO1xuZXhwb3J0IGRlZmF1bHQgR3JhcGg7XG5leHBvcnQgeyBHcmFwaE5vZGUsIEdyYXBoRWRnZSB9OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogVHJlZSBkYXRhIHN0cnVjdHVyZVxuICovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBsaW5rTGlzdCBmcm9tICcuL2hlbHBlci9saW5rTGlzdCc7XG5pbXBvcnQgTGlzdCBmcm9tICcuL0xpc3QnO1xuaW1wb3J0IGNyZWF0ZURpbWVuc2lvbnMgZnJvbSAnLi9oZWxwZXIvY3JlYXRlRGltZW5zaW9ucyc7XG5pbXBvcnQgeyBjb252ZXJ0T3B0aW9uSWROYW1lIH0gZnJvbSAnLi4vdXRpbC9tb2RlbCc7XG5cbnZhciBUcmVlTm9kZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyZWVOb2RlKG5hbWUsIGhvc3RUcmVlKSB7XG4gICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byBsaXN0IGl0ZW0uXG4gICAgICogRG8gbm90IHBlcnNpc3RlbnQgZGF0YUluZGV4IG91dHNpZGUsXG4gICAgICogYmVzYXVzZSBpdCBtYXkgYmUgY2hhbmdlZCBieSBsaXN0LlxuICAgICAqIElmIGRhdGFJbmRleCAtMSxcbiAgICAgKiB0aGlzIG5vZGUgaXMgbG9naWNhbCBkZWxldGVkIChmaWx0ZXJlZCkgaW4gbGlzdC5cbiAgICAgKi9cblxuICAgIHRoaXMuZGF0YUluZGV4ID0gLTE7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMudmlld0NoaWxkcmVuID0gW107XG4gICAgdGhpcy5pc0V4cGFuZCA9IGZhbHNlO1xuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0VHJlZSA9IGhvc3RUcmVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbm9kZSBpcyByZW1vdmVkLlxuICAgKi9cblxuXG4gIFRyZWVOb2RlLnByb3RvdHlwZS5pc1JlbW92ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YUluZGV4IDwgMDtcbiAgfTtcblxuICBUcmVlTm9kZS5wcm90b3R5cGUuZWFjaE5vZGUgPSBmdW5jdGlvbiAob3B0aW9ucywgY2IsIGNvbnRleHQpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnRleHQgPSBjYjtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHpyVXRpbC5pc1N0cmluZyhvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgb3JkZXI6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG9yZGVyID0gb3B0aW9ucy5vcmRlciB8fCAncHJlb3JkZXInO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXNbb3B0aW9ucy5hdHRyIHx8ICdjaGlsZHJlbiddO1xuICAgIHZhciBzdXBwcmVzc1Zpc2l0U3ViO1xuICAgIG9yZGVyID09PSAncHJlb3JkZXInICYmIChzdXBwcmVzc1Zpc2l0U3ViID0gY2IuY2FsbChjb250ZXh0LCB0aGlzKSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgIXN1cHByZXNzVmlzaXRTdWIgJiYgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZHJlbltpXS5lYWNoTm9kZShvcHRpb25zLCBjYiwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgb3JkZXIgPT09ICdwb3N0b3JkZXInICYmIGNiLmNhbGwoY29udGV4dCwgdGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiBVcGRhdGUgZGVwdGggYW5kIGhlaWdodCBvZiB0aGlzIHN1YnRyZWUuXG4gICAqL1xuXG5cbiAgVHJlZU5vZGUucHJvdG90eXBlLnVwZGF0ZURlcHRoQW5kSGVpZ2h0ID0gZnVuY3Rpb24gKGRlcHRoKSB7XG4gICAgdmFyIGhlaWdodCA9IDA7XG4gICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgY2hpbGQudXBkYXRlRGVwdGhBbmRIZWlnaHQoZGVwdGggKyAxKTtcblxuICAgICAgaWYgKGNoaWxkLmhlaWdodCA+IGhlaWdodCkge1xuICAgICAgICBoZWlnaHQgPSBjaGlsZC5oZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKyAxO1xuICB9O1xuXG4gIFRyZWVOb2RlLnByb3RvdHlwZS5nZXROb2RlQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIGlmICh0aGlzLmdldElkKCkgPT09IGlkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHJlcyA9IGNoaWxkcmVuW2ldLmdldE5vZGVCeUlkKGlkKTtcblxuICAgICAgaWYgKHJlcykge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBUcmVlTm9kZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlID09PSB0aGlzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHJlcyA9IGNoaWxkcmVuW2ldLmNvbnRhaW5zKG5vZGUpO1xuXG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHBhcmFtIGluY2x1ZGVTZWxmIERlZmF1bHQgZmFsc2UuXG4gICAqIEByZXR1cm4gb3JkZXI6IFtyb290LCBjaGlsZCwgZ3JhbmRjaGlsZCwgLi4uXVxuICAgKi9cblxuXG4gIFRyZWVOb2RlLnByb3RvdHlwZS5nZXRBbmNlc3RvcnMgPSBmdW5jdGlvbiAoaW5jbHVkZVNlbGYpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gW107XG4gICAgdmFyIG5vZGUgPSBpbmNsdWRlU2VsZiA/IHRoaXMgOiB0aGlzLnBhcmVudE5vZGU7XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgYW5jZXN0b3JzLnB1c2gobm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGFuY2VzdG9ycy5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIGFuY2VzdG9ycztcbiAgfTtcblxuICBUcmVlTm9kZS5wcm90b3R5cGUuZ2V0QW5jZXN0b3JzSW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIHZhciBjdXJyTm9kZSA9IHRoaXM7XG5cbiAgICB3aGlsZSAoY3Vyck5vZGUpIHtcbiAgICAgIGluZGljZXMucHVzaChjdXJyTm9kZS5kYXRhSW5kZXgpO1xuICAgICAgY3Vyck5vZGUgPSBjdXJyTm9kZS5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGluZGljZXMucmV2ZXJzZSgpO1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9O1xuXG4gIFRyZWVOb2RlLnByb3RvdHlwZS5nZXREZXNjZW5kYW50SW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIHRoaXMuZWFjaE5vZGUoZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgaW5kaWNlcy5wdXNoKGNoaWxkTm9kZS5kYXRhSW5kZXgpO1xuICAgIH0pO1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9O1xuXG4gIFRyZWVOb2RlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChkaW1lbnNpb24pIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuaG9zdFRyZWUuZGF0YTtcbiAgICByZXR1cm4gZGF0YS5nZXQoZGF0YS5nZXREaW1lbnNpb24oZGltZW5zaW9uIHx8ICd2YWx1ZScpLCB0aGlzLmRhdGFJbmRleCk7XG4gIH07XG5cbiAgVHJlZU5vZGUucHJvdG90eXBlLnNldExheW91dCA9IGZ1bmN0aW9uIChsYXlvdXQsIG1lcmdlKSB7XG4gICAgdGhpcy5kYXRhSW5kZXggPj0gMCAmJiB0aGlzLmhvc3RUcmVlLmRhdGEuc2V0SXRlbUxheW91dCh0aGlzLmRhdGFJbmRleCwgbGF5b3V0LCBtZXJnZSk7XG4gIH07XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGxheW91dFxuICAgKi9cblxuXG4gIFRyZWVOb2RlLnByb3RvdHlwZS5nZXRMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9zdFRyZWUuZGF0YS5nZXRJdGVtTGF5b3V0KHRoaXMuZGF0YUluZGV4KTtcbiAgfTsgLy8gQGRlcGNyZWNhdGVkXG4gIC8vIGdldE1vZGVsPFQgPSB1bmtub3duLCBTIGV4dGVuZHMga2V5b2YgVCA9IGtleW9mIFQ+KHBhdGg6IFMpOiBNb2RlbDxUW1NdPlxuXG5cbiAgVHJlZU5vZGUucHJvdG90eXBlLmdldE1vZGVsID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAodGhpcy5kYXRhSW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhvc3RUcmVlID0gdGhpcy5ob3N0VHJlZTtcbiAgICB2YXIgaXRlbU1vZGVsID0gaG9zdFRyZWUuZGF0YS5nZXRJdGVtTW9kZWwodGhpcy5kYXRhSW5kZXgpO1xuICAgIHJldHVybiBpdGVtTW9kZWwuZ2V0TW9kZWwocGF0aCk7XG4gIH07IC8vIFRPRE86IFRZUEUgTW9yZSBzcGVjaWZpYyBtb2RlbFxuXG5cbiAgVHJlZU5vZGUucHJvdG90eXBlLmdldExldmVsTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmhvc3RUcmVlLmxldmVsTW9kZWxzIHx8IFtdKVt0aGlzLmRlcHRoXTtcbiAgfTtcblxuICBUcmVlTm9kZS5wcm90b3R5cGUuc2V0VmlzdWFsID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmRhdGFJbmRleCA+PSAwICYmIHRoaXMuaG9zdFRyZWUuZGF0YS5zZXRJdGVtVmlzdWFsKHRoaXMuZGF0YUluZGV4LCBrZXksIHZhbHVlKTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldCBpdGVtIHZpc3VhbFxuICAgKi9cblxuXG4gIFRyZWVOb2RlLnByb3RvdHlwZS5nZXRWaXN1YWwgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuaG9zdFRyZWUuZGF0YS5nZXRJdGVtVmlzdWFsKHRoaXMuZGF0YUluZGV4LCBrZXkpO1xuICB9O1xuXG4gIFRyZWVOb2RlLnByb3RvdHlwZS5nZXRSYXdJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ob3N0VHJlZS5kYXRhLmdldFJhd0luZGV4KHRoaXMuZGF0YUluZGV4KTtcbiAgfTtcblxuICBUcmVlTm9kZS5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9zdFRyZWUuZGF0YS5nZXRJZCh0aGlzLmRhdGFJbmRleCk7XG4gIH07XG4gIC8qKlxuICAgKiBpZiB0aGlzIGlzIGFuIGFuY2VzdG9yIG9mIGFub3RoZXIgbm9kZVxuICAgKlxuICAgKiBAcGFyYW0gbm9kZSBhbm90aGVyIG5vZGVcbiAgICogQHJldHVybiBpZiBpcyBhbmNlc3RvclxuICAgKi9cblxuXG4gIFRyZWVOb2RlLnByb3RvdHlwZS5pc0FuY2VzdG9yT2YgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG5cbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50ID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIC8qKlxuICAgKiBpZiB0aGlzIGlzIGFuIGRlc2NlbmRhbnQgb2YgYW5vdGhlciBub2RlXG4gICAqXG4gICAqIEBwYXJhbSBub2RlIGFub3RoZXIgbm9kZVxuICAgKiBAcmV0dXJuIGlmIGlzIGRlc2NlbmRhbnRcbiAgICovXG5cblxuICBUcmVlTm9kZS5wcm90b3R5cGUuaXNEZXNjZW5kYW50T2YgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlICE9PSB0aGlzICYmIG5vZGUuaXNBbmNlc3Rvck9mKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBUcmVlTm9kZTtcbn0oKTtcblxuZXhwb3J0IHsgVHJlZU5vZGUgfTtcbjtcblxudmFyIFRyZWUgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmVlKGhvc3RNb2RlbCkge1xuICAgIHRoaXMudHlwZSA9ICd0cmVlJztcbiAgICB0aGlzLl9ub2RlcyA9IFtdO1xuICAgIHRoaXMuaG9zdE1vZGVsID0gaG9zdE1vZGVsO1xuICB9XG5cbiAgVHJlZS5wcm90b3R5cGUuZWFjaE5vZGUgPSBmdW5jdGlvbiAob3B0aW9ucywgY2IsIGNvbnRleHQpIHtcbiAgICB0aGlzLnJvb3QuZWFjaE5vZGUob3B0aW9ucywgY2IsIGNvbnRleHQpO1xuICB9O1xuXG4gIFRyZWUucHJvdG90eXBlLmdldE5vZGVCeURhdGFJbmRleCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICB2YXIgcmF3SW5kZXggPSB0aGlzLmRhdGEuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KTtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXNbcmF3SW5kZXhdO1xuICB9O1xuXG4gIFRyZWUucHJvdG90eXBlLmdldE5vZGVCeUlkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5yb290LmdldE5vZGVCeUlkKG5hbWUpO1xuICB9O1xuICAvKipcbiAgICogVXBkYXRlIGl0ZW0gYXZhaWxhYmxlIGJ5IGxpc3QsXG4gICAqIHdoZW4gbGlzdCBoYXMgYmVlbiBwZXJmb3JtZWQgb3B0aW9ucyBsaWtlICdmaWx0ZXJTZWxmJyBvciAnbWFwJy5cbiAgICovXG5cblxuICBUcmVlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5fbm9kZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5vZGVzW2ldLmRhdGFJbmRleCA9IC0xO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmNvdW50KCk7IGkgPCBsZW47IGkrKykge1xuICAgICAgbm9kZXNbZGF0YS5nZXRSYXdJbmRleChpKV0uZGF0YUluZGV4ID0gaTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBDbGVhciBhbGwgbGF5b3V0c1xuICAgKi9cblxuXG4gIFRyZWUucHJvdG90eXBlLmNsZWFyTGF5b3V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRhdGEuY2xlYXJJdGVtTGF5b3V0cygpO1xuICB9O1xuICAvKipcbiAgICogZGF0YSBub2RlIGZvcm1hdDpcbiAgICoge1xuICAgKiAgICAgbmFtZTogLi4uXG4gICAqICAgICB2YWx1ZTogLi4uXG4gICAqICAgICBjaGlsZHJlbjogW1xuICAgKiAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgbmFtZTogLi4uXG4gICAqICAgICAgICAgICAgIHZhbHVlOiAuLi5cbiAgICogICAgICAgICAgICAgY2hpbGRyZW46IC4uLlxuICAgKiAgICAgICAgIH0sXG4gICAqICAgICAgICAgLi4uXG4gICAqICAgICBdXG4gICAqIH1cbiAgICovXG5cblxuICBUcmVlLmNyZWF0ZVRyZWUgPSBmdW5jdGlvbiAoZGF0YVJvb3QsIGhvc3RNb2RlbCwgYmVmb3JlTGluaykge1xuICAgIHZhciB0cmVlID0gbmV3IFRyZWUoaG9zdE1vZGVsKTtcbiAgICB2YXIgbGlzdERhdGEgPSBbXTtcbiAgICB2YXIgZGltTWF4ID0gMTtcbiAgICBidWlsZEhpZXJhcmNoeShkYXRhUm9vdCk7XG5cbiAgICBmdW5jdGlvbiBidWlsZEhpZXJhcmNoeShkYXRhTm9kZSwgcGFyZW50Tm9kZSkge1xuICAgICAgdmFyIHZhbHVlID0gZGF0YU5vZGUudmFsdWU7XG4gICAgICBkaW1NYXggPSBNYXRoLm1heChkaW1NYXgsIHpyVXRpbC5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IDEpO1xuICAgICAgbGlzdERhdGEucHVzaChkYXRhTm9kZSk7XG4gICAgICB2YXIgbm9kZSA9IG5ldyBUcmVlTm9kZShjb252ZXJ0T3B0aW9uSWROYW1lKGRhdGFOb2RlLm5hbWUsICcnKSwgdHJlZSk7XG4gICAgICBwYXJlbnROb2RlID8gYWRkQ2hpbGQobm9kZSwgcGFyZW50Tm9kZSkgOiB0cmVlLnJvb3QgPSBub2RlO1xuXG4gICAgICB0cmVlLl9ub2Rlcy5wdXNoKG5vZGUpO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBkYXRhTm9kZS5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBidWlsZEhpZXJhcmNoeShjaGlsZHJlbltpXSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cmVlLnJvb3QudXBkYXRlRGVwdGhBbmRIZWlnaHQoMCk7XG4gICAgdmFyIGRpbWVuc2lvbnNJbmZvID0gY3JlYXRlRGltZW5zaW9ucyhsaXN0RGF0YSwge1xuICAgICAgY29vcmREaW1lbnNpb25zOiBbJ3ZhbHVlJ10sXG4gICAgICBkaW1lbnNpb25zQ291bnQ6IGRpbU1heFxuICAgIH0pO1xuICAgIHZhciBsaXN0ID0gbmV3IExpc3QoZGltZW5zaW9uc0luZm8sIGhvc3RNb2RlbCk7XG4gICAgbGlzdC5pbml0RGF0YShsaXN0RGF0YSk7XG4gICAgYmVmb3JlTGluayAmJiBiZWZvcmVMaW5rKGxpc3QpO1xuICAgIGxpbmtMaXN0KHtcbiAgICAgIG1haW5EYXRhOiBsaXN0LFxuICAgICAgc3RydWN0OiB0cmVlLFxuICAgICAgc3RydWN0QXR0cjogJ3RyZWUnXG4gICAgfSk7XG4gICAgdHJlZS51cGRhdGUoKTtcbiAgICByZXR1cm4gdHJlZTtcbiAgfTtcblxuICByZXR1cm4gVHJlZTtcbn0oKTtcbi8qKlxuICogSXQgaXMgbmVlZGVkIHRvIGNvbnNpZGVyIHRoZSBtZXNzIG9mICdsaXN0JywgJ2hvc3RNb2RlbCcgd2hlbiBjcmVhdGluZyBhIFRyZWVOb3RlLFxuICogc28gdGhpcyBmdW5jdGlvbiBpcyBub3QgcmVhZHkgYW5kIG5vdCBuZWNlc3NhcnkgdG8gYmUgcHVibGljLlxuICovXG5cblxuZnVuY3Rpb24gYWRkQ2hpbGQoY2hpbGQsIG5vZGUpIHtcbiAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcblxuICBpZiAoY2hpbGQucGFyZW50Tm9kZSA9PT0gbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICBjaGlsZC5wYXJlbnROb2RlID0gbm9kZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVHJlZTsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIExpbmsgbGlzdHMgYW5kIHN0cnVjdCAoZ3JhcGggb3IgdHJlZSlcbiAqL1xuaW1wb3J0IHsgY3VycnksIGVhY2gsIGFzc2VydCwgZXh0ZW5kLCBtYXAsIGtleXMgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgbWFrZUlubmVyIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcblxuZnVuY3Rpb24gbGlua0xpc3Qob3B0KSB7XG4gIHZhciBtYWluRGF0YSA9IG9wdC5tYWluRGF0YTtcbiAgdmFyIGRhdGFzID0gb3B0LmRhdGFzO1xuXG4gIGlmICghZGF0YXMpIHtcbiAgICBkYXRhcyA9IHtcbiAgICAgIG1haW46IG1haW5EYXRhXG4gICAgfTtcbiAgICBvcHQuZGF0YXNBdHRyID0ge1xuICAgICAgbWFpbjogJ2RhdGEnXG4gICAgfTtcbiAgfVxuXG4gIG9wdC5kYXRhcyA9IG9wdC5tYWluRGF0YSA9IG51bGw7XG4gIGxpbmtBbGwobWFpbkRhdGEsIGRhdGFzLCBvcHQpOyAvLyBQb3J4eSBkYXRhIG9yaWdpbmFsIG1ldGhvZHMuXG5cbiAgZWFjaChkYXRhcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBlYWNoKG1haW5EYXRhLlRSQU5TRkVSQUJMRV9NRVRIT0RTLCBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgZGF0YS53cmFwTWV0aG9kKG1ldGhvZE5hbWUsIGN1cnJ5KHRyYW5zZmVySW5qZWN0aW9uLCBvcHQpKTtcbiAgICB9KTtcbiAgfSk7IC8vIEJleW9uZCB0cmFuc2ZlciwgYWRkaXRpb25hbCBmZWF0dXJlcyBzaG91bGQgYmUgYWRkZWQgdG8gYGNsb25lU2hhbGxvd2AuXG5cbiAgbWFpbkRhdGEud3JhcE1ldGhvZCgnY2xvbmVTaGFsbG93JywgY3VycnkoY2xvbmVTaGFsbG93SW5qZWN0aW9uLCBvcHQpKTsgLy8gT25seSBtYWluRGF0YSB0cmlnZ2VyIGNoYW5nZSwgYmVjYXVzZSBzdHJ1Y3QudXBkYXRlIG1heSB0cmlnZ2VyXG4gIC8vIGFub3RoZXIgY2hhbmdhYmxlIG1ldGhvZHMsIHdoaWNoIG1heSBicmluZyBhYm91dCBkZWFkIGxvY2suXG5cbiAgZWFjaChtYWluRGF0YS5DSEFOR0FCTEVfTUVUSE9EUywgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICBtYWluRGF0YS53cmFwTWV0aG9kKG1ldGhvZE5hbWUsIGN1cnJ5KGNoYW5nZUluamVjdGlvbiwgb3B0KSk7XG4gIH0pOyAvLyBNYWtlIHN1cmUgZGF0YXMgY29udGFpbnMgbWFpbkRhdGEuXG5cbiAgYXNzZXJ0KGRhdGFzW21haW5EYXRhLmRhdGFUeXBlXSA9PT0gbWFpbkRhdGEpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2ZlckluamVjdGlvbihvcHQsIHJlcykge1xuICBpZiAoaXNNYWluRGF0YSh0aGlzKSkge1xuICAgIC8vIFRyYW5zZmVyIGRhdGFzIHRvIG5ldyBtYWluIGRhdGEuXG4gICAgdmFyIGRhdGFzID0gZXh0ZW5kKHt9LCBpbm5lcih0aGlzKS5kYXRhcyk7XG4gICAgZGF0YXNbdGhpcy5kYXRhVHlwZV0gPSByZXM7XG4gICAgbGlua0FsbChyZXMsIGRhdGFzLCBvcHQpO1xuICB9IGVsc2Uge1xuICAgIC8vIE1vZGlmeSB0aGUgcmVmZXJlbmNlIGluIG1haW4gZGF0YSB0byBwb2ludCBuZXdEYXRhLlxuICAgIGxpbmtTaW5nbGUocmVzLCB0aGlzLmRhdGFUeXBlLCBpbm5lcih0aGlzKS5tYWluRGF0YSwgb3B0KTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZUluamVjdGlvbihvcHQsIHJlcykge1xuICBvcHQuc3RydWN0ICYmIG9wdC5zdHJ1Y3QudXBkYXRlKCk7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNsb25lU2hhbGxvd0luamVjdGlvbihvcHQsIHJlcykge1xuICAvLyBjbG9uZVNoYWxsb3csIHdoaWNoIGJyaW5ncyBhYm91dCBzb21lIGZyYWdpbGl0aWVzLCBtYXkgYmUgaW5hcHByb3ByaWF0ZVxuICAvLyB0byBiZSBleHBvc2VkIGFzIGFuIEFQSS4gU28gZm9yIGltcGxlbWVudGF0aW9uIHNpbXBsaWNpdHkgd2UgY2FuIG1ha2VcbiAgLy8gdGhlIHJlc3RyaWN0aW9uIHRoYXQgY2xvbmVTaGFsbG93IG9mIG5vdC1tYWluRGF0YSBzaG91bGQgbm90IGJlIGludm9rZWRcbiAgLy8gb3V0c2lkZSwgYnV0IG9ubHkgYmUgaW52b2tlZCBoZXJlLlxuICBlYWNoKGlubmVyKHJlcykuZGF0YXMsIGZ1bmN0aW9uIChkYXRhLCBkYXRhVHlwZSkge1xuICAgIGRhdGEgIT09IHJlcyAmJiBsaW5rU2luZ2xlKGRhdGEuY2xvbmVTaGFsbG93KCksIGRhdGFUeXBlLCByZXMsIG9wdCk7XG4gIH0pO1xuICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBTdXBwbGVtZW50IG1ldGhvZCB0byBMaXN0LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBbZGF0YVR5cGVdIElmIG5vdCBzcGVjaWZpZWQsIHJldHVybiBtYWluRGF0YS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExpbmtlZERhdGEoZGF0YVR5cGUpIHtcbiAgdmFyIG1haW5EYXRhID0gaW5uZXIodGhpcykubWFpbkRhdGE7XG4gIHJldHVybiBkYXRhVHlwZSA9PSBudWxsIHx8IG1haW5EYXRhID09IG51bGwgPyBtYWluRGF0YSA6IGlubmVyKG1haW5EYXRhKS5kYXRhc1tkYXRhVHlwZV07XG59XG4vKipcbiAqIEdldCBsaXN0IG9mIGFsbCBsaW5rZWQgZGF0YVxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGlua2VkRGF0YUFsbCgpIHtcbiAgdmFyIG1haW5EYXRhID0gaW5uZXIodGhpcykubWFpbkRhdGE7XG4gIHJldHVybiBtYWluRGF0YSA9PSBudWxsID8gW3tcbiAgICBkYXRhOiBtYWluRGF0YVxuICB9XSA6IG1hcChrZXlzKGlubmVyKG1haW5EYXRhKS5kYXRhcyksIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBkYXRhOiBpbm5lcihtYWluRGF0YSkuZGF0YXNbdHlwZV1cbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNNYWluRGF0YShkYXRhKSB7XG4gIHJldHVybiBpbm5lcihkYXRhKS5tYWluRGF0YSA9PT0gZGF0YTtcbn1cblxuZnVuY3Rpb24gbGlua0FsbChtYWluRGF0YSwgZGF0YXMsIG9wdCkge1xuICBpbm5lcihtYWluRGF0YSkuZGF0YXMgPSB7fTtcbiAgZWFjaChkYXRhcywgZnVuY3Rpb24gKGRhdGEsIGRhdGFUeXBlKSB7XG4gICAgbGlua1NpbmdsZShkYXRhLCBkYXRhVHlwZSwgbWFpbkRhdGEsIG9wdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsaW5rU2luZ2xlKGRhdGEsIGRhdGFUeXBlLCBtYWluRGF0YSwgb3B0KSB7XG4gIGlubmVyKG1haW5EYXRhKS5kYXRhc1tkYXRhVHlwZV0gPSBkYXRhO1xuICBpbm5lcihkYXRhKS5tYWluRGF0YSA9IG1haW5EYXRhO1xuICBkYXRhLmRhdGFUeXBlID0gZGF0YVR5cGU7XG5cbiAgaWYgKG9wdC5zdHJ1Y3QpIHtcbiAgICBkYXRhW29wdC5zdHJ1Y3RBdHRyXSA9IG9wdC5zdHJ1Y3Q7XG4gICAgb3B0LnN0cnVjdFtvcHQuZGF0YXNBdHRyW2RhdGFUeXBlXV0gPSBkYXRhO1xuICB9IC8vIFN1cHBsZW1lbnQgbWV0aG9kLlxuXG5cbiAgZGF0YS5nZXRMaW5rZWREYXRhID0gZ2V0TGlua2VkRGF0YTtcbiAgZGF0YS5nZXRMaW5rZWREYXRhQWxsID0gZ2V0TGlua2VkRGF0YUFsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlua0xpc3Q7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbi8vIEluIHNvbWVob3cuIElmIHdlIGV4cG9ydCBsaWtlXG4vLyBleHBvcnQgKiBhcyBMaW5lQ2hhcnQgJy4vY2hhcnQvbGluZS9pbnN0YWxsJ1xuLy8gVGhlIGV4cG9ydGVkIGNvZGUgd2lsbCBiZSB0cmFuc2Zvcm1lZCB0b1xuLy8gaW1wb3J0ICogYXMgTGluZUNoYXJ0XzEgJy4vY2hhcnQvbGluZS9pbnN0YWxsJzsgZXhwb3J0IHtMaW5lQ2hhcnRfMSBhcyBMaW5lQ2hhcnR9O1xuLy8gVHJlZXNoYWtpbmcgaW4gd2VicGFjayB3aWxsIG5vdCB3b3JrIGV2ZW4gaWYgd2UgY29uZmlndXJlZCBzaWRlRWZmZWN0cyB0byBmYWxzZSBpbiBwYWNrYWdlLmpzb25cbmV4cG9ydCB7IGluc3RhbGwgYXMgTGluZUNoYXJ0IH0gZnJvbSAnLi4vY2hhcnQvbGluZS9pbnN0YWxsJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgQmFyQ2hhcnQgfSBmcm9tICcuLi9jaGFydC9iYXIvaW5zdGFsbCc7XG5leHBvcnQgeyBpbnN0YWxsIGFzIFBpZUNoYXJ0IH0gZnJvbSAnLi4vY2hhcnQvcGllL2luc3RhbGwnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBTY2F0dGVyQ2hhcnQgfSBmcm9tICcuLi9jaGFydC9zY2F0dGVyL2luc3RhbGwnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBSYWRhckNoYXJ0IH0gZnJvbSAnLi4vY2hhcnQvcmFkYXIvaW5zdGFsbCc7XG5leHBvcnQgeyBpbnN0YWxsIGFzIE1hcENoYXJ0IH0gZnJvbSAnLi4vY2hhcnQvbWFwL2luc3RhbGwnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBUcmVlQ2hhcnQgfSBmcm9tICcuLi9jaGFydC90cmVlL2luc3RhbGwnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBUcmVlbWFwQ2hhcnQgfSBmcm9tICcuLi9jaGFydC90cmVlbWFwL2luc3RhbGwnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBHcmFwaENoYXJ0IH0gZnJvbSAnLi4vY2hhcnQvZ3JhcGgvaW5zdGFsbCc7XG5leHBvcnQgeyBpbnN0YWxsIGFzIEdhdWdlQ2hhcnQgfSBmcm9tICcuLi9jaGFydC9nYXVnZS9pbnN0YWxsJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgRnVubmVsQ2hhcnQgfSBmcm9tICcuLi9jaGFydC9mdW5uZWwvaW5zdGFsbCc7XG5leHBvcnQgeyBpbnN0YWxsIGFzIFBhcmFsbGVsQ2hhcnQgfSBmcm9tICcuLi9jaGFydC9wYXJhbGxlbC9pbnN0YWxsJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgU2Fua2V5Q2hhcnQgfSBmcm9tICcuLi9jaGFydC9zYW5rZXkvaW5zdGFsbCc7XG5leHBvcnQgeyBpbnN0YWxsIGFzIEJveHBsb3RDaGFydCB9IGZyb20gJy4uL2NoYXJ0L2JveHBsb3QvaW5zdGFsbCc7XG5leHBvcnQgeyBpbnN0YWxsIGFzIENhbmRsZXN0aWNrQ2hhcnQgfSBmcm9tICcuLi9jaGFydC9jYW5kbGVzdGljay9pbnN0YWxsJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgRWZmZWN0U2NhdHRlckNoYXJ0IH0gZnJvbSAnLi4vY2hhcnQvZWZmZWN0U2NhdHRlci9pbnN0YWxsJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgTGluZXNDaGFydCB9IGZyb20gJy4uL2NoYXJ0L2xpbmVzL2luc3RhbGwnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBIZWF0bWFwQ2hhcnQgfSBmcm9tICcuLi9jaGFydC9oZWF0bWFwL2luc3RhbGwnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBQaWN0b3JpYWxCYXJDaGFydCB9IGZyb20gJy4uL2NoYXJ0L2Jhci9pbnN0YWxsUGljdG9yaWFsQmFyJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgVGhlbWVSaXZlckNoYXJ0IH0gZnJvbSAnLi4vY2hhcnQvdGhlbWVSaXZlci9pbnN0YWxsJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgU3VuYnVyc3RDaGFydCB9IGZyb20gJy4uL2NoYXJ0L3N1bmJ1cnN0L2luc3RhbGwnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBDdXN0b21DaGFydCB9IGZyb20gJy4uL2NoYXJ0L2N1c3RvbS9pbnN0YWxsJzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKiBnbG9iYWwgRmxvYXQzMkFycmF5ICovXG5pbXBvcnQgeyBtYXAgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IGNyZWF0ZVJlbmRlclBsYW5uZXIgZnJvbSAnLi4vY2hhcnQvaGVscGVyL2NyZWF0ZVJlbmRlclBsYW5uZXInO1xuaW1wb3J0IHsgaXNEaW1lbnNpb25TdGFja2VkIH0gZnJvbSAnLi4vZGF0YS9oZWxwZXIvZGF0YVN0YWNrSGVscGVyJztcbmltcG9ydCB7IGNyZWF0ZUZsb2F0MzJBcnJheSB9IGZyb20gJy4uL3V0aWwvdmVuZG9yJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBvaW50c0xheW91dChzZXJpZXNUeXBlLCBmb3JjZVN0b3JlSW5UeXBlZEFycmF5KSB7XG4gIHJldHVybiB7XG4gICAgc2VyaWVzVHlwZTogc2VyaWVzVHlwZSxcbiAgICBwbGFuOiBjcmVhdGVSZW5kZXJQbGFubmVyKCksXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgdmFyIHBpcGVsaW5lQ29udGV4dCA9IHNlcmllc01vZGVsLnBpcGVsaW5lQ29udGV4dDtcbiAgICAgIHZhciB1c2VUeXBlZEFycmF5ID0gZm9yY2VTdG9yZUluVHlwZWRBcnJheSB8fCBwaXBlbGluZUNvbnRleHQubGFyZ2U7XG5cbiAgICAgIGlmICghY29vcmRTeXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGltcyA9IG1hcChjb29yZFN5cy5kaW1lbnNpb25zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIHJldHVybiBkYXRhLm1hcERpbWVuc2lvbihkaW0pO1xuICAgICAgfSkuc2xpY2UoMCwgMik7XG4gICAgICB2YXIgZGltTGVuID0gZGltcy5sZW5ndGg7XG4gICAgICB2YXIgc3RhY2tSZXN1bHREaW0gPSBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tSZXN1bHREaW1lbnNpb24nKTtcblxuICAgICAgaWYgKGlzRGltZW5zaW9uU3RhY2tlZChkYXRhLCBkaW1zWzBdXG4gICAgICAvKiwgZGltc1sxXSovXG4gICAgICApKSB7XG4gICAgICAgIGRpbXNbMF0gPSBzdGFja1Jlc3VsdERpbTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGltZW5zaW9uU3RhY2tlZChkYXRhLCBkaW1zWzFdXG4gICAgICAvKiwgZGltc1swXSovXG4gICAgICApKSB7XG4gICAgICAgIGRpbXNbMV0gPSBzdGFja1Jlc3VsdERpbTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpbUluZm8wID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpbXNbMF0pO1xuICAgICAgdmFyIGRpbUluZm8xID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpbXNbMV0pO1xuICAgICAgdmFyIGRpbUlkeDAgPSBkaW1JbmZvMCAmJiBkaW1JbmZvMC5pbmRleDtcbiAgICAgIHZhciBkaW1JZHgxID0gZGltSW5mbzEgJiYgZGltSW5mbzEuaW5kZXg7XG4gICAgICByZXR1cm4gZGltTGVuICYmIHtcbiAgICAgICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIChwYXJhbXMsIGRhdGEpIHtcbiAgICAgICAgICB2YXIgc2VnQ291bnQgPSBwYXJhbXMuZW5kIC0gcGFyYW1zLnN0YXJ0O1xuICAgICAgICAgIHZhciBwb2ludHMgPSB1c2VUeXBlZEFycmF5ICYmIGNyZWF0ZUZsb2F0MzJBcnJheShzZWdDb3VudCAqIGRpbUxlbik7XG4gICAgICAgICAgdmFyIHRtcEluID0gW107XG4gICAgICAgICAgdmFyIHRtcE91dCA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IHBhcmFtcy5zdGFydCwgb2Zmc2V0ID0gMDsgaSA8IHBhcmFtcy5lbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoZGltTGVuID09PSAxKSB7XG4gICAgICAgICAgICAgIHZhciB4ID0gZGF0YS5nZXRCeURpbUlkeChkaW1JZHgwLCBpKTsgLy8gTk9URTogTWFrZSBzdXJlIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIG51bGwgdG8gdXNlIGRlZmF1bHQgc3RyYXRlZ3kuXG5cbiAgICAgICAgICAgICAgcG9pbnQgPSBjb29yZFN5cy5kYXRhVG9Qb2ludCh4LCBudWxsLCB0bXBPdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdG1wSW5bMF0gPSBkYXRhLmdldEJ5RGltSWR4KGRpbUlkeDAsIGkpO1xuICAgICAgICAgICAgICB0bXBJblsxXSA9IGRhdGEuZ2V0QnlEaW1JZHgoZGltSWR4MSwgaSk7IC8vIExldCBjb29yZGluYXRlIHN5c3RlbSB0byBoYW5kbGUgdGhlIE5hTiBkYXRhLlxuXG4gICAgICAgICAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQodG1wSW4sIG51bGwsIHRtcE91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh1c2VUeXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgIHBvaW50c1tvZmZzZXQrK10gPSBwb2ludFswXTtcbiAgICAgICAgICAgICAgcG9pbnRzW29mZnNldCsrXSA9IHBvaW50WzFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtTGF5b3V0KGksIHBvaW50LnNsaWNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHVzZVR5cGVkQXJyYXkgJiYgZGF0YS5zZXRMYXlvdXQoJ3BvaW50cycsIHBvaW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkYXRhRmlsdGVyKHNlcmllc1R5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICBzZXJpZXNUeXBlOiBzZXJpZXNUeXBlLFxuICAgIHJlc2V0OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgIHZhciBsZWdlbmRNb2RlbHMgPSBlY01vZGVsLmZpbmRDb21wb25lbnRzKHtcbiAgICAgICAgbWFpblR5cGU6ICdsZWdlbmQnXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFsZWdlbmRNb2RlbHMgfHwgIWxlZ2VuZE1vZGVscy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgIGRhdGEuZmlsdGVyU2VsZihmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGlkeCk7IC8vIElmIGluIGFueSBsZWdlbmQgY29tcG9uZW50IHRoZSBzdGF0dXMgaXMgbm90IHNlbGVjdGVkLlxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVnZW5kTW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRTogTGVnZW5kTW9kZWxcbiAgICAgICAgICBpZiAoIWxlZ2VuZE1vZGVsc1tpXS5pc1NlbGVjdGVkKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbnZhciBzYW1wbGVycyA9IHtcbiAgYXZlcmFnZTogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGNvdW50ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghaXNOYU4oZnJhbWVbaV0pKSB7XG4gICAgICAgIHN1bSArPSBmcmFtZVtpXTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9IC8vIFJldHVybiBOYU4gaWYgY291bnQgaXMgMFxuXG5cbiAgICByZXR1cm4gY291bnQgPT09IDAgPyBOYU4gOiBzdW0gLyBjb3VudDtcbiAgfSxcbiAgc3VtOiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICB2YXIgc3VtID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIElnbm9yZSBOYU5cbiAgICAgIHN1bSArPSBmcmFtZVtpXSB8fCAwO1xuICAgIH1cblxuICAgIHJldHVybiBzdW07XG4gIH0sXG4gIG1heDogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyYW1lW2ldID4gbWF4ICYmIChtYXggPSBmcmFtZVtpXSk7XG4gICAgfSAvLyBOYU4gd2lsbCBjYXVzZSBpbGxlZ2FsIGF4aXMgZXh0ZW50LlxuXG5cbiAgICByZXR1cm4gaXNGaW5pdGUobWF4KSA/IG1heCA6IE5hTjtcbiAgfSxcbiAgbWluOiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICB2YXIgbWluID0gSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmcmFtZVtpXSA8IG1pbiAmJiAobWluID0gZnJhbWVbaV0pO1xuICAgIH0gLy8gTmFOIHdpbGwgY2F1c2UgaWxsZWdhbCBheGlzIGV4dGVudC5cblxuXG4gICAgcmV0dXJuIGlzRmluaXRlKG1pbikgPyBtaW4gOiBOYU47XG4gIH0sXG4gIC8vIFRPRE9cbiAgLy8gTWVkaWFuXG4gIG5lYXJlc3Q6IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgIHJldHVybiBmcmFtZVswXTtcbiAgfVxufTtcblxudmFyIGluZGV4U2FtcGxlciA9IGZ1bmN0aW9uIChmcmFtZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZChmcmFtZS5sZW5ndGggLyAyKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRhdGFTYW1wbGUoc2VyaWVzVHlwZSkge1xuICByZXR1cm4ge1xuICAgIHNlcmllc1R5cGU6IHNlcmllc1R5cGUsXG4gICAgLy8gRklYTUU6VFMgbmV2ZXIgdXNlZCwgc28gY29tbWVudCBpdFxuICAgIC8vIG1vZGlmeU91dHB1dEVuZDogdHJ1ZSxcbiAgICByZXNldDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgdmFyIHNhbXBsaW5nID0gc2VyaWVzTW9kZWwuZ2V0KCdzYW1wbGluZycpO1xuICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgIHZhciBjb3VudCA9IGRhdGEuY291bnQoKTsgLy8gT25seSBjYXJ0ZXNpYW4yZCBzdXBwb3J0IGRvd24gc2FtcGxpbmcuIERpc2FibGUgaXQgd2hlbiB0aGVyZSBpcyBmZXcgZGF0YS5cblxuICAgICAgaWYgKGNvdW50ID4gMTAgJiYgY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJyAmJiBzYW1wbGluZykge1xuICAgICAgICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICB2YXIgdmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKTtcbiAgICAgICAgdmFyIGV4dGVudCA9IGJhc2VBeGlzLmdldEV4dGVudCgpO1xuICAgICAgICB2YXIgZHByID0gYXBpLmdldERldmljZVBpeGVsUmF0aW8oKTsgLy8gQ29vcmRpbnN0ZSBzeXN0ZW0gaGFzIGJlZW4gcmVzaXplZFxuXG4gICAgICAgIHZhciBzaXplID0gTWF0aC5hYnMoZXh0ZW50WzFdIC0gZXh0ZW50WzBdKSAqIChkcHIgfHwgMSk7XG4gICAgICAgIHZhciByYXRlID0gTWF0aC5yb3VuZChjb3VudCAvIHNpemUpO1xuXG4gICAgICAgIGlmIChyYXRlID4gMSkge1xuICAgICAgICAgIGlmIChzYW1wbGluZyA9PT0gJ2x0dGInKSB7XG4gICAgICAgICAgICBzZXJpZXNNb2RlbC5zZXREYXRhKGRhdGEubHR0YkRvd25TYW1wbGUoZGF0YS5tYXBEaW1lbnNpb24odmFsdWVBeGlzLmRpbSksIDEgLyByYXRlKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNhbXBsZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHNhbXBsaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2FtcGxlciA9IHNhbXBsZXJzW3NhbXBsaW5nXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzYW1wbGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FtcGxlciA9IHNhbXBsaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzYW1wbGVyKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHN1cHBvcnQgc2FtcGxlIHRoZSBmaXJzdCBkaW0gbWFwcGVkIGZyb20gdmFsdWUgYXhpcy5cbiAgICAgICAgICAgIHNlcmllc01vZGVsLnNldERhdGEoZGF0YS5kb3duU2FtcGxlKGRhdGEubWFwRGltZW5zaW9uKHZhbHVlQXhpcy5kaW0pLCAxIC8gcmF0ZSwgc2FtcGxlciwgaW5kZXhTYW1wbGVyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogQW5pbWF0ZSBtdWx0aXBsZSBlbGVtZW50cyB3aXRoIGEgc2luZ2xlIGRvbmUtY2FsbGJhY2suXG4gKlxuICogQGV4YW1wbGVcbiAqICBhbmltYXRpb25cbiAqICAgICAgLmNyZWF0ZVdyYXAoKVxuICogICAgICAuYWRkKGVsMSwge3g6IDEwLCB5OiAxMH0pXG4gKiAgICAgIC5hZGQoZWwyLCB7c2hhcGU6IHt3aWR0aDogNTAwfSwgc3R5bGU6IHtmaWxsOiAncmVkJ319LCA0MDApXG4gKiAgICAgIC5kb25lKGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICogICAgICAuc3RhcnQoJ2N1YmljT3V0Jyk7XG4gKi9cbnZhciBBbmltYXRpb25XcmFwID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5pbWF0aW9uV3JhcCgpIHtcbiAgICB0aGlzLl9zdG9yYWdlID0gW107XG4gICAgdGhpcy5fZWxFeGlzdHNNYXAgPSB7fTtcbiAgfVxuICAvKipcbiAgICogQ2F1dGlvbjogYSBlbCBjYW4gb25seSBiZSBhZGRlZCBvbmNlLCBvdGhlcndpc2UgJ2RvbmUnXG4gICAqIG1pZ2h0IG5vdCBiZSBjYWxsZWQuIFRoaXMgbWV0aG9kIGNoZWNrcyB0aGlzIChieSBlbC5pZCksXG4gICAqIHN1cHByZXNzZXMgYWRkaW5nIGFuZCByZXR1cm5zIGZhbHNlIHdoZW4gZXhpc3RpbmcgZWwgZm91bmQuXG4gICAqXG4gICAqIEByZXR1cm4gV2hldGhlciBhZGRpbmcgc3VjY2VlZGVkLlxuICAgKi9cblxuXG4gIEFuaW1hdGlvbldyYXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChlbCwgdGFyZ2V0LCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZykge1xuICAgIGlmICh0aGlzLl9lbEV4aXN0c01hcFtlbC5pZF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbEV4aXN0c01hcFtlbC5pZF0gPSB0cnVlO1xuXG4gICAgdGhpcy5fc3RvcmFnZS5wdXNoKHtcbiAgICAgIGVsOiBlbCxcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgZWFzaW5nOiBlYXNpbmdcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvKipcbiAgICogT25seSBleGVjdXRlIHdoZW4gYW5pbWF0aW9uIGRvbmUvYWJvcnRlZC5cbiAgICovXG5cblxuICBBbmltYXRpb25XcmFwLnByb3RvdHlwZS5maW5pc2hlZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMuX2ZpbmlzaGVkQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFdpbGwgc3RvcCBleGlzdCBhbmltYXRpb24gZmlyc3RseS5cbiAgICovXG5cblxuICBBbmltYXRpb25XcmFwLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGNvdW50ID0gdGhpcy5fc3RvcmFnZS5sZW5ndGg7XG5cbiAgICB2YXIgY2hlY2tUZXJtaW5hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudC0tO1xuXG4gICAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgICAvLyBHdWFyZC5cbiAgICAgICAgX3RoaXMuX3N0b3JhZ2UubGVuZ3RoID0gMDtcbiAgICAgICAgX3RoaXMuX2VsRXhpc3RzTWFwID0ge307XG4gICAgICAgIF90aGlzLl9maW5pc2hlZENhbGxiYWNrICYmIF90aGlzLl9maW5pc2hlZENhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9zdG9yYWdlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMuX3N0b3JhZ2VbaV07XG4gICAgICBpdGVtLmVsLmFuaW1hdGVUbyhpdGVtLnRhcmdldCwge1xuICAgICAgICBkdXJhdGlvbjogaXRlbS5kdXJhdGlvbixcbiAgICAgICAgZGVsYXk6IGl0ZW0uZGVsYXksXG4gICAgICAgIGVhc2luZzogaXRlbS5lYXNpbmcsXG4gICAgICAgIHNldFRvRmluYWw6IHRydWUsXG4gICAgICAgIGRvbmU6IGNoZWNrVGVybWluYXRlLFxuICAgICAgICBhYm9ydGVkOiBjaGVja1Rlcm1pbmF0ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEFuaW1hdGlvbldyYXA7XG59KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVXcmFwKCkge1xuICByZXR1cm4gbmV3IEFuaW1hdGlvbldyYXAoKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vZ3JhcGhpYyc7XG4vKipcbiAqIFNhdXNhZ2U6IHNpbWlsYXIgdG8gc2VjdG9yLCBidXQgaGF2ZSBoYWxmIGNpcmNsZSBvbiBib3RoIHNpZGVzXG4gKi9cblxudmFyIFNhdXNhZ2VTaGFwZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNhdXNhZ2VTaGFwZSgpIHtcbiAgICB0aGlzLmN4ID0gMDtcbiAgICB0aGlzLmN5ID0gMDtcbiAgICB0aGlzLnIwID0gMDtcbiAgICB0aGlzLnIgPSAwO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IDA7XG4gICAgdGhpcy5lbmRBbmdsZSA9IE1hdGguUEkgKiAyO1xuICAgIHRoaXMuY2xvY2t3aXNlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBTYXVzYWdlU2hhcGU7XG59KCk7XG5cbnZhciBTYXVzYWdlUGF0aCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTYXVzYWdlUGF0aCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTYXVzYWdlUGF0aChvcHRzKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSAnc2F1c2FnZSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU2F1c2FnZVBhdGgucHJvdG90eXBlLmdldERlZmF1bHRTaGFwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNhdXNhZ2VTaGFwZSgpO1xuICB9O1xuXG4gIFNhdXNhZ2VQYXRoLnByb3RvdHlwZS5idWlsZFBhdGggPSBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICB2YXIgcjAgPSBNYXRoLm1heChzaGFwZS5yMCB8fCAwLCAwKTtcbiAgICB2YXIgciA9IE1hdGgubWF4KHNoYXBlLnIsIDApO1xuICAgIHZhciBkciA9IChyIC0gcjApICogMC41O1xuICAgIHZhciByQ2VudGVyID0gcjAgKyBkcjtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgdmFyIGVuZEFuZ2xlID0gc2hhcGUuZW5kQW5nbGU7XG4gICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcbiAgICB2YXIgdW5pdFN0YXJ0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIHZhciB1bml0U3RhcnRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgdmFyIHVuaXRFbmRYID0gTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgIHZhciB1bml0RW5kWSA9IE1hdGguc2luKGVuZEFuZ2xlKTtcbiAgICB2YXIgbGVzc1RoYW5DaXJjbGUgPSBjbG9ja3dpc2UgPyBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPCBNYXRoLlBJICogMiA6IHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSA8IE1hdGguUEkgKiAyO1xuXG4gICAgaWYgKGxlc3NUaGFuQ2lyY2xlKSB7XG4gICAgICBjdHgubW92ZVRvKHVuaXRTdGFydFggKiByMCArIHgsIHVuaXRTdGFydFkgKiByMCArIHkpO1xuICAgICAgY3R4LmFyYyh1bml0U3RhcnRYICogckNlbnRlciArIHgsIHVuaXRTdGFydFkgKiByQ2VudGVyICsgeSwgZHIsIC1NYXRoLlBJICsgc3RhcnRBbmdsZSwgc3RhcnRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gICAgfVxuXG4gICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gICAgY3R4Lm1vdmVUbyh1bml0RW5kWCAqIHIgKyB4LCB1bml0RW5kWSAqIHIgKyB5KTtcbiAgICBjdHguYXJjKHVuaXRFbmRYICogckNlbnRlciArIHgsIHVuaXRFbmRZICogckNlbnRlciArIHksIGRyLCBlbmRBbmdsZSAtIE1hdGguUEkgKiAyLCBlbmRBbmdsZSAtIE1hdGguUEksICFjbG9ja3dpc2UpO1xuXG4gICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICBjdHguYXJjKHgsIHksIHIwLCBlbmRBbmdsZSwgc3RhcnRBbmdsZSwgY2xvY2t3aXNlKTtcbiAgICAgIGN0eC5tb3ZlVG8odW5pdFN0YXJ0WCAqIHIwICsgeCwgdW5pdEVuZFkgKiByMCArIHkpO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgfTtcblxuICByZXR1cm4gU2F1c2FnZVBhdGg7XG59KFBhdGgpO1xuXG5leHBvcnQgZGVmYXVsdCBTYXVzYWdlUGF0aDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG4vKiBnbG9iYWwgRmxvYXQzMkFycmF5ICovXG5cbnZhciBzdXBwb3J0RmxvYXQzMkFycmF5ID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgRmxvYXQzMkFycmF5Q3RvciA9ICFzdXBwb3J0RmxvYXQzMkFycmF5ID8gQXJyYXkgOiBGbG9hdDMyQXJyYXk7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRmxvYXQzMkFycmF5KGFyZykge1xuICBpZiAoaXNBcnJheShhcmcpKSB7XG4gICAgLy8gUmV0dXJuIHNlbGYgZGlyZWN0bHkgaWYgZG9uJ3Qgc3VwcG9ydCBUeXBlZEFycmF5LlxuICAgIHJldHVybiBzdXBwb3J0RmxvYXQzMkFycmF5ID8gbmV3IEZsb2F0MzJBcnJheShhcmcpIDogYXJnO1xuICB9IC8vIEVsc2UgaXMgbnVtYmVyXG5cblxuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheUN0b3IoYXJnKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIExlZ2VuZFZpc3VhbFByb3ZpZGVyIGlzIGFuIGJyaWRnZSB0aGF0IHBpY2sgZW5jb2RlZCBjb2xvciBmcm9tIGRhdGEgYW5kXG4gKiBwcm92aWRlIHRvIHRoZSBsZWdlbmQgY29tcG9uZW50LlxuICovXG52YXIgTGVnZW5kVmlzdWFsUHJvdmlkZXIgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMZWdlbmRWaXN1YWxQcm92aWRlciggLy8gRnVuY3Rpb24gdG8gZ2V0IGRhdGEgYWZ0ZXIgZmlsdGVyZWQuIEl0IHN0b3JlcyBhbGwgdGhlIGVuY29kaW5nIGluZm9cbiAgZ2V0RGF0YVdpdGhFbmNvZGVkVmlzdWFsLCAvLyBGdW5jdGlvbiB0byBnZXQgcmF3IGRhdGEgYmVmb3JlIGZpbHRlcmVkLlxuICBnZXRSYXdEYXRhKSB7XG4gICAgdGhpcy5fZ2V0RGF0YVdpdGhFbmNvZGVkVmlzdWFsID0gZ2V0RGF0YVdpdGhFbmNvZGVkVmlzdWFsO1xuICAgIHRoaXMuX2dldFJhd0RhdGEgPSBnZXRSYXdEYXRhO1xuICB9XG5cbiAgTGVnZW5kVmlzdWFsUHJvdmlkZXIucHJvdG90eXBlLmdldEFsbE5hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByYXdEYXRhID0gdGhpcy5fZ2V0UmF3RGF0YSgpOyAvLyBXZSBmaW5kIHRoZSBuYW1lIGZyb20gdGhlIHJhdyBkYXRhLiBJbiBjYXNlIGl0J3MgZmlsdGVyZWQgYnkgdGhlIGxlZ2VuZCBjb21wb25lbnQuXG4gICAgLy8gTm9ybWFsbHksIHRoZSBuYW1lIGNhbiBiZSBmb3VuZCBpbiByYXdEYXRhLCBidXQgY2FuJ3QgYmUgZm91bmQgaW4gZmlsdGVyZWQgZGF0YSB3aWxsIGRpc3BsYXkgYXMgZ3JheS5cblxuXG4gICAgcmV0dXJuIHJhd0RhdGEubWFwQXJyYXkocmF3RGF0YS5nZXROYW1lKTtcbiAgfTtcblxuICBMZWdlbmRWaXN1YWxQcm92aWRlci5wcm90b3R5cGUuY29udGFpbk5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciByYXdEYXRhID0gdGhpcy5fZ2V0UmF3RGF0YSgpO1xuXG4gICAgcmV0dXJuIHJhd0RhdGEuaW5kZXhPZk5hbWUobmFtZSkgPj0gMDtcbiAgfTtcblxuICBMZWdlbmRWaXN1YWxQcm92aWRlci5wcm90b3R5cGUuaW5kZXhPZk5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIC8vIE9ubHkgZ2V0IGRhdGEgd2hlbiBuZWNlc3NhcnkuXG4gICAgLy8gQmVjYXVzZSBMZWdlbmRWaXN1YWxQcm92aWRlciBjb25zdHJ1Y3RvciBtYXkgYmUgbmV3IGluIHRoZSBzdGFnZSB0aGF0IGRhdGEgaXMgbm90IHByZXBhcmVkIHlldC5cbiAgICAvLyBJbnZva2luZyBTZXJpZXMjZ2V0RGF0YSBpbW1lZGlhdGVseSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIHZhciBkYXRhV2l0aEVuY29kZWRWaXN1YWwgPSB0aGlzLl9nZXREYXRhV2l0aEVuY29kZWRWaXN1YWwoKTtcblxuICAgIHJldHVybiBkYXRhV2l0aEVuY29kZWRWaXN1YWwuaW5kZXhPZk5hbWUobmFtZSk7XG4gIH07XG5cbiAgTGVnZW5kVmlzdWFsUHJvdmlkZXIucHJvdG90eXBlLmdldEl0ZW1WaXN1YWwgPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBrZXkpIHtcbiAgICAvLyBHZXQgZW5jb2RlZCB2aXN1YWwgcHJvcGVydGllcyBmcm9tIGZpbmFsIGZpbHRlcmVkIGRhdGEuXG4gICAgdmFyIGRhdGFXaXRoRW5jb2RlZFZpc3VhbCA9IHRoaXMuX2dldERhdGFXaXRoRW5jb2RlZFZpc3VhbCgpO1xuXG4gICAgcmV0dXJuIGRhdGFXaXRoRW5jb2RlZFZpc3VhbC5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwga2V5KTtcbiAgfTtcblxuICByZXR1cm4gTGVnZW5kVmlzdWFsUHJvdmlkZXI7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IExlZ2VuZFZpc3VhbFByb3ZpZGVyOyIsImltcG9ydCBQYXRoUHJveHkgZnJvbSAnLi4vY29yZS9QYXRoUHJveHknO1xuaW1wb3J0IHsgY3ViaWNTdWJkaXZpZGUgfSBmcm9tICcuLi9jb3JlL2N1cnZlJztcbmltcG9ydCB7IGRlZmF1bHRzLCBhc3NlcnQsIG5vb3AsIGNsb25lIH0gZnJvbSAnLi4vY29yZS91dGlsJztcbmltcG9ydCB7IGxlcnAgfSBmcm9tICcuLi9jb3JlL3ZlY3Rvcic7XG5pbXBvcnQgUmVjdCBmcm9tICcuLi9ncmFwaGljL3NoYXBlL1JlY3QnO1xuaW1wb3J0IFNlY3RvciBmcm9tICcuLi9ncmFwaGljL3NoYXBlL1NlY3Rvcic7XG52YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbnZhciBQUk9QX1hZID0gWyd4JywgJ3knXTtcbnZhciBQUk9QX1dIID0gWyd3aWR0aCcsICdoZWlnaHQnXTtcbnZhciB0bXBBcnIgPSBbXTtcbmZ1bmN0aW9uIGFyb3VuZEVxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgMWUtNTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXRoVG9CZXppZXJDdXJ2ZXMocGF0aCkge1xuICAgIHZhciBkYXRhID0gcGF0aC5kYXRhO1xuICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgIHZhciBiZXppZXJBcnJheSA9IFtdO1xuICAgIHZhciBjdXJyZW50U3VicGF0aDtcbiAgICB2YXIgeGkgPSAwO1xuICAgIHZhciB5aSA9IDA7XG4gICAgdmFyIHgwID0gMDtcbiAgICB2YXIgeTAgPSAwO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU5ld1N1YnBhdGgoeCwgeSkge1xuICAgICAgICBpZiAoY3VycmVudFN1YnBhdGggJiYgY3VycmVudFN1YnBhdGgubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgYmV6aWVyQXJyYXkucHVzaChjdXJyZW50U3VicGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFN1YnBhdGggPSBbeCwgeV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZExpbmUoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgaWYgKCEoYXJvdW5kRXF1YWwoeDAsIHgxKSAmJiBhcm91bmRFcXVhbCh5MCwgeTEpKSkge1xuICAgICAgICAgICAgY3VycmVudFN1YnBhdGgucHVzaCh4MCwgeTAsIHgxLCB5MSwgeDEsIHkxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRBcmMoc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGN4LCBjeSwgcngsIHJ5KSB7XG4gICAgICAgIHZhciBkZWx0YSA9IE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLnRhbihkZWx0YSAvIDQpICogNCAvIDM7XG4gICAgICAgIHZhciBkaXIgPSBlbmRBbmdsZSA8IHN0YXJ0QW5nbGUgPyAtMSA6IDE7XG4gICAgICAgIHZhciBjMSA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgICAgICB2YXIgczEgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICAgICAgdmFyIGMyID0gTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgICAgICB2YXIgczIgPSBNYXRoLnNpbihlbmRBbmdsZSk7XG4gICAgICAgIHZhciB4MSA9IGMxICogcnggKyBjeDtcbiAgICAgICAgdmFyIHkxID0gczEgKiByeSArIGN5O1xuICAgICAgICB2YXIgeDQgPSBjMiAqIHJ4ICsgY3g7XG4gICAgICAgIHZhciB5NCA9IHMyICogcnkgKyBjeTtcbiAgICAgICAgdmFyIGh4ID0gcnggKiBsZW4gKiBkaXI7XG4gICAgICAgIHZhciBoeSA9IHJ5ICogbGVuICogZGlyO1xuICAgICAgICBjdXJyZW50U3VicGF0aC5wdXNoKHgxIC0gaHggKiBzMSwgeTEgKyBoeSAqIGMxLCB4NCArIGh4ICogczIsIHk0IC0gaHkgKiBjMiwgeDQsIHk0KTtcbiAgICB9XG4gICAgdmFyIHgxO1xuICAgIHZhciB5MTtcbiAgICB2YXIgeDI7XG4gICAgdmFyIHkyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgaXNGaXJzdCA9IGkgPT09IDE7XG4gICAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgICAgICB4aSA9IGRhdGFbaV07XG4gICAgICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgIHkwID0geWk7XG4gICAgICAgICAgICBpZiAoY21kID09PSBDTUQuTCB8fCBjbWQgPT09IENNRC5DIHx8IGNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3VicGF0aCA9IFt4MCwgeTBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgICAgICAgIHhpID0geDAgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgeWkgPSB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICBjcmVhdGVOZXdTdWJwYXRoKHgwLCB5MCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgICAgICAgIHgxID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHkxID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIGFkZExpbmUoeGksIHlpLCB4MSwgeTEpO1xuICAgICAgICAgICAgICAgIHhpID0geDE7XG4gICAgICAgICAgICAgICAgeWkgPSB5MTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgY3VycmVudFN1YnBhdGgucHVzaChkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIHhpID0gZGF0YVtpKytdLCB5aSA9IGRhdGFbaSsrXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgIHgxID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHkxID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHgyID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHkyID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTdWJwYXRoLnB1c2goeGkgKyAyIC8gMyAqICh4MSAtIHhpKSwgeWkgKyAyIC8gMyAqICh5MSAtIHlpKSwgeDIgKyAyIC8gMyAqICh4MSAtIHgyKSwgeTIgKyAyIC8gMyAqICh5MSAtIHkyKSwgeDIsIHkyKTtcbiAgICAgICAgICAgICAgICB4aSA9IHgyO1xuICAgICAgICAgICAgICAgIHlpID0geTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENNRC5BOlxuICAgICAgICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBkYXRhW2krK10gKyBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICB2YXIgYW50aWNsb2Nrd2lzZSA9ICFkYXRhW2krK107XG4gICAgICAgICAgICAgICAgeDEgPSBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgeTEgPSBNYXRoLnNpbihzdGFydEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlTmV3U3VicGF0aCh4MCwgeTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkTGluZSh4aSwgeWksIHgxLCB5MSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHhpID0gTWF0aC5jb3MoZW5kQW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICB5aSA9IE1hdGguc2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSAoYW50aWNsb2Nrd2lzZSA/IC0xIDogMSkgKiBNYXRoLlBJIC8gMjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhbmdsZSA9IHN0YXJ0QW5nbGU7IGFudGljbG9ja3dpc2UgPyBhbmdsZSA+IGVuZEFuZ2xlIDogYW5nbGUgPCBlbmRBbmdsZTsgYW5nbGUgKz0gc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dEFuZ2xlID0gYW50aWNsb2Nrd2lzZSA/IE1hdGgubWF4KGFuZ2xlICsgc3RlcCwgZW5kQW5nbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKGFuZ2xlICsgc3RlcCwgZW5kQW5nbGUpO1xuICAgICAgICAgICAgICAgICAgICBhZGRBcmMoYW5nbGUsIG5leHRBbmdsZSwgY3gsIGN5LCByeCwgcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgeDAgPSB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHgxID0geDAgKyBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgeTEgPSB5MCArIGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICBjcmVhdGVOZXdTdWJwYXRoKHgxLCB5MCk7XG4gICAgICAgICAgICAgICAgYWRkTGluZSh4MSwgeTAsIHgxLCB5MSk7XG4gICAgICAgICAgICAgICAgYWRkTGluZSh4MSwgeTEsIHgwLCB5MSk7XG4gICAgICAgICAgICAgICAgYWRkTGluZSh4MCwgeTEsIHgwLCB5MCk7XG4gICAgICAgICAgICAgICAgYWRkTGluZSh4MCwgeTAsIHgxLCB5MCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdWJwYXRoICYmIGFkZExpbmUoeGksIHlpLCB4MCwgeTApO1xuICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudFN1YnBhdGggJiYgY3VycmVudFN1YnBhdGgubGVuZ3RoID4gMikge1xuICAgICAgICBiZXppZXJBcnJheS5wdXNoKGN1cnJlbnRTdWJwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlemllckFycmF5O1xufVxuZnVuY3Rpb24gYWxpZ25TdWJwYXRoKHN1YnBhdGgxLCBzdWJwYXRoMikge1xuICAgIHZhciBsZW4xID0gc3VicGF0aDEubGVuZ3RoO1xuICAgIHZhciBsZW4yID0gc3VicGF0aDIubGVuZ3RoO1xuICAgIGlmIChsZW4xID09PSBsZW4yKSB7XG4gICAgICAgIHJldHVybiBbc3VicGF0aDEsIHN1YnBhdGgyXTtcbiAgICB9XG4gICAgdmFyIHNob3J0ZXJQYXRoID0gbGVuMSA8IGxlbjIgPyBzdWJwYXRoMSA6IHN1YnBhdGgyO1xuICAgIHZhciBzaG9ydGVyTGVuID0gTWF0aC5taW4obGVuMSwgbGVuMik7XG4gICAgdmFyIGRpZmYgPSBNYXRoLmFicyhsZW4yIC0gbGVuMSkgLyA2O1xuICAgIHZhciBzaG9ydGVyQmV6aWVyQ291bnQgPSAoc2hvcnRlckxlbiAtIDIpIC8gNjtcbiAgICB2YXIgZWFjaEN1cnZlU3ViRGl2Q291bnQgPSBNYXRoLmNlaWwoZGlmZiAvIHNob3J0ZXJCZXppZXJDb3VudCkgKyAxO1xuICAgIHZhciBuZXdTdWJwYXRoID0gW3Nob3J0ZXJQYXRoWzBdLCBzaG9ydGVyUGF0aFsxXV07XG4gICAgdmFyIHJlbWFpbmVkID0gZGlmZjtcbiAgICB2YXIgdG1wU2VnWCA9IFtdO1xuICAgIHZhciB0bXBTZWdZID0gW107XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBzaG9ydGVyTGVuOykge1xuICAgICAgICB2YXIgeDAgPSBzaG9ydGVyUGF0aFtpIC0gMl07XG4gICAgICAgIHZhciB5MCA9IHNob3J0ZXJQYXRoW2kgLSAxXTtcbiAgICAgICAgdmFyIHgxID0gc2hvcnRlclBhdGhbaSsrXTtcbiAgICAgICAgdmFyIHkxID0gc2hvcnRlclBhdGhbaSsrXTtcbiAgICAgICAgdmFyIHgyID0gc2hvcnRlclBhdGhbaSsrXTtcbiAgICAgICAgdmFyIHkyID0gc2hvcnRlclBhdGhbaSsrXTtcbiAgICAgICAgdmFyIHgzID0gc2hvcnRlclBhdGhbaSsrXTtcbiAgICAgICAgdmFyIHkzID0gc2hvcnRlclBhdGhbaSsrXTtcbiAgICAgICAgaWYgKHJlbWFpbmVkIDw9IDApIHtcbiAgICAgICAgICAgIG5ld1N1YnBhdGgucHVzaCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhY3R1YWxTdWJEaXZDb3VudCA9IE1hdGgubWluKHJlbWFpbmVkLCBlYWNoQ3VydmVTdWJEaXZDb3VudCAtIDEpICsgMTtcbiAgICAgICAgZm9yICh2YXIgayA9IDE7IGsgPD0gYWN0dWFsU3ViRGl2Q291bnQ7IGsrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBrIC8gYWN0dWFsU3ViRGl2Q291bnQ7XG4gICAgICAgICAgICBjdWJpY1N1YmRpdmlkZSh4MCwgeDEsIHgyLCB4MywgcCwgdG1wU2VnWCk7XG4gICAgICAgICAgICBjdWJpY1N1YmRpdmlkZSh5MCwgeTEsIHkyLCB5MywgcCwgdG1wU2VnWSk7XG4gICAgICAgICAgICB4MCA9IHRtcFNlZ1hbM107XG4gICAgICAgICAgICB5MCA9IHRtcFNlZ1lbM107XG4gICAgICAgICAgICBuZXdTdWJwYXRoLnB1c2godG1wU2VnWFsxXSwgdG1wU2VnWVsxXSwgdG1wU2VnWFsyXSwgdG1wU2VnWVsyXSwgeDAsIHkwKTtcbiAgICAgICAgICAgIHgxID0gdG1wU2VnWFs1XTtcbiAgICAgICAgICAgIHkxID0gdG1wU2VnWVs1XTtcbiAgICAgICAgICAgIHgyID0gdG1wU2VnWFs2XTtcbiAgICAgICAgICAgIHkyID0gdG1wU2VnWVs2XTtcbiAgICAgICAgfVxuICAgICAgICByZW1haW5lZCAtPSBhY3R1YWxTdWJEaXZDb3VudCAtIDE7XG4gICAgfVxuICAgIHJldHVybiBzaG9ydGVyUGF0aCA9PT0gc3VicGF0aDEgPyBbbmV3U3VicGF0aCwgc3VicGF0aDJdIDogW3N1YnBhdGgxLCBuZXdTdWJwYXRoXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN1YnBhdGgobGFzdFN1YnBhdGhTdWJwYXRoLCBvdGhlclN1YnBhdGgpIHtcbiAgICB2YXIgbGVuID0gbGFzdFN1YnBhdGhTdWJwYXRoLmxlbmd0aDtcbiAgICB2YXIgbGFzdFggPSBsYXN0U3VicGF0aFN1YnBhdGhbbGVuIC0gMl07XG4gICAgdmFyIGxhc3RZID0gbGFzdFN1YnBhdGhTdWJwYXRoW2xlbiAtIDFdO1xuICAgIHZhciBuZXdTdWJwYXRoID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlclN1YnBhdGgubGVuZ3RoOykge1xuICAgICAgICBuZXdTdWJwYXRoW2krK10gPSBsYXN0WDtcbiAgICAgICAgbmV3U3VicGF0aFtpKytdID0gbGFzdFk7XG4gICAgfVxuICAgIHJldHVybiBuZXdTdWJwYXRoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFsaWduQmV6aWVyQ3VydmVzKGFycmF5MSwgYXJyYXkyKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBsYXN0U3VicGF0aDE7XG4gICAgdmFyIGxhc3RTdWJwYXRoMjtcbiAgICB2YXIgbmV3QXJyYXkxID0gW107XG4gICAgdmFyIG5ld0FycmF5MiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5tYXgoYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCk7IGkrKykge1xuICAgICAgICB2YXIgc3VicGF0aDEgPSBhcnJheTFbaV07XG4gICAgICAgIHZhciBzdWJwYXRoMiA9IGFycmF5MltpXTtcbiAgICAgICAgdmFyIG5ld1N1YnBhdGgxID0gdm9pZCAwO1xuICAgICAgICB2YXIgbmV3U3VicGF0aDIgPSB2b2lkIDA7XG4gICAgICAgIGlmICghc3VicGF0aDEpIHtcbiAgICAgICAgICAgIG5ld1N1YnBhdGgxID0gY3JlYXRlU3VicGF0aChsYXN0U3VicGF0aDEgfHwgc3VicGF0aDIsIHN1YnBhdGgyKTtcbiAgICAgICAgICAgIG5ld1N1YnBhdGgyID0gc3VicGF0aDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXN1YnBhdGgyKSB7XG4gICAgICAgICAgICBuZXdTdWJwYXRoMiA9IGNyZWF0ZVN1YnBhdGgobGFzdFN1YnBhdGgyIHx8IHN1YnBhdGgxLCBzdWJwYXRoMSk7XG4gICAgICAgICAgICBuZXdTdWJwYXRoMSA9IHN1YnBhdGgxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2EgPSBhbGlnblN1YnBhdGgoc3VicGF0aDEsIHN1YnBhdGgyKSwgbmV3U3VicGF0aDEgPSBfYVswXSwgbmV3U3VicGF0aDIgPSBfYVsxXTtcbiAgICAgICAgICAgIGxhc3RTdWJwYXRoMSA9IG5ld1N1YnBhdGgxO1xuICAgICAgICAgICAgbGFzdFN1YnBhdGgyID0gbmV3U3VicGF0aDI7XG4gICAgICAgIH1cbiAgICAgICAgbmV3QXJyYXkxLnB1c2gobmV3U3VicGF0aDEpO1xuICAgICAgICBuZXdBcnJheTIucHVzaChuZXdTdWJwYXRoMik7XG4gICAgfVxuICAgIHJldHVybiBbbmV3QXJyYXkxLCBuZXdBcnJheTJdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNlbnRyb2lkKGFycmF5KSB7XG4gICAgdmFyIHNpZ25lZEFyZWEgPSAwO1xuICAgIHZhciBjeCA9IDA7XG4gICAgdmFyIGN5ID0gMDtcbiAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gbGVuIC0gMjsgaSA8IGxlbjsgaiA9IGksIGkgKz0gMikge1xuICAgICAgICB2YXIgeDAgPSBhcnJheVtqXTtcbiAgICAgICAgdmFyIHkwID0gYXJyYXlbaiArIDFdO1xuICAgICAgICB2YXIgeDEgPSBhcnJheVtpXTtcbiAgICAgICAgdmFyIHkxID0gYXJyYXlbaSArIDFdO1xuICAgICAgICB2YXIgYSA9IHgwICogeTEgLSB4MSAqIHkwO1xuICAgICAgICBzaWduZWRBcmVhICs9IGE7XG4gICAgICAgIGN4ICs9ICh4MCArIHgxKSAqIGE7XG4gICAgICAgIGN5ICs9ICh5MCArIHkxKSAqIGE7XG4gICAgfVxuICAgIGlmIChzaWduZWRBcmVhID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbYXJyYXlbMF0gfHwgMCwgYXJyYXlbMV0gfHwgMF07XG4gICAgfVxuICAgIHJldHVybiBbY3ggLyBzaWduZWRBcmVhIC8gMywgY3kgLyBzaWduZWRBcmVhIC8gMywgc2lnbmVkQXJlYV07XG59XG5mdW5jdGlvbiBmaW5kQmVzdFJpbmdPZmZzZXQoZnJvbVN1YkJlemllcnMsIHRvU3ViQmV6aWVycywgZnJvbUNwLCB0b0NwKSB7XG4gICAgdmFyIGJlemllckNvdW50ID0gKGZyb21TdWJCZXppZXJzLmxlbmd0aCAtIDIpIC8gNjtcbiAgICB2YXIgYmVzdFNjb3JlID0gSW5maW5pdHk7XG4gICAgdmFyIGJlc3RPZmZzZXQgPSAwO1xuICAgIHZhciBsZW4gPSBmcm9tU3ViQmV6aWVycy5sZW5ndGg7XG4gICAgdmFyIGxlbjIgPSBsZW4gLSAyO1xuICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGJlemllckNvdW50OyBvZmZzZXQrKykge1xuICAgICAgICB2YXIgY3Vyc29yT2Zmc2V0ID0gb2Zmc2V0ICogNjtcbiAgICAgICAgdmFyIHNjb3JlID0gMDtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsZW47IGsgKz0gMikge1xuICAgICAgICAgICAgdmFyIGlkeCA9IGsgPT09IDAgPyBjdXJzb3JPZmZzZXQgOiAoKGN1cnNvck9mZnNldCArIGsgLSAyKSAlIGxlbjIgKyAyKTtcbiAgICAgICAgICAgIHZhciB4MCA9IGZyb21TdWJCZXppZXJzW2lkeF0gLSBmcm9tQ3BbMF07XG4gICAgICAgICAgICB2YXIgeTAgPSBmcm9tU3ViQmV6aWVyc1tpZHggKyAxXSAtIGZyb21DcFsxXTtcbiAgICAgICAgICAgIHZhciB4MSA9IHRvU3ViQmV6aWVyc1trXSAtIHRvQ3BbMF07XG4gICAgICAgICAgICB2YXIgeTEgPSB0b1N1YkJlemllcnNbayArIDFdIC0gdG9DcFsxXTtcbiAgICAgICAgICAgIHZhciBkeCA9IHgxIC0geDA7XG4gICAgICAgICAgICB2YXIgZHkgPSB5MSAtIHkwO1xuICAgICAgICAgICAgc2NvcmUgKz0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjb3JlIDwgYmVzdFNjb3JlKSB7XG4gICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgICAgIGJlc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJlc3RPZmZzZXQ7XG59XG5mdW5jdGlvbiByZXZlcnNlKGFycmF5KSB7XG4gICAgdmFyIG5ld0FyciA9IFtdO1xuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICBuZXdBcnJbaV0gPSBhcnJheVtsZW4gLSBpIC0gMl07XG4gICAgICAgIG5ld0FycltpICsgMV0gPSBhcnJheVtsZW4gLSBpIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnI7XG59XG5mdW5jdGlvbiBmaW5kQmVzdE1vcnBoaW5nUm90YXRpb24oZnJvbUFyciwgdG9BcnIsIHNlYXJjaEFuZ2xlSXRlcmF0aW9uLCBzZWFyY2hBbmdsZVJhbmdlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBmcm9tTmVlZHNSZXZlcnNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJvbUFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZnJvbVN1YnBhdGhCZXppZXIgPSBmcm9tQXJyW2ldO1xuICAgICAgICB2YXIgdG9TdWJwYXRoQmV6aWVyID0gdG9BcnJbaV07XG4gICAgICAgIHZhciBmcm9tQ3AgPSBjZW50cm9pZChmcm9tU3VicGF0aEJlemllcik7XG4gICAgICAgIHZhciB0b0NwID0gY2VudHJvaWQodG9TdWJwYXRoQmV6aWVyKTtcbiAgICAgICAgaWYgKGZyb21OZWVkc1JldmVyc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgZnJvbU5lZWRzUmV2ZXJzZSA9IGZyb21DcFsyXSA8IDAgIT09IHRvQ3BbMl0gPCAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdGcm9tU3VicGF0aEJlemllciA9IFtdO1xuICAgICAgICB2YXIgbmV3VG9TdWJwYXRoQmV6aWVyID0gW107XG4gICAgICAgIHZhciBiZXN0QW5nbGUgPSAwO1xuICAgICAgICB2YXIgYmVzdFNjb3JlID0gSW5maW5pdHk7XG4gICAgICAgIHZhciB0bXBBcnJfMSA9IFtdO1xuICAgICAgICB2YXIgbGVuID0gZnJvbVN1YnBhdGhCZXppZXIubGVuZ3RoO1xuICAgICAgICBpZiAoZnJvbU5lZWRzUmV2ZXJzZSkge1xuICAgICAgICAgICAgZnJvbVN1YnBhdGhCZXppZXIgPSByZXZlcnNlKGZyb21TdWJwYXRoQmV6aWVyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0ID0gZmluZEJlc3RSaW5nT2Zmc2V0KGZyb21TdWJwYXRoQmV6aWVyLCB0b1N1YnBhdGhCZXppZXIsIGZyb21DcCwgdG9DcCkgKiA2O1xuICAgICAgICB2YXIgbGVuMiA9IGxlbiAtIDI7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGVuMjsgayArPSAyKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gKG9mZnNldCArIGspICUgbGVuMiArIDI7XG4gICAgICAgICAgICBuZXdGcm9tU3VicGF0aEJlemllcltrICsgMl0gPSBmcm9tU3VicGF0aEJlemllcltpZHhdIC0gZnJvbUNwWzBdO1xuICAgICAgICAgICAgbmV3RnJvbVN1YnBhdGhCZXppZXJbayArIDNdID0gZnJvbVN1YnBhdGhCZXppZXJbaWR4ICsgMV0gLSBmcm9tQ3BbMV07XG4gICAgICAgIH1cbiAgICAgICAgbmV3RnJvbVN1YnBhdGhCZXppZXJbMF0gPSBmcm9tU3VicGF0aEJlemllcltvZmZzZXRdIC0gZnJvbUNwWzBdO1xuICAgICAgICBuZXdGcm9tU3VicGF0aEJlemllclsxXSA9IGZyb21TdWJwYXRoQmV6aWVyW29mZnNldCArIDFdIC0gZnJvbUNwWzFdO1xuICAgICAgICBpZiAoc2VhcmNoQW5nbGVJdGVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IHNlYXJjaEFuZ2xlUmFuZ2UgLyBzZWFyY2hBbmdsZUl0ZXJhdGlvbjtcbiAgICAgICAgICAgIGZvciAodmFyIGFuZ2xlID0gLXNlYXJjaEFuZ2xlUmFuZ2UgLyAyOyBhbmdsZSA8PSBzZWFyY2hBbmdsZVJhbmdlIC8gMjsgYW5nbGUgKz0gc3RlcCkge1xuICAgICAgICAgICAgICAgIHZhciBzYSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB2YXIgY2EgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgICAgICAgdmFyIHNjb3JlID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGZyb21TdWJwYXRoQmV6aWVyLmxlbmd0aDsgayArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MCA9IG5ld0Zyb21TdWJwYXRoQmV6aWVyW2tdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTAgPSBuZXdGcm9tU3VicGF0aEJlemllcltrICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IHRvU3VicGF0aEJlemllcltrXSAtIHRvQ3BbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IHRvU3VicGF0aEJlemllcltrICsgMV0gLSB0b0NwWzFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3WDEgPSB4MSAqIGNhIC0geTEgKiBzYTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1kxID0geDEgKiBzYSArIHkxICogY2E7XG4gICAgICAgICAgICAgICAgICAgIHRtcEFycl8xW2tdID0gbmV3WDE7XG4gICAgICAgICAgICAgICAgICAgIHRtcEFycl8xW2sgKyAxXSA9IG5ld1kxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBuZXdYMSAtIHgwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSBuZXdZMSAtIHkwO1xuICAgICAgICAgICAgICAgICAgICBzY29yZSArPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjb3JlIDwgYmVzdFNjb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgICAgICAgICBiZXN0QW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCB0bXBBcnJfMS5sZW5ndGg7IG0rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VG9TdWJwYXRoQmV6aWVyW21dID0gdG1wQXJyXzFbbV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpXzEgPSAwOyBpXzEgPCBsZW47IGlfMSArPSAyKSB7XG4gICAgICAgICAgICAgICAgbmV3VG9TdWJwYXRoQmV6aWVyW2lfMV0gPSB0b1N1YnBhdGhCZXppZXJbaV8xXSAtIHRvQ3BbMF07XG4gICAgICAgICAgICAgICAgbmV3VG9TdWJwYXRoQmV6aWVyW2lfMSArIDFdID0gdG9TdWJwYXRoQmV6aWVyW2lfMSArIDFdIC0gdG9DcFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBmcm9tOiBuZXdGcm9tU3VicGF0aEJlemllcixcbiAgICAgICAgICAgIHRvOiBuZXdUb1N1YnBhdGhCZXppZXIsXG4gICAgICAgICAgICBmcm9tQ3A6IGZyb21DcCxcbiAgICAgICAgICAgIHRvQ3A6IHRvQ3AsXG4gICAgICAgICAgICByb3RhdGlvbjogLWJlc3RBbmdsZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtb3JwaFBhdGgoZnJvbVBhdGgsIHRvUGF0aCwgYW5pbWF0aW9uT3B0cykge1xuICAgIHZhciBmcm9tUGF0aFByb3h5O1xuICAgIHZhciB0b1BhdGhQcm94eTtcbiAgICBpZiAoIWZyb21QYXRoIHx8ICF0b1BhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRvUGF0aDtcbiAgICB9XG4gICAgIWZyb21QYXRoLnBhdGggJiYgZnJvbVBhdGguY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgZnJvbVBhdGhQcm94eSA9IGZyb21QYXRoLnBhdGg7XG4gICAgZnJvbVBhdGhQcm94eS5iZWdpblBhdGgoKTtcbiAgICBmcm9tUGF0aC5idWlsZFBhdGgoZnJvbVBhdGhQcm94eSwgZnJvbVBhdGguc2hhcGUpO1xuICAgICF0b1BhdGgucGF0aCAmJiB0b1BhdGguY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgdG9QYXRoUHJveHkgPSB0b1BhdGgucGF0aDtcbiAgICB0b1BhdGhQcm94eSA9PT0gZnJvbVBhdGhQcm94eSAmJiAodG9QYXRoUHJveHkgPSBuZXcgUGF0aFByb3h5KGZhbHNlKSk7XG4gICAgdG9QYXRoUHJveHkuYmVnaW5QYXRoKCk7XG4gICAgaWYgKGlzSW5kaXZpZHVhbE1vcnBoaW5nUGF0aCh0b1BhdGgpKSB7XG4gICAgICAgIHRvUGF0aC5fX29sZEJ1aWxkUGF0aCh0b1BhdGhQcm94eSwgdG9QYXRoLnNoYXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRvUGF0aC5idWlsZFBhdGgodG9QYXRoUHJveHksIHRvUGF0aC5zaGFwZSk7XG4gICAgfVxuICAgIHZhciBfYSA9IGFsaWduQmV6aWVyQ3VydmVzKHBhdGhUb0JlemllckN1cnZlcyhmcm9tUGF0aFByb3h5KSwgcGF0aFRvQmV6aWVyQ3VydmVzKHRvUGF0aFByb3h5KSksIGZyb21CZXppZXJDdXJ2ZXMgPSBfYVswXSwgdG9CZXppZXJDdXJ2ZXMgPSBfYVsxXTtcbiAgICB2YXIgbW9ycGhpbmdEYXRhID0gZmluZEJlc3RNb3JwaGluZ1JvdGF0aW9uKGZyb21CZXppZXJDdXJ2ZXMsIHRvQmV6aWVyQ3VydmVzLCAxMCwgTWF0aC5QSSk7XG4gICAgYmVjb21lSW5kaXZpZHVhbE1vcnBoaW5nUGF0aCh0b1BhdGgsIG1vcnBoaW5nRGF0YSwgMCk7XG4gICAgdmFyIG9sZERvbmUgPSBhbmltYXRpb25PcHRzICYmIGFuaW1hdGlvbk9wdHMuZG9uZTtcbiAgICB2YXIgb2xkQWJvcnRlZCA9IGFuaW1hdGlvbk9wdHMgJiYgYW5pbWF0aW9uT3B0cy5hYm9ydGVkO1xuICAgIHZhciBvbGREdXJpbmcgPSBhbmltYXRpb25PcHRzICYmIGFuaW1hdGlvbk9wdHMuZHVyaW5nO1xuICAgIHRvUGF0aC5hbmltYXRlVG8oe1xuICAgICAgICBfX21vcnBoVDogMVxuICAgIH0sIGRlZmF1bHRzKHtcbiAgICAgICAgZHVyaW5nOiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgdG9QYXRoLmRpcnR5U2hhcGUoKTtcbiAgICAgICAgICAgIG9sZER1cmluZyAmJiBvbGREdXJpbmcocCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc3RvcmVJbmRpdmlkdWFsTW9ycGhpbmdQYXRoKHRvUGF0aCk7XG4gICAgICAgICAgICB0b1BhdGguY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgICAgICAgICB0b1BhdGguZGlydHlTaGFwZSgpO1xuICAgICAgICAgICAgb2xkRG9uZSAmJiBvbGREb25lKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFib3J0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9sZEFib3J0ZWQgJiYgb2xkQWJvcnRlZCgpO1xuICAgICAgICB9XG4gICAgfSwgYW5pbWF0aW9uT3B0cykpO1xuICAgIHJldHVybiB0b1BhdGg7XG59XG5mdW5jdGlvbiBtb3JwaGluZ1BhdGhCdWlsZFBhdGgocGF0aCkge1xuICAgIHZhciBtb3JwaGluZ0RhdGEgPSB0aGlzLl9fbW9ycGhpbmdEYXRhO1xuICAgIHZhciB0ID0gdGhpcy5fX21vcnBoVDtcbiAgICB2YXIgb25ldCA9IDEgLSB0O1xuICAgIHZhciBuZXdDcCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9ycGhpbmdEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gbW9ycGhpbmdEYXRhW2ldO1xuICAgICAgICB2YXIgZnJvbSA9IGl0ZW0uZnJvbTtcbiAgICAgICAgdmFyIHRvID0gaXRlbS50bztcbiAgICAgICAgdmFyIGFuZ2xlID0gaXRlbS5yb3RhdGlvbiAqIHQ7XG4gICAgICAgIHZhciBmcm9tQ3AgPSBpdGVtLmZyb21DcDtcbiAgICAgICAgdmFyIHRvQ3AgPSBpdGVtLnRvQ3A7XG4gICAgICAgIHZhciBzYSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdmFyIGNhID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBsZXJwKG5ld0NwLCBmcm9tQ3AsIHRvQ3AsIHQpO1xuICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IGZyb20ubGVuZ3RoOyBtICs9IDIpIHtcbiAgICAgICAgICAgIHZhciB4MCA9IGZyb21bbV07XG4gICAgICAgICAgICB2YXIgeTAgPSBmcm9tW20gKyAxXTtcbiAgICAgICAgICAgIHZhciB4MSA9IHRvW21dO1xuICAgICAgICAgICAgdmFyIHkxID0gdG9bbSArIDFdO1xuICAgICAgICAgICAgdmFyIHggPSB4MCAqIG9uZXQgKyB4MSAqIHQ7XG4gICAgICAgICAgICB2YXIgeSA9IHkwICogb25ldCArIHkxICogdDtcbiAgICAgICAgICAgIHRtcEFyclttXSA9ICh4ICogY2EgLSB5ICogc2EpICsgbmV3Q3BbMF07XG4gICAgICAgICAgICB0bXBBcnJbbSArIDFdID0gKHggKiBzYSArIHkgKiBjYSkgKyBuZXdDcFsxXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IGZyb20ubGVuZ3RoOykge1xuICAgICAgICAgICAgaWYgKG0gPT09IDApIHtcbiAgICAgICAgICAgICAgICBwYXRoLm1vdmVUbyh0bXBBcnJbbSsrXSwgdG1wQXJyW20rK10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKHRtcEFyclttKytdLCB0bXBBcnJbbSsrXSwgdG1wQXJyW20rK10sIHRtcEFyclttKytdLCB0bXBBcnJbbSsrXSwgdG1wQXJyW20rK10pO1xuICAgICAgICB9XG4gICAgfVxufVxuO1xuZnVuY3Rpb24gYmVjb21lSW5kaXZpZHVhbE1vcnBoaW5nUGF0aChwYXRoLCBtb3JwaGluZ0RhdGEsIG1vcnBoVCkge1xuICAgIGlmIChpc0luZGl2aWR1YWxNb3JwaGluZ1BhdGgocGF0aCkpIHtcbiAgICAgICAgdXBkYXRlSW5kaXZpZHVhbE1vcnBoaW5nUGF0aChwYXRoLCBtb3JwaGluZ0RhdGEsIG1vcnBoVCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG1vcnBoaW5nUGF0aCA9IHBhdGg7XG4gICAgbW9ycGhpbmdQYXRoLl9fb2xkQnVpbGRQYXRoID0gbW9ycGhpbmdQYXRoLmJ1aWxkUGF0aDtcbiAgICBtb3JwaGluZ1BhdGguYnVpbGRQYXRoID0gbW9ycGhpbmdQYXRoQnVpbGRQYXRoO1xuICAgIHVwZGF0ZUluZGl2aWR1YWxNb3JwaGluZ1BhdGgobW9ycGhpbmdQYXRoLCBtb3JwaGluZ0RhdGEsIG1vcnBoVCk7XG59XG5mdW5jdGlvbiB1cGRhdGVJbmRpdmlkdWFsTW9ycGhpbmdQYXRoKG1vcnBoaW5nUGF0aCwgbW9ycGhpbmdEYXRhLCBtb3JwaFQpIHtcbiAgICBtb3JwaGluZ1BhdGguX19tb3JwaGluZ0RhdGEgPSBtb3JwaGluZ0RhdGE7XG4gICAgbW9ycGhpbmdQYXRoLl9fbW9ycGhUID0gbW9ycGhUO1xufVxuZnVuY3Rpb24gcmVzdG9yZUluZGl2aWR1YWxNb3JwaGluZ1BhdGgocGF0aCkge1xuICAgIGlmIChpc0luZGl2aWR1YWxNb3JwaGluZ1BhdGgocGF0aCkpIHtcbiAgICAgICAgcGF0aC5idWlsZFBhdGggPSBwYXRoLl9fb2xkQnVpbGRQYXRoO1xuICAgICAgICBwYXRoLl9fb2xkQnVpbGRQYXRoID0gcGF0aC5fX21vcnBoaW5nRGF0YSA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNJbmRpdmlkdWFsTW9ycGhpbmdQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5fX29sZEJ1aWxkUGF0aCAhPSBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29tYmluaW5nUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuICEhcGF0aC5fX2NvbWJpbmluZ1N1Ykxpc3Q7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNJbkFueU1vcnBoaW5nKHBhdGgpIHtcbiAgICByZXR1cm4gaXNJbmRpdmlkdWFsTW9ycGhpbmdQYXRoKHBhdGgpIHx8IGlzQ29tYmluaW5nUGF0aChwYXRoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lKGZyb21QYXRoTGlzdCwgdG9QYXRoLCBhbmltYXRpb25PcHRzLCBjb3B5UHJvcHNJZkRpdmlkZWQpIHtcbiAgICB2YXIgZnJvbUluZGl2aWR1YWxzID0gW107XG4gICAgdmFyIHNlcGFyYXRlQ291bnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJvbVBhdGhMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmcm9tUGF0aCA9IGZyb21QYXRoTGlzdFtpXTtcbiAgICAgICAgaWYgKGlzQ29tYmluaW5nUGF0aChmcm9tUGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBmcm9tQ29tYmluaW5nU3ViTGlzdCA9IGZyb21QYXRoLl9fY29tYmluaW5nU3ViTGlzdDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZnJvbUNvbWJpbmluZ1N1Ykxpc3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBmcm9tSW5kaXZpZHVhbHMucHVzaChmcm9tQ29tYmluaW5nU3ViTGlzdFtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXBhcmF0ZUNvdW50ICs9IGZyb21Db21iaW5pbmdTdWJMaXN0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb21JbmRpdmlkdWFscy5wdXNoKGZyb21QYXRoKTtcbiAgICAgICAgICAgIHNlcGFyYXRlQ291bnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNlcGFyYXRlQ291bnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZGl2aWRpbmdNZXRob2QgPSBhbmltYXRpb25PcHRzID8gYW5pbWF0aW9uT3B0cy5kaXZpZGluZ01ldGhvZCA6IG51bGw7XG4gICAgdmFyIHRvUGF0aFNwbGl0dGVkTGlzdCA9IGRpdmlkZVNoYXBlKHRvUGF0aCwgc2VwYXJhdGVDb3VudCwgZGl2aWRpbmdNZXRob2QpO1xuICAgIGFzc2VydCh0b1BhdGhTcGxpdHRlZExpc3QubGVuZ3RoID09PSBzZXBhcmF0ZUNvdW50KTtcbiAgICB2YXIgb2xkRG9uZSA9IGFuaW1hdGlvbk9wdHMgJiYgYW5pbWF0aW9uT3B0cy5kb25lO1xuICAgIHZhciBvbGRBYm9ydGVkID0gYW5pbWF0aW9uT3B0cyAmJiBhbmltYXRpb25PcHRzLmFib3J0ZWQ7XG4gICAgdmFyIG9sZER1cmluZyA9IGFuaW1hdGlvbk9wdHMgJiYgYW5pbWF0aW9uT3B0cy5kdXJpbmc7XG4gICAgdmFyIGRvbmVDb3VudCA9IDA7XG4gICAgdmFyIGFib3J0ZWRDYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgbW9ycGhBbmltYXRpb25PcHRzID0gZGVmYXVsdHMoe1xuICAgICAgICBkdXJpbmc6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICBvbGREdXJpbmcgJiYgb2xkRHVyaW5nKHApO1xuICAgICAgICB9LFxuICAgICAgICBkb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkb25lQ291bnQrKztcbiAgICAgICAgICAgIGlmIChkb25lQ291bnQgPT09IHRvUGF0aFNwbGl0dGVkTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN0b3JlQ29tYmluaW5nUGF0aCh0b1BhdGgpO1xuICAgICAgICAgICAgICAgIG9sZERvbmUgJiYgb2xkRG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhYm9ydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWFib3J0ZWRDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICBhYm9ydGVkQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvbGRBYm9ydGVkICYmIG9sZEFib3J0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIGFuaW1hdGlvbk9wdHMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VwYXJhdGVDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBmcm9tID0gZnJvbUluZGl2aWR1YWxzW2ldO1xuICAgICAgICB2YXIgdG8gPSB0b1BhdGhTcGxpdHRlZExpc3RbaV07XG4gICAgICAgIGNvcHlQcm9wc0lmRGl2aWRlZCAmJiBjb3B5UHJvcHNJZkRpdmlkZWQodG9QYXRoLCB0bywgdHJ1ZSk7XG4gICAgICAgIG1vcnBoUGF0aChmcm9tLCB0bywgbW9ycGhBbmltYXRpb25PcHRzKTtcbiAgICB9XG4gICAgYmVjb21lQ29tYmluaW5nUGF0aCh0b1BhdGgsIHRvUGF0aFNwbGl0dGVkTGlzdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbUluZGl2aWR1YWxzOiBmcm9tSW5kaXZpZHVhbHMsXG4gICAgICAgIHRvSW5kaXZpZHVhbHM6IHRvUGF0aFNwbGl0dGVkTGlzdCxcbiAgICAgICAgY291bnQ6IHNlcGFyYXRlQ291bnRcbiAgICB9O1xufVxuZnVuY3Rpb24gYmVjb21lQ29tYmluaW5nUGF0aChwYXRoLCBjb21iaW5pbmdTdWJMaXN0KSB7XG4gICAgaWYgKGlzQ29tYmluaW5nUGF0aChwYXRoKSkge1xuICAgICAgICB1cGRhdGVDb21iaW5pbmdQYXRoU3ViTGlzdChwYXRoLCBjb21iaW5pbmdTdWJMaXN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY29tYmluaW5nUGF0aCA9IHBhdGg7XG4gICAgdXBkYXRlQ29tYmluaW5nUGF0aFN1Ykxpc3QoY29tYmluaW5nUGF0aCwgY29tYmluaW5nU3ViTGlzdCk7XG4gICAgY29tYmluaW5nUGF0aC5fX29sZEFkZFNlbGZUb1pyID0gcGF0aC5hZGRTZWxmVG9acjtcbiAgICBjb21iaW5pbmdQYXRoLl9fb2xkUmVtb3ZlU2VsZkZyb21aciA9IHBhdGgucmVtb3ZlU2VsZkZyb21acjtcbiAgICBjb21iaW5pbmdQYXRoLmFkZFNlbGZUb1pyID0gY29tYmluaW5nQWRkU2VsZlRvWnI7XG4gICAgY29tYmluaW5nUGF0aC5yZW1vdmVTZWxmRnJvbVpyID0gY29tYmluaW5nUmVtb3ZlU2VsZkZyb21acjtcbiAgICBjb21iaW5pbmdQYXRoLl9fb2xkQnVpbGRQYXRoID0gY29tYmluaW5nUGF0aC5idWlsZFBhdGg7XG4gICAgY29tYmluaW5nUGF0aC5idWlsZFBhdGggPSBub29wO1xuICAgIGNvbWJpbmluZ1BhdGguY2hpbGRyZW5SZWYgPSBjb21iaW5pbmdDaGlsZHJlblJlZjtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVDb21iaW5pbmdQYXRoKHBhdGgpIHtcbiAgICBpZiAoIWlzQ29tYmluaW5nUGF0aChwYXRoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb21iaW5pbmdQYXRoID0gcGF0aDtcbiAgICB1cGRhdGVDb21iaW5pbmdQYXRoU3ViTGlzdChjb21iaW5pbmdQYXRoLCBudWxsKTtcbiAgICBjb21iaW5pbmdQYXRoLmFkZFNlbGZUb1pyID0gY29tYmluaW5nUGF0aC5fX29sZEFkZFNlbGZUb1pyO1xuICAgIGNvbWJpbmluZ1BhdGgucmVtb3ZlU2VsZkZyb21aciA9IGNvbWJpbmluZ1BhdGguX19vbGRSZW1vdmVTZWxmRnJvbVpyO1xuICAgIGNvbWJpbmluZ1BhdGguYnVpbGRQYXRoID0gY29tYmluaW5nUGF0aC5fX29sZEJ1aWxkUGF0aDtcbiAgICBjb21iaW5pbmdQYXRoLmNoaWxkcmVuUmVmID1cbiAgICAgICAgY29tYmluaW5nUGF0aC5fX2NvbWJpbmluZ1N1Ykxpc3QgPVxuICAgICAgICAgICAgY29tYmluaW5nUGF0aC5fX29sZEFkZFNlbGZUb1pyID1cbiAgICAgICAgICAgICAgICBjb21iaW5pbmdQYXRoLl9fb2xkUmVtb3ZlU2VsZkZyb21aciA9XG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmluZ1BhdGguX19vbGRCdWlsZFBhdGggPSBudWxsO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29tYmluaW5nUGF0aFN1Ykxpc3QoY29tYmluaW5nUGF0aCwgY29tYmluaW5nU3ViTGlzdCkge1xuICAgIGlmIChjb21iaW5pbmdQYXRoLl9fY29tYmluaW5nU3ViTGlzdCAhPT0gY29tYmluaW5nU3ViTGlzdCkge1xuICAgICAgICBjb21iaW5pbmdQYXRoU3ViTGlzdEFkZFJlbW92ZVdpdGhacihjb21iaW5pbmdQYXRoLCAncmVtb3ZlU2VsZkZyb21acicpO1xuICAgICAgICBjb21iaW5pbmdQYXRoLl9fY29tYmluaW5nU3ViTGlzdCA9IGNvbWJpbmluZ1N1Ykxpc3Q7XG4gICAgICAgIGlmIChjb21iaW5pbmdTdWJMaXN0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbWJpbmluZ1N1Ykxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb21iaW5pbmdTdWJMaXN0W2ldLnBhcmVudCA9IGNvbWJpbmluZ1BhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29tYmluaW5nUGF0aFN1Ykxpc3RBZGRSZW1vdmVXaXRoWnIoY29tYmluaW5nUGF0aCwgJ2FkZFNlbGZUb1pyJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tYmluaW5nQWRkU2VsZlRvWnIoenIpIHtcbiAgICB0aGlzLl9fb2xkQWRkU2VsZlRvWnIoenIpO1xuICAgIGNvbWJpbmluZ1BhdGhTdWJMaXN0QWRkUmVtb3ZlV2l0aFpyKHRoaXMsICdhZGRTZWxmVG9acicpO1xufVxuZnVuY3Rpb24gY29tYmluaW5nUGF0aFN1Ykxpc3RBZGRSZW1vdmVXaXRoWnIocGF0aCwgbWV0aG9kKSB7XG4gICAgdmFyIGNvbWJpbmluZ1N1Ykxpc3QgPSBwYXRoLl9fY29tYmluaW5nU3ViTGlzdDtcbiAgICB2YXIgenIgPSBwYXRoLl9fenI7XG4gICAgaWYgKGNvbWJpbmluZ1N1Ykxpc3QgJiYgenIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21iaW5pbmdTdWJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjb21iaW5pbmdTdWJMaXN0W2ldO1xuICAgICAgICAgICAgY2hpbGRbbWV0aG9kXSh6cik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21iaW5pbmdSZW1vdmVTZWxmRnJvbVpyKHpyKSB7XG4gICAgdGhpcy5fX29sZFJlbW92ZVNlbGZGcm9tWnIoenIpO1xuICAgIHZhciBjb21iaW5pbmdTdWJMaXN0ID0gdGhpcy5fX2NvbWJpbmluZ1N1Ykxpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21iaW5pbmdTdWJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNvbWJpbmluZ1N1Ykxpc3RbaV07XG4gICAgICAgIGNoaWxkLnJlbW92ZVNlbGZGcm9tWnIoenIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbWJpbmluZ0NoaWxkcmVuUmVmKCkge1xuICAgIHJldHVybiB0aGlzLl9fY29tYmluaW5nU3ViTGlzdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXBhcmF0ZShmcm9tUGF0aCwgdG9QYXRoTGlzdCwgYW5pbWF0aW9uT3B0cywgY29weVByb3BzSWZEaXZpZGVkKSB7XG4gICAgdmFyIHRvUGF0aExpc3RMZW4gPSB0b1BhdGhMaXN0Lmxlbmd0aDtcbiAgICB2YXIgZnJvbVBhdGhMaXN0O1xuICAgIHZhciBkaXZpZGluZ01ldGhvZCA9IGFuaW1hdGlvbk9wdHMgPyBhbmltYXRpb25PcHRzLmRpdmlkaW5nTWV0aG9kIDogbnVsbDtcbiAgICB2YXIgY29weVByb3BzID0gZmFsc2U7XG4gICAgaWYgKGlzQ29tYmluaW5nUGF0aChmcm9tUGF0aCkpIHtcbiAgICAgICAgdmFyIGZyb21Db21iaW5pbmdTdWJMaXN0ID0gZnJvbVBhdGguX19jb21iaW5pbmdTdWJMaXN0O1xuICAgICAgICBpZiAoZnJvbUNvbWJpbmluZ1N1Ykxpc3QubGVuZ3RoID09PSB0b1BhdGhMaXN0TGVuKSB7XG4gICAgICAgICAgICBmcm9tUGF0aExpc3QgPSBmcm9tQ29tYmluaW5nU3ViTGlzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb21QYXRoTGlzdCA9IGRpdmlkZVNoYXBlKGZyb21QYXRoLCB0b1BhdGhMaXN0TGVuLCBkaXZpZGluZ01ldGhvZCk7XG4gICAgICAgICAgICBjb3B5UHJvcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmcm9tUGF0aExpc3QgPSBkaXZpZGVTaGFwZShmcm9tUGF0aCwgdG9QYXRoTGlzdExlbiwgZGl2aWRpbmdNZXRob2QpO1xuICAgICAgICBjb3B5UHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgICBhc3NlcnQoZnJvbVBhdGhMaXN0Lmxlbmd0aCA9PT0gdG9QYXRoTGlzdExlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1BhdGhMaXN0TGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGNvcHlQcm9wcyAmJiBjb3B5UHJvcHNJZkRpdmlkZWQpIHtcbiAgICAgICAgICAgIGNvcHlQcm9wc0lmRGl2aWRlZChmcm9tUGF0aCwgZnJvbVBhdGhMaXN0W2ldLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9ycGhQYXRoKGZyb21QYXRoTGlzdFtpXSwgdG9QYXRoTGlzdFtpXSwgYW5pbWF0aW9uT3B0cyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21JbmRpdmlkdWFsczogZnJvbVBhdGhMaXN0LFxuICAgICAgICB0b0luZGl2aWR1YWxzOiB0b1BhdGhMaXN0LFxuICAgICAgICBjb3VudDogdG9QYXRoTGlzdExlblxuICAgIH07XG59XG5mdW5jdGlvbiBkaXZpZGVTaGFwZShwYXRoLCBzZXBhcmF0ZUNvdW50LCBkaXZpZGluZ01ldGhvZCkge1xuICAgIHJldHVybiBkaXZpZGluZ01ldGhvZCA9PT0gJ2R1cGxpY2F0ZSdcbiAgICAgICAgPyBkdXBsaWNhdGVTaGFwZShwYXRoLCBzZXBhcmF0ZUNvdW50KVxuICAgICAgICA6IHNwbGl0U2hhcGUocGF0aCwgc2VwYXJhdGVDb3VudCk7XG59XG5mdW5jdGlvbiBzcGxpdFNoYXBlKHBhdGgsIHNlcGFyYXRlQ291bnQpIHtcbiAgICB2YXIgcmVzdWx0UGF0aHMgPSBbXTtcbiAgICBpZiAoc2VwYXJhdGVDb3VudCA8PSAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRQYXRocztcbiAgICB9XG4gICAgaWYgKHNlcGFyYXRlQ291bnQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGR1cGxpY2F0ZVNoYXBlKHBhdGgsIHNlcGFyYXRlQ291bnQpO1xuICAgIH1cbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlY3QpIHtcbiAgICAgICAgdmFyIHRvUGF0aFNoYXBlID0gcGF0aC5zaGFwZTtcbiAgICAgICAgdmFyIHNwbGl0UHJvcElkeCA9IHRvUGF0aFNoYXBlLmhlaWdodCA+IHRvUGF0aFNoYXBlLndpZHRoID8gMSA6IDA7XG4gICAgICAgIHZhciBwcm9wV0ggPSBQUk9QX1dIW3NwbGl0UHJvcElkeF07XG4gICAgICAgIHZhciBwcm9wWFkgPSBQUk9QX1hZW3NwbGl0UHJvcElkeF07XG4gICAgICAgIHZhciBzdWJXSCA9IHRvUGF0aFNoYXBlW3Byb3BXSF0gLyBzZXBhcmF0ZUNvdW50O1xuICAgICAgICB2YXIgeHlDdXJyID0gdG9QYXRoU2hhcGVbcHJvcFhZXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXBhcmF0ZUNvdW50OyBpKyssIHh5Q3VyciArPSBzdWJXSCkge1xuICAgICAgICAgICAgdmFyIHN1YlNoYXBlID0ge1xuICAgICAgICAgICAgICAgIHg6IHRvUGF0aFNoYXBlLngsXG4gICAgICAgICAgICAgICAgeTogdG9QYXRoU2hhcGUueSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdG9QYXRoU2hhcGUud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0b1BhdGhTaGFwZS5oZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdWJTaGFwZVtwcm9wWFldID0geHlDdXJyO1xuICAgICAgICAgICAgc3ViU2hhcGVbcHJvcFdIXSA9IGkgPCBzZXBhcmF0ZUNvdW50IC0gMVxuICAgICAgICAgICAgICAgID8gc3ViV0hcbiAgICAgICAgICAgICAgICA6IHRvUGF0aFNoYXBlW3Byb3BYWV0gKyB0b1BhdGhTaGFwZVtwcm9wV0hdIC0geHlDdXJyO1xuICAgICAgICAgICAgdmFyIHNwbGl0dGVkID0gbmV3IFJlY3QoeyBzaGFwZTogc3ViU2hhcGUgfSk7XG4gICAgICAgICAgICByZXN1bHRQYXRocy5wdXNoKHNwbGl0dGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwYXRoIGluc3RhbmNlb2YgU2VjdG9yKSB7XG4gICAgICAgIHZhciB0b1BhdGhTaGFwZSA9IHBhdGguc2hhcGU7XG4gICAgICAgIHZhciBjbG9ja3dpc2UgPSB0b1BhdGhTaGFwZS5jbG9ja3dpc2U7XG4gICAgICAgIHZhciBzdGFydEFuZ2xlID0gdG9QYXRoU2hhcGUuc3RhcnRBbmdsZTtcbiAgICAgICAgdmFyIGVuZEFuZ2xlID0gdG9QYXRoU2hhcGUuZW5kQW5nbGU7XG4gICAgICAgIHZhciBlbmRBbmdsZU5vcm1hbGl6ZWQgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSwgdG9QYXRoU2hhcGUuZW5kQW5nbGUsIGNsb2Nrd2lzZSk7XG4gICAgICAgIHZhciBzdGVwID0gKGVuZEFuZ2xlTm9ybWFsaXplZCAtIHN0YXJ0QW5nbGUpIC8gc2VwYXJhdGVDb3VudDtcbiAgICAgICAgdmFyIGFuZ2xlQ3VyciA9IHN0YXJ0QW5nbGU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VwYXJhdGVDb3VudDsgaSsrLCBhbmdsZUN1cnIgKz0gc3RlcCkge1xuICAgICAgICAgICAgdmFyIHNwbGl0dGVkID0gbmV3IFNlY3Rvcih7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgY3g6IHRvUGF0aFNoYXBlLmN4LFxuICAgICAgICAgICAgICAgICAgICBjeTogdG9QYXRoU2hhcGUuY3ksXG4gICAgICAgICAgICAgICAgICAgIHI6IHRvUGF0aFNoYXBlLnIsXG4gICAgICAgICAgICAgICAgICAgIHIwOiB0b1BhdGhTaGFwZS5yMCxcbiAgICAgICAgICAgICAgICAgICAgY2xvY2t3aXNlOiBjbG9ja3dpc2UsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IGFuZ2xlQ3VycixcbiAgICAgICAgICAgICAgICAgICAgZW5kQW5nbGU6IGkgPT09IHNlcGFyYXRlQ291bnQgLSAxID8gZW5kQW5nbGUgOiBhbmdsZUN1cnIgKyBzdGVwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHRQYXRocy5wdXNoKHNwbGl0dGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGR1cGxpY2F0ZVNoYXBlKHBhdGgsIHNlcGFyYXRlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0UGF0aHM7XG59XG5mdW5jdGlvbiBkdXBsaWNhdGVTaGFwZShwYXRoLCBzZXBhcmF0ZUNvdW50KSB7XG4gICAgdmFyIHJlc3VsdFBhdGhzID0gW107XG4gICAgaWYgKHNlcGFyYXRlQ291bnQgPD0gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0UGF0aHM7XG4gICAgfVxuICAgIHZhciBjdG9yID0gcGF0aC5jb25zdHJ1Y3RvcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcGFyYXRlQ291bnQ7IGkrKykge1xuICAgICAgICB2YXIgc3ViID0gbmV3IGN0b3Ioe1xuICAgICAgICAgICAgc2hhcGU6IGNsb25lKHBhdGguc2hhcGUpXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHRQYXRocy5wdXNoKHN1Yik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRQYXRocztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhZGlhbihzdGFydCwgZW5kLCBjbG9ja3dpc2UpIHtcbiAgICByZXR1cm4gZW5kICsgUEkyICogKE1hdGhbY2xvY2t3aXNlID8gJ2NlaWwnIDogJ2Zsb29yJ10oKHN0YXJ0IC0gZW5kKSAvIFBJMikpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==