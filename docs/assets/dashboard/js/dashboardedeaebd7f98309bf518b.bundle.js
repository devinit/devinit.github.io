(self["webpackChunkdi_website"] = self["webpackChunkdi_website"] || []).push([["vendors-node_modules_echarts_components_js"],{

/***/ "./node_modules/echarts/components.js":
/*!********************************************!*\
  !*** ./node_modules/echarts/components.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AriaComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.AriaComponent),
/* harmony export */   "AxisPointerComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.AxisPointerComponent),
/* harmony export */   "BrushComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.BrushComponent),
/* harmony export */   "CalendarComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.CalendarComponent),
/* harmony export */   "DataZoomComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.DataZoomComponent),
/* harmony export */   "DataZoomInsideComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.DataZoomInsideComponent),
/* harmony export */   "DataZoomSliderComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.DataZoomSliderComponent),
/* harmony export */   "DatasetComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.DatasetComponent),
/* harmony export */   "GeoComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.GeoComponent),
/* harmony export */   "GraphicComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.GraphicComponent),
/* harmony export */   "GridComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.GridComponent),
/* harmony export */   "GridSimpleComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.GridSimpleComponent),
/* harmony export */   "LegendComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.LegendComponent),
/* harmony export */   "LegendPlainComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.LegendPlainComponent),
/* harmony export */   "LegendScrollComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.LegendScrollComponent),
/* harmony export */   "MarkAreaComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.MarkAreaComponent),
/* harmony export */   "MarkLineComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.MarkLineComponent),
/* harmony export */   "MarkPointComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.MarkPointComponent),
/* harmony export */   "ParallelComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.ParallelComponent),
/* harmony export */   "PolarComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.PolarComponent),
/* harmony export */   "RadarComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.RadarComponent),
/* harmony export */   "SingleAxisComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.SingleAxisComponent),
/* harmony export */   "TimelineComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.TimelineComponent),
/* harmony export */   "TitleComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.TitleComponent),
/* harmony export */   "ToolboxComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.ToolboxComponent),
/* harmony export */   "TooltipComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.TooltipComponent),
/* harmony export */   "TransformComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.TransformComponent),
/* harmony export */   "VisualMapComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.VisualMapComponent),
/* harmony export */   "VisualMapContinuousComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.VisualMapContinuousComponent),
/* harmony export */   "VisualMapPiecewiseComponent": () => (/* reexport safe */ _lib_export_components__WEBPACK_IMPORTED_MODULE_0__.VisualMapPiecewiseComponent)
/* harmony export */ });
/* harmony import */ var _lib_export_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/export/components */ "./node_modules/echarts/lib/export/components.js");
/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



/***/ }),

/***/ "./node_modules/echarts/lib/component/aria/install.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/component/aria/install.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _visual_aria__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../visual/aria */ "./node_modules/echarts/lib/visual/aria.js");
/* harmony import */ var _preprocessor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./preprocessor */ "./node_modules/echarts/lib/component/aria/preprocessor.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function install(registers) {
  registers.registerPreprocessor(_preprocessor__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerVisual(registers.PRIORITY.VISUAL.ARIA, _visual_aria__WEBPACK_IMPORTED_MODULE_1__.default);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/aria/preprocessor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/aria/preprocessor.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ariaPreprocessor)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

function ariaPreprocessor(option) {
  if (!option || !option.aria) {
    return;
  }

  var aria = option.aria; // aria.show is deprecated and should use aria.enabled instead

  if (aria.show != null) {
    aria.enabled = aria.show;
  }

  aria.label = aria.label || {}; // move description, general, series, data to be under aria.label

  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(['description', 'general', 'series', 'data'], function (name) {
    if (aria[name] != null) {
      aria.label[name] = aria[name];
    }
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/AngleAxisView.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axis/AngleAxisView.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Circle.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Ring.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Line.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Sector.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../model/Model */ "./node_modules/echarts/lib/model/Model.js");
/* harmony import */ var _AxisView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AxisView */ "./node_modules/echarts/lib/component/axis/AxisView.js");
/* harmony import */ var _AxisBuilder__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./AxisBuilder */ "./node_modules/echarts/lib/component/axis/AxisBuilder.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








var elementList = ['axisLine', 'axisLabel', 'axisTick', 'minorTick', 'splitLine', 'minorSplitLine', 'splitArea'];

function getAxisLineShape(polar, rExtent, angle) {
  rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());
  var start = polar.coordToPoint([rExtent[0], angle]);
  var end = polar.coordToPoint([rExtent[1], angle]);
  return {
    x1: start[0],
    y1: start[1],
    x2: end[0],
    y2: end[1]
  };
}

function getRadiusIdx(polar) {
  var radiusAxis = polar.getRadiusAxis();
  return radiusAxis.inverse ? 0 : 1;
} // Remove the last tick which will overlap the first tick


function fixAngleOverlap(list) {
  var firstItem = list[0];
  var lastItem = list[list.length - 1];

  if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {
    list.pop();
  }
}

var AngleAxisView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(AngleAxisView, _super);

  function AngleAxisView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = AngleAxisView.type;
    _this.axisPointerClass = 'PolarAxisPointer';
    return _this;
  }

  AngleAxisView.prototype.render = function (angleAxisModel, ecModel) {
    this.group.removeAll();

    if (!angleAxisModel.get('show')) {
      return;
    }

    var angleAxis = angleAxisModel.axis;
    var polar = angleAxis.polar;
    var radiusExtent = polar.getRadiusAxis().getExtent();
    var ticksAngles = angleAxis.getTicksCoords();
    var minorTickAngles = angleAxis.getMinorTicksCoords();
    var labels = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map(angleAxis.getViewLabels(), function (labelItem) {
      labelItem = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone(labelItem);
      var scale = angleAxis.scale;
      var tickValue = scale.type === 'ordinal' ? scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
      labelItem.coord = angleAxis.dataToCoord(tickValue);
      return labelItem;
    });
    fixAngleOverlap(labels);
    fixAngleOverlap(ticksAngles);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(elementList, function (name) {
      if (angleAxisModel.get([name, 'show']) && (!angleAxis.scale.isBlank() || name === 'axisLine')) {
        angelAxisElementsBuilders[name](this.group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels);
      }
    }, this);
  };

  AngleAxisView.type = 'angleAxis';
  return AngleAxisView;
}(_AxisView__WEBPACK_IMPORTED_MODULE_2__.default);

var angelAxisElementsBuilders = {
  axisLine: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    var lineStyleModel = angleAxisModel.getModel(['axisLine', 'lineStyle']); // extent id of the axis radius (r0 and r)

    var rId = getRadiusIdx(polar);
    var r0Id = rId ? 0 : 1;
    var shape;

    if (radiusExtent[r0Id] === 0) {
      shape = new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: radiusExtent[rId]
        },
        style: lineStyleModel.getLineStyle(),
        z2: 1,
        silent: true
      });
    } else {
      shape = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: radiusExtent[rId],
          r0: radiusExtent[r0Id]
        },
        style: lineStyleModel.getLineStyle(),
        z2: 1,
        silent: true
      });
    }

    shape.style.fill = null;
    group.add(shape);
  },
  axisTick: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    var tickModel = angleAxisModel.getModel('axisTick');
    var tickLen = (tickModel.get('inside') ? -1 : 1) * tickModel.get('length');
    var radius = radiusExtent[getRadiusIdx(polar)];
    var lines = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map(ticksAngles, function (tickAngleItem) {
      return new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default({
        shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord)
      });
    });
    group.add(_util_graphic__WEBPACK_IMPORTED_MODULE_6__.mergePath(lines, {
      style: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults(tickModel.getModel('lineStyle').getLineStyle(), {
        stroke: angleAxisModel.get(['axisLine', 'lineStyle', 'color'])
      })
    }));
  },
  minorTick: function (group, angleAxisModel, polar, tickAngles, minorTickAngles, radiusExtent) {
    if (!minorTickAngles.length) {
      return;
    }

    var tickModel = angleAxisModel.getModel('axisTick');
    var minorTickModel = angleAxisModel.getModel('minorTick');
    var tickLen = (tickModel.get('inside') ? -1 : 1) * minorTickModel.get('length');
    var radius = radiusExtent[getRadiusIdx(polar)];
    var lines = [];

    for (var i = 0; i < minorTickAngles.length; i++) {
      for (var k = 0; k < minorTickAngles[i].length; k++) {
        lines.push(new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default({
          shape: getAxisLineShape(polar, [radius, radius + tickLen], minorTickAngles[i][k].coord)
        }));
      }
    }

    group.add(_util_graphic__WEBPACK_IMPORTED_MODULE_6__.mergePath(lines, {
      style: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults(minorTickModel.getModel('lineStyle').getLineStyle(), zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults(tickModel.getLineStyle(), {
        stroke: angleAxisModel.get(['axisLine', 'lineStyle', 'color'])
      }))
    }));
  },
  axisLabel: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels) {
    var rawCategoryData = angleAxisModel.getCategories(true);
    var commonLabelModel = angleAxisModel.getModel('axisLabel');
    var labelMargin = commonLabelModel.get('margin');
    var triggerEvent = angleAxisModel.get('triggerEvent'); // Use length of ticksAngles because it may remove the last tick to avoid overlapping

    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(labels, function (labelItem, idx) {
      var labelModel = commonLabelModel;
      var tickValue = labelItem.tickValue;
      var r = radiusExtent[getRadiusIdx(polar)];
      var p = polar.coordToPoint([r + labelMargin, labelItem.coord]);
      var cx = polar.cx;
      var cy = polar.cy;
      var labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? 'center' : p[0] > cx ? 'left' : 'right';
      var labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3 ? 'middle' : p[1] > cy ? 'top' : 'bottom';

      if (rawCategoryData && rawCategoryData[tickValue]) {
        var rawCategoryItem = rawCategoryData[tickValue];

        if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isObject(rawCategoryItem) && rawCategoryItem.textStyle) {
          labelModel = new _model_Model__WEBPACK_IMPORTED_MODULE_7__.default(rawCategoryItem.textStyle, commonLabelModel, commonLabelModel.ecModel);
        }
      }

      var textEl = new _util_graphic__WEBPACK_IMPORTED_MODULE_8__.default({
        silent: _AxisBuilder__WEBPACK_IMPORTED_MODULE_9__.default.isLabelSilent(angleAxisModel),
        style: (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_10__.createTextStyle)(labelModel, {
          x: p[0],
          y: p[1],
          fill: labelModel.getTextColor() || angleAxisModel.get(['axisLine', 'lineStyle', 'color']),
          text: labelItem.formattedLabel,
          align: labelTextAlign,
          verticalAlign: labelTextVerticalAlign
        })
      });
      group.add(textEl); // Pack data for mouse event

      if (triggerEvent) {
        var eventData = _AxisBuilder__WEBPACK_IMPORTED_MODULE_9__.default.makeAxisEventDataBase(angleAxisModel);
        eventData.targetType = 'axisLabel';
        eventData.value = labelItem.rawLabel;
        (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_11__.getECData)(textEl).eventData = eventData;
      }
    }, this);
  },
  splitLine: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    var splitLineModel = angleAxisModel.getModel('splitLine');
    var lineStyleModel = splitLineModel.getModel('lineStyle');
    var lineColors = lineStyleModel.get('color');
    var lineCount = 0;
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    var splitLines = [];

    for (var i = 0; i < ticksAngles.length; i++) {
      var colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default({
        shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord)
      }));
    } // Simple optimization
    // Batching the lines if color are the same


    for (var i = 0; i < splitLines.length; i++) {
      group.add(_util_graphic__WEBPACK_IMPORTED_MODULE_6__.mergePath(splitLines[i], {
        style: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults({
          stroke: lineColors[i % lineColors.length]
        }, lineStyleModel.getLineStyle()),
        silent: true,
        z: angleAxisModel.get('z')
      }));
    }
  },
  minorSplitLine: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    if (!minorTickAngles.length) {
      return;
    }

    var minorSplitLineModel = angleAxisModel.getModel('minorSplitLine');
    var lineStyleModel = minorSplitLineModel.getModel('lineStyle');
    var lines = [];

    for (var i = 0; i < minorTickAngles.length; i++) {
      for (var k = 0; k < minorTickAngles[i].length; k++) {
        lines.push(new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default({
          shape: getAxisLineShape(polar, radiusExtent, minorTickAngles[i][k].coord)
        }));
      }
    }

    group.add(_util_graphic__WEBPACK_IMPORTED_MODULE_6__.mergePath(lines, {
      style: lineStyleModel.getLineStyle(),
      silent: true,
      z: angleAxisModel.get('z')
    }));
  },
  splitArea: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    if (!ticksAngles.length) {
      return;
    }

    var splitAreaModel = angleAxisModel.getModel('splitArea');
    var areaStyleModel = splitAreaModel.getModel('areaStyle');
    var areaColors = areaStyleModel.get('color');
    var lineCount = 0;
    areaColors = areaColors instanceof Array ? areaColors : [areaColors];
    var splitAreas = [];
    var RADIAN = Math.PI / 180;
    var prevAngle = -ticksAngles[0].coord * RADIAN;
    var r0 = Math.min(radiusExtent[0], radiusExtent[1]);
    var r1 = Math.max(radiusExtent[0], radiusExtent[1]);
    var clockwise = angleAxisModel.get('clockwise');

    for (var i = 1, len = ticksAngles.length; i <= len; i++) {
      var coord = i === len ? ticksAngles[0].coord : ticksAngles[i].coord;
      var colorIndex = lineCount++ % areaColors.length;
      splitAreas[colorIndex] = splitAreas[colorIndex] || [];
      splitAreas[colorIndex].push(new _util_graphic__WEBPACK_IMPORTED_MODULE_12__.default({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r0: r0,
          r: r1,
          startAngle: prevAngle,
          endAngle: -coord * RADIAN,
          clockwise: clockwise
        },
        silent: true
      }));
      prevAngle = -coord * RADIAN;
    } // Simple optimization
    // Batching the lines if color are the same


    for (var i = 0; i < splitAreas.length; i++) {
      group.add(_util_graphic__WEBPACK_IMPORTED_MODULE_6__.mergePath(splitAreas[i], {
        style: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults({
          fill: areaColors[i % areaColors.length]
        }, areaStyleModel.getAreaStyle()),
        silent: true
      }));
    }
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AngleAxisView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/RadiusAxisView.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axis/RadiusAxisView.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Circle.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Sector.js");
/* harmony import */ var _AxisBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AxisBuilder */ "./node_modules/echarts/lib/component/axis/AxisBuilder.js");
/* harmony import */ var _AxisView__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AxisView */ "./node_modules/echarts/lib/component/axis/AxisView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];
var selfBuilderAttrs = ['splitLine', 'splitArea', 'minorSplitLine'];

var RadiusAxisView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(RadiusAxisView, _super);

  function RadiusAxisView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = RadiusAxisView.type;
    _this.axisPointerClass = 'PolarAxisPointer';
    return _this;
  }

  RadiusAxisView.prototype.render = function (radiusAxisModel, ecModel) {
    this.group.removeAll();

    if (!radiusAxisModel.get('show')) {
      return;
    }

    var oldAxisGroup = this._axisGroup;
    var newAxisGroup = this._axisGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_1__.default();
    this.group.add(newAxisGroup);
    var radiusAxis = radiusAxisModel.axis;
    var polar = radiusAxis.polar;
    var angleAxis = polar.getAngleAxis();
    var ticksCoords = radiusAxis.getTicksCoords();
    var minorTicksCoords = radiusAxis.getMinorTicksCoords();
    var axisAngle = angleAxis.getExtent()[0];
    var radiusExtent = radiusAxis.getExtent();
    var layout = layoutAxis(polar, radiusAxisModel, axisAngle);
    var axisBuilder = new _AxisBuilder__WEBPACK_IMPORTED_MODULE_2__.default(radiusAxisModel, layout);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
    newAxisGroup.add(axisBuilder.getGroup());
    _util_graphic__WEBPACK_IMPORTED_MODULE_4__.groupTransition(oldAxisGroup, newAxisGroup, radiusAxisModel);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.each(selfBuilderAttrs, function (name) {
      if (radiusAxisModel.get([name, 'show']) && !radiusAxis.scale.isBlank()) {
        axisElementBuilders[name](this.group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords);
      }
    }, this);
  };

  RadiusAxisView.type = 'radiusAxis';
  return RadiusAxisView;
}(_AxisView__WEBPACK_IMPORTED_MODULE_5__.default);

var axisElementBuilders = {
  splitLine: function (group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
    var splitLineModel = radiusAxisModel.getModel('splitLine');
    var lineStyleModel = splitLineModel.getModel('lineStyle');
    var lineColors = lineStyleModel.get('color');
    var lineCount = 0;
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    var splitLines = [];

    for (var i = 0; i < ticksCoords.length; i++) {
      var colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: ticksCoords[i].coord
        }
      }));
    } // Simple optimization
    // Batching the lines if color are the same


    for (var i = 0; i < splitLines.length; i++) {
      group.add(_util_graphic__WEBPACK_IMPORTED_MODULE_4__.mergePath(splitLines[i], {
        style: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.defaults({
          stroke: lineColors[i % lineColors.length],
          fill: null
        }, lineStyleModel.getLineStyle()),
        silent: true
      }));
    }
  },
  minorSplitLine: function (group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords) {
    if (!minorTicksCoords.length) {
      return;
    }

    var minorSplitLineModel = radiusAxisModel.getModel('minorSplitLine');
    var lineStyleModel = minorSplitLineModel.getModel('lineStyle');
    var lines = [];

    for (var i = 0; i < minorTicksCoords.length; i++) {
      for (var k = 0; k < minorTicksCoords[i].length; k++) {
        lines.push(new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r: minorTicksCoords[i][k].coord
          }
        }));
      }
    }

    group.add(_util_graphic__WEBPACK_IMPORTED_MODULE_4__.mergePath(lines, {
      style: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.defaults({
        fill: null
      }, lineStyleModel.getLineStyle()),
      silent: true
    }));
  },
  splitArea: function (group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
    if (!ticksCoords.length) {
      return;
    }

    var splitAreaModel = radiusAxisModel.getModel('splitArea');
    var areaStyleModel = splitAreaModel.getModel('areaStyle');
    var areaColors = areaStyleModel.get('color');
    var lineCount = 0;
    areaColors = areaColors instanceof Array ? areaColors : [areaColors];
    var splitAreas = [];
    var prevRadius = ticksCoords[0].coord;

    for (var i = 1; i < ticksCoords.length; i++) {
      var colorIndex = lineCount++ % areaColors.length;
      splitAreas[colorIndex] = splitAreas[colorIndex] || [];
      splitAreas[colorIndex].push(new _util_graphic__WEBPACK_IMPORTED_MODULE_7__.default({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r0: prevRadius,
          r: ticksCoords[i].coord,
          startAngle: 0,
          endAngle: Math.PI * 2
        },
        silent: true
      }));
      prevRadius = ticksCoords[i].coord;
    } // Simple optimization
    // Batching the lines if color are the same


    for (var i = 0; i < splitAreas.length; i++) {
      group.add(_util_graphic__WEBPACK_IMPORTED_MODULE_4__.mergePath(splitAreas[i], {
        style: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.defaults({
          fill: areaColors[i % areaColors.length]
        }, areaStyleModel.getAreaStyle()),
        silent: true
      }));
    }
  }
};
/**
 * @inner
 */

function layoutAxis(polar, radiusAxisModel, axisAngle) {
  return {
    position: [polar.cx, polar.cy],
    rotation: axisAngle / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: radiusAxisModel.getModel('axisLabel').get('rotate'),
    // Over splitLine and splitArea
    z2: 1
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadiusAxisView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/SingleAxisView.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axis/SingleAxisView.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _AxisBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AxisBuilder */ "./node_modules/echarts/lib/component/axis/AxisBuilder.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Line.js");
/* harmony import */ var _coord_single_singleAxisHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../coord/single/singleAxisHelper */ "./node_modules/echarts/lib/coord/single/singleAxisHelper.js");
/* harmony import */ var _AxisView__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./AxisView */ "./node_modules/echarts/lib/component/axis/AxisView.js");
/* harmony import */ var _axisSplitHelper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./axisSplitHelper */ "./node_modules/echarts/lib/component/axis/axisSplitHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];
var selfBuilderAttrs = ['splitArea', 'splitLine'];

var SingleAxisView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SingleAxisView, _super);

  function SingleAxisView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = SingleAxisView.type;
    _this.axisPointerClass = 'SingleAxisPointer';
    return _this;
  }

  SingleAxisView.prototype.render = function (axisModel, ecModel, api, payload) {
    var group = this.group;
    group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_1__.default();
    var layout = _coord_single_singleAxisHelper__WEBPACK_IMPORTED_MODULE_2__.layout(axisModel);
    var axisBuilder = new _AxisBuilder__WEBPACK_IMPORTED_MODULE_3__.default(axisModel, layout);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
    group.add(this._axisGroup);
    group.add(axisBuilder.getGroup());
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.each(selfBuilderAttrs, function (name) {
      if (axisModel.get([name, 'show'])) {
        axisElementBuilders[name](this, this.group, this._axisGroup, axisModel);
      }
    }, this);
    _util_graphic__WEBPACK_IMPORTED_MODULE_5__.groupTransition(oldAxisGroup, this._axisGroup, axisModel);

    _super.prototype.render.call(this, axisModel, ecModel, api, payload);
  };

  SingleAxisView.prototype.remove = function () {
    (0,_axisSplitHelper__WEBPACK_IMPORTED_MODULE_6__.rectCoordAxisHandleRemove)(this);
  };

  SingleAxisView.type = 'singleAxis';
  return SingleAxisView;
}(_AxisView__WEBPACK_IMPORTED_MODULE_7__.default);

var axisElementBuilders = {
  splitLine: function (axisView, group, axisGroup, axisModel) {
    var axis = axisModel.axis;

    if (axis.scale.isBlank()) {
      return;
    }

    var splitLineModel = axisModel.getModel('splitLine');
    var lineStyleModel = splitLineModel.getModel('lineStyle');
    var lineColors = lineStyleModel.get('color');
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    var gridRect = axisModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var splitLines = [];
    var lineCount = 0;
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitLineModel
    });
    var p1 = [];
    var p2 = [];

    for (var i = 0; i < ticksCoords.length; ++i) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);

      if (isHorizontal) {
        p1[0] = tickCoord;
        p1[1] = gridRect.y;
        p2[0] = tickCoord;
        p2[1] = gridRect.y + gridRect.height;
      } else {
        p1[0] = gridRect.x;
        p1[1] = tickCoord;
        p2[0] = gridRect.x + gridRect.width;
        p2[1] = tickCoord;
      }

      var colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(new _util_graphic__WEBPACK_IMPORTED_MODULE_8__.default({
        subPixelOptimize: true,
        shape: {
          x1: p1[0],
          y1: p1[1],
          x2: p2[0],
          y2: p2[1]
        },
        silent: true
      }));
    }

    var lineStyle = lineStyleModel.getLineStyle(['color']);

    for (var i = 0; i < splitLines.length; ++i) {
      group.add(_util_graphic__WEBPACK_IMPORTED_MODULE_5__.mergePath(splitLines[i], {
        style: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.defaults({
          stroke: lineColors[i % lineColors.length]
        }, lineStyle),
        silent: true
      }));
    }
  },
  splitArea: function (axisView, group, axisGroup, axisModel) {
    (0,_axisSplitHelper__WEBPACK_IMPORTED_MODULE_6__.rectCoordAxisBuildSplitArea)(axisView, axisGroup, axisModel, axisModel);
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SingleAxisView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js":
/*!****************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var AxisPointerModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(AxisPointerModel, _super);

  function AxisPointerModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = AxisPointerModel.type;
    return _this;
  }

  AxisPointerModel.type = 'axisPointer';
  AxisPointerModel.defaultOption = {
    // 'auto' means that show when triggered by tooltip or handle.
    show: 'auto',
    zlevel: 0,
    z: 50,
    type: 'line',
    // axispointer triggered by tootip determine snap automatically,
    // see `modelHelper`.
    snap: false,
    triggerTooltip: true,
    value: null,
    status: null,
    link: [],
    // Do not set 'auto' here, otherwise global animation: false
    // will not effect at this axispointer.
    animation: null,
    animationDurationUpdate: 200,
    lineStyle: {
      color: '#B9BEC9',
      width: 1,
      type: 'dashed'
    },
    shadowStyle: {
      color: 'rgba(210,219,238,0.2)'
    },
    label: {
      show: true,
      formatter: null,
      precision: 'auto',
      margin: 3,
      color: '#fff',
      padding: [5, 7, 5, 7],
      backgroundColor: 'auto',
      borderColor: null,
      borderWidth: 0,
      borderRadius: 3
    },
    handle: {
      show: false,
      // eslint-disable-next-line
      icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',
      size: 45,
      // handle margin is from symbol center to axis, which is stable when circular move.
      margin: 50,
      // color: '#1b8bbd'
      // color: '#2f4554'
      color: '#333',
      shadowBlur: 3,
      shadowColor: '#aaa',
      shadowOffsetX: 0,
      shadowOffsetY: 2,
      // For mobile performance
      throttle: 40
    }
  };
  return AxisPointerModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxisPointerModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/AxisPointerView.js":
/*!***************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axisPointer/AxisPointerView.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _globalListener__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globalListener */ "./node_modules/echarts/lib/component/axisPointer/globalListener.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var AxisPointerView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(AxisPointerView, _super);

  function AxisPointerView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = AxisPointerView.type;
    return _this;
  }

  AxisPointerView.prototype.render = function (globalAxisPointerModel, ecModel, api) {
    var globalTooltipModel = ecModel.getComponent('tooltip');
    var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click'; // Register global listener in AxisPointerView to enable
    // AxisPointerView to be independent to Tooltip.

    _globalListener__WEBPACK_IMPORTED_MODULE_1__.register('axisPointer', api, function (currTrigger, e, dispatchAction) {
      // If 'none', it is not controlled by mouse totally.
      if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {
        dispatchAction({
          type: 'updateAxisPointer',
          currTrigger: currTrigger,
          x: e && e.offsetX,
          y: e && e.offsetY
        });
      }
    });
  };

  AxisPointerView.prototype.remove = function (ecModel, api) {
    _globalListener__WEBPACK_IMPORTED_MODULE_1__.unregister('axisPointer', api);
  };

  AxisPointerView.prototype.dispose = function (ecModel, api) {
    _globalListener__WEBPACK_IMPORTED_MODULE_1__.unregister('axisPointer', api);
  };

  AxisPointerView.type = 'axisPointer';
  return AxisPointerView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_2__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxisPointerView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js":
/*!***************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _modelHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modelHelper */ "./node_modules/echarts/lib/component/axisPointer/modelHelper.js");
/* harmony import */ var zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zrender/lib/core/event */ "./node_modules/zrender/lib/core/event.js");
/* harmony import */ var _util_throttle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/throttle */ "./node_modules/echarts/lib/util/throttle.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();
var clone = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone;
var bind = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind;
/**
 * Base axis pointer class in 2D.
 */

var BaseAxisPointer =
/** @class */
function () {
  function BaseAxisPointer() {
    this._dragging = false;
    /**
     * In px, arbitrary value. Do not set too small,
     * no animation is ok for most cases.
     */

    this.animationThreshold = 15;
  }
  /**
   * @implement
   */


  BaseAxisPointer.prototype.render = function (axisModel, axisPointerModel, api, forceRender) {
    var value = axisPointerModel.get('value');
    var status = axisPointerModel.get('status'); // Bind them to `this`, not in closure, otherwise they will not
    // be replaced when user calling setOption in not merge mode.

    this._axisModel = axisModel;
    this._axisPointerModel = axisPointerModel;
    this._api = api; // Optimize: `render` will be called repeatly during mouse move.
    // So it is power consuming if performing `render` each time,
    // especially on mobile device.

    if (!forceRender && this._lastValue === value && this._lastStatus === status) {
      return;
    }

    this._lastValue = value;
    this._lastStatus = status;
    var group = this._group;
    var handle = this._handle;

    if (!status || status === 'hide') {
      // Do not clear here, for animation better.
      group && group.hide();
      handle && handle.hide();
      return;
    }

    group && group.show();
    handle && handle.show(); // Otherwise status is 'show'

    var elOption = {};
    this.makeElOption(elOption, value, axisModel, axisPointerModel, api); // Enable change axis pointer type.

    var graphicKey = elOption.graphicKey;

    if (graphicKey !== this._lastGraphicKey) {
      this.clear(api);
    }

    this._lastGraphicKey = graphicKey;
    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);

    if (!group) {
      group = this._group = new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default();
      this.createPointerEl(group, elOption, axisModel, axisPointerModel);
      this.createLabelEl(group, elOption, axisModel, axisPointerModel);
      api.getZr().add(group);
    } else {
      var doUpdateProps = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry(updateProps, axisPointerModel, moveAnimation);
      this.updatePointerEl(group, elOption, doUpdateProps);
      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
    }

    updateMandatoryProps(group, axisPointerModel, true);

    this._renderHandle(value);
  };
  /**
   * @implement
   */


  BaseAxisPointer.prototype.remove = function (api) {
    this.clear(api);
  };
  /**
   * @implement
   */


  BaseAxisPointer.prototype.dispose = function (api) {
    this.clear(api);
  };
  /**
   * @protected
   */


  BaseAxisPointer.prototype.determineAnimation = function (axisModel, axisPointerModel) {
    var animation = axisPointerModel.get('animation');
    var axis = axisModel.axis;
    var isCategoryAxis = axis.type === 'category';
    var useSnap = axisPointerModel.get('snap'); // Value axis without snap always do not snap.

    if (!useSnap && !isCategoryAxis) {
      return false;
    }

    if (animation === 'auto' || animation == null) {
      var animationThreshold = this.animationThreshold;

      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
        return true;
      } // It is important to auto animation when snap used. Consider if there is
      // a dataZoom, animation will be disabled when too many points exist, while
      // it will be enabled for better visual effect when little points exist.


      if (useSnap) {
        var seriesDataCount = _modelHelper__WEBPACK_IMPORTED_MODULE_3__.getAxisInfo(axisModel).seriesDataCount;
        var axisExtent = axis.getExtent(); // Approximate band width

        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
      }

      return false;
    }

    return animation === true;
  };
  /**
   * add {pointer, label, graphicKey} to elOption
   * @protected
   */


  BaseAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {// Shoule be implemenented by sub-class.
  };
  /**
   * @protected
   */


  BaseAxisPointer.prototype.createPointerEl = function (group, elOption, axisModel, axisPointerModel) {
    var pointerOption = elOption.pointer;

    if (pointerOption) {
      var pointerEl = inner(group).pointerEl = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__[pointerOption.type](clone(elOption.pointer));
      group.add(pointerEl);
    }
  };
  /**
   * @protected
   */


  BaseAxisPointer.prototype.createLabelEl = function (group, elOption, axisModel, axisPointerModel) {
    if (elOption.label) {
      var labelEl = inner(group).labelEl = new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default(clone(elOption.label));
      group.add(labelEl);
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  };
  /**
   * @protected
   */


  BaseAxisPointer.prototype.updatePointerEl = function (group, elOption, updateProps) {
    var pointerEl = inner(group).pointerEl;

    if (pointerEl && elOption.pointer) {
      pointerEl.setStyle(elOption.pointer.style);
      updateProps(pointerEl, {
        shape: elOption.pointer.shape
      });
    }
  };
  /**
   * @protected
   */


  BaseAxisPointer.prototype.updateLabelEl = function (group, elOption, updateProps, axisPointerModel) {
    var labelEl = inner(group).labelEl;

    if (labelEl) {
      labelEl.setStyle(elOption.label.style);
      updateProps(labelEl, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: elOption.label.x,
        y: elOption.label.y
      });
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  };
  /**
   * @private
   */


  BaseAxisPointer.prototype._renderHandle = function (value) {
    if (this._dragging || !this.updateHandleTransform) {
      return;
    }

    var axisPointerModel = this._axisPointerModel;

    var zr = this._api.getZr();

    var handle = this._handle;
    var handleModel = axisPointerModel.getModel('handle');
    var status = axisPointerModel.get('status');

    if (!handleModel.get('show') || !status || status === 'hide') {
      handle && zr.remove(handle);
      this._handle = null;
      return;
    }

    var isInit;

    if (!this._handle) {
      isInit = true;
      handle = this._handle = _util_graphic__WEBPACK_IMPORTED_MODULE_4__.createIcon(handleModel.get('icon'), {
        cursor: 'move',
        draggable: true,
        onmousemove: function (e) {
          // Fot mobile devicem, prevent screen slider on the button.
          zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_6__.stop(e.event);
        },
        onmousedown: bind(this._onHandleDragMove, this, 0, 0),
        drift: bind(this._onHandleDragMove, this),
        ondragend: bind(this._onHandleDragEnd, this)
      });
      zr.add(handle);
    }

    updateMandatoryProps(handle, axisPointerModel, false); // update style

    handle.setStyle(handleModel.getItemStyle(null, ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'])); // update position

    var handleSize = handleModel.get('size');

    if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(handleSize)) {
      handleSize = [handleSize, handleSize];
    }

    handle.scaleX = handleSize[0] / 2;
    handle.scaleY = handleSize[1] / 2;
    _util_throttle__WEBPACK_IMPORTED_MODULE_7__.createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');

    this._moveHandleToValue(value, isInit);
  };

  BaseAxisPointer.prototype._moveHandleToValue = function (value, isInit) {
    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
  };

  BaseAxisPointer.prototype._onHandleDragMove = function (dx, dy) {
    var handle = this._handle;

    if (!handle) {
      return;
    }

    this._dragging = true; // Persistent for throttle.

    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
    this._payloadInfo = trans;
    handle.stopAnimation();
    handle.attr(getHandleTransProps(trans));
    inner(handle).lastProp = null;

    this._doDispatchAxisPointer();
  };
  /**
   * Throttled method.
   */


  BaseAxisPointer.prototype._doDispatchAxisPointer = function () {
    var handle = this._handle;

    if (!handle) {
      return;
    }

    var payloadInfo = this._payloadInfo;
    var axisModel = this._axisModel;

    this._api.dispatchAction({
      type: 'updateAxisPointer',
      x: payloadInfo.cursorPoint[0],
      y: payloadInfo.cursorPoint[1],
      tooltipOption: payloadInfo.tooltipOption,
      axesInfo: [{
        axisDim: axisModel.axis.dim,
        axisIndex: axisModel.componentIndex
      }]
    });
  };

  BaseAxisPointer.prototype._onHandleDragEnd = function () {
    this._dragging = false;
    var handle = this._handle;

    if (!handle) {
      return;
    }

    var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with
    // axisPointer. So move handle to align the exact value position when
    // drag ended.


    this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle
    // button, and will be hidden after finger left handle button.


    this._api.dispatchAction({
      type: 'hideTip'
    });
  };
  /**
   * @private
   */


  BaseAxisPointer.prototype.clear = function (api) {
    this._lastValue = null;
    this._lastStatus = null;
    var zr = api.getZr();
    var group = this._group;
    var handle = this._handle;

    if (zr && group) {
      this._lastGraphicKey = null;
      group && zr.remove(group);
      handle && zr.remove(handle);
      this._group = null;
      this._handle = null;
      this._payloadInfo = null;
    }
  };
  /**
   * @protected
   */


  BaseAxisPointer.prototype.doClear = function () {// Implemented by sub-class if necessary.
  };

  BaseAxisPointer.prototype.buildLabel = function (xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  };

  return BaseAxisPointer;
}();

function updateProps(animationModel, moveAnimation, el, props) {
  // Animation optimize.
  if (!propsEqual(inner(el).lastProp, props)) {
    inner(el).lastProp = props;
    moveAnimation ? _util_graphic__WEBPACK_IMPORTED_MODULE_4__.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
  }
}

function propsEqual(lastProps, newProps) {
  if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isObject(lastProps) && zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isObject(newProps)) {
    var equals_1 = true;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(newProps, function (item, key) {
      equals_1 = equals_1 && propsEqual(lastProps[key], item);
    });
    return !!equals_1;
  } else {
    return lastProps === newProps;
  }
}

function updateLabelShowHide(labelEl, axisPointerModel) {
  labelEl[axisPointerModel.get(['label', 'show']) ? 'show' : 'hide']();
}

function getHandleTransProps(trans) {
  return {
    x: trans.x || 0,
    y: trans.y || 0,
    rotation: trans.rotation || 0
  };
}

function updateMandatoryProps(group, axisPointerModel, silent) {
  var z = axisPointerModel.get('z');
  var zlevel = axisPointerModel.get('zlevel');
  group && group.traverse(function (el) {
    if (el.type !== 'group') {
      z != null && (el.z = z);
      zlevel != null && (el.zlevel = zlevel);
      el.silent = silent;
    }
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseAxisPointer);

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _BaseAxisPointer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BaseAxisPointer */ "./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js");
/* harmony import */ var _viewHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewHelper */ "./node_modules/echarts/lib/component/axisPointer/viewHelper.js");
/* harmony import */ var _coord_cartesian_cartesianAxisHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../coord/cartesian/cartesianAxisHelper */ "./node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var CartesianAxisPointer =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(CartesianAxisPointer, _super);

  function CartesianAxisPointer() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * @override
   */


  CartesianAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisPointerType = axisPointerModel.get('type');
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));

    if (axisPointerType && axisPointerType !== 'none') {
      var elStyle = _viewHelper__WEBPACK_IMPORTED_MODULE_1__.buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }

    var layoutInfo = _coord_cartesian_cartesianAxisHelper__WEBPACK_IMPORTED_MODULE_2__.layout(grid.model, axisModel);
    _viewHelper__WEBPACK_IMPORTED_MODULE_1__.buildCartesianSingleLabelElOption( // @ts-ignore
    value, elOption, layoutInfo, axisModel, axisPointerModel, api);
  };
  /**
   * @override
   */


  CartesianAxisPointer.prototype.getHandleTransform = function (value, axisModel, axisPointerModel) {
    var layoutInfo = _coord_cartesian_cartesianAxisHelper__WEBPACK_IMPORTED_MODULE_2__.layout(axisModel.axis.grid.model, axisModel, {
      labelInside: false
    }); // @ts-ignore

    layoutInfo.labelMargin = axisPointerModel.get(['handle', 'margin']);
    var pos = _viewHelper__WEBPACK_IMPORTED_MODULE_1__.getTransformedPosition(axisModel.axis, value, layoutInfo);
    return {
      x: pos[0],
      y: pos[1],
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  };
  /**
   * @override
   */


  CartesianAxisPointer.prototype.updateHandleTransform = function (transform, delta, axisModel, axisPointerModel) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisExtent = axis.getGlobalExtent(true);
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var dimIndex = axis.dim === 'x' ? 0 : 1;
    var currPosition = [transform.x, transform.y];
    currPosition[dimIndex] += delta[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    var cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex]; // Make tooltip do not overlap axisPointer and in the middle of the grid.

    var tooltipOptions = [{
      verticalAlign: 'middle'
    }, {
      align: 'center'
    }];
    return {
      x: currPosition[0],
      y: currPosition[1],
      rotation: transform.rotation,
      cursorPoint: cursorPoint,
      tooltipOption: tooltipOptions[dimIndex]
    };
  };

  return CartesianAxisPointer;
}(_BaseAxisPointer__WEBPACK_IMPORTED_MODULE_3__.default);

function getCartesian(grid, axis) {
  var opt = {};
  opt[axis.dim + 'AxisIndex'] = axis.index;
  return grid.getCartesian(opt);
}

var pointerShapeBuilder = {
  line: function (axis, pixelValue, otherExtent) {
    var targetShape = _viewHelper__WEBPACK_IMPORTED_MODULE_1__.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
    return {
      type: 'Line',
      subPixelOptimize: true,
      shape: targetShape
    };
  },
  shadow: function (axis, pixelValue, otherExtent) {
    var bandWidth = Math.max(1, axis.getBandWidth());
    var span = otherExtent[1] - otherExtent[0];
    return {
      type: 'Rect',
      shape: _viewHelper__WEBPACK_IMPORTED_MODULE_1__.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
    };
  }
};

function getAxisDimIndex(axis) {
  return axis.dim === 'x' ? 0 : 1;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CartesianAxisPointer);

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/PolarAxisPointer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axisPointer/PolarAxisPointer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _BaseAxisPointer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseAxisPointer */ "./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _viewHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewHelper */ "./node_modules/echarts/lib/component/axisPointer/viewHelper.js");
/* harmony import */ var zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/matrix */ "./node_modules/zrender/lib/core/matrix.js");
/* harmony import */ var _axis_AxisBuilder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../axis/AxisBuilder */ "./node_modules/echarts/lib/component/axis/AxisBuilder.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







var PolarAxisPointer =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(PolarAxisPointer, _super);

  function PolarAxisPointer() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * @override
   */


  PolarAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;

    if (axis.dim === 'angle') {
      this.animationThreshold = Math.PI / 18;
    }

    var polar = axis.polar;
    var otherAxis = polar.getOtherAxis(axis);
    var otherExtent = otherAxis.getExtent();
    var coordValue = axis.dataToCoord(value);
    var axisPointerType = axisPointerModel.get('type');

    if (axisPointerType && axisPointerType !== 'none') {
      var elStyle = _viewHelper__WEBPACK_IMPORTED_MODULE_1__.buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder[axisPointerType](axis, polar, coordValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }

    var labelMargin = axisPointerModel.get(['label', 'margin']);
    var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin);
    _viewHelper__WEBPACK_IMPORTED_MODULE_1__.buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos);
  };

  return PolarAxisPointer;
}(_BaseAxisPointer__WEBPACK_IMPORTED_MODULE_2__.default);

;

function getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) {
  var axis = axisModel.axis;
  var coord = axis.dataToCoord(value);
  var axisAngle = polar.getAngleAxis().getExtent()[0];
  axisAngle = axisAngle / 180 * Math.PI;
  var radiusExtent = polar.getRadiusAxis().getExtent();
  var position;
  var align;
  var verticalAlign;

  if (axis.dim === 'radius') {
    var transform = zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
    zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate(transform, transform, axisAngle);
    zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_3__.translate(transform, transform, [polar.cx, polar.cy]);
    position = _util_graphic__WEBPACK_IMPORTED_MODULE_4__.applyTransform([coord, -labelMargin], transform);
    var labelRotation = axisModel.getModel('axisLabel').get('rotate') || 0; // @ts-ignore

    var labelLayout = _axis_AxisBuilder__WEBPACK_IMPORTED_MODULE_5__.default.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1);
    align = labelLayout.textAlign;
    verticalAlign = labelLayout.textVerticalAlign;
  } else {
    // angle axis
    var r = radiusExtent[1];
    position = polar.coordToPoint([r + labelMargin, coord]);
    var cx = polar.cx;
    var cy = polar.cy;
    align = Math.abs(position[0] - cx) / r < 0.3 ? 'center' : position[0] > cx ? 'left' : 'right';
    verticalAlign = Math.abs(position[1] - cy) / r < 0.3 ? 'middle' : position[1] > cy ? 'top' : 'bottom';
  }

  return {
    position: position,
    align: align,
    verticalAlign: verticalAlign
  };
}

var pointerShapeBuilder = {
  line: function (axis, polar, coordValue, otherExtent) {
    return axis.dim === 'angle' ? {
      type: 'Line',
      shape: _viewHelper__WEBPACK_IMPORTED_MODULE_1__.makeLineShape(polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]))
    } : {
      type: 'Circle',
      shape: {
        cx: polar.cx,
        cy: polar.cy,
        r: coordValue
      }
    };
  },
  shadow: function (axis, polar, coordValue, otherExtent) {
    var bandWidth = Math.max(1, axis.getBandWidth());
    var radian = Math.PI / 180;
    return axis.dim === 'angle' ? {
      type: 'Sector',
      shape: _viewHelper__WEBPACK_IMPORTED_MODULE_1__.makeSectorShape(polar.cx, polar.cy, otherExtent[0], otherExtent[1], // In ECharts y is negative if angle is positive
      (-coordValue - bandWidth / 2) * radian, (-coordValue + bandWidth / 2) * radian)
    } : {
      type: 'Sector',
      shape: _viewHelper__WEBPACK_IMPORTED_MODULE_1__.makeSectorShape(polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)
    };
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PolarAxisPointer);

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/SingleAxisPointer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axisPointer/SingleAxisPointer.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _BaseAxisPointer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BaseAxisPointer */ "./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js");
/* harmony import */ var _viewHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewHelper */ "./node_modules/echarts/lib/component/axisPointer/viewHelper.js");
/* harmony import */ var _coord_single_singleAxisHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../coord/single/singleAxisHelper */ "./node_modules/echarts/lib/coord/single/singleAxisHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var XY = ['x', 'y'];
var WH = ['width', 'height'];

var SingleAxisPointer =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SingleAxisPointer, _super);

  function SingleAxisPointer() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * @override
   */


  SingleAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    var coordSys = axis.coordinateSystem;
    var otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis));
    var pixelValue = coordSys.dataToPoint(value)[0];
    var axisPointerType = axisPointerModel.get('type');

    if (axisPointerType && axisPointerType !== 'none') {
      var elStyle = _viewHelper__WEBPACK_IMPORTED_MODULE_1__.buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }

    var layoutInfo = _coord_single_singleAxisHelper__WEBPACK_IMPORTED_MODULE_2__.layout(axisModel);
    _viewHelper__WEBPACK_IMPORTED_MODULE_1__.buildCartesianSingleLabelElOption( // @ts-ignore
    value, elOption, layoutInfo, axisModel, axisPointerModel, api);
  };
  /**
   * @override
   */


  SingleAxisPointer.prototype.getHandleTransform = function (value, axisModel, axisPointerModel) {
    var layoutInfo = _coord_single_singleAxisHelper__WEBPACK_IMPORTED_MODULE_2__.layout(axisModel, {
      labelInside: false
    }); // @ts-ignore

    layoutInfo.labelMargin = axisPointerModel.get(['handle', 'margin']);
    var position = _viewHelper__WEBPACK_IMPORTED_MODULE_1__.getTransformedPosition(axisModel.axis, value, layoutInfo);
    return {
      x: position[0],
      y: position[1],
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  };
  /**
   * @override
   */


  SingleAxisPointer.prototype.updateHandleTransform = function (transform, delta, axisModel, axisPointerModel) {
    var axis = axisModel.axis;
    var coordSys = axis.coordinateSystem;
    var dimIndex = getPointDimIndex(axis);
    var axisExtent = getGlobalExtent(coordSys, dimIndex);
    var currPosition = [transform.x, transform.y];
    currPosition[dimIndex] += delta[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    var otherExtent = getGlobalExtent(coordSys, 1 - dimIndex);
    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    var cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex];
    return {
      x: currPosition[0],
      y: currPosition[1],
      rotation: transform.rotation,
      cursorPoint: cursorPoint,
      tooltipOption: {
        verticalAlign: 'middle'
      }
    };
  };

  return SingleAxisPointer;
}(_BaseAxisPointer__WEBPACK_IMPORTED_MODULE_3__.default);

var pointerShapeBuilder = {
  line: function (axis, pixelValue, otherExtent) {
    var targetShape = _viewHelper__WEBPACK_IMPORTED_MODULE_1__.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getPointDimIndex(axis));
    return {
      type: 'Line',
      subPixelOptimize: true,
      shape: targetShape
    };
  },
  shadow: function (axis, pixelValue, otherExtent) {
    var bandWidth = axis.getBandWidth();
    var span = otherExtent[1] - otherExtent[0];
    return {
      type: 'Rect',
      shape: _viewHelper__WEBPACK_IMPORTED_MODULE_1__.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getPointDimIndex(axis))
    };
  }
};

function getPointDimIndex(axis) {
  return axis.isHorizontal() ? 0 : 1;
}

function getGlobalExtent(coordSys, dimIndex) {
  var rect = coordSys.getRect();
  return [rect[XY[dimIndex]], rect[XY[dimIndex]] + rect[WH[dimIndex]]];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SingleAxisPointer);

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/axisTrigger.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axisPointer/axisTrigger.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ axisTrigger)
/* harmony export */ });
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _modelHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modelHelper */ "./node_modules/echarts/lib/component/axisPointer/modelHelper.js");
/* harmony import */ var _findPointFromSeries__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./findPointFromSeries */ "./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();
/**
 * Basic logic: check all axis, if they do not demand show/highlight,
 * then hide/downplay them.
 *
 * @return content of event obj for echarts.connect.
 */

function axisTrigger(payload, ecModel, api) {
  var currTrigger = payload.currTrigger;
  var point = [payload.x, payload.y];
  var finder = payload;
  var dispatchAction = payload.dispatchAction || (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind)(api.dispatchAction, api);
  var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; // Pending
  // See #6121. But we are not able to reproduce it yet.

  if (!coordSysAxesInfo) {
    return;
  }

  if (illegalPoint(point)) {
    // Used in the default behavior of `connection`: use the sample seriesIndex
    // and dataIndex. And also used in the tooltipView trigger.
    point = (0,_findPointFromSeries__WEBPACK_IMPORTED_MODULE_2__.default)({
      seriesIndex: finder.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: finder.dataIndex
    }, ecModel).point;
  }

  var isIllegalPoint = illegalPoint(point); // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).
  // Notice: In this case, it is difficult to get the `point` (which is necessary to show
  // tooltip, so if point is not given, we just use the point found by sample seriesIndex
  // and dataIndex.

  var inputAxesInfo = finder.axesInfo;
  var axesInfo = coordSysAxesInfo.axesInfo;
  var shouldHide = currTrigger === 'leave' || illegalPoint(point);
  var outputPayload = {};
  var showValueMap = {};
  var dataByCoordSys = {
    list: [],
    map: {}
  };
  var updaters = {
    showPointer: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry)(showPointer, showValueMap),
    showTooltip: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry)(showTooltip, dataByCoordSys)
  }; // Process for triggered axes.

  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {
    // If a point given, it must be contained by the coordinate system.
    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {
      var axis = axisInfo.axis;
      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo); // If no inputAxesInfo, no axis is restricted.

      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
        var val = inputAxisInfo && inputAxisInfo.value;

        if (val == null && !isIllegalPoint) {
          val = axis.pointToData(point);
        }

        val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload);
      }
    });
  }); // Process for linked axes.

  var linkTriggers = {};
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(axesInfo, function (tarAxisInfo, tarKey) {
    var linkGroup = tarAxisInfo.linkGroup; // If axis has been triggered in the previous stage, it should not be triggered by link.

    if (linkGroup && !showValueMap[tarKey]) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {
        var srcValItem = showValueMap[srcKey]; // If srcValItem exist, source axis is triggered, so link to target axis.

        if (srcAxisInfo !== tarAxisInfo && srcValItem) {
          var val = srcValItem.value;
          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
          linkTriggers[tarAxisInfo.key] = val;
        }
      });
    }
  });
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(linkTriggers, function (val, tarKey) {
    processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload);
  });
  updateModelActually(showValueMap, axesInfo, outputPayload);
  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);
  dispatchHighDownActually(axesInfo, dispatchAction, api);
  return outputPayload;
}

function processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {
  var axis = axisInfo.axis;

  if (axis.scale.isBlank() || !axis.containData(newValue)) {
    return;
  }

  if (!axisInfo.involveSeries) {
    updaters.showPointer(axisInfo, newValue);
    return;
  } // Heavy calculation. So put it after axis.containData checking.


  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
  var payloadBatch = payloadInfo.payloadBatch;
  var snapToValue = payloadInfo.snapToValue; // Fill content of event obj for echarts.connect.
  // By default use the first involved series data as a sample to connect.

  if (payloadBatch[0] && outputFinder.seriesIndex == null) {
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend)(outputFinder, payloadBatch[0]);
  } // If no linkSource input, this process is for collecting link
  // target, where snap should not be accepted.


  if (!noSnap && axisInfo.snap) {
    if (axis.containData(snapToValue) && snapToValue != null) {
      newValue = snapToValue;
    }
  }

  updaters.showPointer(axisInfo, newValue, payloadBatch); // Tooltip should always be snapToValue, otherwise there will be
  // incorrect "axis value ~ series value" mapping displayed in tooltip.

  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
}

function buildPayloadsBySeries(value, axisInfo) {
  var axis = axisInfo.axis;
  var dim = axis.dim;
  var snapToValue = value;
  var payloadBatch = [];
  var minDist = Number.MAX_VALUE;
  var minDiff = -1;
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(axisInfo.seriesModels, function (series, idx) {
    var dataDim = series.getData().mapDimensionsAll(dim);
    var seriesNestestValue;
    var dataIndices;

    if (series.getAxisTooltipData) {
      var result = series.getAxisTooltipData(dataDim, value, axis);
      dataIndices = result.dataIndices;
      seriesNestestValue = result.nestestValue;
    } else {
      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex
      // when data length is not same.
      // false,
      axis.type === 'category' ? 0.5 : null);

      if (!dataIndices.length) {
        return;
      }

      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
    }

    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
      return;
    }

    var diff = value - seriesNestestValue;
    var dist = Math.abs(diff); // Consider category case

    if (dist <= minDist) {
      if (dist < minDist || diff >= 0 && minDiff < 0) {
        minDist = dist;
        minDiff = diff;
        snapToValue = seriesNestestValue;
        payloadBatch.length = 0;
      }

      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(dataIndices, function (dataIndex) {
        payloadBatch.push({
          seriesIndex: series.seriesIndex,
          dataIndexInside: dataIndex,
          dataIndex: series.getData().getRawIndex(dataIndex)
        });
      });
    }
  });
  return {
    payloadBatch: payloadBatch,
    snapToValue: snapToValue
  };
}

function showPointer(showValueMap, axisInfo, value, payloadBatch) {
  showValueMap[axisInfo.key] = {
    value: value,
    payloadBatch: payloadBatch
  };
}

function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
  var payloadBatch = payloadInfo.payloadBatch;
  var axis = axisInfo.axis;
  var axisModel = axis.model;
  var axisPointerModel = axisInfo.axisPointerModel; // If no data, do not create anything in dataByCoordSys,
  // whose length will be used to judge whether dispatch action.

  if (!axisInfo.triggerTooltip || !payloadBatch.length) {
    return;
  }

  var coordSysModel = axisInfo.coordSys.model;
  var coordSysKey = _modelHelper__WEBPACK_IMPORTED_MODULE_3__.makeKey(coordSysModel);
  var coordSysItem = dataByCoordSys.map[coordSysKey];

  if (!coordSysItem) {
    coordSysItem = dataByCoordSys.map[coordSysKey] = {
      coordSysId: coordSysModel.id,
      coordSysIndex: coordSysModel.componentIndex,
      coordSysType: coordSysModel.type,
      coordSysMainType: coordSysModel.mainType,
      dataByAxis: []
    };
    dataByCoordSys.list.push(coordSysItem);
  }

  coordSysItem.dataByAxis.push({
    axisDim: axis.dim,
    axisIndex: axisModel.componentIndex,
    axisType: axisModel.type,
    axisId: axisModel.id,
    value: value,
    // Caustion: viewHelper.getValueLabel is actually on "view stage", which
    // depends that all models have been updated. So it should not be performed
    // here. Considering axisPointerModel used here is volatile, which is hard
    // to be retrieve in TooltipView, we prepare parameters here.
    valueLabelOpt: {
      precision: axisPointerModel.get(['label', 'precision']),
      formatter: axisPointerModel.get(['label', 'formatter'])
    },
    seriesDataIndices: payloadBatch.slice()
  });
}

function updateModelActually(showValueMap, axesInfo, outputPayload) {
  var outputAxesInfo = outputPayload.axesInfo = []; // Basic logic: If no 'show' required, 'hide' this axisPointer.

  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(axesInfo, function (axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    var valItem = showValueMap[key];

    if (valItem) {
      !axisInfo.useHandle && (option.status = 'show');
      option.value = valItem.value; // For label formatter param and highlight.

      option.seriesDataIndices = (valItem.payloadBatch || []).slice();
    } // When always show (e.g., handle used), remain
    // original value and status.
    else {
        // If hide, value still need to be set, consider
        // click legend to toggle axis blank.
        !axisInfo.useHandle && (option.status = 'hide');
      } // If status is 'hide', should be no info in payload.


    option.status === 'show' && outputAxesInfo.push({
      axisDim: axisInfo.axis.dim,
      axisIndex: axisInfo.axis.model.componentIndex,
      value: option.value
    });
  });
}

function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {
  // Basic logic: If no showTip required, hideTip will be dispatched.
  if (illegalPoint(point) || !dataByCoordSys.list.length) {
    dispatchAction({
      type: 'hideTip'
    });
    return;
  } // In most case only one axis (or event one series is used). It is
  // convinient to fetch payload.seriesIndex and payload.dataIndex
  // dirtectly. So put the first seriesIndex and dataIndex of the first
  // axis on the payload.


  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  dispatchAction({
    type: 'showTip',
    escapeConnect: true,
    x: point[0],
    y: point[1],
    tooltipOption: payload.tooltipOption,
    position: payload.position,
    dataIndexInside: sampleItem.dataIndexInside,
    dataIndex: sampleItem.dataIndex,
    seriesIndex: sampleItem.seriesIndex,
    dataByCoordSys: dataByCoordSys.list
  });
}

function dispatchHighDownActually(axesInfo, dispatchAction, api) {
  // FIXME
  // highlight status modification shoule be a stage of main process?
  // (Consider confilct (e.g., legend and axisPointer) and setOption)
  var zr = api.getZr();
  var highDownKey = 'axisPointerLastHighlights';
  var lastHighlights = inner(zr)[highDownKey] || {};
  var newHighlights = inner(zr)[highDownKey] = {}; // Update highlight/downplay status according to axisPointer model.
  // Build hash map and remove duplicate incidentally.

  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(axesInfo, function (axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    option.status === 'show' && (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(option.seriesDataIndices, function (batchItem) {
      var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;
      newHighlights[key] = batchItem;
    });
  }); // Diff.

  var toHighlight = [];
  var toDownplay = [];
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(lastHighlights, function (batchItem, key) {
    !newHighlights[key] && toDownplay.push(batchItem);
  });
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(newHighlights, function (batchItem, key) {
    !lastHighlights[key] && toHighlight.push(batchItem);
  });
  toDownplay.length && api.dispatchAction({
    type: 'downplay',
    escapeConnect: true,
    // Not blur others when highlight in axisPointer.
    notBlur: true,
    batch: toDownplay
  });
  toHighlight.length && api.dispatchAction({
    type: 'highlight',
    escapeConnect: true,
    // Not blur others when highlight in axisPointer.
    notBlur: true,
    batch: toHighlight
  });
}

function findInputAxisInfo(inputAxesInfo, axisInfo) {
  for (var i = 0; i < (inputAxesInfo || []).length; i++) {
    var inputAxisInfo = inputAxesInfo[i];

    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
      return inputAxisInfo;
    }
  }
}

function makeMapperParam(axisInfo) {
  var axisModel = axisInfo.axis.model;
  var item = {};
  var dim = item.axisDim = axisInfo.axis.dim;
  item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;
  item.axisName = item[dim + 'AxisName'] = axisModel.name;
  item.axisId = item[dim + 'AxisId'] = axisModel.id;
  return item;
}

function illegalPoint(point) {
  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ findPointFromSeries)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * @param finder contains {seriesIndex, dataIndex, dataIndexInside}
 * @param ecModel
 * @return  {point: [x, y], el: ...} point Will not be null.
 */

function findPointFromSeries(finder, ecModel) {
  var point = [];
  var seriesIndex = finder.seriesIndex;
  var seriesModel;

  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
    return {
      point: []
    };
  }

  var data = seriesModel.getData();
  var dataIndex = _util_model__WEBPACK_IMPORTED_MODULE_0__.queryDataIndex(data, finder);

  if (dataIndex == null || dataIndex < 0 || zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(dataIndex)) {
    return {
      point: []
    };
  }

  var el = data.getItemGraphicEl(dataIndex);
  var coordSys = seriesModel.coordinateSystem;

  if (seriesModel.getTooltipPosition) {
    point = seriesModel.getTooltipPosition(dataIndex) || [];
  } else if (coordSys && coordSys.dataToPoint) {
    if (finder.isStacked) {
      var baseAxis = coordSys.getBaseAxis();
      var valueAxis = coordSys.getOtherAxis(baseAxis);
      var valueAxisDim = valueAxis.dim;
      var baseAxisDim = baseAxis.dim;
      var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;
      var baseDim = data.mapDimension(baseAxisDim);
      var stackedData = [];
      stackedData[baseDataOffset] = data.get(baseDim, dataIndex);
      stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo('stackResultDimension'), dataIndex);
      point = coordSys.dataToPoint(stackedData) || [];
    } else {
      point = coordSys.dataToPoint(data.getValues(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map(coordSys.dimensions, function (dim) {
        return data.mapDimension(dim);
      }), dataIndex)) || [];
    }
  } else if (el) {
    // Use graphic bounding rect
    var rect = el.getBoundingRect().clone();
    rect.applyTransform(el.transform);
    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  }

  return {
    point: point,
    el: el
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/globalListener.js":
/*!**************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axisPointer/globalListener.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "register": () => (/* binding */ register),
/* harmony export */   "unregister": () => (/* binding */ unregister)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/env */ "./node_modules/zrender/lib/core/env.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();
var each = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each;
/**
 * @param {string} key
 * @param {module:echarts/ExtensionAPI} api
 * @param {Function} handler
 *      param: {string} currTrigger
 *      param: {Array.<number>} point
 */

function register(key, api, handler) {
  if (zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_2__.default.node) {
    return;
  }

  var zr = api.getZr();
  inner(zr).records || (inner(zr).records = {});
  initGlobalListeners(zr, api);
  var record = inner(zr).records[key] || (inner(zr).records[key] = {});
  record.handler = handler;
}

function initGlobalListeners(zr, api) {
  if (inner(zr).initialized) {
    return;
  }

  inner(zr).initialized = true;
  useHandler('click', zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry(doEnter, 'click'));
  useHandler('mousemove', zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry(doEnter, 'mousemove')); // useHandler('mouseout', onLeave);

  useHandler('globalout', onLeave);

  function useHandler(eventType, cb) {
    zr.on(eventType, function (e) {
      var dis = makeDispatchAction(api);
      each(inner(zr).records, function (record) {
        record && cb(record, e, dis.dispatchAction);
      });
      dispatchTooltipFinally(dis.pendings, api);
    });
  }
}

function dispatchTooltipFinally(pendings, api) {
  var showLen = pendings.showTip.length;
  var hideLen = pendings.hideTip.length;
  var actuallyPayload;

  if (showLen) {
    actuallyPayload = pendings.showTip[showLen - 1];
  } else if (hideLen) {
    actuallyPayload = pendings.hideTip[hideLen - 1];
  }

  if (actuallyPayload) {
    actuallyPayload.dispatchAction = null;
    api.dispatchAction(actuallyPayload);
  }
}

function onLeave(record, e, dispatchAction) {
  record.handler('leave', null, dispatchAction);
}

function doEnter(currTrigger, record, e, dispatchAction) {
  record.handler(currTrigger, e, dispatchAction);
}

function makeDispatchAction(api) {
  var pendings = {
    showTip: [],
    hideTip: []
  }; // FIXME
  // better approach?
  // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,
  // which may be conflict, (axisPointer call showTip but tooltip call hideTip);
  // So we have to add "final stage" to merge those dispatched actions.

  var dispatchAction = function (payload) {
    var pendingList = pendings[payload.type];

    if (pendingList) {
      pendingList.push(payload);
    } else {
      payload.dispatchAction = dispatchAction;
      api.dispatchAction(payload);
    }
  };

  return {
    dispatchAction: dispatchAction,
    pendings: pendings
  };
}

function unregister(key, api) {
  if (zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_2__.default.node) {
    return;
  }

  var zr = api.getZr();
  var record = (inner(zr).records || {})[key];

  if (record) {
    inner(zr).records[key] = null;
  }
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/install.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axisPointer/install.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _axis_AxisView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../axis/AxisView */ "./node_modules/echarts/lib/component/axis/AxisView.js");
/* harmony import */ var _CartesianAxisPointer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CartesianAxisPointer */ "./node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js");
/* harmony import */ var _AxisPointerModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AxisPointerModel */ "./node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js");
/* harmony import */ var _AxisPointerView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AxisPointerView */ "./node_modules/echarts/lib/component/axisPointer/AxisPointerView.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _modelHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modelHelper */ "./node_modules/echarts/lib/component/axisPointer/modelHelper.js");
/* harmony import */ var _axisTrigger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./axisTrigger */ "./node_modules/echarts/lib/component/axisPointer/axisTrigger.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







function install(registers) {
  // CartesianAxisPointer is not supposed to be required here. But consider
  // echarts.simple.js and online build tooltip, which only require gridSimple,
  // CartesianAxisPointer should be able to required somewhere.
  _axis_AxisView__WEBPACK_IMPORTED_MODULE_0__.default.registerAxisPointerClass('CartesianAxisPointer', _CartesianAxisPointer__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerComponentModel(_AxisPointerModel__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerComponentView(_AxisPointerView__WEBPACK_IMPORTED_MODULE_3__.default);
  registers.registerPreprocessor(function (option) {
    // Always has a global axisPointerModel for default setting.
    if (option) {
      (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
      var link = option.axisPointer.link; // Normalize to array to avoid object mergin. But if link
      // is not set, remain null/undefined, otherwise it will
      // override existent link setting.

      if (link && !(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.isArray)(link)) {
        option.axisPointer.link = [link];
      }
    }
  }); // This process should proformed after coordinate systems created
  // and series data processed. So put it on statistic processing stage.

  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {
    // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
    // allAxesInfo should be updated when setOption performed.
    ecModel.getComponent('axisPointer').coordSysAxesInfo = (0,_modelHelper__WEBPACK_IMPORTED_MODULE_5__.collect)(ecModel, api);
  }); // Broadcast to all views.

  registers.registerAction({
    type: 'updateAxisPointer',
    event: 'updateAxisPointer',
    update: ':updateAxisPointer'
  }, _axisTrigger__WEBPACK_IMPORTED_MODULE_6__.default);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/viewHelper.js":
/*!**********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axisPointer/viewHelper.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildElStyle": () => (/* binding */ buildElStyle),
/* harmony export */   "buildLabelElOption": () => (/* binding */ buildLabelElOption),
/* harmony export */   "getValueLabel": () => (/* binding */ getValueLabel),
/* harmony export */   "getTransformedPosition": () => (/* binding */ getTransformedPosition),
/* harmony export */   "buildCartesianSingleLabelElOption": () => (/* binding */ buildCartesianSingleLabelElOption),
/* harmony export */   "makeLineShape": () => (/* binding */ makeLineShape),
/* harmony export */   "makeRectShape": () => (/* binding */ makeRectShape),
/* harmony export */   "makeSectorShape": () => (/* binding */ makeSectorShape)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var zrender_lib_contain_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/contain/text */ "./node_modules/zrender/lib/contain/text.js");
/* harmony import */ var _util_format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/format */ "./node_modules/echarts/lib/util/format.js");
/* harmony import */ var zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/core/matrix */ "./node_modules/zrender/lib/core/matrix.js");
/* harmony import */ var _coord_axisHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../coord/axisHelper */ "./node_modules/echarts/lib/coord/axisHelper.js");
/* harmony import */ var _axis_AxisBuilder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../axis/AxisBuilder */ "./node_modules/echarts/lib/component/axis/AxisBuilder.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








function buildElStyle(axisPointerModel) {
  var axisPointerType = axisPointerModel.get('type');
  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');
  var style;

  if (axisPointerType === 'line') {
    style = styleModel.getLineStyle();
    style.fill = null;
  } else if (axisPointerType === 'shadow') {
    style = styleModel.getAreaStyle();
    style.stroke = null;
  }

  return style;
}
/**
 * @param {Function} labelPos {align, verticalAlign, position}
 */

function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
  var value = axisPointerModel.get('value');
  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {
    precision: axisPointerModel.get(['label', 'precision']),
    formatter: axisPointerModel.get(['label', 'formatter'])
  });
  var labelModel = axisPointerModel.getModel('label');
  var paddings = _util_format__WEBPACK_IMPORTED_MODULE_0__.normalizeCssArray(labelModel.get('padding') || 0);
  var font = labelModel.getFont();
  var textRect = zrender_lib_contain_text__WEBPACK_IMPORTED_MODULE_1__.getBoundingRect(text, font);
  var position = labelPos.position;
  var width = textRect.width + paddings[1] + paddings[3];
  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.

  var align = labelPos.align;
  align === 'right' && (position[0] -= width);
  align === 'center' && (position[0] -= width / 2);
  var verticalAlign = labelPos.verticalAlign;
  verticalAlign === 'bottom' && (position[1] -= height);
  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container

  confineInContainer(position, width, height, api);
  var bgColor = labelModel.get('backgroundColor');

  if (!bgColor || bgColor === 'auto') {
    bgColor = axisModel.get(['axisLine', 'lineStyle', 'color']);
  }

  elOption.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: position[0],
    y: position[1],
    style: (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_2__.createTextStyle)(labelModel, {
      text: text,
      font: font,
      fill: labelModel.getTextColor(),
      padding: paddings,
      backgroundColor: bgColor
    }),
    // Lable should be over axisPointer.
    z2: 10
  };
} // Do not overflow ec container

function confineInContainer(position, width, height, api) {
  var viewWidth = api.getWidth();
  var viewHeight = api.getHeight();
  position[0] = Math.min(position[0] + width, viewWidth) - width;
  position[1] = Math.min(position[1] + height, viewHeight) - height;
  position[0] = Math.max(position[0], 0);
  position[1] = Math.max(position[1], 0);
}

function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
  value = axis.scale.parse(value);
  var text = axis.scale.getLabel({
    value: value
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: opt.precision
  });
  var formatter = opt.formatter;

  if (formatter) {
    var params_1 = {
      value: _coord_axisHelper__WEBPACK_IMPORTED_MODULE_3__.getAxisRawValue(axis, {
        value: value
      }),
      axisDimension: axis.dim,
      axisIndex: axis.index,
      seriesData: []
    };
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.each(seriesDataIndices, function (idxItem) {
      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
      var dataIndex = idxItem.dataIndexInside;
      var dataParams = series && series.getDataParams(dataIndex);
      dataParams && params_1.seriesData.push(dataParams);
    });

    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.isString(formatter)) {
      text = formatter.replace('{value}', text);
    } else if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.isFunction(formatter)) {
      text = formatter(params_1);
    }
  }

  return text;
}
function getTransformedPosition(axis, value, layoutInfo) {
  var transform = zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_5__.create();
  zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_5__.rotate(transform, transform, layoutInfo.rotation);
  zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_5__.translate(transform, transform, layoutInfo.position);
  return _util_graphic__WEBPACK_IMPORTED_MODULE_6__.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
}
function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
  // @ts-ignore
  var textLayout = _axis_AxisBuilder__WEBPACK_IMPORTED_MODULE_7__.default.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
  layoutInfo.labelMargin = axisPointerModel.get(['label', 'margin']);
  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
    position: getTransformedPosition(axisModel.axis, value, layoutInfo),
    align: textLayout.textAlign,
    verticalAlign: textLayout.textVerticalAlign
  });
}
function makeLineShape(p1, p2, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x1: p1[xDimIndex],
    y1: p1[1 - xDimIndex],
    x2: p2[xDimIndex],
    y2: p2[1 - xDimIndex]
  };
}
function makeRectShape(xy, wh, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x: xy[xDimIndex],
    y: xy[1 - xDimIndex],
    width: wh[xDimIndex],
    height: wh[1 - xDimIndex]
  };
}
function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
  return {
    cx: cx,
    cy: cy,
    r0: r0,
    r: r,
    startAngle: startAngle,
    endAngle: endAngle,
    clockwise: true
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/brush/BrushModel.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/brush/BrushModel.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _visual_visualSolution__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../visual/visualSolution */ "./node_modules/echarts/lib/visual/visualSolution.js");
/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../model/Model */ "./node_modules/echarts/lib/model/Model.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var DEFAULT_OUT_OF_BRUSH_COLOR = '#ddd';

var BrushModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(BrushModel, _super);

  function BrushModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = BrushModel.type;
    /**
     * @readOnly
     */

    _this.areas = [];
    /**
     * Current brush painting area settings.
     * @readOnly
     */

    _this.brushOption = {};
    return _this;
  }

  BrushModel.prototype.optionUpdated = function (newOption, isInit) {
    var thisOption = this.option;
    !isInit && _visual_visualSolution__WEBPACK_IMPORTED_MODULE_1__.replaceVisualOption(thisOption, newOption, ['inBrush', 'outOfBrush']);
    var inBrush = thisOption.inBrush = thisOption.inBrush || {}; // Always give default visual, consider setOption at the second time.

    thisOption.outOfBrush = thisOption.outOfBrush || {
      color: DEFAULT_OUT_OF_BRUSH_COLOR
    };

    if (!inBrush.hasOwnProperty('liftZ')) {
      // Bigger than the highlight z lift, otherwise it will
      // be effected by the highlight z when brush.
      inBrush.liftZ = 5;
    }
  };
  /**
   * If `areas` is null/undefined, range state remain.
   */


  BrushModel.prototype.setAreas = function (areas) {
    if (true) {
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.assert(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.isArray(areas));
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each(areas, function (area) {
        zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.assert(area.brushType, 'Illegal areas');
      });
    } // If areas is null/undefined, range state remain.
    // This helps user to dispatchAction({type: 'brush'}) with no areas
    // set but just want to get the current brush select info from a `brush` event.


    if (!areas) {
      return;
    }

    this.areas = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.map(areas, function (area) {
      return generateBrushOption(this.option, area);
    }, this);
  };
  /**
   * Set the current painting brush option.
   */


  BrushModel.prototype.setBrushOption = function (brushOption) {
    this.brushOption = generateBrushOption(this.option, brushOption);
    this.brushType = this.brushOption.brushType;
  };

  BrushModel.type = 'brush';
  BrushModel.dependencies = ['geo', 'grid', 'xAxis', 'yAxis', 'parallel', 'series'];
  BrushModel.defaultOption = {
    seriesIndex: 'all',
    brushType: 'rect',
    brushMode: 'single',
    transformable: true,
    brushStyle: {
      borderWidth: 1,
      color: 'rgba(210,219,238,0.3)',
      borderColor: '#D2DBEE'
    },
    throttleType: 'fixRate',
    throttleDelay: 0,
    removeOnClick: true,
    z: 10000
  };
  return BrushModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_3__.default);

function generateBrushOption(option, brushOption) {
  return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.merge({
    brushType: option.brushType,
    brushMode: option.brushMode,
    transformable: option.transformable,
    brushStyle: new _model_Model__WEBPACK_IMPORTED_MODULE_4__.default(option.brushStyle).getItemStyle(),
    removeOnClick: option.removeOnClick,
    z: option.z
  }, brushOption, true);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BrushModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/brush/BrushView.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/component/brush/BrushView.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _helper_BrushController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/BrushController */ "./node_modules/echarts/lib/component/helper/BrushController.js");
/* harmony import */ var _visualEncoding__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./visualEncoding */ "./node_modules/echarts/lib/component/brush/visualEncoding.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var BrushView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(BrushView, _super);

  function BrushView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = BrushView.type;
    return _this;
  }

  BrushView.prototype.init = function (ecModel, api) {
    this.ecModel = ecModel;
    this.api = api;
    this.model;
    (this._brushController = new _helper_BrushController__WEBPACK_IMPORTED_MODULE_1__.default(api.getZr())).on('brush', zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind(this._onBrush, this)).mount();
  };

  BrushView.prototype.render = function (brushModel, ecModel, api, payload) {
    this.model = brushModel;

    this._updateController(brushModel, ecModel, api, payload);
  };

  BrushView.prototype.updateTransform = function (brushModel, ecModel, api, payload) {
    // PENDING: `updateTransform` is a little tricky, whose layout need
    // to be calculate mandatorily and other stages will not be performed.
    // Take care the correctness of the logic. See #11754 .
    (0,_visualEncoding__WEBPACK_IMPORTED_MODULE_3__.layoutCovers)(ecModel);

    this._updateController(brushModel, ecModel, api, payload);
  };

  BrushView.prototype.updateVisual = function (brushModel, ecModel, api, payload) {
    this.updateTransform(brushModel, ecModel, api, payload);
  };

  BrushView.prototype.updateView = function (brushModel, ecModel, api, payload) {
    this._updateController(brushModel, ecModel, api, payload);
  };

  BrushView.prototype._updateController = function (brushModel, ecModel, api, payload) {
    // Do not update controller when drawing.
    (!payload || payload.$from !== brushModel.id) && this._brushController.setPanels(brushModel.brushTargetManager.makePanelOpts(api)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice());
  }; // updateLayout: updateController,
  // updateVisual: updateController,


  BrushView.prototype.dispose = function () {
    this._brushController.dispose();
  };

  BrushView.prototype._onBrush = function (eventParam) {
    var modelId = this.model.id;
    var areas = this.model.brushTargetManager.setOutputRanges(eventParam.areas, this.ecModel); // Action is not dispatched on drag end, because the drag end
    // emits the same params with the last drag move event, and
    // may have some delay when using touch pad, which makes
    // animation not smooth (when using debounce).

    (!eventParam.isEnd || eventParam.removeOnClick) && this.api.dispatchAction({
      type: 'brush',
      brushId: modelId,
      areas: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.clone(areas),
      $from: modelId
    });
    eventParam.isEnd && this.api.dispatchAction({
      type: 'brushEnd',
      brushId: modelId,
      areas: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.clone(areas),
      $from: modelId
    });
  };

  BrushView.type = 'brush';
  return BrushView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_4__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BrushView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/brush/install.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/component/brush/install.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _preprocessor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./preprocessor */ "./node_modules/echarts/lib/component/brush/preprocessor.js");
/* harmony import */ var _BrushView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BrushView */ "./node_modules/echarts/lib/component/brush/BrushView.js");
/* harmony import */ var _BrushModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BrushModel */ "./node_modules/echarts/lib/component/brush/BrushModel.js");
/* harmony import */ var _visualEncoding__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./visualEncoding */ "./node_modules/echarts/lib/component/brush/visualEncoding.js");
/* harmony import */ var _toolbox_feature_Brush__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../toolbox/feature/Brush */ "./node_modules/echarts/lib/component/toolbox/feature/Brush.js");
/* harmony import */ var _toolbox_featureManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../toolbox/featureManager */ "./node_modules/echarts/lib/component/toolbox/featureManager.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



 // TODO



function install(registers) {
  registers.registerComponentView(_BrushView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerComponentModel(_BrushModel__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerPreprocessor(_preprocessor__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, _visualEncoding__WEBPACK_IMPORTED_MODULE_3__.default);
  registers.registerAction({
    type: 'brush',
    event: 'brush',
    update: 'updateVisual'
  }, function (payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'brush',
      query: payload
    }, function (brushModel) {
      brushModel.setAreas(payload.areas);
    });
  });
  /**
   * payload: {
   *      brushComponents: [
   *          {
   *              brushId,
   *              brushIndex,
   *              brushName,
   *              series: [
   *                  {
   *                      seriesId,
   *                      seriesIndex,
   *                      seriesName,
   *                      rawIndices: [21, 34, ...]
   *                  },
   *                  ...
   *              ]
   *          },
   *          ...
   *      ]
   * }
   */

  registers.registerAction({
    type: 'brushSelect',
    event: 'brushSelected',
    update: 'none'
  }, function () {});
  registers.registerAction({
    type: 'brushEnd',
    event: 'brushEnd',
    update: 'none'
  }, function () {});
  (0,_toolbox_featureManager__WEBPACK_IMPORTED_MODULE_4__.registerFeature)('brush', _toolbox_feature_Brush__WEBPACK_IMPORTED_MODULE_5__.default);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/brush/preprocessor.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/brush/preprocessor.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ brushPreprocessor)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


var DEFAULT_TOOLBOX_BTNS = ['rect', 'polygon', 'keep', 'clear'];
function brushPreprocessor(option, isNew) {
  var brushComponents = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.normalizeToArray)(option ? option.brush : []);

  if (!brushComponents.length) {
    return;
  }

  var brushComponentSpecifiedBtns = [];
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(brushComponents, function (brushOpt) {
    var tbs = brushOpt.hasOwnProperty('toolbox') ? brushOpt.toolbox : [];

    if (tbs instanceof Array) {
      brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs);
    }
  });
  var toolbox = option && option.toolbox;

  if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(toolbox)) {
    toolbox = toolbox[0];
  }

  if (!toolbox) {
    toolbox = {
      feature: {}
    };
    option.toolbox = [toolbox];
  }

  var toolboxFeature = toolbox.feature || (toolbox.feature = {});
  var toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {});
  var brushTypes = toolboxBrush.type || (toolboxBrush.type = []);
  brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns);
  removeDuplicate(brushTypes);

  if (isNew && !brushTypes.length) {
    brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS);
  }
}

function removeDuplicate(arr) {
  var map = {};
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(arr, function (val) {
    map[val] = 1;
  });
  arr.length = 0;
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(map, function (flag, val) {
    arr.push(val);
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/brush/selector.js":
/*!**************************************************************!*\
  !*** ./node_modules/echarts/lib/component/brush/selector.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeBrushCommonSelectorForSeries": () => (/* binding */ makeBrushCommonSelectorForSeries),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_contain_polygon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/contain/polygon */ "./node_modules/zrender/lib/contain/polygon.js");
/* harmony import */ var zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/BoundingRect */ "./node_modules/zrender/lib/core/BoundingRect.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function makeBrushCommonSelectorForSeries(area) {
  var brushType = area.brushType; // Do not use function binding or curry for performance.

  var selectors = {
    point: function (itemLayout) {
      return selector[brushType].point(itemLayout, selectors, area);
    },
    rect: function (itemLayout) {
      return selector[brushType].rect(itemLayout, selectors, area);
    }
  };
  return selectors;
}
var selector = {
  lineX: getLineSelectors(0),
  lineY: getLineSelectors(1),
  rect: {
    point: function (itemLayout, selectors, area) {
      return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]);
    },
    rect: function (itemLayout, selectors, area) {
      return itemLayout && area.boundingRect.intersect(itemLayout);
    }
  },
  polygon: {
    point: function (itemLayout, selectors, area) {
      return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]) && zrender_lib_contain_polygon__WEBPACK_IMPORTED_MODULE_0__.contain(area.range, itemLayout[0], itemLayout[1]);
    },
    rect: function (itemLayout, selectors, area) {
      var points = area.range;

      if (!itemLayout || points.length <= 1) {
        return false;
      }

      var x = itemLayout.x;
      var y = itemLayout.y;
      var width = itemLayout.width;
      var height = itemLayout.height;
      var p = points[0];

      if (zrender_lib_contain_polygon__WEBPACK_IMPORTED_MODULE_0__.contain(points, x, y) || zrender_lib_contain_polygon__WEBPACK_IMPORTED_MODULE_0__.contain(points, x + width, y) || zrender_lib_contain_polygon__WEBPACK_IMPORTED_MODULE_0__.contain(points, x, y + height) || zrender_lib_contain_polygon__WEBPACK_IMPORTED_MODULE_0__.contain(points, x + width, y + height) || zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_1__.default.create(itemLayout).contain(p[0], p[1]) || (0,_util_graphic__WEBPACK_IMPORTED_MODULE_2__.linePolygonIntersect)(x, y, x + width, y, points) || (0,_util_graphic__WEBPACK_IMPORTED_MODULE_2__.linePolygonIntersect)(x, y, x, y + height, points) || (0,_util_graphic__WEBPACK_IMPORTED_MODULE_2__.linePolygonIntersect)(x + width, y, x + width, y + height, points) || (0,_util_graphic__WEBPACK_IMPORTED_MODULE_2__.linePolygonIntersect)(x, y + height, x + width, y + height, points)) {
        return true;
      }
    }
  }
};

function getLineSelectors(xyIndex) {
  var xy = ['x', 'y'];
  var wh = ['width', 'height'];
  return {
    point: function (itemLayout, selectors, area) {
      if (itemLayout) {
        var range = area.range;
        var p = itemLayout[xyIndex];
        return inLineRange(p, range);
      }
    },
    rect: function (itemLayout, selectors, area) {
      if (itemLayout) {
        var range = area.range;
        var layoutRange = [itemLayout[xy[xyIndex]], itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]]];
        layoutRange[1] < layoutRange[0] && layoutRange.reverse();
        return inLineRange(layoutRange[0], range) || inLineRange(layoutRange[1], range) || inLineRange(range[0], layoutRange) || inLineRange(range[1], layoutRange);
      }
    }
  };
}

function inLineRange(p, range) {
  return range[0] <= p && p <= range[1];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (selector);

/***/ }),

/***/ "./node_modules/echarts/lib/component/brush/visualEncoding.js":
/*!********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/brush/visualEncoding.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "layoutCovers": () => (/* binding */ layoutCovers),
/* harmony export */   "default": () => (/* binding */ brushVisual)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/core/BoundingRect */ "./node_modules/zrender/lib/core/BoundingRect.js");
/* harmony import */ var _visual_visualSolution__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../visual/visualSolution */ "./node_modules/echarts/lib/visual/visualSolution.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selector */ "./node_modules/echarts/lib/component/brush/selector.js");
/* harmony import */ var _util_throttle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/throttle */ "./node_modules/echarts/lib/util/throttle.js");
/* harmony import */ var _helper_BrushTargetManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helper/BrushTargetManager */ "./node_modules/echarts/lib/component/helper/BrushTargetManager.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var STATE_LIST = ['inBrush', 'outOfBrush'];
var DISPATCH_METHOD = '__ecBrushSelect';
var DISPATCH_FLAG = '__ecInBrushSelectEvent';
;
function layoutCovers(ecModel) {
  ecModel.eachComponent({
    mainType: 'brush'
  }, function (brushModel) {
    var brushTargetManager = brushModel.brushTargetManager = new _helper_BrushTargetManager__WEBPACK_IMPORTED_MODULE_0__.default(brushModel.option, ecModel);
    brushTargetManager.setInputRanges(brushModel.areas, ecModel);
  });
}
/**
 * Register the visual encoding if this modules required.
 */

function brushVisual(ecModel, api, payload) {
  var brushSelected = [];
  var throttleType;
  var throttleDelay;
  ecModel.eachComponent({
    mainType: 'brush'
  }, function (brushModel) {
    payload && payload.type === 'takeGlobalCursor' && brushModel.setBrushOption(payload.key === 'brush' ? payload.brushOption : {
      brushType: false
    });
  });
  layoutCovers(ecModel);
  ecModel.eachComponent({
    mainType: 'brush'
  }, function (brushModel, brushIndex) {
    var thisBrushSelected = {
      brushId: brushModel.id,
      brushIndex: brushIndex,
      brushName: brushModel.name,
      areas: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone(brushModel.areas),
      selected: []
    }; // Every brush component exists in event params, convenient
    // for user to find by index.

    brushSelected.push(thisBrushSelected);
    var brushOption = brushModel.option;
    var brushLink = brushOption.brushLink;
    var linkedSeriesMap = [];
    var selectedDataIndexForLink = [];
    var rangeInfoBySeries = [];
    var hasBrushExists = false;

    if (!brushIndex) {
      // Only the first throttle setting works.
      throttleType = brushOption.throttleType;
      throttleDelay = brushOption.throttleDelay;
    } // Add boundingRect and selectors to range.


    var areas = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map(brushModel.areas, function (area) {
      var builder = boundingRectBuilders[area.brushType];
      var selectableArea = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults({
        boundingRect: builder ? builder(area) : void 0
      }, area);
      selectableArea.selectors = (0,_selector__WEBPACK_IMPORTED_MODULE_2__.makeBrushCommonSelectorForSeries)(selectableArea);
      return selectableArea;
    });
    var visualMappings = _visual_visualSolution__WEBPACK_IMPORTED_MODULE_3__.createVisualMappings(brushModel.option, STATE_LIST, function (mappingOption) {
      mappingOption.mappingMethod = 'fixed';
    });
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(brushLink) && zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(brushLink, function (seriesIndex) {
      linkedSeriesMap[seriesIndex] = 1;
    });

    function linkOthers(seriesIndex) {
      return brushLink === 'all' || !!linkedSeriesMap[seriesIndex];
    } // If no supported brush or no brush on the series,
    // all visuals should be in original state.


    function brushed(rangeInfoList) {
      return !!rangeInfoList.length;
    }
    /**
     * Logic for each series: (If the logic has to be modified one day, do it carefully!)
     *
     * ( brushed ┬ && ┬hasBrushExist ┬ && linkOthers  ) => StepA: ┬record, ┬ StepB: ┬visualByRecord.
     *   !brushed┘    ├hasBrushExist ┤                            └nothing,┘        ├visualByRecord.
     *                └!hasBrushExist┘                                              └nothing.
     * ( !brushed  && ┬hasBrushExist ┬ && linkOthers  ) => StepA:  nothing,  StepB: ┬visualByRecord.
     *                └!hasBrushExist┘                                              └nothing.
     * ( brushed ┬ &&                     !linkOthers ) => StepA:  nothing,  StepB: ┬visualByCheck.
     *   !brushed┘                                                                  └nothing.
     * ( !brushed  &&                     !linkOthers ) => StepA:  nothing,  StepB:  nothing.
     */
    // Step A


    ecModel.eachSeries(function (seriesModel, seriesIndex) {
      var rangeInfoList = rangeInfoBySeries[seriesIndex] = [];
      seriesModel.subType === 'parallel' ? stepAParallel(seriesModel, seriesIndex) : stepAOthers(seriesModel, seriesIndex, rangeInfoList);
    });

    function stepAParallel(seriesModel, seriesIndex) {
      var coordSys = seriesModel.coordinateSystem;
      hasBrushExists = hasBrushExists || coordSys.hasAxisBrushed();
      linkOthers(seriesIndex) && coordSys.eachActiveState(seriesModel.getData(), function (activeState, dataIndex) {
        activeState === 'active' && (selectedDataIndexForLink[dataIndex] = 1);
      });
    }

    function stepAOthers(seriesModel, seriesIndex, rangeInfoList) {
      if (!seriesModel.brushSelector || brushModelNotControll(brushModel, seriesIndex)) {
        return;
      }

      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(areas, function (area) {
        if (brushModel.brushTargetManager.controlSeries(area, seriesModel, ecModel)) {
          rangeInfoList.push(area);
        }

        hasBrushExists = hasBrushExists || brushed(rangeInfoList);
      });

      if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {
        var data_1 = seriesModel.getData();
        data_1.each(function (dataIndex) {
          if (checkInRange(seriesModel, rangeInfoList, data_1, dataIndex)) {
            selectedDataIndexForLink[dataIndex] = 1;
          }
        });
      }
    } // Step B


    ecModel.eachSeries(function (seriesModel, seriesIndex) {
      var seriesBrushSelected = {
        seriesId: seriesModel.id,
        seriesIndex: seriesIndex,
        seriesName: seriesModel.name,
        dataIndex: []
      }; // Every series exists in event params, convenient
      // for user to find series by seriesIndex.

      thisBrushSelected.selected.push(seriesBrushSelected);
      var rangeInfoList = rangeInfoBySeries[seriesIndex];
      var data = seriesModel.getData();
      var getValueState = linkOthers(seriesIndex) ? function (dataIndex) {
        return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush') : 'outOfBrush';
      } : function (dataIndex) {
        return checkInRange(seriesModel, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush') : 'outOfBrush';
      }; // If no supported brush or no brush, all visuals are in original state.

      (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && _visual_visualSolution__WEBPACK_IMPORTED_MODULE_3__.applyVisual(STATE_LIST, visualMappings, data, getValueState);
    });
  });
  dispatchAction(api, throttleType, throttleDelay, brushSelected, payload);
}
;

function dispatchAction(api, throttleType, throttleDelay, brushSelected, payload) {
  // This event will not be triggered when `setOpion`, otherwise dead lock may
  // triggered when do `setOption` in event listener, which we do not find
  // satisfactory way to solve yet. Some considered resolutions:
  // (a) Diff with prevoius selected data ant only trigger event when changed.
  // But store previous data and diff precisely (i.e., not only by dataIndex, but
  // also detect value changes in selected data) might bring complexity or fragility.
  // (b) Use spectial param like `silent` to suppress event triggering.
  // But such kind of volatile param may be weird in `setOption`.
  if (!payload) {
    return;
  }

  var zr = api.getZr();

  if (zr[DISPATCH_FLAG]) {
    return;
  }

  if (!zr[DISPATCH_METHOD]) {
    zr[DISPATCH_METHOD] = doDispatch;
  }

  var fn = _util_throttle__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType);
  fn(api, brushSelected);
}

function doDispatch(api, brushSelected) {
  if (!api.isDisposed()) {
    var zr = api.getZr();
    zr[DISPATCH_FLAG] = true;
    api.dispatchAction({
      type: 'brushSelect',
      batch: brushSelected
    });
    zr[DISPATCH_FLAG] = false;
  }
}

function checkInRange(seriesModel, rangeInfoList, data, dataIndex) {
  for (var i = 0, len = rangeInfoList.length; i < len; i++) {
    var area = rangeInfoList[i];

    if (seriesModel.brushSelector(dataIndex, data, area.selectors, area)) {
      return true;
    }
  }
}

function brushModelNotControll(brushModel, seriesIndex) {
  var seriesIndices = brushModel.option.seriesIndex;
  return seriesIndices != null && seriesIndices !== 'all' && (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(seriesIndices) ? zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.indexOf(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices);
}

var boundingRectBuilders = {
  rect: function (area) {
    return getBoundingRectFromMinMax(area.range);
  },
  polygon: function (area) {
    var minMax;
    var range = area.range;

    for (var i = 0, len = range.length; i < len; i++) {
      minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]];
      var rg = range[i];
      rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]);
      rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]);
      rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]);
      rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]);
    }

    return minMax && getBoundingRectFromMinMax(minMax);
  }
};

function getBoundingRectFromMinMax(minMax) {
  return new zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_5__.default(minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0]);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/calendar/CalendarView.js":
/*!*********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/calendar/CalendarView.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polyline.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _util_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/format */ "./node_modules/echarts/lib/util/format.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







var MONTH_TEXT = {
  EN: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  CN: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月']
};
var WEEK_TEXT = {
  EN: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  CN: ['日', '一', '二', '三', '四', '五', '六']
};

var CalendarView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(CalendarView, _super);

  function CalendarView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CalendarView.type;
    return _this;
  }

  CalendarView.prototype.render = function (calendarModel, ecModel, api) {
    var group = this.group;
    group.removeAll();
    var coordSys = calendarModel.coordinateSystem; // range info

    var rangeData = coordSys.getRangeInfo();
    var orient = coordSys.getOrient();

    this._renderDayRect(calendarModel, rangeData, group); // _renderLines must be called prior to following function


    this._renderLines(calendarModel, rangeData, orient, group);

    this._renderYearText(calendarModel, rangeData, orient, group);

    this._renderMonthText(calendarModel, orient, group);

    this._renderWeekText(calendarModel, rangeData, orient, group);
  }; // render day rect


  CalendarView.prototype._renderDayRect = function (calendarModel, rangeData, group) {
    var coordSys = calendarModel.coordinateSystem;
    var itemRectStyleModel = calendarModel.getModel('itemStyle').getItemStyle();
    var sw = coordSys.getCellWidth();
    var sh = coordSys.getCellHeight();

    for (var i = rangeData.start.time; i <= rangeData.end.time; i = coordSys.getNextNDay(i, 1).time) {
      var point = coordSys.dataToRect([i], false).tl; // every rect

      var rect = new _util_graphic__WEBPACK_IMPORTED_MODULE_1__.default({
        shape: {
          x: point[0],
          y: point[1],
          width: sw,
          height: sh
        },
        cursor: 'default',
        style: itemRectStyleModel
      });
      group.add(rect);
    }
  }; // render separate line


  CalendarView.prototype._renderLines = function (calendarModel, rangeData, orient, group) {
    var self = this;
    var coordSys = calendarModel.coordinateSystem;
    var lineStyleModel = calendarModel.getModel(['splitLine', 'lineStyle']).getLineStyle();
    var show = calendarModel.get(['splitLine', 'show']);
    var lineWidth = lineStyleModel.lineWidth;
    this._tlpoints = [];
    this._blpoints = [];
    this._firstDayOfMonth = [];
    this._firstDayPoints = [];
    var firstDay = rangeData.start;

    for (var i = 0; firstDay.time <= rangeData.end.time; i++) {
      addPoints(firstDay.formatedDate);

      if (i === 0) {
        firstDay = coordSys.getDateInfo(rangeData.start.y + '-' + rangeData.start.m);
      }

      var date = firstDay.date;
      date.setMonth(date.getMonth() + 1);
      firstDay = coordSys.getDateInfo(date);
    }

    addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);

    function addPoints(date) {
      self._firstDayOfMonth.push(coordSys.getDateInfo(date));

      self._firstDayPoints.push(coordSys.dataToRect([date], false).tl);

      var points = self._getLinePointsOfOneWeek(calendarModel, date, orient);

      self._tlpoints.push(points[0]);

      self._blpoints.push(points[points.length - 1]);

      show && self._drawSplitline(points, lineStyleModel, group);
    } // render top/left line


    show && this._drawSplitline(self._getEdgesPoints(self._tlpoints, lineWidth, orient), lineStyleModel, group); // render bottom/right line

    show && this._drawSplitline(self._getEdgesPoints(self._blpoints, lineWidth, orient), lineStyleModel, group);
  }; // get points at both ends


  CalendarView.prototype._getEdgesPoints = function (points, lineWidth, orient) {
    var rs = [points[0].slice(), points[points.length - 1].slice()];
    var idx = orient === 'horizontal' ? 0 : 1; // both ends of the line are extend half lineWidth

    rs[0][idx] = rs[0][idx] - lineWidth / 2;
    rs[1][idx] = rs[1][idx] + lineWidth / 2;
    return rs;
  }; // render split line


  CalendarView.prototype._drawSplitline = function (points, lineStyle, group) {
    var poyline = new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default({
      z2: 20,
      shape: {
        points: points
      },
      style: lineStyle
    });
    group.add(poyline);
  }; // render month line of one week points


  CalendarView.prototype._getLinePointsOfOneWeek = function (calendarModel, date, orient) {
    var coordSys = calendarModel.coordinateSystem;
    var parsedDate = coordSys.getDateInfo(date);
    var points = [];

    for (var i = 0; i < 7; i++) {
      var tmpD = coordSys.getNextNDay(parsedDate.time, i);
      var point = coordSys.dataToRect([tmpD.time], false);
      points[2 * tmpD.day] = point.tl;
      points[2 * tmpD.day + 1] = point[orient === 'horizontal' ? 'bl' : 'tr'];
    }

    return points;
  };

  CalendarView.prototype._formatterLabel = function (formatter, params) {
    if (typeof formatter === 'string' && formatter) {
      return _util_format__WEBPACK_IMPORTED_MODULE_3__.formatTplSimple(formatter, params);
    }

    if (typeof formatter === 'function') {
      return formatter(params);
    }

    return params.nameMap;
  };

  CalendarView.prototype._yearTextPositionControl = function (textEl, point, orient, position, margin) {
    var x = point[0];
    var y = point[1];
    var aligns = ['center', 'bottom'];

    if (position === 'bottom') {
      y += margin;
      aligns = ['center', 'top'];
    } else if (position === 'left') {
      x -= margin;
    } else if (position === 'right') {
      x += margin;
      aligns = ['center', 'top'];
    } else {
      // top
      y -= margin;
    }

    var rotate = 0;

    if (position === 'left' || position === 'right') {
      rotate = Math.PI / 2;
    }

    return {
      rotation: rotate,
      x: x,
      y: y,
      style: {
        align: aligns[0],
        verticalAlign: aligns[1]
      }
    };
  }; // render year


  CalendarView.prototype._renderYearText = function (calendarModel, rangeData, orient, group) {
    var yearLabel = calendarModel.getModel('yearLabel');

    if (!yearLabel.get('show')) {
      return;
    }

    var margin = yearLabel.get('margin');
    var pos = yearLabel.get('position');

    if (!pos) {
      pos = orient !== 'horizontal' ? 'top' : 'left';
    }

    var points = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];
    var xc = (points[0][0] + points[1][0]) / 2;
    var yc = (points[0][1] + points[1][1]) / 2;
    var idx = orient === 'horizontal' ? 0 : 1;
    var posPoints = {
      top: [xc, points[idx][1]],
      bottom: [xc, points[1 - idx][1]],
      left: [points[1 - idx][0], yc],
      right: [points[idx][0], yc]
    };
    var name = rangeData.start.y;

    if (+rangeData.end.y > +rangeData.start.y) {
      name = name + '-' + rangeData.end.y;
    }

    var formatter = yearLabel.get('formatter');
    var params = {
      start: rangeData.start.y,
      end: rangeData.end.y,
      nameMap: name
    };

    var content = this._formatterLabel(formatter, params);

    var yearText = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default({
      z2: 30,
      style: (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_5__.createTextStyle)(yearLabel, {
        text: content
      })
    });
    yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin));
    group.add(yearText);
  };

  CalendarView.prototype._monthTextPositionControl = function (point, isCenter, orient, position, margin) {
    var align = 'left';
    var vAlign = 'top';
    var x = point[0];
    var y = point[1];

    if (orient === 'horizontal') {
      y = y + margin;

      if (isCenter) {
        align = 'center';
      }

      if (position === 'start') {
        vAlign = 'bottom';
      }
    } else {
      x = x + margin;

      if (isCenter) {
        vAlign = 'middle';
      }

      if (position === 'start') {
        align = 'right';
      }
    }

    return {
      x: x,
      y: y,
      align: align,
      verticalAlign: vAlign
    };
  }; // render month and year text


  CalendarView.prototype._renderMonthText = function (calendarModel, orient, group) {
    var monthLabel = calendarModel.getModel('monthLabel');

    if (!monthLabel.get('show')) {
      return;
    }

    var nameMap = monthLabel.get('nameMap');
    var margin = monthLabel.get('margin');
    var pos = monthLabel.get('position');
    var align = monthLabel.get('align');
    var termPoints = [this._tlpoints, this._blpoints];

    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_6__.isString(nameMap)) {
      nameMap = MONTH_TEXT[nameMap.toUpperCase()] || [];
    }

    var idx = pos === 'start' ? 0 : 1;
    var axis = orient === 'horizontal' ? 0 : 1;
    margin = pos === 'start' ? -margin : margin;
    var isCenter = align === 'center';

    for (var i = 0; i < termPoints[idx].length - 1; i++) {
      var tmp = termPoints[idx][i].slice();
      var firstDay = this._firstDayOfMonth[i];

      if (isCenter) {
        var firstDayPoints = this._firstDayPoints[i];
        tmp[axis] = (firstDayPoints[axis] + termPoints[0][i + 1][axis]) / 2;
      }

      var formatter = monthLabel.get('formatter');
      var name_1 = nameMap[+firstDay.m - 1];
      var params = {
        yyyy: firstDay.y,
        yy: (firstDay.y + '').slice(2),
        MM: firstDay.m,
        M: +firstDay.m,
        nameMap: name_1
      };

      var content = this._formatterLabel(formatter, params);

      var monthText = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default({
        z2: 30,
        style: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_6__.extend((0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_5__.createTextStyle)(monthLabel, {
          text: content
        }), this._monthTextPositionControl(tmp, isCenter, orient, pos, margin))
      });
      group.add(monthText);
    }
  };

  CalendarView.prototype._weekTextPositionControl = function (point, orient, position, margin, cellSize) {
    var align = 'center';
    var vAlign = 'middle';
    var x = point[0];
    var y = point[1];
    var isStart = position === 'start';

    if (orient === 'horizontal') {
      x = x + margin + (isStart ? 1 : -1) * cellSize[0] / 2;
      align = isStart ? 'right' : 'left';
    } else {
      y = y + margin + (isStart ? 1 : -1) * cellSize[1] / 2;
      vAlign = isStart ? 'bottom' : 'top';
    }

    return {
      x: x,
      y: y,
      align: align,
      verticalAlign: vAlign
    };
  }; // render weeks


  CalendarView.prototype._renderWeekText = function (calendarModel, rangeData, orient, group) {
    var dayLabel = calendarModel.getModel('dayLabel');

    if (!dayLabel.get('show')) {
      return;
    }

    var coordSys = calendarModel.coordinateSystem;
    var pos = dayLabel.get('position');
    var nameMap = dayLabel.get('nameMap');
    var margin = dayLabel.get('margin');
    var firstDayOfWeek = coordSys.getFirstDayOfWeek();

    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_6__.isString(nameMap)) {
      nameMap = WEEK_TEXT[nameMap.toUpperCase()] || [];
    }

    var start = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time;
    var cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];
    margin = _util_number__WEBPACK_IMPORTED_MODULE_7__.parsePercent(margin, cellSize[orient === 'horizontal' ? 0 : 1]);

    if (pos === 'start') {
      start = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time;
      margin = -margin;
    }

    for (var i = 0; i < 7; i++) {
      var tmpD = coordSys.getNextNDay(start, i);
      var point = coordSys.dataToRect([tmpD.time], false).center;
      var day = i;
      day = Math.abs((i + firstDayOfWeek) % 7);
      var weekText = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default({
        z2: 30,
        style: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_6__.extend((0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_5__.createTextStyle)(dayLabel, {
          text: nameMap[day]
        }), this._weekTextPositionControl(point, orient, pos, margin, cellSize))
      });
      group.add(weekText);
    }
  };

  CalendarView.type = 'calendar';
  return CalendarView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_8__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalendarView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/calendar/install.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/calendar/install.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _coord_calendar_CalendarModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../coord/calendar/CalendarModel */ "./node_modules/echarts/lib/coord/calendar/CalendarModel.js");
/* harmony import */ var _CalendarView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CalendarView */ "./node_modules/echarts/lib/component/calendar/CalendarView.js");
/* harmony import */ var _coord_calendar_Calendar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../coord/calendar/Calendar */ "./node_modules/echarts/lib/coord/calendar/Calendar.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function install(registers) {
  registers.registerComponentModel(_coord_calendar_CalendarModel__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerComponentView(_CalendarView__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerCoordinateSystem('calendar', _coord_calendar_Calendar__WEBPACK_IMPORTED_MODULE_2__.default);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/AxisProxy.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/AxisProxy.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _helper_sliderMove__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helper/sliderMove */ "./node_modules/echarts/lib/component/helper/sliderMove.js");
/* harmony import */ var _coord_axisHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../coord/axisHelper */ "./node_modules/echarts/lib/coord/axisHelper.js");
/* harmony import */ var _coord_scaleRawExtentInfo__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../coord/scaleRawExtentInfo */ "./node_modules/echarts/lib/coord/scaleRawExtentInfo.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helper */ "./node_modules/echarts/lib/component/dataZoom/helper.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







var each = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each;
var asc = _util_number__WEBPACK_IMPORTED_MODULE_1__.asc;
/**
 * Operate single axis.
 * One axis can only operated by one axis operator.
 * Different dataZoomModels may be defined to operate the same axis.
 * (i.e. 'inside' data zoom and 'slider' data zoom components)
 * So dataZoomModels share one axisProxy in that case.
 */

var AxisProxy =
/** @class */
function () {
  function AxisProxy(dimName, axisIndex, dataZoomModel, ecModel) {
    this._dimName = dimName;
    this._axisIndex = axisIndex;
    this.ecModel = ecModel;
    this._dataZoomModel = dataZoomModel; // /**
    //  * @readOnly
    //  * @private
    //  */
    // this.hasSeriesStacked;
  }
  /**
   * Whether the axisProxy is hosted by dataZoomModel.
   */


  AxisProxy.prototype.hostedBy = function (dataZoomModel) {
    return this._dataZoomModel === dataZoomModel;
  };
  /**
   * @return Value can only be NaN or finite value.
   */


  AxisProxy.prototype.getDataValueWindow = function () {
    return this._valueWindow.slice();
  };
  /**
   * @return {Array.<number>}
   */


  AxisProxy.prototype.getDataPercentWindow = function () {
    return this._percentWindow.slice();
  };

  AxisProxy.prototype.getTargetSeriesModels = function () {
    var seriesModels = [];
    this.ecModel.eachSeries(function (seriesModel) {
      if ((0,_helper__WEBPACK_IMPORTED_MODULE_2__.isCoordSupported)(seriesModel)) {
        var axisMainType = (0,_helper__WEBPACK_IMPORTED_MODULE_2__.getAxisMainType)(this._dimName);
        var axisModel = seriesModel.getReferringComponents(axisMainType, _util_model__WEBPACK_IMPORTED_MODULE_3__.SINGLE_REFERRING).models[0];

        if (axisModel && this._axisIndex === axisModel.componentIndex) {
          seriesModels.push(seriesModel);
        }
      }
    }, this);
    return seriesModels;
  };

  AxisProxy.prototype.getAxisModel = function () {
    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);
  };

  AxisProxy.prototype.getMinMaxSpan = function () {
    return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.clone(this._minMaxSpan);
  };
  /**
   * Only calculate by given range and this._dataExtent, do not change anything.
   */


  AxisProxy.prototype.calculateDataWindow = function (opt) {
    var dataExtent = this._dataExtent;
    var axisModel = this.getAxisModel();
    var scale = axisModel.axis.scale;

    var rangePropMode = this._dataZoomModel.getRangePropMode();

    var percentExtent = [0, 100];
    var percentWindow = [];
    var valueWindow = [];
    var hasPropModeValue;
    each(['start', 'end'], function (prop, idx) {
      var boundPercent = opt[prop];
      var boundValue = opt[prop + 'Value']; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or
      // on `valueProp` ('startValue', 'endValue'). (They are based on the data extent
      // but not min/max of axis, which will be calculated by data window then).
      // The former one is suitable for cases that a dataZoom component controls multiple
      // axes with different unit or extent, and the latter one is suitable for accurate
      // zoom by pixel (e.g., in dataZoomSelect).
      // we use `getRangePropMode()` to mark which prop is used. `rangePropMode` is updated
      // only when setOption or dispatchAction, otherwise it remains its original value.
      // (Why not only record `percentProp` and always map to `valueProp`? Because
      // the map `valueProp` -> `percentProp` -> `valueProp` probably not the original
      // `valueProp`. consider two axes constrolled by one dataZoom. They have different
      // data extent. All of values that are overflow the `dataExtent` will be calculated
      // to percent '100%').

      if (rangePropMode[idx] === 'percent') {
        boundPercent == null && (boundPercent = percentExtent[idx]); // Use scale.parse to math round for category or time axis.

        boundValue = scale.parse(_util_number__WEBPACK_IMPORTED_MODULE_1__.linearMap(boundPercent, percentExtent, dataExtent));
      } else {
        hasPropModeValue = true;
        boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue); // Calculating `percent` from `value` may be not accurate, because
        // This calculation can not be inversed, because all of values that
        // are overflow the `dataExtent` will be calculated to percent '100%'

        boundPercent = _util_number__WEBPACK_IMPORTED_MODULE_1__.linearMap(boundValue, dataExtent, percentExtent);
      } // valueWindow[idx] = round(boundValue);
      // percentWindow[idx] = round(boundPercent);


      valueWindow[idx] = boundValue;
      percentWindow[idx] = boundPercent;
    });
    asc(valueWindow);
    asc(percentWindow); // The windows from user calling of `dispatchAction` might be out of the extent,
    // or do not obey the `min/maxSpan`, `min/maxValueSpan`. But we dont restrict window
    // by `zoomLock` here, because we see `zoomLock` just as a interaction constraint,
    // where API is able to initialize/modify the window size even though `zoomLock`
    // specified.

    var spans = this._minMaxSpan;
    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);

    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {
      var suffix = toValue ? 'Span' : 'ValueSpan';
      (0,_helper_sliderMove__WEBPACK_IMPORTED_MODULE_4__.default)(0, fromWindow, fromExtent, 'all', spans['min' + suffix], spans['max' + suffix]);

      for (var i = 0; i < 2; i++) {
        toWindow[i] = _util_number__WEBPACK_IMPORTED_MODULE_1__.linearMap(fromWindow[i], fromExtent, toExtent, true);
        toValue && (toWindow[i] = scale.parse(toWindow[i]));
      }
    }

    return {
      valueWindow: valueWindow,
      percentWindow: percentWindow
    };
  };
  /**
   * Notice: reset should not be called before series.restoreData() called,
   * so it is recommanded to be called in "process stage" but not "model init
   * stage".
   */


  AxisProxy.prototype.reset = function (dataZoomModel) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }

    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.

    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // this.hasSeriesStacked = false;
    // each(targetSeries, function (series) {
    // let data = series.getData();
    // let dataDim = data.mapDimension(this._dimName);
    // let stackedDimension = data.getCalculationInfo('stackedDimension');
    // if (stackedDimension && stackedDimension === dataDim) {
    // this.hasSeriesStacked = true;
    // }
    // }, this);
    // `calculateDataWindow` uses min/maxSpan.

    this._updateMinMaxSpan();

    var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);
    this._valueWindow = dataWindow.valueWindow;
    this._percentWindow = dataWindow.percentWindow; // Update axis setting then.

    this._setAxisModel();
  };

  AxisProxy.prototype.filterData = function (dataZoomModel, api) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }

    var axisDim = this._dimName;
    var seriesModels = this.getTargetSeriesModels();
    var filterMode = dataZoomModel.get('filterMode');
    var valueWindow = this._valueWindow;

    if (filterMode === 'none') {
      return;
    } // FIXME
    // Toolbox may has dataZoom injected. And if there are stacked bar chart
    // with NaN data, NaN will be filtered and stack will be wrong.
    // So we need to force the mode to be set empty.
    // In fect, it is not a big deal that do not support filterMode-'filter'
    // when using toolbox#dataZoom, utill tooltip#dataZoom support "single axis
    // selection" some day, which might need "adapt to data extent on the
    // otherAxis", which is disabled by filterMode-'empty'.
    // But currently, stack has been fixed to based on value but not index,
    // so this is not an issue any more.
    // let otherAxisModel = this.getOtherAxisModel();
    // if (dataZoomModel.get('$fromToolbox')
    //     && otherAxisModel
    //     && otherAxisModel.hasSeriesStacked
    // ) {
    //     filterMode = 'empty';
    // }
    // TODO
    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.


    each(seriesModels, function (seriesModel) {
      var seriesData = seriesModel.getData();
      var dataDims = seriesData.mapDimensionsAll(axisDim);

      if (!dataDims.length) {
        return;
      }

      if (filterMode === 'weakFilter') {
        seriesData.filterSelf(function (dataIndex) {
          var leftOut;
          var rightOut;
          var hasValue;

          for (var i = 0; i < dataDims.length; i++) {
            var value = seriesData.get(dataDims[i], dataIndex);
            var thisHasValue = !isNaN(value);
            var thisLeftOut = value < valueWindow[0];
            var thisRightOut = value > valueWindow[1];

            if (thisHasValue && !thisLeftOut && !thisRightOut) {
              return true;
            }

            thisHasValue && (hasValue = true);
            thisLeftOut && (leftOut = true);
            thisRightOut && (rightOut = true);
          } // If both left out and right out, do not filter.


          return hasValue && leftOut && rightOut;
        });
      } else {
        each(dataDims, function (dim) {
          if (filterMode === 'empty') {
            seriesModel.setData(seriesData = seriesData.map(dim, function (value) {
              return !isInWindow(value) ? NaN : value;
            }));
          } else {
            var range = {};
            range[dim] = valueWindow; // console.time('select');

            seriesData.selectRange(range); // console.timeEnd('select');
          }
        });
      }

      each(dataDims, function (dim) {
        seriesData.setApproximateExtent(valueWindow, dim);
      });
    });

    function isInWindow(value) {
      return value >= valueWindow[0] && value <= valueWindow[1];
    }
  };

  AxisProxy.prototype._updateMinMaxSpan = function () {
    var minMaxSpan = this._minMaxSpan = {};
    var dataZoomModel = this._dataZoomModel;
    var dataExtent = this._dataExtent;
    each(['min', 'max'], function (minMax) {
      var percentSpan = dataZoomModel.get(minMax + 'Span');
      var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');
      valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan)); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan

      if (valueSpan != null) {
        percentSpan = _util_number__WEBPACK_IMPORTED_MODULE_1__.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
      } else if (percentSpan != null) {
        valueSpan = _util_number__WEBPACK_IMPORTED_MODULE_1__.linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];
      }

      minMaxSpan[minMax + 'Span'] = percentSpan;
      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;
    }, this);
  };

  AxisProxy.prototype._setAxisModel = function () {
    var axisModel = this.getAxisModel();
    var percentWindow = this._percentWindow;
    var valueWindow = this._valueWindow;

    if (!percentWindow) {
      return;
    } // [0, 500]: arbitrary value, guess axis extent.


    var precision = _util_number__WEBPACK_IMPORTED_MODULE_1__.getPixelPrecision(valueWindow, [0, 500]);
    precision = Math.min(precision, 20); // For value axis, if min/max/scale are not set, we just use the extent obtained
    // by series data, which may be a little different from the extent calculated by
    // `axisHelper.getScaleExtent`. But the different just affects the experience a
    // little when zooming. So it will not be fixed until some users require it strongly.

    var rawExtentInfo = axisModel.axis.scale.rawExtentInfo;

    if (percentWindow[0] !== 0) {
      rawExtentInfo.setDeterminedMinMax('min', +valueWindow[0].toFixed(precision));
    }

    if (percentWindow[1] !== 100) {
      rawExtentInfo.setDeterminedMinMax('max', +valueWindow[1].toFixed(precision));
    }

    rawExtentInfo.freeze();
  };

  return AxisProxy;
}();

function calculateDataExtent(axisProxy, axisDim, seriesModels) {
  var dataExtent = [Infinity, -Infinity];
  each(seriesModels, function (seriesModel) {
    (0,_coord_axisHelper__WEBPACK_IMPORTED_MODULE_5__.unionAxisExtentFromData)(dataExtent, seriesModel.getData(), axisDim);
  }); // It is important to get "consistent" extent when more then one axes is
  // controlled by a `dataZoom`, otherwise those axes will not be synchronized
  // when zooming. But it is difficult to know what is "consistent", considering
  // axes have different type or even different meanings (For example, two
  // time axes are used to compare data of the same date in different years).
  // So basically dataZoom just obtains extent by series.data (in category axis
  // extent can be obtained from axis.data).
  // Nevertheless, user can set min/max/scale on axes to make extent of axes
  // consistent.

  var axisModel = axisProxy.getAxisModel();
  var rawExtentResult = (0,_coord_scaleRawExtentInfo__WEBPACK_IMPORTED_MODULE_6__.ensureScaleRawExtentInfo)(axisModel.axis.scale, axisModel, dataExtent).calculate();
  return [rawExtentResult.min, rawExtentResult.max];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxisProxy);

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js":
/*!**********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helper */ "./node_modules/echarts/lib/component/dataZoom/helper.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var DataZoomAxisInfo =
/** @class */
function () {
  function DataZoomAxisInfo() {
    this.indexList = [];
    this.indexMap = [];
  }

  DataZoomAxisInfo.prototype.add = function (axisCmptIdx) {
    // Remove duplication.
    if (!this.indexMap[axisCmptIdx]) {
      this.indexList.push(axisCmptIdx);
      this.indexMap[axisCmptIdx] = true;
    }
  };

  return DataZoomAxisInfo;
}();

var DataZoomModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(DataZoomModel, _super);

  function DataZoomModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = DataZoomModel.type;
    _this._autoThrottle = true;
    _this._noTarget = true;
    /**
     * It is `[rangeModeForMin, rangeModeForMax]`.
     * The optional values for `rangeMode`:
     * + `'value'` mode: the axis extent will always be determined by
     *     `dataZoom.startValue` and `dataZoom.endValue`, despite
     *     how data like and how `axis.min` and `axis.max` are.
     * + `'percent'` mode: `100` represents 100% of the `[dMin, dMax]`,
     *     where `dMin` is `axis.min` if `axis.min` specified, otherwise `data.extent[0]`,
     *     and `dMax` is `axis.max` if `axis.max` specified, otherwise `data.extent[1]`.
     *     Axis extent will be determined by the result of the percent of `[dMin, dMax]`.
     *
     * For example, when users are using dynamic data (update data periodically via `setOption`),
     * if in `'value`' mode, the window will be kept in a fixed value range despite how
     * data are appended, while if in `'percent'` mode, whe window range will be changed alone with
     * the appended data (suppose `axis.min` and `axis.max` are not specified).
     */

    _this._rangePropMode = ['percent', 'percent'];
    return _this;
  }

  DataZoomModel.prototype.init = function (option, parentModel, ecModel) {
    var inputRawOption = retrieveRawOption(option);
    /**
     * Suppose a "main process" start at the point that model prepared (that is,
     * model initialized or merged or method called in `action`).
     * We should keep the `main process` idempotent, that is, given a set of values
     * on `option`, we get the same result.
     *
     * But sometimes, values on `option` will be updated for providing users
     * a "final calculated value" (`dataZoomProcessor` will do that). Those value
     * should not be the base/input of the `main process`.
     *
     * So in that case we should save and keep the input of the `main process`
     * separately, called `settledOption`.
     *
     * For example, consider the case:
     * (Step_1) brush zoom the grid by `toolbox.dataZoom`,
     *     where the original input `option.startValue`, `option.endValue` are earsed by
     *     calculated value.
     * (Step)2) click the legend to hide and show a series,
     *     where the new range is calculated by the earsed `startValue` and `endValue`,
     *     which brings incorrect result.
     */

    this.settledOption = inputRawOption;
    this.mergeDefaultAndTheme(option, ecModel);

    this._doInit(inputRawOption);
  };

  DataZoomModel.prototype.mergeOption = function (newOption) {
    var inputRawOption = retrieveRawOption(newOption); //FIX #2591

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge)(this.option, newOption, true);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge)(this.settledOption, inputRawOption, true);

    this._doInit(inputRawOption);
  };

  DataZoomModel.prototype._doInit = function (inputRawOption) {
    var thisOption = this.option; // if (!env.canvasSupported) {
    //     thisOption.realtime = false;
    // }

    this._setDefaultThrottle(inputRawOption);

    this._updateRangeUse(inputRawOption);

    var settledOption = this.settledOption;
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
      // start/end has higher priority over startValue/endValue if they
      // both set, but we should make chart.setOption({endValue: 1000})
      // effective, rather than chart.setOption({endValue: 1000, end: null}).
      if (this._rangePropMode[index] === 'value') {
        thisOption[names[0]] = settledOption[names[0]] = null;
      } // Otherwise do nothing and use the merge result.

    }, this);

    this._resetTarget();
  };

  DataZoomModel.prototype._resetTarget = function () {
    var optionOrient = this.get('orient', true);
    var targetAxisIndexMap = this._targetAxisInfoMap = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.createHashMap)();

    var hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap);

    if (hasAxisSpecified) {
      this._orient = optionOrient || this._makeAutoOrientByTargetAxis();
    } else {
      this._orient = optionOrient || 'horizontal';

      this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);
    }

    this._noTarget = true;
    targetAxisIndexMap.each(function (axisInfo) {
      if (axisInfo.indexList.length) {
        this._noTarget = false;
      }
    }, this);
  };

  DataZoomModel.prototype._fillSpecifiedTargetAxis = function (targetAxisIndexMap) {
    var hasAxisSpecified = false;
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(_helper__WEBPACK_IMPORTED_MODULE_2__.DATA_ZOOM_AXIS_DIMENSIONS, function (axisDim) {
      var refering = this.getReferringComponents((0,_helper__WEBPACK_IMPORTED_MODULE_2__.getAxisMainType)(axisDim), _util_model__WEBPACK_IMPORTED_MODULE_3__.MULTIPLE_REFERRING); // When user set axisIndex as a empty array, we think that user specify axisIndex
      // but do not want use auto mode. Because empty array may be encountered when
      // some error occured.

      if (!refering.specified) {
        return;
      }

      hasAxisSpecified = true;
      var axisInfo = new DataZoomAxisInfo();
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(refering.models, function (axisModel) {
        axisInfo.add(axisModel.componentIndex);
      });
      targetAxisIndexMap.set(axisDim, axisInfo);
    }, this);
    return hasAxisSpecified;
  };

  DataZoomModel.prototype._fillAutoTargetAxisByOrient = function (targetAxisIndexMap, orient) {
    var ecModel = this.ecModel;
    var needAuto = true; // Find axis that parallel to dataZoom as default.

    if (needAuto) {
      var axisDim = orient === 'vertical' ? 'y' : 'x';
      var axisModels = ecModel.findComponents({
        mainType: axisDim + 'Axis'
      });
      setParallelAxis(axisModels, axisDim);
    } // Find axis that parallel to dataZoom as default.


    if (needAuto) {
      var axisModels = ecModel.findComponents({
        mainType: 'singleAxis',
        filter: function (axisModel) {
          return axisModel.get('orient', true) === orient;
        }
      });
      setParallelAxis(axisModels, 'single');
    }

    function setParallelAxis(axisModels, axisDim) {
      // At least use the first parallel axis as the target axis.
      var axisModel = axisModels[0];

      if (!axisModel) {
        return;
      }

      var axisInfo = new DataZoomAxisInfo();
      axisInfo.add(axisModel.componentIndex);
      targetAxisIndexMap.set(axisDim, axisInfo);
      needAuto = false; // Find parallel axes in the same grid.

      if (axisDim === 'x' || axisDim === 'y') {
        var gridModel_1 = axisModel.getReferringComponents('grid', _util_model__WEBPACK_IMPORTED_MODULE_3__.SINGLE_REFERRING).models[0];
        gridModel_1 && (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(axisModels, function (axModel) {
          if (axisModel.componentIndex !== axModel.componentIndex && gridModel_1 === axModel.getReferringComponents('grid', _util_model__WEBPACK_IMPORTED_MODULE_3__.SINGLE_REFERRING).models[0]) {
            axisInfo.add(axModel.componentIndex);
          }
        });
      }
    }

    if (needAuto) {
      // If no parallel axis, find the first category axis as default. (Also consider polar).
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(_helper__WEBPACK_IMPORTED_MODULE_2__.DATA_ZOOM_AXIS_DIMENSIONS, function (axisDim) {
        if (!needAuto) {
          return;
        }

        var axisModels = ecModel.findComponents({
          mainType: (0,_helper__WEBPACK_IMPORTED_MODULE_2__.getAxisMainType)(axisDim),
          filter: function (axisModel) {
            return axisModel.get('type', true) === 'category';
          }
        });

        if (axisModels[0]) {
          var axisInfo = new DataZoomAxisInfo();
          axisInfo.add(axisModels[0].componentIndex);
          targetAxisIndexMap.set(axisDim, axisInfo);
          needAuto = false;
        }
      }, this);
    }
  };

  DataZoomModel.prototype._makeAutoOrientByTargetAxis = function () {
    var dim; // Find the first axis

    this.eachTargetAxis(function (axisDim) {
      !dim && (dim = axisDim);
    }, this);
    return dim === 'y' ? 'vertical' : 'horizontal';
  };

  DataZoomModel.prototype._setDefaultThrottle = function (inputRawOption) {
    // When first time user set throttle, auto throttle ends.
    if (inputRawOption.hasOwnProperty('throttle')) {
      this._autoThrottle = false;
    }

    if (this._autoThrottle) {
      var globalOption = this.ecModel.option;
      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
    }
  };

  DataZoomModel.prototype._updateRangeUse = function (inputRawOption) {
    var rangePropMode = this._rangePropMode;
    var rangeModeInOption = this.get('rangeMode');
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
      var percentSpecified = inputRawOption[names[0]] != null;
      var valueSpecified = inputRawOption[names[1]] != null;

      if (percentSpecified && !valueSpecified) {
        rangePropMode[index] = 'percent';
      } else if (!percentSpecified && valueSpecified) {
        rangePropMode[index] = 'value';
      } else if (rangeModeInOption) {
        rangePropMode[index] = rangeModeInOption[index];
      } else if (percentSpecified) {
        // percentSpecified && valueSpecified
        rangePropMode[index] = 'percent';
      } // else remain its original setting.

    });
  };

  DataZoomModel.prototype.noTarget = function () {
    return this._noTarget;
  };

  DataZoomModel.prototype.getFirstTargetAxisModel = function () {
    var firstAxisModel;
    this.eachTargetAxis(function (axisDim, axisIndex) {
      if (firstAxisModel == null) {
        firstAxisModel = this.ecModel.getComponent((0,_helper__WEBPACK_IMPORTED_MODULE_2__.getAxisMainType)(axisDim), axisIndex);
      }
    }, this);
    return firstAxisModel;
  };
  /**
   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel
   */


  DataZoomModel.prototype.eachTargetAxis = function (callback, context) {
    this._targetAxisInfoMap.each(function (axisInfo, axisDim) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(axisInfo.indexList, function (axisIndex) {
        callback.call(context, axisDim, axisIndex);
      });
    });
  };
  /**
   * @return If not found, return null/undefined.
   */


  DataZoomModel.prototype.getAxisProxy = function (axisDim, axisIndex) {
    var axisModel = this.getAxisModel(axisDim, axisIndex);

    if (axisModel) {
      return axisModel.__dzAxisProxy;
    }
  };
  /**
   * @return If not found, return null/undefined.
   */


  DataZoomModel.prototype.getAxisModel = function (axisDim, axisIndex) {
    if (true) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)(axisDim && axisIndex != null);
    }

    var axisInfo = this._targetAxisInfoMap.get(axisDim);

    if (axisInfo && axisInfo.indexMap[axisIndex]) {
      return this.ecModel.getComponent((0,_helper__WEBPACK_IMPORTED_MODULE_2__.getAxisMainType)(axisDim), axisIndex);
    }
  };
  /**
   * If not specified, set to undefined.
   */


  DataZoomModel.prototype.setRawRange = function (opt) {
    var thisOption = this.option;
    var settledOption = this.settledOption;
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)([['start', 'startValue'], ['end', 'endValue']], function (names) {
      // Consider the pair <start, startValue>:
      // If one has value and the other one is `null/undefined`, we both set them
      // to `settledOption`. This strategy enables the feature to clear the original
      // value in `settledOption` to `null/undefined`.
      // But if both of them are `null/undefined`, we do not set them to `settledOption`
      // and keep `settledOption` with the original value. This strategy enables users to
      // only set <end or endValue> but not set <start or startValue> when calling
      // `dispatchAction`.
      // The pair <end, endValue> is treated in the same way.
      if (opt[names[0]] != null || opt[names[1]] != null) {
        thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];
        thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];
      }
    }, this);

    this._updateRangeUse(opt);
  };

  DataZoomModel.prototype.setCalculatedRange = function (opt) {
    var option = this.option;
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(['start', 'startValue', 'end', 'endValue'], function (name) {
      option[name] = opt[name];
    });
  };

  DataZoomModel.prototype.getPercentRange = function () {
    var axisProxy = this.findRepresentativeAxisProxy();

    if (axisProxy) {
      return axisProxy.getDataPercentWindow();
    }
  };
  /**
   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);
   *
   * @return [startValue, endValue] value can only be '-' or finite number.
   */


  DataZoomModel.prototype.getValueRange = function (axisDim, axisIndex) {
    if (axisDim == null && axisIndex == null) {
      var axisProxy = this.findRepresentativeAxisProxy();

      if (axisProxy) {
        return axisProxy.getDataValueWindow();
      }
    } else {
      return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();
    }
  };
  /**
   * @param axisModel If axisModel given, find axisProxy
   *      corresponding to the axisModel
   */


  DataZoomModel.prototype.findRepresentativeAxisProxy = function (axisModel) {
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    } // Find the first hosted axisProxy


    var firstProxy;

    var axisDimList = this._targetAxisInfoMap.keys();

    for (var i = 0; i < axisDimList.length; i++) {
      var axisDim = axisDimList[i];

      var axisInfo = this._targetAxisInfoMap.get(axisDim);

      for (var j = 0; j < axisInfo.indexList.length; j++) {
        var proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j]);

        if (proxy.hostedBy(this)) {
          return proxy;
        }

        if (!firstProxy) {
          firstProxy = proxy;
        }
      }
    } // If no hosted proxy found, still need to return a proxy.
    // This case always happens in toolbox dataZoom, where axes are all hosted by
    // other dataZooms.


    return firstProxy;
  };

  DataZoomModel.prototype.getRangePropMode = function () {
    return this._rangePropMode.slice();
  };

  DataZoomModel.prototype.getOrient = function () {
    if (true) {
      // Should not be called before initialized.
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this._orient);
    }

    return this._orient;
  };

  DataZoomModel.type = 'dataZoom';
  DataZoomModel.dependencies = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series', 'toolbox'];
  DataZoomModel.defaultOption = {
    zlevel: 0,
    z: 4,
    filterMode: 'filter',
    start: 0,
    end: 100
  };
  return DataZoomModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_4__.default);
/**
 * Retrieve the those raw params from option, which will be cached separately.
 * becasue they will be overwritten by normalized/calculated values in the main
 * process.
 */


function retrieveRawOption(option) {
  var ret = {};
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {
    option.hasOwnProperty(name) && (ret[name] = option[name]);
  });
  return ret;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataZoomModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/DataZoomView.js":
/*!*********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/DataZoomView.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var DataZoomView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(DataZoomView, _super);

  function DataZoomView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = DataZoomView.type;
    return _this;
  }

  DataZoomView.prototype.render = function (dataZoomModel, ecModel, api, payload) {
    this.dataZoomModel = dataZoomModel;
    this.ecModel = ecModel;
    this.api = api;
  };

  DataZoomView.type = 'dataZoom';
  return DataZoomView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataZoomView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js":
/*!************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _DataZoomModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DataZoomModel */ "./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js");
/* harmony import */ var _util_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/component */ "./node_modules/echarts/lib/util/component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var InsideZoomModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(InsideZoomModel, _super);

  function InsideZoomModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = InsideZoomModel.type;
    return _this;
  }

  InsideZoomModel.type = 'dataZoom.inside';
  InsideZoomModel.defaultOption = (0,_util_component__WEBPACK_IMPORTED_MODULE_1__.inheritDefaultOption)(_DataZoomModel__WEBPACK_IMPORTED_MODULE_2__.default.defaultOption, {
    disabled: false,
    zoomLock: false,
    zoomOnMouseWheel: true,
    moveOnMouseMove: true,
    moveOnMouseWheel: false,
    preventDefaultMouseMove: true
  });
  return InsideZoomModel;
}(_DataZoomModel__WEBPACK_IMPORTED_MODULE_2__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InsideZoomModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _DataZoomView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DataZoomView */ "./node_modules/echarts/lib/component/dataZoom/DataZoomView.js");
/* harmony import */ var _helper_sliderMove__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helper/sliderMove */ "./node_modules/echarts/lib/component/helper/sliderMove.js");
/* harmony import */ var _roams__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./roams */ "./node_modules/echarts/lib/component/dataZoom/roams.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var InsideZoomView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(InsideZoomView, _super);

  function InsideZoomView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'dataZoom.inside';
    return _this;
  }

  InsideZoomView.prototype.render = function (dataZoomModel, ecModel, api) {
    _super.prototype.render.apply(this, arguments);

    if (dataZoomModel.noTarget()) {
      this._clear();

      return;
    } // Hence the `throttle` util ensures to preserve command order,
    // here simply updating range all the time will not cause missing
    // any of the the roam change.


    this.range = dataZoomModel.getPercentRange(); // Reset controllers.

    _roams__WEBPACK_IMPORTED_MODULE_1__.setViewInfoToCoordSysRecord(api, dataZoomModel, {
      pan: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(getRangeHandlers.pan, this),
      zoom: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(getRangeHandlers.zoom, this),
      scrollMove: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(getRangeHandlers.scrollMove, this)
    });
  };

  InsideZoomView.prototype.dispose = function () {
    this._clear();

    _super.prototype.dispose.apply(this, arguments);
  };

  InsideZoomView.prototype._clear = function () {
    _roams__WEBPACK_IMPORTED_MODULE_1__.disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel);
    this.range = null;
  };

  InsideZoomView.type = 'dataZoom.inside';
  return InsideZoomView;
}(_DataZoomView__WEBPACK_IMPORTED_MODULE_3__.default);

var getRangeHandlers = {
  zoom: function (coordSysInfo, coordSysMainType, controller, e) {
    var lastRange = this.range;
    var range = lastRange.slice(); // Calculate transform by the first axis.

    var axisModel = coordSysInfo.axisModels[0];

    if (!axisModel) {
      return;
    }

    var directionInfo = getDirectionInfo[coordSysMainType](null, [e.originX, e.originY], axisModel, controller, coordSysInfo);
    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
    var scale = Math.max(1 / e.scale, 0);
    range[0] = (range[0] - percentPoint) * scale + percentPoint;
    range[1] = (range[1] - percentPoint) * scale + percentPoint; // Restrict range.

    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    (0,_helper_sliderMove__WEBPACK_IMPORTED_MODULE_4__.default)(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
    this.range = range;

    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
      return range;
    }
  },
  pan: makeMover(function (range, axisModel, coordSysInfo, coordSysMainType, controller, e) {
    var directionInfo = getDirectionInfo[coordSysMainType]([e.oldX, e.oldY], [e.newX, e.newY], axisModel, controller, coordSysInfo);
    return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
  }),
  scrollMove: makeMover(function (range, axisModel, coordSysInfo, coordSysMainType, controller, e) {
    var directionInfo = getDirectionInfo[coordSysMainType]([0, 0], [e.scrollDelta, e.scrollDelta], axisModel, controller, coordSysInfo);
    return directionInfo.signal * (range[1] - range[0]) * e.scrollDelta;
  })
};

function makeMover(getPercentDelta) {
  return function (coordSysInfo, coordSysMainType, controller, e) {
    var lastRange = this.range;
    var range = lastRange.slice(); // Calculate transform by the first axis.

    var axisModel = coordSysInfo.axisModels[0];

    if (!axisModel) {
      return;
    }

    var percentDelta = getPercentDelta(range, axisModel, coordSysInfo, coordSysMainType, controller, e);
    (0,_helper_sliderMove__WEBPACK_IMPORTED_MODULE_4__.default)(percentDelta, range, [0, 100], 'all');
    this.range = range;

    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
      return range;
    }
  };
}

var getDirectionInfo = {
  grid: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    var axis = axisModel.axis;
    var ret = {};
    var rect = coordSysInfo.model.coordinateSystem.getRect();
    oldPoint = oldPoint || [0, 0];

    if (axis.dim === 'x') {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      // axis.dim === 'y'
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }

    return ret;
  },
  polar: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    var axis = axisModel.axis;
    var ret = {};
    var polar = coordSysInfo.model.coordinateSystem;
    var radiusExtent = polar.getRadiusAxis().getExtent();
    var angleExtent = polar.getAngleAxis().getExtent();
    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
    newPoint = polar.pointToCoord(newPoint);

    if (axisModel.mainType === 'radiusAxis') {
      ret.pixel = newPoint[0] - oldPoint[0]; // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);
      // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);

      ret.pixelLength = radiusExtent[1] - radiusExtent[0];
      ret.pixelStart = radiusExtent[0];
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      // 'angleAxis'
      ret.pixel = newPoint[1] - oldPoint[1]; // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);
      // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);

      ret.pixelLength = angleExtent[1] - angleExtent[0];
      ret.pixelStart = angleExtent[0];
      ret.signal = axis.inverse ? -1 : 1;
    }

    return ret;
  },
  singleAxis: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    var axis = axisModel.axis;
    var rect = coordSysInfo.model.coordinateSystem.getRect();
    var ret = {};
    oldPoint = oldPoint || [0, 0];

    if (axis.orient === 'horizontal') {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      // 'vertical'
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }

    return ret;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InsideZoomView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js":
/*!************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _DataZoomModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DataZoomModel */ "./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var SelectDataZoomModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SelectDataZoomModel, _super);

  function SelectDataZoomModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = SelectDataZoomModel.type;
    return _this;
  }

  SelectDataZoomModel.type = 'dataZoom.select';
  return SelectDataZoomModel;
}(_DataZoomModel__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SelectDataZoomModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/SelectZoomView.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/SelectZoomView.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _DataZoomView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DataZoomView */ "./node_modules/echarts/lib/component/dataZoom/DataZoomView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var SelectDataZoomView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SelectDataZoomView, _super);

  function SelectDataZoomView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = SelectDataZoomView.type;
    return _this;
  }

  SelectDataZoomView.type = 'dataZoom.select';
  return SelectDataZoomView;
}(_DataZoomView__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SelectDataZoomView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js":
/*!************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _DataZoomModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DataZoomModel */ "./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js");
/* harmony import */ var _util_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/component */ "./node_modules/echarts/lib/util/component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var SliderZoomModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SliderZoomModel, _super);

  function SliderZoomModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = SliderZoomModel.type;
    return _this;
  }

  SliderZoomModel.type = 'dataZoom.slider';
  SliderZoomModel.layoutMode = 'box';
  SliderZoomModel.defaultOption = (0,_util_component__WEBPACK_IMPORTED_MODULE_1__.inheritDefaultOption)(_DataZoomModel__WEBPACK_IMPORTED_MODULE_2__.default.defaultOption, {
    show: true,
    // deault value can only be drived in view stage.
    right: 'ph',
    top: 'ph',
    width: 'ph',
    height: 'ph',
    left: null,
    bottom: null,
    borderColor: '#d2dbee',
    borderRadius: 3,
    backgroundColor: 'rgba(47,69,84,0)',
    // dataBackgroundColor: '#ddd',
    dataBackground: {
      lineStyle: {
        color: '#d2dbee',
        width: 0.5
      },
      areaStyle: {
        color: '#d2dbee',
        opacity: 0.2
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: '#8fb0f7',
        width: 0.5
      },
      areaStyle: {
        color: '#8fb0f7',
        opacity: 0.2
      }
    },
    // Color of selected window.
    fillerColor: 'rgba(135,175,274,0.2)',
    handleIcon: 'path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z',
    // Percent of the slider height
    handleSize: '100%',
    handleStyle: {
      color: '#fff',
      borderColor: '#ACB8D1'
    },
    moveHandleSize: 7,
    moveHandleIcon: 'path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z',
    moveHandleStyle: {
      color: '#D2DBEE',
      opacity: 0.7
    },
    showDetail: true,
    showDataShadow: 'auto',
    realtime: true,
    zoomLock: false,
    textStyle: {
      color: '#6E7079'
    },
    brushSelect: true,
    brushStyle: {
      color: 'rgba(135,175,274,0.15)'
    },
    emphasis: {
      handleStyle: {
        borderColor: '#8FB0F7'
      },
      moveHandleStyle: {
        color: '#8FB0F7'
      }
    }
  });
  return SliderZoomModel;
}(_DataZoomModel__WEBPACK_IMPORTED_MODULE_2__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SliderZoomModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! zrender/lib/core/event */ "./node_modules/zrender/lib/core/event.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polygon.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polyline.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/core/Point.js");
/* harmony import */ var _util_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/throttle */ "./node_modules/echarts/lib/util/throttle.js");
/* harmony import */ var _DataZoomView__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./DataZoomView */ "./node_modules/echarts/lib/component/dataZoom/DataZoomView.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _helper_sliderMove__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../helper/sliderMove */ "./node_modules/echarts/lib/component/helper/sliderMove.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./helper */ "./node_modules/echarts/lib/component/dataZoom/helper.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _util_symbol__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/symbol */ "./node_modules/echarts/lib/util/symbol.js");
/* harmony import */ var _util_log__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../util/log */ "./node_modules/echarts/lib/util/log.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/













var Rect = _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default; // Constants

var DEFAULT_LOCATION_EDGE_GAP = 7;
var DEFAULT_FRAME_BORDER_WIDTH = 1;
var DEFAULT_FILLER_SIZE = 30;
var DEFAULT_MOVE_HANDLE_SIZE = 7;
var HORIZONTAL = 'horizontal';
var VERTICAL = 'vertical';
var LABEL_GAP = 5;
var SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];
var REALTIME_ANIMATION_CONFIG = {
  easing: 'cubicOut',
  duration: 100
};

var SliderZoomView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(SliderZoomView, _super);

  function SliderZoomView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = SliderZoomView.type;
    _this._displayables = {};
    return _this;
  }

  SliderZoomView.prototype.init = function (ecModel, api) {
    this.api = api; // A unique handler for each dataZoom component

    this._onBrush = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(this._onBrush, this);
    this._onBrushEnd = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(this._onBrushEnd, this);
  };

  SliderZoomView.prototype.render = function (dataZoomModel, ecModel, api, payload) {
    _super.prototype.render.apply(this, arguments);

    _util_throttle__WEBPACK_IMPORTED_MODULE_3__.createOrUpdate(this, '_dispatchZoomAction', dataZoomModel.get('throttle'), 'fixRate');
    this._orient = dataZoomModel.getOrient();

    if (dataZoomModel.get('show') === false) {
      this.group.removeAll();
      return;
    }

    if (dataZoomModel.noTarget()) {
      this._clear();

      this.group.removeAll();
      return;
    } // Notice: this._resetInterval() should not be executed when payload.type
    // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'
    // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,


    if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {
      this._buildView();
    }

    this._updateView();
  };

  SliderZoomView.prototype.dispose = function () {
    this._clear();

    _super.prototype.dispose.apply(this, arguments);
  };

  SliderZoomView.prototype._clear = function () {
    _util_throttle__WEBPACK_IMPORTED_MODULE_3__.clear(this, '_dispatchZoomAction');
    var zr = this.api.getZr();
    zr.off('mousemove', this._onBrush);
    zr.off('mouseup', this._onBrushEnd);
  };

  SliderZoomView.prototype._buildView = function () {
    var thisGroup = this.group;
    thisGroup.removeAll();
    this._brushing = false;
    this._displayables.brushRect = null;

    this._resetLocation();

    this._resetInterval();

    var barGroup = this._displayables.sliderGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default();

    this._renderBackground();

    this._renderHandle();

    this._renderDataShadow();

    thisGroup.add(barGroup);

    this._positionGroup();
  };

  SliderZoomView.prototype._resetLocation = function () {
    var dataZoomModel = this.dataZoomModel;
    var api = this.api;
    var showMoveHandle = dataZoomModel.get('brushSelect');
    var moveHandleSize = showMoveHandle ? DEFAULT_MOVE_HANDLE_SIZE : 0; // If some of x/y/width/height are not specified,
    // auto-adapt according to target grid.

    var coordRect = this._findCoordRect();

    var ecSize = {
      width: api.getWidth(),
      height: api.getHeight()
    }; // Default align by coordinate system rect.

    var positionInfo = this._orient === HORIZONTAL ? {
      // Why using 'right', because right should be used in vertical,
      // and it is better to be consistent for dealing with position param merge.
      right: ecSize.width - coordRect.x - coordRect.width,
      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - moveHandleSize,
      width: coordRect.width,
      height: DEFAULT_FILLER_SIZE
    } : {
      right: DEFAULT_LOCATION_EDGE_GAP,
      top: coordRect.y,
      width: DEFAULT_FILLER_SIZE,
      height: coordRect.height
    }; // Do not write back to option and replace value 'ph', because
    // the 'ph' value should be recalculated when resize.

    var layoutParams = _util_layout__WEBPACK_IMPORTED_MODULE_5__.getLayoutParams(dataZoomModel.option); // Replace the placeholder value.

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(['right', 'top', 'width', 'height'], function (name) {
      if (layoutParams[name] === 'ph') {
        layoutParams[name] = positionInfo[name];
      }
    });
    var layoutRect = _util_layout__WEBPACK_IMPORTED_MODULE_5__.getLayoutRect(layoutParams, ecSize);
    this._location = {
      x: layoutRect.x,
      y: layoutRect.y
    };
    this._size = [layoutRect.width, layoutRect.height];
    this._orient === VERTICAL && this._size.reverse();
  };

  SliderZoomView.prototype._positionGroup = function () {
    var thisGroup = this.group;
    var location = this._location;
    var orient = this._orient; // Just use the first axis to determine mapping.

    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
    var inverse = targetAxisModel && targetAxisModel.get('inverse');
    var sliderGroup = this._displayables.sliderGroup;
    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse; // Transform barGroup.

    sliderGroup.attr(orient === HORIZONTAL && !inverse ? {
      scaleY: otherAxisInverse ? 1 : -1,
      scaleX: 1
    } : orient === HORIZONTAL && inverse ? {
      scaleY: otherAxisInverse ? 1 : -1,
      scaleX: -1
    } : orient === VERTICAL && !inverse ? {
      scaleY: otherAxisInverse ? -1 : 1,
      scaleX: 1,
      rotation: Math.PI / 2
    } // Dont use Math.PI, considering shadow direction.
    : {
      scaleY: otherAxisInverse ? -1 : 1,
      scaleX: -1,
      rotation: Math.PI / 2
    }); // Position barGroup

    var rect = thisGroup.getBoundingRect([sliderGroup]);
    thisGroup.x = location.x - rect.x;
    thisGroup.y = location.y - rect.y;
    thisGroup.markRedraw();
  };

  SliderZoomView.prototype._getViewExtent = function () {
    return [0, this._size[0]];
  };

  SliderZoomView.prototype._renderBackground = function () {
    var dataZoomModel = this.dataZoomModel;
    var size = this._size;
    var barGroup = this._displayables.sliderGroup;
    var brushSelect = dataZoomModel.get('brushSelect');
    barGroup.add(new Rect({
      silent: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: dataZoomModel.get('backgroundColor')
      },
      z2: -40
    })); // Click panel, over shadow, below handles.

    var clickPanel = new Rect({
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: 'transparent'
      },
      z2: 0,
      onclick: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(this._onClickPanel, this)
    });
    var zr = this.api.getZr();

    if (brushSelect) {
      clickPanel.on('mousedown', this._onBrushStart, this);
      clickPanel.cursor = 'crosshair';
      zr.on('mousemove', this._onBrush);
      zr.on('mouseup', this._onBrushEnd);
    } else {
      zr.off('mousemove', this._onBrush);
      zr.off('mouseup', this._onBrushEnd);
    }

    barGroup.add(clickPanel);
  };

  SliderZoomView.prototype._renderDataShadow = function () {
    var info = this._dataShadowInfo = this._prepareDataShadowInfo();

    this._displayables.dataShadowSegs = [];

    if (!info) {
      return;
    }

    var size = this._size;
    var seriesModel = info.series;
    var data = seriesModel.getRawData();
    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() // @see candlestick
    : info.otherDim;

    if (otherDim == null) {
      return;
    }

    var otherDataExtent = data.getDataExtent(otherDim); // Nice extent.

    var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;
    otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];
    var otherShadowExtent = [0, size[1]];
    var thisShadowExtent = [0, size[0]];
    var areaPoints = [[size[0], 0], [0, 0]];
    var linePoints = [];
    var step = thisShadowExtent[1] / (data.count() - 1);
    var thisCoord = 0; // Optimize for large data shadow

    var stride = Math.round(data.count() / size[0]);
    var lastIsEmpty;
    data.each([otherDim], function (value, index) {
      if (stride > 0 && index % stride) {
        thisCoord += step;
        return;
      } // FIXME
      // Should consider axis.min/axis.max when drawing dataShadow.
      // FIXME
      // 应该使用统一的空判断？还是在list里进行空判断？


      var isEmpty = value == null || isNaN(value) || value === ''; // See #4235.

      var otherCoord = isEmpty ? 0 : (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.linearMap)(value, otherDataExtent, otherShadowExtent, true); // Attempt to draw data shadow precisely when there are empty value.

      if (isEmpty && !lastIsEmpty && index) {
        areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);
        linePoints.push([linePoints[linePoints.length - 1][0], 0]);
      } else if (!isEmpty && lastIsEmpty) {
        areaPoints.push([thisCoord, 0]);
        linePoints.push([thisCoord, 0]);
      }

      areaPoints.push([thisCoord, otherCoord]);
      linePoints.push([thisCoord, otherCoord]);
      thisCoord += step;
      lastIsEmpty = isEmpty;
    });
    var dataZoomModel = this.dataZoomModel;

    function createDataShadowGroup(isSelectedArea) {
      var model = dataZoomModel.getModel(isSelectedArea ? 'selectedDataBackground' : 'dataBackground');
      var group = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default();
      var polygon = new _util_graphic__WEBPACK_IMPORTED_MODULE_7__.default({
        shape: {
          points: areaPoints
        },
        segmentIgnoreThreshold: 1,
        style: model.getModel('areaStyle').getAreaStyle(),
        silent: true,
        z2: -20
      });
      var polyline = new _util_graphic__WEBPACK_IMPORTED_MODULE_8__.default({
        shape: {
          points: linePoints
        },
        segmentIgnoreThreshold: 1,
        style: model.getModel('lineStyle').getLineStyle(),
        silent: true,
        z2: -19
      });
      group.add(polygon);
      group.add(polyline);
      return group;
    } // let dataBackgroundModel = dataZoomModel.getModel('dataBackground');


    for (var i = 0; i < 3; i++) {
      var group = createDataShadowGroup(i === 1);

      this._displayables.sliderGroup.add(group);

      this._displayables.dataShadowSegs.push(group);
    }
  };

  SliderZoomView.prototype._prepareDataShadowInfo = function () {
    var dataZoomModel = this.dataZoomModel;
    var showDataShadow = dataZoomModel.get('showDataShadow');

    if (showDataShadow === false) {
      return;
    } // Find a representative series.


    var result;
    var ecModel = this.ecModel;
    dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
      var seriesModels = dataZoomModel.getAxisProxy(axisDim, axisIndex).getTargetSeriesModels();
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(seriesModels, function (seriesModel) {
        if (result) {
          return;
        }

        if (showDataShadow !== true && (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.indexOf)(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {
          return;
        }

        var thisAxis = ecModel.getComponent((0,_helper__WEBPACK_IMPORTED_MODULE_9__.getAxisMainType)(axisDim), axisIndex).axis;
        var otherDim = getOtherDim(axisDim);
        var otherAxisInverse;
        var coordSys = seriesModel.coordinateSystem;

        if (otherDim != null && coordSys.getOtherAxis) {
          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
        }

        otherDim = seriesModel.getData().mapDimension(otherDim);
        result = {
          thisAxis: thisAxis,
          series: seriesModel,
          thisDim: axisDim,
          otherDim: otherDim,
          otherAxisInverse: otherAxisInverse
        };
      }, this);
    }, this);
    return result;
  };

  SliderZoomView.prototype._renderHandle = function () {
    var thisGroup = this.group;
    var displayables = this._displayables;
    var handles = displayables.handles = [null, null];
    var handleLabels = displayables.handleLabels = [null, null];
    var sliderGroup = this._displayables.sliderGroup;
    var size = this._size;
    var dataZoomModel = this.dataZoomModel;
    var api = this.api;
    var borderRadius = dataZoomModel.get('borderRadius') || 0;
    var brushSelect = dataZoomModel.get('brushSelect');
    var filler = displayables.filler = new Rect({
      silent: brushSelect,
      style: {
        fill: dataZoomModel.get('fillerColor')
      },
      textConfig: {
        position: 'inside'
      }
    });
    sliderGroup.add(filler); // Frame border.

    sliderGroup.add(new Rect({
      silent: true,
      subPixelOptimize: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1],
        r: borderRadius
      },
      style: {
        stroke: dataZoomModel.get('dataBackgroundColor') // deprecated option
        || dataZoomModel.get('borderColor'),
        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
        fill: 'rgba(0,0,0,0)'
      }
    })); // Left and right handle to resize

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)([0, 1], function (handleIndex) {
      var iconStr = dataZoomModel.get('handleIcon');

      if (!_util_symbol__WEBPACK_IMPORTED_MODULE_10__.symbolBuildProxies[iconStr] && iconStr.indexOf('path://') < 0 && iconStr.indexOf('image://') < 0) {
        // Compatitable with the old icon parsers. Which can use a path string without path://
        iconStr = 'path://' + iconStr;

        if (true) {
          (0,_util_log__WEBPACK_IMPORTED_MODULE_11__.deprecateLog)('handleIcon now needs \'path://\' prefix when using a path string');
        }
      }

      var path = (0,_util_symbol__WEBPACK_IMPORTED_MODULE_10__.createSymbol)(iconStr, -1, 0, 2, 2, null, true);
      path.attr({
        cursor: getCursor(this._orient),
        draggable: true,
        drift: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(this._onDragMove, this, handleIndex),
        ondragend: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(this._onDragEnd, this),
        onmouseover: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(this._showDataInfo, this, true),
        onmouseout: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(this._showDataInfo, this, false),
        z2: 5
      });
      var bRect = path.getBoundingRect();
      var handleSize = dataZoomModel.get('handleSize');
      this._handleHeight = (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.parsePercent)(handleSize, this._size[1]);
      this._handleWidth = bRect.width / bRect.height * this._handleHeight;
      path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());
      path.style.strokeNoScale = true;
      path.rectHover = true;
      path.ensureState('emphasis').style = dataZoomModel.getModel(['emphasis', 'handleStyle']).getItemStyle();
      (0,_util_states__WEBPACK_IMPORTED_MODULE_12__.enableHoverEmphasis)(path);
      var handleColor = dataZoomModel.get('handleColor'); // deprecated option
      // Compatitable with previous version

      if (handleColor != null) {
        path.style.fill = handleColor;
      }

      sliderGroup.add(handles[handleIndex] = path);
      var textStyleModel = dataZoomModel.getModel('textStyle');
      thisGroup.add(handleLabels[handleIndex] = new _util_graphic__WEBPACK_IMPORTED_MODULE_13__.default({
        silent: true,
        invisible: true,
        style: {
          x: 0,
          y: 0,
          text: '',
          verticalAlign: 'middle',
          align: 'center',
          fill: textStyleModel.getTextColor(),
          font: textStyleModel.getFont()
        },
        z2: 10
      }));
    }, this); // Handle to move. Only visible when brushSelect is set true.

    var actualMoveZone = filler;

    if (brushSelect) {
      var moveHandleHeight = (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.parsePercent)(dataZoomModel.get('moveHandleSize'), size[1]);
      var moveHandle_1 = displayables.moveHandle = new _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default({
        style: dataZoomModel.getModel('moveHandleStyle').getItemStyle(),
        silent: true,
        shape: {
          r: [0, 0, 2, 2],
          y: size[1] - 0.5,
          height: moveHandleHeight
        }
      });
      var iconSize = moveHandleHeight * 0.8;
      var moveHandleIcon = displayables.moveHandleIcon = (0,_util_symbol__WEBPACK_IMPORTED_MODULE_10__.createSymbol)(dataZoomModel.get('moveHandleIcon'), -iconSize / 2, -iconSize / 2, iconSize, iconSize, '#fff', true);
      moveHandleIcon.silent = true;
      moveHandleIcon.y = size[1] + moveHandleHeight / 2 - 0.5;
      moveHandle_1.ensureState('emphasis').style = dataZoomModel.getModel(['emphasis', 'moveHandleStyle']).getItemStyle();
      var moveZoneExpandSize = Math.min(size[1] / 2, Math.max(moveHandleHeight, 10));
      actualMoveZone = displayables.moveZone = new _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default({
        invisible: true,
        shape: {
          y: size[1] - moveZoneExpandSize,
          height: moveHandleHeight + moveZoneExpandSize
        }
      });
      actualMoveZone.on('mouseover', function () {
        api.enterEmphasis(moveHandle_1);
      }).on('mouseout', function () {
        api.leaveEmphasis(moveHandle_1);
      });
      sliderGroup.add(moveHandle_1);
      sliderGroup.add(moveHandleIcon);
      sliderGroup.add(actualMoveZone);
    }

    actualMoveZone.attr({
      draggable: true,
      cursor: getCursor(this._orient),
      drift: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(this._onDragMove, this, 'all'),
      ondragstart: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(this._showDataInfo, this, true),
      ondragend: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(this._onDragEnd, this),
      onmouseover: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(this._showDataInfo, this, true),
      onmouseout: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind)(this._showDataInfo, this, false)
    });
  };

  SliderZoomView.prototype._resetInterval = function () {
    var range = this._range = this.dataZoomModel.getPercentRange();

    var viewExtent = this._getViewExtent();

    this._handleEnds = [(0,_util_number__WEBPACK_IMPORTED_MODULE_6__.linearMap)(range[0], [0, 100], viewExtent, true), (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.linearMap)(range[1], [0, 100], viewExtent, true)];
  };

  SliderZoomView.prototype._updateInterval = function (handleIndex, delta) {
    var dataZoomModel = this.dataZoomModel;
    var handleEnds = this._handleEnds;

    var viewExtend = this._getViewExtent();

    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    var percentExtent = [0, 100];
    (0,_helper_sliderMove__WEBPACK_IMPORTED_MODULE_14__.default)(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.linearMap)(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.linearMap)(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
    var lastRange = this._range;
    var range = this._range = (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.asc)([(0,_util_number__WEBPACK_IMPORTED_MODULE_6__.linearMap)(handleEnds[0], viewExtend, percentExtent, true), (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.linearMap)(handleEnds[1], viewExtend, percentExtent, true)]);
    return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
  };

  SliderZoomView.prototype._updateView = function (nonRealtime) {
    var displaybles = this._displayables;
    var handleEnds = this._handleEnds;
    var handleInterval = (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.asc)(handleEnds.slice());
    var size = this._size;
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)([0, 1], function (handleIndex) {
      // Handles
      var handle = displaybles.handles[handleIndex];
      var handleHeight = this._handleHeight;
      handle.attr({
        scaleX: handleHeight / 2,
        scaleY: handleHeight / 2,
        // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.
        // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.
        x: handleEnds[handleIndex] + (handleIndex ? -1 : 1),
        y: size[1] / 2 - handleHeight / 2
      });
    }, this); // Filler

    displaybles.filler.setShape({
      x: handleInterval[0],
      y: 0,
      width: handleInterval[1] - handleInterval[0],
      height: size[1]
    });
    var viewExtent = {
      x: handleInterval[0],
      width: handleInterval[1] - handleInterval[0]
    }; // Move handle

    if (displaybles.moveHandle) {
      displaybles.moveHandle.setShape(viewExtent);
      displaybles.moveZone.setShape(viewExtent); // Force update path on the invisible object

      displaybles.moveZone.getBoundingRect();
      displaybles.moveHandleIcon && displaybles.moveHandleIcon.attr('x', viewExtent.x + viewExtent.width / 2);
    } // update clip path of shadow.


    var dataShadowSegs = displaybles.dataShadowSegs;
    var segIntervals = [0, handleInterval[0], handleInterval[1], size[0]];

    for (var i = 0; i < dataShadowSegs.length; i++) {
      var segGroup = dataShadowSegs[i];
      var clipPath = segGroup.getClipPath();

      if (!clipPath) {
        clipPath = new _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default();
        segGroup.setClipPath(clipPath);
      }

      clipPath.setShape({
        x: segIntervals[i],
        y: 0,
        width: segIntervals[i + 1] - segIntervals[i],
        height: size[1]
      });
    }

    this._updateDataInfo(nonRealtime);
  };

  SliderZoomView.prototype._updateDataInfo = function (nonRealtime) {
    var dataZoomModel = this.dataZoomModel;
    var displaybles = this._displayables;
    var handleLabels = displaybles.handleLabels;
    var orient = this._orient;
    var labelTexts = ['', '']; // FIXME
    // date型，支持formatter，autoformatter（ec2 date.getAutoFormatter）

    if (dataZoomModel.get('showDetail')) {
      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();

      if (axisProxy) {
        var axis = axisProxy.getAxisModel().axis;
        var range = this._range;
        var dataInterval = nonRealtime // See #4434, data and axis are not processed and reset yet in non-realtime mode.
        ? axisProxy.calculateDataWindow({
          start: range[0],
          end: range[1]
        }).valueWindow : axisProxy.getDataValueWindow();
        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
      }
    }

    var orderedHandleEnds = (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.asc)(this._handleEnds.slice());
    setLabel.call(this, 0);
    setLabel.call(this, 1);

    function setLabel(handleIndex) {
      // Label
      // Text should not transform by barGroup.
      // Ignore handlers transform
      var barTransform = _util_graphic__WEBPACK_IMPORTED_MODULE_15__.getTransform(displaybles.handles[handleIndex].parent, this.group);
      var direction = _util_graphic__WEBPACK_IMPORTED_MODULE_15__.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);
      var offset = this._handleWidth / 2 + LABEL_GAP;
      var textPoint = _util_graphic__WEBPACK_IMPORTED_MODULE_15__.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        verticalAlign: orient === HORIZONTAL ? 'middle' : direction,
        align: orient === HORIZONTAL ? direction : 'center',
        text: labelTexts[handleIndex]
      });
    }
  };

  SliderZoomView.prototype._formatLabel = function (value, axis) {
    var dataZoomModel = this.dataZoomModel;
    var labelFormatter = dataZoomModel.get('labelFormatter');
    var labelPrecision = dataZoomModel.get('labelPrecision');

    if (labelPrecision == null || labelPrecision === 'auto') {
      labelPrecision = axis.getPixelPrecision();
    }

    var valueStr = value == null || isNaN(value) ? '' // FIXME Glue code
    : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel({
      value: Math.round(value)
    }) // param of toFixed should less then 20.
    : value.toFixed(Math.min(labelPrecision, 20));
    return (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(labelFormatter) ? labelFormatter(value, valueStr) : (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.isString)(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;
  };
  /**
   * @param showOrHide true: show, false: hide
   */


  SliderZoomView.prototype._showDataInfo = function (showOrHide) {
    // Always show when drgging.
    showOrHide = this._dragging || showOrHide;
    var displayables = this._displayables;
    var handleLabels = displayables.handleLabels;
    handleLabels[0].attr('invisible', !showOrHide);
    handleLabels[1].attr('invisible', !showOrHide); // Highlight move handle

    displayables.moveHandle && this.api[showOrHide ? 'enterEmphasis' : 'leaveEmphasis'](displayables.moveHandle, 1);
  };

  SliderZoomView.prototype._onDragMove = function (handleIndex, dx, dy, event) {
    this._dragging = true; // For mobile device, prevent screen slider on the button.

    zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_16__.stop(event.event); // Transform dx, dy to bar coordination.

    var barTransform = this._displayables.sliderGroup.getLocalTransform();

    var vertex = _util_graphic__WEBPACK_IMPORTED_MODULE_15__.applyTransform([dx, dy], barTransform, true);

    var changed = this._updateInterval(handleIndex, vertex[0]);

    var realtime = this.dataZoomModel.get('realtime');

    this._updateView(!realtime); // Avoid dispatch dataZoom repeatly but range not changed,
    // which cause bad visual effect when progressive enabled.


    changed && realtime && this._dispatchZoomAction(true);
  };

  SliderZoomView.prototype._onDragEnd = function () {
    this._dragging = false;

    this._showDataInfo(false); // While in realtime mode and stream mode, dispatch action when
    // drag end will cause the whole view rerender, which is unnecessary.


    var realtime = this.dataZoomModel.get('realtime');
    !realtime && this._dispatchZoomAction(false);
  };

  SliderZoomView.prototype._onClickPanel = function (e) {
    var size = this._size;

    var localPoint = this._displayables.sliderGroup.transformCoordToLocal(e.offsetX, e.offsetY);

    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
      return;
    }

    var handleEnds = this._handleEnds;
    var center = (handleEnds[0] + handleEnds[1]) / 2;

    var changed = this._updateInterval('all', localPoint[0] - center);

    this._updateView();

    changed && this._dispatchZoomAction(false);
  };

  SliderZoomView.prototype._onBrushStart = function (e) {
    var x = e.offsetX;
    var y = e.offsetY;
    this._brushStart = new _util_graphic__WEBPACK_IMPORTED_MODULE_17__.default(x, y);
    this._brushing = true;
    this._brushStartTime = +new Date(); // this._updateBrushRect(x, y);
  };

  SliderZoomView.prototype._onBrushEnd = function (e) {
    if (!this._brushing) {
      return;
    }

    var brushRect = this._displayables.brushRect;
    this._brushing = false;

    if (!brushRect) {
      return;
    }

    brushRect.attr('ignore', true);
    var brushShape = brushRect.shape;
    var brushEndTime = +new Date(); // console.log(brushEndTime - this._brushStartTime);

    if (brushEndTime - this._brushStartTime < 200 && Math.abs(brushShape.width) < 5) {
      // Will treat it as a click
      return;
    }

    var viewExtend = this._getViewExtent();

    var percentExtent = [0, 100];
    this._range = (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.asc)([(0,_util_number__WEBPACK_IMPORTED_MODULE_6__.linearMap)(brushShape.x, viewExtend, percentExtent, true), (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.linearMap)(brushShape.x + brushShape.width, viewExtend, percentExtent, true)]);
    this._handleEnds = [brushShape.x, brushShape.x + brushShape.width];

    this._updateView();

    this._dispatchZoomAction(false);
  };

  SliderZoomView.prototype._onBrush = function (e) {
    if (this._brushing) {
      // For mobile device, prevent screen slider on the button.
      zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_16__.stop(e.event);

      this._updateBrushRect(e.offsetX, e.offsetY);
    }
  };

  SliderZoomView.prototype._updateBrushRect = function (mouseX, mouseY) {
    var displayables = this._displayables;
    var dataZoomModel = this.dataZoomModel;
    var brushRect = displayables.brushRect;

    if (!brushRect) {
      brushRect = displayables.brushRect = new Rect({
        silent: true,
        style: dataZoomModel.getModel('brushStyle').getItemStyle()
      });
      displayables.sliderGroup.add(brushRect);
    }

    brushRect.attr('ignore', false);
    var brushStart = this._brushStart;
    var sliderGroup = this._displayables.sliderGroup;
    var endPoint = sliderGroup.transformCoordToLocal(mouseX, mouseY);
    var startPoint = sliderGroup.transformCoordToLocal(brushStart.x, brushStart.y);
    var size = this._size;
    endPoint[0] = Math.max(Math.min(size[0], endPoint[0]), 0);
    brushRect.setShape({
      x: startPoint[0],
      y: 0,
      width: endPoint[0] - startPoint[0],
      height: size[1]
    });
  };
  /**
   * This action will be throttled.
   */


  SliderZoomView.prototype._dispatchZoomAction = function (realtime) {
    var range = this._range;
    this.api.dispatchAction({
      type: 'dataZoom',
      from: this.uid,
      dataZoomId: this.dataZoomModel.id,
      animation: realtime ? REALTIME_ANIMATION_CONFIG : null,
      start: range[0],
      end: range[1]
    });
  };

  SliderZoomView.prototype._findCoordRect = function () {
    // Find the grid coresponding to the first axis referred by dataZoom.
    var rect;
    var coordSysInfoList = (0,_helper__WEBPACK_IMPORTED_MODULE_9__.collectReferCoordSysModelInfo)(this.dataZoomModel).infoList;

    if (!rect && coordSysInfoList.length) {
      var coordSys = coordSysInfoList[0].model.coordinateSystem;
      rect = coordSys.getRect && coordSys.getRect();
    }

    if (!rect) {
      var width = this.api.getWidth();
      var height = this.api.getHeight();
      rect = {
        x: width * 0.2,
        y: height * 0.2,
        width: width * 0.6,
        height: height * 0.6
      };
    }

    return rect;
  };

  SliderZoomView.type = 'dataZoom.slider';
  return SliderZoomView;
}(_DataZoomView__WEBPACK_IMPORTED_MODULE_18__.default);

function getOtherDim(thisDim) {
  // FIXME
  // 这个逻辑和getOtherAxis里一致，但是写在这里是否不好
  var map = {
    x: 'y',
    y: 'x',
    radius: 'angle',
    angle: 'radius'
  };
  return map[thisDim];
}

function getCursor(orient) {
  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SliderZoomView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ installDataZoomAction)
/* harmony export */ });
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helper */ "./node_modules/echarts/lib/component/dataZoom/helper.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function installDataZoomAction(registers) {
  registers.registerAction('dataZoom', function (payload, ecModel) {
    var effectedModels = (0,_helper__WEBPACK_IMPORTED_MODULE_0__.findEffectedDataZooms)(ecModel, payload);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(effectedModels, function (dataZoomModel) {
      dataZoomModel.setRawRange({
        start: payload.start,
        end: payload.end,
        startValue: payload.startValue,
        endValue: payload.endValue
      });
    });
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helper */ "./node_modules/echarts/lib/component/dataZoom/helper.js");
/* harmony import */ var _AxisProxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AxisProxy */ "./node_modules/echarts/lib/component/dataZoom/AxisProxy.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var dataZoomProcessor = {
  // `dataZoomProcessor` will only be performed in needed series. Consider if
  // there is a line series and a pie series, it is better not to update the
  // line series if only pie series is needed to be updated.
  getTargetSeries: function (ecModel) {
    function eachAxisModel(cb) {
      ecModel.eachComponent('dataZoom', function (dataZoomModel) {
        dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
          var axisModel = ecModel.getComponent((0,_helper__WEBPACK_IMPORTED_MODULE_0__.getAxisMainType)(axisDim), axisIndex);
          cb(axisDim, axisIndex, axisModel, dataZoomModel);
        });
      });
    } // FIXME: it brings side-effect to `getTargetSeries`.
    // Prepare axis proxies.


    eachAxisModel(function (axisDim, axisIndex, axisModel, dataZoomModel) {
      // dispose all last axis proxy, in case that some axis are deleted.
      axisModel.__dzAxisProxy = null;
    });
    var proxyList = [];
    eachAxisModel(function (axisDim, axisIndex, axisModel, dataZoomModel) {
      // Different dataZooms may constrol the same axis. In that case,
      // an axisProxy serves both of them.
      if (!axisModel.__dzAxisProxy) {
        // Use the first dataZoomModel as the main model of axisProxy.
        axisModel.__dzAxisProxy = new _AxisProxy__WEBPACK_IMPORTED_MODULE_1__.default(axisDim, axisIndex, dataZoomModel, ecModel);
        proxyList.push(axisModel.__dzAxisProxy);
      }
    });
    var seriesModelMap = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.createHashMap)();
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(proxyList, function (axisProxy) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(axisProxy.getTargetSeriesModels(), function (seriesModel) {
        seriesModelMap.set(seriesModel.uid, seriesModel);
      });
    });
    return seriesModelMap;
  },
  // Consider appendData, where filter should be performed. Because data process is
  // in block mode currently, it is not need to worry about that the overallProgress
  // execute every frame.
  overallReset: function (ecModel, api) {
    ecModel.eachComponent('dataZoom', function (dataZoomModel) {
      // We calculate window and reset axis here but not in model
      // init stage and not after action dispatch handler, because
      // reset should be called after seriesData.restoreData.
      dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
        dataZoomModel.getAxisProxy(axisDim, axisIndex).reset(dataZoomModel);
      }); // Caution: data zoom filtering is order sensitive when using
      // percent range and no min/max/scale set on axis.
      // For example, we have dataZoom definition:
      // [
      //      {xAxisIndex: 0, start: 30, end: 70},
      //      {yAxisIndex: 0, start: 20, end: 80}
      // ]
      // In this case, [20, 80] of y-dataZoom should be based on data
      // that have filtered by x-dataZoom using range of [30, 70],
      // but should not be based on full raw data. Thus sliding
      // x-dataZoom will change both ranges of xAxis and yAxis,
      // while sliding y-dataZoom will only change the range of yAxis.
      // So we should filter x-axis after reset x-axis immediately,
      // and then reset y-axis and filter y-axis.

      dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
        dataZoomModel.getAxisProxy(axisDim, axisIndex).filterData(dataZoomModel, api);
      });
    });
    ecModel.eachComponent('dataZoom', function (dataZoomModel) {
      // Fullfill all of the range props so that user
      // is able to get them from chart.getOption().
      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();

      if (axisProxy) {
        var percentRange = axisProxy.getDataPercentWindow();
        var valueRange = axisProxy.getDataValueWindow();
        dataZoomModel.setCalculatedRange({
          start: percentRange[0],
          end: percentRange[1],
          startValue: valueRange[0],
          endValue: valueRange[1]
        });
      }
    });
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dataZoomProcessor);

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/helper.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/helper.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DATA_ZOOM_AXIS_DIMENSIONS": () => (/* binding */ DATA_ZOOM_AXIS_DIMENSIONS),
/* harmony export */   "isCoordSupported": () => (/* binding */ isCoordSupported),
/* harmony export */   "getAxisMainType": () => (/* binding */ getAxisMainType),
/* harmony export */   "getAxisIndexPropName": () => (/* binding */ getAxisIndexPropName),
/* harmony export */   "getAxisIdPropName": () => (/* binding */ getAxisIdPropName),
/* harmony export */   "findEffectedDataZooms": () => (/* binding */ findEffectedDataZooms),
/* harmony export */   "collectReferCoordSysModelInfo": () => (/* binding */ collectReferCoordSysModelInfo)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

var DATA_ZOOM_AXIS_DIMENSIONS = ['x', 'y', 'radius', 'angle', 'single']; // Supported coords.
// FIXME: polar has been broken (but rarely used).

var SERIES_COORDS = ['cartesian2d', 'polar', 'singleAxis'];
function isCoordSupported(seriesModel) {
  var coordType = seriesModel.get('coordinateSystem');
  return (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.indexOf)(SERIES_COORDS, coordType) >= 0;
}
function getAxisMainType(axisDim) {
  if (true) {
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.assert)(axisDim);
  }

  return axisDim + 'Axis';
}
function getAxisIndexPropName(axisDim) {
  if (true) {
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.assert)(axisDim);
  }

  return axisDim + 'AxisIndex';
}
function getAxisIdPropName(axisDim) {
  if (true) {
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.assert)(axisDim);
  }

  return axisDim + 'AxisId';
}
/**
 * If two dataZoomModels has the same axis controlled, we say that they are 'linked'.
 * This function finds all linked dataZoomModels start from the given payload.
 */

function findEffectedDataZooms(ecModel, payload) {
  // Key: `DataZoomAxisDimension`
  var axisRecords = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.createHashMap)();
  var effectedModels = []; // Key: uid of dataZoomModel

  var effectedModelMap = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.createHashMap)(); // Find the dataZooms specified by payload.

  ecModel.eachComponent({
    mainType: 'dataZoom',
    query: payload
  }, function (dataZoomModel) {
    if (!effectedModelMap.get(dataZoomModel.uid)) {
      addToEffected(dataZoomModel);
    }
  }); // Start from the given dataZoomModels, travel the graph to find
  // all of the linked dataZoom models.

  var foundNewLink;

  do {
    foundNewLink = false;
    ecModel.eachComponent('dataZoom', processSingle);
  } while (foundNewLink);

  function processSingle(dataZoomModel) {
    if (!effectedModelMap.get(dataZoomModel.uid) && isLinked(dataZoomModel)) {
      addToEffected(dataZoomModel);
      foundNewLink = true;
    }
  }

  function addToEffected(dataZoom) {
    effectedModelMap.set(dataZoom.uid, true);
    effectedModels.push(dataZoom);
    markAxisControlled(dataZoom);
  }

  function isLinked(dataZoomModel) {
    var isLink = false;
    dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
      var axisIdxArr = axisRecords.get(axisDim);

      if (axisIdxArr && axisIdxArr[axisIndex]) {
        isLink = true;
      }
    });
    return isLink;
  }

  function markAxisControlled(dataZoomModel) {
    dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
      (axisRecords.get(axisDim) || axisRecords.set(axisDim, []))[axisIndex] = true;
    });
  }

  return effectedModels;
}
/**
 * Find the first target coordinate system.
 * Available after model built.
 *
 * @return Like {
 *                  grid: [
 *                      {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},
 *                      {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},
 *                      ...
 *                  ],  // cartesians must not be null/undefined.
 *                  polar: [
 *                      {model: coord0, axisModels: [axis4], coordIndex: 0},
 *                      ...
 *                  ],  // polars must not be null/undefined.
 *                  singleAxis: [
 *                      {model: coord0, axisModels: [], coordIndex: 0}
 *                  ]
 *              }
 */

function collectReferCoordSysModelInfo(dataZoomModel) {
  var ecModel = dataZoomModel.ecModel;
  var coordSysInfoWrap = {
    infoList: [],
    infoMap: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.createHashMap)()
  };
  dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
    var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);

    if (!axisModel) {
      return;
    }

    var coordSysModel = axisModel.getCoordSysModel();

    if (!coordSysModel) {
      return;
    }

    var coordSysUid = coordSysModel.uid;
    var coordSysInfo = coordSysInfoWrap.infoMap.get(coordSysUid);

    if (!coordSysInfo) {
      coordSysInfo = {
        model: coordSysModel,
        axisModels: []
      };
      coordSysInfoWrap.infoList.push(coordSysInfo);
      coordSysInfoWrap.infoMap.set(coordSysUid, coordSysInfo);
    }

    coordSysInfo.axisModels.push(axisModel);
  });
  return coordSysInfoWrap;
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/history.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/history.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "push": () => (/* binding */ push),
/* harmony export */   "pop": () => (/* binding */ pop),
/* harmony export */   "clear": () => (/* binding */ clear),
/* harmony export */   "count": () => (/* binding */ count)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


var each = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each;
var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_1__.makeInner)();
/**
 * @param ecModel
 * @param newSnapshot key is dataZoomId
 */

function push(ecModel, newSnapshot) {
  var storedSnapshots = getStoreSnapshots(ecModel); // If previous dataZoom can not be found,
  // complete an range with current range.

  each(newSnapshot, function (batchItem, dataZoomId) {
    var i = storedSnapshots.length - 1;

    for (; i >= 0; i--) {
      var snapshot = storedSnapshots[i];

      if (snapshot[dataZoomId]) {
        break;
      }
    }

    if (i < 0) {
      // No origin range set, create one by current range.
      var dataZoomModel = ecModel.queryComponents({
        mainType: 'dataZoom',
        subType: 'select',
        id: dataZoomId
      })[0];

      if (dataZoomModel) {
        var percentRange = dataZoomModel.getPercentRange();
        storedSnapshots[0][dataZoomId] = {
          dataZoomId: dataZoomId,
          start: percentRange[0],
          end: percentRange[1]
        };
      }
    }
  });
  storedSnapshots.push(newSnapshot);
}
function pop(ecModel) {
  var storedSnapshots = getStoreSnapshots(ecModel);
  var head = storedSnapshots[storedSnapshots.length - 1];
  storedSnapshots.length > 1 && storedSnapshots.pop(); // Find top for all dataZoom.

  var snapshot = {};
  each(head, function (batchItem, dataZoomId) {
    for (var i = storedSnapshots.length - 1; i >= 0; i--) {
      batchItem = storedSnapshots[i][dataZoomId];

      if (batchItem) {
        snapshot[dataZoomId] = batchItem;
        break;
      }
    }
  });
  return snapshot;
}
function clear(ecModel) {
  inner(ecModel).snapshots = null;
}
function count(ecModel) {
  return getStoreSnapshots(ecModel).length;
}
/**
 * History length of each dataZoom may be different.
 * this._history[0] is used to store origin range.
 */

function getStoreSnapshots(ecModel) {
  var store = inner(ecModel);

  if (!store.snapshots) {
    store.snapshots = [{}];
  }

  return store.snapshots;
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/install.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/install.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extension */ "./node_modules/echarts/lib/extension.js");
/* harmony import */ var _installDataZoomInside__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./installDataZoomInside */ "./node_modules/echarts/lib/component/dataZoom/installDataZoomInside.js");
/* harmony import */ var _installDataZoomSlider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./installDataZoomSlider */ "./node_modules/echarts/lib/component/dataZoom/installDataZoomSlider.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function install(registers) {
  (0,_extension__WEBPACK_IMPORTED_MODULE_0__.use)(_installDataZoomInside__WEBPACK_IMPORTED_MODULE_1__.install);
  (0,_extension__WEBPACK_IMPORTED_MODULE_0__.use)(_installDataZoomSlider__WEBPACK_IMPORTED_MODULE_2__.install); // Do not install './dataZoomSelect',
  // since it only work for toolbox dataZoom.
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/installCommon.js":
/*!**********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/installCommon.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ installCommon)
/* harmony export */ });
/* harmony import */ var _dataZoomProcessor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dataZoomProcessor */ "./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js");
/* harmony import */ var _dataZoomAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dataZoomAction */ "./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


var installed = false;
function installCommon(registers) {
  if (installed) {
    return;
  }

  installed = true;
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, _dataZoomProcessor__WEBPACK_IMPORTED_MODULE_0__.default);
  (0,_dataZoomAction__WEBPACK_IMPORTED_MODULE_1__.default)(registers);
  registers.registerSubTypeDefaulter('dataZoom', function () {
    // Default 'slider' when no type specified.
    return 'slider';
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/installDataZoomInside.js":
/*!******************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/installDataZoomInside.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _InsideZoomModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./InsideZoomModel */ "./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js");
/* harmony import */ var _InsideZoomView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InsideZoomView */ "./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js");
/* harmony import */ var _roams__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./roams */ "./node_modules/echarts/lib/component/dataZoom/roams.js");
/* harmony import */ var _installCommon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./installCommon */ "./node_modules/echarts/lib/component/dataZoom/installCommon.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




function install(registers) {
  (0,_installCommon__WEBPACK_IMPORTED_MODULE_0__.default)(registers);
  registers.registerComponentModel(_InsideZoomModel__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerComponentView(_InsideZoomView__WEBPACK_IMPORTED_MODULE_2__.default);
  (0,_roams__WEBPACK_IMPORTED_MODULE_3__.installDataZoomRoamProcessor)(registers);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/installDataZoomSelect.js":
/*!******************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/installDataZoomSelect.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _SelectZoomModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SelectZoomModel */ "./node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js");
/* harmony import */ var _SelectZoomView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SelectZoomView */ "./node_modules/echarts/lib/component/dataZoom/SelectZoomView.js");
/* harmony import */ var _installCommon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./installCommon */ "./node_modules/echarts/lib/component/dataZoom/installCommon.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function install(registers) {
  registers.registerComponentModel(_SelectZoomModel__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerComponentView(_SelectZoomView__WEBPACK_IMPORTED_MODULE_1__.default);
  (0,_installCommon__WEBPACK_IMPORTED_MODULE_2__.default)(registers);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/installDataZoomSlider.js":
/*!******************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/installDataZoomSlider.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _SliderZoomModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SliderZoomModel */ "./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js");
/* harmony import */ var _SliderZoomView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SliderZoomView */ "./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js");
/* harmony import */ var _installCommon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./installCommon */ "./node_modules/echarts/lib/component/dataZoom/installCommon.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function install(registers) {
  registers.registerComponentModel(_SliderZoomModel__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerComponentView(_SliderZoomView__WEBPACK_IMPORTED_MODULE_1__.default);
  (0,_installCommon__WEBPACK_IMPORTED_MODULE_2__.default)(registers);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataZoom/roams.js":
/*!**************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataZoom/roams.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setViewInfoToCoordSysRecord": () => (/* binding */ setViewInfoToCoordSysRecord),
/* harmony export */   "disposeCoordSysRecordIfNeeded": () => (/* binding */ disposeCoordSysRecordIfNeeded),
/* harmony export */   "installDataZoomRoamProcessor": () => (/* binding */ installDataZoomRoamProcessor)
/* harmony export */ });
/* harmony import */ var _component_helper_RoamController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../component/helper/RoamController */ "./node_modules/echarts/lib/component/helper/RoamController.js");
/* harmony import */ var _util_throttle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/throttle */ "./node_modules/echarts/lib/util/throttle.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helper */ "./node_modules/echarts/lib/component/dataZoom/helper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Only create one roam controller for each coordinate system.
// one roam controller might be refered by two inside data zoom
// components (for example, one for x and one for y). When user
// pan or zoom, only dispatch one action for those data zoom
// components.





var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();
function setViewInfoToCoordSysRecord(api, dataZoomModel, getRange) {
  inner(api).coordSysRecordMap.each(function (coordSysRecord) {
    var dzInfo = coordSysRecord.dataZoomInfoMap.get(dataZoomModel.uid);

    if (dzInfo) {
      dzInfo.getRange = getRange;
    }
  });
}
function disposeCoordSysRecordIfNeeded(api, dataZoomModel) {
  var coordSysRecordMap = inner(api).coordSysRecordMap;
  var coordSysKeyArr = coordSysRecordMap.keys();

  for (var i = 0; i < coordSysKeyArr.length; i++) {
    var coordSysKey = coordSysKeyArr[i];
    var coordSysRecord = coordSysRecordMap.get(coordSysKey);
    var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;

    if (dataZoomInfoMap) {
      var dzUid = dataZoomModel.uid;
      var dzInfo = dataZoomInfoMap.get(dzUid);

      if (dzInfo) {
        dataZoomInfoMap.removeKey(dzUid);

        if (!dataZoomInfoMap.keys().length) {
          disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
        }
      }
    }
  }
}

function disposeCoordSysRecord(coordSysRecordMap, coordSysRecord) {
  if (coordSysRecord) {
    coordSysRecordMap.removeKey(coordSysRecord.model.uid);
    var controller = coordSysRecord.controller;
    controller && controller.dispose();
  }
}

function createCoordSysRecord(api, coordSysModel) {
  // These init props will never change after record created.
  var coordSysRecord = {
    model: coordSysModel,
    containsPoint: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry)(containsPoint, coordSysModel),
    dispatchAction: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry)(dispatchAction, api),
    dataZoomInfoMap: null,
    controller: null
  }; // Must not do anything depends on coordSysRecord outside the event handler here,
  // because coordSysRecord not completed yet.

  var controller = coordSysRecord.controller = new _component_helper_RoamController__WEBPACK_IMPORTED_MODULE_2__.default(api.getZr());
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(['pan', 'zoom', 'scrollMove'], function (eventName) {
    controller.on(eventName, function (event) {
      var batch = [];
      coordSysRecord.dataZoomInfoMap.each(function (dzInfo) {
        // Check whether the behaviors (zoomOnMouseWheel, moveOnMouseMove,
        // moveOnMouseWheel, ...) enabled.
        if (!event.isAvailableBehavior(dzInfo.model.option)) {
          return;
        }

        var method = (dzInfo.getRange || {})[eventName];
        var range = method && method(dzInfo.dzReferCoordSysInfo, coordSysRecord.model.mainType, coordSysRecord.controller, event);
        !dzInfo.model.get('disabled', true) && range && batch.push({
          dataZoomId: dzInfo.model.id,
          start: range[0],
          end: range[1]
        });
      });
      batch.length && coordSysRecord.dispatchAction(batch);
    });
  });
  return coordSysRecord;
}
/**
 * This action will be throttled.
 */


function dispatchAction(api, batch) {
  api.dispatchAction({
    type: 'dataZoom',
    animation: {
      easing: 'cubicOut',
      duration: 100
    },
    batch: batch
  });
}

function containsPoint(coordSysModel, e, x, y) {
  return coordSysModel.coordinateSystem.containPoint([x, y]);
}
/**
 * Merge roamController settings when multiple dataZooms share one roamController.
 */


function mergeControllerParams(dataZoomInfoMap) {
  var controlType; // DO NOT use reserved word (true, false, undefined) as key literally. Even if encapsulated
  // as string, it is probably revert to reserved word by compress tool. See #7411.

  var prefix = 'type_';
  var typePriority = {
    'type_true': 2,
    'type_move': 1,
    'type_false': 0,
    'type_undefined': -1
  };
  var preventDefaultMouseMove = true;
  dataZoomInfoMap.each(function (dataZoomInfo) {
    var dataZoomModel = dataZoomInfo.model;
    var oneType = dataZoomModel.get('disabled', true) ? false : dataZoomModel.get('zoomLock', true) ? 'move' : true;

    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
      controlType = oneType;
    } // Prevent default move event by default. If one false, do not prevent. Otherwise
    // users may be confused why it does not work when multiple insideZooms exist.


    preventDefaultMouseMove = preventDefaultMouseMove && dataZoomModel.get('preventDefaultMouseMove', true);
  });
  return {
    controlType: controlType,
    opt: {
      // RoamController will enable all of these functionalities,
      // and the final behavior is determined by its event listener
      // provided by each inside zoom.
      zoomOnMouseWheel: true,
      moveOnMouseMove: true,
      moveOnMouseWheel: true,
      preventDefaultMouseMove: !!preventDefaultMouseMove
    }
  };
}

function installDataZoomRoamProcessor(registers) {
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, function (ecModel, api) {
    var apiInner = inner(api);
    var coordSysRecordMap = apiInner.coordSysRecordMap || (apiInner.coordSysRecordMap = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.createHashMap)());
    coordSysRecordMap.each(function (coordSysRecord) {
      // `coordSysRecordMap` always exists (becuase it hold the `roam controller`, which should
      // better not re-create each time), but clear `dataZoomInfoMap` each round of the workflow.
      coordSysRecord.dataZoomInfoMap = null;
    });
    ecModel.eachComponent({
      mainType: 'dataZoom',
      subType: 'inside'
    }, function (dataZoomModel) {
      var dzReferCoordSysWrap = (0,_helper__WEBPACK_IMPORTED_MODULE_3__.collectReferCoordSysModelInfo)(dataZoomModel);
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(dzReferCoordSysWrap.infoList, function (dzCoordSysInfo) {
        var coordSysUid = dzCoordSysInfo.model.uid;
        var coordSysRecord = coordSysRecordMap.get(coordSysUid) || coordSysRecordMap.set(coordSysUid, createCoordSysRecord(api, dzCoordSysInfo.model));
        var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap || (coordSysRecord.dataZoomInfoMap = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.createHashMap)()); // Notice these props might be changed each time for a single dataZoomModel.

        dataZoomInfoMap.set(dataZoomModel.uid, {
          dzReferCoordSysInfo: dzCoordSysInfo,
          model: dataZoomModel,
          getRange: null
        });
      });
    }); // (1) Merge dataZoom settings for each coord sys and set to the roam controller.
    // (2) Clear coord sys if not refered by any dataZoom.

    coordSysRecordMap.each(function (coordSysRecord) {
      var controller = coordSysRecord.controller;
      var firstDzInfo;
      var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;

      if (dataZoomInfoMap) {
        var firstDzKey = dataZoomInfoMap.keys()[0];

        if (firstDzKey != null) {
          firstDzInfo = dataZoomInfoMap.get(firstDzKey);
        }
      }

      if (!firstDzInfo) {
        disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
        return;
      }

      var controllerParams = mergeControllerParams(dataZoomInfoMap);
      controller.enable(controllerParams.controlType, controllerParams.opt);
      controller.setPointerChecker(coordSysRecord.containsPoint);
      _util_throttle__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate(coordSysRecord, 'dispatchAction', firstDzInfo.model.get('throttle', true), 'fixRate');
    });
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/dataset/install.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/component/dataset/install.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DatasetModel": () => (/* binding */ DatasetModel),
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");
/* harmony import */ var _util_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/types */ "./node_modules/echarts/lib/util/types.js");
/* harmony import */ var _data_helper_sourceManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/helper/sourceManager */ "./node_modules/echarts/lib/data/helper/sourceManager.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * This module is imported by echarts directly.
 *
 * Notice:
 * Always keep this file exists for backward compatibility.
 * Because before 4.1.0, dataset is an optional component,
 * some users may import this module manually.
 */






var DatasetModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(DatasetModel, _super);

  function DatasetModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'dataset';
    return _this;
  }

  DatasetModel.prototype.init = function (option, parentModel, ecModel) {
    _super.prototype.init.call(this, option, parentModel, ecModel);

    this._sourceManager = new _data_helper_sourceManager__WEBPACK_IMPORTED_MODULE_1__.SourceManager(this);
    (0,_data_helper_sourceManager__WEBPACK_IMPORTED_MODULE_1__.disableTransformOptionMerge)(this);
  };

  DatasetModel.prototype.mergeOption = function (newOption, ecModel) {
    _super.prototype.mergeOption.call(this, newOption, ecModel);

    (0,_data_helper_sourceManager__WEBPACK_IMPORTED_MODULE_1__.disableTransformOptionMerge)(this);
  };

  DatasetModel.prototype.optionUpdated = function () {
    this._sourceManager.dirty();
  };

  DatasetModel.prototype.getSourceManager = function () {
    return this._sourceManager;
  };

  DatasetModel.type = 'dataset';
  DatasetModel.defaultOption = {
    seriesLayoutBy: _util_types__WEBPACK_IMPORTED_MODULE_2__.SERIES_LAYOUT_BY_COLUMN
  };
  return DatasetModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_3__.default);



var DatasetView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(DatasetView, _super);

  function DatasetView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'dataset';
    return _this;
  }

  DatasetView.type = 'dataset';
  return DatasetView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_4__.default);

function install(registers) {
  registers.registerComponentModel(DatasetModel);
  registers.registerComponentView(DatasetView);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/graphic/install.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/component/graphic/install.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Image.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _util_styleCompat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/styleCompat */ "./node_modules/echarts/lib/util/styleCompat.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/










var TRANSFORM_PROPS = {
  x: 1,
  y: 1,
  scaleX: 1,
  scaleY: 1,
  originX: 1,
  originY: 1,
  rotation: 1
};
;
var inner = _util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner();
var _nonShapeGraphicElements = {
  // Reserved but not supported in graphic component.
  path: null,
  compoundPath: null,
  // Supported in graphic component.
  group: _util_graphic__WEBPACK_IMPORTED_MODULE_1__.default,
  image: _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default,
  text: _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default
}; // ------------------------
// Preprocessor
// ------------------------

var preprocessor = function (option) {
  var graphicOption = option.graphic; // Convert
  // {graphic: [{left: 10, type: 'circle'}, ...]}
  // or
  // {graphic: {left: 10, type: 'circle'}}
  // to
  // {graphic: [{elements: [{left: 10, type: 'circle'}, ...]}]}

  if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.isArray(graphicOption)) {
    if (!graphicOption[0] || !graphicOption[0].elements) {
      option.graphic = [{
        elements: graphicOption
      }];
    } else {
      // Only one graphic instance can be instantiated. (We dont
      // want that too many views are created in echarts._viewMap)
      option.graphic = [option.graphic[0]];
    }
  } else if (graphicOption && !graphicOption.elements) {
    option.graphic = [{
      elements: [graphicOption]
    }];
  }
};

;

var GraphicComponentModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__extends)(GraphicComponentModel, _super);

  function GraphicComponentModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = GraphicComponentModel.type;
    return _this;
  }

  GraphicComponentModel.prototype.mergeOption = function (option, ecModel) {
    // Prevent default merge to elements
    var elements = this.option.elements;
    this.option.elements = null;

    _super.prototype.mergeOption.call(this, option, ecModel);

    this.option.elements = elements;
  };

  GraphicComponentModel.prototype.optionUpdated = function (newOption, isInit) {
    var thisOption = this.option;
    var newList = (isInit ? thisOption : newOption).elements;
    var existList = thisOption.elements = isInit ? [] : thisOption.elements;
    var flattenedList = [];

    this._flatten(newList, flattenedList, null);

    var mappingResult = _util_model__WEBPACK_IMPORTED_MODULE_0__.mappingToExists(existList, flattenedList, 'normalMerge'); // Clear elOptionsToUpdate

    var elOptionsToUpdate = this._elOptionsToUpdate = [];
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.each(mappingResult, function (resultItem, index) {
      var newElOption = resultItem.newOption;

      if (true) {
        zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.assert(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.isObject(newElOption) || resultItem.existing, 'Empty graphic option definition');
      }

      if (!newElOption) {
        return;
      }

      elOptionsToUpdate.push(newElOption);
      setKeyInfoToNewElOption(resultItem, newElOption);
      mergeNewElOptionToExist(existList, index, newElOption);
      setLayoutInfoToExist(existList[index], newElOption);
    }, this); // Clean

    for (var i = existList.length - 1; i >= 0; i--) {
      if (existList[i] == null) {
        existList.splice(i, 1);
      } else {
        // $action should be volatile, otherwise option gotten from
        // `getOption` will contain unexpected $action.
        delete existList[i].$action;
      }
    }
  };
  /**
   * Convert
   * [{
   *  type: 'group',
   *  id: 'xx',
   *  children: [{type: 'circle'}, {type: 'polygon'}]
   * }]
   * to
   * [
   *  {type: 'group', id: 'xx'},
   *  {type: 'circle', parentId: 'xx'},
   *  {type: 'polygon', parentId: 'xx'}
   * ]
   */


  GraphicComponentModel.prototype._flatten = function (optionList, result, parentOption) {
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.each(optionList, function (option) {
      if (!option) {
        return;
      }

      if (parentOption) {
        option.parentOption = parentOption;
      }

      result.push(option);
      var children = option.children;

      if (option.type === 'group' && children) {
        this._flatten(children, result, option);
      } // Deleting for JSON output, and for not affecting group creation.


      delete option.children;
    }, this);
  }; // FIXME
  // Pass to view using payload? setOption has a payload?


  GraphicComponentModel.prototype.useElOptionsToUpdate = function () {
    var els = this._elOptionsToUpdate; // Clear to avoid render duplicately when zooming.

    this._elOptionsToUpdate = null;
    return els;
  };

  GraphicComponentModel.type = 'graphic';
  GraphicComponentModel.defaultOption = {
    elements: [] // parentId: null

  };
  return GraphicComponentModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_6__.default); // ------------------------
// View
// ------------------------


var GraphicComponentView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__extends)(GraphicComponentView, _super);

  function GraphicComponentView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = GraphicComponentView.type;
    return _this;
  }

  GraphicComponentView.prototype.init = function () {
    this._elMap = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.createHashMap();
  };

  GraphicComponentView.prototype.render = function (graphicModel, ecModel, api) {
    // Having leveraged between use cases and algorithm complexity, a very
    // simple layout mechanism is used:
    // The size(width/height) can be determined by itself or its parent (not
    // implemented yet), but can not by its children. (Top-down travel)
    // The location(x/y) can be determined by the bounding rect of itself
    // (can including its descendants or not) and the size of its parent.
    // (Bottom-up travel)
    // When `chart.clear()` or `chart.setOption({...}, true)` with the same id,
    // view will be reused.
    if (graphicModel !== this._lastGraphicModel) {
      this._clear();
    }

    this._lastGraphicModel = graphicModel;

    this._updateElements(graphicModel);

    this._relocate(graphicModel, api);
  };
  /**
   * Update graphic elements.
   */


  GraphicComponentView.prototype._updateElements = function (graphicModel) {
    var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();

    if (!elOptionsToUpdate) {
      return;
    }

    var elMap = this._elMap;
    var rootGroup = this.group; // Top-down tranverse to assign graphic settings to each elements.

    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.each(elOptionsToUpdate, function (elOption) {
      var id = _util_model__WEBPACK_IMPORTED_MODULE_0__.convertOptionIdName(elOption.id, null);
      var elExisting = id != null ? elMap.get(id) : null;
      var parentId = _util_model__WEBPACK_IMPORTED_MODULE_0__.convertOptionIdName(elOption.parentId, null);
      var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;
      var elType = elOption.type;
      var elOptionStyle = elOption.style;

      if (elType === 'text' && elOptionStyle) {
        // In top/bottom mode, textVerticalAlign should not be used, which cause
        // inaccurately locating.
        if (elOption.hv && elOption.hv[1]) {
          elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = elOptionStyle.verticalAlign = elOptionStyle.align = null;
        }
      }

      var textContentOption = elOption.textContent;
      var textConfig = elOption.textConfig;

      if (elOptionStyle && (0,_util_styleCompat__WEBPACK_IMPORTED_MODULE_7__.isEC4CompatibleStyle)(elOptionStyle, elType, !!textConfig, !!textContentOption)) {
        var convertResult = (0,_util_styleCompat__WEBPACK_IMPORTED_MODULE_7__.convertFromEC4CompatibleStyle)(elOptionStyle, elType, true);

        if (!textConfig && convertResult.textConfig) {
          textConfig = elOption.textConfig = convertResult.textConfig;
        }

        if (!textContentOption && convertResult.textContent) {
          textContentOption = convertResult.textContent;
        }
      } // Remove unnecessary props to avoid potential problems.


      var elOptionCleaned = getCleanedElOption(elOption); // For simple, do not support parent change, otherwise reorder is needed.

      if (true) {
        elExisting && zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.assert(targetElParent === elExisting.parent, 'Changing parent is not supported.');
      }

      var $action = elOption.$action || 'merge';

      if ($action === 'merge') {
        elExisting ? elExisting.attr(elOptionCleaned) : createEl(id, targetElParent, elOptionCleaned, elMap);
      } else if ($action === 'replace') {
        removeEl(elExisting, elMap);
        createEl(id, targetElParent, elOptionCleaned, elMap);
      } else if ($action === 'remove') {
        removeEl(elExisting, elMap);
      }

      var el = elMap.get(id);

      if (el && textContentOption) {
        if ($action === 'merge') {
          var textContentExisting = el.getTextContent();
          textContentExisting ? textContentExisting.attr(textContentOption) : el.setTextContent(new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default(textContentOption));
        } else if ($action === 'replace') {
          el.setTextContent(new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default(textContentOption));
        }
      }

      if (el) {
        var elInner = inner(el);
        elInner.__ecGraphicWidthOption = elOption.width;
        elInner.__ecGraphicHeightOption = elOption.height;
        setEventData(el, graphicModel, elOption);
      }
    });
  };
  /**
   * Locate graphic elements.
   */


  GraphicComponentView.prototype._relocate = function (graphicModel, api) {
    var elOptions = graphicModel.option.elements;
    var rootGroup = this.group;
    var elMap = this._elMap;
    var apiWidth = api.getWidth();
    var apiHeight = api.getHeight(); // Top-down to calculate percentage width/height of group

    for (var i = 0; i < elOptions.length; i++) {
      var elOption = elOptions[i];
      var id = _util_model__WEBPACK_IMPORTED_MODULE_0__.convertOptionIdName(elOption.id, null);
      var el = id != null ? elMap.get(id) : null;

      if (!el || !el.isGroup) {
        continue;
      }

      var parentEl = el.parent;
      var isParentRoot = parentEl === rootGroup; // Like 'position:absolut' in css, default 0.

      var elInner = inner(el);
      var parentElInner = inner(parentEl);
      elInner.__ecGraphicWidth = (0,_util_number__WEBPACK_IMPORTED_MODULE_8__.parsePercent)(elInner.__ecGraphicWidthOption, isParentRoot ? apiWidth : parentElInner.__ecGraphicWidth) || 0;
      elInner.__ecGraphicHeight = (0,_util_number__WEBPACK_IMPORTED_MODULE_8__.parsePercent)(elInner.__ecGraphicHeightOption, isParentRoot ? apiHeight : parentElInner.__ecGraphicHeight) || 0;
    } // Bottom-up tranvese all elements (consider ec resize) to locate elements.


    for (var i = elOptions.length - 1; i >= 0; i--) {
      var elOption = elOptions[i];
      var id = _util_model__WEBPACK_IMPORTED_MODULE_0__.convertOptionIdName(elOption.id, null);
      var el = id != null ? elMap.get(id) : null;

      if (!el) {
        continue;
      }

      var parentEl = el.parent;
      var parentElInner = inner(parentEl);
      var containerInfo = parentEl === rootGroup ? {
        width: apiWidth,
        height: apiHeight
      } : {
        width: parentElInner.__ecGraphicWidth,
        height: parentElInner.__ecGraphicHeight
      }; // PENDING
      // Currently, when `bounding: 'all'`, the union bounding rect of the group
      // does not include the rect of [0, 0, group.width, group.height], which
      // is probably weird for users. Should we make a break change for it?

      _util_layout__WEBPACK_IMPORTED_MODULE_9__.positionElement(el, elOption, containerInfo, null, {
        hv: elOption.hv,
        boundingMode: elOption.bounding
      });
    }
  };
  /**
   * Clear all elements.
   */


  GraphicComponentView.prototype._clear = function () {
    var elMap = this._elMap;
    elMap.each(function (el) {
      removeEl(el, elMap);
    });
    this._elMap = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.createHashMap();
  };

  GraphicComponentView.prototype.dispose = function () {
    this._clear();
  };

  GraphicComponentView.type = 'graphic';
  return GraphicComponentView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_10__.default);

function createEl(id, targetElParent, elOption, elMap) {
  var graphicType = elOption.type;

  if (true) {
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.assert(graphicType, 'graphic type MUST be set');
  }

  var Clz = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.hasOwn(_nonShapeGraphicElements, graphicType) // Those graphic elements are not shapes. They should not be
  // overwritten by users, so do them first.
  ? _nonShapeGraphicElements[graphicType] : _util_graphic__WEBPACK_IMPORTED_MODULE_11__.getShapeClass(graphicType);

  if (true) {
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.assert(Clz, 'graphic type can not be found');
  }

  var el = new Clz(elOption);
  targetElParent.add(el);
  elMap.set(id, el);
  inner(el).__ecGraphicId = id;
}

function removeEl(elExisting, elMap) {
  var existElParent = elExisting && elExisting.parent;

  if (existElParent) {
    elExisting.type === 'group' && elExisting.traverse(function (el) {
      removeEl(el, elMap);
    });
    elMap.removeKey(inner(elExisting).__ecGraphicId);
    existElParent.remove(elExisting);
  }
} // Remove unnecessary props to avoid potential problems.


function getCleanedElOption(elOption) {
  elOption = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.extend({}, elOption);
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.each(['id', 'parentId', '$action', 'hv', 'bounding', 'textContent'].concat(_util_layout__WEBPACK_IMPORTED_MODULE_9__.LOCATION_PARAMS), function (name) {
    delete elOption[name];
  });
  return elOption;
}

function isSetLoc(obj, props) {
  var isSet;
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.each(props, function (prop) {
    obj[prop] != null && obj[prop] !== 'auto' && (isSet = true);
  });
  return isSet;
}

function setKeyInfoToNewElOption(resultItem, newElOption) {
  var existElOption = resultItem.existing; // Set id and type after id assigned.

  newElOption.id = resultItem.keyInfo.id;
  !newElOption.type && existElOption && (newElOption.type = existElOption.type); // Set parent id if not specified

  if (newElOption.parentId == null) {
    var newElParentOption = newElOption.parentOption;

    if (newElParentOption) {
      newElOption.parentId = newElParentOption.id;
    } else if (existElOption) {
      newElOption.parentId = existElOption.parentId;
    }
  } // Clear


  newElOption.parentOption = null;
}

function mergeNewElOptionToExist(existList, index, newElOption) {
  // Update existing options, for `getOption` feature.
  var newElOptCopy = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.extend({}, newElOption);
  var existElOption = existList[index];
  var $action = newElOption.$action || 'merge';

  if ($action === 'merge') {
    if (existElOption) {
      if (true) {
        var newType = newElOption.type;
        zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.assert(!newType || existElOption.type === newType, 'Please set $action: "replace" to change `type`');
      } // We can ensure that newElOptCopy and existElOption are not
      // the same object, so `merge` will not change newElOptCopy.


      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.merge(existElOption, newElOptCopy, true); // Rigid body, use ignoreSize.

      _util_layout__WEBPACK_IMPORTED_MODULE_9__.mergeLayoutParam(existElOption, newElOptCopy, {
        ignoreSize: true
      }); // Will be used in render.

      _util_layout__WEBPACK_IMPORTED_MODULE_9__.copyLayoutParams(newElOption, existElOption);
    } else {
      existList[index] = newElOptCopy;
    }
  } else if ($action === 'replace') {
    existList[index] = newElOptCopy;
  } else if ($action === 'remove') {
    // null will be cleaned later.
    existElOption && (existList[index] = null);
  }
}

function setLayoutInfoToExist(existItem, newElOption) {
  if (!existItem) {
    return;
  }

  existItem.hv = newElOption.hv = [// Rigid body, dont care `width`.
  isSetLoc(newElOption, ['left', 'right']), // Rigid body, dont care `height`.
  isSetLoc(newElOption, ['top', 'bottom'])]; // Give default group size. Otherwise layout error may occur.

  if (existItem.type === 'group') {
    var existingGroupOpt = existItem;
    var newGroupOpt = newElOption;
    existingGroupOpt.width == null && (existingGroupOpt.width = newGroupOpt.width = 0);
    existingGroupOpt.height == null && (existingGroupOpt.height = newGroupOpt.height = 0);
  }
}

function setEventData(el, graphicModel, elOption) {
  var eventData = (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_12__.getECData)(el).eventData; // Simple optimize for large amount of elements that no need event.

  if (!el.silent && !el.ignore && !eventData) {
    eventData = (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_12__.getECData)(el).eventData = {
      componentType: 'graphic',
      componentIndex: graphicModel.componentIndex,
      name: el.name
    };
  } // `elOption.info` enables user to mount some info on
  // elements and use them in event handlers.


  if (eventData) {
    eventData.info = elOption.info;
  }
}

function install(registers) {
  registers.registerComponentModel(GraphicComponentModel);
  registers.registerComponentView(GraphicComponentView);
  registers.registerPreprocessor(preprocessor);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/grid/install.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/component/grid/install.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _installSimple__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./installSimple */ "./node_modules/echarts/lib/component/grid/installSimple.js");
/* harmony import */ var _axisPointer_install__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../axisPointer/install */ "./node_modules/echarts/lib/component/axisPointer/install.js");
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extension */ "./node_modules/echarts/lib/extension.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function install(registers) {
  (0,_extension__WEBPACK_IMPORTED_MODULE_0__.use)(_installSimple__WEBPACK_IMPORTED_MODULE_1__.install);
  (0,_extension__WEBPACK_IMPORTED_MODULE_0__.use)(_axisPointer_install__WEBPACK_IMPORTED_MODULE_2__.install);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/BrushTargetManager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/helper/BrushTargetManager.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _brushHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./brushHelper */ "./node_modules/echarts/lib/component/helper/brushHelper.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var COORD_CONVERTS = ['dataToPoint', 'pointToData']; // FIXME
// how to genarialize to more coordinate systems.

var INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];

var BrushTargetManager =
/** @class */
function () {
  /**
   * @param finder contains Index/Id/Name of xAxis/yAxis/geo/grid
   *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}
   * @param opt.include include coordinate system types.
   */
  function BrushTargetManager(finder, ecModel, opt) {
    var _this = this;

    this._targetInfoList = [];
    var foundCpts = parseFinder(ecModel, finder);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(targetInfoBuilders, function (builder, type) {
      if (!opt || !opt.include || (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.indexOf)(opt.include, type) >= 0) {
        builder(foundCpts, _this._targetInfoList);
      }
    });
  }

  BrushTargetManager.prototype.setOutputRanges = function (areas, ecModel) {
    this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {
      (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges

      if (!area.coordRange) {
        area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not
        // rebuild range by coordRange accrately, which may bring trouble when
        // brushing only one item. So we use __rangeOffset to rebuilding range
        // by coordRange. And this it only used in brush component so it is no
        // need to be adapted to coordRanges.

        var result = coordConvert[area.brushType](0, coordSys, coordRange);
        area.__rangeOffset = {
          offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),
          xyMinMax: result.xyMinMax
        };
      }
    });
    return areas;
  };

  BrushTargetManager.prototype.matchOutputRanges = function (areas, ecModel, cb) {
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(areas, function (area) {
      var targetInfo = this.findTargetInfo(area, ecModel);

      if (targetInfo && targetInfo !== true) {
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(targetInfo.coordSyses, function (coordSys) {
          var result = coordConvert[area.brushType](1, coordSys, area.range);
          cb(area, result.values, coordSys, ecModel);
        });
      }
    }, this);
  };
  /**
   * the `areas` is `BrushModel.areas`.
   * Called in layout stage.
   * convert `area.coordRange` to global range and set panelId to `area.range`.
   */


  BrushTargetManager.prototype.setInputRanges = function (areas, ecModel) {
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(areas, function (area) {
      var targetInfo = this.findTargetInfo(area, ecModel);

      if (true) {
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.assert)(!targetInfo || targetInfo === true || area.coordRange, 'coordRange must be specified when coord index specified.');
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.assert)(!targetInfo || targetInfo !== true || area.range, 'range must be specified in global brush.');
      }

      area.range = area.range || []; // convert coordRange to global range and set panelId.

      if (targetInfo && targetInfo !== true) {
        area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does
        // not keep its original value, for the sake of the dataZoom scenario,
        // where area.coordRange remains unchanged but area.range may be changed.
        // (2) Only support converting one coordRange to pixel range in brush
        // component. So do not consider `coordRanges`.
        // (3) About __rangeOffset, see comment above.

        var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);
        var rangeOffset = area.__rangeOffset;
        area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
      }
    }, this);
  };

  BrushTargetManager.prototype.makePanelOpts = function (api, getDefaultBrushType) {
    return (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map)(this._targetInfoList, function (targetInfo) {
      var rect = targetInfo.getPanelRect();
      return {
        panelId: targetInfo.panelId,
        defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,
        clipPath: _brushHelper__WEBPACK_IMPORTED_MODULE_1__.makeRectPanelClipPath(rect),
        isTargetByCursor: _brushHelper__WEBPACK_IMPORTED_MODULE_1__.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),
        getLinearBrushOtherExtent: _brushHelper__WEBPACK_IMPORTED_MODULE_1__.makeLinearBrushOtherExtent(rect)
      };
    });
  };

  BrushTargetManager.prototype.controlSeries = function (area, seriesModel, ecModel) {
    // Check whether area is bound in coord, and series do not belong to that coord.
    // If do not do this check, some brush (like lineX) will controll all axes.
    var targetInfo = this.findTargetInfo(area, ecModel);
    return targetInfo === true || targetInfo && (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.indexOf)(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
  };
  /**
   * If return Object, a coord found.
   * If reutrn true, global found.
   * Otherwise nothing found.
   */


  BrushTargetManager.prototype.findTargetInfo = function (area, ecModel) {
    var targetInfoList = this._targetInfoList;
    var foundCpts = parseFinder(ecModel, area);

    for (var i = 0; i < targetInfoList.length; i++) {
      var targetInfo = targetInfoList[i];
      var areaPanelId = area.panelId;

      if (areaPanelId) {
        if (targetInfo.panelId === areaPanelId) {
          return targetInfo;
        }
      } else {
        for (var j = 0; j < targetInfoMatchers.length; j++) {
          if (targetInfoMatchers[j](foundCpts, targetInfo)) {
            return targetInfo;
          }
        }
      }
    }

    return true;
  };

  return BrushTargetManager;
}();

function formatMinMax(minMax) {
  minMax[0] > minMax[1] && minMax.reverse();
  return minMax;
}

function parseFinder(ecModel, finder) {
  return (0,_util_model__WEBPACK_IMPORTED_MODULE_2__.parseFinder)(ecModel, finder, {
    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES
  });
}

var targetInfoBuilders = {
  grid: function (foundCpts, targetInfoList) {
    var xAxisModels = foundCpts.xAxisModels;
    var yAxisModels = foundCpts.yAxisModels;
    var gridModels = foundCpts.gridModels; // Remove duplicated.

    var gridModelMap = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.createHashMap)();
    var xAxesHas = {};
    var yAxesHas = {};

    if (!xAxisModels && !yAxisModels && !gridModels) {
      return;
    }

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(xAxisModels, function (axisModel) {
      var gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
    });
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(yAxisModels, function (axisModel) {
      var gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      yAxesHas[gridModel.id] = true;
    });
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(gridModels, function (gridModel) {
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
      yAxesHas[gridModel.id] = true;
    });
    gridModelMap.each(function (gridModel) {
      var grid = gridModel.coordinateSystem;
      var cartesians = [];
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(grid.getCartesians(), function (cartesian, index) {
        if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.indexOf)(xAxisModels, cartesian.getAxis('x').model) >= 0 || (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.indexOf)(yAxisModels, cartesian.getAxis('y').model) >= 0) {
          cartesians.push(cartesian);
        }
      });
      targetInfoList.push({
        panelId: 'grid--' + gridModel.id,
        gridModel: gridModel,
        coordSysModel: gridModel,
        // Use the first one as the representitive coordSys.
        coordSys: cartesians[0],
        coordSyses: cartesians,
        getPanelRect: panelRectBuilders.grid,
        xAxisDeclared: xAxesHas[gridModel.id],
        yAxisDeclared: yAxesHas[gridModel.id]
      });
    });
  },
  geo: function (foundCpts, targetInfoList) {
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(foundCpts.geoModels, function (geoModel) {
      var coordSys = geoModel.coordinateSystem;
      targetInfoList.push({
        panelId: 'geo--' + geoModel.id,
        geoModel: geoModel,
        coordSysModel: geoModel,
        coordSys: coordSys,
        coordSyses: [coordSys],
        getPanelRect: panelRectBuilders.geo
      });
    });
  }
};
var targetInfoMatchers = [// grid
function (foundCpts, targetInfo) {
  var xAxisModel = foundCpts.xAxisModel;
  var yAxisModel = foundCpts.yAxisModel;
  var gridModel = foundCpts.gridModel;
  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);
  return gridModel && gridModel === targetInfo.gridModel;
}, // geo
function (foundCpts, targetInfo) {
  var geoModel = foundCpts.geoModel;
  return geoModel && geoModel === targetInfo.geoModel;
}];
var panelRectBuilders = {
  grid: function () {
    // grid is not Transformable.
    return this.coordSys.master.getRect().clone();
  },
  geo: function () {
    var coordSys = this.coordSys;
    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform

    rect.applyTransform(_util_graphic__WEBPACK_IMPORTED_MODULE_3__.getTransform(coordSys));
    return rect;
  }
};
var coordConvert = {
  lineX: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.curry)(axisConvert, 0),
  lineY: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.curry)(axisConvert, 1),
  rect: function (to, coordSys, rangeOrCoordRange) {
    var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);
    var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);
    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];
    return {
      values: values,
      xyMinMax: values
    };
  },
  polygon: function (to, coordSys, rangeOrCoordRange) {
    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
    var values = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map)(rangeOrCoordRange, function (item) {
      var p = coordSys[COORD_CONVERTS[to]](item);
      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);
      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);
      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);
      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);
      return p;
    });
    return {
      values: values,
      xyMinMax: xyMinMax
    };
  }
};

function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
  if (true) {
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.assert)(coordSys.type === 'cartesian2d', 'lineX/lineY brush is available only in cartesian2d.');
  }

  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);
  var values = formatMinMax((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map)([0, 1], function (i) {
    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));
  }));
  var xyMinMax = [];
  xyMinMax[axisNameIndex] = values;
  xyMinMax[1 - axisNameIndex] = [NaN, NaN];
  return {
    values: values,
    xyMinMax: xyMinMax
  };
}

var diffProcessor = {
  lineX: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.curry)(axisDiffProcessor, 0),
  lineY: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.curry)(axisDiffProcessor, 1),
  rect: function (values, refer, scales) {
    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];
  },
  polygon: function (values, refer, scales) {
    return (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map)(values, function (item, idx) {
      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
    });
  }
};

function axisDiffProcessor(axisNameIndex, values, refer, scales) {
  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];
} // We have to process scale caused by dataZoom manually,
// although it might be not accurate.
// Return [0~1, 0~1]


function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
  var sizeCurr = getSize(xyMinMaxCurr);
  var sizeOrigin = getSize(xyMinMaxOrigin);
  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
  isNaN(scales[0]) && (scales[0] = 1);
  isNaN(scales[1]) && (scales[1] = 1);
  return scales;
}

function getSize(xyMinMax) {
  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BrushTargetManager);

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/listComponent.js":
/*!********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/helper/listComponent.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "layout": () => (/* binding */ layout),
/* harmony export */   "makeBackground": () => (/* binding */ makeBackground)
/* harmony export */ });
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _util_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/format */ "./node_modules/echarts/lib/util/format.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// @ts-nocheck



/**
 * Layout list like component.
 * It will box layout each items in group of component and then position the whole group in the viewport
 * @param {module:zrender/group/Group} group
 * @param {module:echarts/model/Component} componentModel
 * @param {module:echarts/ExtensionAPI}
 */

function layout(group, componentModel, api) {
  var boxLayoutParams = componentModel.getBoxLayoutParams();
  var padding = componentModel.get('padding');
  var viewportSize = {
    width: api.getWidth(),
    height: api.getHeight()
  };
  var rect = (0,_util_layout__WEBPACK_IMPORTED_MODULE_0__.getLayoutRect)(boxLayoutParams, viewportSize, padding);
  (0,_util_layout__WEBPACK_IMPORTED_MODULE_0__.box)(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);
  (0,_util_layout__WEBPACK_IMPORTED_MODULE_0__.positionElement)(group, boxLayoutParams, viewportSize, padding);
}
function makeBackground(rect, componentModel) {
  var padding = _util_format__WEBPACK_IMPORTED_MODULE_1__.normalizeCssArray(componentModel.get('padding'));
  var style = componentModel.getItemStyle(['color', 'opacity']);
  style.fill = componentModel.get('backgroundColor');
  rect = new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default({
    shape: {
      x: rect.x - padding[3],
      y: rect.y - padding[0],
      width: rect.width + padding[1] + padding[3],
      height: rect.height + padding[0] + padding[2],
      r: componentModel.get('borderRadius')
    },
    style: style,
    silent: true,
    z2: -1
  }); // FIXME
  // `subPixelOptimizeRect` may bring some gap between edge of viewpart
  // and background rect when setting like `left: 0`, `top: 0`.
  // graphic.subPixelOptimizeRect(rect);

  return rect;
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/LegendModel.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/legend/LegendModel.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/Model */ "./node_modules/echarts/lib/model/Model.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var getDefaultSelectorOptions = function (ecModel, type) {
  if (type === 'all') {
    return {
      type: 'all',
      title: ecModel.getLocale(['legend', 'selector', 'all'])
    };
  } else if (type === 'inverse') {
    return {
      type: 'inverse',
      title: ecModel.getLocale(['legend', 'selector', 'inverse'])
    };
  }
};

var LegendModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(LegendModel, _super);

  function LegendModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = LegendModel.type;
    _this.layoutMode = {
      type: 'box',
      // legend.width/height are maxWidth/maxHeight actually,
      // whereas realy width/height is calculated by its content.
      // (Setting {left: 10, right: 10} does not make sense).
      // So consider the case:
      // `setOption({legend: {left: 10});`
      // then `setOption({legend: {right: 10});`
      // The previous `left` should be cleared by setting `ignoreSize`.
      ignoreSize: true
    };
    return _this;
  }

  LegendModel.prototype.init = function (option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    option.selected = option.selected || {};

    this._updateSelector(option);
  };

  LegendModel.prototype.mergeOption = function (option, ecModel) {
    _super.prototype.mergeOption.call(this, option, ecModel);

    this._updateSelector(option);
  };

  LegendModel.prototype._updateSelector = function (option) {
    var selector = option.selector;
    var ecModel = this.ecModel;

    if (selector === true) {
      selector = option.selector = ['all', 'inverse'];
    }

    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(selector)) {
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(selector, function (item, index) {
        zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isString(item) && (item = {
          type: item
        });
        selector[index] = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge(item, getDefaultSelectorOptions(ecModel, item.type));
      });
    }
  };

  LegendModel.prototype.optionUpdated = function () {
    this._updateData(this.ecModel);

    var legendData = this._data; // If selectedMode is single, try to select one

    if (legendData[0] && this.get('selectedMode') === 'single') {
      var hasSelected = false; // If has any selected in option.selected

      for (var i = 0; i < legendData.length; i++) {
        var name_1 = legendData[i].get('name');

        if (this.isSelected(name_1)) {
          // Force to unselect others
          this.select(name_1);
          hasSelected = true;
          break;
        }
      } // Try select the first if selectedMode is single


      !hasSelected && this.select(legendData[0].get('name'));
    }
  };

  LegendModel.prototype._updateData = function (ecModel) {
    var potentialData = [];
    var availableNames = [];
    ecModel.eachRawSeries(function (seriesModel) {
      var seriesName = seriesModel.name;
      availableNames.push(seriesName);
      var isPotential;

      if (seriesModel.legendVisualProvider) {
        var provider = seriesModel.legendVisualProvider;
        var names = provider.getAllNames();

        if (!ecModel.isSeriesFiltered(seriesModel)) {
          availableNames = availableNames.concat(names);
        }

        if (names.length) {
          potentialData = potentialData.concat(names);
        } else {
          isPotential = true;
        }
      } else {
        isPotential = true;
      }

      if (isPotential && (0,_util_model__WEBPACK_IMPORTED_MODULE_2__.isNameSpecified)(seriesModel)) {
        potentialData.push(seriesModel.name);
      }
    });
    /**
     * @type {Array.<string>}
     * @private
     */

    this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,
    // which is convinient for user preparing option.

    var rawData = this.get('data') || potentialData;
    var legendData = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map(rawData, function (dataItem) {
      // Can be string or number
      if (typeof dataItem === 'string' || typeof dataItem === 'number') {
        dataItem = {
          name: dataItem
        };
      }

      return new _model_Model__WEBPACK_IMPORTED_MODULE_3__.default(dataItem, this, this.ecModel);
    }, this);
    /**
     * @type {Array.<module:echarts/model/Model>}
     * @private
     */

    this._data = legendData;
  };

  LegendModel.prototype.getData = function () {
    return this._data;
  };

  LegendModel.prototype.select = function (name) {
    var selected = this.option.selected;
    var selectedMode = this.get('selectedMode');

    if (selectedMode === 'single') {
      var data = this._data;
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(data, function (dataItem) {
        selected[dataItem.get('name')] = false;
      });
    }

    selected[name] = true;
  };

  LegendModel.prototype.unSelect = function (name) {
    if (this.get('selectedMode') !== 'single') {
      this.option.selected[name] = false;
    }
  };

  LegendModel.prototype.toggleSelected = function (name) {
    var selected = this.option.selected; // Default is true

    if (!selected.hasOwnProperty(name)) {
      selected[name] = true;
    }

    this[selected[name] ? 'unSelect' : 'select'](name);
  };

  LegendModel.prototype.allSelect = function () {
    var data = this._data;
    var selected = this.option.selected;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(data, function (dataItem) {
      selected[dataItem.get('name', true)] = true;
    });
  };

  LegendModel.prototype.inverseSelect = function () {
    var data = this._data;
    var selected = this.option.selected;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(data, function (dataItem) {
      var name = dataItem.get('name', true); // Initially, default value is true

      if (!selected.hasOwnProperty(name)) {
        selected[name] = true;
      }

      selected[name] = !selected[name];
    });
  };

  LegendModel.prototype.isSelected = function (name) {
    var selected = this.option.selected;
    return !(selected.hasOwnProperty(name) && !selected[name]) && zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.indexOf(this._availableNames, name) >= 0;
  };

  LegendModel.prototype.getOrient = function () {
    return this.get('orient') === 'vertical' ? {
      index: 1,
      name: 'vertical'
    } : {
      index: 0,
      name: 'horizontal'
    };
  };

  LegendModel.type = 'legend.plain';
  LegendModel.dependencies = ['series'];
  LegendModel.defaultOption = {
    zlevel: 0,
    z: 4,
    show: true,
    orient: 'horizontal',
    left: 'center',
    // right: 'center',
    top: 0,
    // bottom: null,
    align: 'auto',
    backgroundColor: 'rgba(0,0,0,0)',
    borderColor: '#ccc',
    borderRadius: 0,
    borderWidth: 0,
    padding: 5,
    itemGap: 10,
    itemWidth: 25,
    itemHeight: 14,
    inactiveColor: '#ccc',
    inactiveBorderColor: '#ccc',
    itemStyle: {
      borderWidth: 0
    },
    textStyle: {
      color: '#333'
    },
    selectedMode: true,
    selector: false,
    selectorLabel: {
      show: true,
      borderRadius: 10,
      padding: [3, 5, 3, 5],
      fontSize: 12,
      fontFamily: ' sans-serif',
      color: '#666',
      borderWidth: 1,
      borderColor: '#666'
    },
    emphasis: {
      selectorLabel: {
        show: true,
        color: '#eee',
        backgroundColor: '#666'
      }
    },
    selectorPosition: 'auto',
    selectorItemGap: 7,
    selectorButtonGap: 10,
    tooltip: {
      show: false
    }
  };
  return LegendModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_4__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LegendModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/LegendView.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/legend/LegendView.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_symbol__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/symbol */ "./node_modules/echarts/lib/util/symbol.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _helper_listComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helper/listComponent */ "./node_modules/echarts/lib/component/helper/listComponent.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");
/* harmony import */ var zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/tool/color */ "./node_modules/zrender/lib/tool/color.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/










var curry = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.curry;
var each = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each;
var Group = _util_graphic__WEBPACK_IMPORTED_MODULE_1__.default;

var LegendView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(LegendView, _super);

  function LegendView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = LegendView.type;
    _this.newlineDisabled = false;
    return _this;
  }

  LegendView.prototype.init = function () {
    this.group.add(this._contentGroup = new Group());
    this.group.add(this._selectorGroup = new Group());
    this._isFirstRender = true;
  };
  /**
   * @protected
   */


  LegendView.prototype.getContentGroup = function () {
    return this._contentGroup;
  };
  /**
   * @protected
   */


  LegendView.prototype.getSelectorGroup = function () {
    return this._selectorGroup;
  };
  /**
   * @override
   */


  LegendView.prototype.render = function (legendModel, ecModel, api) {
    var isFirstRender = this._isFirstRender;
    this._isFirstRender = false;
    this.resetInner();

    if (!legendModel.get('show', true)) {
      return;
    }

    var itemAlign = legendModel.get('align');
    var orient = legendModel.get('orient');

    if (!itemAlign || itemAlign === 'auto') {
      itemAlign = legendModel.get('left') === 'right' && orient === 'vertical' ? 'right' : 'left';
    } // selector has been normalized to an array in model


    var selector = legendModel.get('selector', true);
    var selectorPosition = legendModel.get('selectorPosition', true);

    if (selector && (!selectorPosition || selectorPosition === 'auto')) {
      selectorPosition = orient === 'horizontal' ? 'end' : 'start';
    }

    this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition); // Perform layout.

    var positionInfo = legendModel.getBoxLayoutParams();
    var viewportSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var padding = legendModel.get('padding');
    var maxSize = _util_layout__WEBPACK_IMPORTED_MODULE_3__.getLayoutRect(positionInfo, viewportSize, padding);
    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition); // Place mainGroup, based on the calculated `mainRect`.

    var layoutRect = _util_layout__WEBPACK_IMPORTED_MODULE_3__.getLayoutRect(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.defaults({
      width: mainRect.width,
      height: mainRect.height
    }, positionInfo), viewportSize, padding);
    this.group.x = layoutRect.x - mainRect.x;
    this.group.y = layoutRect.y - mainRect.y;
    this.group.markRedraw(); // Render background after group is layout.

    this.group.add(this._backgroundEl = (0,_helper_listComponent__WEBPACK_IMPORTED_MODULE_4__.makeBackground)(mainRect, legendModel));
  };

  LegendView.prototype.resetInner = function () {
    this.getContentGroup().removeAll();
    this._backgroundEl && this.group.remove(this._backgroundEl);
    this.getSelectorGroup().removeAll();
  };

  LegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
    var contentGroup = this.getContentGroup();
    var legendDrawnMap = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.createHashMap();
    var selectMode = legendModel.get('selectedMode');
    var excludeSeriesId = [];
    ecModel.eachRawSeries(function (seriesModel) {
      !seriesModel.get('legendHoverLink') && excludeSeriesId.push(seriesModel.id);
    });
    each(legendModel.getData(), function (itemModel, dataIndex) {
      var name = itemModel.get('name'); // Use empty string or \n as a newline string

      if (!this.newlineDisabled && (name === '' || name === '\n')) {
        var g = new Group(); // @ts-ignore

        g.newline = true;
        contentGroup.add(g);
        return;
      } // Representitive series.


      var seriesModel = ecModel.getSeriesByName(name)[0];

      if (legendDrawnMap.get(name)) {
        // Have been drawed
        return;
      } // Legend to control series.


      if (seriesModel) {
        var data = seriesModel.getData();
        var style = data.getVisual('style');
        var color = style[data.getVisual('drawType')] || style.fill;
        var borderColor = style.stroke;
        var decal = style.decal; // Using rect symbol defaultly

        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';
        var symbolType = data.getVisual('symbol');

        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, decal, selectMode);

        itemGroup.on('click', curry(dispatchSelectAction, name, null, api, excludeSeriesId)).on('mouseover', curry(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
        legendDrawnMap.set(name, true);
      } else {
        // Legend to control data. In pie and funnel.
        ecModel.eachRawSeries(function (seriesModel) {
          // In case multiple series has same data name
          if (legendDrawnMap.get(name)) {
            return;
          }

          if (seriesModel.legendVisualProvider) {
            var provider = seriesModel.legendVisualProvider;

            if (!provider.containName(name)) {
              return;
            }

            var idx = provider.indexOfName(name);
            var style = provider.getItemVisual(idx, 'style');
            var borderColor = style.stroke;
            var decal = style.decal;
            var color = style.fill;
            var colorArr = (0,zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_5__.parse)(style.fill); // Color may be set to transparent in visualMap when data is out of range.
            // Do not show nothing.

            if (colorArr && colorArr[3] === 0) {
              colorArr[3] = 0.2; // TODO color is set to 0, 0, 0, 0. Should show correct RGBA

              color = (0,zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_5__.stringify)(colorArr, 'rgba');
            }

            var legendSymbolType = 'roundRect';

            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, borderColor, decal, selectMode); // FIXME: consider different series has items with the same name.


            itemGroup.on('click', curry(dispatchSelectAction, null, name, api, excludeSeriesId)) // Should not specify the series name, consider legend controls
            // more than one pie series.
            .on('mouseover', curry(dispatchHighlightAction, null, name, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, null, name, api, excludeSeriesId));
            legendDrawnMap.set(name, true);
          }
        }, this);
      }

      if (true) {
        if (!legendDrawnMap.get(name)) {
          console.warn(name + ' series not exists. Legend data should be same with series name or data name.');
        }
      }
    }, this);

    if (selector) {
      this._createSelector(selector, legendModel, api, orient, selectorPosition);
    }
  };

  LegendView.prototype._createSelector = function (selector, legendModel, api, orient, selectorPosition) {
    var selectorGroup = this.getSelectorGroup();
    each(selector, function createSelectorButton(selectorItem) {
      var type = selectorItem.type;
      var labelText = new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default({
        style: {
          x: 0,
          y: 0,
          align: 'center',
          verticalAlign: 'middle'
        },
        onclick: function () {
          api.dispatchAction({
            type: type === 'all' ? 'legendAllSelect' : 'legendInverseSelect'
          });
        }
      });
      selectorGroup.add(labelText);
      var labelModel = legendModel.getModel('selectorLabel');
      var emphasisLabelModel = legendModel.getModel(['emphasis', 'selectorLabel']);
      (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_7__.setLabelStyle)(labelText, {
        normal: labelModel,
        emphasis: emphasisLabelModel
      }, {
        defaultText: selectorItem.title
      });
      (0,_util_states__WEBPACK_IMPORTED_MODULE_8__.enableHoverEmphasis)(labelText);
    });
  };

  LegendView.prototype._createItem = function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, decal, selectMode) {
    var itemWidth = legendModel.get('itemWidth');
    var itemHeight = legendModel.get('itemHeight');
    var inactiveColor = legendModel.get('inactiveColor');
    var inactiveBorderColor = legendModel.get('inactiveBorderColor');
    var symbolKeepAspect = legendModel.get('symbolKeepAspect');
    var legendModelItemStyle = legendModel.getModel('itemStyle');
    var isSelected = legendModel.isSelected(name);
    var itemGroup = new Group();
    var textStyleModel = itemModel.getModel('textStyle');
    var itemIcon = itemModel.get('icon');
    var tooltipModel = itemModel.getModel('tooltip');
    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first

    legendSymbolType = itemIcon || legendSymbolType;
    var legendSymbol = (0,_util_symbol__WEBPACK_IMPORTED_MODULE_9__.createSymbol)(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend
    symbolKeepAspect == null ? true : symbolKeepAspect);
    itemGroup.add(setSymbolStyle(legendSymbol, legendSymbolType, legendModelItemStyle, borderColor, inactiveBorderColor, decal, isSelected)); // Compose symbols
    // PENDING

    if (!itemIcon && symbolType // At least show one symbol, can't be all none
    && (symbolType !== legendSymbolType || symbolType === 'none')) {
      var size = itemHeight * 0.8;

      if (symbolType === 'none') {
        symbolType = 'circle';
      }

      var legendSymbolCenter = (0,_util_symbol__WEBPACK_IMPORTED_MODULE_9__.createSymbol)(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend
      symbolKeepAspect == null ? true : symbolKeepAspect); // Put symbol in the center

      itemGroup.add(setSymbolStyle(legendSymbolCenter, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, decal, isSelected));
    }

    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;
    var textAlign = itemAlign;
    var formatter = legendModel.get('formatter');
    var content = name;

    if (typeof formatter === 'string' && formatter) {
      content = formatter.replace('{name}', name != null ? name : '');
    } else if (typeof formatter === 'function') {
      content = formatter(name);
    }

    itemGroup.add(new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default({
      style: (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_7__.createTextStyle)(textStyleModel, {
        text: content,
        x: textX,
        y: itemHeight / 2,
        fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
        align: textAlign,
        verticalAlign: 'middle'
      })
    })); // Add a invisible rect to increase the area of mouse hover

    var hitRect = new _util_graphic__WEBPACK_IMPORTED_MODULE_10__.default({
      shape: itemGroup.getBoundingRect(),
      invisible: true
    });

    if (tooltipModel.get('show')) {
      var formatterParams = {
        componentType: 'legend',
        legendIndex: legendModel.componentIndex,
        name: name,
        $vars: ['name']
      };
      hitRect.tooltip = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.extend({
        content: name,
        // Defaul formatter
        formatter: legendGlobalTooltipModel.get('formatter', true) || function (params) {
          return params.name;
        },
        formatterParams: formatterParams
      }, tooltipModel.option);
    }

    itemGroup.add(hitRect);
    itemGroup.eachChild(function (child) {
      child.silent = true;
    });
    hitRect.silent = !selectMode;
    this.getContentGroup().add(itemGroup);
    (0,_util_states__WEBPACK_IMPORTED_MODULE_8__.enableHoverEmphasis)(itemGroup); // @ts-ignore

    itemGroup.__legendDataIndex = dataIndex;
    return itemGroup;
  };

  LegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
    var contentGroup = this.getContentGroup();
    var selectorGroup = this.getSelectorGroup(); // Place items in contentGroup.

    _util_layout__WEBPACK_IMPORTED_MODULE_3__.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);
    var contentRect = contentGroup.getBoundingRect();
    var contentPos = [-contentRect.x, -contentRect.y];
    selectorGroup.markRedraw();
    contentGroup.markRedraw();

    if (selector) {
      // Place buttons in selectorGroup
      _util_layout__WEBPACK_IMPORTED_MODULE_3__.box( // Buttons in selectorGroup always layout horizontally
      'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));
      var selectorRect = selectorGroup.getBoundingRect();
      var selectorPos = [-selectorRect.x, -selectorRect.y];
      var selectorButtonGap = legendModel.get('selectorButtonGap', true);
      var orientIdx = legendModel.getOrient().index;
      var wh = orientIdx === 0 ? 'width' : 'height';
      var hw = orientIdx === 0 ? 'height' : 'width';
      var yx = orientIdx === 0 ? 'y' : 'x';

      if (selectorPosition === 'end') {
        selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
      } else {
        contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
      } //Always align selector to content as 'middle'


      selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      var mainRect = {
        x: 0,
        y: 0
      };
      mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
      mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
      return mainRect;
    } else {
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      return this.group.getBoundingRect();
    }
  };
  /**
   * @protected
   */


  LegendView.prototype.remove = function () {
    this.getContentGroup().removeAll();
    this._isFirstRender = true;
  };

  LegendView.type = 'legend.plain';
  return LegendView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_11__.default);

function setSymbolStyle(symbol, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, decal, isSelected) {
  var itemStyle;

  if (symbolType !== 'line' && symbolType.indexOf('empty') < 0) {
    itemStyle = legendModelItemStyle.getItemStyle();
    symbol.style.stroke = borderColor;
    symbol.style.decal = decal;

    if (!isSelected) {
      itemStyle.stroke = inactiveBorderColor;
    }
  } else {
    itemStyle = legendModelItemStyle.getItemStyle(['borderWidth', 'borderColor']);
  }

  symbol.setStyle(itemStyle);
  return symbol;
}

function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
  // downplay before unselect
  dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
  api.dispatchAction({
    type: 'legendToggleSelect',
    name: seriesName != null ? seriesName : dataName
  }); // highlight after select
  // TODO higlight immediately may cause animation loss.

  dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
}

function isUseHoverLayer(api) {
  var list = api.getZr().storage.getDisplayList();
  var emphasisState;
  var i = 0;
  var len = list.length;

  while (i < len && !(emphasisState = list[i].states.emphasis)) {
    i++;
  }

  return emphasisState && emphasisState.hoverLayer;
}

function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
  // If element hover will move to a hoverLayer.
  if (!isUseHoverLayer(api)) {
    api.dispatchAction({
      type: 'highlight',
      seriesName: seriesName,
      name: dataName,
      excludeSeriesId: excludeSeriesId
    });
  }
}

function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
  // If element hover will move to a hoverLayer.
  if (!isUseHoverLayer(api)) {
    api.dispatchAction({
      type: 'downplay',
      seriesName: seriesName,
      name: dataName,
      excludeSeriesId: excludeSeriesId
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LegendView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/ScrollableLegendModel.js":
/*!****************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/legend/ScrollableLegendModel.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _LegendModel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LegendModel */ "./node_modules/echarts/lib/component/legend/LegendModel.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _util_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/component */ "./node_modules/echarts/lib/util/component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var ScrollableLegendModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ScrollableLegendModel, _super);

  function ScrollableLegendModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ScrollableLegendModel.type;
    return _this;
  }
  /**
   * @param {number} scrollDataIndex
   */


  ScrollableLegendModel.prototype.setScrollDataIndex = function (scrollDataIndex) {
    this.option.scrollDataIndex = scrollDataIndex;
  };

  ScrollableLegendModel.prototype.init = function (option, parentModel, ecModel) {
    var inputPositionParams = (0,_util_layout__WEBPACK_IMPORTED_MODULE_1__.getLayoutParams)(option);

    _super.prototype.init.call(this, option, parentModel, ecModel);

    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
  };
  /**
   * @override
   */


  ScrollableLegendModel.prototype.mergeOption = function (option, ecModel) {
    _super.prototype.mergeOption.call(this, option, ecModel);

    mergeAndNormalizeLayoutParams(this, this.option, option);
  };

  ScrollableLegendModel.type = 'legend.scroll';
  ScrollableLegendModel.defaultOption = (0,_util_component__WEBPACK_IMPORTED_MODULE_2__.inheritDefaultOption)(_LegendModel__WEBPACK_IMPORTED_MODULE_3__.default.defaultOption, {
    scrollDataIndex: 0,
    pageButtonItemGap: 5,
    pageButtonGap: null,
    pageButtonPosition: 'end',
    pageFormatter: '{current}/{total}',
    pageIcons: {
      horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],
      vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']
    },
    pageIconColor: '#2f4554',
    pageIconInactiveColor: '#aaa',
    pageIconSize: 15,
    pageTextStyle: {
      color: '#333'
    },
    animationDurationUpdate: 800
  });
  return ScrollableLegendModel;
}(_LegendModel__WEBPACK_IMPORTED_MODULE_3__.default);

; // Do not `ignoreSize` to enable setting {left: 10, right: 10}.

function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
  var orient = legendModel.getOrient();
  var ignoreSize = [1, 1];
  ignoreSize[orient.index] = 0;
  (0,_util_layout__WEBPACK_IMPORTED_MODULE_1__.mergeLayoutParam)(target, raw, {
    type: 'box',
    ignoreSize: !!ignoreSize
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ScrollableLegendModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/ScrollableLegendView.js":
/*!***************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/legend/ScrollableLegendView.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _LegendView__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./LegendView */ "./node_modules/echarts/lib/component/legend/LegendView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Separate legend and scrollable legend to reduce package size.
 */





var Group = _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default;
var WH = ['width', 'height'];
var XY = ['x', 'y'];

var ScrollableLegendView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ScrollableLegendView, _super);

  function ScrollableLegendView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ScrollableLegendView.type;
    _this.newlineDisabled = true;
    _this._currentIndex = 0;
    return _this;
  }

  ScrollableLegendView.prototype.init = function () {
    _super.prototype.init.call(this);

    this.group.add(this._containerGroup = new Group());

    this._containerGroup.add(this.getContentGroup());

    this.group.add(this._controllerGroup = new Group());
  };
  /**
   * @override
   */


  ScrollableLegendView.prototype.resetInner = function () {
    _super.prototype.resetInner.call(this);

    this._controllerGroup.removeAll();

    this._containerGroup.removeClipPath();

    this._containerGroup.__rectSize = null;
  };
  /**
   * @override
   */


  ScrollableLegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
    var self = this; // Render content items.

    _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);

    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,
    // e.g., '3/12345' should not overlap with the control arrow button.

    var pageIconSize = legendModel.get('pageIconSize', true);
    var pageIconSizeArr = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];
    createPageButton('pagePrev', 0);
    var pageTextStyleModel = legendModel.getModel('pageTextStyle');
    controllerGroup.add(new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default({
      name: 'pageText',
      style: {
        // Placeholder to calculate a proper layout.
        text: 'xx/xx',
        fill: pageTextStyleModel.getTextColor(),
        font: pageTextStyleModel.getFont(),
        verticalAlign: 'middle',
        align: 'center'
      },
      silent: true
    }));
    createPageButton('pageNext', 1);

    function createPageButton(name, iconIdx) {
      var pageDataIndexName = name + 'DataIndex';
      var icon = _util_graphic__WEBPACK_IMPORTED_MODULE_4__.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {
        // Buttons will be created in each render, so we do not need
        // to worry about avoiding using legendModel kept in scope.
        onclick: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind(self._pageGo, self, pageDataIndexName, legendModel, api)
      }, {
        x: -pageIconSizeArr[0] / 2,
        y: -pageIconSizeArr[1] / 2,
        width: pageIconSizeArr[0],
        height: pageIconSizeArr[1]
      });
      icon.name = name;
      controllerGroup.add(icon);
    }
  };
  /**
   * @override
   */


  ScrollableLegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
    var selectorGroup = this.getSelectorGroup();
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var xy = XY[orientIdx];
    var hw = WH[1 - orientIdx];
    var yx = XY[1 - orientIdx];
    selector && _util_layout__WEBPACK_IMPORTED_MODULE_5__.box( // Buttons in selectorGroup always layout horizontally
    'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));
    var selectorButtonGap = legendModel.get('selectorButtonGap', true);
    var selectorRect = selectorGroup.getBoundingRect();
    var selectorPos = [-selectorRect.x, -selectorRect.y];
    var processMaxSize = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.clone(maxSize);
    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);

    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);

    if (selector) {
      if (selectorPosition === 'end') {
        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
      } else {
        var offset = selectorRect[wh] + selectorButtonGap;
        selectorPos[orientIdx] -= offset;
        mainRect[xy] -= offset;
      }

      mainRect[wh] += selectorRect[wh] + selectorButtonGap;
      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      selectorGroup.markRedraw();
    }

    return mainRect;
  };

  ScrollableLegendView.prototype._layoutContentAndController = function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {
    var contentGroup = this.getContentGroup();
    var containerGroup = this._containerGroup;
    var controllerGroup = this._controllerGroup; // Place items in contentGroup.

    _util_layout__WEBPACK_IMPORTED_MODULE_5__.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
    _util_layout__WEBPACK_IMPORTED_MODULE_5__.box( // Buttons in controller are layout always horizontally.
    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));
    var contentRect = contentGroup.getBoundingRect();
    var controllerRect = controllerGroup.getBoundingRect();
    var showController = this._showController = contentRect[wh] > maxSize[wh]; // In case that the inner elements of contentGroup layout do not based on [0, 0]

    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.
    // If first rendering, `contentGroup.position` is [0, 0], which
    // does not make sense and may cause unexepcted animation if adopted.

    if (!isFirstRender) {
      contentPos[orientIdx] = contentGroup[xy];
    } // Layout container group based on 0.


    var containerPos = [0, 0];
    var controllerPos = [-controllerRect.x, -controllerRect.y];
    var pageButtonGap = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.

    if (showController) {
      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.

      if (pageButtonPosition === 'end') {
        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
      } // controller is on the left / top.
      else {
          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
        }
    } // Always align controller to content as 'middle'.


    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
    contentGroup.setPosition(contentPos);
    containerGroup.setPosition(containerPos);
    controllerGroup.setPosition(controllerPos); // Calculate `mainRect` and set `clipPath`.
    // mainRect should not be calculated by `this.group.getBoundingRect()`
    // for sake of the overflow.

    var mainRect = {
      x: 0,
      y: 0
    }; // Consider content may be overflow (should be clipped).

    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.

    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
    containerGroup.__rectSize = maxSize[wh];

    if (showController) {
      var clipShape = {
        x: 0,
        y: 0
      };
      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
      clipShape[hw] = mainRect[hw];
      containerGroup.setClipPath(new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default({
        shape: clipShape
      })); // Consider content may be larger than container, container rect
      // can not be obtained from `containerGroup.getBoundingRect()`.

      containerGroup.__rectSize = clipShape[wh];
    } else {
      // Do not remove or ignore controller. Keep them set as placeholders.
      controllerGroup.eachChild(function (child) {
        child.attr({
          invisible: true,
          silent: true
        });
      });
    } // Content translate animation.


    var pageInfo = this._getPageInfo(legendModel);

    pageInfo.pageIndex != null && _util_graphic__WEBPACK_IMPORTED_MODULE_4__.updateProps(contentGroup, {
      x: pageInfo.contentPosition[0],
      y: pageInfo.contentPosition[1]
    }, // When switch from "show controller" to "not show controller", view should be
    // updated immediately without animation, otherwise causes weird effect.
    showController ? legendModel : null);

    this._updatePageInfoView(legendModel, pageInfo);

    return mainRect;
  };

  ScrollableLegendView.prototype._pageGo = function (to, legendModel, api) {
    var scrollDataIndex = this._getPageInfo(legendModel)[to];

    scrollDataIndex != null && api.dispatchAction({
      type: 'legendScroll',
      scrollDataIndex: scrollDataIndex,
      legendId: legendModel.id
    });
  };

  ScrollableLegendView.prototype._updatePageInfoView = function (legendModel, pageInfo) {
    var controllerGroup = this._controllerGroup;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each(['pagePrev', 'pageNext'], function (name) {
      var key = name + 'DataIndex';
      var canJump = pageInfo[key] != null;
      var icon = controllerGroup.childOfName(name);

      if (icon) {
        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));
        icon.cursor = canJump ? 'pointer' : 'default';
      }
    });
    var pageText = controllerGroup.childOfName('pageText');
    var pageFormatter = legendModel.get('pageFormatter');
    var pageIndex = pageInfo.pageIndex;
    var current = pageIndex != null ? pageIndex + 1 : 0;
    var total = pageInfo.pageCount;
    pageText && pageFormatter && pageText.setStyle('text', zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.isString(pageFormatter) ? pageFormatter.replace('{current}', current == null ? '' : current + '').replace('{total}', total == null ? '' : total + '') : pageFormatter({
      current: current,
      total: total
    }));
  };
  /**
   *  contentPosition: Array.<number>, null when data item not found.
   *  pageIndex: number, null when data item not found.
   *  pageCount: number, always be a number, can be 0.
   *  pagePrevDataIndex: number, null when no previous page.
   *  pageNextDataIndex: number, null when no next page.
   * }
   */


  ScrollableLegendView.prototype._getPageInfo = function (legendModel) {
    var scrollDataIndex = legendModel.get('scrollDataIndex', true);
    var contentGroup = this.getContentGroup();
    var containerRectSize = this._containerGroup.__rectSize;
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var xy = XY[orientIdx];

    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);

    var children = contentGroup.children();
    var targetItem = children[targetItemIndex];
    var itemCount = children.length;
    var pCount = !itemCount ? 0 : 1;
    var result = {
      contentPosition: [contentGroup.x, contentGroup.y],
      pageCount: pCount,
      pageIndex: pCount - 1,
      pagePrevDataIndex: null,
      pageNextDataIndex: null
    };

    if (!targetItem) {
      return result;
    }

    var targetItemInfo = getItemInfo(targetItem);
    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:
    // (1) Always align based on the left/top most item.
    // (2) It is user-friendly that the last item shown in the
    // current window is shown at the begining of next window.
    // Otherwise if half of the last item is cut by the window,
    // it will have no chance to display entirely.
    // (3) Consider that item size probably be different, we
    // have calculate pageIndex by size rather than item index,
    // and we can not get page index directly by division.
    // (4) The window is to narrow to contain more than
    // one item, we should make sure that the page can be fliped.

    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {
      currItemInfo = getItemInfo(children[i]);

      if ( // Half of the last item is out of the window.
      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page
      // can be started at the current item or the last item.
      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {
        if (winEndItemInfo.i > winStartItemInfo.i) {
          winStartItemInfo = winEndItemInfo;
        } else {
          // e.g., when page size is smaller than item size.
          winStartItemInfo = currItemInfo;
        }

        if (winStartItemInfo) {
          if (result.pageNextDataIndex == null) {
            result.pageNextDataIndex = winStartItemInfo.i;
          }

          ++result.pageCount;
        }
      }

      winEndItemInfo = currItemInfo;
    }

    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {
      currItemInfo = getItemInfo(children[i]);

      if ( // If the the end item does not intersect with the window started
      // from the current item, a page can be settled.
      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.
      winStartItemInfo.i < winEndItemInfo.i) {
        winEndItemInfo = winStartItemInfo;

        if (result.pagePrevDataIndex == null) {
          result.pagePrevDataIndex = winStartItemInfo.i;
        }

        ++result.pageCount;
        ++result.pageIndex;
      }

      winStartItemInfo = currItemInfo;
    }

    return result;

    function getItemInfo(el) {
      if (el) {
        var itemRect = el.getBoundingRect();
        var start = itemRect[xy] + el[xy];
        return {
          s: start,
          e: start + itemRect[wh],
          i: el.__legendDataIndex
        };
      }
    }

    function intersect(itemInfo, winStart) {
      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
    }
  };

  ScrollableLegendView.prototype._findTargetItemIndex = function (targetDataIndex) {
    if (!this._showController) {
      return 0;
    }

    var index;
    var contentGroup = this.getContentGroup();
    var defaultIndex;
    contentGroup.eachChild(function (child, idx) {
      var legendDataIdx = child.__legendDataIndex; // FIXME
      // If the given targetDataIndex (from model) is illegal,
      // we use defaultIndex. But the index on the legend model and
      // action payload is still illegal. That case will not be
      // changed until some scenario requires.

      if (defaultIndex == null && legendDataIdx != null) {
        defaultIndex = idx;
      }

      if (legendDataIdx === targetDataIndex) {
        index = idx;
      }
    });
    return index != null ? index : defaultIndex;
  };

  ScrollableLegendView.type = 'legend.scroll';
  return ScrollableLegendView;
}(_LegendView__WEBPACK_IMPORTED_MODULE_7__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ScrollableLegendView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/install.js":
/*!**************************************************************!*\
  !*** ./node_modules/echarts/lib/component/legend/install.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extension */ "./node_modules/echarts/lib/extension.js");
/* harmony import */ var _installLegendPlain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./installLegendPlain */ "./node_modules/echarts/lib/component/legend/installLegendPlain.js");
/* harmony import */ var _installLegendScroll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./installLegendScroll */ "./node_modules/echarts/lib/component/legend/installLegendScroll.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function install(registers) {
  (0,_extension__WEBPACK_IMPORTED_MODULE_0__.use)(_installLegendPlain__WEBPACK_IMPORTED_MODULE_1__.install);
  (0,_extension__WEBPACK_IMPORTED_MODULE_0__.use)(_installLegendScroll__WEBPACK_IMPORTED_MODULE_2__.install);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/installLegendPlain.js":
/*!*************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/legend/installLegendPlain.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _LegendModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LegendModel */ "./node_modules/echarts/lib/component/legend/LegendModel.js");
/* harmony import */ var _LegendView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LegendView */ "./node_modules/echarts/lib/component/legend/LegendView.js");
/* harmony import */ var _legendFilter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./legendFilter */ "./node_modules/echarts/lib/component/legend/legendFilter.js");
/* harmony import */ var _legendAction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./legendAction */ "./node_modules/echarts/lib/component/legend/legendAction.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




function install(registers) {
  registers.registerComponentModel(_LegendModel__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerComponentView(_LegendView__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, _legendFilter__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerSubTypeDefaulter('legend', function () {
    return 'plain';
  });
  (0,_legendAction__WEBPACK_IMPORTED_MODULE_3__.installLegendAction)(registers);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/installLegendScroll.js":
/*!**************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/legend/installLegendScroll.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extension */ "./node_modules/echarts/lib/extension.js");
/* harmony import */ var _installLegendPlain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./installLegendPlain */ "./node_modules/echarts/lib/component/legend/installLegendPlain.js");
/* harmony import */ var _ScrollableLegendModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ScrollableLegendModel */ "./node_modules/echarts/lib/component/legend/ScrollableLegendModel.js");
/* harmony import */ var _ScrollableLegendView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ScrollableLegendView */ "./node_modules/echarts/lib/component/legend/ScrollableLegendView.js");
/* harmony import */ var _scrollableLegendAction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scrollableLegendAction */ "./node_modules/echarts/lib/component/legend/scrollableLegendAction.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





function install(registers) {
  (0,_extension__WEBPACK_IMPORTED_MODULE_0__.use)(_installLegendPlain__WEBPACK_IMPORTED_MODULE_1__.install);
  registers.registerComponentModel(_ScrollableLegendModel__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerComponentView(_ScrollableLegendView__WEBPACK_IMPORTED_MODULE_3__.default);
  (0,_scrollableLegendAction__WEBPACK_IMPORTED_MODULE_4__.default)(registers);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/legendAction.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/legend/legendAction.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "installLegendAction": () => (/* binding */ installLegendAction)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// @ts-nocheck


function legendSelectActionHandler(methodName, payload, ecModel) {
  var selectedMap = {};
  var isToggleSelect = methodName === 'toggleSelected';
  var isSelected; // Update all legend components

  ecModel.eachComponent('legend', function (legendModel) {
    if (isToggleSelect && isSelected != null) {
      // Force other legend has same selected status
      // Or the first is toggled to true and other are toggled to false
      // In the case one legend has some item unSelected in option. And if other legend
      // doesn't has the item, they will assume it is selected.
      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);
    } else if (methodName === 'allSelect' || methodName === 'inverseSelect') {
      legendModel[methodName]();
    } else {
      legendModel[methodName](payload.name);
      isSelected = legendModel.isSelected(payload.name);
    }

    var legendData = legendModel.getData();
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(legendData, function (model) {
      var name = model.get('name'); // Wrap element

      if (name === '\n' || name === '') {
        return;
      }

      var isItemSelected = legendModel.isSelected(name);

      if (selectedMap.hasOwnProperty(name)) {
        // Unselected if any legend is unselected
        selectedMap[name] = selectedMap[name] && isItemSelected;
      } else {
        selectedMap[name] = isItemSelected;
      }
    });
  }); // Return the event explicitly

  return methodName === 'allSelect' || methodName === 'inverseSelect' ? {
    selected: selectedMap
  } : {
    name: payload.name,
    selected: selectedMap
  };
}

function installLegendAction(registers) {
  /**
   * @event legendToggleSelect
   * @type {Object}
   * @property {string} type 'legendToggleSelect'
   * @property {string} [from]
   * @property {string} name Series name or data item name
   */
  registers.registerAction('legendToggleSelect', 'legendselectchanged', (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.curry)(legendSelectActionHandler, 'toggleSelected'));
  registers.registerAction('legendAllSelect', 'legendselectall', (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.curry)(legendSelectActionHandler, 'allSelect'));
  registers.registerAction('legendInverseSelect', 'legendinverseselect', (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.curry)(legendSelectActionHandler, 'inverseSelect'));
  /**
   * @event legendSelect
   * @type {Object}
   * @property {string} type 'legendSelect'
   * @property {string} name Series name or data item name
   */

  registers.registerAction('legendSelect', 'legendselected', (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.curry)(legendSelectActionHandler, 'select'));
  /**
   * @event legendUnSelect
   * @type {Object}
   * @property {string} type 'legendUnSelect'
   * @property {string} name Series name or data item name
   */

  registers.registerAction('legendUnSelect', 'legendunselected', (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.curry)(legendSelectActionHandler, 'unSelect'));
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/legendFilter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/legend/legendFilter.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ legendFilter)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function legendFilter(ecModel) {
  var legendModels = ecModel.findComponents({
    mainType: 'legend'
  });

  if (legendModels && legendModels.length) {
    ecModel.filterSeries(function (series) {
      // If in any legend component the status is not selected.
      // Because in legend series is assumed selected when it is not in the legend data.
      for (var i = 0; i < legendModels.length; i++) {
        if (!legendModels[i].isSelected(series.name)) {
          return false;
        }
      }

      return true;
    });
  }
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/legend/scrollableLegendAction.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/legend/scrollableLegendAction.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ installScrollableLegendAction)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function installScrollableLegendAction(registers) {
  /**
   * @event legendScroll
   * @type {Object}
   * @property {string} type 'legendScroll'
   * @property {string} scrollDataIndex
   */
  registers.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {
    var scrollDataIndex = payload.scrollDataIndex;
    scrollDataIndex != null && ecModel.eachComponent({
      mainType: 'legend',
      subType: 'scroll',
      query: payload
    }, function (legendModel) {
      legendModel.setScrollDataIndex(scrollDataIndex);
    });
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkAreaModel.js":
/*!********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/marker/MarkAreaModel.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _MarkerModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkerModel */ "./node_modules/echarts/lib/component/marker/MarkerModel.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var MarkAreaModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(MarkAreaModel, _super);

  function MarkAreaModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = MarkAreaModel.type;
    return _this;
  }

  MarkAreaModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {
    return new MarkAreaModel(markerOpt, masterMarkerModel, ecModel);
  };

  MarkAreaModel.type = 'markArea';
  MarkAreaModel.defaultOption = {
    zlevel: 0,
    // PENDING
    z: 1,
    tooltip: {
      trigger: 'item'
    },
    // markArea should fixed on the coordinate system
    animation: false,
    label: {
      show: true,
      position: 'top'
    },
    itemStyle: {
      // color and borderColor default to use color from series
      // color: 'auto'
      // borderColor: 'auto'
      borderWidth: 0
    },
    emphasis: {
      label: {
        show: true,
        position: 'top'
      }
    }
  };
  return MarkAreaModel;
}(_MarkerModel__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MarkAreaModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkAreaView.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/marker/MarkAreaView.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! zrender/lib/tool/color */ "./node_modules/zrender/lib/tool/color.js");
/* harmony import */ var _data_List__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../data/List */ "./node_modules/echarts/lib/data/List.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polygon.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _markerHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./markerHelper */ "./node_modules/echarts/lib/component/marker/markerHelper.js");
/* harmony import */ var _MarkerView__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./MarkerView */ "./node_modules/echarts/lib/component/marker/MarkerView.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _coord_CoordinateSystem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../coord/CoordinateSystem */ "./node_modules/echarts/lib/coord/CoordinateSystem.js");
/* harmony import */ var _MarkerModel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MarkerModel */ "./node_modules/echarts/lib/component/marker/MarkerModel.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _visual_helper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../visual/helper */ "./node_modules/echarts/lib/visual/helper.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
 // TODO Optimize on polar















var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();

var markAreaTransform = function (seriesModel, coordSys, maModel, item) {
  var lt = _markerHelper__WEBPACK_IMPORTED_MODULE_1__.dataTransform(seriesModel, item[0]);
  var rb = _markerHelper__WEBPACK_IMPORTED_MODULE_1__.dataTransform(seriesModel, item[1]); // FIXME make sure lt is less than rb

  var ltCoord = lt.coord;
  var rbCoord = rb.coord;
  ltCoord[0] = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.retrieve)(ltCoord[0], -Infinity);
  ltCoord[1] = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.retrieve)(ltCoord[1], -Infinity);
  rbCoord[0] = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.retrieve)(rbCoord[0], Infinity);
  rbCoord[1] = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.retrieve)(rbCoord[1], Infinity); // Merge option into one

  var result = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.mergeAll)([{}, lt, rb]);
  result.coord = [lt.coord, rb.coord];
  result.x0 = lt.x;
  result.y0 = lt.y;
  result.x1 = rb.x;
  result.y1 = rb.y;
  return result;
};

function isInifinity(val) {
  return !isNaN(val) && !isFinite(val);
} // If a markArea has one dim


function ifMarkAreaHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
  var otherDimIndex = 1 - dimIndex;
  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);
}

function markAreaFilter(coordSys, item) {
  var fromCoord = item.coord[0];
  var toCoord = item.coord[1];

  if ((0,_coord_CoordinateSystem__WEBPACK_IMPORTED_MODULE_3__.isCoordinateSystemType)(coordSys, 'cartesian2d')) {
    // In case
    // {
    //  markArea: {
    //    data: [{ yAxis: 2 }]
    //  }
    // }
    if (fromCoord && toCoord && (ifMarkAreaHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkAreaHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
      return true;
    }
  }

  return _markerHelper__WEBPACK_IMPORTED_MODULE_1__.dataFilter(coordSys, {
    coord: fromCoord,
    x: item.x0,
    y: item.y0
  }) || _markerHelper__WEBPACK_IMPORTED_MODULE_1__.dataFilter(coordSys, {
    coord: toCoord,
    x: item.x1,
    y: item.y1
  });
} // dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']


function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  var itemModel = data.getItemModel(idx);
  var point;
  var xPx = _util_number__WEBPACK_IMPORTED_MODULE_4__.parsePercent(itemModel.get(dims[0]), api.getWidth());
  var yPx = _util_number__WEBPACK_IMPORTED_MODULE_4__.parsePercent(itemModel.get(dims[1]), api.getHeight());

  if (!isNaN(xPx) && !isNaN(yPx)) {
    point = [xPx, yPx];
  } else {
    // Chart like bar may have there own marker positioning logic
    if (seriesModel.getMarkerPosition) {
      // Use the getMarkerPoisition
      point = seriesModel.getMarkerPosition(data.getValues(dims, idx));
    } else {
      var x = data.get(dims[0], idx);
      var y = data.get(dims[1], idx);
      var pt = [x, y];
      coordSys.clampData && coordSys.clampData(pt, pt);
      point = coordSys.dataToPoint(pt, true);
    }

    if ((0,_coord_CoordinateSystem__WEBPACK_IMPORTED_MODULE_3__.isCoordinateSystemType)(coordSys, 'cartesian2d')) {
      // TODO: TYPE ts@4.1 may still infer it as Axis instead of Axis2D. Not sure if it's a bug
      var xAxis = coordSys.getAxis('x');
      var yAxis = coordSys.getAxis('y');
      var x = data.get(dims[0], idx);
      var y = data.get(dims[1], idx);

      if (isInifinity(x)) {
        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);
      } else if (isInifinity(y)) {
        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);
      }
    } // Use x, y if has any


    if (!isNaN(xPx)) {
      point[0] = xPx;
    }

    if (!isNaN(yPx)) {
      point[1] = yPx;
    }
  }

  return point;
}

var dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];

var MarkAreaView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__extends)(MarkAreaView, _super);

  function MarkAreaView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = MarkAreaView.type;
    return _this;
  }

  MarkAreaView.prototype.updateTransform = function (markAreaModel, ecModel, api) {
    ecModel.eachSeries(function (seriesModel) {
      var maModel = _MarkerModel__WEBPACK_IMPORTED_MODULE_6__.default.getMarkerModelFromSeries(seriesModel, 'markArea');

      if (maModel) {
        var areaData_1 = maModel.getData();
        areaData_1.each(function (idx) {
          var points = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.map)(dimPermutations, function (dim) {
            return getSingleMarkerEndPoint(areaData_1, idx, dim, seriesModel, api);
          }); // Layout

          areaData_1.setItemLayout(idx, points);
          var el = areaData_1.getItemGraphicEl(idx);
          el.setShape('points', points);
        });
      }
    }, this);
  };

  MarkAreaView.prototype.renderSeries = function (seriesModel, maModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var areaGroupMap = this.markerGroupMap;
    var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {
      group: new _util_graphic__WEBPACK_IMPORTED_MODULE_7__.default()
    });
    this.group.add(polygonGroup.group);
    this.markKeep(polygonGroup);
    var areaData = createList(coordSys, seriesModel, maModel); // Line data for tooltip and formatter

    maModel.setData(areaData); // Update visual and layout of line

    areaData.each(function (idx) {
      // Layout
      var points = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.map)(dimPermutations, function (dim) {
        return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
      }); // If none of the area is inside coordSys, allClipped is set to be true
      // in layout so that label will not be displayed. See #12591

      var allClipped = true;
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(dimPermutations, function (dim) {
        if (!allClipped) {
          return;
        }

        var xValue = areaData.get(dim[0], idx);
        var yValue = areaData.get(dim[1], idx); // If is infinity, the axis should be considered not clipped

        if ((isInifinity(xValue) || coordSys.getAxis('x').containData(xValue)) && (isInifinity(yValue) || coordSys.getAxis('y').containData(yValue))) {
          allClipped = false;
        }
      });
      areaData.setItemLayout(idx, {
        points: points,
        allClipped: allClipped
      });
      var style = areaData.getItemModel(idx).getModel('itemStyle').getItemStyle();
      var color = (0,_visual_helper__WEBPACK_IMPORTED_MODULE_8__.getVisualFromData)(seriesData, 'color');

      if (!style.fill) {
        style.fill = color;

        if (typeof style.fill === 'string') {
          style.fill = zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_9__.modifyAlpha(style.fill, 0.4);
        }
      }

      if (!style.stroke) {
        style.stroke = color;
      } // Visual


      areaData.setItemVisual(idx, 'style', style);
    });
    areaData.diff(inner(polygonGroup).data).add(function (idx) {
      var layout = areaData.getItemLayout(idx);

      if (!layout.allClipped) {
        var polygon = new _util_graphic__WEBPACK_IMPORTED_MODULE_10__.default({
          shape: {
            points: layout.points
          }
        });
        areaData.setItemGraphicEl(idx, polygon);
        polygonGroup.group.add(polygon);
      }
    }).update(function (newIdx, oldIdx) {
      var polygon = inner(polygonGroup).data.getItemGraphicEl(oldIdx);
      var layout = areaData.getItemLayout(newIdx);

      if (!layout.allClipped) {
        if (polygon) {
          _util_graphic__WEBPACK_IMPORTED_MODULE_11__.updateProps(polygon, {
            shape: {
              points: layout.points
            }
          }, maModel, newIdx);
        } else {
          polygon = new _util_graphic__WEBPACK_IMPORTED_MODULE_10__.default({
            shape: {
              points: layout.points
            }
          });
        }

        areaData.setItemGraphicEl(newIdx, polygon);
        polygonGroup.group.add(polygon);
      } else if (polygon) {
        polygonGroup.group.remove(polygon);
      }
    }).remove(function (idx) {
      var polygon = inner(polygonGroup).data.getItemGraphicEl(idx);
      polygonGroup.group.remove(polygon);
    }).execute();
    areaData.eachItemGraphicEl(function (polygon, idx) {
      var itemModel = areaData.getItemModel(idx);
      var style = areaData.getItemVisual(idx, 'style');
      polygon.useStyle(areaData.getItemVisual(idx, 'style'));
      (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_12__.setLabelStyle)(polygon, (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_12__.getLabelStatesModels)(itemModel), {
        labelFetcher: maModel,
        labelDataIndex: idx,
        defaultText: areaData.getName(idx) || '',
        inheritColor: typeof style.fill === 'string' ? zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_9__.modifyAlpha(style.fill, 1) : '#000'
      });
      (0,_util_states__WEBPACK_IMPORTED_MODULE_13__.setStatesStylesFromModel)(polygon, itemModel);
      (0,_util_states__WEBPACK_IMPORTED_MODULE_13__.enableHoverEmphasis)(polygon);
      (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_14__.getECData)(polygon).dataModel = maModel;
    });
    inner(polygonGroup).data = areaData;
    polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');
  };

  MarkAreaView.type = 'markArea';
  return MarkAreaView;
}(_MarkerView__WEBPACK_IMPORTED_MODULE_15__.default);

function createList(coordSys, seriesModel, maModel) {
  var coordDimsInfos;
  var areaData;
  var dims = ['x0', 'y0', 'x1', 'y1'];

  if (coordSys) {
    coordDimsInfos = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.map)(coordSys && coordSys.dimensions, function (coordDim) {
      var data = seriesModel.getData();
      var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

      return (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.defaults)({
        name: coordDim
      }, info);
    });
    areaData = new _data_List__WEBPACK_IMPORTED_MODULE_16__.default((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.map)(dims, function (dim, idx) {
      return {
        name: dim,
        type: coordDimsInfos[idx % 2].type
      };
    }), maModel);
  } else {
    coordDimsInfos = [{
      name: 'value',
      type: 'float'
    }];
    areaData = new _data_List__WEBPACK_IMPORTED_MODULE_16__.default(coordDimsInfos, maModel);
  }

  var optData = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.map)(maModel.get('data'), (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.curry)(markAreaTransform, seriesModel, coordSys, maModel));

  if (coordSys) {
    optData = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.filter)(optData, (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.curry)(markAreaFilter, coordSys));
  }

  var dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) {
    // TODO should convert to ParsedValue?
    return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];
  } : function (item) {
    return item.value;
  };
  areaData.initData(optData, null, dimValueGetter);
  areaData.hasItemOption = true;
  return areaData;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MarkAreaView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkLineModel.js":
/*!********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/marker/MarkLineModel.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _MarkerModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkerModel */ "./node_modules/echarts/lib/component/marker/MarkerModel.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var MarkLineModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(MarkLineModel, _super);

  function MarkLineModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = MarkLineModel.type;
    return _this;
  }

  MarkLineModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {
    return new MarkLineModel(markerOpt, masterMarkerModel, ecModel);
  };

  MarkLineModel.type = 'markLine';
  MarkLineModel.defaultOption = {
    zlevel: 0,
    z: 5,
    symbol: ['circle', 'arrow'],
    symbolSize: [8, 16],
    //symbolRotate: 0,
    precision: 2,
    tooltip: {
      trigger: 'item'
    },
    label: {
      show: true,
      position: 'end',
      distance: 5
    },
    lineStyle: {
      type: 'dashed'
    },
    emphasis: {
      label: {
        show: true
      },
      lineStyle: {
        width: 3
      }
    },
    animationEasing: 'linear'
  };
  return MarkLineModel;
}(_MarkerModel__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MarkLineModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkLineView.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/marker/MarkLineView.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _data_List__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../data/List */ "./node_modules/echarts/lib/data/List.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _markerHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./markerHelper */ "./node_modules/echarts/lib/component/marker/markerHelper.js");
/* harmony import */ var _chart_helper_LineDraw__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../chart/helper/LineDraw */ "./node_modules/echarts/lib/chart/helper/LineDraw.js");
/* harmony import */ var _MarkerView__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./MarkerView */ "./node_modules/echarts/lib/component/marker/MarkerView.js");
/* harmony import */ var _data_helper_dataStackHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/helper/dataStackHelper */ "./node_modules/echarts/lib/data/helper/dataStackHelper.js");
/* harmony import */ var _coord_CoordinateSystem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../coord/CoordinateSystem */ "./node_modules/echarts/lib/coord/CoordinateSystem.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _MarkerModel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MarkerModel */ "./node_modules/echarts/lib/component/marker/MarkerModel.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _visual_helper__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../visual/helper */ "./node_modules/echarts/lib/visual/helper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/













var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();

var markLineTransform = function (seriesModel, coordSys, mlModel, item) {
  var data = seriesModel.getData();
  var itemArray;

  if (!(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(item)) {
    // Special type markLine like 'min', 'max', 'average', 'median'
    var mlType = item.type;

    if (mlType === 'min' || mlType === 'max' || mlType === 'average' || mlType === 'median' // In case
    // data: [{
    //   yAxis: 10
    // }]
    || item.xAxis != null || item.yAxis != null) {
      var valueAxis = void 0;
      var value = void 0;

      if (item.yAxis != null || item.xAxis != null) {
        valueAxis = coordSys.getAxis(item.yAxis != null ? 'y' : 'x');
        value = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.retrieve)(item.yAxis, item.xAxis);
      } else {
        var axisInfo = _markerHelper__WEBPACK_IMPORTED_MODULE_2__.getAxisInfo(item, data, coordSys, seriesModel);
        valueAxis = axisInfo.valueAxis;
        var valueDataDim = (0,_data_helper_dataStackHelper__WEBPACK_IMPORTED_MODULE_3__.getStackedDimension)(data, axisInfo.valueDataDim);
        value = _markerHelper__WEBPACK_IMPORTED_MODULE_2__.numCalculate(data, valueDataDim, mlType);
      }

      var valueIndex = valueAxis.dim === 'x' ? 0 : 1;
      var baseIndex = 1 - valueIndex; // Normized to 2d data with start and end point

      var mlFrom = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone)(item);
      var mlTo = {
        coord: []
      };
      mlFrom.type = null;
      mlFrom.coord = [];
      mlFrom.coord[baseIndex] = -Infinity;
      mlTo.coord[baseIndex] = Infinity;
      var precision = mlModel.get('precision');

      if (precision >= 0 && typeof value === 'number') {
        value = +value.toFixed(Math.min(precision, 20));
      }

      mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
      itemArray = [mlFrom, mlTo, {
        type: mlType,
        valueIndex: item.valueIndex,
        // Force to use the value of calculated value.
        value: value
      }];
    } else {
      // Invalid data
      if (true) {
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.logError)('Invalid markLine data.');
      }

      itemArray = [];
    }
  } else {
    itemArray = item;
  }

  var normalizedItem = [_markerHelper__WEBPACK_IMPORTED_MODULE_2__.dataTransform(seriesModel, itemArray[0]), _markerHelper__WEBPACK_IMPORTED_MODULE_2__.dataTransform(seriesModel, itemArray[1]), (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, itemArray[2])]; // Avoid line data type is extended by from(to) data type

  normalizedItem[2].type = normalizedItem[2].type || null; // Merge from option and to option into line option

  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge)(normalizedItem[2], normalizedItem[0]);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge)(normalizedItem[2], normalizedItem[1]);
  return normalizedItem;
};

function isInifinity(val) {
  return !isNaN(val) && !isFinite(val);
} // If a markLine has one dim


function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
  var otherDimIndex = 1 - dimIndex;
  var dimName = coordSys.dimensions[dimIndex];
  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
}

function markLineFilter(coordSys, item) {
  if (coordSys.type === 'cartesian2d') {
    var fromCoord = item[0].coord;
    var toCoord = item[1].coord; // In case
    // {
    //  markLine: {
    //    data: [{ yAxis: 2 }]
    //  }
    // }

    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
      return true;
    }
  }

  return _markerHelper__WEBPACK_IMPORTED_MODULE_2__.dataFilter(coordSys, item[0]) && _markerHelper__WEBPACK_IMPORTED_MODULE_2__.dataFilter(coordSys, item[1]);
}

function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  var itemModel = data.getItemModel(idx);
  var point;
  var xPx = _util_number__WEBPACK_IMPORTED_MODULE_4__.parsePercent(itemModel.get('x'), api.getWidth());
  var yPx = _util_number__WEBPACK_IMPORTED_MODULE_4__.parsePercent(itemModel.get('y'), api.getHeight());

  if (!isNaN(xPx) && !isNaN(yPx)) {
    point = [xPx, yPx];
  } else {
    // Chart like bar may have there own marker positioning logic
    if (seriesModel.getMarkerPosition) {
      // Use the getMarkerPoisition
      point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
    } else {
      var dims = coordSys.dimensions;
      var x = data.get(dims[0], idx);
      var y = data.get(dims[1], idx);
      point = coordSys.dataToPoint([x, y]);
    } // Expand line to the edge of grid if value on one axis is Inifnity
    // In case
    //  markLine: {
    //    data: [{
    //      yAxis: 2
    //      // or
    //      type: 'average'
    //    }]
    //  }


    if ((0,_coord_CoordinateSystem__WEBPACK_IMPORTED_MODULE_5__.isCoordinateSystemType)(coordSys, 'cartesian2d')) {
      // TODO: TYPE ts@4.1 may still infer it as Axis instead of Axis2D. Not sure if it's a bug
      var xAxis = coordSys.getAxis('x');
      var yAxis = coordSys.getAxis('y');
      var dims = coordSys.dimensions;

      if (isInifinity(data.get(dims[0], idx))) {
        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
      } else if (isInifinity(data.get(dims[1], idx))) {
        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
      }
    } // Use x, y if has any


    if (!isNaN(xPx)) {
      point[0] = xPx;
    }

    if (!isNaN(yPx)) {
      point[1] = yPx;
    }
  }

  data.setItemLayout(idx, point);
}

var MarkLineView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__extends)(MarkLineView, _super);

  function MarkLineView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = MarkLineView.type;
    return _this;
  }

  MarkLineView.prototype.updateTransform = function (markLineModel, ecModel, api) {
    ecModel.eachSeries(function (seriesModel) {
      var mlModel = _MarkerModel__WEBPACK_IMPORTED_MODULE_7__.default.getMarkerModelFromSeries(seriesModel, 'markLine');

      if (mlModel) {
        var mlData_1 = mlModel.getData();
        var fromData_1 = inner(mlModel).from;
        var toData_1 = inner(mlModel).to; // Update visual and layout of from symbol and to symbol

        fromData_1.each(function (idx) {
          updateSingleMarkerEndLayout(fromData_1, idx, true, seriesModel, api);
          updateSingleMarkerEndLayout(toData_1, idx, false, seriesModel, api);
        }); // Update layout of line

        mlData_1.each(function (idx) {
          mlData_1.setItemLayout(idx, [fromData_1.getItemLayout(idx), toData_1.getItemLayout(idx)]);
        });
        this.markerGroupMap.get(seriesModel.id).updateLayout();
      }
    }, this);
  };

  MarkLineView.prototype.renderSeries = function (seriesModel, mlModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var lineDrawMap = this.markerGroupMap;
    var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new _chart_helper_LineDraw__WEBPACK_IMPORTED_MODULE_8__.default());
    this.group.add(lineDraw.group);
    var mlData = createList(coordSys, seriesModel, mlModel);
    var fromData = mlData.from;
    var toData = mlData.to;
    var lineData = mlData.line;
    inner(mlModel).from = fromData;
    inner(mlModel).to = toData; // Line data for tooltip and formatter

    mlModel.setData(lineData);
    var symbolType = mlModel.get('symbol');
    var symbolSize = mlModel.get('symbolSize');

    if (!(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(symbolType)) {
      symbolType = [symbolType, symbolType];
    }

    if (!(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(symbolSize)) {
      symbolSize = [symbolSize, symbolSize];
    } // Update visual and layout of from symbol and to symbol


    mlData.from.each(function (idx) {
      updateDataVisualAndLayout(fromData, idx, true);
      updateDataVisualAndLayout(toData, idx, false);
    }); // Update visual and layout of line

    lineData.each(function (idx) {
      var lineStyle = lineData.getItemModel(idx).getModel('lineStyle').getLineStyle(); // lineData.setItemVisual(idx, {
      //     color: lineColor || fromData.getItemVisual(idx, 'color')
      // });

      lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);

      if (lineStyle.stroke == null) {
        lineStyle.stroke = fromData.getItemVisual(idx, 'style').fill;
      }

      lineData.setItemVisual(idx, {
        fromSymbolRotate: fromData.getItemVisual(idx, 'symbolRotate'),
        fromSymbolSize: fromData.getItemVisual(idx, 'symbolSize'),
        fromSymbol: fromData.getItemVisual(idx, 'symbol'),
        toSymbolRotate: toData.getItemVisual(idx, 'symbolRotate'),
        toSymbolSize: toData.getItemVisual(idx, 'symbolSize'),
        toSymbol: toData.getItemVisual(idx, 'symbol'),
        style: lineStyle
      });
    });
    lineDraw.updateData(lineData); // Set host model for tooltip
    // FIXME

    mlData.line.eachItemGraphicEl(function (el, idx) {
      el.traverse(function (child) {
        (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_9__.getECData)(child).dataModel = mlModel;
      });
    });

    function updateDataVisualAndLayout(data, idx, isFrom) {
      var itemModel = data.getItemModel(idx);
      updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
      var style = itemModel.getModel('itemStyle').getItemStyle();

      if (style.fill == null) {
        style.fill = (0,_visual_helper__WEBPACK_IMPORTED_MODULE_10__.getVisualFromData)(seriesData, 'color');
      }

      data.setItemVisual(idx, {
        symbolRotate: itemModel.get('symbolRotate'),
        symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],
        symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],
        style: style
      });
    }

    this.markKeep(lineDraw);
    lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');
  };

  MarkLineView.type = 'markLine';
  return MarkLineView;
}(_MarkerView__WEBPACK_IMPORTED_MODULE_11__.default);

function createList(coordSys, seriesModel, mlModel) {
  var coordDimsInfos;

  if (coordSys) {
    coordDimsInfos = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map)(coordSys && coordSys.dimensions, function (coordDim) {
      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

      return (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults)({
        name: coordDim
      }, info);
    });
  } else {
    coordDimsInfos = [{
      name: 'value',
      type: 'float'
    }];
  }

  var fromData = new _data_List__WEBPACK_IMPORTED_MODULE_12__.default(coordDimsInfos, mlModel);
  var toData = new _data_List__WEBPACK_IMPORTED_MODULE_12__.default(coordDimsInfos, mlModel); // No dimensions

  var lineData = new _data_List__WEBPACK_IMPORTED_MODULE_12__.default([], mlModel);
  var optData = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map)(mlModel.get('data'), (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry)(markLineTransform, seriesModel, coordSys, mlModel));

  if (coordSys) {
    optData = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.filter)(optData, (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry)(markLineFilter, coordSys));
  }

  var dimValueGetter = coordSys ? _markerHelper__WEBPACK_IMPORTED_MODULE_2__.dimValueGetter : function (item) {
    return item.value;
  };
  fromData.initData((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map)(optData, function (item) {
    return item[0];
  }), null, dimValueGetter);
  toData.initData((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map)(optData, function (item) {
    return item[1];
  }), null, dimValueGetter);
  lineData.initData((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map)(optData, function (item) {
    return item[2];
  }));
  lineData.hasItemOption = true;
  return {
    from: fromData,
    to: toData,
    line: lineData
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MarkLineView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkPointModel.js":
/*!*********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/marker/MarkPointModel.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _MarkerModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkerModel */ "./node_modules/echarts/lib/component/marker/MarkerModel.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var MarkPointModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(MarkPointModel, _super);

  function MarkPointModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = MarkPointModel.type;
    return _this;
  }

  MarkPointModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {
    return new MarkPointModel(markerOpt, masterMarkerModel, ecModel);
  };

  MarkPointModel.type = 'markPoint';
  MarkPointModel.defaultOption = {
    zlevel: 0,
    z: 5,
    symbol: 'pin',
    symbolSize: 50,
    //symbolRotate: 0,
    //symbolOffset: [0, 0]
    tooltip: {
      trigger: 'item'
    },
    label: {
      show: true,
      position: 'inside'
    },
    itemStyle: {
      borderWidth: 2
    },
    emphasis: {
      label: {
        show: true
      }
    }
  };
  return MarkPointModel;
}(_MarkerModel__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MarkPointModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkPointView.js":
/*!********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/marker/MarkPointView.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _chart_helper_SymbolDraw__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../chart/helper/SymbolDraw */ "./node_modules/echarts/lib/chart/helper/SymbolDraw.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _data_List__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../data/List */ "./node_modules/echarts/lib/data/List.js");
/* harmony import */ var _markerHelper__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./markerHelper */ "./node_modules/echarts/lib/component/marker/markerHelper.js");
/* harmony import */ var _MarkerView__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MarkerView */ "./node_modules/echarts/lib/component/marker/MarkerView.js");
/* harmony import */ var _MarkerModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MarkerModel */ "./node_modules/echarts/lib/component/marker/MarkerModel.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _visual_helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../visual/helper */ "./node_modules/echarts/lib/visual/helper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/











function updateMarkerLayout(mpData, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  mpData.each(function (idx) {
    var itemModel = mpData.getItemModel(idx);
    var point;
    var xPx = _util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent(itemModel.get('x'), api.getWidth());
    var yPx = _util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent(itemModel.get('y'), api.getHeight());

    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx];
    } // Chart like bar may have there own marker positioning logic
    else if (seriesModel.getMarkerPosition) {
        // Use the getMarkerPoisition
        point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
      } else if (coordSys) {
        var x = mpData.get(coordSys.dimensions[0], idx);
        var y = mpData.get(coordSys.dimensions[1], idx);
        point = coordSys.dataToPoint([x, y]);
      } // Use x, y if has any


    if (!isNaN(xPx)) {
      point[0] = xPx;
    }

    if (!isNaN(yPx)) {
      point[1] = yPx;
    }

    mpData.setItemLayout(idx, point);
  });
}

var MarkPointView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(MarkPointView, _super);

  function MarkPointView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = MarkPointView.type;
    return _this;
  }

  MarkPointView.prototype.updateTransform = function (markPointModel, ecModel, api) {
    ecModel.eachSeries(function (seriesModel) {
      var mpModel = _MarkerModel__WEBPACK_IMPORTED_MODULE_2__.default.getMarkerModelFromSeries(seriesModel, 'markPoint');

      if (mpModel) {
        updateMarkerLayout(mpModel.getData(), seriesModel, api);
        this.markerGroupMap.get(seriesModel.id).updateLayout();
      }
    }, this);
  };

  MarkPointView.prototype.renderSeries = function (seriesModel, mpModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var symbolDrawMap = this.markerGroupMap;
    var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new _chart_helper_SymbolDraw__WEBPACK_IMPORTED_MODULE_3__.default());
    var mpData = createList(coordSys, seriesModel, mpModel); // FIXME

    mpModel.setData(mpData);
    updateMarkerLayout(mpModel.getData(), seriesModel, api);
    mpData.each(function (idx) {
      var itemModel = mpData.getItemModel(idx);
      var symbol = itemModel.getShallow('symbol');
      var symbolSize = itemModel.getShallow('symbolSize');
      var symbolRotate = itemModel.getShallow('symbolRotate');

      if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.isFunction)(symbol) || (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.isFunction)(symbolSize) || (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.isFunction)(symbolRotate)) {
        var rawIdx = mpModel.getRawValue(idx);
        var dataParams = mpModel.getDataParams(idx);

        if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.isFunction)(symbol)) {
          symbol = symbol(rawIdx, dataParams);
        }

        if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.isFunction)(symbolSize)) {
          // FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？
          symbolSize = symbolSize(rawIdx, dataParams);
        }

        if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.isFunction)(symbolRotate)) {
          symbolRotate = symbolRotate(rawIdx, dataParams);
        }
      }

      var style = itemModel.getModel('itemStyle').getItemStyle();
      var color = (0,_visual_helper__WEBPACK_IMPORTED_MODULE_5__.getVisualFromData)(seriesData, 'color');

      if (!style.fill) {
        style.fill = color;
      }

      mpData.setItemVisual(idx, {
        symbol: symbol,
        symbolSize: symbolSize,
        symbolRotate: symbolRotate,
        style: style
      });
    }); // TODO Text are wrong

    symbolDraw.updateData(mpData);
    this.group.add(symbolDraw.group); // Set host model for tooltip
    // FIXME

    mpData.eachItemGraphicEl(function (el) {
      el.traverse(function (child) {
        (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_6__.getECData)(child).dataModel = mpModel;
      });
    });
    this.markKeep(symbolDraw);
    symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');
  };

  MarkPointView.type = 'markPoint';
  return MarkPointView;
}(_MarkerView__WEBPACK_IMPORTED_MODULE_7__.default);

function createList(coordSys, seriesModel, mpModel) {
  var coordDimsInfos;

  if (coordSys) {
    coordDimsInfos = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.map)(coordSys && coordSys.dimensions, function (coordDim) {
      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

      return (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.defaults)({
        name: coordDim
      }, info);
    });
  } else {
    coordDimsInfos = [{
      name: 'value',
      type: 'float'
    }];
  }

  var mpData = new _data_List__WEBPACK_IMPORTED_MODULE_8__.default(coordDimsInfos, mpModel);
  var dataOpt = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.map)(mpModel.get('data'), (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.curry)(_markerHelper__WEBPACK_IMPORTED_MODULE_9__.dataTransform, seriesModel));

  if (coordSys) {
    dataOpt = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.filter)(dataOpt, (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.curry)(_markerHelper__WEBPACK_IMPORTED_MODULE_9__.dataFilter, coordSys));
  }

  mpData.initData(dataOpt, null, coordSys ? _markerHelper__WEBPACK_IMPORTED_MODULE_9__.dimValueGetter : function (item) {
    return item.value;
  });
  return mpData;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MarkPointView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkerModel.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/marker/MarkerModel.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/env */ "./node_modules/zrender/lib/core/env.js");
/* harmony import */ var _model_mixin_dataFormat__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../model/mixin/dataFormat */ "./node_modules/echarts/lib/model/mixin/dataFormat.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tooltip/tooltipMarkup */ "./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








function fillLabel(opt) {
  (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.defaultEmphasis)(opt, 'label', ['show']);
} // { [componentType]: MarkerModel }


var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();

var MarkerModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(MarkerModel, _super);

  function MarkerModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = MarkerModel.type;
    /**
     * If marker model is created by self from series
     */

    _this.createdBySelf = false;
    return _this;
  }
  /**
   * @overrite
   */


  MarkerModel.prototype.init = function (option, parentModel, ecModel) {
    if (true) {
      if (this.type === 'marker') {
        throw new Error('Marker component is abstract component. Use markLine, markPoint, markArea instead.');
      }
    }

    this.mergeDefaultAndTheme(option, ecModel);

    this._mergeOption(option, ecModel, false, true);
  };

  MarkerModel.prototype.isAnimationEnabled = function () {
    if (zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_2__.default.node) {
      return false;
    }

    var hostSeries = this.__hostSeries;
    return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();
  };
  /**
   * @overrite
   */


  MarkerModel.prototype.mergeOption = function (newOpt, ecModel) {
    this._mergeOption(newOpt, ecModel, false, false);
  };

  MarkerModel.prototype._mergeOption = function (newOpt, ecModel, createdBySelf, isInit) {
    var componentType = this.mainType;

    if (!createdBySelf) {
      ecModel.eachSeries(function (seriesModel) {
        // mainType can be markPoint, markLine, markArea
        var markerOpt = seriesModel.get(this.mainType, true);
        var markerModel = inner(seriesModel)[componentType];

        if (!markerOpt || !markerOpt.data) {
          inner(seriesModel)[componentType] = null;
          return;
        }

        if (!markerModel) {
          if (isInit) {
            // Default label emphasis `position` and `show`
            fillLabel(markerOpt);
          }

          zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.each(markerOpt.data, function (item) {
            // FIXME Overwrite fillLabel method ?
            if (item instanceof Array) {
              fillLabel(item[0]);
              fillLabel(item[1]);
            } else {
              fillLabel(item);
            }
          });
          markerModel = this.createMarkerModelFromSeries(markerOpt, this, ecModel); // markerModel = new ImplementedMarkerModel(
          //     markerOpt, this, ecModel
          // );

          zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.extend(markerModel, {
            mainType: this.mainType,
            // Use the same series index and name
            seriesIndex: seriesModel.seriesIndex,
            name: seriesModel.name,
            createdBySelf: true
          });
          markerModel.__hostSeries = seriesModel;
        } else {
          markerModel._mergeOption(markerOpt, ecModel, true);
        }

        inner(seriesModel)[componentType] = markerModel;
      }, this);
    }
  };

  MarkerModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var value = this.getRawValue(dataIndex);
    var itemName = data.getName(dataIndex);
    return (0,_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_4__.createTooltipMarkup)('section', {
      header: this.name,
      blocks: [(0,_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_4__.createTooltipMarkup)('nameValue', {
        name: itemName,
        value: value,
        noName: !itemName,
        noValue: value == null
      })]
    });
  };

  MarkerModel.prototype.getData = function () {
    return this._data;
  };

  MarkerModel.prototype.setData = function (data) {
    this._data = data;
  };

  MarkerModel.getMarkerModelFromSeries = function (seriesModel, // Support three types of markers. Strict check.
  componentType) {
    return inner(seriesModel)[componentType];
  };

  MarkerModel.type = 'marker';
  MarkerModel.dependencies = ['series', 'grid', 'polar', 'geo'];
  return MarkerModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_5__.default);

zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.mixin(MarkerModel, _model_mixin_dataFormat__WEBPACK_IMPORTED_MODULE_6__.DataFormatMixin.prototype);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MarkerModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/MarkerView.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/marker/MarkerView.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _MarkerModel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MarkerModel */ "./node_modules/echarts/lib/component/marker/MarkerModel.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();

var MarkerView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(MarkerView, _super);

  function MarkerView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = MarkerView.type;
    return _this;
  }

  MarkerView.prototype.init = function () {
    this.markerGroupMap = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.createHashMap)();
  };

  MarkerView.prototype.render = function (markerModel, ecModel, api) {
    var _this = this;

    var markerGroupMap = this.markerGroupMap;
    markerGroupMap.each(function (item) {
      inner(item).keep = false;
    });
    ecModel.eachSeries(function (seriesModel) {
      var markerModel = _MarkerModel__WEBPACK_IMPORTED_MODULE_3__.default.getMarkerModelFromSeries(seriesModel, _this.type);
      markerModel && _this.renderSeries(seriesModel, markerModel, ecModel, api);
    });
    markerGroupMap.each(function (item) {
      !inner(item).keep && _this.group.remove(item.group);
    });
  };

  MarkerView.prototype.markKeep = function (drawGroup) {
    inner(drawGroup).keep = true;
  };

  MarkerView.prototype.blurSeries = function (seriesModelList) {
    var _this = this;

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(seriesModelList, function (seriesModel) {
      var markerModel = _MarkerModel__WEBPACK_IMPORTED_MODULE_3__.default.getMarkerModelFromSeries(seriesModel, _this.type);

      if (markerModel) {
        var data = markerModel.getData();
        data.eachItemGraphicEl(function (el) {
          if (el) {
            (0,_util_states__WEBPACK_IMPORTED_MODULE_4__.enterBlur)(el);
          }
        });
      }
    });
  };

  MarkerView.type = 'marker';
  return MarkerView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_5__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MarkerView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/installMarkArea.js":
/*!**********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/marker/installMarkArea.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _MarkAreaModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MarkAreaModel */ "./node_modules/echarts/lib/component/marker/MarkAreaModel.js");
/* harmony import */ var _MarkAreaView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkAreaView */ "./node_modules/echarts/lib/component/marker/MarkAreaView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function install(registers) {
  registers.registerComponentModel(_MarkAreaModel__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerComponentView(_MarkAreaView__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerPreprocessor(function (opt) {
    // Make sure markArea component is enabled
    opt.markArea = opt.markArea || {};
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/installMarkLine.js":
/*!**********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/marker/installMarkLine.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _MarkLineModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MarkLineModel */ "./node_modules/echarts/lib/component/marker/MarkLineModel.js");
/* harmony import */ var _MarkLineView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkLineView */ "./node_modules/echarts/lib/component/marker/MarkLineView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */



function install(registers) {
  registers.registerComponentModel(_MarkLineModel__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerComponentView(_MarkLineView__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerPreprocessor(function (opt) {
    // Make sure markLine component is enabled
    opt.markLine = opt.markLine || {};
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/installMarkPoint.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/marker/installMarkPoint.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _MarkPointModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MarkPointModel */ "./node_modules/echarts/lib/component/marker/MarkPointModel.js");
/* harmony import */ var _MarkPointView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkPointView */ "./node_modules/echarts/lib/component/marker/MarkPointView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */



function install(registers) {
  registers.registerComponentModel(_MarkPointModel__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerComponentView(_MarkPointView__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerPreprocessor(function (opt) {
    // Make sure markPoint component is enabled
    opt.markPoint = opt.markPoint || {};
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/marker/markerHelper.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/marker/markerHelper.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dataTransform": () => (/* binding */ dataTransform),
/* harmony export */   "getAxisInfo": () => (/* binding */ getAxisInfo),
/* harmony export */   "dataFilter": () => (/* binding */ dataFilter),
/* harmony export */   "dimValueGetter": () => (/* binding */ dimValueGetter),
/* harmony export */   "numCalculate": () => (/* binding */ numCalculate)
/* harmony export */ });
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _data_helper_dataStackHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/helper/dataStackHelper */ "./node_modules/echarts/lib/data/helper/dataStackHelper.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




function hasXOrY(item) {
  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
}

function hasXAndY(item) {
  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
} // Make it simple, do not visit all stacked value to count precision.
// function getPrecision(data, valueAxisDim, dataIndex) {
//     let precision = -1;
//     let stackedDim = data.mapDimension(valueAxisDim);
//     do {
//         precision = Math.max(
//             numberUtil.getPrecision(data.get(stackedDim, dataIndex)),
//             precision
//         );
//         let stackedOnSeries = data.getCalculationInfo('stackedOnSeries');
//         if (stackedOnSeries) {
//             let byValue = data.get(data.getCalculationInfo('stackedByDimension'), dataIndex);
//             data = stackedOnSeries.getData();
//             dataIndex = data.indexOf(data.getCalculationInfo('stackedByDimension'), byValue);
//             stackedDim = data.getCalculationInfo('stackedDimension');
//         }
//         else {
//             data = null;
//         }
//     } while (data);
//     return precision;
// }


function markerTypeCalculatorWithExtent(markerType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
  var coordArr = [];
  var stacked = (0,_data_helper_dataStackHelper__WEBPACK_IMPORTED_MODULE_0__.isDimensionStacked)(data, targetDataDim
  /*, otherDataDim*/
  );
  var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;
  var value = numCalculate(data, calcDataDim, markerType);
  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];
  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);
  coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);
  var coordArrValue = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.

  var precision = _util_number__WEBPACK_IMPORTED_MODULE_1__.getPrecision(data.get(targetDataDim, dataIndex));
  precision = Math.min(precision, 20);

  if (precision >= 0) {
    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
  }

  return [coordArr, coordArrValue];
} // TODO Specified percent


var markerTypeCalculator = {
  min: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.curry)(markerTypeCalculatorWithExtent, 'min'),
  max: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.curry)(markerTypeCalculatorWithExtent, 'max'),
  average: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.curry)(markerTypeCalculatorWithExtent, 'average'),
  median: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.curry)(markerTypeCalculatorWithExtent, 'median')
};
/**
 * Transform markPoint data item to format used in List by do the following
 * 1. Calculate statistic like `max`, `min`, `average`
 * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array
 * @param  {module:echarts/model/Series} seriesModel
 * @param  {module:echarts/coord/*} [coordSys]
 * @param  {Object} item
 * @return {Object}
 */

function dataTransform(seriesModel, item) {
  var data = seriesModel.getData();
  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly
  // 2. If `coord` is not a data array. Which uses `xAxis`,
  // `yAxis` to specify the coord on each dimension
  // parseFloat first because item.x and item.y can be percent string like '20%'

  if (item && !hasXAndY(item) && !(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(item.coord) && coordSys) {
    var dims = coordSys.dimensions;
    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option
    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value

    item = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.clone)(item);

    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
      var otherCoordIndex = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.indexOf)(dims, axisInfo.baseAxis.dim);
      var targetCoordIndex = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.indexOf)(dims, axisInfo.valueAxis.dim);
      var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);
      item.coord = coordInfo[0]; // Force to use the value of calculated value.
      // let item use the value without stack.

      item.value = coordInfo[1];
    } else {
      // FIXME Only has one of xAxis and yAxis.
      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average

      for (var i = 0; i < 2; i++) {
        if (markerTypeCalculator[coord[i]]) {
          coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);
        }
      }

      item.coord = coord;
    }
  }

  return item;
}
function getAxisInfo(item, data, coordSys, seriesModel) {
  var ret = {};

  if (item.valueIndex != null || item.valueDim != null) {
    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));
    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
  } else {
    ret.baseAxis = seriesModel.getBaseAxis();
    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);
  }

  return ret;
}

function dataDimToCoordDim(seriesModel, dataDim) {
  var data = seriesModel.getData();
  var dimensions = data.dimensions;
  dataDim = data.getDimension(dataDim);

  for (var i = 0; i < dimensions.length; i++) {
    var dimItem = data.getDimensionInfo(dimensions[i]);

    if (dimItem.name === dataDim) {
      return dimItem.coordDim;
    }
  }
}
/**
 * Filter data which is out of coordinateSystem range
 * [dataFilter description]
 */


function dataFilter( // Currently only polar and cartesian has containData.
coordSys, item) {
  // Alwalys return true if there is no coordSys
  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
}
function dimValueGetter(item, dimName, dataIndex, dimIndex) {
  // x, y, radius, angle
  if (dimIndex < 2) {
    return item.coord && item.coord[dimIndex];
  }

  return item.value;
}
function numCalculate(data, valueDataDim, type) {
  if (type === 'average') {
    var sum_1 = 0;
    var count_1 = 0;
    data.each(valueDataDim, function (val, idx) {
      if (!isNaN(val)) {
        sum_1 += val;
        count_1++;
      }
    });
    return sum_1 / count_1;
  } else if (type === 'median') {
    return data.getMedian(valueDataDim);
  } else {
    // max & min
    return data.getDataExtent(valueDataDim)[type === 'max' ? 1 : 0];
  }
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/polar/install.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/component/polar/install.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extension */ "./node_modules/echarts/lib/extension.js");
/* harmony import */ var _axis_AxisView__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../axis/AxisView */ "./node_modules/echarts/lib/component/axis/AxisView.js");
/* harmony import */ var _axisPointer_PolarAxisPointer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../axisPointer/PolarAxisPointer */ "./node_modules/echarts/lib/component/axisPointer/PolarAxisPointer.js");
/* harmony import */ var _axisPointer_install__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../axisPointer/install */ "./node_modules/echarts/lib/component/axisPointer/install.js");
/* harmony import */ var _coord_polar_PolarModel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../coord/polar/PolarModel */ "./node_modules/echarts/lib/coord/polar/PolarModel.js");
/* harmony import */ var _coord_axisModelCreator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../coord/axisModelCreator */ "./node_modules/echarts/lib/coord/axisModelCreator.js");
/* harmony import */ var _coord_polar_AxisModel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../coord/polar/AxisModel */ "./node_modules/echarts/lib/coord/polar/AxisModel.js");
/* harmony import */ var _coord_polar_polarCreator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../coord/polar/polarCreator */ "./node_modules/echarts/lib/coord/polar/polarCreator.js");
/* harmony import */ var _axis_AngleAxisView__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../axis/AngleAxisView */ "./node_modules/echarts/lib/component/axis/AngleAxisView.js");
/* harmony import */ var _axis_RadiusAxisView__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../axis/RadiusAxisView */ "./node_modules/echarts/lib/component/axis/RadiusAxisView.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _layout_barPolar__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../layout/barPolar */ "./node_modules/echarts/lib/layout/barPolar.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/














var angleAxisExtraOption = {
  startAngle: 90,
  clockwise: true,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
};
var radiusAxisExtraOption = {
  splitNumber: 5
};

var PolarView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(PolarView, _super);

  function PolarView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = PolarView.type;
    return _this;
  }

  PolarView.type = 'polar';
  return PolarView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_1__.default);

function install(registers) {
  (0,_extension__WEBPACK_IMPORTED_MODULE_2__.use)(_axisPointer_install__WEBPACK_IMPORTED_MODULE_3__.install);
  _axis_AxisView__WEBPACK_IMPORTED_MODULE_4__.default.registerAxisPointerClass('PolarAxisPointer', _axisPointer_PolarAxisPointer__WEBPACK_IMPORTED_MODULE_5__.default);
  registers.registerCoordinateSystem('polar', _coord_polar_polarCreator__WEBPACK_IMPORTED_MODULE_6__.default);
  registers.registerComponentModel(_coord_polar_PolarModel__WEBPACK_IMPORTED_MODULE_7__.default);
  registers.registerComponentView(PolarView); // Model and view for angleAxis and radiusAxis

  (0,_coord_axisModelCreator__WEBPACK_IMPORTED_MODULE_8__.default)(registers, 'angle', _coord_polar_AxisModel__WEBPACK_IMPORTED_MODULE_9__.AngleAxisModel, angleAxisExtraOption);
  (0,_coord_axisModelCreator__WEBPACK_IMPORTED_MODULE_8__.default)(registers, 'radius', _coord_polar_AxisModel__WEBPACK_IMPORTED_MODULE_9__.RadiusAxisModel, radiusAxisExtraOption);
  registers.registerComponentView(_axis_AngleAxisView__WEBPACK_IMPORTED_MODULE_10__.default);
  registers.registerComponentView(_axis_RadiusAxisView__WEBPACK_IMPORTED_MODULE_11__.default);
  registers.registerLayout((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_12__.curry)(_layout_barPolar__WEBPACK_IMPORTED_MODULE_13__.default, 'bar'));
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/singleAxis/install.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/singleAxis/install.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extension */ "./node_modules/echarts/lib/extension.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");
/* harmony import */ var _axis_SingleAxisView__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../axis/SingleAxisView */ "./node_modules/echarts/lib/component/axis/SingleAxisView.js");
/* harmony import */ var _coord_axisModelCreator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../coord/axisModelCreator */ "./node_modules/echarts/lib/coord/axisModelCreator.js");
/* harmony import */ var _coord_single_AxisModel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../coord/single/AxisModel */ "./node_modules/echarts/lib/coord/single/AxisModel.js");
/* harmony import */ var _coord_single_singleCreator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../coord/single/singleCreator */ "./node_modules/echarts/lib/coord/single/singleCreator.js");
/* harmony import */ var _axisPointer_install__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../axisPointer/install */ "./node_modules/echarts/lib/component/axisPointer/install.js");
/* harmony import */ var _axis_AxisView__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../axis/AxisView */ "./node_modules/echarts/lib/component/axis/AxisView.js");
/* harmony import */ var _axisPointer_SingleAxisPointer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../axisPointer/SingleAxisPointer */ "./node_modules/echarts/lib/component/axisPointer/SingleAxisPointer.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/











var SingleView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SingleView, _super);

  function SingleView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = SingleView.type;
    return _this;
  }

  SingleView.type = 'single';
  return SingleView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_1__.default);

function install(registers) {
  (0,_extension__WEBPACK_IMPORTED_MODULE_2__.use)(_axisPointer_install__WEBPACK_IMPORTED_MODULE_3__.install);
  _axis_AxisView__WEBPACK_IMPORTED_MODULE_4__.default.registerAxisPointerClass('SingleAxisPointer', _axisPointer_SingleAxisPointer__WEBPACK_IMPORTED_MODULE_5__.default);
  registers.registerComponentView(SingleView); // Axis

  registers.registerComponentView(_axis_SingleAxisView__WEBPACK_IMPORTED_MODULE_6__.default);
  registers.registerComponentModel(_coord_single_AxisModel__WEBPACK_IMPORTED_MODULE_7__.default);
  (0,_coord_axisModelCreator__WEBPACK_IMPORTED_MODULE_8__.default)(registers, 'single', _coord_single_AxisModel__WEBPACK_IMPORTED_MODULE_7__.default, _coord_single_AxisModel__WEBPACK_IMPORTED_MODULE_7__.default.defaultOption);
  registers.registerCoordinateSystem('single', _coord_single_singleCreator__WEBPACK_IMPORTED_MODULE_9__.default);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/timeline/SliderTimelineModel.js":
/*!****************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/timeline/SliderTimelineModel.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _TimelineModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TimelineModel */ "./node_modules/echarts/lib/component/timeline/TimelineModel.js");
/* harmony import */ var _model_mixin_dataFormat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../model/mixin/dataFormat */ "./node_modules/echarts/lib/model/mixin/dataFormat.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/component */ "./node_modules/echarts/lib/util/component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var SliderTimelineModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SliderTimelineModel, _super);

  function SliderTimelineModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = SliderTimelineModel.type;
    return _this;
  }

  SliderTimelineModel.type = 'timeline.slider';
  /**
   * @protected
   */

  SliderTimelineModel.defaultOption = (0,_util_component__WEBPACK_IMPORTED_MODULE_1__.inheritDefaultOption)(_TimelineModel__WEBPACK_IMPORTED_MODULE_2__.default.defaultOption, {
    backgroundColor: 'rgba(0,0,0,0)',
    borderColor: '#ccc',
    borderWidth: 0,
    orient: 'horizontal',
    inverse: false,
    tooltip: {
      trigger: 'item' // data item may also have tootip attr.

    },
    symbol: 'circle',
    symbolSize: 12,
    lineStyle: {
      show: true,
      width: 2,
      color: '#DAE1F5'
    },
    label: {
      position: 'auto',
      // When using number, label position is not
      // restricted by viewRect.
      // positive: right/bottom, negative: left/top
      show: true,
      interval: 'auto',
      rotate: 0,
      // formatter: null,
      // 其余属性默认使用全局文本样式，详见TEXTSTYLE
      color: '#A4B1D7'
    },
    itemStyle: {
      color: '#A4B1D7',
      borderWidth: 1
    },
    checkpointStyle: {
      symbol: 'circle',
      symbolSize: 15,
      color: '#316bf3',
      borderColor: '#fff',
      borderWidth: 2,
      shadowBlur: 2,
      shadowOffsetX: 1,
      shadowOffsetY: 1,
      shadowColor: 'rgba(0, 0, 0, 0.3)',
      // borderColor: 'rgba(194,53,49, 0.5)',
      animation: true,
      animationDuration: 300,
      animationEasing: 'quinticInOut'
    },
    controlStyle: {
      show: true,
      showPlayBtn: true,
      showPrevBtn: true,
      showNextBtn: true,
      itemSize: 24,
      itemGap: 12,
      position: 'left',
      playIcon: 'path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z',
      stopIcon: 'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z',
      nextIcon: 'M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z',
      prevIcon: 'M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z',
      prevBtnSize: 18,
      nextBtnSize: 18,
      color: '#A4B1D7',
      borderColor: '#A4B1D7',
      borderWidth: 1
    },
    emphasis: {
      label: {
        show: true,
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: '#6f778d'
      },
      itemStyle: {
        color: '#316BF3'
      },
      controlStyle: {
        color: '#316BF3',
        borderColor: '#316BF3',
        borderWidth: 2
      }
    },
    progress: {
      lineStyle: {
        color: '#316BF3'
      },
      itemStyle: {
        color: '#316BF3'
      },
      label: {
        color: '#6f778d'
      }
    },
    data: []
  });
  return SliderTimelineModel;
}(_TimelineModel__WEBPACK_IMPORTED_MODULE_2__.default);

(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.mixin)(SliderTimelineModel, _model_mixin_dataFormat__WEBPACK_IMPORTED_MODULE_4__.DataFormatMixin.prototype);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SliderTimelineModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/timeline/SliderTimelineView.js":
/*!***************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/timeline/SliderTimelineView.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! zrender/lib/core/BoundingRect */ "./node_modules/zrender/lib/core/BoundingRect.js");
/* harmony import */ var zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/matrix */ "./node_modules/zrender/lib/core/matrix.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Line.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _TimelineView__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./TimelineView */ "./node_modules/echarts/lib/component/timeline/TimelineView.js");
/* harmony import */ var _TimelineAxis__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TimelineAxis */ "./node_modules/echarts/lib/component/timeline/TimelineAxis.js");
/* harmony import */ var _util_symbol__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../../util/symbol */ "./node_modules/echarts/lib/util/symbol.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _scale_Ordinal__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../scale/Ordinal */ "./node_modules/echarts/lib/scale/Ordinal.js");
/* harmony import */ var _scale_Time__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../scale/Time */ "./node_modules/echarts/lib/scale/Time.js");
/* harmony import */ var _scale_Interval__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../scale/Interval */ "./node_modules/echarts/lib/scale/Interval.js");
/* harmony import */ var zrender_lib_contain_text__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! zrender/lib/contain/text */ "./node_modules/zrender/lib/contain/text.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tooltip/tooltipMarkup */ "./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



















var PI = Math.PI;
var labelDataIndexStore = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();

var SliderTimelineView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(SliderTimelineView, _super);

  function SliderTimelineView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = SliderTimelineView.type;
    return _this;
  }

  SliderTimelineView.prototype.init = function (ecModel, api) {
    this.api = api;
  };
  /**
   * @override
   */


  SliderTimelineView.prototype.render = function (timelineModel, ecModel, api) {
    this.model = timelineModel;
    this.api = api;
    this.ecModel = ecModel;
    this.group.removeAll();

    if (timelineModel.get('show', true)) {
      var layoutInfo_1 = this._layout(timelineModel, api);

      var mainGroup_1 = this._createGroup('_mainGroup');

      var labelGroup = this._createGroup('_labelGroup');

      var axis_1 = this._axis = this._createAxis(layoutInfo_1, timelineModel);

      timelineModel.formatTooltip = function (dataIndex) {
        var name = axis_1.scale.getLabel({
          value: dataIndex
        });
        return (0,_tooltip_tooltipMarkup__WEBPACK_IMPORTED_MODULE_2__.createTooltipMarkup)('nameValue', {
          noName: true,
          value: name
        });
      };

      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.each)(['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'], function (name) {
        this['_render' + name](layoutInfo_1, mainGroup_1, axis_1, timelineModel);
      }, this);

      this._renderAxisLabel(layoutInfo_1, labelGroup, axis_1, timelineModel);

      this._position(layoutInfo_1, timelineModel);
    }

    this._doPlayStop();

    this._updateTicksStatus();
  };
  /**
   * @override
   */


  SliderTimelineView.prototype.remove = function () {
    this._clearTimer();

    this.group.removeAll();
  };
  /**
   * @override
   */


  SliderTimelineView.prototype.dispose = function () {
    this._clearTimer();
  };

  SliderTimelineView.prototype._layout = function (timelineModel, api) {
    var labelPosOpt = timelineModel.get(['label', 'position']);
    var orient = timelineModel.get('orient');
    var viewRect = getViewRect(timelineModel, api);
    var parsedLabelPos; // Auto label offset.

    if (labelPosOpt == null || labelPosOpt === 'auto') {
      parsedLabelPos = orient === 'horizontal' ? viewRect.y + viewRect.height / 2 < api.getHeight() / 2 ? '-' : '+' : viewRect.x + viewRect.width / 2 < api.getWidth() / 2 ? '+' : '-';
    } else if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.isString)(labelPosOpt)) {
      parsedLabelPos = {
        horizontal: {
          top: '-',
          bottom: '+'
        },
        vertical: {
          left: '-',
          right: '+'
        }
      }[orient][labelPosOpt];
    } else {
      // is number
      parsedLabelPos = labelPosOpt;
    }

    var labelAlignMap = {
      horizontal: 'center',
      vertical: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'left' : 'right'
    };
    var labelBaselineMap = {
      horizontal: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'top' : 'bottom',
      vertical: 'middle'
    };
    var rotationMap = {
      horizontal: 0,
      vertical: PI / 2
    }; // Position

    var mainLength = orient === 'vertical' ? viewRect.height : viewRect.width;
    var controlModel = timelineModel.getModel('controlStyle');
    var showControl = controlModel.get('show', true);
    var controlSize = showControl ? controlModel.get('itemSize') : 0;
    var controlGap = showControl ? controlModel.get('itemGap') : 0;
    var sizePlusGap = controlSize + controlGap; // Special label rotate.

    var labelRotation = timelineModel.get(['label', 'rotate']) || 0;
    labelRotation = labelRotation * PI / 180; // To radian.

    var playPosition;
    var prevBtnPosition;
    var nextBtnPosition;
    var controlPosition = controlModel.get('position', true);
    var showPlayBtn = showControl && controlModel.get('showPlayBtn', true);
    var showPrevBtn = showControl && controlModel.get('showPrevBtn', true);
    var showNextBtn = showControl && controlModel.get('showNextBtn', true);
    var xLeft = 0;
    var xRight = mainLength; // position[0] means left, position[1] means middle.

    if (controlPosition === 'left' || controlPosition === 'bottom') {
      showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);
      showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);
      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
    } else {
      // 'top' 'right'
      showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
      showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);
      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
    }

    var axisExtent = [xLeft, xRight];

    if (timelineModel.get('inverse')) {
      axisExtent.reverse();
    }

    return {
      viewRect: viewRect,
      mainLength: mainLength,
      orient: orient,
      rotation: rotationMap[orient],
      labelRotation: labelRotation,
      labelPosOpt: parsedLabelPos,
      labelAlign: timelineModel.get(['label', 'align']) || labelAlignMap[orient],
      labelBaseline: timelineModel.get(['label', 'verticalAlign']) || timelineModel.get(['label', 'baseline']) || labelBaselineMap[orient],
      // Based on mainGroup.
      playPosition: playPosition,
      prevBtnPosition: prevBtnPosition,
      nextBtnPosition: nextBtnPosition,
      axisExtent: axisExtent,
      controlSize: controlSize,
      controlGap: controlGap
    };
  };

  SliderTimelineView.prototype._position = function (layoutInfo, timelineModel) {
    // Position is be called finally, because bounding rect is needed for
    // adapt content to fill viewRect (auto adapt offset).
    // Timeline may be not all in the viewRect when 'offset' is specified
    // as a number, because it is more appropriate that label aligns at
    // 'offset' but not the other edge defined by viewRect.
    var mainGroup = this._mainGroup;
    var labelGroup = this._labelGroup;
    var viewRect = layoutInfo.viewRect;

    if (layoutInfo.orient === 'vertical') {
      // transform to horizontal, inverse rotate by left-top point.
      var m = zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_4__.create();
      var rotateOriginX = viewRect.x;
      var rotateOriginY = viewRect.y + viewRect.height;
      zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_4__.translate(m, m, [-rotateOriginX, -rotateOriginY]);
      zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_4__.rotate(m, m, -PI / 2);
      zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_4__.translate(m, m, [rotateOriginX, rotateOriginY]);
      viewRect = viewRect.clone();
      viewRect.applyTransform(m);
    }

    var viewBound = getBound(viewRect);
    var mainBound = getBound(mainGroup.getBoundingRect());
    var labelBound = getBound(labelGroup.getBoundingRect());
    var mainPosition = [mainGroup.x, mainGroup.y];
    var labelsPosition = [labelGroup.x, labelGroup.y];
    labelsPosition[0] = mainPosition[0] = viewBound[0][0];
    var labelPosOpt = layoutInfo.labelPosOpt;

    if (labelPosOpt == null || (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.isString)(labelPosOpt)) {
      // '+' or '-'
      var mainBoundIdx = labelPosOpt === '+' ? 0 : 1;
      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
      toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);
    } else {
      var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;
      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
      labelsPosition[1] = mainPosition[1] + labelPosOpt;
    }

    mainGroup.setPosition(mainPosition);
    labelGroup.setPosition(labelsPosition);
    mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;
    setOrigin(mainGroup);
    setOrigin(labelGroup);

    function setOrigin(targetGroup) {
      targetGroup.originX = viewBound[0][0] - targetGroup.x;
      targetGroup.originY = viewBound[1][0] - targetGroup.y;
    }

    function getBound(rect) {
      // [[xmin, xmax], [ymin, ymax]]
      return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];
    }

    function toBound(fromPos, from, to, dimIdx, boundIdx) {
      fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];
    }
  };

  SliderTimelineView.prototype._createAxis = function (layoutInfo, timelineModel) {
    var data = timelineModel.getData();
    var axisType = timelineModel.get('axisType');
    var scale = createScaleByModel(timelineModel, axisType); // Customize scale. The `tickValue` is `dataIndex`.

    scale.getTicks = function () {
      return data.mapArray(['value'], function (value) {
        return {
          value: value
        };
      });
    };

    var dataExtent = data.getDataExtent('value');
    scale.setExtent(dataExtent[0], dataExtent[1]);
    scale.niceTicks();
    var axis = new _TimelineAxis__WEBPACK_IMPORTED_MODULE_5__.default('value', scale, layoutInfo.axisExtent, axisType);
    axis.model = timelineModel;
    return axis;
  };

  SliderTimelineView.prototype._createGroup = function (key) {
    var newGroup = this[key] = new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default();
    this.group.add(newGroup);
    return newGroup;
  };

  SliderTimelineView.prototype._renderAxisLine = function (layoutInfo, group, axis, timelineModel) {
    var axisExtent = axis.getExtent();

    if (!timelineModel.get(['lineStyle', 'show'])) {
      return;
    }

    var line = new _util_graphic__WEBPACK_IMPORTED_MODULE_7__.default({
      shape: {
        x1: axisExtent[0],
        y1: 0,
        x2: axisExtent[1],
        y2: 0
      },
      style: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.extend)({
        lineCap: 'round'
      }, timelineModel.getModel('lineStyle').getLineStyle()),
      silent: true,
      z2: 1
    });
    group.add(line);
    var progressLine = this._progressLine = new _util_graphic__WEBPACK_IMPORTED_MODULE_7__.default({
      shape: {
        x1: axisExtent[0],
        x2: this._currentPointer ? this._currentPointer.x : axisExtent[0],
        y1: 0,
        y2: 0
      },
      style: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.defaults)({
        lineCap: 'round',
        lineWidth: line.style.lineWidth
      }, timelineModel.getModel(['progress', 'lineStyle']).getLineStyle()),
      silent: true,
      z2: 1
    });
    group.add(progressLine);
  };

  SliderTimelineView.prototype._renderAxisTick = function (layoutInfo, group, axis, timelineModel) {
    var _this = this;

    var data = timelineModel.getData(); // Show all ticks, despite ignoring strategy.

    var ticks = axis.scale.getTicks();
    this._tickSymbols = []; // The value is dataIndex, see the costomized scale.

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.each)(ticks, function (tick) {
      var tickCoord = axis.dataToCoord(tick.value);
      var itemModel = data.getItemModel(tick.value);
      var itemStyleModel = itemModel.getModel('itemStyle');
      var hoverStyleModel = itemModel.getModel(['emphasis', 'itemStyle']);
      var progressStyleModel = itemModel.getModel(['progress', 'itemStyle']);
      var symbolOpt = {
        x: tickCoord,
        y: 0,
        onclick: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.bind)(_this._changeTimeline, _this, tick.value)
      };
      var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);
      el.ensureState('emphasis').style = hoverStyleModel.getItemStyle();
      el.ensureState('progress').style = progressStyleModel.getItemStyle();
      (0,_util_states__WEBPACK_IMPORTED_MODULE_8__.enableHoverEmphasis)(el);
      var ecData = (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_9__.getECData)(el);

      if (itemModel.get('tooltip')) {
        ecData.dataIndex = tick.value;
        ecData.dataModel = timelineModel;
      } else {
        ecData.dataIndex = ecData.dataModel = null;
      }

      _this._tickSymbols.push(el);
    });
  };

  SliderTimelineView.prototype._renderAxisLabel = function (layoutInfo, group, axis, timelineModel) {
    var _this = this;

    var labelModel = axis.getLabelModel();

    if (!labelModel.get('show')) {
      return;
    }

    var data = timelineModel.getData();
    var labels = axis.getViewLabels();
    this._tickLabels = [];
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.each)(labels, function (labelItem) {
      // The tickValue is dataIndex, see the costomized scale.
      var dataIndex = labelItem.tickValue;
      var itemModel = data.getItemModel(dataIndex);
      var normalLabelModel = itemModel.getModel('label');
      var hoverLabelModel = itemModel.getModel(['emphasis', 'label']);
      var progressLabelModel = itemModel.getModel(['progress', 'label']);
      var tickCoord = axis.dataToCoord(labelItem.tickValue);
      var textEl = new _util_graphic__WEBPACK_IMPORTED_MODULE_10__.default({
        x: tickCoord,
        y: 0,
        rotation: layoutInfo.labelRotation - layoutInfo.rotation,
        onclick: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.bind)(_this._changeTimeline, _this, dataIndex),
        silent: false,
        style: (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_11__.createTextStyle)(normalLabelModel, {
          text: labelItem.formattedLabel,
          align: layoutInfo.labelAlign,
          verticalAlign: layoutInfo.labelBaseline
        })
      });
      textEl.ensureState('emphasis').style = (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_11__.createTextStyle)(hoverLabelModel);
      textEl.ensureState('progress').style = (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_11__.createTextStyle)(progressLabelModel);
      group.add(textEl);
      (0,_util_states__WEBPACK_IMPORTED_MODULE_8__.enableHoverEmphasis)(textEl);
      labelDataIndexStore(textEl).dataIndex = dataIndex;

      _this._tickLabels.push(textEl);
    });
  };

  SliderTimelineView.prototype._renderControl = function (layoutInfo, group, axis, timelineModel) {
    var controlSize = layoutInfo.controlSize;
    var rotation = layoutInfo.rotation;
    var itemStyle = timelineModel.getModel('controlStyle').getItemStyle();
    var hoverStyle = timelineModel.getModel(['emphasis', 'controlStyle']).getItemStyle();
    var playState = timelineModel.getPlayState();
    var inverse = timelineModel.get('inverse', true);
    makeBtn(layoutInfo.nextBtnPosition, 'next', (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.bind)(this._changeTimeline, this, inverse ? '-' : '+'));
    makeBtn(layoutInfo.prevBtnPosition, 'prev', (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.bind)(this._changeTimeline, this, inverse ? '+' : '-'));
    makeBtn(layoutInfo.playPosition, playState ? 'stop' : 'play', (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.bind)(this._handlePlayClick, this, !playState), true);

    function makeBtn(position, iconName, onclick, willRotate) {
      if (!position) {
        return;
      }

      var iconSize = (0,zrender_lib_contain_text__WEBPACK_IMPORTED_MODULE_12__.parsePercent)((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.retrieve2)(timelineModel.get(['controlStyle', iconName + 'BtnSize']), controlSize), controlSize);
      var rect = [0, -iconSize / 2, iconSize, iconSize];
      var opt = {
        position: position,
        origin: [controlSize / 2, 0],
        rotation: willRotate ? -rotation : 0,
        rectHover: true,
        style: itemStyle,
        onclick: onclick
      };
      var btn = makeControlIcon(timelineModel, iconName + 'Icon', rect, opt);
      btn.ensureState('emphasis').style = hoverStyle;
      group.add(btn);
      (0,_util_states__WEBPACK_IMPORTED_MODULE_8__.enableHoverEmphasis)(btn);
    }
  };

  SliderTimelineView.prototype._renderCurrentPointer = function (layoutInfo, group, axis, timelineModel) {
    var data = timelineModel.getData();
    var currentIndex = timelineModel.getCurrentIndex();
    var pointerModel = data.getItemModel(currentIndex).getModel('checkpointStyle');
    var me = this;
    var callback = {
      onCreate: function (pointer) {
        pointer.draggable = true;
        pointer.drift = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.bind)(me._handlePointerDrag, me);
        pointer.ondragend = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.bind)(me._handlePointerDragend, me);
        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel, true);
      },
      onUpdate: function (pointer) {
        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel);
      }
    }; // Reuse when exists, for animation and drag.

    this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);
  };

  SliderTimelineView.prototype._handlePlayClick = function (nextState) {
    this._clearTimer();

    this.api.dispatchAction({
      type: 'timelinePlayChange',
      playState: nextState,
      from: this.uid
    });
  };

  SliderTimelineView.prototype._handlePointerDrag = function (dx, dy, e) {
    this._clearTimer();

    this._pointerChangeTimeline([e.offsetX, e.offsetY]);
  };

  SliderTimelineView.prototype._handlePointerDragend = function (e) {
    this._pointerChangeTimeline([e.offsetX, e.offsetY], true);
  };

  SliderTimelineView.prototype._pointerChangeTimeline = function (mousePos, trigger) {
    var toCoord = this._toAxisCoord(mousePos)[0];

    var axis = this._axis;
    var axisExtent = _util_number__WEBPACK_IMPORTED_MODULE_13__.asc(axis.getExtent().slice());
    toCoord > axisExtent[1] && (toCoord = axisExtent[1]);
    toCoord < axisExtent[0] && (toCoord = axisExtent[0]);
    this._currentPointer.x = toCoord;

    this._currentPointer.markRedraw();

    this._progressLine.shape.x2 = toCoord;

    this._progressLine.dirty();

    var targetDataIndex = this._findNearestTick(toCoord);

    var timelineModel = this.model;

    if (trigger || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get('realtime')) {
      this._changeTimeline(targetDataIndex);
    }
  };

  SliderTimelineView.prototype._doPlayStop = function () {
    var _this = this;

    this._clearTimer();

    if (this.model.getPlayState()) {
      this._timer = setTimeout(function () {
        // Do not cache
        var timelineModel = _this.model;

        _this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get('rewind', true) ? -1 : 1));
      }, this.model.get('playInterval'));
    }
  };

  SliderTimelineView.prototype._toAxisCoord = function (vertex) {
    var trans = this._mainGroup.getLocalTransform();

    return _util_graphic__WEBPACK_IMPORTED_MODULE_14__.applyTransform(vertex, trans, true);
  };

  SliderTimelineView.prototype._findNearestTick = function (axisCoord) {
    var data = this.model.getData();
    var dist = Infinity;
    var targetDataIndex;
    var axis = this._axis;
    data.each(['value'], function (value, dataIndex) {
      var coord = axis.dataToCoord(value);
      var d = Math.abs(coord - axisCoord);

      if (d < dist) {
        dist = d;
        targetDataIndex = dataIndex;
      }
    });
    return targetDataIndex;
  };

  SliderTimelineView.prototype._clearTimer = function () {
    if (this._timer) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  };

  SliderTimelineView.prototype._changeTimeline = function (nextIndex) {
    var currentIndex = this.model.getCurrentIndex();

    if (nextIndex === '+') {
      nextIndex = currentIndex + 1;
    } else if (nextIndex === '-') {
      nextIndex = currentIndex - 1;
    }

    this.api.dispatchAction({
      type: 'timelineChange',
      currentIndex: nextIndex,
      from: this.uid
    });
  };

  SliderTimelineView.prototype._updateTicksStatus = function () {
    var currentIndex = this.model.getCurrentIndex();
    var tickSymbols = this._tickSymbols;
    var tickLabels = this._tickLabels;

    if (tickSymbols) {
      for (var i = 0; i < tickSymbols.length; i++) {
        tickSymbols && tickSymbols[i] && tickSymbols[i].toggleState('progress', i < currentIndex);
      }
    }

    if (tickLabels) {
      for (var i = 0; i < tickLabels.length; i++) {
        tickLabels && tickLabels[i] && tickLabels[i].toggleState('progress', labelDataIndexStore(tickLabels[i]).dataIndex <= currentIndex);
      }
    }
  };

  SliderTimelineView.type = 'timeline.slider';
  return SliderTimelineView;
}(_TimelineView__WEBPACK_IMPORTED_MODULE_15__.default);

function createScaleByModel(model, axisType) {
  axisType = axisType || model.get('type');

  if (axisType) {
    switch (axisType) {
      // Buildin scale
      case 'category':
        return new _scale_Ordinal__WEBPACK_IMPORTED_MODULE_16__.default({
          ordinalMeta: model.getCategories(),
          extent: [Infinity, -Infinity]
        });

      case 'time':
        return new _scale_Time__WEBPACK_IMPORTED_MODULE_17__.default({
          locale: model.ecModel.getLocaleModel(),
          useUTC: model.ecModel.get('useUTC')
        });

      default:
        // default to be value
        return new _scale_Interval__WEBPACK_IMPORTED_MODULE_18__.default();
    }
  }
}

function getViewRect(model, api) {
  return _util_layout__WEBPACK_IMPORTED_MODULE_19__.getLayoutRect(model.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  }, model.get('padding'));
}

function makeControlIcon(timelineModel, objPath, rect, opts) {
  var style = opts.style;
  var icon = _util_graphic__WEBPACK_IMPORTED_MODULE_14__.createIcon(timelineModel.get(['controlStyle', objPath]), opts || {}, new zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_20__.default(rect[0], rect[1], rect[2], rect[3])); // TODO createIcon won't use style in opt.

  if (style) {
    icon.setStyle(style);
  }

  return icon;
}
/**
 * Create symbol or update symbol
 * opt: basic position and event handlers
 */


function giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {
  var color = itemStyleModel.get('color');

  if (!symbol) {
    var symbolType = hostModel.get('symbol');
    symbol = (0,_util_symbol__WEBPACK_IMPORTED_MODULE_21__.createSymbol)(symbolType, -1, -1, 2, 2, color);
    symbol.setStyle('strokeNoScale', true);
    group.add(symbol);
    callback && callback.onCreate(symbol);
  } else {
    symbol.setColor(color);
    group.add(symbol); // Group may be new, also need to add.

    callback && callback.onUpdate(symbol);
  } // Style


  var itemStyle = itemStyleModel.getItemStyle(['color']);
  symbol.setStyle(itemStyle); // Transform and events.

  opt = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.merge)({
    rectHover: true,
    z2: 100
  }, opt, true);
  var symbolSize = hostModel.get('symbolSize');
  symbolSize = symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
  opt.scaleX = symbolSize[0] / 2;
  opt.scaleY = symbolSize[1] / 2;
  var symbolOffset = hostModel.get('symbolOffset');

  if (symbolOffset) {
    opt.x = opt.x || 0;
    opt.y = opt.y || 0;
    opt.x += _util_number__WEBPACK_IMPORTED_MODULE_13__.parsePercent(symbolOffset[0], symbolSize[0]);
    opt.y += _util_number__WEBPACK_IMPORTED_MODULE_13__.parsePercent(symbolOffset[1], symbolSize[1]);
  }

  var symbolRotate = hostModel.get('symbolRotate');
  opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
  symbol.attr(opt); // FIXME
  // (1) When symbol.style.strokeNoScale is true and updateTransform is not performed,
  // getBoundingRect will return wrong result.
  // (This is supposed to be resolved in zrender, but it is a little difficult to
  // leverage performance and auto updateTransform)
  // (2) All of ancesters of symbol do not scale, so we can just updateTransform symbol.

  symbol.updateTransform();
  return symbol;
}

function pointerMoveTo(pointer, progressLine, dataIndex, axis, timelineModel, noAnimation) {
  if (pointer.dragging) {
    return;
  }

  var pointerModel = timelineModel.getModel('checkpointStyle');
  var toCoord = axis.dataToCoord(timelineModel.getData().get('value', dataIndex));

  if (noAnimation || !pointerModel.get('animation', true)) {
    pointer.attr({
      x: toCoord,
      y: 0
    });
    progressLine && progressLine.attr({
      shape: {
        x2: toCoord
      }
    });
  } else {
    var animationCfg = {
      duration: pointerModel.get('animationDuration', true),
      easing: pointerModel.get('animationEasing', true)
    };
    pointer.stopAnimation(null, true);
    pointer.animateTo({
      x: toCoord,
      y: 0
    }, animationCfg);
    progressLine && progressLine.animateTo({
      shape: {
        x2: toCoord
      }
    }, animationCfg);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SliderTimelineView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/timeline/TimelineAxis.js":
/*!*********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/timeline/TimelineAxis.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _coord_Axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../coord/Axis */ "./node_modules/echarts/lib/coord/Axis.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * Extend axis 2d
 */

var TimelineAxis =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(TimelineAxis, _super);

  function TimelineAxis(dim, scale, coordExtent, axisType) {
    var _this = _super.call(this, dim, scale, coordExtent) || this;

    _this.type = axisType || 'value';
    return _this;
  }
  /**
   * @override
   */


  TimelineAxis.prototype.getLabelModel = function () {
    // Force override
    return this.model.getModel('label');
  };
  /**
   * @override
   */


  TimelineAxis.prototype.isHorizontal = function () {
    return this.model.get('orient') === 'horizontal';
  };

  return TimelineAxis;
}(_coord_Axis__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TimelineAxis);

/***/ }),

/***/ "./node_modules/echarts/lib/component/timeline/TimelineModel.js":
/*!**********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/timeline/TimelineModel.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");
/* harmony import */ var _data_List__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/List */ "./node_modules/echarts/lib/data/List.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var TimelineModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(TimelineModel, _super);

  function TimelineModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = TimelineModel.type;
    _this.layoutMode = 'box';
    return _this;
  }
  /**
   * @override
   */


  TimelineModel.prototype.init = function (option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);

    this._initData();
  };
  /**
   * @override
   */


  TimelineModel.prototype.mergeOption = function (option) {
    _super.prototype.mergeOption.apply(this, arguments);

    this._initData();
  };

  TimelineModel.prototype.setCurrentIndex = function (currentIndex) {
    if (currentIndex == null) {
      currentIndex = this.option.currentIndex;
    }

    var count = this._data.count();

    if (this.option.loop) {
      currentIndex = (currentIndex % count + count) % count;
    } else {
      currentIndex >= count && (currentIndex = count - 1);
      currentIndex < 0 && (currentIndex = 0);
    }

    this.option.currentIndex = currentIndex;
  };
  /**
   * @return {number} currentIndex
   */


  TimelineModel.prototype.getCurrentIndex = function () {
    return this.option.currentIndex;
  };
  /**
   * @return {boolean}
   */


  TimelineModel.prototype.isIndexMax = function () {
    return this.getCurrentIndex() >= this._data.count() - 1;
  };
  /**
   * @param {boolean} state true: play, false: stop
   */


  TimelineModel.prototype.setPlayState = function (state) {
    this.option.autoPlay = !!state;
  };
  /**
   * @return {boolean} true: play, false: stop
   */


  TimelineModel.prototype.getPlayState = function () {
    return !!this.option.autoPlay;
  };
  /**
   * @private
   */


  TimelineModel.prototype._initData = function () {
    var thisOption = this.option;
    var dataArr = thisOption.data || [];
    var axisType = thisOption.axisType;
    var names = this._names = [];
    var processedDataArr;

    if (axisType === 'category') {
      processedDataArr = [];
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(dataArr, function (item, index) {
        var value = (0,_util_model__WEBPACK_IMPORTED_MODULE_2__.convertOptionIdName)((0,_util_model__WEBPACK_IMPORTED_MODULE_2__.getDataItemValue)(item), '');
        var newItem;

        if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(item)) {
          newItem = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone)(item);
          newItem.value = index;
        } else {
          newItem = index;
        }

        processedDataArr.push(newItem);
        names.push(value);
      });
    } else {
      processedDataArr = dataArr;
    }

    var dimType = {
      category: 'ordinal',
      time: 'time',
      value: 'number'
    }[axisType] || 'number';
    var data = this._data = new _data_List__WEBPACK_IMPORTED_MODULE_3__.default([{
      name: 'value',
      type: dimType
    }], this);
    data.initData(processedDataArr, names);
  };

  TimelineModel.prototype.getData = function () {
    return this._data;
  };
  /**
   * @public
   * @return {Array.<string>} categoreis
   */


  TimelineModel.prototype.getCategories = function () {
    if (this.get('axisType') === 'category') {
      return this._names.slice();
    }
  };

  TimelineModel.type = 'timeline';
  /**
   * @protected
   */

  TimelineModel.defaultOption = {
    zlevel: 0,
    z: 4,
    show: true,
    axisType: 'time',
    realtime: true,
    left: '20%',
    top: null,
    right: '20%',
    bottom: 0,
    width: null,
    height: 40,
    padding: 5,
    controlPosition: 'left',
    autoPlay: false,
    rewind: false,
    loop: true,
    playInterval: 2000,
    currentIndex: 0,
    itemStyle: {},
    label: {
      color: '#000'
    },
    data: []
  };
  return TimelineModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_4__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TimelineModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/timeline/TimelineView.js":
/*!*********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/timeline/TimelineView.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var TimelineView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(TimelineView, _super);

  function TimelineView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = TimelineView.type;
    return _this;
  }

  TimelineView.type = 'timeline';
  return TimelineView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TimelineView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/timeline/install.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/timeline/install.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _SliderTimelineModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SliderTimelineModel */ "./node_modules/echarts/lib/component/timeline/SliderTimelineModel.js");
/* harmony import */ var _SliderTimelineView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SliderTimelineView */ "./node_modules/echarts/lib/component/timeline/SliderTimelineView.js");
/* harmony import */ var _timelineAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./timelineAction */ "./node_modules/echarts/lib/component/timeline/timelineAction.js");
/* harmony import */ var _preprocessor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./preprocessor */ "./node_modules/echarts/lib/component/timeline/preprocessor.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */





function install(registers) {
  registers.registerComponentModel(_SliderTimelineModel__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerComponentView(_SliderTimelineView__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerSubTypeDefaulter('timeline', function () {
    // Only slider now.
    return 'slider';
  });
  (0,_timelineAction__WEBPACK_IMPORTED_MODULE_2__.installTimelineAction)(registers);
  registers.registerPreprocessor(_preprocessor__WEBPACK_IMPORTED_MODULE_3__.default);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/timeline/preprocessor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/timeline/preprocessor.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ timelinePreprocessor)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// @ts-nocheck

function timelinePreprocessor(option) {
  var timelineOpt = option && option.timeline;

  if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(timelineOpt)) {
    timelineOpt = timelineOpt ? [timelineOpt] : [];
  }

  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(timelineOpt, function (opt) {
    if (!opt) {
      return;
    }

    compatibleEC2(opt);
  });
}

function compatibleEC2(opt) {
  var type = opt.type;
  var ec2Types = {
    'number': 'value',
    'time': 'time'
  }; // Compatible with ec2

  if (ec2Types[type]) {
    opt.axisType = ec2Types[type];
    delete opt.type;
  }

  transferItem(opt);

  if (has(opt, 'controlPosition')) {
    var controlStyle = opt.controlStyle || (opt.controlStyle = {});

    if (!has(controlStyle, 'position')) {
      controlStyle.position = opt.controlPosition;
    }

    if (controlStyle.position === 'none' && !has(controlStyle, 'show')) {
      controlStyle.show = false;
      delete controlStyle.position;
    }

    delete opt.controlPosition;
  }

  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(opt.data || [], function (dataItem) {
    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject(dataItem) && !zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(dataItem)) {
      if (!has(dataItem, 'value') && has(dataItem, 'name')) {
        // In ec2, using name as value.
        dataItem.value = dataItem.name;
      }

      transferItem(dataItem);
    }
  });
}

function transferItem(opt) {
  var itemStyle = opt.itemStyle || (opt.itemStyle = {});
  var itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {}); // Transfer label out

  var label = opt.label || opt.label || {};
  var labelNormal = label.normal || (label.normal = {});
  var excludeLabelAttr = {
    normal: 1,
    emphasis: 1
  };
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(label, function (value, name) {
    if (!excludeLabelAttr[name] && !has(labelNormal, name)) {
      labelNormal[name] = value;
    }
  });

  if (itemStyleEmphasis.label && !has(label, 'emphasis')) {
    label.emphasis = itemStyleEmphasis.label;
    delete itemStyleEmphasis.label;
  }
}

function has(obj, attr) {
  return obj.hasOwnProperty(attr);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/timeline/timelineAction.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/timeline/timelineAction.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "installTimelineAction": () => (/* binding */ installTimelineAction)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

function installTimelineAction(registers) {
  registers.registerAction({
    type: 'timelineChange',
    event: 'timelineChanged',
    update: 'prepareAndUpdate'
  }, function (payload, ecModel) {
    var timelineModel = ecModel.getComponent('timeline');

    if (timelineModel && payload.currentIndex != null) {
      timelineModel.setCurrentIndex(payload.currentIndex);

      if (!timelineModel.get('loop', true) && timelineModel.isIndexMax()) {
        timelineModel.setPlayState(false);
      }
    } // Set normalized currentIndex to payload.


    ecModel.resetOption('timeline', {
      replaceMerge: timelineModel.get('replaceMerge', true)
    });
    return (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.defaults)({
      currentIndex: timelineModel.option.currentIndex
    }, payload);
  });
  registers.registerAction({
    type: 'timelinePlayChange',
    event: 'timelinePlayChanged',
    update: 'update'
  }, function (payload, ecModel) {
    var timelineModel = ecModel.getComponent('timeline');

    if (timelineModel && payload.playState != null) {
      timelineModel.setPlayState(payload.playState);
    }
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/title/install.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/component/title/install.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");
/* harmony import */ var _util_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/format */ "./node_modules/echarts/lib/util/format.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/










var TitleModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(TitleModel, _super);

  function TitleModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = TitleModel.type;
    _this.layoutMode = {
      type: 'box',
      ignoreSize: true
    };
    return _this;
  }

  TitleModel.type = 'title';
  TitleModel.defaultOption = {
    zlevel: 0,
    z: 6,
    show: true,
    text: '',
    target: 'blank',
    subtext: '',
    subtarget: 'blank',
    left: 0,
    top: 0,
    backgroundColor: 'rgba(0,0,0,0)',
    borderColor: '#ccc',
    borderWidth: 0,
    padding: 5,
    itemGap: 10,
    textStyle: {
      fontSize: 18,
      fontWeight: 'bold',
      color: '#464646'
    },
    subtextStyle: {
      fontSize: 12,
      color: '#6E7079'
    }
  };
  return TitleModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_1__.default); // View


var TitleView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(TitleView, _super);

  function TitleView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = TitleView.type;
    return _this;
  }

  TitleView.prototype.render = function (titleModel, ecModel, api) {
    this.group.removeAll();

    if (!titleModel.get('show')) {
      return;
    }

    var group = this.group;
    var textStyleModel = titleModel.getModel('textStyle');
    var subtextStyleModel = titleModel.getModel('subtextStyle');
    var textAlign = titleModel.get('textAlign');
    var textVerticalAlign = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.retrieve2(titleModel.get('textBaseline'), titleModel.get('textVerticalAlign'));
    var textEl = new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default({
      style: (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_4__.createTextStyle)(textStyleModel, {
        text: titleModel.get('text'),
        fill: textStyleModel.getTextColor()
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var textRect = textEl.getBoundingRect();
    var subText = titleModel.get('subtext');
    var subTextEl = new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default({
      style: (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_4__.createTextStyle)(subtextStyleModel, {
        text: subText,
        fill: subtextStyleModel.getTextColor(),
        y: textRect.height + titleModel.get('itemGap'),
        verticalAlign: 'top'
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var link = titleModel.get('link');
    var sublink = titleModel.get('sublink');
    var triggerEvent = titleModel.get('triggerEvent', true);
    textEl.silent = !link && !triggerEvent;
    subTextEl.silent = !sublink && !triggerEvent;

    if (link) {
      textEl.on('click', function () {
        (0,_util_format__WEBPACK_IMPORTED_MODULE_5__.windowOpen)(link, '_' + titleModel.get('target'));
      });
    }

    if (sublink) {
      subTextEl.on('click', function () {
        (0,_util_format__WEBPACK_IMPORTED_MODULE_5__.windowOpen)(sublink, '_' + titleModel.get('subtarget'));
      });
    }

    (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_6__.getECData)(textEl).eventData = (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_6__.getECData)(subTextEl).eventData = triggerEvent ? {
      componentType: 'title',
      componentIndex: titleModel.componentIndex
    } : null;
    group.add(textEl);
    subText && group.add(subTextEl); // If no subText, but add subTextEl, there will be an empty line.

    var groupRect = group.getBoundingRect();
    var layoutOption = titleModel.getBoxLayoutParams();
    layoutOption.width = groupRect.width;
    layoutOption.height = groupRect.height;
    var layoutRect = (0,_util_layout__WEBPACK_IMPORTED_MODULE_7__.getLayoutRect)(layoutOption, {
      width: api.getWidth(),
      height: api.getHeight()
    }, titleModel.get('padding')); // Adjust text align based on position

    if (!textAlign) {
      // Align left if title is on the left. center and right is same
      textAlign = titleModel.get('left') || titleModel.get('right'); // @ts-ignore

      if (textAlign === 'middle') {
        textAlign = 'center';
      } // Adjust layout by text align


      if (textAlign === 'right') {
        layoutRect.x += layoutRect.width;
      } else if (textAlign === 'center') {
        layoutRect.x += layoutRect.width / 2;
      }
    }

    if (!textVerticalAlign) {
      textVerticalAlign = titleModel.get('top') || titleModel.get('bottom'); // @ts-ignore

      if (textVerticalAlign === 'center') {
        textVerticalAlign = 'middle';
      }

      if (textVerticalAlign === 'bottom') {
        layoutRect.y += layoutRect.height;
      } else if (textVerticalAlign === 'middle') {
        layoutRect.y += layoutRect.height / 2;
      }

      textVerticalAlign = textVerticalAlign || 'top';
    }

    group.x = layoutRect.x;
    group.y = layoutRect.y;
    group.markRedraw();
    var alignStyle = {
      align: textAlign,
      verticalAlign: textVerticalAlign
    };
    textEl.setStyle(alignStyle);
    subTextEl.setStyle(alignStyle); // Render background
    // Get groupRect again because textAlign has been changed

    groupRect = group.getBoundingRect();
    var padding = layoutRect.margin;
    var style = titleModel.getItemStyle(['color', 'opacity']);
    style.fill = titleModel.get('backgroundColor');
    var rect = new _util_graphic__WEBPACK_IMPORTED_MODULE_8__.default({
      shape: {
        x: groupRect.x - padding[3],
        y: groupRect.y - padding[0],
        width: groupRect.width + padding[1] + padding[3],
        height: groupRect.height + padding[0] + padding[2],
        r: titleModel.get('borderRadius')
      },
      style: style,
      subPixelOptimize: true,
      silent: true
    });
    group.add(rect);
  };

  TitleView.type = 'title';
  return TitleView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_9__.default);

function install(registers) {
  registers.registerComponentModel(TitleModel);
  registers.registerComponentView(TitleView);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/ToolboxModel.js":
/*!********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/toolbox/ToolboxModel.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _featureManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./featureManager */ "./node_modules/echarts/lib/component/toolbox/featureManager.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var ToolboxModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ToolboxModel, _super);

  function ToolboxModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ToolboxModel.type;
    return _this;
  }

  ToolboxModel.prototype.optionUpdated = function () {
    _super.prototype.optionUpdated.apply(this, arguments);

    var ecModel = this.ecModel;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(this.option.feature, function (featureOpt, featureName) {
      var Feature = _featureManager__WEBPACK_IMPORTED_MODULE_2__.getFeature(featureName);

      if (Feature) {
        if (Feature.getDefaultOption) {
          Feature.defaultOption = Feature.getDefaultOption(ecModel);
        }

        zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge(featureOpt, Feature.defaultOption);
      }
    });
  };

  ToolboxModel.type = 'toolbox';
  ToolboxModel.layoutMode = {
    type: 'box',
    ignoreSize: true
  };
  ToolboxModel.defaultOption = {
    show: true,
    z: 6,
    zlevel: 0,
    orient: 'horizontal',
    left: 'right',
    top: 'top',
    // right
    // bottom
    backgroundColor: 'transparent',
    borderColor: '#ccc',
    borderRadius: 0,
    borderWidth: 0,
    padding: 5,
    itemSize: 15,
    itemGap: 8,
    showTitle: true,
    iconStyle: {
      borderColor: '#666',
      color: 'none'
    },
    emphasis: {
      iconStyle: {
        borderColor: '#3E98C5'
      }
    },
    // textStyle: {},
    // feature
    tooltip: {
      show: false
    }
  };
  return ToolboxModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_3__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ToolboxModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/ToolboxView.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/toolbox/ToolboxView.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_contain_text__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! zrender/lib/contain/text */ "./node_modules/zrender/lib/contain/text.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/Model */ "./node_modules/echarts/lib/model/Model.js");
/* harmony import */ var _data_DataDiffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/DataDiffer */ "./node_modules/echarts/lib/data/DataDiffer.js");
/* harmony import */ var _helper_listComponent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../helper/listComponent */ "./node_modules/echarts/lib/component/helper/listComponent.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");
/* harmony import */ var _featureManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./featureManager */ "./node_modules/echarts/lib/component/toolbox/featureManager.js");
/* harmony import */ var _util_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/component */ "./node_modules/echarts/lib/util/component.js");
/* harmony import */ var zrender_lib_graphic_Text__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! zrender/lib/graphic/Text */ "./node_modules/zrender/lib/graphic/Text.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/













var ToolboxView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ToolboxView, _super);

  function ToolboxView() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ToolboxView.prototype.render = function (toolboxModel, ecModel, api, payload) {
    var group = this.group;
    group.removeAll();

    if (!toolboxModel.get('show')) {
      return;
    }

    var itemSize = +toolboxModel.get('itemSize');
    var featureOpts = toolboxModel.get('feature') || {};
    var features = this._features || (this._features = {});
    var featureNames = [];
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(featureOpts, function (opt, name) {
      featureNames.push(name);
    });
    new _data_DataDiffer__WEBPACK_IMPORTED_MODULE_2__.default(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry(processFeature, null)).execute(); // Keep for diff.

    this._featureNames = featureNames;

    function processFeature(newIndex, oldIndex) {
      var featureName = featureNames[newIndex];
      var oldName = featureNames[oldIndex];
      var featureOpt = featureOpts[featureName];
      var featureModel = new _model_Model__WEBPACK_IMPORTED_MODULE_3__.default(featureOpt, toolboxModel, toolboxModel.ecModel);
      var feature; // FIX#11236, merge feature title from MagicType newOption. TODO: consider seriesIndex ?

      if (payload && payload.newTitle != null && payload.featureName === featureName) {
        featureOpt.title = payload.newTitle;
      }

      if (featureName && !oldName) {
        // Create
        if (isUserFeatureName(featureName)) {
          feature = {
            onclick: featureModel.option.onclick,
            featureName: featureName
          };
        } else {
          var Feature = (0,_featureManager__WEBPACK_IMPORTED_MODULE_4__.getFeature)(featureName);

          if (!Feature) {
            return;
          }

          feature = new Feature();
        }

        features[featureName] = feature;
      } else {
        feature = features[oldName]; // If feature does not exsit.

        if (!feature) {
          return;
        }
      }

      feature.uid = (0,_util_component__WEBPACK_IMPORTED_MODULE_5__.getUID)('toolbox-feature');
      feature.model = featureModel;
      feature.ecModel = ecModel;
      feature.api = api;

      if (feature instanceof _featureManager__WEBPACK_IMPORTED_MODULE_4__.ToolboxFeature) {
        if (!featureName && oldName) {
          feature.dispose && feature.dispose(ecModel, api);
          return;
        }

        if (!featureModel.get('show') || feature.unusable) {
          feature.remove && feature.remove(ecModel, api);
          return;
        }
      }

      createIconPaths(featureModel, feature, featureName);

      featureModel.setIconStatus = function (iconName, status) {
        var option = this.option;
        var iconPaths = this.iconPaths;
        option.iconStatus = option.iconStatus || {};
        option.iconStatus[iconName] = status;

        if (iconPaths[iconName]) {
          (status === 'emphasis' ? _util_states__WEBPACK_IMPORTED_MODULE_6__.enterEmphasis : _util_states__WEBPACK_IMPORTED_MODULE_6__.leaveEmphasis)(iconPaths[iconName]);
        }
      };

      if (feature instanceof _featureManager__WEBPACK_IMPORTED_MODULE_4__.ToolboxFeature) {
        if (feature.render) {
          feature.render(featureModel, ecModel, api, payload);
        }
      }
    }

    function createIconPaths(featureModel, feature, featureName) {
      var iconStyleModel = featureModel.getModel('iconStyle');
      var iconStyleEmphasisModel = featureModel.getModel(['emphasis', 'iconStyle']); // If one feature has mutiple icon. they are orginaized as
      // {
      //     icon: {
      //         foo: '',
      //         bar: ''
      //     },
      //     title: {
      //         foo: '',
      //         bar: ''
      //     }
      // }

      var icons = feature instanceof _featureManager__WEBPACK_IMPORTED_MODULE_4__.ToolboxFeature && feature.getIcons ? feature.getIcons() : featureModel.get('icon');
      var titles = featureModel.get('title') || {};
      var iconsMap;
      var titlesMap;

      if (typeof icons === 'string') {
        iconsMap = {};
        iconsMap[featureName] = icons;
      } else {
        iconsMap = icons;
      }

      if (typeof titles === 'string') {
        titlesMap = {};
        titlesMap[featureName] = titles;
      } else {
        titlesMap = titles;
      }

      var iconPaths = featureModel.iconPaths = {};
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(iconsMap, function (iconStr, iconName) {
        var path = _util_graphic__WEBPACK_IMPORTED_MODULE_7__.createIcon(iconStr, {}, {
          x: -itemSize / 2,
          y: -itemSize / 2,
          width: itemSize,
          height: itemSize
        }); // TODO handling image

        path.setStyle(iconStyleModel.getItemStyle());
        var pathEmphasisState = path.ensureState('emphasis');
        pathEmphasisState.style = iconStyleEmphasisModel.getItemStyle(); // Text position calculation

        var textContent = new zrender_lib_graphic_Text__WEBPACK_IMPORTED_MODULE_8__.default({
          style: {
            text: titlesMap[iconName],
            align: iconStyleEmphasisModel.get('textAlign'),
            borderRadius: iconStyleEmphasisModel.get('textBorderRadius'),
            padding: iconStyleEmphasisModel.get('textPadding'),
            fill: null
          },
          ignore: true
        });
        path.setTextContent(textContent);
        var tooltipModel = toolboxModel.getModel('tooltip');

        if (tooltipModel && tooltipModel.get('show')) {
          path.tooltip = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend({
            content: titlesMap[iconName],
            formatter: tooltipModel.get('formatter', true) || function () {
              return titlesMap[iconName];
            },
            formatterParams: {
              componentType: 'toolbox',
              name: iconName,
              title: titlesMap[iconName],
              $vars: ['name', 'title']
            },
            position: tooltipModel.get('position', true) || 'bottom'
          }, tooltipModel.option);
        } // graphic.enableHoverEmphasis(path);


        path.__title = titlesMap[iconName];
        path.on('mouseover', function () {
          // Should not reuse above hoverStyle, which might be modified.
          var hoverStyle = iconStyleEmphasisModel.getItemStyle();
          var defaultTextPosition = toolboxModel.get('orient') === 'vertical' ? toolboxModel.get('right') == null ? 'right' : 'left' : toolboxModel.get('bottom') == null ? 'bottom' : 'top';
          textContent.setStyle({
            fill: iconStyleEmphasisModel.get('textFill') || hoverStyle.fill || hoverStyle.stroke || '#000',
            backgroundColor: iconStyleEmphasisModel.get('textBackgroundColor')
          });
          path.setTextConfig({
            position: iconStyleEmphasisModel.get('textPosition') || defaultTextPosition
          });
          textContent.ignore = !toolboxModel.get('showTitle'); // Use enterEmphasis and leaveEmphasis provide by ec.
          // There are flags managed by the echarts.

          (0,_util_states__WEBPACK_IMPORTED_MODULE_6__.enterEmphasis)(this);
        }).on('mouseout', function () {
          if (featureModel.get(['iconStatus', iconName]) !== 'emphasis') {
            (0,_util_states__WEBPACK_IMPORTED_MODULE_6__.leaveEmphasis)(this);
          }

          textContent.hide();
        });
        (featureModel.get(['iconStatus', iconName]) === 'emphasis' ? _util_states__WEBPACK_IMPORTED_MODULE_6__.enterEmphasis : _util_states__WEBPACK_IMPORTED_MODULE_6__.leaveEmphasis)(path);
        group.add(path);
        path.on('click', zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind(feature.onclick, feature, ecModel, api, iconName));
        iconPaths[iconName] = path;
      });
    }

    _helper_listComponent__WEBPACK_IMPORTED_MODULE_9__.layout(group, toolboxModel, api); // Render background after group is layout
    // FIXME

    group.add(_helper_listComponent__WEBPACK_IMPORTED_MODULE_9__.makeBackground(group.getBoundingRect(), toolboxModel)); // Adjust icon title positions to avoid them out of screen

    group.eachChild(function (icon) {
      var titleText = icon.__title; // const hoverStyle = icon.hoverStyle;
      // TODO simplify code?

      var emphasisState = icon.ensureState('emphasis');
      var emphasisTextConfig = emphasisState.textConfig || (emphasisState.textConfig = {});
      var textContent = icon.getTextContent();
      var emphasisTextState = textContent && textContent.states.emphasis; // May be background element

      if (emphasisTextState && !zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isFunction(emphasisTextState) && titleText) {
        var emphasisTextStyle = emphasisTextState.style || (emphasisTextState.style = {});
        var rect = zrender_lib_contain_text__WEBPACK_IMPORTED_MODULE_10__.getBoundingRect(titleText, zrender_lib_graphic_Text__WEBPACK_IMPORTED_MODULE_8__.default.makeFont(emphasisTextStyle));
        var offsetX = icon.x + group.x;
        var offsetY = icon.y + group.y + itemSize;
        var needPutOnTop = false;

        if (offsetY + rect.height > api.getHeight()) {
          emphasisTextConfig.position = 'top';
          needPutOnTop = true;
        }

        var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;

        if (offsetX + rect.width / 2 > api.getWidth()) {
          emphasisTextConfig.position = ['100%', topOffset];
          emphasisTextStyle.align = 'right';
        } else if (offsetX - rect.width / 2 < 0) {
          emphasisTextConfig.position = [0, topOffset];
          emphasisTextStyle.align = 'left';
        }
      }
    });
  };

  ToolboxView.prototype.updateView = function (toolboxModel, ecModel, api, payload) {
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(this._features, function (feature) {
      feature instanceof _featureManager__WEBPACK_IMPORTED_MODULE_4__.ToolboxFeature && feature.updateView && feature.updateView(feature.model, ecModel, api, payload);
    });
  }; // updateLayout(toolboxModel, ecModel, api, payload) {
  //     zrUtil.each(this._features, function (feature) {
  //         feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);
  //     });
  // },


  ToolboxView.prototype.remove = function (ecModel, api) {
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(this._features, function (feature) {
      feature instanceof _featureManager__WEBPACK_IMPORTED_MODULE_4__.ToolboxFeature && feature.remove && feature.remove(ecModel, api);
    });
    this.group.removeAll();
  };

  ToolboxView.prototype.dispose = function (ecModel, api) {
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(this._features, function (feature) {
      feature instanceof _featureManager__WEBPACK_IMPORTED_MODULE_4__.ToolboxFeature && feature.dispose && feature.dispose(ecModel, api);
    });
  };

  ToolboxView.type = 'toolbox';
  return ToolboxView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_11__.default);

function isUserFeatureName(featureName) {
  return featureName.indexOf('my') === 0;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ToolboxView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/Brush.js":
/*!*********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/toolbox/feature/Brush.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _featureManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../featureManager */ "./node_modules/echarts/lib/component/toolbox/featureManager.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var ICON_TYPES = ['rect', 'polygon', 'lineX', 'lineY', 'keep', 'clear'];

var BrushFeature =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(BrushFeature, _super);

  function BrushFeature() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  BrushFeature.prototype.render = function (featureModel, ecModel, api) {
    var brushType;
    var brushMode;
    var isBrushed;
    ecModel.eachComponent({
      mainType: 'brush'
    }, function (brushModel) {
      brushType = brushModel.brushType;
      brushMode = brushModel.brushOption.brushMode || 'single';
      isBrushed = isBrushed || !!brushModel.areas.length;
    });
    this._brushType = brushType;
    this._brushMode = brushMode;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(featureModel.get('type', true), function (type) {
      featureModel.setIconStatus(type, (type === 'keep' ? brushMode === 'multiple' : type === 'clear' ? isBrushed : type === brushType) ? 'emphasis' : 'normal');
    });
  };

  BrushFeature.prototype.updateView = function (featureModel, ecModel, api) {
    this.render(featureModel, ecModel, api);
  };

  BrushFeature.prototype.getIcons = function () {
    var model = this.model;
    var availableIcons = model.get('icon', true);
    var icons = {};
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(model.get('type', true), function (type) {
      if (availableIcons[type]) {
        icons[type] = availableIcons[type];
      }
    });
    return icons;
  };

  ;

  BrushFeature.prototype.onclick = function (ecModel, api, type) {
    var brushType = this._brushType;
    var brushMode = this._brushMode;

    if (type === 'clear') {
      // Trigger parallel action firstly
      api.dispatchAction({
        type: 'axisAreaSelect',
        intervals: []
      });
      api.dispatchAction({
        type: 'brush',
        command: 'clear',
        // Clear all areas of all brush components.
        areas: []
      });
    } else {
      api.dispatchAction({
        type: 'takeGlobalCursor',
        key: 'brush',
        brushOption: {
          brushType: type === 'keep' ? brushType : brushType === type ? false : type,
          brushMode: type === 'keep' ? brushMode === 'multiple' ? 'single' : 'multiple' : brushMode
        }
      });
    }
  };

  ;

  BrushFeature.getDefaultOption = function (ecModel) {
    var defaultOption = {
      show: true,
      type: ICON_TYPES.slice(),
      icon: {
        /* eslint-disable */
        rect: 'M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13',
        polygon: 'M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2',
        lineX: 'M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4',
        lineY: 'M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4',
        keep: 'M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z',
        clear: 'M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2' // jshint ignore:line

        /* eslint-enable */

      },
      // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
      title: ecModel.getLocale(['toolbox', 'brush', 'title'])
    };
    return defaultOption;
  };

  return BrushFeature;
}(_featureManager__WEBPACK_IMPORTED_MODULE_2__.ToolboxFeature);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BrushFeature);

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/DataView.js":
/*!************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/toolbox/feature/DataView.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _core_echarts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/echarts */ "./node_modules/echarts/lib/core/echarts.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _featureManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../featureManager */ "./node_modules/echarts/lib/component/toolbox/featureManager.js");
/* harmony import */ var zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/event */ "./node_modules/zrender/lib/core/event.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var BLOCK_SPLITER = new Array(60).join('-');
var ITEM_SPLITER = '\t';
/**
 * Group series into two types
 *  1. on category axis, like line, bar
 *  2. others, like scatter, pie
 */

function groupSeries(ecModel) {
  var seriesGroupByCategoryAxis = {};
  var otherSeries = [];
  var meta = [];
  ecModel.eachRawSeries(function (seriesModel) {
    var coordSys = seriesModel.coordinateSystem;

    if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {
      // TODO: TYPE Consider polar? Include polar may increase unecessary bundle size.
      var baseAxis = coordSys.getBaseAxis();

      if (baseAxis.type === 'category') {
        var key = baseAxis.dim + '_' + baseAxis.index;

        if (!seriesGroupByCategoryAxis[key]) {
          seriesGroupByCategoryAxis[key] = {
            categoryAxis: baseAxis,
            valueAxis: coordSys.getOtherAxis(baseAxis),
            series: []
          };
          meta.push({
            axisDim: baseAxis.dim,
            axisIndex: baseAxis.index
          });
        }

        seriesGroupByCategoryAxis[key].series.push(seriesModel);
      } else {
        otherSeries.push(seriesModel);
      }
    } else {
      otherSeries.push(seriesModel);
    }
  });
  return {
    seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,
    other: otherSeries,
    meta: meta
  };
}
/**
 * Assemble content of series on cateogory axis
 * @inner
 */


function assembleSeriesWithCategoryAxis(groups) {
  var tables = [];
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(groups, function (group, key) {
    var categoryAxis = group.categoryAxis;
    var valueAxis = group.valueAxis;
    var valueAxisDim = valueAxis.dim;
    var headers = [' '].concat(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map(group.series, function (series) {
      return series.name;
    })); // @ts-ignore TODO Polar

    var columns = [categoryAxis.model.getCategories()];
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(group.series, function (series) {
      var rawData = series.getRawData();
      columns.push(series.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function (val) {
        return val;
      }));
    }); // Assemble table content

    var lines = [headers.join(ITEM_SPLITER)];

    for (var i = 0; i < columns[0].length; i++) {
      var items = [];

      for (var j = 0; j < columns.length; j++) {
        items.push(columns[j][i]);
      }

      lines.push(items.join(ITEM_SPLITER));
    }

    tables.push(lines.join('\n'));
  });
  return tables.join('\n\n' + BLOCK_SPLITER + '\n\n');
}
/**
 * Assemble content of other series
 */


function assembleOtherSeries(series) {
  return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map(series, function (series) {
    var data = series.getRawData();
    var lines = [series.name];
    var vals = [];
    data.each(data.dimensions, function () {
      var argLen = arguments.length;
      var dataIndex = arguments[argLen - 1];
      var name = data.getName(dataIndex);

      for (var i = 0; i < argLen - 1; i++) {
        vals[i] = arguments[i];
      }

      lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER));
    });
    return lines.join('\n');
  }).join('\n\n' + BLOCK_SPLITER + '\n\n');
}

function getContentFromModel(ecModel) {
  var result = groupSeries(ecModel);
  return {
    value: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function (str) {
      return !!str.replace(/[\n\t\s]/g, '');
    }).join('\n\n' + BLOCK_SPLITER + '\n\n'),
    meta: result.meta
  };
}

function trim(str) {
  return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}
/**
 * If a block is tsv format
 */


function isTSVFormat(block) {
  // Simple method to find out if a block is tsv format
  var firstLine = block.slice(0, block.indexOf('\n'));

  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
    return true;
  }
}

var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');
/**
 * @param {string} tsv
 * @return {Object}
 */

function parseTSVContents(tsv) {
  var tsvLines = tsv.split(/\n+/g);
  var headers = trim(tsvLines.shift()).split(itemSplitRegex);
  var categories = [];
  var series = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map(headers, function (header) {
    return {
      name: header,
      data: []
    };
  });

  for (var i = 0; i < tsvLines.length; i++) {
    var items = trim(tsvLines[i]).split(itemSplitRegex);
    categories.push(items.shift());

    for (var j = 0; j < items.length; j++) {
      series[j] && (series[j].data[i] = items[j]);
    }
  }

  return {
    series: series,
    categories: categories
  };
}

function parseListContents(str) {
  var lines = str.split(/\n+/g);
  var seriesName = trim(lines.shift());
  var data = [];

  for (var i = 0; i < lines.length; i++) {
    // if line is empty, ignore it.
    // there is a case that a user forgot to delete `\n`.
    var line = trim(lines[i]);

    if (!line) {
      continue;
    }

    var items = line.split(itemSplitRegex);
    var name_1 = '';
    var value = void 0;
    var hasName = false;

    if (isNaN(items[0])) {
      // First item is name
      hasName = true;
      name_1 = items[0];
      items = items.slice(1);
      data[i] = {
        name: name_1,
        value: []
      };
      value = data[i].value;
    } else {
      value = data[i] = [];
    }

    for (var j = 0; j < items.length; j++) {
      value.push(+items[j]);
    }

    if (value.length === 1) {
      hasName ? data[i].value = value[0] : data[i] = value[0];
    }
  }

  return {
    name: seriesName,
    data: data
  };
}

function parseContents(str, blockMetaList) {
  var blocks = str.split(new RegExp('\n*' + BLOCK_SPLITER + '\n*', 'g'));
  var newOption = {
    series: []
  };
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(blocks, function (block, idx) {
    if (isTSVFormat(block)) {
      var result = parseTSVContents(block);
      var blockMeta = blockMetaList[idx];
      var axisKey = blockMeta.axisDim + 'Axis';

      if (blockMeta) {
        newOption[axisKey] = newOption[axisKey] || [];
        newOption[axisKey][blockMeta.axisIndex] = {
          data: result.categories
        };
        newOption.series = newOption.series.concat(result.series);
      }
    } else {
      var result = parseListContents(block);
      newOption.series.push(result);
    }
  });
  return newOption;
}

var DataView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DataView, _super);

  function DataView() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  DataView.prototype.onclick = function (ecModel, api) {
    var container = api.getDom();
    var model = this.model;

    if (this._dom) {
      container.removeChild(this._dom);
    }

    var root = document.createElement('div');
    root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';
    root.style.backgroundColor = model.get('backgroundColor') || '#fff'; // Create elements

    var header = document.createElement('h4');
    var lang = model.get('lang') || [];
    header.innerHTML = lang[0] || model.get('title');
    header.style.cssText = 'margin: 10px 20px;';
    header.style.color = model.get('textColor');
    var viewMain = document.createElement('div');
    var textarea = document.createElement('textarea');
    viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';
    var optionToContent = model.get('optionToContent');
    var contentToOption = model.get('contentToOption');
    var result = getContentFromModel(ecModel);

    if (typeof optionToContent === 'function') {
      var htmlOrDom = optionToContent(api.getOption());

      if (typeof htmlOrDom === 'string') {
        viewMain.innerHTML = htmlOrDom;
      } else if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isDom(htmlOrDom)) {
        viewMain.appendChild(htmlOrDom);
      }
    } else {
      // Use default textarea
      viewMain.appendChild(textarea);
      textarea.readOnly = model.get('readOnly');
      textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';
      textarea.style.color = model.get('textColor');
      textarea.style.borderColor = model.get('textareaBorderColor');
      textarea.style.backgroundColor = model.get('textareaColor');
      textarea.value = result.value;
    }

    var blockMetaList = result.meta;
    var buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';
    var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';
    var closeButton = document.createElement('div');
    var refreshButton = document.createElement('div');
    buttonStyle += ';background-color:' + model.get('buttonColor');
    buttonStyle += ';color:' + model.get('buttonTextColor');
    var self = this;

    function close() {
      container.removeChild(root);
      self._dom = null;
    }

    (0,zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_2__.addEventListener)(closeButton, 'click', close);
    (0,zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_2__.addEventListener)(refreshButton, 'click', function () {
      if (contentToOption == null && optionToContent != null || contentToOption != null && optionToContent == null) {
        if (true) {
          // eslint-disable-next-line
          console.warn('It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored.');
        }

        close();
        return;
      }

      var newOption;

      try {
        if (typeof contentToOption === 'function') {
          newOption = contentToOption(viewMain, api.getOption());
        } else {
          newOption = parseContents(textarea.value, blockMetaList);
        }
      } catch (e) {
        close();
        throw new Error('Data view format error ' + e);
      }

      if (newOption) {
        api.dispatchAction({
          type: 'changeDataView',
          newOption: newOption
        });
      }

      close();
    });
    closeButton.innerHTML = lang[1];
    refreshButton.innerHTML = lang[2];
    refreshButton.style.cssText = buttonStyle;
    closeButton.style.cssText = buttonStyle;
    !model.get('readOnly') && buttonContainer.appendChild(refreshButton);
    buttonContainer.appendChild(closeButton);
    root.appendChild(header);
    root.appendChild(viewMain);
    root.appendChild(buttonContainer);
    viewMain.style.height = container.clientHeight - 80 + 'px';
    container.appendChild(root);
    this._dom = root;
  };

  DataView.prototype.remove = function (ecModel, api) {
    this._dom && api.getDom().removeChild(this._dom);
  };

  DataView.prototype.dispose = function (ecModel, api) {
    this.remove(ecModel, api);
  };

  DataView.getDefaultOption = function (ecModel) {
    var defaultOption = {
      show: true,
      readOnly: false,
      optionToContent: null,
      contentToOption: null,
      // eslint-disable-next-line
      icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',
      title: ecModel.getLocale(['toolbox', 'dataView', 'title']),
      lang: ecModel.getLocale(['toolbox', 'dataView', 'lang']),
      backgroundColor: '#fff',
      textColor: '#000',
      textareaColor: '#fff',
      textareaBorderColor: '#333',
      buttonColor: '#c23531',
      buttonTextColor: '#fff'
    };
    return defaultOption;
  };

  return DataView;
}(_featureManager__WEBPACK_IMPORTED_MODULE_3__.ToolboxFeature);
/**
 * @inner
 */


function tryMergeDataOption(newData, originalData) {
  return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map(newData, function (newVal, idx) {
    var original = originalData && originalData[idx];

    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject(original) && !zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(original)) {
      var newValIsObject = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject(newVal) && !zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(newVal);

      if (!newValIsObject) {
        newVal = {
          value: newVal
        };
      } // original data has name but new data has no name


      var shouldDeleteName = original.name != null && newVal.name == null; // Original data has option

      newVal = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.defaults(newVal, original);
      shouldDeleteName && delete newVal.name;
      return newVal;
    } else {
      return newVal;
    }
  });
} // TODO: SELF REGISTERED.


_core_echarts__WEBPACK_IMPORTED_MODULE_4__.registerAction({
  type: 'changeDataView',
  event: 'dataViewChanged',
  update: 'prepareAndUpdate'
}, function (payload, ecModel) {
  var newSeriesOptList = [];
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(payload.newOption.series, function (seriesOpt) {
    var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];

    if (!seriesModel) {
      // New created series
      // Geuss the series type
      newSeriesOptList.push(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.extend({
        // Default is scatter
        type: 'scatter'
      }, seriesOpt));
    } else {
      var originalData = seriesModel.get('data');
      newSeriesOptList.push({
        name: seriesOpt.name,
        data: tryMergeDataOption(seriesOpt.data, originalData)
      });
    }
  });
  ecModel.mergeOption(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.defaults({
    series: newSeriesOptList
  }, payload.newOption));
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/DataZoom.js":
/*!************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/toolbox/feature/DataZoom.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _helper_BrushController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../helper/BrushController */ "./node_modules/echarts/lib/component/helper/BrushController.js");
/* harmony import */ var _helper_BrushTargetManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../helper/BrushTargetManager */ "./node_modules/echarts/lib/component/helper/BrushTargetManager.js");
/* harmony import */ var _dataZoom_history__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../dataZoom/history */ "./node_modules/echarts/lib/component/dataZoom/history.js");
/* harmony import */ var _helper_sliderMove__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../helper/sliderMove */ "./node_modules/echarts/lib/component/helper/sliderMove.js");
/* harmony import */ var _featureManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../featureManager */ "./node_modules/echarts/lib/component/toolbox/featureManager.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _model_internalComponentCreator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../model/internalComponentCreator */ "./node_modules/echarts/lib/model/internalComponentCreator.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
 // TODO depends on DataZoom and Brush









var each = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each;
var DATA_ZOOM_ID_BASE = (0,_util_model__WEBPACK_IMPORTED_MODULE_1__.makeInternalComponentId)('toolbox-dataZoom_');
var ICON_TYPES = ['zoom', 'back'];

var DataZoomFeature =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DataZoomFeature, _super);

  function DataZoomFeature() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  DataZoomFeature.prototype.render = function (featureModel, ecModel, api, payload) {
    if (!this._brushController) {
      this._brushController = new _helper_BrushController__WEBPACK_IMPORTED_MODULE_3__.default(api.getZr());

      this._brushController.on('brush', zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.bind(this._onBrush, this)).mount();
    }

    updateZoomBtnStatus(featureModel, ecModel, this, payload, api);
    updateBackBtnStatus(featureModel, ecModel);
  };

  DataZoomFeature.prototype.onclick = function (ecModel, api, type) {
    handlers[type].call(this);
  };

  DataZoomFeature.prototype.remove = function (ecModel, api) {
    this._brushController && this._brushController.unmount();
  };

  DataZoomFeature.prototype.dispose = function (ecModel, api) {
    this._brushController && this._brushController.dispose();
  };

  DataZoomFeature.prototype._onBrush = function (eventParam) {
    var areas = eventParam.areas;

    if (!eventParam.isEnd || !areas.length) {
      return;
    }

    var snapshot = {};
    var ecModel = this.ecModel;

    this._brushController.updateCovers([]); // remove cover


    var brushTargetManager = new _helper_BrushTargetManager__WEBPACK_IMPORTED_MODULE_4__.default(makeAxisFinder(this.model), ecModel, {
      include: ['grid']
    });
    brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {
      if (coordSys.type !== 'cartesian2d') {
        return;
      }

      var brushType = area.brushType;

      if (brushType === 'rect') {
        setBatch('x', coordSys, coordRange[0]);
        setBatch('y', coordSys, coordRange[1]);
      } else {
        setBatch({
          lineX: 'x',
          lineY: 'y'
        }[brushType], coordSys, coordRange);
      }
    });
    _dataZoom_history__WEBPACK_IMPORTED_MODULE_5__.push(ecModel, snapshot);

    this._dispatchZoomAction(snapshot);

    function setBatch(dimName, coordSys, minMax) {
      var axis = coordSys.getAxis(dimName);
      var axisModel = axis.model;
      var dataZoomModel = findDataZoom(dimName, axisModel, ecModel); // Restrict range.

      var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();

      if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
        minMax = (0,_helper_sliderMove__WEBPACK_IMPORTED_MODULE_6__.default)(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
      }

      dataZoomModel && (snapshot[dataZoomModel.id] = {
        dataZoomId: dataZoomModel.id,
        startValue: minMax[0],
        endValue: minMax[1]
      });
    }

    function findDataZoom(dimName, axisModel, ecModel) {
      var found;
      ecModel.eachComponent({
        mainType: 'dataZoom',
        subType: 'select'
      }, function (dzModel) {
        var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);
        has && (found = dzModel);
      });
      return found;
    }
  };

  ;

  DataZoomFeature.prototype._dispatchZoomAction = function (snapshot) {
    var batch = []; // Convert from hash map to array.

    each(snapshot, function (batchItem, dataZoomId) {
      batch.push(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.clone(batchItem));
    });
    batch.length && this.api.dispatchAction({
      type: 'dataZoom',
      from: this.uid,
      batch: batch
    });
  };

  DataZoomFeature.getDefaultOption = function (ecModel) {
    var defaultOption = {
      show: true,
      filterMode: 'filter',
      // Icon group
      icon: {
        zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',
        back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'
      },
      // `zoom`, `back`
      title: ecModel.getLocale(['toolbox', 'dataZoom', 'title']),
      brushStyle: {
        borderWidth: 0,
        color: 'rgba(210,219,238,0.2)'
      }
    };
    return defaultOption;
  };

  return DataZoomFeature;
}(_featureManager__WEBPACK_IMPORTED_MODULE_7__.ToolboxFeature);

var handlers = {
  zoom: function () {
    var nextActive = !this._isZoomActive;
    this.api.dispatchAction({
      type: 'takeGlobalCursor',
      key: 'dataZoomSelect',
      dataZoomSelectActive: nextActive
    });
  },
  back: function () {
    this._dispatchZoomAction(_dataZoom_history__WEBPACK_IMPORTED_MODULE_5__.pop(this.ecModel));
  }
};

function makeAxisFinder(dzFeatureModel) {
  var setting = {
    xAxisIndex: dzFeatureModel.get('xAxisIndex', true),
    yAxisIndex: dzFeatureModel.get('yAxisIndex', true),
    xAxisId: dzFeatureModel.get('xAxisId', true),
    yAxisId: dzFeatureModel.get('yAxisId', true)
  }; // If both `xAxisIndex` `xAxisId` not set, it means 'all'.
  // If both `yAxisIndex` `yAxisId` not set, it means 'all'.
  // Some old cases set like this below to close yAxis control but leave xAxis control:
  // `{ feature: { dataZoom: { yAxisIndex: false } }`.

  if (setting.xAxisIndex == null && setting.xAxisId == null) {
    setting.xAxisIndex = 'all';
  }

  if (setting.yAxisIndex == null && setting.yAxisId == null) {
    setting.yAxisIndex = 'all';
  }

  return setting;
}

function updateBackBtnStatus(featureModel, ecModel) {
  featureModel.setIconStatus('back', _dataZoom_history__WEBPACK_IMPORTED_MODULE_5__.count(ecModel) > 1 ? 'emphasis' : 'normal');
}

function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {
  var zoomActive = view._isZoomActive;

  if (payload && payload.type === 'takeGlobalCursor') {
    zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false;
  }

  view._isZoomActive = zoomActive;
  featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');
  var brushTargetManager = new _helper_BrushTargetManager__WEBPACK_IMPORTED_MODULE_4__.default(makeAxisFinder(featureModel), ecModel, {
    include: ['grid']
  });
  var panels = brushTargetManager.makePanelOpts(api, function (targetInfo) {
    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? 'lineX' : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? 'lineY' : 'rect';
  });

  view._brushController.setPanels(panels).enableBrush(zoomActive && panels.length ? {
    brushType: 'auto',
    brushStyle: featureModel.getModel('brushStyle').getItemStyle()
  } : false);
}

(0,_model_internalComponentCreator__WEBPACK_IMPORTED_MODULE_8__.registerInternalOptionCreator)('dataZoom', function (ecModel) {
  var toolboxModel = ecModel.getComponent('toolbox', 0);

  if (!toolboxModel) {
    return;
  }

  var dzFeatureModel = toolboxModel.getModel(['feature', 'dataZoom']);
  var dzOptions = [];
  var finder = makeAxisFinder(dzFeatureModel);
  var finderResult = (0,_util_model__WEBPACK_IMPORTED_MODULE_1__.parseFinder)(ecModel, finder);
  each(finderResult.xAxisModels, function (axisModel) {
    return buildInternalOptions(axisModel, 'xAxis', 'xAxisIndex');
  });
  each(finderResult.yAxisModels, function (axisModel) {
    return buildInternalOptions(axisModel, 'yAxis', 'yAxisIndex');
  });

  function buildInternalOptions(axisModel, axisMainType, axisIndexPropName) {
    var axisIndex = axisModel.componentIndex;
    var newOpt = {
      type: 'select',
      $fromToolbox: true,
      // Default to be filter
      filterMode: dzFeatureModel.get('filterMode', true) || 'filter',
      // Id for merge mapping.
      id: DATA_ZOOM_ID_BASE + axisMainType + axisIndex
    };
    newOpt[axisIndexPropName] = axisIndex;
    dzOptions.push(newOpt);
  }

  return dzOptions;
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataZoomFeature);

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/MagicType.js":
/*!*************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/toolbox/feature/MagicType.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _core_echarts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/echarts */ "./node_modules/echarts/lib/core/echarts.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _featureManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../featureManager */ "./node_modules/echarts/lib/component/toolbox/featureManager.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var INNER_STACK_KEYWORD = '__ec_magicType_stack__';
var ICON_TYPES = ['line', 'bar', 'stack']; // stack and tiled appears in pair for the title

var TITLE_TYPES = ['line', 'bar', 'stack', 'tiled'];
var radioTypes = [['line', 'bar'], ['stack']];

var MagicType =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(MagicType, _super);

  function MagicType() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  MagicType.prototype.getIcons = function () {
    var model = this.model;
    var availableIcons = model.get('icon');
    var icons = {};
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(model.get('type'), function (type) {
      if (availableIcons[type]) {
        icons[type] = availableIcons[type];
      }
    });
    return icons;
  };

  MagicType.getDefaultOption = function (ecModel) {
    var defaultOption = {
      show: true,
      type: [],
      // Icon group
      icon: {
        line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',
        bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',
        // eslint-disable-next-line
        stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z' // jshint ignore:line

      },
      // `line`, `bar`, `stack`, `tiled`
      title: ecModel.getLocale(['toolbox', 'magicType', 'title']),
      option: {},
      seriesIndex: {}
    };
    return defaultOption;
  };

  MagicType.prototype.onclick = function (ecModel, api, type) {
    var model = this.model;
    var seriesIndex = model.get(['seriesIndex', type]); // Not supported magicType

    if (!seriesOptGenreator[type]) {
      return;
    }

    var newOption = {
      series: []
    };

    var generateNewSeriesTypes = function (seriesModel) {
      var seriesType = seriesModel.subType;
      var seriesId = seriesModel.id;
      var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);

      if (newSeriesOpt) {
        // PENDING If merge original option?
        zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults(newSeriesOpt, seriesModel.option);
        newOption.series.push(newSeriesOpt);
      } // Modify boundaryGap


      var coordSys = seriesModel.coordinateSystem;

      if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {
        var categoryAxis = coordSys.getAxesByScale('ordinal')[0];

        if (categoryAxis) {
          var axisDim = categoryAxis.dim;
          var axisType = axisDim + 'Axis';
          var axisModel = seriesModel.getReferringComponents(axisType, _util_model__WEBPACK_IMPORTED_MODULE_2__.SINGLE_REFERRING).models[0];
          var axisIndex = axisModel.componentIndex;
          newOption[axisType] = newOption[axisType] || [];

          for (var i = 0; i <= axisIndex; i++) {
            newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
          }

          newOption[axisType][axisIndex].boundaryGap = type === 'bar';
        }
      }
    };

    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(radioTypes, function (radio) {
      if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.indexOf(radio, type) >= 0) {
        zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(radio, function (item) {
          model.setIconStatus(item, 'normal');
        });
      }
    });
    model.setIconStatus(type, 'emphasis');
    ecModel.eachComponent({
      mainType: 'series',
      query: seriesIndex == null ? null : {
        seriesIndex: seriesIndex
      }
    }, generateNewSeriesTypes);
    var newTitle; // Change title of stack

    if (type === 'stack') {
      // use titles in model instead of ecModel
      // as stack and tiled appears in pair, just flip them
      // no need of checking stack state
      newTitle = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge({
        stack: model.option.title.tiled,
        tiled: model.option.title.stack
      }, model.option.title);
    }

    api.dispatchAction({
      type: 'changeMagicType',
      currentType: type,
      newOption: newOption,
      newTitle: newTitle,
      featureName: 'magicType'
    });
  };

  return MagicType;
}(_featureManager__WEBPACK_IMPORTED_MODULE_3__.ToolboxFeature);

var seriesOptGenreator = {
  'line': function (seriesType, seriesId, seriesModel, model) {
    if (seriesType === 'bar') {
      return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge({
        id: seriesId,
        type: 'line',
        // Preserve data related option
        data: seriesModel.get('data'),
        stack: seriesModel.get('stack'),
        markPoint: seriesModel.get('markPoint'),
        markLine: seriesModel.get('markLine')
      }, model.get(['option', 'line']) || {}, true);
    }
  },
  'bar': function (seriesType, seriesId, seriesModel, model) {
    if (seriesType === 'line') {
      return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge({
        id: seriesId,
        type: 'bar',
        // Preserve data related option
        data: seriesModel.get('data'),
        stack: seriesModel.get('stack'),
        markPoint: seriesModel.get('markPoint'),
        markLine: seriesModel.get('markLine')
      }, model.get(['option', 'bar']) || {}, true);
    }
  },
  'stack': function (seriesType, seriesId, seriesModel, model) {
    var isStack = seriesModel.get('stack') === INNER_STACK_KEYWORD;

    if (seriesType === 'line' || seriesType === 'bar') {
      model.setIconStatus('stack', isStack ? 'normal' : 'emphasis');
      return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge({
        id: seriesId,
        stack: isStack ? '' : INNER_STACK_KEYWORD
      }, model.get(['option', 'stack']) || {}, true);
    }
  }
}; // TODO: SELF REGISTERED.

_core_echarts__WEBPACK_IMPORTED_MODULE_4__.registerAction({
  type: 'changeMagicType',
  event: 'magicTypeChanged',
  update: 'prepareAndUpdate'
}, function (payload, ecModel) {
  ecModel.mergeOption(payload.newOption);
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MagicType);

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/Restore.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/toolbox/feature/Restore.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _core_echarts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/echarts */ "./node_modules/echarts/lib/core/echarts.js");
/* harmony import */ var _dataZoom_history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dataZoom/history */ "./node_modules/echarts/lib/component/dataZoom/history.js");
/* harmony import */ var _featureManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../featureManager */ "./node_modules/echarts/lib/component/toolbox/featureManager.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var RestoreOption =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(RestoreOption, _super);

  function RestoreOption() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  RestoreOption.prototype.onclick = function (ecModel, api) {
    _dataZoom_history__WEBPACK_IMPORTED_MODULE_1__.clear(ecModel);
    api.dispatchAction({
      type: 'restore',
      from: this.uid
    });
  };

  RestoreOption.getDefaultOption = function (ecModel) {
    var defaultOption = {
      show: true,
      // eslint-disable-next-line
      icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',
      title: ecModel.getLocale(['toolbox', 'restore', 'title'])
    };
    return defaultOption;
  };

  return RestoreOption;
}(_featureManager__WEBPACK_IMPORTED_MODULE_2__.ToolboxFeature); // TODO: SELF REGISTERED.


_core_echarts__WEBPACK_IMPORTED_MODULE_3__.registerAction({
  type: 'restore',
  event: 'restore',
  update: 'prepareAndUpdate'
}, function (payload, ecModel) {
  ecModel.resetOption('recreate');
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RestoreOption);

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js":
/*!***************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/env */ "./node_modules/zrender/lib/core/env.js");
/* harmony import */ var _featureManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../featureManager */ "./node_modules/echarts/lib/component/toolbox/featureManager.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/* global Uint8Array */




var SaveAsImage =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SaveAsImage, _super);

  function SaveAsImage() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  SaveAsImage.prototype.onclick = function (ecModel, api) {
    var model = this.model;
    var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';
    var isSvg = api.getZr().painter.getType() === 'svg';
    var type = isSvg ? 'svg' : model.get('type', true) || 'png';
    var url = api.getConnectedDataURL({
      type: type,
      backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',
      connectedBackgroundColor: model.get('connectedBackgroundColor'),
      excludeComponents: model.get('excludeComponents'),
      pixelRatio: model.get('pixelRatio')
    }); // Chrome, Firefox, New Edge

    if (typeof MouseEvent === 'function' && (zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_1__.default.browser.newEdge || !zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_1__.default.browser.ie && !zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_1__.default.browser.edge)) {
      var $a = document.createElement('a');
      $a.download = title + '.' + type;
      $a.target = '_blank';
      $a.href = url;
      var evt = new MouseEvent('click', {
        // some micro front-end framework， window maybe is a Proxy
        view: document.defaultView,
        bubbles: true,
        cancelable: false
      });
      $a.dispatchEvent(evt);
    } // IE or old Edge
    else {
        if (window.navigator.msSaveOrOpenBlob || isSvg) {
          var parts = url.split(','); // data:[<mime type>][;charset=<charset>][;base64],<encoded data>

          var base64Encoded = parts[0].indexOf('base64') > -1;
          var bstr = isSvg // should decode the svg data uri first
          ? decodeURIComponent(parts[1]) : parts[1]; // only `atob` when the data uri is encoded with base64
          // otherwise, like `svg` data uri exported by zrender,
          // there will be an error, for it's not encoded with base64.
          // (just a url-encoded string through `encodeURIComponent`)

          base64Encoded && (bstr = atob(bstr));
          var filename = title + '.' + type;

          if (window.navigator.msSaveOrOpenBlob) {
            var n = bstr.length;
            var u8arr = new Uint8Array(n);

            while (n--) {
              u8arr[n] = bstr.charCodeAt(n);
            }

            var blob = new Blob([u8arr]);
            window.navigator.msSaveOrOpenBlob(blob, filename);
          } else {
            var frame = document.createElement('iframe');
            document.body.appendChild(frame);
            var cw = frame.contentWindow;
            var doc = cw.document;
            doc.open('image/svg+xml', 'replace');
            doc.write(bstr);
            doc.close();
            cw.focus();
            doc.execCommand('SaveAs', true, filename);
            document.body.removeChild(frame);
          }
        } else {
          var lang = model.get('lang');
          var html = '' + '<body style="margin:0;">' + '<img src="' + url + '" style="max-width:100%;" title="' + (lang && lang[0] || '') + '" />' + '</body>';
          var tab = window.open();
          tab.document.write(html);
          tab.document.title = title;
        }
      }
  };

  SaveAsImage.getDefaultOption = function (ecModel) {
    var defaultOption = {
      show: true,
      icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',
      title: ecModel.getLocale(['toolbox', 'saveAsImage', 'title']),
      type: 'png',
      // Default use option.backgroundColor
      // backgroundColor: '#fff',
      connectedBackgroundColor: '#fff',
      name: '',
      excludeComponents: ['toolbox'],
      // use current pixel ratio of device by default
      // pixelRatio: 1,
      lang: ecModel.getLocale(['toolbox', 'saveAsImage', 'lang'])
    };
    return defaultOption;
  };

  return SaveAsImage;
}(_featureManager__WEBPACK_IMPORTED_MODULE_2__.ToolboxFeature);

SaveAsImage.prototype.unusable = !zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_1__.default.canvasSupported;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SaveAsImage);

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/featureManager.js":
/*!**********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/toolbox/featureManager.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ToolboxFeature": () => (/* binding */ ToolboxFeature),
/* harmony export */   "registerFeature": () => (/* binding */ registerFeature),
/* harmony export */   "getFeature": () => (/* binding */ getFeature)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

var ToolboxFeature =
/** @class */
function () {
  function ToolboxFeature() {}

  return ToolboxFeature;
}();


var features = {};
function registerFeature(name, ctor) {
  features[name] = ctor;
}
function getFeature(name) {
  return features[name];
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/toolbox/install.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/component/toolbox/install.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../extension */ "./node_modules/echarts/lib/extension.js");
/* harmony import */ var _component_dataZoom_installDataZoomSelect__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../component/dataZoom/installDataZoomSelect */ "./node_modules/echarts/lib/component/dataZoom/installDataZoomSelect.js");
/* harmony import */ var _ToolboxModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ToolboxModel */ "./node_modules/echarts/lib/component/toolbox/ToolboxModel.js");
/* harmony import */ var _ToolboxView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ToolboxView */ "./node_modules/echarts/lib/component/toolbox/ToolboxView.js");
/* harmony import */ var _featureManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./featureManager */ "./node_modules/echarts/lib/component/toolbox/featureManager.js");
/* harmony import */ var _feature_SaveAsImage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./feature/SaveAsImage */ "./node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js");
/* harmony import */ var _feature_MagicType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./feature/MagicType */ "./node_modules/echarts/lib/component/toolbox/feature/MagicType.js");
/* harmony import */ var _feature_DataView__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./feature/DataView */ "./node_modules/echarts/lib/component/toolbox/feature/DataView.js");
/* harmony import */ var _feature_Restore__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./feature/Restore */ "./node_modules/echarts/lib/component/toolbox/feature/Restore.js");
/* harmony import */ var _feature_DataZoom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./feature/DataZoom */ "./node_modules/echarts/lib/component/toolbox/feature/DataZoom.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



 // TODOD: REGISTER IN INSTALL







function install(registers) {
  registers.registerComponentModel(_ToolboxModel__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerComponentView(_ToolboxView__WEBPACK_IMPORTED_MODULE_1__.default);
  (0,_featureManager__WEBPACK_IMPORTED_MODULE_2__.registerFeature)('saveAsImage', _feature_SaveAsImage__WEBPACK_IMPORTED_MODULE_3__.default);
  (0,_featureManager__WEBPACK_IMPORTED_MODULE_2__.registerFeature)('magicType', _feature_MagicType__WEBPACK_IMPORTED_MODULE_4__.default);
  (0,_featureManager__WEBPACK_IMPORTED_MODULE_2__.registerFeature)('dataView', _feature_DataView__WEBPACK_IMPORTED_MODULE_5__.default);
  (0,_featureManager__WEBPACK_IMPORTED_MODULE_2__.registerFeature)('dataZoom', _feature_DataZoom__WEBPACK_IMPORTED_MODULE_6__.default);
  (0,_featureManager__WEBPACK_IMPORTED_MODULE_2__.registerFeature)('restore', _feature_Restore__WEBPACK_IMPORTED_MODULE_7__.default);
  (0,_extension__WEBPACK_IMPORTED_MODULE_8__.use)(_component_dataZoom_installDataZoomSelect__WEBPACK_IMPORTED_MODULE_9__.install);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/tooltip/TooltipHTMLContent.js":
/*!**************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/tooltip/TooltipHTMLContent.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/tool/color */ "./node_modules/zrender/lib/tool/color.js");
/* harmony import */ var zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zrender/lib/core/event */ "./node_modules/zrender/lib/core/event.js");
/* harmony import */ var zrender_lib_core_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/core/dom */ "./node_modules/zrender/lib/core/dom.js");
/* harmony import */ var zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/env */ "./node_modules/zrender/lib/core/env.js");
/* harmony import */ var _util_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/format */ "./node_modules/echarts/lib/util/format.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helper */ "./node_modules/echarts/lib/component/tooltip/helper.js");
/* harmony import */ var _tooltipMarkup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tooltipMarkup */ "./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








var vendors = ['-ms-', '-moz-', '-o-', '-webkit-', ''];
var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';

function mirrorPos(pos) {
  pos = pos === 'left' ? 'right' : pos === 'right' ? 'left' : pos === 'top' ? 'bottom' : 'top';
  return pos;
}

function assembleArrow(backgroundColor, borderColor, arrowPosition) {
  if (!(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isString)(arrowPosition) || arrowPosition === 'inside') {
    return '';
  }

  borderColor = (0,_util_format__WEBPACK_IMPORTED_MODULE_1__.convertToColorString)(borderColor);
  var arrowPos = mirrorPos(arrowPosition);
  var positionStyle = '';
  var transformStyle = '';

  if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.indexOf)(['left', 'right'], arrowPos) > -1) {
    positionStyle = arrowPos + ":-6px;top:50%;";
    transformStyle = "translateY(-50%) rotate(" + (arrowPos === 'left' ? -225 : -45) + "deg)";
  } else {
    positionStyle = arrowPos + ":-6px;left:50%;";
    transformStyle = "translateX(-50%) rotate(" + (arrowPos === 'top' ? 225 : 45) + "deg)";
  }

  transformStyle = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map)(vendors, function (vendorPrefix) {
    return vendorPrefix + 'transform:' + transformStyle;
  }).join(';');
  var styleCss = ['position:absolute;width:10px;height:10px;', "" + positionStyle + transformStyle + ";", "border-bottom: " + borderColor + " solid 1px;", "border-right: " + borderColor + " solid 1px;", "background-color: " + backgroundColor + ";", 'box-shadow: 8px 8px 16px -3px #000;'];
  return "<div style=\"" + styleCss.join('') + "\"></div>";
}

function assembleTransition(duration, onlyFade) {
  var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';
  var transitionText = 'opacity ' + duration / 2 + 's ' + transitionCurve + ',' + 'visibility ' + duration / 2 + 's ' + transitionCurve;

  if (!onlyFade) {
    transitionText += ',left ' + duration + 's ' + transitionCurve + ',top ' + duration + 's ' + transitionCurve;
  }

  return (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map)(vendors, function (vendorPrefix) {
    return vendorPrefix + 'transition:' + transitionText;
  }).join(';');
}
/**
 * @param {Object} textStyle
 * @return {string}
 * @inner
 */


function assembleFont(textStyleModel) {
  var cssText = [];
  var fontSize = textStyleModel.get('fontSize');
  var color = textStyleModel.getTextColor();
  color && cssText.push('color:' + color);
  cssText.push('font:' + textStyleModel.getFont());
  fontSize // @ts-ignore, leave it to the tooltip refactor.
  && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');
  var shadowColor = textStyleModel.get('textShadowColor');
  var shadowBlur = textStyleModel.get('textShadowBlur') || 0;
  var shadowOffsetX = textStyleModel.get('textShadowOffsetX') || 0;
  var shadowOffsetY = textStyleModel.get('textShadowOffsetY') || 0;
  shadowColor && shadowBlur && cssText.push('text-shadow:' + shadowOffsetX + 'px ' + shadowOffsetY + 'px ' + shadowBlur + 'px ' + shadowColor);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(['decoration', 'align'], function (name) {
    var val = textStyleModel.get(name);
    val && cssText.push('text-' + name + ':' + val);
  });
  return cssText.join(';');
}

function assembleCssText(tooltipModel, enableTransition, onlyFade) {
  var cssText = [];
  var transitionDuration = tooltipModel.get('transitionDuration');
  var backgroundColor = tooltipModel.get('backgroundColor');
  var shadowBlur = tooltipModel.get('shadowBlur');
  var shadowColor = tooltipModel.get('shadowColor');
  var shadowOffsetX = tooltipModel.get('shadowOffsetX');
  var shadowOffsetY = tooltipModel.get('shadowOffsetY');
  var textStyleModel = tooltipModel.getModel('textStyle');
  var padding = (0,_tooltipMarkup__WEBPACK_IMPORTED_MODULE_2__.getPaddingFromTooltipModel)(tooltipModel, 'html');
  var boxShadow = shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor;
  cssText.push('box-shadow:' + boxShadow); // Animation transition. Do not animate when transitionDuration is 0.

  enableTransition && transitionDuration && cssText.push(assembleTransition(transitionDuration, onlyFade));

  if (backgroundColor) {
    if (zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_3__.default.canvasSupported) {
      cssText.push('background-Color:' + backgroundColor);
    } else {
      // for ie
      cssText.push('background-Color:#' + (0,zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_4__.toHex)(backgroundColor));
      cssText.push('filter:alpha(opacity=70)');
    }
  } // Border style


  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(['width', 'color', 'radius'], function (name) {
    var borderName = 'border-' + name;
    var camelCase = (0,_util_format__WEBPACK_IMPORTED_MODULE_1__.toCamelCase)(borderName);
    var val = tooltipModel.get(camelCase);
    val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
  }); // Text style

  cssText.push(assembleFont(textStyleModel)); // Padding

  if (padding != null) {
    cssText.push('padding:' + (0,_util_format__WEBPACK_IMPORTED_MODULE_1__.normalizeCssArray)(padding).join('px ') + 'px');
  }

  return cssText.join(';') + ';';
} // If not able to make, do not modify the input `out`.


function makeStyleCoord(out, zr, appendToBody, zrX, zrY) {
  var zrPainter = zr && zr.painter;

  if (appendToBody) {
    var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();

    if (zrViewportRoot) {
      // Some APPs might use scale on body, so we support CSS transform here.
      (0,zrender_lib_core_dom__WEBPACK_IMPORTED_MODULE_5__.transformLocalCoord)(out, zrViewportRoot, document.body, zrX, zrY);
    }
  } else {
    out[0] = zrX;
    out[1] = zrY; // xy should be based on canvas root. But tooltipContent is
    // the sibling of canvas root. So padding of ec container
    // should be considered here.

    var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();

    if (viewportRootOffset) {
      out[0] += viewportRootOffset.offsetLeft;
      out[1] += viewportRootOffset.offsetTop;
    }
  }

  out[2] = out[0] / zr.getWidth();
  out[3] = out[1] / zr.getHeight();
}

var TooltipHTMLContent =
/** @class */
function () {
  function TooltipHTMLContent(container, api, opt) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._enterable = true;
    this._firstShow = true;
    this._longHide = true;

    if (zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_3__.default.wxa) {
      return null;
    }

    var el = document.createElement('div'); // TODO: TYPE

    el.domBelongToZr = true;
    this.el = el;
    var zr = this._zr = api.getZr();
    var appendToBody = this._appendToBody = opt && opt.appendToBody;
    makeStyleCoord(this._styleCoord, zr, appendToBody, api.getWidth() / 2, api.getHeight() / 2);

    if (appendToBody) {
      document.body.appendChild(el);
    } else {
      container.appendChild(el);
    }

    this._container = container; // FIXME
    // Is it needed to trigger zr event manually if
    // the browser do not support `pointer-events: none`.

    var self = this;

    el.onmouseenter = function () {
      // clear the timeout in hideLater and keep showing tooltip
      if (self._enterable) {
        clearTimeout(self._hideTimeout);
        self._show = true;
      }

      self._inContent = true;
    };

    el.onmousemove = function (e) {
      e = e || window.event;

      if (!self._enterable) {
        // `pointer-events: none` is set to tooltip content div
        // if `enterable` is set as `false`, and `el.onmousemove`
        // can not be triggered. But in browser that do not
        // support `pointer-events`, we need to do this:
        // Try trigger zrender event to avoid mouse
        // in and out shape too frequently
        var handler = zr.handler;
        var zrViewportRoot = zr.painter.getViewportRoot();
        (0,zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_6__.normalizeEvent)(zrViewportRoot, e, true);
        handler.dispatch('mousemove', e);
      }
    };

    el.onmouseleave = function () {
      // set `_inContent` to `false` before `hideLater`
      self._inContent = false;

      if (self._enterable) {
        if (self._show) {
          self.hideLater(self._hideDelay);
        }
      }
    };
  }
  /**
   * Update when tooltip is rendered
   */


  TooltipHTMLContent.prototype.update = function (tooltipModel) {
    // FIXME
    // Move this logic to ec main?
    var container = this._container;
    var stl = container.currentStyle || document.defaultView.getComputedStyle(container);
    var domStyle = container.style;

    if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {
      domStyle.position = 'relative';
    } // move tooltip if chart resized


    var alwaysShowContent = tooltipModel.get('alwaysShowContent');
    alwaysShowContent && this._moveIfResized(); // update className

    this.el.className = tooltipModel.get('className') || ''; // Hide the tooltip
    // PENDING
    // this.hide();
  };

  TooltipHTMLContent.prototype.show = function (tooltipModel, nearPointColor) {
    clearTimeout(this._hideTimeout);
    clearTimeout(this._longHideTimeout);
    var el = this.el;
    var styleCoord = this._styleCoord;
    var offset = el.offsetHeight / 2;
    nearPointColor = (0,_util_format__WEBPACK_IMPORTED_MODULE_1__.convertToColorString)(nearPointColor);
    el.style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide) // Because of the reason described in:
    // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore
    // we should set initial value to `left` and `top`.
    + ';left:' + styleCoord[0] + 'px;top:' + (styleCoord[1] - offset) + 'px;' + ("border-color: " + nearPointColor + ";") + (tooltipModel.get('extraCssText') || '');
    el.style.display = el.innerHTML ? 'block' : 'none'; // If mouse occasionally move over the tooltip, a mouseout event will be
    // triggered by canvas, and cause some unexpectable result like dragging
    // stop, "unfocusAdjacency". Here `pointer-events: none` is used to solve
    // it. Although it is not supported by IE8~IE10, fortunately it is a rare
    // scenario.

    el.style.pointerEvents = this._enterable ? 'auto' : 'none';
    this._show = true;
    this._firstShow = false;
    this._longHide = false;
  };

  TooltipHTMLContent.prototype.setContent = function (content, markers, tooltipModel, borderColor, arrowPosition) {
    if (content == null) {
      return;
    }

    var el = this.el;

    if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isString)(arrowPosition) && tooltipModel.get('trigger') === 'item' && !(0,_helper__WEBPACK_IMPORTED_MODULE_7__.shouldTooltipConfine)(tooltipModel)) {
      content += assembleArrow(tooltipModel.get('backgroundColor'), borderColor, arrowPosition);
    }

    if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isString)(content)) {
      el.innerHTML = content;
    } else if (content) {
      // Clear previous
      el.innerHTML = '';

      if (!(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(content)) {
        content = [content];
      }

      for (var i = 0; i < content.length; i++) {
        if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isDom)(content[i]) && content[i].parentNode !== el) {
          el.appendChild(content[i]);
        }
      }
    }
  };

  TooltipHTMLContent.prototype.setEnterable = function (enterable) {
    this._enterable = enterable;
  };

  TooltipHTMLContent.prototype.getSize = function () {
    var el = this.el;
    return [el.clientWidth, el.clientHeight];
  };

  TooltipHTMLContent.prototype.moveTo = function (zrX, zrY) {
    var styleCoord = this._styleCoord;
    makeStyleCoord(styleCoord, this._zr, this._appendToBody, zrX, zrY);

    if (styleCoord[0] != null && styleCoord[1] != null) {
      var style = this.el.style; // If using float on style, the final width of the dom might
      // keep changing slightly while mouse move. So `toFixed(0)` them.

      style.left = styleCoord[0].toFixed(0) + 'px';
      style.top = styleCoord[1].toFixed(0) + 'px';
    }
  };
  /**
   * when `alwaysShowContent` is true,
   * move the tooltip after chart resized
   */


  TooltipHTMLContent.prototype._moveIfResized = function () {
    // The ratio of left to width
    var ratioX = this._styleCoord[2]; // The ratio of top to height

    var ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  };

  TooltipHTMLContent.prototype.hide = function () {
    var _this = this;

    this.el.style.visibility = 'hidden';
    this.el.style.opacity = '0';
    this._show = false;
    this._longHideTimeout = setTimeout(function () {
      return _this._longHide = true;
    }, 500);
  };

  TooltipHTMLContent.prototype.hideLater = function (time) {
    if (this._show && !(this._inContent && this._enterable)) {
      if (time) {
        this._hideDelay = time; // Set show false to avoid invoke hideLater multiple times

        this._show = false;
        this._hideTimeout = setTimeout((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.bind)(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  };

  TooltipHTMLContent.prototype.isShow = function () {
    return this._show;
  };

  TooltipHTMLContent.prototype.dispose = function () {
    this.el.parentNode.removeChild(this.el);
  };

  TooltipHTMLContent.prototype.getOuterSize = function () {
    var width = this.el.clientWidth;
    var height = this.el.clientHeight; // Consider browser compatibility.
    // IE8 does not support getComputedStyle.

    if (document.defaultView && document.defaultView.getComputedStyle) {
      var stl = document.defaultView.getComputedStyle(this.el);

      if (stl) {
        width += parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);
        height += parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);
      }
    }

    return {
      width: width,
      height: height
    };
  };

  return TooltipHTMLContent;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TooltipHTMLContent);

/***/ }),

/***/ "./node_modules/echarts/lib/component/tooltip/TooltipModel.js":
/*!********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/tooltip/TooltipModel.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var TooltipModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(TooltipModel, _super);

  function TooltipModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = TooltipModel.type;
    return _this;
  }

  TooltipModel.type = 'tooltip';
  TooltipModel.dependencies = ['axisPointer'];
  TooltipModel.defaultOption = {
    zlevel: 0,
    z: 60,
    show: true,
    // tooltip main content
    showContent: true,
    // 'trigger' only works on coordinate system.
    // 'item' | 'axis' | 'none'
    trigger: 'item',
    // 'click' | 'mousemove' | 'none'
    triggerOn: 'mousemove|click',
    alwaysShowContent: false,
    displayMode: 'single',
    renderMode: 'auto',
    // whether restraint content inside viewRect.
    // If renderMode: 'richText', default true.
    // If renderMode: 'html', defaut false (for backward compat).
    confine: null,
    showDelay: 0,
    hideDelay: 100,
    // Animation transition time, unit is second
    transitionDuration: 0.4,
    enterable: false,
    backgroundColor: '#fff',
    // box shadow
    shadowBlur: 10,
    shadowColor: 'rgba(0, 0, 0, .2)',
    shadowOffsetX: 1,
    shadowOffsetY: 2,
    // tooltip border radius, unit is px, default is 4
    borderRadius: 4,
    // tooltip border width, unit is px, default is 0 (no border)
    borderWidth: 1,
    // Tooltip inside padding, default is 5 for all direction
    // Array is allowed to set up, right, bottom, left, same with css
    // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
    padding: null,
    // Extra css text
    extraCssText: '',
    // axis indicator, trigger by axis
    axisPointer: {
      // default is line
      // legal values: 'line' | 'shadow' | 'cross'
      type: 'line',
      // Valid when type is line, appoint tooltip line locate on which line. Optional
      // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
      // default is 'auto', chose the axis which type is category.
      // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
      axis: 'auto',
      animation: 'auto',
      animationDurationUpdate: 200,
      animationEasingUpdate: 'exponentialOut',
      crossStyle: {
        color: '#999',
        width: 1,
        type: 'dashed',
        // TODO formatter
        textStyle: {}
      } // lineStyle and shadowStyle should not be specified here,
      // otherwise it will always override those styles on option.axisPointer.

    },
    textStyle: {
      color: '#666',
      fontSize: 14
    }
  };
  return TooltipModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TooltipModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/tooltip/TooltipRichContent.js":
/*!**************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/tooltip/TooltipRichContent.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_graphic_Text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/graphic/Text */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _tooltipMarkup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tooltipMarkup */ "./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js");
/* harmony import */ var _util_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/log */ "./node_modules/echarts/lib/util/log.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var TooltipRichContent =
/** @class */
function () {
  function TooltipRichContent(api) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._enterable = true;
    this._zr = api.getZr();
    makeStyleCoord(this._styleCoord, this._zr, api.getWidth() / 2, api.getHeight() / 2);
  }
  /**
   * Update when tooltip is rendered
   */


  TooltipRichContent.prototype.update = function (tooltipModel) {
    var alwaysShowContent = tooltipModel.get('alwaysShowContent');
    alwaysShowContent && this._moveIfResized();
  };

  TooltipRichContent.prototype.show = function () {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }

    this.el.show();
    this._show = true;
  };
  /**
   * Set tooltip content
   */


  TooltipRichContent.prototype.setContent = function (content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {
    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject(content)) {
      (0,_util_log__WEBPACK_IMPORTED_MODULE_1__.throwError)( true ? 'Passing DOM nodes as content is not supported in richText tooltip!' : 0);
    }

    if (this.el) {
      this._zr.remove(this.el);
    }

    var textStyleModel = tooltipModel.getModel('textStyle');
    this.el = new zrender_lib_graphic_Text__WEBPACK_IMPORTED_MODULE_2__.default({
      style: {
        rich: markupStyleCreator.richTextStyles,
        text: content,
        lineHeight: 22,
        backgroundColor: tooltipModel.get('backgroundColor'),
        borderRadius: tooltipModel.get('borderRadius'),
        borderWidth: 1,
        borderColor: borderColor,
        shadowColor: tooltipModel.get('shadowColor'),
        shadowBlur: tooltipModel.get('shadowBlur'),
        shadowOffsetX: tooltipModel.get('shadowOffsetX'),
        shadowOffsetY: tooltipModel.get('shadowOffsetY'),
        textShadowColor: textStyleModel.get('textShadowColor'),
        textShadowBlur: textStyleModel.get('textShadowBlur') || 0,
        textShadowOffsetX: textStyleModel.get('textShadowOffsetX') || 0,
        textShadowOffsetY: textStyleModel.get('textShadowOffsetY') || 0,
        fill: tooltipModel.get(['textStyle', 'color']),
        padding: (0,_tooltipMarkup__WEBPACK_IMPORTED_MODULE_3__.getPaddingFromTooltipModel)(tooltipModel, 'richText'),
        verticalAlign: 'top',
        align: 'left'
      },
      z: tooltipModel.get('z')
    });

    this._zr.add(this.el);

    var self = this;
    this.el.on('mouseover', function () {
      // clear the timeout in hideLater and keep showing tooltip
      if (self._enterable) {
        clearTimeout(self._hideTimeout);
        self._show = true;
      }

      self._inContent = true;
    });
    this.el.on('mouseout', function () {
      if (self._enterable) {
        if (self._show) {
          self.hideLater(self._hideDelay);
        }
      }

      self._inContent = false;
    });
  };

  TooltipRichContent.prototype.setEnterable = function (enterable) {
    this._enterable = enterable;
  };

  TooltipRichContent.prototype.getSize = function () {
    var el = this.el;
    var bounding = this.el.getBoundingRect(); // bounding rect does not include shadow. For renderMode richText,
    // if overflow, it will be cut. So calculate them accurately.

    var shadowOuterSize = calcShadowOuterSize(el.style);
    return [bounding.width + shadowOuterSize.left + shadowOuterSize.right, bounding.height + shadowOuterSize.top + shadowOuterSize.bottom];
  };

  TooltipRichContent.prototype.moveTo = function (x, y) {
    var el = this.el;

    if (el) {
      var styleCoord = this._styleCoord;
      makeStyleCoord(styleCoord, this._zr, x, y);
      x = styleCoord[0];
      y = styleCoord[1];
      var style = el.style;
      var borderWidth = mathMaxWith0(style.borderWidth || 0);
      var shadowOuterSize = calcShadowOuterSize(style); // rich text x, y do not include border.

      el.x = x + borderWidth + shadowOuterSize.left;
      el.y = y + borderWidth + shadowOuterSize.top;
      el.markRedraw();
    }
  };
  /**
   * when `alwaysShowContent` is true,
   * move the tooltip after chart resized
   */


  TooltipRichContent.prototype._moveIfResized = function () {
    // The ratio of left to width
    var ratioX = this._styleCoord[2]; // The ratio of top to height

    var ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  };

  TooltipRichContent.prototype.hide = function () {
    if (this.el) {
      this.el.hide();
    }

    this._show = false;
  };

  TooltipRichContent.prototype.hideLater = function (time) {
    if (this._show && !(this._inContent && this._enterable)) {
      if (time) {
        this._hideDelay = time; // Set show false to avoid invoke hideLater multiple times

        this._show = false;
        this._hideTimeout = setTimeout(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.bind(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  };

  TooltipRichContent.prototype.isShow = function () {
    return this._show;
  };

  TooltipRichContent.prototype.getOuterSize = function () {
    var size = this.getSize();
    return {
      width: size[0],
      height: size[1]
    };
  };

  TooltipRichContent.prototype.dispose = function () {
    this._zr.remove(this.el);
  };

  return TooltipRichContent;
}();

function mathMaxWith0(val) {
  return Math.max(0, val);
}

function calcShadowOuterSize(style) {
  var shadowBlur = mathMaxWith0(style.shadowBlur || 0);
  var shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);
  var shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);
  return {
    left: mathMaxWith0(shadowBlur - shadowOffsetX),
    right: mathMaxWith0(shadowBlur + shadowOffsetX),
    top: mathMaxWith0(shadowBlur - shadowOffsetY),
    bottom: mathMaxWith0(shadowBlur + shadowOffsetY)
  };
}

function makeStyleCoord(out, zr, zrX, zrY) {
  out[0] = zrX;
  out[1] = zrY;
  out[2] = out[0] / zr.getWidth();
  out[3] = out[1] / zr.getHeight();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TooltipRichContent);

/***/ }),

/***/ "./node_modules/echarts/lib/component/tooltip/TooltipView.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/tooltip/TooltipView.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/env */ "./node_modules/zrender/lib/core/env.js");
/* harmony import */ var _TooltipHTMLContent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TooltipHTMLContent */ "./node_modules/echarts/lib/component/tooltip/TooltipHTMLContent.js");
/* harmony import */ var _TooltipRichContent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TooltipRichContent */ "./node_modules/echarts/lib/component/tooltip/TooltipRichContent.js");
/* harmony import */ var _util_format__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../util/format */ "./node_modules/echarts/lib/util/format.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _axisPointer_findPointFromSeries__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../axisPointer/findPointFromSeries */ "./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../model/Model */ "./node_modules/echarts/lib/model/Model.js");
/* harmony import */ var _axisPointer_globalListener__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../axisPointer/globalListener */ "./node_modules/echarts/lib/component/axisPointer/globalListener.js");
/* harmony import */ var _coord_axisHelper__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../coord/axisHelper */ "./node_modules/echarts/lib/coord/axisHelper.js");
/* harmony import */ var _axisPointer_viewHelper__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../axisPointer/viewHelper */ "./node_modules/echarts/lib/component/axisPointer/viewHelper.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");
/* harmony import */ var _util_time__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../util/time */ "./node_modules/echarts/lib/util/time.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./helper */ "./node_modules/echarts/lib/component/tooltip/helper.js");
/* harmony import */ var _model_mixin_dataFormat__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../model/mixin/dataFormat */ "./node_modules/echarts/lib/model/mixin/dataFormat.js");
/* harmony import */ var _tooltipMarkup__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tooltipMarkup */ "./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js");
/* harmony import */ var _util_event__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/event */ "./node_modules/echarts/lib/util/event.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */


/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
















 // import { isDimensionStacked } from '../../data/helper/dataStackHelper';






var bind = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.bind;
var each = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each;
var parsePercent = _util_number__WEBPACK_IMPORTED_MODULE_1__.parsePercent;
var proxyRect = new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
});

var TooltipView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(TooltipView, _super);

  function TooltipView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = TooltipView.type;
    return _this;
  }

  TooltipView.prototype.init = function (ecModel, api) {
    if (zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_4__.default.node) {
      return;
    }

    var tooltipModel = ecModel.getComponent('tooltip');
    var renderMode = tooltipModel.get('renderMode');
    this._renderMode = (0,_util_model__WEBPACK_IMPORTED_MODULE_5__.getTooltipRenderMode)(renderMode);
    this._tooltipContent = this._renderMode === 'richText' ? new _TooltipRichContent__WEBPACK_IMPORTED_MODULE_6__.default(api) : new _TooltipHTMLContent__WEBPACK_IMPORTED_MODULE_7__.default(api.getDom(), api, {
      appendToBody: tooltipModel.get('appendToBody', true)
    });
  };

  TooltipView.prototype.render = function (tooltipModel, ecModel, api) {
    if (zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_4__.default.node) {
      return;
    } // Reset


    this.group.removeAll();
    this._tooltipModel = tooltipModel;
    this._ecModel = ecModel;
    this._api = api;
    /**
     * @private
     * @type {boolean}
     */

    this._alwaysShowContent = tooltipModel.get('alwaysShowContent');
    var tooltipContent = this._tooltipContent;
    tooltipContent.update(tooltipModel);
    tooltipContent.setEnterable(tooltipModel.get('enterable'));

    this._initGlobalListener();

    this._keepShow();
  };

  TooltipView.prototype._initGlobalListener = function () {
    var tooltipModel = this._tooltipModel;
    var triggerOn = tooltipModel.get('triggerOn');
    _axisPointer_globalListener__WEBPACK_IMPORTED_MODULE_8__.register('itemTooltip', this._api, bind(function (currTrigger, e, dispatchAction) {
      // If 'none', it is not controlled by mouse totally.
      if (triggerOn !== 'none') {
        if (triggerOn.indexOf(currTrigger) >= 0) {
          this._tryShow(e, dispatchAction);
        } else if (currTrigger === 'leave') {
          this._hide(dispatchAction);
        }
      }
    }, this));
  };

  TooltipView.prototype._keepShow = function () {
    var tooltipModel = this._tooltipModel;
    var ecModel = this._ecModel;
    var api = this._api; // Try to keep the tooltip show when refreshing

    if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API,
    // self.manuallyShowTip({x, y}) might cause tooltip hide,
    // which is not expected.
    && tooltipModel.get('triggerOn') !== 'none') {
      var self_1 = this;
      clearTimeout(this._refreshUpdateTimeout);
      this._refreshUpdateTimeout = setTimeout(function () {
        // Show tip next tick after other charts are rendered
        // In case highlight action has wrong result
        // FIXME
        !api.isDisposed() && self_1.manuallyShowTip(tooltipModel, ecModel, api, {
          x: self_1._lastX,
          y: self_1._lastY,
          dataByCoordSys: self_1._lastDataByCoordSys
        });
      });
    }
  };
  /**
   * Show tip manually by
   * dispatchAction({
   *     type: 'showTip',
   *     x: 10,
   *     y: 10
   * });
   * Or
   * dispatchAction({
   *      type: 'showTip',
   *      seriesIndex: 0,
   *      dataIndex or dataIndexInside or name
   * });
   *
   *  TODO Batch
   */


  TooltipView.prototype.manuallyShowTip = function (tooltipModel, ecModel, api, payload) {
    if (payload.from === this.uid || zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_4__.default.node) {
      return;
    }

    var dispatchAction = makeDispatchAction(payload, api); // Reset ticket

    this._ticket = ''; // When triggered from axisPointer.

    var dataByCoordSys = payload.dataByCoordSys;

    if (payload.tooltip && payload.x != null && payload.y != null) {
      var el = proxyRect;
      el.x = payload.x;
      el.y = payload.y;
      el.update();
      el.tooltip = payload.tooltip; // Manually show tooltip while view is not using zrender elements.

      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        target: el
      }, dispatchAction);
    } else if (dataByCoordSys) {
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        dataByCoordSys: dataByCoordSys,
        tooltipOption: payload.tooltipOption
      }, dispatchAction);
    } else if (payload.seriesIndex != null) {
      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
        return;
      }

      var pointInfo = (0,_axisPointer_findPointFromSeries__WEBPACK_IMPORTED_MODULE_9__.default)(payload, ecModel);
      var cx = pointInfo.point[0];
      var cy = pointInfo.point[1];

      if (cx != null && cy != null) {
        this._tryShow({
          offsetX: cx,
          offsetY: cy,
          position: payload.position,
          target: pointInfo.el
        }, dispatchAction);
      }
    } else if (payload.x != null && payload.y != null) {
      // FIXME
      // should wrap dispatchAction like `axisPointer/globalListener` ?
      api.dispatchAction({
        type: 'updateAxisPointer',
        x: payload.x,
        y: payload.y
      });

      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        target: api.getZr().findHover(payload.x, payload.y).target
      }, dispatchAction);
    }
  };

  TooltipView.prototype.manuallyHideTip = function (tooltipModel, ecModel, api, payload) {
    var tooltipContent = this._tooltipContent;

    if (!this._alwaysShowContent && this._tooltipModel) {
      tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
    }

    this._lastX = this._lastY = this._lastDataByCoordSys = null;

    if (payload.from !== this.uid) {
      this._hide(makeDispatchAction(payload, api));
    }
  }; // Be compatible with previous design, that is, when tooltip.type is 'axis' and
  // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer
  // and tooltip.


  TooltipView.prototype._manuallyAxisShowTip = function (tooltipModel, ecModel, api, payload) {
    var seriesIndex = payload.seriesIndex;
    var dataIndex = payload.dataIndex; // @ts-ignore

    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;

    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
      return;
    }

    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);

    if (!seriesModel) {
      return;
    }

    var data = seriesModel.getData();
    var tooltipCascadedModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);

    if (tooltipCascadedModel.get('trigger') !== 'axis') {
      return;
    }

    api.dispatchAction({
      type: 'updateAxisPointer',
      seriesIndex: seriesIndex,
      dataIndex: dataIndex,
      position: payload.position
    });
    return true;
  };

  TooltipView.prototype._tryShow = function (e, dispatchAction) {
    var el = e.target;
    var tooltipModel = this._tooltipModel;

    if (!tooltipModel) {
      return;
    } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed


    this._lastX = e.offsetX;
    this._lastY = e.offsetY;
    var dataByCoordSys = e.dataByCoordSys;

    if (dataByCoordSys && dataByCoordSys.length) {
      this._showAxisTooltip(dataByCoordSys, e);
    } // Always show item tooltip if mouse is on the element with dataIndex
    else if (el && (0,_util_event__WEBPACK_IMPORTED_MODULE_10__.findEventDispatcher)(el, function (target) {
        return (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_11__.getECData)(target).dataIndex != null;
      }, true)) {
        this._lastDataByCoordSys = null;

        this._showSeriesItemTooltip(e, el, dispatchAction);
      } // Tooltip provided directly. Like legend.
      else if (el && el.tooltip) {
          this._lastDataByCoordSys = null;

          this._showComponentItemTooltip(e, el, dispatchAction);
        } else {
          this._lastDataByCoordSys = null;

          this._hide(dispatchAction);
        }
  };

  TooltipView.prototype._showOrMove = function (tooltipModel, cb) {
    // showDelay is used in this case: tooltip.enterable is set
    // as true. User intent to move mouse into tooltip and click
    // something. `showDelay` makes it easier to enter the content
    // but tooltip do not move immediately.
    var delay = tooltipModel.get('showDelay');
    cb = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.bind(cb, this);
    clearTimeout(this._showTimout);
    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
  };

  TooltipView.prototype._showAxisTooltip = function (dataByCoordSys, e) {
    var ecModel = this._ecModel;
    var globalTooltipModel = this._tooltipModel;
    var point = [e.offsetX, e.offsetY];
    var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);
    var renderMode = this._renderMode;
    var cbParamsList = [];
    var articleMarkup = (0,_tooltipMarkup__WEBPACK_IMPORTED_MODULE_12__.createTooltipMarkup)('section', {
      blocks: [],
      noHeader: true
    }); // Only for legacy: `Serise['formatTooltip']` returns a string.

    var markupTextArrLegacy = [];
    var markupStyleCreator = new _tooltipMarkup__WEBPACK_IMPORTED_MODULE_12__.TooltipMarkupStyleCreator();
    each(dataByCoordSys, function (itemCoordSys) {
      each(itemCoordSys.dataByAxis, function (axisItem) {
        var axisModel = ecModel.getComponent(axisItem.axisDim + 'Axis', axisItem.axisIndex);
        var axisValue = axisItem.value;

        if (!axisModel || axisValue == null) {
          return;
        }

        var axisValueLabel = _axisPointer_viewHelper__WEBPACK_IMPORTED_MODULE_13__.getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);
        var axisSectionMarkup = (0,_tooltipMarkup__WEBPACK_IMPORTED_MODULE_12__.createTooltipMarkup)('section', {
          header: axisValueLabel,
          noHeader: !zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.trim(axisValueLabel),
          sortBlocks: true,
          blocks: []
        });
        articleMarkup.blocks.push(axisSectionMarkup);
        zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(axisItem.seriesDataIndices, function (idxItem) {
          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
          var dataIndex = idxItem.dataIndexInside;
          var cbParams = series.getDataParams(dataIndex);
          cbParams.axisDim = axisItem.axisDim;
          cbParams.axisIndex = axisItem.axisIndex;
          cbParams.axisType = axisItem.axisType;
          cbParams.axisId = axisItem.axisId;
          cbParams.axisValue = _coord_axisHelper__WEBPACK_IMPORTED_MODULE_14__.getAxisRawValue(axisModel.axis, {
            value: axisValue
          });
          cbParams.axisValueLabel = axisValueLabel; // Pre-create marker style for makers. Users can assemble richText
          // text in `formatter` callback and use those markers style.

          cbParams.marker = markupStyleCreator.makeTooltipMarker('item', _util_format__WEBPACK_IMPORTED_MODULE_15__.convertToColorString(cbParams.color), renderMode);
          var seriesTooltipResult = (0,_model_mixin_dataFormat__WEBPACK_IMPORTED_MODULE_16__.normalizeTooltipFormatResult)(series.formatTooltip(dataIndex, true, null));

          if (seriesTooltipResult.markupFragment) {
            axisSectionMarkup.blocks.push(seriesTooltipResult.markupFragment);
          }

          if (seriesTooltipResult.markupText) {
            markupTextArrLegacy.push(seriesTooltipResult.markupText);
          }

          cbParamsList.push(cbParams);
        });
      });
    }); // In most cases, the second axis is displays upper on the first one.
    // So we reverse it to look better.

    articleMarkup.blocks.reverse();
    markupTextArrLegacy.reverse();
    var positionExpr = e.position;
    var orderMode = singleTooltipModel.get('order');
    var builtMarkupText = (0,_tooltipMarkup__WEBPACK_IMPORTED_MODULE_12__.buildTooltipMarkup)(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get('useUTC'), singleTooltipModel.get('textStyle'));
    builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);
    var blockBreak = renderMode === 'richText' ? '\n\n' : '<br/>';
    var allMarkupText = markupTextArrLegacy.join(blockBreak);

    this._showOrMove(singleTooltipModel, function () {
      if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {
        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList);
      } else {
        this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + '', point[0], point[1], positionExpr, null, markupStyleCreator);
      }
    }); // Do not trigger events here, because this branch only be entered
    // from dispatchAction.

  };

  TooltipView.prototype._showSeriesItemTooltip = function (e, el, dispatchAction) {
    var dispatcher = (0,_util_event__WEBPACK_IMPORTED_MODULE_10__.findEventDispatcher)(el, function (target) {
      return (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_11__.getECData)(target).dataIndex != null;
    }, true);
    var ecModel = this._ecModel;
    var ecData = (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_11__.getECData)(dispatcher); // Use dataModel in element if possible
    // Used when mouseover on a element like markPoint or edge
    // In which case, the data is not main data in series.

    var seriesIndex = ecData.seriesIndex;
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link.

    var dataModel = ecData.dataModel || seriesModel;
    var dataIndex = ecData.dataIndex;
    var dataType = ecData.dataType;
    var data = dataModel.getData(dataType);
    var renderMode = this._renderMode;
    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);
    var tooltipTrigger = tooltipModel.get('trigger');

    if (tooltipTrigger != null && tooltipTrigger !== 'item') {
      return;
    }

    var params = dataModel.getDataParams(dataIndex, dataType);
    var markupStyleCreator = new _tooltipMarkup__WEBPACK_IMPORTED_MODULE_12__.TooltipMarkupStyleCreator(); // Pre-create marker style for makers. Users can assemble richText
    // text in `formatter` callback and use those markers style.

    params.marker = markupStyleCreator.makeTooltipMarker('item', _util_format__WEBPACK_IMPORTED_MODULE_15__.convertToColorString(params.color), renderMode);
    var seriesTooltipResult = (0,_model_mixin_dataFormat__WEBPACK_IMPORTED_MODULE_16__.normalizeTooltipFormatResult)(dataModel.formatTooltip(dataIndex, false, dataType));
    var orderMode = tooltipModel.get('order');
    var markupText = seriesTooltipResult.markupFragment ? (0,_tooltipMarkup__WEBPACK_IMPORTED_MODULE_12__.buildTooltipMarkup)(seriesTooltipResult.markupFragment, markupStyleCreator, renderMode, orderMode, ecModel.get('useUTC'), tooltipModel.get('textStyle')) : seriesTooltipResult.markupText;
    var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;

    this._showOrMove(tooltipModel, function () {
      this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target, markupStyleCreator);
    }); // FIXME
    // duplicated showtip if manuallyShowTip is called from dispatchAction.


    dispatchAction({
      type: 'showTip',
      dataIndexInside: dataIndex,
      dataIndex: data.getRawIndex(dataIndex),
      seriesIndex: seriesIndex,
      from: this.uid
    });
  };

  TooltipView.prototype._showComponentItemTooltip = function (e, el, dispatchAction) {
    var tooltipOpt = el.tooltip;

    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isString(tooltipOpt)) {
      var content = tooltipOpt;
      tooltipOpt = {
        content: content,
        // Fixed formatter
        formatter: content
      };
    }

    var subTooltipModel = new _model_Model__WEBPACK_IMPORTED_MODULE_17__.default(tooltipOpt, this._tooltipModel, this._ecModel);
    var defaultHtml = subTooltipModel.get('content');
    var asyncTicket = Math.random() + ''; // PENDING: this case do not support richText style yet.

    var markupStyleCreator = new _tooltipMarkup__WEBPACK_IMPORTED_MODULE_12__.TooltipMarkupStyleCreator(); // Do not check whether `trigger` is 'none' here, because `trigger`
    // only works on coordinate system. In fact, we have not found case
    // that requires setting `trigger` nothing on component yet.

    this._showOrMove(subTooltipModel, function () {
      this._showTooltipContent( // Use formatterParams from element defined in component
      subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el, markupStyleCreator);
    }); // If not dispatch showTip, tip may be hide triggered by axis.


    dispatchAction({
      type: 'showTip',
      from: this.uid
    });
  };

  TooltipView.prototype._showTooltipContent = function ( // Use Model<TooltipOption> insteadof TooltipModel because this model may be from series or other options.
  // Instead of top level tooltip.
  tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markupStyleCreator) {
    // Reset ticket
    this._ticket = '';

    if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {
      return;
    }

    var tooltipContent = this._tooltipContent;
    var formatter = tooltipModel.get('formatter');
    positionExpr = positionExpr || tooltipModel.get('position');
    var html = defaultHtml;

    var nearPoint = this._getNearestPoint([x, y], params, tooltipModel.get('trigger'), tooltipModel.get('borderColor'));

    if (formatter && zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isString(formatter)) {
      var useUTC = tooltipModel.ecModel.get('useUTC');
      var params0 = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(params) ? params[0] : params;
      var isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf('time') >= 0;
      html = formatter;

      if (isTimeAxis) {
        html = (0,_util_time__WEBPACK_IMPORTED_MODULE_18__.format)(params0.axisValue, html, useUTC);
      }

      html = _util_format__WEBPACK_IMPORTED_MODULE_15__.formatTpl(html, params, true);
    } else if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isFunction(formatter)) {
      var callback = bind(function (cbTicket, html) {
        if (cbTicket === this._ticket) {
          tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPoint.color, positionExpr);

          this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
        }
      }, this);
      this._ticket = asyncTicket;
      html = formatter(params, asyncTicket, callback);
    }

    tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPoint.color, positionExpr);
    tooltipContent.show(tooltipModel, nearPoint.color);

    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
  };

  TooltipView.prototype._getNearestPoint = function (point, tooltipDataParams, trigger, borderColor) {
    if (trigger === 'axis' || zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(tooltipDataParams)) {
      return {
        color: borderColor || (this._renderMode === 'html' ? '#fff' : 'none')
      };
    }

    if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(tooltipDataParams)) {
      return {
        color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor
      };
    }
  };

  TooltipView.prototype._updatePosition = function (tooltipModel, positionExpr, x, // Mouse x
  y, // Mouse y
  content, params, el) {
    var viewWidth = this._api.getWidth();

    var viewHeight = this._api.getHeight();

    positionExpr = positionExpr || tooltipModel.get('position');
    var contentSize = content.getSize();
    var align = tooltipModel.get('align');
    var vAlign = tooltipModel.get('verticalAlign');
    var rect = el && el.getBoundingRect().clone();
    el && rect.applyTransform(el.transform);

    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isFunction(positionExpr)) {
      // Callback of position can be an array or a string specify the position
      positionExpr = positionExpr([x, y], params, content.el, rect, {
        viewSize: [viewWidth, viewHeight],
        contentSize: contentSize.slice()
      });
    }

    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(positionExpr)) {
      x = parsePercent(positionExpr[0], viewWidth);
      y = parsePercent(positionExpr[1], viewHeight);
    } else if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject(positionExpr)) {
      var boxLayoutPosition = positionExpr;
      boxLayoutPosition.width = contentSize[0];
      boxLayoutPosition.height = contentSize[1];
      var layoutRect = _util_layout__WEBPACK_IMPORTED_MODULE_19__.getLayoutRect(boxLayoutPosition, {
        width: viewWidth,
        height: viewHeight
      });
      x = layoutRect.x;
      y = layoutRect.y;
      align = null; // When positionExpr is left/top/right/bottom,
      // align and verticalAlign will not work.

      vAlign = null;
    } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element
    else if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isString(positionExpr) && el) {
        var pos = calcTooltipPosition(positionExpr, rect, contentSize);
        x = pos[0];
        y = pos[1];
      } else {
        var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
        x = pos[0];
        y = pos[1];
      }

    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);
    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);

    if ((0,_helper__WEBPACK_IMPORTED_MODULE_20__.shouldTooltipConfine)(tooltipModel)) {
      var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);
      x = pos[0];
      y = pos[1];
    }

    content.moveTo(x, y);
  }; // FIXME
  // Should we remove this but leave this to user?


  TooltipView.prototype._updateContentNotChangedOnAxis = function (dataByCoordSys) {
    var lastCoordSys = this._lastDataByCoordSys;
    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
    contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {
      var lastDataByAxis = lastItemCoordSys.dataByAxis || [];
      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
      contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;
      contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {
        var thisItem = thisDataByAxis[indexAxis] || {};
        var lastIndices = lastItem.seriesDataIndices || [];
        var newIndices = thisItem.seriesDataIndices || [];
        contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
        contentNotChanged && each(lastIndices, function (lastIdxItem, j) {
          var newIdxItem = newIndices[j];
          contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
        });
      });
    });
    this._lastDataByCoordSys = dataByCoordSys;
    return !!contentNotChanged;
  };

  TooltipView.prototype._hide = function (dispatchAction) {
    // Do not directly hideLater here, because this behavior may be prevented
    // in dispatchAction when showTip is dispatched.
    // FIXME
    // duplicated hideTip if manuallyHideTip is called from dispatchAction.
    this._lastDataByCoordSys = null;
    dispatchAction({
      type: 'hideTip',
      from: this.uid
    });
  };

  TooltipView.prototype.dispose = function (ecModel, api) {
    if (zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_4__.default.node) {
      return;
    }

    this._tooltipContent.dispose();

    _axisPointer_globalListener__WEBPACK_IMPORTED_MODULE_8__.unregister('itemTooltip', api);
  };

  TooltipView.type = 'tooltip';
  return TooltipView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_21__.default);
/**
 * From top to bottom. (the last one should be globalTooltipModel);
 */


function buildTooltipModel(modelCascade) {
  // Last is always tooltip model.
  var resultModel = modelCascade.pop();

  while (modelCascade.length) {
    var tooltipOpt = modelCascade.pop();

    if (tooltipOpt) {
      if (tooltipOpt instanceof _model_Model__WEBPACK_IMPORTED_MODULE_17__.default) {
        tooltipOpt = tooltipOpt.get('tooltip', true);
      } // In each data item tooltip can be simply write:
      // {
      //  value: 10,
      //  tooltip: 'Something you need to know'
      // }


      if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isString(tooltipOpt)) {
        tooltipOpt = {
          formatter: tooltipOpt
        };
      }

      resultModel = new _model_Model__WEBPACK_IMPORTED_MODULE_17__.default(tooltipOpt, resultModel, resultModel.ecModel);
    }
  }

  return resultModel;
}

function makeDispatchAction(payload, api) {
  return payload.dispatchAction || zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.bind(api.dispatchAction, api);
}

function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {
  var size = content.getOuterSize();
  var width = size.width;
  var height = size.height;

  if (gapH != null) {
    // Add extra 2 pixels for this case:
    // At present the "values" in defaut tooltip are using CSS `float: right`.
    // When the right edge of the tooltip box is on the right side of the
    // viewport, the `float` layout might push the "values" to the second line.
    if (x + width + gapH + 2 > viewWidth) {
      x -= width + gapH;
    } else {
      x += gapH;
    }
  }

  if (gapV != null) {
    if (y + height + gapV > viewHeight) {
      y -= height + gapV;
    } else {
      y += gapV;
    }
  }

  return [x, y];
}

function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {
  var size = content.getOuterSize();
  var width = size.width;
  var height = size.height;
  x = Math.min(x + width, viewWidth) - width;
  y = Math.min(y + height, viewHeight) - height;
  x = Math.max(x, 0);
  y = Math.max(y, 0);
  return [x, y];
}

function calcTooltipPosition(position, rect, contentSize) {
  var domWidth = contentSize[0];
  var domHeight = contentSize[1];
  var gap = 10;
  var offset = 5;
  var x = 0;
  var y = 0;
  var rectWidth = rect.width;
  var rectHeight = rect.height;

  switch (position) {
    case 'inside':
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;

    case 'top':
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y - domHeight - gap;
      break;

    case 'bottom':
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight + gap;
      break;

    case 'left':
      x = rect.x - domWidth - gap - offset;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;

    case 'right':
      x = rect.x + rectWidth + gap + offset;
      y = rect.y + rectHeight / 2 - domHeight / 2;
  }

  return [x, y];
}

function isCenterAlign(align) {
  return align === 'center' || align === 'middle';
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TooltipView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/tooltip/helper.js":
/*!**************************************************************!*\
  !*** ./node_modules/echarts/lib/component/tooltip/helper.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shouldTooltipConfine": () => (/* binding */ shouldTooltipConfine)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function shouldTooltipConfine(tooltipModel) {
  var confineOption = tooltipModel.get('confine');
  return confineOption != null ? !!confineOption // In richText mode, the outside part can not be visible.
  : tooltipModel.get('renderMode') === 'richText';
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/tooltip/install.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/component/tooltip/install.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _axisPointer_install__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../axisPointer/install */ "./node_modules/echarts/lib/component/axisPointer/install.js");
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extension */ "./node_modules/echarts/lib/extension.js");
/* harmony import */ var _TooltipModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TooltipModel */ "./node_modules/echarts/lib/component/tooltip/TooltipModel.js");
/* harmony import */ var _TooltipView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TooltipView */ "./node_modules/echarts/lib/component/tooltip/TooltipView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




function install(registers) {
  (0,_extension__WEBPACK_IMPORTED_MODULE_0__.use)(_axisPointer_install__WEBPACK_IMPORTED_MODULE_1__.install);
  registers.registerComponentModel(_TooltipModel__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerComponentView(_TooltipView__WEBPACK_IMPORTED_MODULE_3__.default);
  /**
   * @action
   * @property {string} type
   * @property {number} seriesIndex
   * @property {number} dataIndex
   * @property {number} [x]
   * @property {number} [y]
   */

  registers.registerAction({
    type: 'showTip',
    event: 'showTip',
    update: 'tooltip:manuallyShowTip'
  }, // noop
  function () {});
  registers.registerAction({
    type: 'hideTip',
    event: 'hideTip',
    update: 'tooltip:manuallyHideTip'
  }, // noop
  function () {});
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/transform/filterTransform.js":
/*!*************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/transform/filterTransform.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "filterTransform": () => (/* binding */ filterTransform)
/* harmony export */ });
/* harmony import */ var _util_conditionalExpression__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/conditionalExpression */ "./node_modules/echarts/lib/util/conditionalExpression.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/log */ "./node_modules/echarts/lib/util/log.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var filterTransform = {
  type: 'echarts:filter',
  // PEDING: enhance to filter by index rather than create new data
  transform: function (params) {
    // [Caveat] Fail-Fast:
    // Do not return the whole dataset unless user config indicate it explicitly.
    // For example, if no condition specified by mistake, return an empty result
    // is better than return the entire raw soruce for user to find the mistake.
    var upstream = params.upstream;
    var rawItem;
    var condition = (0,_util_conditionalExpression__WEBPACK_IMPORTED_MODULE_0__.parseConditionalExpression)(params.config, {
      valueGetterAttrMap: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.createHashMap)({
        dimension: true
      }),
      prepareGetValue: function (exprOption) {
        var errMsg = '';
        var dimLoose = exprOption.dimension;

        if (!(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(exprOption, 'dimension')) {
          if (true) {
            errMsg = (0,_util_log__WEBPACK_IMPORTED_MODULE_2__.makePrintable)('Relation condition must has prop "dimension" specified.', 'Illegal condition:', exprOption);
          }

          (0,_util_log__WEBPACK_IMPORTED_MODULE_2__.throwError)(errMsg);
        }

        var dimInfo = upstream.getDimensionInfo(dimLoose);

        if (!dimInfo) {
          if (true) {
            errMsg = (0,_util_log__WEBPACK_IMPORTED_MODULE_2__.makePrintable)('Can not find dimension info via: ' + dimLoose + '.\n', 'Existing dimensions: ', upstream.cloneAllDimensionInfo(), '.\n', 'Illegal condition:', exprOption, '.\n');
          }

          (0,_util_log__WEBPACK_IMPORTED_MODULE_2__.throwError)(errMsg);
        }

        return {
          dimIdx: dimInfo.index
        };
      },
      getValue: function (param) {
        return upstream.retrieveValueFromItem(rawItem, param.dimIdx);
      }
    });
    var resultData = [];

    for (var i = 0, len = upstream.count(); i < len; i++) {
      rawItem = upstream.getRawDataItem(i);

      if (condition.evaluate()) {
        resultData.push(rawItem);
      }
    }

    return {
      data: resultData
    };
  }
};

/***/ }),

/***/ "./node_modules/echarts/lib/component/transform/install.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/transform/install.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _filterTransform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filterTransform */ "./node_modules/echarts/lib/component/transform/filterTransform.js");
/* harmony import */ var _sortTransform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sortTransform */ "./node_modules/echarts/lib/component/transform/sortTransform.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function install(registers) {
  registers.registerTransform(_filterTransform__WEBPACK_IMPORTED_MODULE_0__.filterTransform);
  registers.registerTransform(_sortTransform__WEBPACK_IMPORTED_MODULE_1__.sortTransform);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/transform/sortTransform.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/transform/sortTransform.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sortTransform": () => (/* binding */ sortTransform)
/* harmony export */ });
/* harmony import */ var _util_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/types */ "./node_modules/echarts/lib/util/types.js");
/* harmony import */ var _util_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/log */ "./node_modules/echarts/lib/util/log.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _data_helper_dataValueHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/helper/dataValueHelper */ "./node_modules/echarts/lib/data/helper/dataValueHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var sampleLog = '';

if (true) {
  sampleLog = ['Valid config is like:', '{ dimension: "age", order: "asc" }', 'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'].join(' ');
}

var sortTransform = {
  type: 'echarts:sort',
  transform: function (params) {
    var upstream = params.upstream;
    var config = params.config;
    var errMsg = ''; // Normalize
    // const orderExprList: OrderExpression[] = isArray(config[0])
    //     ? config as OrderExpression[]
    //     : [config as OrderExpression];

    var orderExprList = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.normalizeToArray)(config);

    if (!orderExprList.length) {
      if (true) {
        errMsg = 'Empty `config` in sort transform.';
      }

      (0,_util_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
    }

    var orderDefList = [];
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(orderExprList, function (orderExpr) {
      var dimLoose = orderExpr.dimension;
      var order = orderExpr.order;
      var parserName = orderExpr.parser;
      var incomparable = orderExpr.incomparable;

      if (dimLoose == null) {
        if (true) {
          errMsg = 'Sort transform config must has "dimension" specified.' + sampleLog;
        }

        (0,_util_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
      }

      if (order !== 'asc' && order !== 'desc') {
        if (true) {
          errMsg = 'Sort transform config must has "order" specified.' + sampleLog;
        }

        (0,_util_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
      }

      if (incomparable && incomparable !== 'min' && incomparable !== 'max') {
        var errMsg_1 = '';

        if (true) {
          errMsg_1 = 'incomparable must be "min" or "max" rather than "' + incomparable + '".';
        }

        (0,_util_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg_1);
      }

      if (order !== 'asc' && order !== 'desc') {
        var errMsg_2 = '';

        if (true) {
          errMsg_2 = 'order must be "asc" or "desc" rather than "' + order + '".';
        }

        (0,_util_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg_2);
      }

      var dimInfo = upstream.getDimensionInfo(dimLoose);

      if (!dimInfo) {
        if (true) {
          errMsg = (0,_util_log__WEBPACK_IMPORTED_MODULE_1__.makePrintable)('Can not find dimension info via: ' + dimLoose + '.\n', 'Existing dimensions: ', upstream.cloneAllDimensionInfo(), '.\n', 'Illegal config:', orderExpr, '.\n');
        }

        (0,_util_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
      }

      var parser = parserName ? (0,_data_helper_dataValueHelper__WEBPACK_IMPORTED_MODULE_3__.getRawValueParser)(parserName) : null;

      if (parserName && !parser) {
        if (true) {
          errMsg = (0,_util_log__WEBPACK_IMPORTED_MODULE_1__.makePrintable)('Invalid parser name ' + parserName + '.\n', 'Illegal config:', orderExpr, '.\n');
        }

        (0,_util_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
      }

      orderDefList.push({
        dimIdx: dimInfo.index,
        parser: parser,
        comparator: new _data_helper_dataValueHelper__WEBPACK_IMPORTED_MODULE_3__.SortOrderComparator(order, incomparable)
      });
    }); // TODO: support it?

    var sourceFormat = upstream.sourceFormat;

    if (sourceFormat !== _util_types__WEBPACK_IMPORTED_MODULE_4__.SOURCE_FORMAT_ARRAY_ROWS && sourceFormat !== _util_types__WEBPACK_IMPORTED_MODULE_4__.SOURCE_FORMAT_OBJECT_ROWS) {
      if (true) {
        errMsg = 'sourceFormat "' + sourceFormat + '" is not supported yet';
      }

      (0,_util_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
    } // Other upstream format are all array.


    var resultData = [];

    for (var i = 0, len = upstream.count(); i < len; i++) {
      resultData.push(upstream.getRawDataItem(i));
    }

    resultData.sort(function (item0, item1) {
      for (var i = 0; i < orderDefList.length; i++) {
        var orderDef = orderDefList[i];
        var val0 = upstream.retrieveValueFromItem(item0, orderDef.dimIdx);
        var val1 = upstream.retrieveValueFromItem(item1, orderDef.dimIdx);

        if (orderDef.parser) {
          val0 = orderDef.parser(val0);
          val1 = orderDef.parser(val1);
        }

        var result = orderDef.comparator.evaluate(val0, val1);

        if (result !== 0) {
          return result;
        }
      }

      return 0;
    });
    return {
      data: resultData
    };
  }
};

/***/ }),

/***/ "./node_modules/echarts/lib/component/visualMap/ContinuousModel.js":
/*!*************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/visualMap/ContinuousModel.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _VisualMapModel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VisualMapModel */ "./node_modules/echarts/lib/component/visualMap/VisualMapModel.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _util_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/component */ "./node_modules/echarts/lib/util/component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




 // Constant

var DEFAULT_BAR_BOUND = [20, 140];

var ContinuousModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ContinuousModel, _super);

  function ContinuousModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ContinuousModel.type;
    return _this;
  }
  /**
   * @override
   */


  ContinuousModel.prototype.optionUpdated = function (newOption, isInit) {
    _super.prototype.optionUpdated.apply(this, arguments);

    this.resetExtent();
    this.resetVisual(function (mappingOption) {
      mappingOption.mappingMethod = 'linear';
      mappingOption.dataExtent = this.getExtent();
    });

    this._resetRange();
  };
  /**
   * @protected
   * @override
   */


  ContinuousModel.prototype.resetItemSize = function () {
    _super.prototype.resetItemSize.apply(this, arguments);

    var itemSize = this.itemSize;
    (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
    (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
  };
  /**
   * @private
   */


  ContinuousModel.prototype._resetRange = function () {
    var dataExtent = this.getExtent();
    var range = this.option.range;

    if (!range || range.auto) {
      // `range` should always be array (so we dont use other
      // value like 'auto') for user-friend. (consider getOption).
      dataExtent.auto = 1;
      this.option.range = dataExtent;
    } else if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(range)) {
      if (range[0] > range[1]) {
        range.reverse();
      }

      range[0] = Math.max(range[0], dataExtent[0]);
      range[1] = Math.min(range[1], dataExtent[1]);
    }
  };
  /**
   * @protected
   * @override
   */


  ContinuousModel.prototype.completeVisualOption = function () {
    _super.prototype.completeVisualOption.apply(this, arguments);

    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(this.stateList, function (state) {
      var symbolSize = this.option.controller[state].symbolSize;

      if (symbolSize && symbolSize[0] !== symbolSize[1]) {
        symbolSize[0] = symbolSize[1] / 3; // For good looking.
      }
    }, this);
  };
  /**
   * @override
   */


  ContinuousModel.prototype.setSelected = function (selected) {
    this.option.range = selected.slice();

    this._resetRange();
  };
  /**
   * @public
   */


  ContinuousModel.prototype.getSelected = function () {
    var dataExtent = this.getExtent();
    var dataInterval = _util_number__WEBPACK_IMPORTED_MODULE_2__.asc((this.get('range') || []).slice()); // Clamp

    dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);
    dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);
    dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);
    dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);
    return dataInterval;
  };
  /**
   * @override
   */


  ContinuousModel.prototype.getValueState = function (value) {
    var range = this.option.range;
    var dataExtent = this.getExtent(); // When range[0] === dataExtent[0], any value larger than dataExtent[0] maps to 'inRange'.
    // range[1] is processed likewise.

    return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? 'inRange' : 'outOfRange';
  };

  ContinuousModel.prototype.findTargetDataIndices = function (range) {
    var result = [];
    this.eachTargetSeries(function (seriesModel) {
      var dataIndices = [];
      var data = seriesModel.getData();
      data.each(this.getDataDimension(data), function (value, dataIndex) {
        range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);
      }, this);
      result.push({
        seriesId: seriesModel.id,
        dataIndex: dataIndices
      });
    }, this);
    return result;
  };
  /**
   * @implement
   */


  ContinuousModel.prototype.getVisualMeta = function (getColorVisual) {
    var oVals = getColorStopValues(this, 'outOfRange', this.getExtent());
    var iVals = getColorStopValues(this, 'inRange', this.option.range.slice());
    var stops = [];

    function setStop(value, valueState) {
      stops.push({
        value: value,
        color: getColorVisual(value, valueState)
      });
    } // Format to: outOfRange -- inRange -- outOfRange.


    var iIdx = 0;
    var oIdx = 0;
    var iLen = iVals.length;
    var oLen = oVals.length;

    for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {
      // If oVal[oIdx] === iVals[iIdx], oVal[oIdx] should be ignored.
      if (oVals[oIdx] < iVals[iIdx]) {
        setStop(oVals[oIdx], 'outOfRange');
      }
    }

    for (var first = 1; iIdx < iLen; iIdx++, first = 0) {
      // If range is full, value beyond min, max will be clamped.
      // make a singularity
      first && stops.length && setStop(iVals[iIdx], 'outOfRange');
      setStop(iVals[iIdx], 'inRange');
    }

    for (var first = 1; oIdx < oLen; oIdx++) {
      if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {
        // make a singularity
        if (first) {
          stops.length && setStop(stops[stops.length - 1].value, 'outOfRange');
          first = 0;
        }

        setStop(oVals[oIdx], 'outOfRange');
      }
    }

    var stopsLen = stops.length;
    return {
      stops: stops,
      outerColors: [stopsLen ? stops[0].color : 'transparent', stopsLen ? stops[stopsLen - 1].color : 'transparent']
    };
  };

  ContinuousModel.type = 'visualMap.continuous';
  ContinuousModel.defaultOption = (0,_util_component__WEBPACK_IMPORTED_MODULE_3__.inheritDefaultOption)(_VisualMapModel__WEBPACK_IMPORTED_MODULE_4__.default.defaultOption, {
    align: 'auto',
    calculable: false,
    hoverLink: true,
    realtime: true,
    handleIcon: 'path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z',
    handleSize: '120%',
    handleStyle: {
      borderColor: '#fff',
      borderWidth: 1
    },
    indicatorIcon: 'circle',
    indicatorSize: '50%',
    indicatorStyle: {
      borderColor: '#fff',
      borderWidth: 2,
      shadowBlur: 2,
      shadowOffsetX: 1,
      shadowOffsetY: 1,
      shadowColor: 'rgba(0,0,0,0.2)'
    } // emphasis: {
    //     handleStyle: {
    //         shadowBlur: 3,
    //         shadowOffsetX: 1,
    //         shadowOffsetY: 1,
    //         shadowColor: 'rgba(0,0,0,0.2)'
    //     }
    // }

  });
  return ContinuousModel;
}(_VisualMapModel__WEBPACK_IMPORTED_MODULE_4__.default);

function getColorStopValues(visualMapModel, valueState, dataExtent) {
  if (dataExtent[0] === dataExtent[1]) {
    return dataExtent.slice();
  } // When using colorHue mapping, it is not linear color any more.
  // Moreover, canvas gradient seems not to be accurate linear.
  // FIXME
  // Should be arbitrary value 100? or based on pixel size?


  var count = 200;
  var step = (dataExtent[1] - dataExtent[0]) / count;
  var value = dataExtent[0];
  var stopValues = [];

  for (var i = 0; i <= count && value < dataExtent[1]; i++) {
    stopValues.push(value);
    value += step;
  }

  stopValues.push(dataExtent[1]);
  return stopValues;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ContinuousModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/visualMap/ContinuousView.js":
/*!************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/visualMap/ContinuousView.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_graphic_LinearGradient__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! zrender/lib/graphic/LinearGradient */ "./node_modules/zrender/lib/graphic/LinearGradient.js");
/* harmony import */ var zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! zrender/lib/core/event */ "./node_modules/zrender/lib/core/event.js");
/* harmony import */ var _VisualMapView__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./VisualMapView */ "./node_modules/echarts/lib/component/visualMap/VisualMapView.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polygon.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _helper_sliderMove__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../helper/sliderMove */ "./node_modules/echarts/lib/component/helper/sliderMove.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helper */ "./node_modules/echarts/lib/component/visualMap/helper.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var zrender_lib_contain_text__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! zrender/lib/contain/text */ "./node_modules/zrender/lib/contain/text.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _util_symbol__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/symbol */ "./node_modules/echarts/lib/util/symbol.js");
/* harmony import */ var zrender_lib_graphic_Image__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! zrender/lib/graphic/Image */ "./node_modules/zrender/lib/graphic/Image.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/















var linearMap = _util_number__WEBPACK_IMPORTED_MODULE_0__.linearMap;
var each = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each;
var mathMin = Math.min;
var mathMax = Math.max; // Arbitrary value

var HOVER_LINK_SIZE = 12;
var HOVER_LINK_OUT = 6; // Notice:
// Any "interval" should be by the order of [low, high].
// "handle0" (handleIndex === 0) maps to
// low data value: this._dataInterval[0] and has low coord.
// "handle1" (handleIndex === 1) maps to
// high data value: this._dataInterval[1] and has high coord.
// The logic of transform is implemented in this._createBarGroup.

var ContinuousView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ContinuousView, _super);

  function ContinuousView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ContinuousView.type;
    _this._shapes = {};
    _this._dataInterval = [];
    _this._handleEnds = [];
    _this._hoverLinkDataIndices = [];
    return _this;
  }

  ContinuousView.prototype.doRender = function (visualMapModel, ecModel, api, payload) {
    this._api = api;

    if (!payload || payload.type !== 'selectDataRange' || payload.from !== this.uid) {
      this._buildView();
    }
  };

  ContinuousView.prototype._buildView = function () {
    this.group.removeAll();
    var visualMapModel = this.visualMapModel;
    var thisGroup = this.group;
    this._orient = visualMapModel.get('orient');
    this._useHandle = visualMapModel.get('calculable');

    this._resetInterval();

    this._renderBar(thisGroup);

    var dataRangeText = visualMapModel.get('text');

    this._renderEndsText(thisGroup, dataRangeText, 0);

    this._renderEndsText(thisGroup, dataRangeText, 1); // Do this for background size calculation.


    this._updateView(true); // After updating view, inner shapes is built completely,
    // and then background can be rendered.


    this.renderBackground(thisGroup); // Real update view

    this._updateView();

    this._enableHoverLinkToSeries();

    this._enableHoverLinkFromSeries();

    this.positionGroup(thisGroup);
  };

  ContinuousView.prototype._renderEndsText = function (group, dataRangeText, endsIndex) {
    if (!dataRangeText) {
      return;
    } // Compatible with ec2, text[0] map to high value, text[1] map low value.


    var text = dataRangeText[1 - endsIndex];
    text = text != null ? text + '' : '';
    var visualMapModel = this.visualMapModel;
    var textGap = visualMapModel.get('textGap');
    var itemSize = visualMapModel.itemSize;
    var barGroup = this._shapes.mainGroup;

    var position = this._applyTransform([itemSize[0] / 2, endsIndex === 0 ? -textGap : itemSize[1] + textGap], barGroup);

    var align = this._applyTransform(endsIndex === 0 ? 'bottom' : 'top', barGroup);

    var orient = this._orient;
    var textStyleModel = this.visualMapModel.textStyleModel;
    this.group.add(new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default({
      style: {
        x: position[0],
        y: position[1],
        verticalAlign: orient === 'horizontal' ? 'middle' : align,
        align: orient === 'horizontal' ? align : 'center',
        text: text,
        font: textStyleModel.getFont(),
        fill: textStyleModel.getTextColor()
      }
    }));
  };

  ContinuousView.prototype._renderBar = function (targetGroup) {
    var visualMapModel = this.visualMapModel;
    var shapes = this._shapes;
    var itemSize = visualMapModel.itemSize;
    var orient = this._orient;
    var useHandle = this._useHandle;
    var itemAlign = _helper__WEBPACK_IMPORTED_MODULE_4__.getItemAlign(visualMapModel, this.api, itemSize);

    var mainGroup = shapes.mainGroup = this._createBarGroup(itemAlign);

    var gradientBarGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default();
    mainGroup.add(gradientBarGroup); // Bar

    gradientBarGroup.add(shapes.outOfRange = createPolygon());
    gradientBarGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor(this._orient) : null, zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind(this._dragHandle, this, 'all', false), zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind(this._dragHandle, this, 'all', true))); // A border radius clip.

    gradientBarGroup.setClipPath(new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default({
      shape: {
        x: 0,
        y: 0,
        width: itemSize[0],
        height: itemSize[1],
        r: 3
      }
    }));
    var textRect = visualMapModel.textStyleModel.getTextRect('国');
    var textSize = mathMax(textRect.width, textRect.height); // Handle

    if (useHandle) {
      shapes.handleThumbs = [];
      shapes.handleLabels = [];
      shapes.handleLabelPoints = [];

      this._createHandle(visualMapModel, mainGroup, 0, itemSize, textSize, orient);

      this._createHandle(visualMapModel, mainGroup, 1, itemSize, textSize, orient);
    }

    this._createIndicator(visualMapModel, mainGroup, itemSize, textSize, orient);

    targetGroup.add(mainGroup);
  };

  ContinuousView.prototype._createHandle = function (visualMapModel, mainGroup, handleIndex, itemSize, textSize, orient) {
    var onDrift = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind(this._dragHandle, this, handleIndex, false);
    var onDragEnd = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind(this._dragHandle, this, handleIndex, true);
    var handleSize = (0,zrender_lib_contain_text__WEBPACK_IMPORTED_MODULE_7__.parsePercent)(visualMapModel.get('handleSize'), itemSize[0]);
    var handleThumb = (0,_util_symbol__WEBPACK_IMPORTED_MODULE_8__.createSymbol)(visualMapModel.get('handleIcon'), -handleSize / 2, -handleSize / 2, handleSize, handleSize, null, true);
    var cursor = getCursor(this._orient);
    handleThumb.attr({
      cursor: cursor,
      draggable: true,
      drift: onDrift,
      ondragend: onDragEnd,
      onmousemove: function (e) {
        zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_9__.stop(e.event);
      }
    });
    handleThumb.x = itemSize[0] / 2;
    handleThumb.useStyle(visualMapModel.getModel('handleStyle').getItemStyle());
    handleThumb.setStyle({
      strokeNoScale: true,
      strokeFirst: true
    });
    handleThumb.style.lineWidth *= 2;
    handleThumb.ensureState('emphasis').style = visualMapModel.getModel(['emphasis', 'handleStyle']).getItemStyle();
    (0,_util_states__WEBPACK_IMPORTED_MODULE_10__.setAsHighDownDispatcher)(handleThumb, true);
    mainGroup.add(handleThumb); // Text is always horizontal layout but should not be effected by
    // transform (orient/inverse). So label is built separately but not
    // use zrender/graphic/helper/RectText, and is located based on view
    // group (according to handleLabelPoint) but not barGroup.

    var textStyleModel = this.visualMapModel.textStyleModel;
    var handleLabel = new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default({
      cursor: cursor,
      draggable: true,
      drift: onDrift,
      onmousemove: function (e) {
        // Fot mobile devicem, prevent screen slider on the button.
        zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_9__.stop(e.event);
      },
      ondragend: onDragEnd,
      style: {
        x: 0,
        y: 0,
        text: '',
        font: textStyleModel.getFont(),
        fill: textStyleModel.getTextColor()
      }
    });
    handleLabel.ensureState('blur').style = {
      opacity: 0.1
    };
    handleLabel.stateTransition = {
      duration: 200
    };
    this.group.add(handleLabel);
    var handleLabelPoint = [handleSize, 0];
    var shapes = this._shapes;
    shapes.handleThumbs[handleIndex] = handleThumb;
    shapes.handleLabelPoints[handleIndex] = handleLabelPoint;
    shapes.handleLabels[handleIndex] = handleLabel;
  };

  ContinuousView.prototype._createIndicator = function (visualMapModel, mainGroup, itemSize, textSize, orient) {
    var scale = (0,zrender_lib_contain_text__WEBPACK_IMPORTED_MODULE_7__.parsePercent)(visualMapModel.get('indicatorSize'), itemSize[0]);
    var indicator = (0,_util_symbol__WEBPACK_IMPORTED_MODULE_8__.createSymbol)(visualMapModel.get('indicatorIcon'), -scale / 2, -scale / 2, scale, scale, null, true);
    indicator.attr({
      cursor: 'move',
      invisible: true,
      silent: true,
      x: itemSize[0] / 2
    });
    var indicatorStyle = visualMapModel.getModel('indicatorStyle').getItemStyle();

    if (indicator instanceof zrender_lib_graphic_Image__WEBPACK_IMPORTED_MODULE_11__.default) {
      var pathStyle = indicator.style;
      indicator.useStyle(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend({
        // TODO other properties like x, y ?
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, indicatorStyle));
    } else {
      indicator.useStyle(indicatorStyle);
    }

    mainGroup.add(indicator);
    var textStyleModel = this.visualMapModel.textStyleModel;
    var indicatorLabel = new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default({
      silent: true,
      invisible: true,
      style: {
        x: 0,
        y: 0,
        text: '',
        font: textStyleModel.getFont(),
        fill: textStyleModel.getTextColor()
      }
    });
    this.group.add(indicatorLabel);
    var indicatorLabelPoint = [(orient === 'horizontal' ? textSize / 2 : HOVER_LINK_OUT) + itemSize[0] / 2, 0];
    var shapes = this._shapes;
    shapes.indicator = indicator;
    shapes.indicatorLabel = indicatorLabel;
    shapes.indicatorLabelPoint = indicatorLabelPoint;
    this._firstShowIndicator = true;
  };

  ContinuousView.prototype._dragHandle = function (handleIndex, isEnd, // dx is event from ondragend if isEnd is true. It's not used
  dx, dy) {
    if (!this._useHandle) {
      return;
    }

    this._dragging = !isEnd;

    if (!isEnd) {
      // Transform dx, dy to bar coordination.
      var vertex = this._applyTransform([dx, dy], this._shapes.mainGroup, true);

      this._updateInterval(handleIndex, vertex[1]);

      this._hideIndicator(); // Considering realtime, update view should be executed
      // before dispatch action.


      this._updateView();
    } // dragEnd do not dispatch action when realtime.


    if (isEnd === !this.visualMapModel.get('realtime')) {
      // jshint ignore:line
      this.api.dispatchAction({
        type: 'selectDataRange',
        from: this.uid,
        visualMapId: this.visualMapModel.id,
        selected: this._dataInterval.slice()
      });
    }

    if (isEnd) {
      !this._hovering && this._clearHoverLinkToSeries();
    } else if (useHoverLinkOnHandle(this.visualMapModel)) {
      this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);
    }
  };

  ContinuousView.prototype._resetInterval = function () {
    var visualMapModel = this.visualMapModel;
    var dataInterval = this._dataInterval = visualMapModel.getSelected();
    var dataExtent = visualMapModel.getExtent();
    var sizeExtent = [0, visualMapModel.itemSize[1]];
    this._handleEnds = [linearMap(dataInterval[0], dataExtent, sizeExtent, true), linearMap(dataInterval[1], dataExtent, sizeExtent, true)];
  };
  /**
   * @private
   * @param {(number|string)} handleIndex 0 or 1 or 'all'
   * @param {number} dx
   * @param {number} dy
   */


  ContinuousView.prototype._updateInterval = function (handleIndex, delta) {
    delta = delta || 0;
    var visualMapModel = this.visualMapModel;
    var handleEnds = this._handleEnds;
    var sizeExtent = [0, visualMapModel.itemSize[1]];
    (0,_helper_sliderMove__WEBPACK_IMPORTED_MODULE_12__.default)(delta, handleEnds, sizeExtent, handleIndex, // cross is forbiden
    0);
    var dataExtent = visualMapModel.getExtent(); // Update data interval.

    this._dataInterval = [linearMap(handleEnds[0], sizeExtent, dataExtent, true), linearMap(handleEnds[1], sizeExtent, dataExtent, true)];
  };

  ContinuousView.prototype._updateView = function (forSketch) {
    var visualMapModel = this.visualMapModel;
    var dataExtent = visualMapModel.getExtent();
    var shapes = this._shapes;
    var outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];
    var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;

    var visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, 'inRange');

    var visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, 'outOfRange');

    shapes.inRange.setStyle({
      fill: visualInRange.barColor // opacity: visualInRange.opacity

    }).setShape('points', visualInRange.barPoints);
    shapes.outOfRange.setStyle({
      fill: visualOutOfRange.barColor // opacity: visualOutOfRange.opacity

    }).setShape('points', visualOutOfRange.barPoints);

    this._updateHandle(inRangeHandleEnds, visualInRange);
  };

  ContinuousView.prototype._createBarVisual = function (dataInterval, dataExtent, handleEnds, forceState) {
    var opts = {
      forceState: forceState,
      convertOpacityToAlpha: true
    };

    var colorStops = this._makeColorGradient(dataInterval, opts);

    var symbolSizes = [this.getControllerVisual(dataInterval[0], 'symbolSize', opts), this.getControllerVisual(dataInterval[1], 'symbolSize', opts)];

    var barPoints = this._createBarPoints(handleEnds, symbolSizes);

    return {
      barColor: new zrender_lib_graphic_LinearGradient__WEBPACK_IMPORTED_MODULE_13__.default(0, 0, 0, 1, colorStops),
      barPoints: barPoints,
      handlesColor: [colorStops[0].color, colorStops[colorStops.length - 1].color]
    };
  };

  ContinuousView.prototype._makeColorGradient = function (dataInterval, opts) {
    // Considering colorHue, which is not linear, so we have to sample
    // to calculate gradient color stops, but not only caculate head
    // and tail.
    var sampleNumber = 100; // Arbitrary value.

    var colorStops = [];
    var step = (dataInterval[1] - dataInterval[0]) / sampleNumber;
    colorStops.push({
      color: this.getControllerVisual(dataInterval[0], 'color', opts),
      offset: 0
    });

    for (var i = 1; i < sampleNumber; i++) {
      var currValue = dataInterval[0] + step * i;

      if (currValue > dataInterval[1]) {
        break;
      }

      colorStops.push({
        color: this.getControllerVisual(currValue, 'color', opts),
        offset: i / sampleNumber
      });
    }

    colorStops.push({
      color: this.getControllerVisual(dataInterval[1], 'color', opts),
      offset: 1
    });
    return colorStops;
  };

  ContinuousView.prototype._createBarPoints = function (handleEnds, symbolSizes) {
    var itemSize = this.visualMapModel.itemSize;
    return [[itemSize[0] - symbolSizes[0], handleEnds[0]], [itemSize[0], handleEnds[0]], [itemSize[0], handleEnds[1]], [itemSize[0] - symbolSizes[1], handleEnds[1]]];
  };

  ContinuousView.prototype._createBarGroup = function (itemAlign) {
    var orient = this._orient;
    var inverse = this.visualMapModel.get('inverse');
    return new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default(orient === 'horizontal' && !inverse ? {
      scaleX: itemAlign === 'bottom' ? 1 : -1,
      rotation: Math.PI / 2
    } : orient === 'horizontal' && inverse ? {
      scaleX: itemAlign === 'bottom' ? -1 : 1,
      rotation: -Math.PI / 2
    } : orient === 'vertical' && !inverse ? {
      scaleX: itemAlign === 'left' ? 1 : -1,
      scaleY: -1
    } : {
      scaleX: itemAlign === 'left' ? 1 : -1
    });
  };

  ContinuousView.prototype._updateHandle = function (handleEnds, visualInRange) {
    if (!this._useHandle) {
      return;
    }

    var shapes = this._shapes;
    var visualMapModel = this.visualMapModel;
    var handleThumbs = shapes.handleThumbs;
    var handleLabels = shapes.handleLabels;
    var itemSize = visualMapModel.itemSize;
    var dataExtent = visualMapModel.getExtent();
    each([0, 1], function (handleIndex) {
      var handleThumb = handleThumbs[handleIndex];
      handleThumb.setStyle('fill', visualInRange.handlesColor[handleIndex]);
      handleThumb.y = handleEnds[handleIndex];
      var val = linearMap(handleEnds[handleIndex], [0, itemSize[1]], dataExtent, true);
      var symbolSize = this.getControllerVisual(val, 'symbolSize');
      handleThumb.scaleX = handleThumb.scaleY = symbolSize / itemSize[0];
      handleThumb.x = itemSize[0] - symbolSize / 2; // Update handle label position.

      var textPoint = _util_graphic__WEBPACK_IMPORTED_MODULE_14__.applyTransform(shapes.handleLabelPoints[handleIndex], _util_graphic__WEBPACK_IMPORTED_MODULE_14__.getTransform(handleThumb, this.group));
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
        verticalAlign: 'middle',
        align: this._orient === 'vertical' ? this._applyTransform('left', shapes.mainGroup) : 'center'
      });
    }, this);
  };

  ContinuousView.prototype._showIndicator = function (cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
    var visualMapModel = this.visualMapModel;
    var dataExtent = visualMapModel.getExtent();
    var itemSize = visualMapModel.itemSize;
    var sizeExtent = [0, itemSize[1]];
    var shapes = this._shapes;
    var indicator = shapes.indicator;

    if (!indicator) {
      return;
    }

    indicator.attr('invisible', false);
    var opts = {
      convertOpacityToAlpha: true
    };
    var color = this.getControllerVisual(cursorValue, 'color', opts);
    var symbolSize = this.getControllerVisual(cursorValue, 'symbolSize');
    var y = linearMap(cursorValue, dataExtent, sizeExtent, true);
    var x = itemSize[0] - symbolSize / 2;
    var oldIndicatorPos = {
      x: indicator.x,
      y: indicator.y
    }; // Update handle label position.

    indicator.y = y;
    indicator.x = x;
    var textPoint = _util_graphic__WEBPACK_IMPORTED_MODULE_14__.applyTransform(shapes.indicatorLabelPoint, _util_graphic__WEBPACK_IMPORTED_MODULE_14__.getTransform(indicator, this.group));
    var indicatorLabel = shapes.indicatorLabel;
    indicatorLabel.attr('invisible', false);

    var align = this._applyTransform('left', shapes.mainGroup);

    var orient = this._orient;
    var isHorizontal = orient === 'horizontal';
    indicatorLabel.setStyle({
      text: (rangeSymbol ? rangeSymbol : '') + visualMapModel.formatValueText(textValue),
      verticalAlign: isHorizontal ? align : 'middle',
      align: isHorizontal ? 'center' : align
    });
    var indicatorNewProps = {
      x: x,
      y: y,
      style: {
        fill: color
      }
    };
    var labelNewProps = {
      style: {
        x: textPoint[0],
        y: textPoint[1]
      }
    };

    if (visualMapModel.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
      var animationCfg = {
        duration: 100,
        easing: 'cubicInOut',
        additive: true
      };
      indicator.x = oldIndicatorPos.x;
      indicator.y = oldIndicatorPos.y;
      indicator.animateTo(indicatorNewProps, animationCfg);
      indicatorLabel.animateTo(labelNewProps, animationCfg);
    } else {
      indicator.attr(indicatorNewProps);
      indicatorLabel.attr(labelNewProps);
    }

    this._firstShowIndicator = false;
    var handleLabels = this._shapes.handleLabels;

    if (handleLabels) {
      for (var i = 0; i < handleLabels.length; i++) {
        // Fade out handle labels.
        // NOTE: Must use api enter/leave on emphasis/blur/select state. Or the global states manager will change it.
        this._api.enterBlur(handleLabels[i]);
      }
    }
  };

  ContinuousView.prototype._enableHoverLinkToSeries = function () {
    var self = this;

    this._shapes.mainGroup.on('mousemove', function (e) {
      self._hovering = true;

      if (!self._dragging) {
        var itemSize = self.visualMapModel.itemSize;

        var pos = self._applyTransform([e.offsetX, e.offsetY], self._shapes.mainGroup, true, true); // For hover link show when hover handle, which might be
        // below or upper than sizeExtent.


        pos[1] = mathMin(mathMax(0, pos[1]), itemSize[1]);

        self._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);
      }
    }).on('mouseout', function () {
      // When mouse is out of handle, hoverLink still need
      // to be displayed when realtime is set as false.
      self._hovering = false;
      !self._dragging && self._clearHoverLinkToSeries();
    });
  };

  ContinuousView.prototype._enableHoverLinkFromSeries = function () {
    var zr = this.api.getZr();

    if (this.visualMapModel.option.hoverLink) {
      zr.on('mouseover', this._hoverLinkFromSeriesMouseOver, this);
      zr.on('mouseout', this._hideIndicator, this);
    } else {
      this._clearHoverLinkFromSeries();
    }
  };

  ContinuousView.prototype._doHoverLinkToSeries = function (cursorPos, hoverOnBar) {
    var visualMapModel = this.visualMapModel;
    var itemSize = visualMapModel.itemSize;

    if (!visualMapModel.option.hoverLink) {
      return;
    }

    var sizeExtent = [0, itemSize[1]];
    var dataExtent = visualMapModel.getExtent(); // For hover link show when hover handle, which might be below or upper than sizeExtent.

    cursorPos = mathMin(mathMax(sizeExtent[0], cursorPos), sizeExtent[1]);
    var halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);
    var hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];
    var cursorValue = linearMap(cursorPos, sizeExtent, dataExtent, true);
    var valueRange = [linearMap(hoverRange[0], sizeExtent, dataExtent, true), linearMap(hoverRange[1], sizeExtent, dataExtent, true)]; // Consider data range is out of visualMap range, see test/visualMap-continuous.html,
    // where china and india has very large population.

    hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);
    hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity); // Do not show indicator when mouse is over handle,
    // otherwise labels overlap, especially when dragging.

    if (hoverOnBar) {
      if (valueRange[0] === -Infinity) {
        this._showIndicator(cursorValue, valueRange[1], '< ', halfHoverLinkSize);
      } else if (valueRange[1] === Infinity) {
        this._showIndicator(cursorValue, valueRange[0], '> ', halfHoverLinkSize);
      } else {
        this._showIndicator(cursorValue, cursorValue, '≈ ', halfHoverLinkSize);
      }
    } // When realtime is set as false, handles, which are in barGroup,
    // also trigger hoverLink, which help user to realize where they
    // focus on when dragging. (see test/heatmap-large.html)
    // When realtime is set as true, highlight will not show when hover
    // handle, because the label on handle, which displays a exact value
    // but not range, might mislead users.


    var oldBatch = this._hoverLinkDataIndices;
    var newBatch = [];

    if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {
      newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);
    }

    var resultBatches = _util_model__WEBPACK_IMPORTED_MODULE_15__.compressBatches(oldBatch, newBatch);

    this._dispatchHighDown('downplay', _helper__WEBPACK_IMPORTED_MODULE_4__.makeHighDownBatch(resultBatches[0], visualMapModel));

    this._dispatchHighDown('highlight', _helper__WEBPACK_IMPORTED_MODULE_4__.makeHighDownBatch(resultBatches[1], visualMapModel));
  };

  ContinuousView.prototype._hoverLinkFromSeriesMouseOver = function (e) {
    var el = e.target;
    var visualMapModel = this.visualMapModel;

    if (!el || (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_16__.getECData)(el).dataIndex == null) {
      return;
    }

    var ecData = (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_16__.getECData)(el);
    var dataModel = this.ecModel.getSeriesByIndex(ecData.seriesIndex);

    if (!visualMapModel.isTargetSeries(dataModel)) {
      return;
    }

    var data = dataModel.getData(ecData.dataType);
    var value = data.get(visualMapModel.getDataDimension(data), ecData.dataIndex);

    if (!isNaN(value)) {
      this._showIndicator(value, value);
    }
  };

  ContinuousView.prototype._hideIndicator = function () {
    var shapes = this._shapes;
    shapes.indicator && shapes.indicator.attr('invisible', true);
    shapes.indicatorLabel && shapes.indicatorLabel.attr('invisible', true);
    var handleLabels = this._shapes.handleLabels;

    if (handleLabels) {
      for (var i = 0; i < handleLabels.length; i++) {
        // Fade out handle labels.
        // NOTE: Must use api enter/leave on emphasis/blur/select state. Or the global states manager will change it.
        this._api.leaveBlur(handleLabels[i]);
      }
    }
  };

  ContinuousView.prototype._clearHoverLinkToSeries = function () {
    this._hideIndicator();

    var indices = this._hoverLinkDataIndices;

    this._dispatchHighDown('downplay', _helper__WEBPACK_IMPORTED_MODULE_4__.makeHighDownBatch(indices, this.visualMapModel));

    indices.length = 0;
  };

  ContinuousView.prototype._clearHoverLinkFromSeries = function () {
    this._hideIndicator();

    var zr = this.api.getZr();
    zr.off('mouseover', this._hoverLinkFromSeriesMouseOver);
    zr.off('mouseout', this._hideIndicator);
  };

  ContinuousView.prototype._applyTransform = function (vertex, element, inverse, global) {
    var transform = _util_graphic__WEBPACK_IMPORTED_MODULE_14__.getTransform(element, global ? null : this.group);
    return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(vertex) ? _util_graphic__WEBPACK_IMPORTED_MODULE_14__.applyTransform(vertex, transform, inverse) : _util_graphic__WEBPACK_IMPORTED_MODULE_14__.transformDirection(vertex, transform, inverse);
  }; // TODO: TYPE more specified payload types.


  ContinuousView.prototype._dispatchHighDown = function (type, batch) {
    batch && batch.length && this.api.dispatchAction({
      type: type,
      batch: batch
    });
  };
  /**
   * @override
   */


  ContinuousView.prototype.dispose = function () {
    this._clearHoverLinkFromSeries();

    this._clearHoverLinkToSeries();
  };
  /**
   * @override
   */


  ContinuousView.prototype.remove = function () {
    this._clearHoverLinkFromSeries();

    this._clearHoverLinkToSeries();
  };

  ContinuousView.type = 'visualMap.continuous';
  return ContinuousView;
}(_VisualMapView__WEBPACK_IMPORTED_MODULE_17__.default);

function createPolygon(points, cursor, onDrift, onDragEnd) {
  return new _util_graphic__WEBPACK_IMPORTED_MODULE_18__.default({
    shape: {
      points: points
    },
    draggable: !!onDrift,
    cursor: cursor,
    drift: onDrift,
    onmousemove: function (e) {
      // Fot mobile devicem, prevent screen slider on the button.
      zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_9__.stop(e.event);
    },
    ondragend: onDragEnd
  });
}

function getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {
  var halfHoverLinkSize = HOVER_LINK_SIZE / 2;
  var hoverLinkDataSize = visualMapModel.get('hoverLinkDataSize');

  if (hoverLinkDataSize) {
    halfHoverLinkSize = linearMap(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;
  }

  return halfHoverLinkSize;
}

function useHoverLinkOnHandle(visualMapModel) {
  var hoverLinkOnHandle = visualMapModel.get('hoverLinkOnHandle');
  return !!(hoverLinkOnHandle == null ? visualMapModel.get('realtime') : hoverLinkOnHandle);
}

function getCursor(orient) {
  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ContinuousView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/visualMap/PiecewiseModel.js":
/*!************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/visualMap/PiecewiseModel.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _VisualMapModel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./VisualMapModel */ "./node_modules/echarts/lib/component/visualMap/VisualMapModel.js");
/* harmony import */ var _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../visual/VisualMapping */ "./node_modules/echarts/lib/visual/VisualMapping.js");
/* harmony import */ var _visual_visualDefault__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../visual/visualDefault */ "./node_modules/echarts/lib/visual/visualDefault.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _util_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/component */ "./node_modules/echarts/lib/util/component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








var PiecewiseModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(PiecewiseModel, _super);

  function PiecewiseModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = PiecewiseModel.type;
    /**
     * The order is always [low, ..., high].
     * [{text: string, interval: Array.<number>}, ...]
     */

    _this._pieceList = [];
    return _this;
  }

  PiecewiseModel.prototype.optionUpdated = function (newOption, isInit) {
    _super.prototype.optionUpdated.apply(this, arguments);

    this.resetExtent();

    var mode = this._mode = this._determineMode();

    this._pieceList = [];

    resetMethods[this._mode].call(this, this._pieceList);

    this._resetSelected(newOption, isInit);

    var categories = this.option.categories;
    this.resetVisual(function (mappingOption, state) {
      if (mode === 'categories') {
        mappingOption.mappingMethod = 'category';
        mappingOption.categories = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone(categories);
      } else {
        mappingOption.dataExtent = this.getExtent();
        mappingOption.mappingMethod = 'piecewise';
        mappingOption.pieceList = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map(this._pieceList, function (piece) {
          piece = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone(piece);

          if (state !== 'inRange') {
            // FIXME
            // outOfRange do not support special visual in pieces.
            piece.visual = null;
          }

          return piece;
        });
      }
    });
  };
  /**
   * @protected
   * @override
   */


  PiecewiseModel.prototype.completeVisualOption = function () {
    // Consider this case:
    // visualMap: {
    //      pieces: [{symbol: 'circle', lt: 0}, {symbol: 'rect', gte: 0}]
    // }
    // where no inRange/outOfRange set but only pieces. So we should make
    // default inRange/outOfRange for this case, otherwise visuals that only
    // appear in `pieces` will not be taken into account in visual encoding.
    var option = this.option;
    var visualTypesInPieces = {};
    var visualTypes = _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_2__.default.listVisualTypes();
    var isCategory = this.isCategory();
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(option.pieces, function (piece) {
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(visualTypes, function (visualType) {
        if (piece.hasOwnProperty(visualType)) {
          visualTypesInPieces[visualType] = 1;
        }
      });
    });
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(visualTypesInPieces, function (v, visualType) {
      var exists = false;
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(this.stateList, function (state) {
        exists = exists || has(option, state, visualType) || has(option.target, state, visualType);
      }, this);
      !exists && zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(this.stateList, function (state) {
        (option[state] || (option[state] = {}))[visualType] = _visual_visualDefault__WEBPACK_IMPORTED_MODULE_3__.default.get(visualType, state === 'inRange' ? 'active' : 'inactive', isCategory);
      });
    }, this);

    function has(obj, state, visualType) {
      return obj && obj[state] && obj[state].hasOwnProperty(visualType);
    }

    _super.prototype.completeVisualOption.apply(this, arguments);
  };

  PiecewiseModel.prototype._resetSelected = function (newOption, isInit) {
    var thisOption = this.option;
    var pieceList = this._pieceList; // Selected do not merge but all override.

    var selected = (isInit ? thisOption : newOption).selected || {};
    thisOption.selected = selected; // Consider 'not specified' means true.

    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(pieceList, function (piece, index) {
      var key = this.getSelectedMapKey(piece);

      if (!selected.hasOwnProperty(key)) {
        selected[key] = true;
      }
    }, this);

    if (thisOption.selectedMode === 'single') {
      // Ensure there is only one selected.
      var hasSel_1 = false;
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(pieceList, function (piece, index) {
        var key = this.getSelectedMapKey(piece);

        if (selected[key]) {
          hasSel_1 ? selected[key] = false : hasSel_1 = true;
        }
      }, this);
    } // thisOption.selectedMode === 'multiple', default: all selected.

  };
  /**
   * @public
   */


  PiecewiseModel.prototype.getSelectedMapKey = function (piece) {
    return this._mode === 'categories' ? piece.value + '' : piece.index + '';
  };
  /**
   * @public
   */


  PiecewiseModel.prototype.getPieceList = function () {
    return this._pieceList;
  };
  /**
   * @return {string}
   */


  PiecewiseModel.prototype._determineMode = function () {
    var option = this.option;
    return option.pieces && option.pieces.length > 0 ? 'pieces' : this.option.categories ? 'categories' : 'splitNumber';
  };
  /**
   * @override
   */


  PiecewiseModel.prototype.setSelected = function (selected) {
    this.option.selected = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone(selected);
  };
  /**
   * @override
   */


  PiecewiseModel.prototype.getValueState = function (value) {
    var index = _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_2__.default.findPieceIndex(value, this._pieceList);
    return index != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? 'inRange' : 'outOfRange' : 'outOfRange';
  };
  /**
   * @public
   * @param pieceIndex piece index in visualMapModel.getPieceList()
   */


  PiecewiseModel.prototype.findTargetDataIndices = function (pieceIndex) {
    var result = [];
    var pieceList = this._pieceList;
    this.eachTargetSeries(function (seriesModel) {
      var dataIndices = [];
      var data = seriesModel.getData();
      data.each(this.getDataDimension(data), function (value, dataIndex) {
        // Should always base on model pieceList, because it is order sensitive.
        var pIdx = _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_2__.default.findPieceIndex(value, pieceList);
        pIdx === pieceIndex && dataIndices.push(dataIndex);
      }, this);
      result.push({
        seriesId: seriesModel.id,
        dataIndex: dataIndices
      });
    }, this);
    return result;
  };
  /**
   * @private
   * @param piece piece.value or piece.interval is required.
   * @return  Can be Infinity or -Infinity
   */


  PiecewiseModel.prototype.getRepresentValue = function (piece) {
    var representValue;

    if (this.isCategory()) {
      representValue = piece.value;
    } else {
      if (piece.value != null) {
        representValue = piece.value;
      } else {
        var pieceInterval = piece.interval || [];
        representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;
      }
    }

    return representValue;
  };

  PiecewiseModel.prototype.getVisualMeta = function (getColorVisual) {
    // Do not support category. (category axis is ordinal, numerical)
    if (this.isCategory()) {
      return;
    }

    var stops = [];
    var outerColors = ['', ''];
    var visualMapModel = this;

    function setStop(interval, valueState) {
      var representValue = visualMapModel.getRepresentValue({
        interval: interval
      }); // Not category

      if (!valueState) {
        valueState = visualMapModel.getValueState(representValue);
      }

      var color = getColorVisual(representValue, valueState);

      if (interval[0] === -Infinity) {
        outerColors[0] = color;
      } else if (interval[1] === Infinity) {
        outerColors[1] = color;
      } else {
        stops.push({
          value: interval[0],
          color: color
        }, {
          value: interval[1],
          color: color
        });
      }
    } // Suplement


    var pieceList = this._pieceList.slice();

    if (!pieceList.length) {
      pieceList.push({
        interval: [-Infinity, Infinity]
      });
    } else {
      var edge = pieceList[0].interval[0];
      edge !== -Infinity && pieceList.unshift({
        interval: [-Infinity, edge]
      });
      edge = pieceList[pieceList.length - 1].interval[1];
      edge !== Infinity && pieceList.push({
        interval: [edge, Infinity]
      });
    }

    var curr = -Infinity;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(pieceList, function (piece) {
      var interval = piece.interval;

      if (interval) {
        // Fulfill gap.
        interval[0] > curr && setStop([curr, interval[0]], 'outOfRange');
        setStop(interval.slice());
        curr = interval[1];
      }
    }, this);
    return {
      stops: stops,
      outerColors: outerColors
    };
  };

  PiecewiseModel.type = 'visualMap.piecewise';
  PiecewiseModel.defaultOption = (0,_util_component__WEBPACK_IMPORTED_MODULE_4__.inheritDefaultOption)(_VisualMapModel__WEBPACK_IMPORTED_MODULE_5__.default.defaultOption, {
    selected: null,
    minOpen: false,
    maxOpen: false,
    align: 'auto',
    itemWidth: 20,
    itemHeight: 14,
    itemSymbol: 'roundRect',
    pieces: null,
    categories: null,
    splitNumber: 5,
    selectedMode: 'multiple',
    itemGap: 10,
    hoverLink: true // Enable hover highlight.

  });
  return PiecewiseModel;
}(_VisualMapModel__WEBPACK_IMPORTED_MODULE_5__.default);

;
/**
 * Key is this._mode
 * @type {Object}
 * @this {module:echarts/component/viusalMap/PiecewiseMode}
 */

var resetMethods = {
  splitNumber: function (outPieceList) {
    var thisOption = this.option;
    var precision = Math.min(thisOption.precision, 20);
    var dataExtent = this.getExtent();
    var splitNumber = thisOption.splitNumber;
    splitNumber = Math.max(parseInt(splitNumber, 10), 1);
    thisOption.splitNumber = splitNumber;
    var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber; // Precision auto-adaption

    while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {
      precision++;
    }

    thisOption.precision = precision;
    splitStep = +splitStep.toFixed(precision);

    if (thisOption.minOpen) {
      outPieceList.push({
        interval: [-Infinity, dataExtent[0]],
        close: [0, 0]
      });
    }

    for (var index = 0, curr = dataExtent[0]; index < splitNumber; curr += splitStep, index++) {
      var max = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep;
      outPieceList.push({
        interval: [curr, max],
        close: [1, 1]
      });
    }

    if (thisOption.maxOpen) {
      outPieceList.push({
        interval: [dataExtent[1], Infinity],
        close: [0, 0]
      });
    }

    (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.reformIntervals)(outPieceList);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(outPieceList, function (piece, index) {
      piece.index = index;
      piece.text = this.formatValueText(piece.interval);
    }, this);
  },
  categories: function (outPieceList) {
    var thisOption = this.option;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(thisOption.categories, function (cate) {
      // FIXME category模式也使用pieceList，但在visualMapping中不是使用pieceList。
      // 是否改一致。
      outPieceList.push({
        text: this.formatValueText(cate, true),
        value: cate
      });
    }, this); // See "Order Rule".

    normalizeReverse(thisOption, outPieceList);
  },
  pieces: function (outPieceList) {
    var thisOption = this.option;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(thisOption.pieces, function (pieceListItem, index) {
      if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isObject(pieceListItem)) {
        pieceListItem = {
          value: pieceListItem
        };
      }

      var item = {
        text: '',
        index: index
      };

      if (pieceListItem.label != null) {
        item.text = pieceListItem.label;
      }

      if (pieceListItem.hasOwnProperty('value')) {
        var value = item.value = pieceListItem.value;
        item.interval = [value, value];
        item.close = [1, 1];
      } else {
        // `min` `max` is legacy option.
        // `lt` `gt` `lte` `gte` is recommanded.
        var interval = item.interval = [];
        var close_1 = item.close = [0, 0];
        var closeList = [1, 0, 1];
        var infinityList = [-Infinity, Infinity];
        var useMinMax = [];

        for (var lg = 0; lg < 2; lg++) {
          var names = [['gte', 'gt', 'min'], ['lte', 'lt', 'max']][lg];

          for (var i = 0; i < 3 && interval[lg] == null; i++) {
            interval[lg] = pieceListItem[names[i]];
            close_1[lg] = closeList[i];
            useMinMax[lg] = i === 2;
          }

          interval[lg] == null && (interval[lg] = infinityList[lg]);
        }

        useMinMax[0] && interval[1] === Infinity && (close_1[0] = 0);
        useMinMax[1] && interval[0] === -Infinity && (close_1[1] = 0);

        if (true) {
          if (interval[0] > interval[1]) {
            console.warn('Piece ' + index + 'is illegal: ' + interval + ' lower bound should not greater then uppper bound.');
          }
        }

        if (interval[0] === interval[1] && close_1[0] && close_1[1]) {
          // Consider: [{min: 5, max: 5, visual: {...}}, {min: 0, max: 5}],
          // we use value to lift the priority when min === max
          item.value = interval[0];
        }
      }

      item.visual = _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_2__.default.retrieveVisuals(pieceListItem);
      outPieceList.push(item);
    }, this); // See "Order Rule".

    normalizeReverse(thisOption, outPieceList); // Only pieces

    (0,_util_number__WEBPACK_IMPORTED_MODULE_6__.reformIntervals)(outPieceList);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(outPieceList, function (piece) {
      var close = piece.close;
      var edgeSymbols = [['<', '≤'][close[1]], ['>', '≥'][close[0]]];
      piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);
    }, this);
  }
};

function normalizeReverse(thisOption, pieceList) {
  var inverse = thisOption.inverse;

  if (thisOption.orient === 'vertical' ? !inverse : inverse) {
    pieceList.reverse();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PiecewiseModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/visualMap/PiecewiseView.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/visualMap/PiecewiseView.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _VisualMapView__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./VisualMapView */ "./node_modules/echarts/lib/component/visualMap/VisualMapView.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_symbol__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/symbol */ "./node_modules/echarts/lib/util/symbol.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helper */ "./node_modules/echarts/lib/component/visualMap/helper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








var PiecewiseVisualMapView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(PiecewiseVisualMapView, _super);

  function PiecewiseVisualMapView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = PiecewiseVisualMapView.type;
    return _this;
  }

  PiecewiseVisualMapView.prototype.doRender = function () {
    var thisGroup = this.group;
    thisGroup.removeAll();
    var visualMapModel = this.visualMapModel;
    var textGap = visualMapModel.get('textGap');
    var textStyleModel = visualMapModel.textStyleModel;
    var textFont = textStyleModel.getFont();
    var textFill = textStyleModel.getTextColor();

    var itemAlign = this._getItemAlign();

    var itemSize = visualMapModel.itemSize;

    var viewData = this._getViewData();

    var endsText = viewData.endsText;
    var showLabel = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.retrieve(visualMapModel.get('showLabel', true), !endsText);
    endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(viewData.viewPieceList, function (item) {
      var piece = item.piece;
      var itemGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default();
      itemGroup.onclick = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind(this._onItemClick, this, piece);

      this._enableHoverLink(itemGroup, item.indexInModelPieceList); // TODO Category


      var representValue = visualMapModel.getRepresentValue(piece);

      this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]]);

      if (showLabel) {
        var visualState = this.visualMapModel.getValueState(representValue);
        itemGroup.add(new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default({
          style: {
            x: itemAlign === 'right' ? -textGap : itemSize[0] + textGap,
            y: itemSize[1] / 2,
            text: piece.text,
            verticalAlign: 'middle',
            align: itemAlign,
            font: textFont,
            fill: textFill,
            opacity: visualState === 'outOfRange' ? 0.5 : 1
          }
        }));
      }

      thisGroup.add(itemGroup);
    }, this);
    endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign);
    _util_layout__WEBPACK_IMPORTED_MODULE_4__.box(visualMapModel.get('orient'), thisGroup, visualMapModel.get('itemGap'));
    this.renderBackground(thisGroup);
    this.positionGroup(thisGroup);
  };

  PiecewiseVisualMapView.prototype._enableHoverLink = function (itemGroup, pieceIndex) {
    var _this = this;

    itemGroup.on('mouseover', function () {
      return onHoverLink('highlight');
    }).on('mouseout', function () {
      return onHoverLink('downplay');
    });

    var onHoverLink = function (method) {
      var visualMapModel = _this.visualMapModel; // TODO: TYPE More detailed action types

      visualMapModel.option.hoverLink && _this.api.dispatchAction({
        type: method,
        batch: _helper__WEBPACK_IMPORTED_MODULE_5__.makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)
      });
    };
  };

  PiecewiseVisualMapView.prototype._getItemAlign = function () {
    var visualMapModel = this.visualMapModel;
    var modelOption = visualMapModel.option;

    if (modelOption.orient === 'vertical') {
      return _helper__WEBPACK_IMPORTED_MODULE_5__.getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
    } else {
      // horizontal, most case left unless specifying right.
      var align = modelOption.align;

      if (!align || align === 'auto') {
        align = 'left';
      }

      return align;
    }
  };

  PiecewiseVisualMapView.prototype._renderEndsText = function (group, text, itemSize, showLabel, itemAlign) {
    if (!text) {
      return;
    }

    var itemGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default();
    var textStyleModel = this.visualMapModel.textStyleModel;
    itemGroup.add(new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default({
      style: {
        x: showLabel ? itemAlign === 'right' ? itemSize[0] : 0 : itemSize[0] / 2,
        y: itemSize[1] / 2,
        verticalAlign: 'middle',
        align: showLabel ? itemAlign : 'center',
        text: text,
        font: textStyleModel.getFont(),
        fill: textStyleModel.getTextColor()
      }
    }));
    group.add(itemGroup);
  };
  /**
   * @private
   * @return {Object} {peiceList, endsText} The order is the same as screen pixel order.
   */


  PiecewiseVisualMapView.prototype._getViewData = function () {
    var visualMapModel = this.visualMapModel;
    var viewPieceList = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map(visualMapModel.getPieceList(), function (piece, index) {
      return {
        piece: piece,
        indexInModelPieceList: index
      };
    });
    var endsText = visualMapModel.get('text'); // Consider orient and inverse.

    var orient = visualMapModel.get('orient');
    var inverse = visualMapModel.get('inverse'); // Order of model pieceList is always [low, ..., high]

    if (orient === 'horizontal' ? inverse : !inverse) {
      viewPieceList.reverse();
    } // Origin order of endsText is [high, low]
    else if (endsText) {
        endsText = endsText.slice().reverse();
      }

    return {
      viewPieceList: viewPieceList,
      endsText: endsText
    };
  };

  PiecewiseVisualMapView.prototype._createItemSymbol = function (group, representValue, shapeParam) {
    group.add((0,_util_symbol__WEBPACK_IMPORTED_MODULE_6__.createSymbol)( // symbol will be string
    this.getControllerVisual(representValue, 'symbol'), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], // color will be string
    this.getControllerVisual(representValue, 'color')));
  };

  PiecewiseVisualMapView.prototype._onItemClick = function (piece) {
    var visualMapModel = this.visualMapModel;
    var option = visualMapModel.option;
    var selected = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone(option.selected);
    var newKey = visualMapModel.getSelectedMapKey(piece);

    if (option.selectedMode === 'single') {
      selected[newKey] = true;
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(selected, function (o, key) {
        selected[key] = key === newKey;
      });
    } else {
      selected[newKey] = !selected[newKey];
    }

    this.api.dispatchAction({
      type: 'selectDataRange',
      from: this.uid,
      visualMapId: this.visualMapModel.id,
      selected: selected
    });
  };

  PiecewiseVisualMapView.type = 'visualMap.piecewise';
  return PiecewiseVisualMapView;
}(_VisualMapView__WEBPACK_IMPORTED_MODULE_7__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PiecewiseVisualMapView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/visualMap/VisualMapModel.js":
/*!************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/visualMap/VisualMapModel.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/env */ "./node_modules/zrender/lib/core/env.js");
/* harmony import */ var _visual_visualDefault__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../visual/visualDefault */ "./node_modules/echarts/lib/visual/visualDefault.js");
/* harmony import */ var _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../visual/VisualMapping */ "./node_modules/echarts/lib/visual/VisualMapping.js");
/* harmony import */ var _visual_visualSolution__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../visual/visualSolution */ "./node_modules/echarts/lib/visual/visualSolution.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/









var mapVisual = _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_0__.default.mapVisual;
var eachVisual = _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_0__.default.eachVisual;
var isArray = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray;
var each = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each;
var asc = _util_number__WEBPACK_IMPORTED_MODULE_2__.asc;
var linearMap = _util_number__WEBPACK_IMPORTED_MODULE_2__.linearMap;

var VisualMapModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(VisualMapModel, _super);

  function VisualMapModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = VisualMapModel.type;
    _this.stateList = ['inRange', 'outOfRange'];
    _this.replacableOptionKeys = ['inRange', 'outOfRange', 'target', 'controller', 'color'];
    _this.layoutMode = {
      type: 'box',
      ignoreSize: true
    };
    /**
     * [lowerBound, upperBound]
     */

    _this.dataBound = [-Infinity, Infinity];
    _this.targetVisuals = {};
    _this.controllerVisuals = {};
    return _this;
  }

  VisualMapModel.prototype.init = function (option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
  };
  /**
   * @protected
   */


  VisualMapModel.prototype.optionUpdated = function (newOption, isInit) {
    var thisOption = this.option; // FIXME
    // necessary?
    // Disable realtime view update if canvas is not supported.

    if (!zrender_lib_core_env__WEBPACK_IMPORTED_MODULE_4__.default.canvasSupported) {
      thisOption.realtime = false;
    }

    !isInit && _visual_visualSolution__WEBPACK_IMPORTED_MODULE_5__.replaceVisualOption(thisOption, newOption, this.replacableOptionKeys);
    this.textStyleModel = this.getModel('textStyle');
    this.resetItemSize();
    this.completeVisualOption();
  };
  /**
   * @protected
   */


  VisualMapModel.prototype.resetVisual = function (supplementVisualOption) {
    var stateList = this.stateList;
    supplementVisualOption = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind(supplementVisualOption, this);
    this.controllerVisuals = _visual_visualSolution__WEBPACK_IMPORTED_MODULE_5__.createVisualMappings(this.option.controller, stateList, supplementVisualOption);
    this.targetVisuals = _visual_visualSolution__WEBPACK_IMPORTED_MODULE_5__.createVisualMappings(this.option.target, stateList, supplementVisualOption);
  };
  /**
   * @protected
   * @return {Array.<number>} An array of series indices.
   */


  VisualMapModel.prototype.getTargetSeriesIndices = function () {
    var optionSeriesIndex = this.option.seriesIndex;
    var seriesIndices = [];

    if (optionSeriesIndex == null || optionSeriesIndex === 'all') {
      this.ecModel.eachSeries(function (seriesModel, index) {
        seriesIndices.push(index);
      });
    } else {
      seriesIndices = _util_model__WEBPACK_IMPORTED_MODULE_6__.normalizeToArray(optionSeriesIndex);
    }

    return seriesIndices;
  };
  /**
   * @public
   */


  VisualMapModel.prototype.eachTargetSeries = function (callback, context) {
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(this.getTargetSeriesIndices(), function (seriesIndex) {
      var seriesModel = this.ecModel.getSeriesByIndex(seriesIndex);

      if (seriesModel) {
        callback.call(context, seriesModel);
      }
    }, this);
  };
  /**
   * @pubilc
   */


  VisualMapModel.prototype.isTargetSeries = function (seriesModel) {
    var is = false;
    this.eachTargetSeries(function (model) {
      model === seriesModel && (is = true);
    });
    return is;
  };
  /**
   * @example
   * this.formatValueText(someVal); // format single numeric value to text.
   * this.formatValueText(someVal, true); // format single category value to text.
   * this.formatValueText([min, max]); // format numeric min-max to text.
   * this.formatValueText([this.dataBound[0], max]); // using data lower bound.
   * this.formatValueText([min, this.dataBound[1]]); // using data upper bound.
   *
   * @param value Real value, or this.dataBound[0 or 1].
   * @param isCategory Only available when value is number.
   * @param edgeSymbols Open-close symbol when value is interval.
   * @protected
   */


  VisualMapModel.prototype.formatValueText = function (value, isCategory, edgeSymbols) {
    var option = this.option;
    var precision = option.precision;
    var dataBound = this.dataBound;
    var formatter = option.formatter;
    var isMinMax;
    edgeSymbols = edgeSymbols || ['<', '>'];

    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(value)) {
      value = value.slice();
      isMinMax = true;
    }

    var textValue = isCategory ? value // Value is string when isCategory
    : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value);

    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isString(formatter)) {
      return formatter.replace('{value}', isMinMax ? textValue[0] : textValue).replace('{value2}', isMinMax ? textValue[1] : textValue);
    } else if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isFunction(formatter)) {
      return isMinMax ? formatter(value[0], value[1]) : formatter(value);
    }

    if (isMinMax) {
      if (value[0] === dataBound[0]) {
        return edgeSymbols[0] + ' ' + textValue[1];
      } else if (value[1] === dataBound[1]) {
        return edgeSymbols[1] + ' ' + textValue[0];
      } else {
        return textValue[0] + ' - ' + textValue[1];
      }
    } else {
      // Format single value (includes category case).
      return textValue;
    }

    function toFixed(val) {
      return val === dataBound[0] ? 'min' : val === dataBound[1] ? 'max' : (+val).toFixed(Math.min(precision, 20));
    }
  };
  /**
   * @protected
   */


  VisualMapModel.prototype.resetExtent = function () {
    var thisOption = this.option; // Can not calculate data extent by data here.
    // Because series and data may be modified in processing stage.
    // So we do not support the feature "auto min/max".

    var extent = asc([thisOption.min, thisOption.max]);
    this._dataExtent = extent;
  };
  /**
   * Return  Concrete dimention. If return null/undefined, no dimension used.
   */


  VisualMapModel.prototype.getDataDimension = function (list) {
    var optDim = this.option.dimension;
    var listDimensions = list.dimensions;

    if (optDim == null && !listDimensions.length) {
      return;
    }

    if (optDim != null) {
      return list.getDimension(optDim);
    }

    var dimNames = list.dimensions;

    for (var i = dimNames.length - 1; i >= 0; i--) {
      var dimName = dimNames[i];
      var dimInfo = list.getDimensionInfo(dimName);

      if (!dimInfo.isCalculationCoord) {
        return dimName;
      }
    }
  };

  VisualMapModel.prototype.getExtent = function () {
    return this._dataExtent.slice();
  };

  VisualMapModel.prototype.completeVisualOption = function () {
    var ecModel = this.ecModel;
    var thisOption = this.option;
    var base = {
      inRange: thisOption.inRange,
      outOfRange: thisOption.outOfRange
    };
    var target = thisOption.target || (thisOption.target = {});
    var controller = thisOption.controller || (thisOption.controller = {});
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge(target, base); // Do not override

    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge(controller, base); // Do not override

    var isCategory = this.isCategory();
    completeSingle.call(this, target);
    completeSingle.call(this, controller);
    completeInactive.call(this, target, 'inRange', 'outOfRange'); // completeInactive.call(this, target, 'outOfRange', 'inRange');

    completeController.call(this, controller);

    function completeSingle(base) {
      // Compatible with ec2 dataRange.color.
      // The mapping order of dataRange.color is: [high value, ..., low value]
      // whereas inRange.color and outOfRange.color is [low value, ..., high value]
      // Notice: ec2 has no inverse.
      if (isArray(thisOption.color) // If there has been inRange: {symbol: ...}, adding color is a mistake.
      // So adding color only when no inRange defined.
      && !base.inRange) {
        base.inRange = {
          color: thisOption.color.slice().reverse()
        };
      } // Compatible with previous logic, always give a defautl color, otherwise
      // simple config with no inRange and outOfRange will not work.
      // Originally we use visualMap.color as the default color, but setOption at
      // the second time the default color will be erased. So we change to use
      // constant DEFAULT_COLOR.
      // If user do not want the default color, set inRange: {color: null}.


      base.inRange = base.inRange || {
        color: ecModel.get('gradientColor')
      };
    }

    function completeInactive(base, stateExist, stateAbsent) {
      var optExist = base[stateExist];
      var optAbsent = base[stateAbsent];

      if (optExist && !optAbsent) {
        optAbsent = base[stateAbsent] = {};
        each(optExist, function (visualData, visualType) {
          if (!_visual_VisualMapping__WEBPACK_IMPORTED_MODULE_0__.default.isValidType(visualType)) {
            return;
          }

          var defa = _visual_visualDefault__WEBPACK_IMPORTED_MODULE_7__.default.get(visualType, 'inactive', isCategory);

          if (defa != null) {
            optAbsent[visualType] = defa; // Compatibable with ec2:
            // Only inactive color to rgba(0,0,0,0) can not
            // make label transparent, so use opacity also.

            if (visualType === 'color' && !optAbsent.hasOwnProperty('opacity') && !optAbsent.hasOwnProperty('colorAlpha')) {
              optAbsent.opacity = [0, 0];
            }
          }
        });
      }
    }

    function completeController(controller) {
      var symbolExists = (controller.inRange || {}).symbol || (controller.outOfRange || {}).symbol;
      var symbolSizeExists = (controller.inRange || {}).symbolSize || (controller.outOfRange || {}).symbolSize;
      var inactiveColor = this.get('inactiveColor');
      each(this.stateList, function (state) {
        var itemSize = this.itemSize;
        var visuals = controller[state]; // Set inactive color for controller if no other color
        // attr (like colorAlpha) specified.

        if (!visuals) {
          visuals = controller[state] = {
            color: isCategory ? inactiveColor : [inactiveColor]
          };
        } // Consistent symbol and symbolSize if not specified.


        if (visuals.symbol == null) {
          visuals.symbol = symbolExists && zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone(symbolExists) || (isCategory ? 'roundRect' : ['roundRect']);
        }

        if (visuals.symbolSize == null) {
          visuals.symbolSize = symbolSizeExists && zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone(symbolSizeExists) || (isCategory ? itemSize[0] : [itemSize[0], itemSize[0]]);
        } // Filter square and none.


        visuals.symbol = mapVisual(visuals.symbol, function (symbol) {
          return symbol === 'none' || symbol === 'square' ? 'roundRect' : symbol;
        }); // Normalize symbolSize

        var symbolSize = visuals.symbolSize;

        if (symbolSize != null) {
          var max_1 = -Infinity; // symbolSize can be object when categories defined.

          eachVisual(symbolSize, function (value) {
            value > max_1 && (max_1 = value);
          });
          visuals.symbolSize = mapVisual(symbolSize, function (value) {
            return linearMap(value, [0, max_1], [0, itemSize[0]], true);
          });
        }
      }, this);
    }
  };

  VisualMapModel.prototype.resetItemSize = function () {
    this.itemSize = [parseFloat(this.get('itemWidth')), parseFloat(this.get('itemHeight'))];
  };

  VisualMapModel.prototype.isCategory = function () {
    return !!this.option.categories;
  };
  /**
   * @public
   * @abstract
   */


  VisualMapModel.prototype.setSelected = function (selected) {};

  VisualMapModel.prototype.getSelected = function () {
    return null;
  };
  /**
   * @public
   * @abstract
   */


  VisualMapModel.prototype.getValueState = function (value) {
    return null;
  };
  /**
   * FIXME
   * Do not publish to thirt-part-dev temporarily
   * util the interface is stable. (Should it return
   * a function but not visual meta?)
   *
   * @pubilc
   * @abstract
   * @param getColorVisual
   *        params: value, valueState
   *        return: color
   * @return {Object} visualMeta
   *        should includes {stops, outerColors}
   *        outerColor means [colorBeyondMinValue, colorBeyondMaxValue]
   */


  VisualMapModel.prototype.getVisualMeta = function (getColorVisual) {
    return null;
  };

  VisualMapModel.type = 'visualMap';
  VisualMapModel.dependencies = ['series'];
  VisualMapModel.defaultOption = {
    show: true,
    zlevel: 0,
    z: 4,
    seriesIndex: 'all',
    min: 0,
    max: 200,
    left: 0,
    right: null,
    top: null,
    bottom: 0,
    itemWidth: null,
    itemHeight: null,
    inverse: false,
    orient: 'vertical',
    backgroundColor: 'rgba(0,0,0,0)',
    borderColor: '#ccc',
    contentColor: '#5793f3',
    inactiveColor: '#aaa',
    borderWidth: 0,
    padding: 5,
    // 接受数组分别设定上右下左边距，同css
    textGap: 10,
    precision: 0,
    textStyle: {
      color: '#333' // 值域文字颜色

    }
  };
  return VisualMapModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_8__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VisualMapModel);

/***/ }),

/***/ "./node_modules/echarts/lib/component/visualMap/VisualMapView.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/visualMap/VisualMapView.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/format */ "./node_modules/echarts/lib/util/format.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../visual/VisualMapping */ "./node_modules/echarts/lib/visual/VisualMapping.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








var VisualMapView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(VisualMapView, _super);

  function VisualMapView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = VisualMapView.type;
    _this.autoPositionValues = {
      left: 1,
      right: 1,
      top: 1,
      bottom: 1
    };
    return _this;
  }

  VisualMapView.prototype.init = function (ecModel, api) {
    this.ecModel = ecModel;
    this.api = api;
  };
  /**
   * @protected
   */


  VisualMapView.prototype.render = function (visualMapModel, ecModel, api, payload // TODO: TYPE
  ) {
    this.visualMapModel = visualMapModel;

    if (visualMapModel.get('show') === false) {
      this.group.removeAll();
      return;
    }

    this.doRender(visualMapModel, ecModel, api, payload);
  };
  /**
   * @protected
   */


  VisualMapView.prototype.renderBackground = function (group) {
    var visualMapModel = this.visualMapModel;
    var padding = _util_format__WEBPACK_IMPORTED_MODULE_1__.normalizeCssArray(visualMapModel.get('padding') || 0);
    var rect = group.getBoundingRect();
    group.add(new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default({
      z2: -1,
      silent: true,
      shape: {
        x: rect.x - padding[3],
        y: rect.y - padding[0],
        width: rect.width + padding[3] + padding[1],
        height: rect.height + padding[0] + padding[2]
      },
      style: {
        fill: visualMapModel.get('backgroundColor'),
        stroke: visualMapModel.get('borderColor'),
        lineWidth: visualMapModel.get('borderWidth')
      }
    }));
  };
  /**
   * @protected
   * @param targetValue can be Infinity or -Infinity
   * @param visualCluster Only can be 'color' 'opacity' 'symbol' 'symbolSize'
   * @param opts
   * @param opts.forceState Specify state, instead of using getValueState method.
   * @param opts.convertOpacityToAlpha For color gradient in controller widget.
   * @return {*} Visual value.
   */


  VisualMapView.prototype.getControllerVisual = function (targetValue, visualCluster, opts) {
    opts = opts || {};
    var forceState = opts.forceState;
    var visualMapModel = this.visualMapModel;
    var visualObj = {}; // Default values.

    if (visualCluster === 'symbol') {
      visualObj.symbol = visualMapModel.get('itemSymbol');
    }

    if (visualCluster === 'color') {
      var defaultColor = visualMapModel.get('contentColor');
      visualObj.color = defaultColor;
    }

    function getter(key) {
      return visualObj[key];
    }

    function setter(key, value) {
      visualObj[key] = value;
    }

    var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];
    var visualTypes = _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_3__.default.prepareVisualTypes(mappings);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.each(visualTypes, function (type) {
      var visualMapping = mappings[type];

      if (opts.convertOpacityToAlpha && type === 'opacity') {
        type = 'colorAlpha';
        visualMapping = mappings.__alphaForOpacity;
      }

      if (_visual_VisualMapping__WEBPACK_IMPORTED_MODULE_3__.default.dependsOn(type, visualCluster)) {
        visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
      }
    });
    return visualObj[visualCluster];
  };

  VisualMapView.prototype.positionGroup = function (group) {
    var model = this.visualMapModel;
    var api = this.api;
    _util_layout__WEBPACK_IMPORTED_MODULE_5__.positionElement(group, model.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  };

  VisualMapView.prototype.doRender = function (visualMapModel, ecModel, api, payload) {};

  VisualMapView.type = 'visualMap';
  return VisualMapView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_6__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VisualMapView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/visualMap/helper.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/visualMap/helper.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getItemAlign": () => (/* binding */ getItemAlign),
/* harmony export */   "makeHighDownBatch": () => (/* binding */ makeHighDownBatch)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


var paramsSet = [['left', 'right', 'width'], ['top', 'bottom', 'height']];
/**
 * @param visualMapModel
 * @param api
 * @param itemSize always [short, long]
 * @return {string} 'left' or 'right' or 'top' or 'bottom'
 */

function getItemAlign(visualMapModel, api, itemSize) {
  var modelOption = visualMapModel.option;
  var itemAlign = modelOption.align;

  if (itemAlign != null && itemAlign !== 'auto') {
    return itemAlign;
  } // Auto decision align.


  var ecSize = {
    width: api.getWidth(),
    height: api.getHeight()
  };
  var realIndex = modelOption.orient === 'horizontal' ? 1 : 0;
  var reals = paramsSet[realIndex];
  var fakeValue = [0, null, 10];
  var layoutInput = {};

  for (var i = 0; i < 3; i++) {
    layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];
    layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];
  }

  var rParam = [['x', 'width', 3], ['y', 'height', 0]][realIndex];
  var rect = (0,_util_layout__WEBPACK_IMPORTED_MODULE_0__.getLayoutRect)(layoutInput, ecSize, modelOption.padding);
  return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];
}
/**
 * Prepare dataIndex for outside usage, where dataIndex means rawIndex, and
 * dataIndexInside means filtered index.
 */
// TODO: TYPE more specified payload types.

function makeHighDownBatch(batch, visualMapModel) {
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(batch || [], function (batchItem) {
    if (batchItem.dataIndex != null) {
      batchItem.dataIndexInside = batchItem.dataIndex;
      batchItem.dataIndex = null;
    }

    batchItem.highlightKey = 'visualMap' + (visualMapModel ? visualMapModel.componentIndex : '');
  });
  return batch;
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/visualMap/install.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/visualMap/install.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extension */ "./node_modules/echarts/lib/extension.js");
/* harmony import */ var _installVisualMapContinuous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./installVisualMapContinuous */ "./node_modules/echarts/lib/component/visualMap/installVisualMapContinuous.js");
/* harmony import */ var _installVisualMapPiecewise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./installVisualMapPiecewise */ "./node_modules/echarts/lib/component/visualMap/installVisualMapPiecewise.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function install(registers) {
  (0,_extension__WEBPACK_IMPORTED_MODULE_0__.use)(_installVisualMapContinuous__WEBPACK_IMPORTED_MODULE_1__.install);
  (0,_extension__WEBPACK_IMPORTED_MODULE_0__.use)(_installVisualMapPiecewise__WEBPACK_IMPORTED_MODULE_2__.install); // Do not install './dataZoomSelect',
  // since it only work for toolbox dataZoom.
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/visualMap/installCommon.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/visualMap/installCommon.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ installCommon)
/* harmony export */ });
/* harmony import */ var _visualMapAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./visualMapAction */ "./node_modules/echarts/lib/component/visualMap/visualMapAction.js");
/* harmony import */ var _visualEncoding__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./visualEncoding */ "./node_modules/echarts/lib/component/visualMap/visualEncoding.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _preprocessor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./preprocessor */ "./node_modules/echarts/lib/component/visualMap/preprocessor.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var installed = false;
function installCommon(registers) {
  if (installed) {
    return;
  }

  installed = true;
  registers.registerSubTypeDefaulter('visualMap', function (option) {
    // Compatible with ec2, when splitNumber === 0, continuous visualMap will be used.
    return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? 'continuous' : 'piecewise';
  });
  registers.registerAction(_visualMapAction__WEBPACK_IMPORTED_MODULE_0__.visualMapActionInfo, _visualMapAction__WEBPACK_IMPORTED_MODULE_0__.visualMapActionHander);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(_visualEncoding__WEBPACK_IMPORTED_MODULE_2__.visualMapEncodingHandlers, function (handler) {
    registers.registerVisual(registers.PRIORITY.VISUAL.COMPONENT, handler);
  });
  registers.registerPreprocessor(_preprocessor__WEBPACK_IMPORTED_MODULE_3__.default);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/visualMap/installVisualMapContinuous.js":
/*!************************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/visualMap/installVisualMapContinuous.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _ContinuousModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContinuousModel */ "./node_modules/echarts/lib/component/visualMap/ContinuousModel.js");
/* harmony import */ var _ContinuousView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ContinuousView */ "./node_modules/echarts/lib/component/visualMap/ContinuousView.js");
/* harmony import */ var _installCommon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./installCommon */ "./node_modules/echarts/lib/component/visualMap/installCommon.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function install(registers) {
  registers.registerComponentModel(_ContinuousModel__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerComponentView(_ContinuousView__WEBPACK_IMPORTED_MODULE_1__.default);
  (0,_installCommon__WEBPACK_IMPORTED_MODULE_2__.default)(registers);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/visualMap/installVisualMapPiecewise.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/visualMap/installVisualMapPiecewise.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _PiecewiseModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PiecewiseModel */ "./node_modules/echarts/lib/component/visualMap/PiecewiseModel.js");
/* harmony import */ var _PiecewiseView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PiecewiseView */ "./node_modules/echarts/lib/component/visualMap/PiecewiseView.js");
/* harmony import */ var _installCommon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./installCommon */ "./node_modules/echarts/lib/component/visualMap/installCommon.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function install(registers) {
  registers.registerComponentModel(_PiecewiseModel__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerComponentView(_PiecewiseView__WEBPACK_IMPORTED_MODULE_1__.default);
  (0,_installCommon__WEBPACK_IMPORTED_MODULE_2__.default)(registers);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/visualMap/preprocessor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/visualMap/preprocessor.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ visualMapPreprocessor)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// @ts-nocheck

var each = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each;
function visualMapPreprocessor(option) {
  var visualMap = option && option.visualMap;

  if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(visualMap)) {
    visualMap = visualMap ? [visualMap] : [];
  }

  each(visualMap, function (opt) {
    if (!opt) {
      return;
    } // rename splitList to pieces


    if (has(opt, 'splitList') && !has(opt, 'pieces')) {
      opt.pieces = opt.splitList;
      delete opt.splitList;
    }

    var pieces = opt.pieces;

    if (pieces && zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(pieces)) {
      each(pieces, function (piece) {
        if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject(piece)) {
          if (has(piece, 'start') && !has(piece, 'min')) {
            piece.min = piece.start;
          }

          if (has(piece, 'end') && !has(piece, 'max')) {
            piece.max = piece.end;
          }
        }
      });
    }
  });
}

function has(obj, name) {
  return obj && obj.hasOwnProperty && obj.hasOwnProperty(name);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/visualMap/visualEncoding.js":
/*!************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/visualMap/visualEncoding.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "visualMapEncodingHandlers": () => (/* binding */ visualMapEncodingHandlers)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _visual_visualSolution__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../visual/visualSolution */ "./node_modules/echarts/lib/visual/visualSolution.js");
/* harmony import */ var _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../visual/VisualMapping */ "./node_modules/echarts/lib/visual/VisualMapping.js");
/* harmony import */ var _visual_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../visual/helper */ "./node_modules/echarts/lib/visual/helper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var visualMapEncodingHandlers = [{
  createOnAllSeries: true,
  reset: function (seriesModel, ecModel) {
    var resetDefines = [];
    ecModel.eachComponent('visualMap', function (visualMapModel) {
      var pipelineContext = seriesModel.pipelineContext;

      if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) {
        return;
      }

      resetDefines.push(_visual_visualSolution__WEBPACK_IMPORTED_MODULE_0__.incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimension(seriesModel.getData())));
    });
    return resetDefines;
  }
}, // Only support color.
{
  createOnAllSeries: true,
  reset: function (seriesModel, ecModel) {
    var data = seriesModel.getData();
    var visualMetaList = [];
    ecModel.eachComponent('visualMap', function (visualMapModel) {
      if (visualMapModel.isTargetSeries(seriesModel)) {
        var visualMeta = visualMapModel.getVisualMeta(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind(getColorVisual, null, seriesModel, visualMapModel)) || {
          stops: [],
          outerColors: []
        };
        var concreteDim = visualMapModel.getDataDimension(data);
        var dimInfo = data.getDimensionInfo(concreteDim);

        if (dimInfo != null) {
          // visualMeta.dimension should be dimension index, but not concrete dimension.
          visualMeta.dimension = dimInfo.index;
          visualMetaList.push(visualMeta);
        }
      }
    }); // console.log(JSON.stringify(visualMetaList.map(a => a.stops)));

    seriesModel.getData().setVisual('visualMeta', visualMetaList);
  }
}]; // FIXME
// performance and export for heatmap?
// value can be Infinity or -Infinity

function getColorVisual(seriesModel, visualMapModel, value, valueState) {
  var mappings = visualMapModel.targetVisuals[valueState];
  var visualTypes = _visual_VisualMapping__WEBPACK_IMPORTED_MODULE_2__.default.prepareVisualTypes(mappings);
  var resultVisual = {
    color: (0,_visual_helper__WEBPACK_IMPORTED_MODULE_3__.getVisualFromData)(seriesModel.getData(), 'color') // default color.

  };

  for (var i = 0, len = visualTypes.length; i < len; i++) {
    var type = visualTypes[i];
    var mapping = mappings[type === 'opacity' ? '__alphaForOpacity' : type];
    mapping && mapping.applyVisual(value, getVisual, setVisual);
  }

  return resultVisual.color;

  function getVisual(key) {
    return resultVisual[key];
  }

  function setVisual(key, value) {
    resultVisual[key] = value;
  }
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/visualMap/visualMapAction.js":
/*!*************************************************************************!*\
  !*** ./node_modules/echarts/lib/component/visualMap/visualMapAction.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "visualMapActionInfo": () => (/* binding */ visualMapActionInfo),
/* harmony export */   "visualMapActionHander": () => (/* binding */ visualMapActionHander)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var visualMapActionInfo = {
  type: 'selectDataRange',
  event: 'dataRangeSelected',
  // FIXME use updateView appears wrong
  update: 'update'
};
var visualMapActionHander = function (payload, ecModel) {
  ecModel.eachComponent({
    mainType: 'visualMap',
    query: payload
  }, function (model) {
    model.setSelected(payload.selected);
  });
};

/***/ }),

/***/ "./node_modules/echarts/lib/coord/calendar/Calendar.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/calendar/Calendar.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


 // (24*60*60*1000)

var PROXIMATE_ONE_DAY = 86400000;

var Calendar =
/** @class */
function () {
  function Calendar(calendarModel, ecModel, api) {
    this.type = 'calendar';
    this.dimensions = Calendar.dimensions; // Required in createListFromData

    this.getDimensionsInfo = Calendar.getDimensionsInfo;
    this._model = calendarModel;
  }

  Calendar.getDimensionsInfo = function () {
    return [{
      name: 'time',
      type: 'time'
    }, 'value'];
  };

  Calendar.prototype.getRangeInfo = function () {
    return this._rangeInfo;
  };

  Calendar.prototype.getModel = function () {
    return this._model;
  };

  Calendar.prototype.getRect = function () {
    return this._rect;
  };

  Calendar.prototype.getCellWidth = function () {
    return this._sw;
  };

  Calendar.prototype.getCellHeight = function () {
    return this._sh;
  };

  Calendar.prototype.getOrient = function () {
    return this._orient;
  };
  /**
   * getFirstDayOfWeek
   *
   * @example
   *     0 : start at Sunday
   *     1 : start at Monday
   *
   * @return {number}
   */


  Calendar.prototype.getFirstDayOfWeek = function () {
    return this._firstDayOfWeek;
  };
  /**
   * get date info
   * }
   */


  Calendar.prototype.getDateInfo = function (date) {
    date = _util_number__WEBPACK_IMPORTED_MODULE_0__.parseDate(date);
    var y = date.getFullYear();
    var m = date.getMonth() + 1;
    var mStr = m < 10 ? '0' + m : '' + m;
    var d = date.getDate();
    var dStr = d < 10 ? '0' + d : '' + d;
    var day = date.getDay();
    day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);
    return {
      y: y + '',
      m: mStr,
      d: dStr,
      day: day,
      time: date.getTime(),
      formatedDate: y + '-' + mStr + '-' + dStr,
      date: date
    };
  };

  Calendar.prototype.getNextNDay = function (date, n) {
    n = n || 0;

    if (n === 0) {
      return this.getDateInfo(date);
    }

    date = new Date(this.getDateInfo(date).time);
    date.setDate(date.getDate() + n);
    return this.getDateInfo(date);
  };

  Calendar.prototype.update = function (ecModel, api) {
    this._firstDayOfWeek = +this._model.getModel('dayLabel').get('firstDay');
    this._orient = this._model.get('orient');
    this._lineWidth = this._model.getModel('itemStyle').getItemStyle().lineWidth || 0;
    this._rangeInfo = this._getRangeInfo(this._initRangeOption());
    var weeks = this._rangeInfo.weeks || 1;
    var whNames = ['width', 'height'];

    var cellSize = this._model.getCellSize().slice();

    var layoutParams = this._model.getBoxLayoutParams();

    var cellNumbers = this._orient === 'horizontal' ? [weeks, 7] : [7, weeks];
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each([0, 1], function (idx) {
      if (cellSizeSpecified(cellSize, idx)) {
        layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];
      }
    });
    var whGlobal = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var calendarRect = this._rect = _util_layout__WEBPACK_IMPORTED_MODULE_2__.getLayoutRect(layoutParams, whGlobal);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each([0, 1], function (idx) {
      if (!cellSizeSpecified(cellSize, idx)) {
        cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];
      }
    });

    function cellSizeSpecified(cellSize, idx) {
      return cellSize[idx] != null && cellSize[idx] !== 'auto';
    } // Has been calculated out number.


    this._sw = cellSize[0];
    this._sh = cellSize[1];
  };
  /**
   * Convert a time data(time, value) item to (x, y) point.
   */
  // TODO Clamp of calendar is not same with cartesian coordinate systems.
  // It will return NaN if data exceeds.


  Calendar.prototype.dataToPoint = function (data, clamp) {
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(data) && (data = data[0]);
    clamp == null && (clamp = true);
    var dayInfo = this.getDateInfo(data);
    var range = this._rangeInfo;
    var date = dayInfo.formatedDate; // if not in range return [NaN, NaN]

    if (clamp && !(dayInfo.time >= range.start.time && dayInfo.time < range.end.time + PROXIMATE_ONE_DAY)) {
      return [NaN, NaN];
    }

    var week = dayInfo.day;

    var nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek;

    if (this._orient === 'vertical') {
      return [this._rect.x + week * this._sw + this._sw / 2, this._rect.y + nthWeek * this._sh + this._sh / 2];
    }

    return [this._rect.x + nthWeek * this._sw + this._sw / 2, this._rect.y + week * this._sh + this._sh / 2];
  };
  /**
   * Convert a (x, y) point to time data
   */


  Calendar.prototype.pointToData = function (point) {
    var date = this.pointToDate(point);
    return date && date.time;
  };
  /**
   * Convert a time date item to (x, y) four point.
   */


  Calendar.prototype.dataToRect = function (data, clamp) {
    var point = this.dataToPoint(data, clamp);
    return {
      contentShape: {
        x: point[0] - (this._sw - this._lineWidth) / 2,
        y: point[1] - (this._sh - this._lineWidth) / 2,
        width: this._sw - this._lineWidth,
        height: this._sh - this._lineWidth
      },
      center: point,
      tl: [point[0] - this._sw / 2, point[1] - this._sh / 2],
      tr: [point[0] + this._sw / 2, point[1] - this._sh / 2],
      br: [point[0] + this._sw / 2, point[1] + this._sh / 2],
      bl: [point[0] - this._sw / 2, point[1] + this._sh / 2]
    };
  };
  /**
   * Convert a (x, y) point to time date
   *
   * @param  {Array} point point
   * @return {Object}       date
   */


  Calendar.prototype.pointToDate = function (point) {
    var nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1;
    var nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1;
    var range = this._rangeInfo.range;

    if (this._orient === 'vertical') {
      return this._getDateByWeeksAndDay(nthY, nthX - 1, range);
    }

    return this._getDateByWeeksAndDay(nthX, nthY - 1, range);
  };

  Calendar.prototype.convertToPixel = function (ecModel, finder, value) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  };

  Calendar.prototype.convertFromPixel = function (ecModel, finder, pixel) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  };

  Calendar.prototype.containPoint = function (point) {
    console.warn('Not implemented.');
    return false;
  };
  /**
   * initRange
   * Normalize to an [start, end] array
   */


  Calendar.prototype._initRangeOption = function () {
    var range = this._model.get('range');

    var normalizedRange; // Convert [1990] to 1990

    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(range) && range.length === 1) {
      range = range[0];
    }

    if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(range)) {
      var rangeStr = range.toString(); // One year.

      if (/^\d{4}$/.test(rangeStr)) {
        normalizedRange = [rangeStr + '-01-01', rangeStr + '-12-31'];
      } // One month


      if (/^\d{4}[\/|-]\d{1,2}$/.test(rangeStr)) {
        var start = this.getDateInfo(rangeStr);
        var firstDay = start.date;
        firstDay.setMonth(firstDay.getMonth() + 1);
        var end = this.getNextNDay(firstDay, -1);
        normalizedRange = [start.formatedDate, end.formatedDate];
      } // One day


      if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(rangeStr)) {
        normalizedRange = [rangeStr, rangeStr];
      }
    } else {
      normalizedRange = range;
    }

    if (!normalizedRange) {
      if (true) {
        zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.logError('Invalid date range.');
      } // Not handling it.


      return range;
    }

    var tmp = this._getRangeInfo(normalizedRange);

    if (tmp.start.time > tmp.end.time) {
      normalizedRange.reverse();
    }

    return normalizedRange;
  };
  /**
   * range info
   *
   * @private
   * @param  {Array} range range ['2017-01-01', '2017-07-08']
   *  If range[0] > range[1], they will not be reversed.
   * @return {Object}       obj
   */


  Calendar.prototype._getRangeInfo = function (range) {
    var parsedRange = [this.getDateInfo(range[0]), this.getDateInfo(range[1])];
    var reversed;

    if (parsedRange[0].time > parsedRange[1].time) {
      reversed = true;
      parsedRange.reverse();
    }

    var allDay = Math.floor(parsedRange[1].time / PROXIMATE_ONE_DAY) - Math.floor(parsedRange[0].time / PROXIMATE_ONE_DAY) + 1; // Consider case1 (#11677 #10430):
    // Set the system timezone as "UK", set the range to `['2016-07-01', '2016-12-31']`
    // Consider case2:
    // Firstly set system timezone as "Time Zone: America/Toronto",
    // ```
    // let first = new Date(1478412000000 - 3600 * 1000 * 2.5);
    // let second = new Date(1478412000000);
    // let allDays = Math.floor(second / ONE_DAY) - Math.floor(first / ONE_DAY) + 1;
    // ```
    // will get wrong result because of DST. So we should fix it.

    var date = new Date(parsedRange[0].time);
    var startDateNum = date.getDate();
    var endDateNum = parsedRange[1].date.getDate();
    date.setDate(startDateNum + allDay - 1); // The bias can not over a month, so just compare date.

    var dateNum = date.getDate();

    if (dateNum !== endDateNum) {
      var sign = date.getTime() - parsedRange[1].time > 0 ? 1 : -1;

      while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - parsedRange[1].time) * sign > 0) {
        allDay -= sign;
        date.setDate(dateNum - sign);
      }
    }

    var weeks = Math.floor((allDay + parsedRange[0].day + 6) / 7);
    var nthWeek = reversed ? -weeks + 1 : weeks - 1;
    reversed && parsedRange.reverse();
    return {
      range: [parsedRange[0].formatedDate, parsedRange[1].formatedDate],
      start: parsedRange[0],
      end: parsedRange[1],
      allDay: allDay,
      weeks: weeks,
      // From 0.
      nthWeek: nthWeek,
      fweek: parsedRange[0].day,
      lweek: parsedRange[1].day
    };
  };
  /**
   * get date by nthWeeks and week day in range
   *
   * @private
   * @param  {number} nthWeek the week
   * @param  {number} day   the week day
   * @param  {Array} range [d1, d2]
   * @return {Object}
   */


  Calendar.prototype._getDateByWeeksAndDay = function (nthWeek, day, range) {
    var rangeInfo = this._getRangeInfo(range);

    if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) {
      return null;
    }

    var nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;
    var date = new Date(rangeInfo.start.time);
    date.setDate(+rangeInfo.start.d + nthDay);
    return this.getDateInfo(date);
  };

  Calendar.create = function (ecModel, api) {
    var calendarList = [];
    ecModel.eachComponent('calendar', function (calendarModel) {
      var calendar = new Calendar(calendarModel, ecModel, api);
      calendarList.push(calendar);
      calendarModel.coordinateSystem = calendar;
    });
    ecModel.eachSeries(function (calendarSeries) {
      if (calendarSeries.get('coordinateSystem') === 'calendar') {
        // Inject coordinate system
        calendarSeries.coordinateSystem = calendarList[calendarSeries.get('calendarIndex') || 0];
      }
    });
    return calendarList;
  };

  Calendar.dimensions = ['time', 'value'];
  return Calendar;
}();

function getCoordSys(finder) {
  var calendarModel = finder.calendarModel;
  var seriesModel = finder.seriesModel;
  var coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;
  return coordSys;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Calendar);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/calendar/CalendarModel.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/calendar/CalendarModel.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var CalendarModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(CalendarModel, _super);

  function CalendarModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CalendarModel.type;
    return _this;
  }
  /**
   * @override
   */


  CalendarModel.prototype.init = function (option, parentModel, ecModel) {
    var inputPositionParams = (0,_util_layout__WEBPACK_IMPORTED_MODULE_1__.getLayoutParams)(option);

    _super.prototype.init.apply(this, arguments);

    mergeAndNormalizeLayoutParams(option, inputPositionParams);
  };
  /**
   * @override
   */


  CalendarModel.prototype.mergeOption = function (option) {
    _super.prototype.mergeOption.apply(this, arguments);

    mergeAndNormalizeLayoutParams(this.option, option);
  };

  CalendarModel.prototype.getCellSize = function () {
    // Has been normalized
    return this.option.cellSize;
  };

  CalendarModel.type = 'calendar';
  CalendarModel.defaultOption = {
    zlevel: 0,
    z: 2,
    left: 80,
    top: 60,
    cellSize: 20,
    // horizontal vertical
    orient: 'horizontal',
    // month separate line style
    splitLine: {
      show: true,
      lineStyle: {
        color: '#000',
        width: 1,
        type: 'solid'
      }
    },
    // rect style  temporarily unused emphasis
    itemStyle: {
      color: '#fff',
      borderWidth: 1,
      borderColor: '#ccc'
    },
    // week text style
    dayLabel: {
      show: true,
      firstDay: 0,
      // start end
      position: 'start',
      margin: '50%',
      nameMap: 'en',
      color: '#000'
    },
    // month text style
    monthLabel: {
      show: true,
      // start end
      position: 'start',
      margin: 5,
      // center or left
      align: 'center',
      // cn en []
      nameMap: 'en',
      formatter: null,
      color: '#000'
    },
    // year text style
    yearLabel: {
      show: true,
      // top bottom left right
      position: null,
      margin: 30,
      formatter: null,
      color: '#ccc',
      fontFamily: 'sans-serif',
      fontWeight: 'bolder',
      fontSize: 20
    }
  };
  return CalendarModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_2__.default);

function mergeAndNormalizeLayoutParams(target, raw) {
  // Normalize cellSize
  var cellSize = target.cellSize;
  var cellSizeArr;

  if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.isArray(cellSize)) {
    cellSizeArr = target.cellSize = [cellSize, cellSize];
  } else {
    cellSizeArr = cellSize;
  }

  if (cellSizeArr.length === 1) {
    cellSizeArr[1] = cellSizeArr[0];
  }

  var ignoreSize = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.map([0, 1], function (hvIdx) {
    // If user have set `width` or both `left` and `right`, cellSizeArr
    // will be automatically set to 'auto', otherwise the default
    // setting of cellSizeArr will make `width` setting not work.
    if ((0,_util_layout__WEBPACK_IMPORTED_MODULE_1__.sizeCalculable)(raw, hvIdx)) {
      cellSizeArr[hvIdx] = 'auto';
    }

    return cellSizeArr[hvIdx] != null && cellSizeArr[hvIdx] !== 'auto';
  });
  (0,_util_layout__WEBPACK_IMPORTED_MODULE_1__.mergeLayoutParam)(target, raw, {
    type: 'box',
    ignoreSize: ignoreSize
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalendarModel);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/polar/AngleAxis.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/coord/polar/AngleAxis.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_contain_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/contain/text */ "./node_modules/zrender/lib/contain/text.js");
/* harmony import */ var _Axis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Axis */ "./node_modules/echarts/lib/coord/Axis.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();

var AngleAxis =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(AngleAxis, _super);

  function AngleAxis(scale, angleExtent) {
    return _super.call(this, 'angle', scale, angleExtent || [0, 360]) || this;
  }

  AngleAxis.prototype.pointToData = function (point, clamp) {
    return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1];
  };
  /**
   * Only be called in category axis.
   * Angle axis uses text height to decide interval
   *
   * @override
   * @return {number} Auto interval for cateogry axis tick and label
   */


  AngleAxis.prototype.calculateCategoryInterval = function () {
    var axis = this;
    var labelModel = axis.getLabelModel();
    var ordinalScale = axis.scale;
    var ordinalExtent = ordinalScale.getExtent(); // Providing this method is for optimization:
    // avoid generating a long array by `getTicks`
    // in large category data case.

    var tickCount = ordinalScale.count();

    if (ordinalExtent[1] - ordinalExtent[0] < 1) {
      return 0;
    }

    var tickValue = ordinalExtent[0];
    var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
    var unitH = Math.abs(unitSpan); // Not precise, just use height as text width
    // and each distance from axis line yet.

    var rect = zrender_lib_contain_text__WEBPACK_IMPORTED_MODULE_2__.getBoundingRect(tickValue == null ? '' : tickValue + '', labelModel.getFont(), 'center', 'top');
    var maxH = Math.max(rect.height, 7);
    var dh = maxH / unitH; // 0/0 is NaN, 1/0 is Infinity.

    isNaN(dh) && (dh = Infinity);
    var interval = Math.max(0, Math.floor(dh));
    var cache = inner(axis.model);
    var lastAutoInterval = cache.lastAutoInterval;
    var lastTickCount = cache.lastTickCount; // Use cache to keep interval stable while moving zoom window,
    // otherwise the calculated interval might jitter when the zoom
    // window size is close to the interval-changing size.

    if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 // Always choose the bigger one, otherwise the critical
    // point is not the same when zooming in or zooming out.
    && lastAutoInterval > interval) {
      interval = lastAutoInterval;
    } // Only update cache if cache not used, otherwise the
    // changing of interval is too insensitive.
    else {
        cache.lastTickCount = tickCount;
        cache.lastAutoInterval = interval;
      }

    return interval;
  };

  return AngleAxis;
}(_Axis__WEBPACK_IMPORTED_MODULE_3__.default);

AngleAxis.prototype.dataToAngle = _Axis__WEBPACK_IMPORTED_MODULE_3__.default.prototype.dataToCoord;
AngleAxis.prototype.angleToData = _Axis__WEBPACK_IMPORTED_MODULE_3__.default.prototype.coordToData;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AngleAxis);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/polar/AxisModel.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/coord/polar/AxisModel.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PolarAxisModel": () => (/* binding */ PolarAxisModel),
/* harmony export */   "AngleAxisModel": () => (/* binding */ AngleAxisModel),
/* harmony export */   "RadiusAxisModel": () => (/* binding */ RadiusAxisModel)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");
/* harmony import */ var _axisModelCommonMixin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../axisModelCommonMixin */ "./node_modules/echarts/lib/coord/axisModelCommonMixin.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var PolarAxisModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(PolarAxisModel, _super);

  function PolarAxisModel() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  PolarAxisModel.prototype.getCoordSysModel = function () {
    return this.getReferringComponents('polar', _util_model__WEBPACK_IMPORTED_MODULE_1__.SINGLE_REFERRING).models[0];
  };

  PolarAxisModel.type = 'polarAxis';
  return PolarAxisModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_2__.default);

zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.mixin(PolarAxisModel, _axisModelCommonMixin__WEBPACK_IMPORTED_MODULE_4__.AxisModelCommonMixin);


var AngleAxisModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(AngleAxisModel, _super);

  function AngleAxisModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = AngleAxisModel.type;
    return _this;
  }

  AngleAxisModel.type = 'angleAxis';
  return AngleAxisModel;
}(PolarAxisModel);



var RadiusAxisModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(RadiusAxisModel, _super);

  function RadiusAxisModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = RadiusAxisModel.type;
    return _this;
  }

  RadiusAxisModel.type = 'radiusAxis';
  return RadiusAxisModel;
}(PolarAxisModel);



/***/ }),

/***/ "./node_modules/echarts/lib/coord/polar/Polar.js":
/*!*******************************************************!*\
  !*** ./node_modules/echarts/lib/coord/polar/Polar.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _RadiusAxis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RadiusAxis */ "./node_modules/echarts/lib/coord/polar/RadiusAxis.js");
/* harmony import */ var _AngleAxis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AngleAxis */ "./node_modules/echarts/lib/coord/polar/AngleAxis.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var Polar =
/** @class */
function () {
  function Polar(name) {
    this.dimensions = ['radius', 'angle'];
    this.type = 'polar';
    /**
     * x of polar center
     */

    this.cx = 0;
    /**
     * y of polar center
     */

    this.cy = 0;
    this._radiusAxis = new _RadiusAxis__WEBPACK_IMPORTED_MODULE_0__.default();
    this._angleAxis = new _AngleAxis__WEBPACK_IMPORTED_MODULE_1__.default();
    this.axisPointerEnabled = true;
    this.name = name || '';
    this._radiusAxis.polar = this._angleAxis.polar = this;
  }
  /**
   * If contain coord
   */


  Polar.prototype.containPoint = function (point) {
    var coord = this.pointToCoord(point);
    return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);
  };
  /**
   * If contain data
   */


  Polar.prototype.containData = function (data) {
    return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);
  };

  Polar.prototype.getAxis = function (dim) {
    var key = '_' + dim + 'Axis';
    return this[key];
  };

  Polar.prototype.getAxes = function () {
    return [this._radiusAxis, this._angleAxis];
  };
  /**
   * Get axes by type of scale
   */


  Polar.prototype.getAxesByScale = function (scaleType) {
    var axes = [];
    var angleAxis = this._angleAxis;
    var radiusAxis = this._radiusAxis;
    angleAxis.scale.type === scaleType && axes.push(angleAxis);
    radiusAxis.scale.type === scaleType && axes.push(radiusAxis);
    return axes;
  };

  Polar.prototype.getAngleAxis = function () {
    return this._angleAxis;
  };

  Polar.prototype.getRadiusAxis = function () {
    return this._radiusAxis;
  };

  Polar.prototype.getOtherAxis = function (axis) {
    var angleAxis = this._angleAxis;
    return axis === angleAxis ? this._radiusAxis : angleAxis;
  };
  /**
   * Base axis will be used on stacking.
   *
   */


  Polar.prototype.getBaseAxis = function () {
    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAngleAxis();
  };

  Polar.prototype.getTooltipAxes = function (dim) {
    var baseAxis = dim != null && dim !== 'auto' ? this.getAxis(dim) : this.getBaseAxis();
    return {
      baseAxes: [baseAxis],
      otherAxes: [this.getOtherAxis(baseAxis)]
    };
  };
  /**
   * Convert a single data item to (x, y) point.
   * Parameter data is an array which the first element is radius and the second is angle
   */


  Polar.prototype.dataToPoint = function (data, clamp) {
    return this.coordToPoint([this._radiusAxis.dataToRadius(data[0], clamp), this._angleAxis.dataToAngle(data[1], clamp)]);
  };
  /**
   * Convert a (x, y) point to data
   */


  Polar.prototype.pointToData = function (point, clamp) {
    var coord = this.pointToCoord(point);
    return [this._radiusAxis.radiusToData(coord[0], clamp), this._angleAxis.angleToData(coord[1], clamp)];
  };
  /**
   * Convert a (x, y) point to (radius, angle) coord
   */


  Polar.prototype.pointToCoord = function (point) {
    var dx = point[0] - this.cx;
    var dy = point[1] - this.cy;
    var angleAxis = this.getAngleAxis();
    var extent = angleAxis.getExtent();
    var minAngle = Math.min(extent[0], extent[1]);
    var maxAngle = Math.max(extent[0], extent[1]); // Fix fixed extent in polarCreator
    // FIXME

    angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;
    var radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    var radian = Math.atan2(-dy, dx) / Math.PI * 180; // move to angleExtent

    var dir = radian < minAngle ? 1 : -1;

    while (radian < minAngle || radian > maxAngle) {
      radian += dir * 360;
    }

    return [radius, radian];
  };
  /**
   * Convert a (radius, angle) coord to (x, y) point
   */


  Polar.prototype.coordToPoint = function (coord) {
    var radius = coord[0];
    var radian = coord[1] / 180 * Math.PI;
    var x = Math.cos(radian) * radius + this.cx; // Inverse the y

    var y = -Math.sin(radian) * radius + this.cy;
    return [x, y];
  };
  /**
   * Get ring area of cartesian.
   * Area will have a contain function to determine if a point is in the coordinate system.
   */


  Polar.prototype.getArea = function () {
    var angleAxis = this.getAngleAxis();
    var radiusAxis = this.getRadiusAxis();
    var radiusExtent = radiusAxis.getExtent().slice();
    radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();
    var angleExtent = angleAxis.getExtent();
    var RADIAN = Math.PI / 180;
    return {
      cx: this.cx,
      cy: this.cy,
      r0: radiusExtent[0],
      r: radiusExtent[1],
      startAngle: -angleExtent[0] * RADIAN,
      endAngle: -angleExtent[1] * RADIAN,
      clockwise: angleAxis.inverse,
      contain: function (x, y) {
        // It's a ring shape.
        // Start angle and end angle don't matter
        var dx = x - this.cx;
        var dy = y - this.cy;
        var d2 = dx * dx + dy * dy;
        var r = this.r;
        var r0 = this.r0;
        return d2 <= r * r && d2 >= r0 * r0;
      }
    };
  };

  Polar.prototype.convertToPixel = function (ecModel, finder, value) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? this.dataToPoint(value) : null;
  };

  Polar.prototype.convertFromPixel = function (ecModel, finder, pixel) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? this.pointToData(pixel) : null;
  };

  return Polar;
}();

function getCoordSys(finder) {
  var seriesModel = finder.seriesModel;
  var polarModel = finder.polarModel;
  return polarModel && polarModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Polar);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/polar/PolarModel.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/polar/PolarModel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var PolarModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(PolarModel, _super);

  function PolarModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = PolarModel.type;
    return _this;
  }

  PolarModel.prototype.findAxisModel = function (axisType) {
    var foundAxisModel;
    var ecModel = this.ecModel;
    ecModel.eachComponent(axisType, function (axisModel) {
      if (axisModel.getCoordSysModel() === this) {
        foundAxisModel = axisModel;
      }
    }, this);
    return foundAxisModel;
  };

  PolarModel.type = 'polar';
  PolarModel.dependencies = ['radiusAxis', 'angleAxis'];
  PolarModel.defaultOption = {
    zlevel: 0,
    z: 0,
    center: ['50%', '50%'],
    radius: '80%'
  };
  return PolarModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PolarModel);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/polar/RadiusAxis.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/polar/RadiusAxis.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Axis */ "./node_modules/echarts/lib/coord/Axis.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var RadiusAxis =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(RadiusAxis, _super);

  function RadiusAxis(scale, radiusExtent) {
    return _super.call(this, 'radius', scale, radiusExtent) || this;
  }

  RadiusAxis.prototype.pointToData = function (point, clamp) {
    return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1];
  };

  return RadiusAxis;
}(_Axis__WEBPACK_IMPORTED_MODULE_1__.default);

RadiusAxis.prototype.dataToRadius = _Axis__WEBPACK_IMPORTED_MODULE_1__.default.prototype.dataToCoord;
RadiusAxis.prototype.radiusToData = _Axis__WEBPACK_IMPORTED_MODULE_1__.default.prototype.coordToData;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadiusAxis);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/polar/polarCreator.js":
/*!**************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/polar/polarCreator.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _Polar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Polar */ "./node_modules/echarts/lib/coord/polar/Polar.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _coord_axisHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../coord/axisHelper */ "./node_modules/echarts/lib/coord/axisHelper.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// TODO Axis scale





/**
 * Resize method bound to the polar
 */

function resizePolar(polar, polarModel, api) {
  var center = polarModel.get('center');
  var width = api.getWidth();
  var height = api.getHeight();
  polar.cx = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(center[0], width);
  polar.cy = (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(center[1], height);
  var radiusAxis = polar.getRadiusAxis();
  var size = Math.min(width, height) / 2;
  var radius = polarModel.get('radius');

  if (radius == null) {
    radius = [0, '100%'];
  } else if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(radius)) {
    // r0 = 0
    radius = [0, radius];
  }

  var parsedRadius = [(0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(radius[0], size), (0,_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent)(radius[1], size)];
  radiusAxis.inverse ? radiusAxis.setExtent(parsedRadius[1], parsedRadius[0]) : radiusAxis.setExtent(parsedRadius[0], parsedRadius[1]);
}
/**
 * Update polar
 */


function updatePolarScale(ecModel, api) {
  var polar = this;
  var angleAxis = polar.getAngleAxis();
  var radiusAxis = polar.getRadiusAxis(); // Reset scale

  angleAxis.scale.setExtent(Infinity, -Infinity);
  radiusAxis.scale.setExtent(Infinity, -Infinity);
  ecModel.eachSeries(function (seriesModel) {
    if (seriesModel.coordinateSystem === polar) {
      var data_1 = seriesModel.getData();
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each((0,_coord_axisHelper__WEBPACK_IMPORTED_MODULE_2__.getDataDimensionsOnAxis)(data_1, 'radius'), function (dim) {
        radiusAxis.scale.unionExtentFromData(data_1, dim);
      });
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each((0,_coord_axisHelper__WEBPACK_IMPORTED_MODULE_2__.getDataDimensionsOnAxis)(data_1, 'angle'), function (dim) {
        angleAxis.scale.unionExtentFromData(data_1, dim);
      });
    }
  });
  (0,_coord_axisHelper__WEBPACK_IMPORTED_MODULE_2__.niceScaleExtent)(angleAxis.scale, angleAxis.model);
  (0,_coord_axisHelper__WEBPACK_IMPORTED_MODULE_2__.niceScaleExtent)(radiusAxis.scale, radiusAxis.model); // Fix extent of category angle axis

  if (angleAxis.type === 'category' && !angleAxis.onBand) {
    var extent = angleAxis.getExtent();
    var diff = 360 / angleAxis.scale.count();
    angleAxis.inverse ? extent[1] += diff : extent[1] -= diff;
    angleAxis.setExtent(extent[0], extent[1]);
  }
}

function isAngleAxisModel(axisModel) {
  return axisModel.mainType === 'angleAxis';
}
/**
 * Set common axis properties
 */


function setAxis(axis, axisModel) {
  axis.type = axisModel.get('type');
  axis.scale = (0,_coord_axisHelper__WEBPACK_IMPORTED_MODULE_2__.createScaleByModel)(axisModel);
  axis.onBand = axisModel.get('boundaryGap') && axis.type === 'category';
  axis.inverse = axisModel.get('inverse');

  if (isAngleAxisModel(axisModel)) {
    axis.inverse = axis.inverse !== axisModel.get('clockwise');
    var startAngle = axisModel.get('startAngle');
    axis.setExtent(startAngle, startAngle + (axis.inverse ? -360 : 360));
  } // Inject axis instance


  axisModel.axis = axis;
  axis.model = axisModel;
}

var polarCreator = {
  dimensions: _Polar__WEBPACK_IMPORTED_MODULE_3__.default.prototype.dimensions,
  create: function (ecModel, api) {
    var polarList = [];
    ecModel.eachComponent('polar', function (polarModel, idx) {
      var polar = new _Polar__WEBPACK_IMPORTED_MODULE_3__.default(idx + ''); // Inject resize and update method

      polar.update = updatePolarScale;
      var radiusAxis = polar.getRadiusAxis();
      var angleAxis = polar.getAngleAxis();
      var radiusAxisModel = polarModel.findAxisModel('radiusAxis');
      var angleAxisModel = polarModel.findAxisModel('angleAxis');
      setAxis(radiusAxis, radiusAxisModel);
      setAxis(angleAxis, angleAxisModel);
      resizePolar(polar, polarModel, api);
      polarList.push(polar);
      polarModel.coordinateSystem = polar;
      polar.model = polarModel;
    }); // Inject coordinateSystem to series

    ecModel.eachSeries(function (seriesModel) {
      if (seriesModel.get('coordinateSystem') === 'polar') {
        var polarModel = seriesModel.getReferringComponents('polar', _util_model__WEBPACK_IMPORTED_MODULE_4__.SINGLE_REFERRING).models[0];

        if (true) {
          if (!polarModel) {
            throw new Error('Polar "' + zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.retrieve(seriesModel.get('polarIndex'), seriesModel.get('polarId'), 0) + '" not found');
          }
        }

        seriesModel.coordinateSystem = polarModel.coordinateSystem;
      }
    });
    return polarList;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (polarCreator);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/single/AxisModel.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/single/AxisModel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");
/* harmony import */ var _axisModelCommonMixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../axisModelCommonMixin */ "./node_modules/echarts/lib/coord/axisModelCommonMixin.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var SingleAxisModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SingleAxisModel, _super);

  function SingleAxisModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = SingleAxisModel.type;
    return _this;
  }

  SingleAxisModel.prototype.getCoordSysModel = function () {
    return this;
  };

  SingleAxisModel.type = 'singleAxis';
  SingleAxisModel.layoutMode = 'box';
  SingleAxisModel.defaultOption = {
    left: '5%',
    top: '5%',
    right: '5%',
    bottom: '5%',
    type: 'value',
    position: 'bottom',
    orient: 'horizontal',
    axisLine: {
      show: true,
      lineStyle: {
        width: 1,
        type: 'solid'
      }
    },
    // Single coordinate system and single axis is the,
    // which is used as the parent tooltip model.
    // same model, so we set default tooltip show as true.
    tooltip: {
      show: true
    },
    axisTick: {
      show: true,
      length: 6,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      interval: 'auto'
    },
    splitLine: {
      show: true,
      lineStyle: {
        type: 'dashed',
        opacity: 0.2
      }
    }
  };
  return SingleAxisModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_1__.default);

(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.mixin)(SingleAxisModel, _axisModelCommonMixin__WEBPACK_IMPORTED_MODULE_3__.AxisModelCommonMixin.prototype);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SingleAxisModel);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/single/Single.js":
/*!*********************************************************!*\
  !*** ./node_modules/echarts/lib/coord/single/Single.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SingleAxis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SingleAxis */ "./node_modules/echarts/lib/coord/single/SingleAxis.js");
/* harmony import */ var _axisHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../axisHelper */ "./node_modules/echarts/lib/coord/axisHelper.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Single coordinates system.
 */




/**
 * Create a single coordinates system.
 */

var Single =
/** @class */
function () {
  function Single(axisModel, ecModel, api) {
    this.type = 'single';
    this.dimension = 'single';
    /**
     * Add it just for draw tooltip.
     */

    this.dimensions = ['single'];
    this.axisPointerEnabled = true;
    this.model = axisModel;

    this._init(axisModel, ecModel, api);
  }
  /**
   * Initialize single coordinate system.
   */


  Single.prototype._init = function (axisModel, ecModel, api) {
    var dim = this.dimension;
    var axis = new _SingleAxis__WEBPACK_IMPORTED_MODULE_0__.default(dim, _axisHelper__WEBPACK_IMPORTED_MODULE_1__.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisModel.get('position'));
    var isCategory = axis.type === 'category';
    axis.onBand = isCategory && axisModel.get('boundaryGap');
    axis.inverse = axisModel.get('inverse');
    axis.orient = axisModel.get('orient');
    axisModel.axis = axis;
    axis.model = axisModel;
    axis.coordinateSystem = this;
    this._axis = axis;
  };
  /**
   * Update axis scale after data processed
   */


  Single.prototype.update = function (ecModel, api) {
    ecModel.eachSeries(function (seriesModel) {
      if (seriesModel.coordinateSystem === this) {
        var data_1 = seriesModel.getData();
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(data_1.mapDimensionsAll(this.dimension), function (dim) {
          this._axis.scale.unionExtentFromData(data_1, dim);
        }, this);
        _axisHelper__WEBPACK_IMPORTED_MODULE_1__.niceScaleExtent(this._axis.scale, this._axis.model);
      }
    }, this);
  };
  /**
   * Resize the single coordinate system.
   */


  Single.prototype.resize = function (axisModel, api) {
    this._rect = (0,_util_layout__WEBPACK_IMPORTED_MODULE_3__.getLayoutRect)({
      left: axisModel.get('left'),
      top: axisModel.get('top'),
      right: axisModel.get('right'),
      bottom: axisModel.get('bottom'),
      width: axisModel.get('width'),
      height: axisModel.get('height')
    }, {
      width: api.getWidth(),
      height: api.getHeight()
    });

    this._adjustAxis();
  };

  Single.prototype.getRect = function () {
    return this._rect;
  };

  Single.prototype._adjustAxis = function () {
    var rect = this._rect;
    var axis = this._axis;
    var isHorizontal = axis.isHorizontal();
    var extent = isHorizontal ? [0, rect.width] : [0, rect.height];
    var idx = axis.reverse ? 1 : 0;
    axis.setExtent(extent[idx], extent[1 - idx]);

    this._updateAxisTransform(axis, isHorizontal ? rect.x : rect.y);
  };

  Single.prototype._updateAxisTransform = function (axis, coordBase) {
    var axisExtent = axis.getExtent();
    var extentSum = axisExtent[0] + axisExtent[1];
    var isHorizontal = axis.isHorizontal();
    axis.toGlobalCoord = isHorizontal ? function (coord) {
      return coord + coordBase;
    } : function (coord) {
      return extentSum - coord + coordBase;
    };
    axis.toLocalCoord = isHorizontal ? function (coord) {
      return coord - coordBase;
    } : function (coord) {
      return extentSum - coord + coordBase;
    };
  };
  /**
   * Get axis.
   */


  Single.prototype.getAxis = function () {
    return this._axis;
  };
  /**
   * Get axis, add it just for draw tooltip.
   */


  Single.prototype.getBaseAxis = function () {
    return this._axis;
  };

  Single.prototype.getAxes = function () {
    return [this._axis];
  };

  Single.prototype.getTooltipAxes = function () {
    return {
      baseAxes: [this.getAxis()],
      // Empty otherAxes
      otherAxes: []
    };
  };
  /**
   * If contain point.
   */


  Single.prototype.containPoint = function (point) {
    var rect = this.getRect();
    var axis = this.getAxis();
    var orient = axis.orient;

    if (orient === 'horizontal') {
      return axis.contain(axis.toLocalCoord(point[0])) && point[1] >= rect.y && point[1] <= rect.y + rect.height;
    } else {
      return axis.contain(axis.toLocalCoord(point[1])) && point[0] >= rect.y && point[0] <= rect.y + rect.height;
    }
  };

  Single.prototype.pointToData = function (point) {
    var axis = this.getAxis();
    return [axis.coordToData(axis.toLocalCoord(point[axis.orient === 'horizontal' ? 0 : 1]))];
  };
  /**
   * Convert the series data to concrete point.
   * Can be [val] | val
   */


  Single.prototype.dataToPoint = function (val) {
    var axis = this.getAxis();
    var rect = this.getRect();
    var pt = [];
    var idx = axis.orient === 'horizontal' ? 0 : 1;

    if (val instanceof Array) {
      val = val[0];
    }

    pt[idx] = axis.toGlobalCoord(axis.dataToCoord(+val));
    pt[1 - idx] = idx === 0 ? rect.y + rect.height / 2 : rect.x + rect.width / 2;
    return pt;
  };

  Single.prototype.convertToPixel = function (ecModel, finder, value) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? this.dataToPoint(value) : null;
  };

  Single.prototype.convertFromPixel = function (ecModel, finder, pixel) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? this.pointToData(pixel) : null;
  };

  return Single;
}();

function getCoordSys(finder) {
  var seriesModel = finder.seriesModel;
  var singleModel = finder.singleAxisModel;
  return singleModel && singleModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Single);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/single/SingleAxis.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/single/SingleAxis.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Axis */ "./node_modules/echarts/lib/coord/Axis.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var SingleAxis =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SingleAxis, _super);

  function SingleAxis(dim, scale, coordExtent, axisType, position) {
    var _this = _super.call(this, dim, scale, coordExtent) || this;

    _this.type = axisType || 'value';
    _this.position = position || 'bottom';
    return _this;
  }
  /**
   * Judge the orient of the axis.
   */


  SingleAxis.prototype.isHorizontal = function () {
    var position = this.position;
    return position === 'top' || position === 'bottom';
  };

  SingleAxis.prototype.pointToData = function (point, clamp) {
    return this.coordinateSystem.pointToData(point)[0];
  };

  return SingleAxis;
}(_Axis__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SingleAxis);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/single/singleAxisHelper.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/single/singleAxisHelper.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "layout": () => (/* binding */ layout)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

function layout(axisModel, opt) {
  opt = opt || {};
  var single = axisModel.coordinateSystem;
  var axis = axisModel.axis;
  var layout = {};
  var axisPosition = axis.position;
  var orient = axis.orient;
  var rect = single.getRect();
  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  var positionMap = {
    horizontal: {
      top: rectBound[2],
      bottom: rectBound[3]
    },
    vertical: {
      left: rectBound[0],
      right: rectBound[1]
    }
  };
  layout.position = [orient === 'vertical' ? positionMap.vertical[axisPosition] : rectBound[0], orient === 'horizontal' ? positionMap.horizontal[axisPosition] : rectBound[3]];
  var r = {
    horizontal: 0,
    vertical: 1
  };
  layout.rotation = Math.PI / 2 * r[orient];
  var directionMap = {
    top: -1,
    bottom: 1,
    right: 1,
    left: -1
  };
  layout.labelDirection = layout.tickDirection = layout.nameDirection = directionMap[axisPosition];

  if (axisModel.get(['axisTick', 'inside'])) {
    layout.tickDirection = -layout.tickDirection;
  }

  if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.retrieve(opt.labelInside, axisModel.get(['axisLabel', 'inside']))) {
    layout.labelDirection = -layout.labelDirection;
  }

  var labelRotation = opt.rotate;
  labelRotation == null && (labelRotation = axisModel.get(['axisLabel', 'rotate']));
  layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;
  layout.z2 = 1;
  return layout;
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/single/singleCreator.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/single/singleCreator.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Single__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Single */ "./node_modules/echarts/lib/coord/single/Single.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Single coordinate system creator.
 */


/**
 * Create single coordinate system and inject it into seriesModel.
 */

function create(ecModel, api) {
  var singles = [];
  ecModel.eachComponent('singleAxis', function (axisModel, idx) {
    var single = new _Single__WEBPACK_IMPORTED_MODULE_0__.default(axisModel, ecModel, api);
    single.name = 'single_' + idx;
    single.resize(axisModel, api);
    axisModel.coordinateSystem = single;
    singles.push(single);
  });
  ecModel.eachSeries(function (seriesModel) {
    if (seriesModel.get('coordinateSystem') === 'singleAxis') {
      var singleAxisModel = seriesModel.getReferringComponents('singleAxis', _util_model__WEBPACK_IMPORTED_MODULE_1__.SINGLE_REFERRING).models[0];
      seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem;
    }
  });
  return singles;
}

var singleCreator = {
  create: create,
  dimensions: _Single__WEBPACK_IMPORTED_MODULE_0__.default.prototype.dimensions
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (singleCreator);

/***/ }),

/***/ "./node_modules/echarts/lib/export/components.js":
/*!*******************************************************!*\
  !*** ./node_modules/echarts/lib/export/components.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GridSimpleComponent": () => (/* reexport safe */ _component_grid_installSimple__WEBPACK_IMPORTED_MODULE_0__.install),
/* harmony export */   "GridComponent": () => (/* reexport safe */ _component_grid_install__WEBPACK_IMPORTED_MODULE_1__.install),
/* harmony export */   "PolarComponent": () => (/* reexport safe */ _component_polar_install__WEBPACK_IMPORTED_MODULE_2__.install),
/* harmony export */   "RadarComponent": () => (/* reexport safe */ _component_radar_install__WEBPACK_IMPORTED_MODULE_3__.install),
/* harmony export */   "GeoComponent": () => (/* reexport safe */ _component_geo_install__WEBPACK_IMPORTED_MODULE_4__.install),
/* harmony export */   "SingleAxisComponent": () => (/* reexport safe */ _component_singleAxis_install__WEBPACK_IMPORTED_MODULE_5__.install),
/* harmony export */   "ParallelComponent": () => (/* reexport safe */ _component_parallel_install__WEBPACK_IMPORTED_MODULE_6__.install),
/* harmony export */   "CalendarComponent": () => (/* reexport safe */ _component_calendar_install__WEBPACK_IMPORTED_MODULE_7__.install),
/* harmony export */   "GraphicComponent": () => (/* reexport safe */ _component_graphic_install__WEBPACK_IMPORTED_MODULE_8__.install),
/* harmony export */   "ToolboxComponent": () => (/* reexport safe */ _component_toolbox_install__WEBPACK_IMPORTED_MODULE_9__.install),
/* harmony export */   "TooltipComponent": () => (/* reexport safe */ _component_tooltip_install__WEBPACK_IMPORTED_MODULE_10__.install),
/* harmony export */   "AxisPointerComponent": () => (/* reexport safe */ _component_axisPointer_install__WEBPACK_IMPORTED_MODULE_11__.install),
/* harmony export */   "BrushComponent": () => (/* reexport safe */ _component_brush_install__WEBPACK_IMPORTED_MODULE_12__.install),
/* harmony export */   "TitleComponent": () => (/* reexport safe */ _component_title_install__WEBPACK_IMPORTED_MODULE_13__.install),
/* harmony export */   "TimelineComponent": () => (/* reexport safe */ _component_timeline_install__WEBPACK_IMPORTED_MODULE_14__.install),
/* harmony export */   "MarkPointComponent": () => (/* reexport safe */ _component_marker_installMarkPoint__WEBPACK_IMPORTED_MODULE_15__.install),
/* harmony export */   "MarkLineComponent": () => (/* reexport safe */ _component_marker_installMarkLine__WEBPACK_IMPORTED_MODULE_16__.install),
/* harmony export */   "MarkAreaComponent": () => (/* reexport safe */ _component_marker_installMarkArea__WEBPACK_IMPORTED_MODULE_17__.install),
/* harmony export */   "LegendComponent": () => (/* reexport safe */ _component_legend_install__WEBPACK_IMPORTED_MODULE_18__.install),
/* harmony export */   "LegendScrollComponent": () => (/* reexport safe */ _component_legend_installLegendScroll__WEBPACK_IMPORTED_MODULE_19__.install),
/* harmony export */   "LegendPlainComponent": () => (/* reexport safe */ _component_legend_installLegendPlain__WEBPACK_IMPORTED_MODULE_20__.install),
/* harmony export */   "DataZoomComponent": () => (/* reexport safe */ _component_dataZoom_install__WEBPACK_IMPORTED_MODULE_21__.install),
/* harmony export */   "DataZoomInsideComponent": () => (/* reexport safe */ _component_dataZoom_installDataZoomInside__WEBPACK_IMPORTED_MODULE_22__.install),
/* harmony export */   "DataZoomSliderComponent": () => (/* reexport safe */ _component_dataZoom_installDataZoomSlider__WEBPACK_IMPORTED_MODULE_23__.install),
/* harmony export */   "VisualMapComponent": () => (/* reexport safe */ _component_visualMap_install__WEBPACK_IMPORTED_MODULE_24__.install),
/* harmony export */   "VisualMapContinuousComponent": () => (/* reexport safe */ _component_visualMap_installVisualMapContinuous__WEBPACK_IMPORTED_MODULE_25__.install),
/* harmony export */   "VisualMapPiecewiseComponent": () => (/* reexport safe */ _component_visualMap_installVisualMapPiecewise__WEBPACK_IMPORTED_MODULE_26__.install),
/* harmony export */   "AriaComponent": () => (/* reexport safe */ _component_aria_install__WEBPACK_IMPORTED_MODULE_27__.install),
/* harmony export */   "TransformComponent": () => (/* reexport safe */ _component_transform_install__WEBPACK_IMPORTED_MODULE_28__.install),
/* harmony export */   "DatasetComponent": () => (/* reexport safe */ _component_dataset_install__WEBPACK_IMPORTED_MODULE_29__.install)
/* harmony export */ });
/* harmony import */ var _component_grid_installSimple__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/grid/installSimple */ "./node_modules/echarts/lib/component/grid/installSimple.js");
/* harmony import */ var _component_grid_install__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/grid/install */ "./node_modules/echarts/lib/component/grid/install.js");
/* harmony import */ var _component_polar_install__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../component/polar/install */ "./node_modules/echarts/lib/component/polar/install.js");
/* harmony import */ var _component_radar_install__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/radar/install */ "./node_modules/echarts/lib/component/radar/install.js");
/* harmony import */ var _component_geo_install__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../component/geo/install */ "./node_modules/echarts/lib/component/geo/install.js");
/* harmony import */ var _component_singleAxis_install__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component/singleAxis/install */ "./node_modules/echarts/lib/component/singleAxis/install.js");
/* harmony import */ var _component_parallel_install__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/parallel/install */ "./node_modules/echarts/lib/component/parallel/install.js");
/* harmony import */ var _component_calendar_install__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/calendar/install */ "./node_modules/echarts/lib/component/calendar/install.js");
/* harmony import */ var _component_graphic_install__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/graphic/install */ "./node_modules/echarts/lib/component/graphic/install.js");
/* harmony import */ var _component_toolbox_install__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/toolbox/install */ "./node_modules/echarts/lib/component/toolbox/install.js");
/* harmony import */ var _component_tooltip_install__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/tooltip/install */ "./node_modules/echarts/lib/component/tooltip/install.js");
/* harmony import */ var _component_axisPointer_install__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/axisPointer/install */ "./node_modules/echarts/lib/component/axisPointer/install.js");
/* harmony import */ var _component_brush_install__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/brush/install */ "./node_modules/echarts/lib/component/brush/install.js");
/* harmony import */ var _component_title_install__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/title/install */ "./node_modules/echarts/lib/component/title/install.js");
/* harmony import */ var _component_timeline_install__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/timeline/install */ "./node_modules/echarts/lib/component/timeline/install.js");
/* harmony import */ var _component_marker_installMarkPoint__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../component/marker/installMarkPoint */ "./node_modules/echarts/lib/component/marker/installMarkPoint.js");
/* harmony import */ var _component_marker_installMarkLine__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../component/marker/installMarkLine */ "./node_modules/echarts/lib/component/marker/installMarkLine.js");
/* harmony import */ var _component_marker_installMarkArea__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../component/marker/installMarkArea */ "./node_modules/echarts/lib/component/marker/installMarkArea.js");
/* harmony import */ var _component_legend_install__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../component/legend/install */ "./node_modules/echarts/lib/component/legend/install.js");
/* harmony import */ var _component_legend_installLegendScroll__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../component/legend/installLegendScroll */ "./node_modules/echarts/lib/component/legend/installLegendScroll.js");
/* harmony import */ var _component_legend_installLegendPlain__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../component/legend/installLegendPlain */ "./node_modules/echarts/lib/component/legend/installLegendPlain.js");
/* harmony import */ var _component_dataZoom_install__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../component/dataZoom/install */ "./node_modules/echarts/lib/component/dataZoom/install.js");
/* harmony import */ var _component_dataZoom_installDataZoomInside__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../component/dataZoom/installDataZoomInside */ "./node_modules/echarts/lib/component/dataZoom/installDataZoomInside.js");
/* harmony import */ var _component_dataZoom_installDataZoomSlider__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../component/dataZoom/installDataZoomSlider */ "./node_modules/echarts/lib/component/dataZoom/installDataZoomSlider.js");
/* harmony import */ var _component_visualMap_install__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../component/visualMap/install */ "./node_modules/echarts/lib/component/visualMap/install.js");
/* harmony import */ var _component_visualMap_installVisualMapContinuous__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../component/visualMap/installVisualMapContinuous */ "./node_modules/echarts/lib/component/visualMap/installVisualMapContinuous.js");
/* harmony import */ var _component_visualMap_installVisualMapPiecewise__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../component/visualMap/installVisualMapPiecewise */ "./node_modules/echarts/lib/component/visualMap/installVisualMapPiecewise.js");
/* harmony import */ var _component_aria_install__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../component/aria/install */ "./node_modules/echarts/lib/component/aria/install.js");
/* harmony import */ var _component_transform_install__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../component/transform/install */ "./node_modules/echarts/lib/component/transform/install.js");
/* harmony import */ var _component_dataset_install__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../component/dataset/install */ "./node_modules/echarts/lib/component/dataset/install.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/































/***/ }),

/***/ "./node_modules/echarts/lib/layout/barPolar.js":
/*!*****************************************************!*\
  !*** ./node_modules/echarts/lib/layout/barPolar.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _data_helper_dataStackHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/helper/dataStackHelper */ "./node_modules/echarts/lib/data/helper/dataStackHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




function getSeriesStackId(seriesModel) {
  return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;
}

function getAxisKey(polar, axis) {
  return axis.dim + polar.model.componentIndex;
}

function barLayoutPolar(seriesType, ecModel, api) {
  var lastStackCoords = {};
  var barWidthAndOffset = calRadialBar(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {
    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'polar';
  }));
  ecModel.eachSeriesByType(seriesType, function (seriesModel) {
    // Check series coordinate, do layout for polar only
    if (seriesModel.coordinateSystem.type !== 'polar') {
      return;
    }

    var data = seriesModel.getData();
    var polar = seriesModel.coordinateSystem;
    var baseAxis = polar.getBaseAxis();
    var axisKey = getAxisKey(polar, baseAxis);
    var stackId = getSeriesStackId(seriesModel);
    var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];
    var columnOffset = columnLayoutInfo.offset;
    var columnWidth = columnLayoutInfo.width;
    var valueAxis = polar.getOtherAxis(baseAxis);
    var cx = seriesModel.coordinateSystem.cx;
    var cy = seriesModel.coordinateSystem.cy;
    var barMinHeight = seriesModel.get('barMinHeight') || 0;
    var barMinAngle = seriesModel.get('barMinAngle') || 0;
    lastStackCoords[stackId] = lastStackCoords[stackId] || [];
    var valueDim = data.mapDimension(valueAxis.dim);
    var baseDim = data.mapDimension(baseAxis.dim);
    var stacked = (0,_data_helper_dataStackHelper__WEBPACK_IMPORTED_MODULE_1__.isDimensionStacked)(data, valueDim
    /*, baseDim*/
    );
    var clampLayout = baseAxis.dim !== 'radius' || !seriesModel.get('roundCap', true);
    var valueAxisStart = valueAxis.dataToCoord(0);

    for (var idx = 0, len = data.count(); idx < len; idx++) {
      var value = data.get(valueDim, idx);
      var baseValue = data.get(baseDim, idx);
      var sign = value >= 0 ? 'p' : 'n';
      var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in
      // stackResultDimension directly.
      // Only ordinal axis can be stacked.

      if (stacked) {
        if (!lastStackCoords[stackId][baseValue]) {
          lastStackCoords[stackId][baseValue] = {
            p: valueAxisStart,
            n: valueAxisStart // Negative stack

          };
        } // Should also consider #4243


        baseCoord = lastStackCoords[stackId][baseValue][sign];
      }

      var r0 = void 0;
      var r = void 0;
      var startAngle = void 0;
      var endAngle = void 0; // radial sector

      if (valueAxis.dim === 'radius') {
        var radiusSpan = valueAxis.dataToCoord(value) - valueAxisStart;
        var angle = baseAxis.dataToCoord(baseValue);

        if (Math.abs(radiusSpan) < barMinHeight) {
          radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;
        }

        r0 = baseCoord;
        r = baseCoord + radiusSpan;
        startAngle = angle - columnOffset;
        endAngle = startAngle - columnWidth;
        stacked && (lastStackCoords[stackId][baseValue][sign] = r);
      } // tangential sector
      else {
          var angleSpan = valueAxis.dataToCoord(value, clampLayout) - valueAxisStart;
          var radius = baseAxis.dataToCoord(baseValue);

          if (Math.abs(angleSpan) < barMinAngle) {
            angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;
          }

          r0 = radius + columnOffset;
          r = r0 + columnWidth;
          startAngle = baseCoord;
          endAngle = baseCoord + angleSpan; // if the previous stack is at the end of the ring,
          // add a round to differentiate it from origin
          // let extent = angleAxis.getExtent();
          // let stackCoord = angle;
          // if (stackCoord === extent[0] && value > 0) {
          //     stackCoord = extent[1];
          // }
          // else if (stackCoord === extent[1] && value < 0) {
          //     stackCoord = extent[0];
          // }

          stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);
        }

      data.setItemLayout(idx, {
        cx: cx,
        cy: cy,
        r0: r0,
        r: r,
        // Consider that positive angle is anti-clockwise,
        // while positive radian of sector is clockwise
        startAngle: -startAngle * Math.PI / 180,
        endAngle: -endAngle * Math.PI / 180
      });
    }
  });
}
/**
 * Calculate bar width and offset for radial bar charts
 */


function calRadialBar(barSeries) {
  // Columns info on each category axis. Key is polar name
  var columnsMap = {};
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(barSeries, function (seriesModel, idx) {
    var data = seriesModel.getData();
    var polar = seriesModel.coordinateSystem;
    var baseAxis = polar.getBaseAxis();
    var axisKey = getAxisKey(polar, baseAxis);
    var axisExtent = baseAxis.getExtent();
    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    var columnsOnAxis = columnsMap[axisKey] || {
      bandWidth: bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: '20%',
      gap: '30%',
      stacks: {}
    };
    var stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    var stackId = getSeriesStackId(seriesModel);

    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }

    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    };
    var barWidth = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.parsePercent)(seriesModel.get('barWidth'), bandWidth);
    var barMaxWidth = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.parsePercent)(seriesModel.get('barMaxWidth'), bandWidth);
    var barGap = seriesModel.get('barGap');
    var barCategoryGap = seriesModel.get('barCategoryGap');

    if (barWidth && !stacks[stackId].width) {
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      stacks[stackId].width = barWidth;
      columnsOnAxis.remainedWidth -= barWidth;
    }

    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    barGap != null && (columnsOnAxis.gap = barGap);
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  var result = {};
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(columnsMap, function (columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    var stacks = columnsOnAxis.stacks;
    var bandWidth = columnsOnAxis.bandWidth;
    var categoryGap = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.parsePercent)(columnsOnAxis.categoryGap, bandWidth);
    var barGapPercent = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.parsePercent)(columnsOnAxis.gap, 1);
    var remainedWidth = columnsOnAxis.remainedWidth;
    var autoWidthCount = columnsOnAxis.autoWidthCount;
    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth

    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(stacks, function (column, stack) {
      var maxWidth = column.maxWidth;

      if (maxWidth && maxWidth < autoWidth) {
        maxWidth = Math.min(maxWidth, remainedWidth);

        if (column.width) {
          maxWidth = Math.min(maxWidth, column.width);
        }

        remainedWidth -= maxWidth;
        column.width = maxWidth;
        autoWidthCount--;
      }
    }); // Recalculate width again

    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    var widthSum = 0;
    var lastColumn;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(stacks, function (column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }

      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });

    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }

    var offset = -widthSum / 2;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(stacks, function (column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        offset: offset,
        width: column.width
      };
      offset += column.width * (1 + barGapPercent);
    });
  });
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (barLayoutPolar);

/***/ }),

/***/ "./node_modules/echarts/lib/util/conditionalExpression.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/util/conditionalExpression.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseConditionalExpression": () => (/* binding */ parseConditionalExpression)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log */ "./node_modules/echarts/lib/util/log.js");
/* harmony import */ var _data_helper_dataValueHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/helper/dataValueHelper */ "./node_modules/echarts/lib/data/helper/dataValueHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



;
var RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {
  value: 'eq',
  // PENDING: not good for literal semantic?
  '<': 'lt',
  '<=': 'lte',
  '>': 'gt',
  '>=': 'gte',
  '=': 'eq',
  '!=': 'ne',
  '<>': 'ne' // Might mileading for sake of the different between '==' and '===',
  // So dont support them.
  // '==': 'eq',
  // '===': 'seq',
  // '!==': 'sne'
  // PENDING: Whether support some common alias "ge", "le", "neq"?
  // ge: 'gte',
  // le: 'lte',
  // neq: 'ne',

};

var RegExpEvaluator =
/** @class */
function () {
  function RegExpEvaluator(rVal) {
    // Support condVal: RegExp | string
    var condValue = this._condVal = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isString)(rVal) ? new RegExp(rVal) : (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isRegExp)(rVal) ? rVal : null;

    if (condValue == null) {
      var errMsg = '';

      if (true) {
        errMsg = (0,_log__WEBPACK_IMPORTED_MODULE_1__.makePrintable)('Illegal regexp', rVal, 'in');
      }

      (0,_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
    }
  }

  RegExpEvaluator.prototype.evaluate = function (lVal) {
    var type = typeof lVal;
    return type === 'string' ? this._condVal.test(lVal) : type === 'number' ? this._condVal.test(lVal + '') : false;
  };

  return RegExpEvaluator;
}();

var ConstConditionInternal =
/** @class */
function () {
  function ConstConditionInternal() {}

  ConstConditionInternal.prototype.evaluate = function () {
    return this.value;
  };

  return ConstConditionInternal;
}();

var AndConditionInternal =
/** @class */
function () {
  function AndConditionInternal() {}

  AndConditionInternal.prototype.evaluate = function () {
    var children = this.children;

    for (var i = 0; i < children.length; i++) {
      if (!children[i].evaluate()) {
        return false;
      }
    }

    return true;
  };

  return AndConditionInternal;
}();

var OrConditionInternal =
/** @class */
function () {
  function OrConditionInternal() {}

  OrConditionInternal.prototype.evaluate = function () {
    var children = this.children;

    for (var i = 0; i < children.length; i++) {
      if (children[i].evaluate()) {
        return true;
      }
    }

    return false;
  };

  return OrConditionInternal;
}();

var NotConditionInternal =
/** @class */
function () {
  function NotConditionInternal() {}

  NotConditionInternal.prototype.evaluate = function () {
    return !this.child.evaluate();
  };

  return NotConditionInternal;
}();

var RelationalConditionInternal =
/** @class */
function () {
  function RelationalConditionInternal() {}

  RelationalConditionInternal.prototype.evaluate = function () {
    var needParse = !!this.valueParser; // Call getValue with no `this`.

    var getValue = this.getValue;
    var tarValRaw = getValue(this.valueGetterParam);
    var tarValParsed = needParse ? this.valueParser(tarValRaw) : null; // Relational cond follow "and" logic internally.

    for (var i = 0; i < this.subCondList.length; i++) {
      if (!this.subCondList[i].evaluate(needParse ? tarValParsed : tarValRaw)) {
        return false;
      }
    }

    return true;
  };

  return RelationalConditionInternal;
}();

function parseOption(exprOption, getters) {
  if (exprOption === true || exprOption === false) {
    var cond = new ConstConditionInternal();
    cond.value = exprOption;
    return cond;
  }

  var errMsg = '';

  if (!isObjectNotArray(exprOption)) {
    if (true) {
      errMsg = (0,_log__WEBPACK_IMPORTED_MODULE_1__.makePrintable)('Illegal config. Expect a plain object but actually', exprOption);
    }

    (0,_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
  }

  if (exprOption.and) {
    return parseAndOrOption('and', exprOption, getters);
  } else if (exprOption.or) {
    return parseAndOrOption('or', exprOption, getters);
  } else if (exprOption.not) {
    return parseNotOption(exprOption, getters);
  }

  return parseRelationalOption(exprOption, getters);
}

function parseAndOrOption(op, exprOption, getters) {
  var subOptionArr = exprOption[op];
  var errMsg = '';

  if (true) {
    errMsg = (0,_log__WEBPACK_IMPORTED_MODULE_1__.makePrintable)('"and"/"or" condition should only be `' + op + ': [...]` and must not be empty array.', 'Illegal condition:', exprOption);
  }

  if (!(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(subOptionArr)) {
    (0,_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
  }

  if (!subOptionArr.length) {
    (0,_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
  }

  var cond = op === 'and' ? new AndConditionInternal() : new OrConditionInternal();
  cond.children = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map)(subOptionArr, function (subOption) {
    return parseOption(subOption, getters);
  });

  if (!cond.children.length) {
    (0,_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
  }

  return cond;
}

function parseNotOption(exprOption, getters) {
  var subOption = exprOption.not;
  var errMsg = '';

  if (true) {
    errMsg = (0,_log__WEBPACK_IMPORTED_MODULE_1__.makePrintable)('"not" condition should only be `not: {}`.', 'Illegal condition:', exprOption);
  }

  if (!isObjectNotArray(subOption)) {
    (0,_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
  }

  var cond = new NotConditionInternal();
  cond.child = parseOption(subOption, getters);

  if (!cond.child) {
    (0,_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
  }

  return cond;
}

function parseRelationalOption(exprOption, getters) {
  var errMsg = '';
  var valueGetterParam = getters.prepareGetValue(exprOption);
  var subCondList = [];
  var exprKeys = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.keys)(exprOption);
  var parserName = exprOption.parser;
  var valueParser = parserName ? (0,_data_helper_dataValueHelper__WEBPACK_IMPORTED_MODULE_2__.getRawValueParser)(parserName) : null;

  for (var i = 0; i < exprKeys.length; i++) {
    var keyRaw = exprKeys[i];

    if (keyRaw === 'parser' || getters.valueGetterAttrMap.get(keyRaw)) {
      continue;
    }

    var op = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, keyRaw) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[keyRaw] : keyRaw;
    var condValueRaw = exprOption[keyRaw];
    var condValueParsed = valueParser ? valueParser(condValueRaw) : condValueRaw;
    var evaluator = (0,_data_helper_dataValueHelper__WEBPACK_IMPORTED_MODULE_2__.createFilterComparator)(op, condValueParsed) || op === 'reg' && new RegExpEvaluator(condValueParsed);

    if (!evaluator) {
      if (true) {
        errMsg = (0,_log__WEBPACK_IMPORTED_MODULE_1__.makePrintable)('Illegal relational operation: "' + keyRaw + '" in condition:', exprOption);
      }

      (0,_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
    }

    subCondList.push(evaluator);
  }

  if (!subCondList.length) {
    if (true) {
      errMsg = (0,_log__WEBPACK_IMPORTED_MODULE_1__.makePrintable)('Relational condition must have at least one operator.', 'Illegal condition:', exprOption);
    } // No relational operator always disabled in case of dangers result.


    (0,_log__WEBPACK_IMPORTED_MODULE_1__.throwError)(errMsg);
  }

  var cond = new RelationalConditionInternal();
  cond.valueGetterParam = valueGetterParam;
  cond.valueParser = valueParser;
  cond.getValue = getters.getValue;
  cond.subCondList = subCondList;
  return cond;
}

function isObjectNotArray(val) {
  return (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(val) && !(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArrayLike)(val);
}

var ConditionalExpressionParsed =
/** @class */
function () {
  function ConditionalExpressionParsed(exprOption, getters) {
    this._cond = parseOption(exprOption, getters);
  }

  ConditionalExpressionParsed.prototype.evaluate = function () {
    return this._cond.evaluate();
  };

  return ConditionalExpressionParsed;
}();

;
function parseConditionalExpression(exprOption, getters) {
  return new ConditionalExpressionParsed(exprOption, getters);
}

/***/ }),

/***/ "./node_modules/echarts/lib/visual/aria.js":
/*!*************************************************!*\
  !*** ./node_modules/echarts/lib/visual/aria.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ariaVisual)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _data_helper_dataProvider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../data/helper/dataProvider */ "./node_modules/echarts/lib/data/helper/dataProvider.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _model_mixin_palette__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/mixin/palette */ "./node_modules/echarts/lib/model/mixin/palette.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var DEFAULT_OPTION = {
  label: {
    enabled: true
  },
  decal: {
    show: false
  }
};
var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();
var decalPaletteScope = {};
function ariaVisual(ecModel, api) {
  var ariaModel = ecModel.getModel('aria'); // See "area enabled" detection code in `GlobalModel.ts`.

  if (!ariaModel.get('enabled')) {
    return;
  }

  var defaultOption = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone(DEFAULT_OPTION);
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge(defaultOption.label, ecModel.getLocaleModel().get('aria'), false);
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge(ariaModel.option, defaultOption, false);
  setDecal();
  setLabel();

  function setDecal() {
    var decalModel = ariaModel.getModel('decal');
    var useDecal = decalModel.get('show');

    if (useDecal) {
      // Each type of series use one scope.
      // Pie and funnel are using diferrent scopes
      var paletteScopeGroupByType_1 = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.createHashMap();
      ecModel.eachSeries(function (seriesModel) {
        if (!seriesModel.useColorPaletteOnData) {
          return;
        }

        var decalScope = paletteScopeGroupByType_1.get(seriesModel.type);

        if (!decalScope) {
          decalScope = {};
          paletteScopeGroupByType_1.set(seriesModel.type, decalScope);
        }

        inner(seriesModel).scope = decalScope;
      });
      ecModel.eachRawSeries(function (seriesModel) {
        if (ecModel.isSeriesFiltered(seriesModel)) {
          return;
        }

        if (typeof seriesModel.enableAriaDecal === 'function') {
          // Let series define how to use decal palette on data
          seriesModel.enableAriaDecal();
          return;
        }

        var data = seriesModel.getData();

        if (seriesModel.useColorPaletteOnData) {
          var dataAll_1 = seriesModel.getRawData();
          var idxMap_1 = {};
          var decalScope_1 = inner(seriesModel).scope;
          data.each(function (idx) {
            var rawIdx = data.getRawIndex(idx);
            idxMap_1[rawIdx] = idx;
          });
          var dataCount_1 = dataAll_1.count();
          dataAll_1.each(function (rawIdx) {
            var idx = idxMap_1[rawIdx];
            var name = dataAll_1.getName(rawIdx) || rawIdx + '';
            var paletteDecal = (0,_model_mixin_palette__WEBPACK_IMPORTED_MODULE_2__.getDecalFromPalette)(seriesModel.ecModel, name, decalScope_1, dataCount_1);
            var specifiedDecal = data.getItemVisual(idx, 'decal');
            data.setItemVisual(idx, 'decal', mergeDecal(specifiedDecal, paletteDecal));
          });
        } else {
          var paletteDecal = (0,_model_mixin_palette__WEBPACK_IMPORTED_MODULE_2__.getDecalFromPalette)(seriesModel.ecModel, seriesModel.name, decalPaletteScope, ecModel.getSeriesCount());
          var specifiedDecal = data.getVisual('decal');
          data.setVisual('decal', mergeDecal(specifiedDecal, paletteDecal));
        }

        function mergeDecal(specifiedDecal, paletteDecal) {
          // Merge decal from palette to decal from itemStyle.
          // User do not need to specify all of the decal props.
          var resultDecal = specifiedDecal ? zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend({}, paletteDecal), specifiedDecal) : paletteDecal;
          resultDecal.dirty = true;
          return resultDecal;
        }
      });
    }
  }

  function setLabel() {
    var labelLocale = ecModel.getLocaleModel().get('aria');
    var labelModel = ariaModel.getModel('label');
    labelModel.option = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults(labelModel.option, labelLocale);

    if (!labelModel.get('enabled')) {
      return;
    }

    var dom = api.getZr().dom;

    if (labelModel.get('description')) {
      dom.setAttribute('aria-label', labelModel.get('description'));
      return;
    }

    var seriesCnt = ecModel.getSeriesCount();
    var maxDataCnt = labelModel.get(['data', 'maxCount']) || 10;
    var maxSeriesCnt = labelModel.get(['series', 'maxCount']) || 10;
    var displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);
    var ariaLabel;

    if (seriesCnt < 1) {
      // No series, no aria label
      return;
    } else {
      var title = getTitle();

      if (title) {
        var withTitle = labelModel.get(['general', 'withTitle']);
        ariaLabel = replace(withTitle, {
          title: title
        });
      } else {
        ariaLabel = labelModel.get(['general', 'withoutTitle']);
      }

      var seriesLabels_1 = [];
      var prefix = seriesCnt > 1 ? labelModel.get(['series', 'multiple', 'prefix']) : labelModel.get(['series', 'single', 'prefix']);
      ariaLabel += replace(prefix, {
        seriesCount: seriesCnt
      });
      ecModel.eachSeries(function (seriesModel, idx) {
        if (idx < displaySeriesCnt) {
          var seriesLabel = void 0;
          var seriesName = seriesModel.get('name');
          var withName = seriesName ? 'withName' : 'withoutName';
          seriesLabel = seriesCnt > 1 ? labelModel.get(['series', 'multiple', withName]) : labelModel.get(['series', 'single', withName]);
          seriesLabel = replace(seriesLabel, {
            seriesId: seriesModel.seriesIndex,
            seriesName: seriesModel.get('name'),
            seriesType: getSeriesTypeName(seriesModel.subType)
          });
          var data = seriesModel.getData();

          if (data.count() > maxDataCnt) {
            // Show part of data
            var partialLabel = labelModel.get(['data', 'partialData']);
            seriesLabel += replace(partialLabel, {
              displayCnt: maxDataCnt
            });
          } else {
            seriesLabel += labelModel.get(['data', 'allData']);
          }

          var dataLabels = [];

          for (var i = 0; i < data.count(); i++) {
            if (i < maxDataCnt) {
              var name_1 = data.getName(i);
              var value = (0,_data_helper_dataProvider__WEBPACK_IMPORTED_MODULE_3__.retrieveRawValue)(data, i);
              var dataLabel = labelModel.get(['data', name_1 ? 'withName' : 'withoutName']);
              dataLabels.push(replace(dataLabel, {
                name: name_1,
                value: value
              }));
            }
          }

          var middleSeparator_1 = labelModel.get(['data', 'separator', 'middle']);
          var endSeparator_1 = labelModel.get(['data', 'separator', 'end']);
          seriesLabel += dataLabels.join(middleSeparator_1) + endSeparator_1;
          seriesLabels_1.push(seriesLabel);
        }
      });
      var separatorModel = labelModel.getModel(['series', 'multiple', 'separator']);
      var middleSeparator = separatorModel.get('middle');
      var endSeparator = separatorModel.get('end');
      ariaLabel += seriesLabels_1.join(middleSeparator) + endSeparator;
      dom.setAttribute('aria-label', ariaLabel);
    }
  }

  function replace(str, keyValues) {
    if (typeof str !== 'string') {
      return str;
    }

    var result = str;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(keyValues, function (value, key) {
      result = result.replace(new RegExp('\\{\\s*' + key + '\\s*\\}', 'g'), value);
    });
    return result;
  }

  function getTitle() {
    var title = ecModel.get('title');

    if (title && title.length) {
      title = title[0];
    }

    return title && title.text;
  }

  function getSeriesTypeName(type) {
    return ecModel.getLocaleModel().get(['series', 'typeNames'])[type] || '自定义图';
  }
}

/***/ }),

/***/ "./node_modules/echarts/lib/visual/visualDefault.js":
/*!**********************************************************!*\
  !*** ./node_modules/echarts/lib/visual/visualDefault.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @file Visual mapping.
 */

var visualDefault = {
  /**
   * @public
   */
  get: function (visualType, key, isCategory) {
    var value = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.clone((defaultOption[visualType] || {})[key]);
    return isCategory ? zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(value) ? value[value.length - 1] : value : value;
  }
};
var defaultOption = {
  color: {
    active: ['#006edd', '#e0ffff'],
    inactive: ['rgba(0,0,0,0)']
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ['circle', 'roundRect', 'diamond'],
    inactive: ['none']
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (visualDefault);

/***/ }),

/***/ "./node_modules/echarts/lib/visual/visualSolution.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/visual/visualSolution.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createVisualMappings": () => (/* binding */ createVisualMappings),
/* harmony export */   "replaceVisualOption": () => (/* binding */ replaceVisualOption),
/* harmony export */   "applyVisual": () => (/* binding */ applyVisual),
/* harmony export */   "incrementalApplyVisual": () => (/* binding */ incrementalApplyVisual)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _VisualMapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VisualMapping */ "./node_modules/echarts/lib/visual/VisualMapping.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helper */ "./node_modules/echarts/lib/visual/helper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * @file Visual solution, for consistent option specification.
 */



var each = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each;

function hasKeys(obj) {
  if (obj) {
    for (var name_1 in obj) {
      if (obj.hasOwnProperty(name_1)) {
        return true;
      }
    }
  }
}

function createVisualMappings(option, stateList, supplementVisualOption) {
  var visualMappings = {};
  each(stateList, function (state) {
    var mappings = visualMappings[state] = createMappings();
    each(option[state], function (visualData, visualType) {
      if (!_VisualMapping__WEBPACK_IMPORTED_MODULE_1__.default.isValidType(visualType)) {
        return;
      }

      var mappingOption = {
        type: visualType,
        visual: visualData
      };
      supplementVisualOption && supplementVisualOption(mappingOption, state);
      mappings[visualType] = new _VisualMapping__WEBPACK_IMPORTED_MODULE_1__.default(mappingOption); // Prepare a alpha for opacity, for some case that opacity
      // is not supported, such as rendering using gradient color.

      if (visualType === 'opacity') {
        mappingOption = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.clone(mappingOption);
        mappingOption.type = 'colorAlpha';
        mappings.__hidden.__alphaForOpacity = new _VisualMapping__WEBPACK_IMPORTED_MODULE_1__.default(mappingOption);
      }
    });
  });
  return visualMappings;

  function createMappings() {
    var Creater = function () {}; // Make sure hidden fields will not be visited by
    // object iteration (with hasOwnProperty checking).


    Creater.prototype.__hidden = Creater.prototype;
    var obj = new Creater();
    return obj;
  }
}
function replaceVisualOption(thisOption, newOption, keys) {
  // Visual attributes merge is not supported, otherwise it
  // brings overcomplicated merge logic. See #2853. So if
  // newOption has anyone of these keys, all of these keys
  // will be reset. Otherwise, all keys remain.
  var has;
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(keys, function (key) {
    if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
      has = true;
    }
  });
  has && zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(keys, function (key) {
    if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
      thisOption[key] = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.clone(newOption[key]);
    } else {
      delete thisOption[key];
    }
  });
}
/**
 * @param stateList
 * @param visualMappings
 * @param list
 * @param getValueState param: valueOrIndex, return: state.
 * @param scope Scope for getValueState
 * @param dimension Concrete dimension, if used.
 */
// ???! handle brush?

function applyVisual(stateList, visualMappings, data, getValueState, scope, dimension) {
  var visualTypesMap = {};
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(stateList, function (state) {
    var visualTypes = _VisualMapping__WEBPACK_IMPORTED_MODULE_1__.default.prepareVisualTypes(visualMappings[state]);
    visualTypesMap[state] = visualTypes;
  });
  var dataIndex;

  function getVisual(key) {
    return (0,_helper__WEBPACK_IMPORTED_MODULE_2__.getItemVisualFromData)(data, dataIndex, key);
  }

  function setVisual(key, value) {
    (0,_helper__WEBPACK_IMPORTED_MODULE_2__.setItemVisualFromData)(data, dataIndex, key, value);
  }

  if (dimension == null) {
    data.each(eachItem);
  } else {
    data.each([dimension], eachItem);
  }

  function eachItem(valueOrIndex, index) {
    dataIndex = dimension == null ? valueOrIndex // First argument is index
    : index;
    var rawDataItem = data.getRawDataItem(dataIndex); // Consider performance
    // @ts-ignore

    if (rawDataItem && rawDataItem.visualMap === false) {
      return;
    }

    var valueState = getValueState.call(scope, valueOrIndex);
    var mappings = visualMappings[valueState];
    var visualTypes = visualTypesMap[valueState];

    for (var i = 0, len = visualTypes.length; i < len; i++) {
      var type = visualTypes[i];
      mappings[type] && mappings[type].applyVisual(valueOrIndex, getVisual, setVisual);
    }
  }
}
/**
 * @param data
 * @param stateList
 * @param visualMappings <state, Object.<visualType, module:echarts/visual/VisualMapping>>
 * @param getValueState param: valueOrIndex, return: state.
 * @param dim dimension or dimension index.
 */

function incrementalApplyVisual(stateList, visualMappings, getValueState, dim) {
  var visualTypesMap = {};
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(stateList, function (state) {
    var visualTypes = _VisualMapping__WEBPACK_IMPORTED_MODULE_1__.default.prepareVisualTypes(visualMappings[state]);
    visualTypesMap[state] = visualTypes;
  });
  return {
    progress: function progress(params, data) {
      var dimName;

      if (dim != null) {
        dimName = data.getDimension(dim);
      }

      function getVisual(key) {
        return (0,_helper__WEBPACK_IMPORTED_MODULE_2__.getItemVisualFromData)(data, dataIndex, key);
      }

      function setVisual(key, value) {
        (0,_helper__WEBPACK_IMPORTED_MODULE_2__.setItemVisualFromData)(data, dataIndex, key, value);
      }

      var dataIndex;

      while ((dataIndex = params.next()) != null) {
        var rawDataItem = data.getRawDataItem(dataIndex); // Consider performance
        // @ts-ignore

        if (rawDataItem && rawDataItem.visualMap === false) {
          continue;
        }

        var value = dim != null ? data.get(dimName, dataIndex) : dataIndex;
        var valueState = getValueState(value);
        var mappings = visualMappings[valueState];
        var visualTypes = visualTypesMap[valueState];

        for (var i = 0, len = visualTypes.length; i < len; i++) {
          var type = visualTypes[i];
          mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);
        }
      }
    }
  };
}

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvY29tcG9uZW50cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9hcmlhL2luc3RhbGwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXJpYS9wcmVwcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9BbmdsZUF4aXNWaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvUmFkaXVzQXhpc1ZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9TaW5nbGVBeGlzVmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9BeGlzUG9pbnRlck1vZGVsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0F4aXNQb2ludGVyVmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9CYXNlQXhpc1BvaW50ZXIuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvQ2FydGVzaWFuQXhpc1BvaW50ZXIuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvUG9sYXJBeGlzUG9pbnRlci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9TaW5nbGVBeGlzUG9pbnRlci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9heGlzVHJpZ2dlci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9maW5kUG9pbnRGcm9tU2VyaWVzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL2dsb2JhbExpc3RlbmVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL2luc3RhbGwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvdmlld0hlbHBlci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9icnVzaC9CcnVzaE1vZGVsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2JydXNoL0JydXNoVmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9icnVzaC9pbnN0YWxsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2JydXNoL3ByZXByb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9icnVzaC9zZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9icnVzaC92aXN1YWxFbmNvZGluZy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9jYWxlbmRhci9DYWxlbmRhclZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvY2FsZW5kYXIvaW5zdGFsbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9BeGlzUHJveHkuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21Nb2RlbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbVZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vSW5zaWRlWm9vbU1vZGVsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0luc2lkZVpvb21WaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL1NlbGVjdFpvb21Nb2RlbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TZWxlY3Rab29tVmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TbGlkZXJab29tTW9kZWwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vU2xpZGVyWm9vbVZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vZGF0YVpvb21BY3Rpb24uanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vZGF0YVpvb21Qcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaGVscGVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaW5zdGFsbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9pbnN0YWxsQ29tbW9uLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2luc3RhbGxEYXRhWm9vbUluc2lkZS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9pbnN0YWxsRGF0YVpvb21TZWxlY3QuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaW5zdGFsbERhdGFab29tU2xpZGVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL3JvYW1zLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFzZXQvaW5zdGFsbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9ncmFwaGljL2luc3RhbGwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZ3JpZC9pbnN0YWxsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9CcnVzaFRhcmdldE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2xpc3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL0xlZ2VuZE1vZGVsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9MZWdlbmRWaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9TY3JvbGxhYmxlTGVnZW5kTW9kZWwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL1Njcm9sbGFibGVMZWdlbmRWaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9pbnN0YWxsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9pbnN0YWxsTGVnZW5kUGxhaW4uanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL2luc3RhbGxMZWdlbmRTY3JvbGwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL2xlZ2VuZEFjdGlvbi5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kRmlsdGVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9zY3JvbGxhYmxlTGVnZW5kQWN0aW9uLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrQXJlYU1vZGVsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrQXJlYVZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtMaW5lTW9kZWwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtMaW5lVmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya1BvaW50TW9kZWwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtQb2ludFZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtlck1vZGVsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrZXJWaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9pbnN0YWxsTWFya0FyZWEuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL2luc3RhbGxNYXJrTGluZS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvaW5zdGFsbE1hcmtQb2ludC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvbWFya2VySGVscGVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3BvbGFyL2luc3RhbGwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvc2luZ2xlQXhpcy9pbnN0YWxsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3RpbWVsaW5lL1NsaWRlclRpbWVsaW5lTW9kZWwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdGltZWxpbmUvU2xpZGVyVGltZWxpbmVWaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3RpbWVsaW5lL1RpbWVsaW5lQXhpcy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90aW1lbGluZS9UaW1lbGluZU1vZGVsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3RpbWVsaW5lL1RpbWVsaW5lVmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90aW1lbGluZS9pbnN0YWxsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3RpbWVsaW5lL3ByZXByb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90aW1lbGluZS90aW1lbGluZUFjdGlvbi5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90aXRsZS9pbnN0YWxsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvVG9vbGJveE1vZGVsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvVG9vbGJveFZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL0JydXNoLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9EYXRhVmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvRGF0YVpvb20uanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL01hZ2ljVHlwZS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvUmVzdG9yZS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvU2F2ZUFzSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2luc3RhbGwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwSFRNTENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwTW9kZWwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwUmljaENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwVmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL2hlbHBlci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL2luc3RhbGwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdHJhbnNmb3JtL2ZpbHRlclRyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90cmFuc2Zvcm0vaW5zdGFsbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90cmFuc2Zvcm0vc29ydFRyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC92aXN1YWxNYXAvQ29udGludW91c01vZGVsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Zpc3VhbE1hcC9Db250aW51b3VzVmlldy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC92aXN1YWxNYXAvUGllY2V3aXNlTW9kZWwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdmlzdWFsTWFwL1BpZWNld2lzZVZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdmlzdWFsTWFwL1Zpc3VhbE1hcE1vZGVsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Zpc3VhbE1hcC9WaXN1YWxNYXBWaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Zpc3VhbE1hcC9oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdmlzdWFsTWFwL2luc3RhbGwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdmlzdWFsTWFwL2luc3RhbGxDb21tb24uanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdmlzdWFsTWFwL2luc3RhbGxWaXN1YWxNYXBDb250aW51b3VzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Zpc3VhbE1hcC9pbnN0YWxsVmlzdWFsTWFwUGllY2V3aXNlLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Zpc3VhbE1hcC9wcmVwcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdmlzdWFsTWFwL3Zpc3VhbEVuY29kaW5nLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Zpc3VhbE1hcC92aXN1YWxNYXBBY3Rpb24uanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYWxlbmRhci9DYWxlbmRhci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhbGVuZGFyL0NhbGVuZGFyTW9kZWwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9wb2xhci9BbmdsZUF4aXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9wb2xhci9BeGlzTW9kZWwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9wb2xhci9Qb2xhci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL3BvbGFyL1BvbGFyTW9kZWwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9wb2xhci9SYWRpdXNBeGlzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvcG9sYXIvcG9sYXJDcmVhdG9yLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvc2luZ2xlL0F4aXNNb2RlbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL3NpbmdsZS9TaW5nbGUuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9zaW5nbGUvU2luZ2xlQXhpcy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL3NpbmdsZS9zaW5nbGVBeGlzSGVscGVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvc2luZ2xlL3NpbmdsZUNyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9leHBvcnQvY29tcG9uZW50cy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2xheW91dC9iYXJQb2xhci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvY29uZGl0aW9uYWxFeHByZXNzaW9uLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlzdWFsL2FyaWEuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aXN1YWwvdmlzdWFsRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Zpc3VhbC92aXN1YWxTb2x1dGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkM7QUFDRztBQUN2QztBQUNQLGlDQUFpQyxrREFBZ0I7QUFDakQsMkRB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMsQ0FBQyxxREFBYTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxpRUFBZSxVQUFVLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN2V6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQ007QUFDOEI7QUFDVjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnREFBUzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsTUFBTSxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuUHJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0M7QUFDUDs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnREFBUzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLENBQUMsMENBQUk7O0FBRU4saUVB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QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEMiLCJmaWxlIjoiZGFzaGJvYXJkL2pzL2Rhc2hib2FyZGVkZWFlYmQ3Zjk4MzA5YmY1MThiLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuZXhwb3J0ICogZnJvbSAnLi9saWIvZXhwb3J0L2NvbXBvbmVudHMnOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgYXJpYVZpc3VhbCBmcm9tICcuLi8uLi92aXN1YWwvYXJpYSc7XG5pbXBvcnQgYXJpYVByZXByb2Nlc3NvciBmcm9tICcuL3ByZXByb2Nlc3Nvcic7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGFyaWFQcmVwcm9jZXNzb3IpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJWaXN1YWwocmVnaXN0ZXJzLlBSSU9SSVRZLlZJU1VBTC5BUklBLCBhcmlhVmlzdWFsKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcmlhUHJlcHJvY2Vzc29yKG9wdGlvbikge1xuICBpZiAoIW9wdGlvbiB8fCAhb3B0aW9uLmFyaWEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYXJpYSA9IG9wdGlvbi5hcmlhOyAvLyBhcmlhLnNob3cgaXMgZGVwcmVjYXRlZCBhbmQgc2hvdWxkIHVzZSBhcmlhLmVuYWJsZWQgaW5zdGVhZFxuXG4gIGlmIChhcmlhLnNob3cgIT0gbnVsbCkge1xuICAgIGFyaWEuZW5hYmxlZCA9IGFyaWEuc2hvdztcbiAgfVxuXG4gIGFyaWEubGFiZWwgPSBhcmlhLmxhYmVsIHx8IHt9OyAvLyBtb3ZlIGRlc2NyaXB0aW9uLCBnZW5lcmFsLCBzZXJpZXMsIGRhdGEgdG8gYmUgdW5kZXIgYXJpYS5sYWJlbFxuXG4gIHpyVXRpbC5lYWNoKFsnZGVzY3JpcHRpb24nLCAnZ2VuZXJhbCcsICdzZXJpZXMnLCAnZGF0YSddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChhcmlhW25hbWVdICE9IG51bGwpIHtcbiAgICAgIGFyaWEubGFiZWxbbmFtZV0gPSBhcmlhW25hbWVdO1xuICAgIH1cbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgeyBjcmVhdGVUZXh0U3R5bGUgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlJztcbmltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Nb2RlbCc7XG5pbXBvcnQgQXhpc1ZpZXcgZnJvbSAnLi9BeGlzVmlldyc7XG5pbXBvcnQgQXhpc0J1aWxkZXIgZnJvbSAnLi9BeGlzQnVpbGRlcic7XG5pbXBvcnQgeyBnZXRFQ0RhdGEgfSBmcm9tICcuLi8uLi91dGlsL2lubmVyU3RvcmUnO1xudmFyIGVsZW1lbnRMaXN0ID0gWydheGlzTGluZScsICdheGlzTGFiZWwnLCAnYXhpc1RpY2snLCAnbWlub3JUaWNrJywgJ3NwbGl0TGluZScsICdtaW5vclNwbGl0TGluZScsICdzcGxpdEFyZWEnXTtcblxuZnVuY3Rpb24gZ2V0QXhpc0xpbmVTaGFwZShwb2xhciwgckV4dGVudCwgYW5nbGUpIHtcbiAgckV4dGVudFsxXSA+IHJFeHRlbnRbMF0gJiYgKHJFeHRlbnQgPSByRXh0ZW50LnNsaWNlKCkucmV2ZXJzZSgpKTtcbiAgdmFyIHN0YXJ0ID0gcG9sYXIuY29vcmRUb1BvaW50KFtyRXh0ZW50WzBdLCBhbmdsZV0pO1xuICB2YXIgZW5kID0gcG9sYXIuY29vcmRUb1BvaW50KFtyRXh0ZW50WzFdLCBhbmdsZV0pO1xuICByZXR1cm4ge1xuICAgIHgxOiBzdGFydFswXSxcbiAgICB5MTogc3RhcnRbMV0sXG4gICAgeDI6IGVuZFswXSxcbiAgICB5MjogZW5kWzFdXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFJhZGl1c0lkeChwb2xhcikge1xuICB2YXIgcmFkaXVzQXhpcyA9IHBvbGFyLmdldFJhZGl1c0F4aXMoKTtcbiAgcmV0dXJuIHJhZGl1c0F4aXMuaW52ZXJzZSA/IDAgOiAxO1xufSAvLyBSZW1vdmUgdGhlIGxhc3QgdGljayB3aGljaCB3aWxsIG92ZXJsYXAgdGhlIGZpcnN0IHRpY2tcblxuXG5mdW5jdGlvbiBmaXhBbmdsZU92ZXJsYXAobGlzdCkge1xuICB2YXIgZmlyc3RJdGVtID0gbGlzdFswXTtcbiAgdmFyIGxhc3RJdGVtID0gbGlzdFtsaXN0Lmxlbmd0aCAtIDFdO1xuXG4gIGlmIChmaXJzdEl0ZW0gJiYgbGFzdEl0ZW0gJiYgTWF0aC5hYnMoTWF0aC5hYnMoZmlyc3RJdGVtLmNvb3JkIC0gbGFzdEl0ZW0uY29vcmQpIC0gMzYwKSA8IDFlLTQpIHtcbiAgICBsaXN0LnBvcCgpO1xuICB9XG59XG5cbnZhciBBbmdsZUF4aXNWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEFuZ2xlQXhpc1ZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gQW5nbGVBeGlzVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBBbmdsZUF4aXNWaWV3LnR5cGU7XG4gICAgX3RoaXMuYXhpc1BvaW50ZXJDbGFzcyA9ICdQb2xhckF4aXNQb2ludGVyJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBBbmdsZUF4aXNWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoYW5nbGVBeGlzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgaWYgKCFhbmdsZUF4aXNNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmdsZUF4aXMgPSBhbmdsZUF4aXNNb2RlbC5heGlzO1xuICAgIHZhciBwb2xhciA9IGFuZ2xlQXhpcy5wb2xhcjtcbiAgICB2YXIgcmFkaXVzRXh0ZW50ID0gcG9sYXIuZ2V0UmFkaXVzQXhpcygpLmdldEV4dGVudCgpO1xuICAgIHZhciB0aWNrc0FuZ2xlcyA9IGFuZ2xlQXhpcy5nZXRUaWNrc0Nvb3JkcygpO1xuICAgIHZhciBtaW5vclRpY2tBbmdsZXMgPSBhbmdsZUF4aXMuZ2V0TWlub3JUaWNrc0Nvb3JkcygpO1xuICAgIHZhciBsYWJlbHMgPSB6clV0aWwubWFwKGFuZ2xlQXhpcy5nZXRWaWV3TGFiZWxzKCksIGZ1bmN0aW9uIChsYWJlbEl0ZW0pIHtcbiAgICAgIGxhYmVsSXRlbSA9IHpyVXRpbC5jbG9uZShsYWJlbEl0ZW0pO1xuICAgICAgdmFyIHNjYWxlID0gYW5nbGVBeGlzLnNjYWxlO1xuICAgICAgdmFyIHRpY2tWYWx1ZSA9IHNjYWxlLnR5cGUgPT09ICdvcmRpbmFsJyA/IHNjYWxlLmdldFJhd09yZGluYWxOdW1iZXIobGFiZWxJdGVtLnRpY2tWYWx1ZSkgOiBsYWJlbEl0ZW0udGlja1ZhbHVlO1xuICAgICAgbGFiZWxJdGVtLmNvb3JkID0gYW5nbGVBeGlzLmRhdGFUb0Nvb3JkKHRpY2tWYWx1ZSk7XG4gICAgICByZXR1cm4gbGFiZWxJdGVtO1xuICAgIH0pO1xuICAgIGZpeEFuZ2xlT3ZlcmxhcChsYWJlbHMpO1xuICAgIGZpeEFuZ2xlT3ZlcmxhcCh0aWNrc0FuZ2xlcyk7XG4gICAgenJVdGlsLmVhY2goZWxlbWVudExpc3QsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAoYW5nbGVBeGlzTW9kZWwuZ2V0KFtuYW1lLCAnc2hvdyddKSAmJiAoIWFuZ2xlQXhpcy5zY2FsZS5pc0JsYW5rKCkgfHwgbmFtZSA9PT0gJ2F4aXNMaW5lJykpIHtcbiAgICAgICAgYW5nZWxBeGlzRWxlbWVudHNCdWlsZGVyc1tuYW1lXSh0aGlzLmdyb3VwLCBhbmdsZUF4aXNNb2RlbCwgcG9sYXIsIHRpY2tzQW5nbGVzLCBtaW5vclRpY2tBbmdsZXMsIHJhZGl1c0V4dGVudCwgbGFiZWxzKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuICBBbmdsZUF4aXNWaWV3LnR5cGUgPSAnYW5nbGVBeGlzJztcbiAgcmV0dXJuIEFuZ2xlQXhpc1ZpZXc7XG59KEF4aXNWaWV3KTtcblxudmFyIGFuZ2VsQXhpc0VsZW1lbnRzQnVpbGRlcnMgPSB7XG4gIGF4aXNMaW5lOiBmdW5jdGlvbiAoZ3JvdXAsIGFuZ2xlQXhpc01vZGVsLCBwb2xhciwgdGlja3NBbmdsZXMsIG1pbm9yVGlja0FuZ2xlcywgcmFkaXVzRXh0ZW50KSB7XG4gICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gYW5nbGVBeGlzTW9kZWwuZ2V0TW9kZWwoWydheGlzTGluZScsICdsaW5lU3R5bGUnXSk7IC8vIGV4dGVudCBpZCBvZiB0aGUgYXhpcyByYWRpdXMgKHIwIGFuZCByKVxuXG4gICAgdmFyIHJJZCA9IGdldFJhZGl1c0lkeChwb2xhcik7XG4gICAgdmFyIHIwSWQgPSBySWQgPyAwIDogMTtcbiAgICB2YXIgc2hhcGU7XG5cbiAgICBpZiAocmFkaXVzRXh0ZW50W3IwSWRdID09PSAwKSB7XG4gICAgICBzaGFwZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgY3g6IHBvbGFyLmN4LFxuICAgICAgICAgIGN5OiBwb2xhci5jeSxcbiAgICAgICAgICByOiByYWRpdXNFeHRlbnRbcklkXVxuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCksXG4gICAgICAgIHoyOiAxLFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaGFwZSA9IG5ldyBncmFwaGljLlJpbmcoe1xuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIGN4OiBwb2xhci5jeCxcbiAgICAgICAgICBjeTogcG9sYXIuY3ksXG4gICAgICAgICAgcjogcmFkaXVzRXh0ZW50W3JJZF0sXG4gICAgICAgICAgcjA6IHJhZGl1c0V4dGVudFtyMElkXVxuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCksXG4gICAgICAgIHoyOiAxLFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNoYXBlLnN0eWxlLmZpbGwgPSBudWxsO1xuICAgIGdyb3VwLmFkZChzaGFwZSk7XG4gIH0sXG4gIGF4aXNUaWNrOiBmdW5jdGlvbiAoZ3JvdXAsIGFuZ2xlQXhpc01vZGVsLCBwb2xhciwgdGlja3NBbmdsZXMsIG1pbm9yVGlja0FuZ2xlcywgcmFkaXVzRXh0ZW50KSB7XG4gICAgdmFyIHRpY2tNb2RlbCA9IGFuZ2xlQXhpc01vZGVsLmdldE1vZGVsKCdheGlzVGljaycpO1xuICAgIHZhciB0aWNrTGVuID0gKHRpY2tNb2RlbC5nZXQoJ2luc2lkZScpID8gLTEgOiAxKSAqIHRpY2tNb2RlbC5nZXQoJ2xlbmd0aCcpO1xuICAgIHZhciByYWRpdXMgPSByYWRpdXNFeHRlbnRbZ2V0UmFkaXVzSWR4KHBvbGFyKV07XG4gICAgdmFyIGxpbmVzID0genJVdGlsLm1hcCh0aWNrc0FuZ2xlcywgZnVuY3Rpb24gKHRpY2tBbmdsZUl0ZW0pIHtcbiAgICAgIHJldHVybiBuZXcgZ3JhcGhpYy5MaW5lKHtcbiAgICAgICAgc2hhcGU6IGdldEF4aXNMaW5lU2hhcGUocG9sYXIsIFtyYWRpdXMsIHJhZGl1cyArIHRpY2tMZW5dLCB0aWNrQW5nbGVJdGVtLmNvb3JkKVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZ3JvdXAuYWRkKGdyYXBoaWMubWVyZ2VQYXRoKGxpbmVzLCB7XG4gICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKHRpY2tNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCksIHtcbiAgICAgICAgc3Ryb2tlOiBhbmdsZUF4aXNNb2RlbC5nZXQoWydheGlzTGluZScsICdsaW5lU3R5bGUnLCAnY29sb3InXSlcbiAgICAgIH0pXG4gICAgfSkpO1xuICB9LFxuICBtaW5vclRpY2s6IGZ1bmN0aW9uIChncm91cCwgYW5nbGVBeGlzTW9kZWwsIHBvbGFyLCB0aWNrQW5nbGVzLCBtaW5vclRpY2tBbmdsZXMsIHJhZGl1c0V4dGVudCkge1xuICAgIGlmICghbWlub3JUaWNrQW5nbGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0aWNrTW9kZWwgPSBhbmdsZUF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc1RpY2snKTtcbiAgICB2YXIgbWlub3JUaWNrTW9kZWwgPSBhbmdsZUF4aXNNb2RlbC5nZXRNb2RlbCgnbWlub3JUaWNrJyk7XG4gICAgdmFyIHRpY2tMZW4gPSAodGlja01vZGVsLmdldCgnaW5zaWRlJykgPyAtMSA6IDEpICogbWlub3JUaWNrTW9kZWwuZ2V0KCdsZW5ndGgnKTtcbiAgICB2YXIgcmFkaXVzID0gcmFkaXVzRXh0ZW50W2dldFJhZGl1c0lkeChwb2xhcildO1xuICAgIHZhciBsaW5lcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5vclRpY2tBbmdsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbWlub3JUaWNrQW5nbGVzW2ldLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGxpbmVzLnB1c2gobmV3IGdyYXBoaWMuTGluZSh7XG4gICAgICAgICAgc2hhcGU6IGdldEF4aXNMaW5lU2hhcGUocG9sYXIsIFtyYWRpdXMsIHJhZGl1cyArIHRpY2tMZW5dLCBtaW5vclRpY2tBbmdsZXNbaV1ba10uY29vcmQpXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBncm91cC5hZGQoZ3JhcGhpYy5tZXJnZVBhdGgobGluZXMsIHtcbiAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMobWlub3JUaWNrTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpLCB6clV0aWwuZGVmYXVsdHModGlja01vZGVsLmdldExpbmVTdHlsZSgpLCB7XG4gICAgICAgIHN0cm9rZTogYW5nbGVBeGlzTW9kZWwuZ2V0KFsnYXhpc0xpbmUnLCAnbGluZVN0eWxlJywgJ2NvbG9yJ10pXG4gICAgICB9KSlcbiAgICB9KSk7XG4gIH0sXG4gIGF4aXNMYWJlbDogZnVuY3Rpb24gKGdyb3VwLCBhbmdsZUF4aXNNb2RlbCwgcG9sYXIsIHRpY2tzQW5nbGVzLCBtaW5vclRpY2tBbmdsZXMsIHJhZGl1c0V4dGVudCwgbGFiZWxzKSB7XG4gICAgdmFyIHJhd0NhdGVnb3J5RGF0YSA9IGFuZ2xlQXhpc01vZGVsLmdldENhdGVnb3JpZXModHJ1ZSk7XG4gICAgdmFyIGNvbW1vbkxhYmVsTW9kZWwgPSBhbmdsZUF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc0xhYmVsJyk7XG4gICAgdmFyIGxhYmVsTWFyZ2luID0gY29tbW9uTGFiZWxNb2RlbC5nZXQoJ21hcmdpbicpO1xuICAgIHZhciB0cmlnZ2VyRXZlbnQgPSBhbmdsZUF4aXNNb2RlbC5nZXQoJ3RyaWdnZXJFdmVudCcpOyAvLyBVc2UgbGVuZ3RoIG9mIHRpY2tzQW5nbGVzIGJlY2F1c2UgaXQgbWF5IHJlbW92ZSB0aGUgbGFzdCB0aWNrIHRvIGF2b2lkIG92ZXJsYXBwaW5nXG5cbiAgICB6clV0aWwuZWFjaChsYWJlbHMsIGZ1bmN0aW9uIChsYWJlbEl0ZW0sIGlkeCkge1xuICAgICAgdmFyIGxhYmVsTW9kZWwgPSBjb21tb25MYWJlbE1vZGVsO1xuICAgICAgdmFyIHRpY2tWYWx1ZSA9IGxhYmVsSXRlbS50aWNrVmFsdWU7XG4gICAgICB2YXIgciA9IHJhZGl1c0V4dGVudFtnZXRSYWRpdXNJZHgocG9sYXIpXTtcbiAgICAgIHZhciBwID0gcG9sYXIuY29vcmRUb1BvaW50KFtyICsgbGFiZWxNYXJnaW4sIGxhYmVsSXRlbS5jb29yZF0pO1xuICAgICAgdmFyIGN4ID0gcG9sYXIuY3g7XG4gICAgICB2YXIgY3kgPSBwb2xhci5jeTtcbiAgICAgIHZhciBsYWJlbFRleHRBbGlnbiA9IE1hdGguYWJzKHBbMF0gLSBjeCkgLyByIDwgMC4zID8gJ2NlbnRlcicgOiBwWzBdID4gY3ggPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgdmFyIGxhYmVsVGV4dFZlcnRpY2FsQWxpZ24gPSBNYXRoLmFicyhwWzFdIC0gY3kpIC8gciA8IDAuMyA/ICdtaWRkbGUnIDogcFsxXSA+IGN5ID8gJ3RvcCcgOiAnYm90dG9tJztcblxuICAgICAgaWYgKHJhd0NhdGVnb3J5RGF0YSAmJiByYXdDYXRlZ29yeURhdGFbdGlja1ZhbHVlXSkge1xuICAgICAgICB2YXIgcmF3Q2F0ZWdvcnlJdGVtID0gcmF3Q2F0ZWdvcnlEYXRhW3RpY2tWYWx1ZV07XG5cbiAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChyYXdDYXRlZ29yeUl0ZW0pICYmIHJhd0NhdGVnb3J5SXRlbS50ZXh0U3R5bGUpIHtcbiAgICAgICAgICBsYWJlbE1vZGVsID0gbmV3IE1vZGVsKHJhd0NhdGVnb3J5SXRlbS50ZXh0U3R5bGUsIGNvbW1vbkxhYmVsTW9kZWwsIGNvbW1vbkxhYmVsTW9kZWwuZWNNb2RlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgICBzaWxlbnQ6IEF4aXNCdWlsZGVyLmlzTGFiZWxTaWxlbnQoYW5nbGVBeGlzTW9kZWwpLFxuICAgICAgICBzdHlsZTogY3JlYXRlVGV4dFN0eWxlKGxhYmVsTW9kZWwsIHtcbiAgICAgICAgICB4OiBwWzBdLFxuICAgICAgICAgIHk6IHBbMV0sXG4gICAgICAgICAgZmlsbDogbGFiZWxNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBhbmdsZUF4aXNNb2RlbC5nZXQoWydheGlzTGluZScsICdsaW5lU3R5bGUnLCAnY29sb3InXSksXG4gICAgICAgICAgdGV4dDogbGFiZWxJdGVtLmZvcm1hdHRlZExhYmVsLFxuICAgICAgICAgIGFsaWduOiBsYWJlbFRleHRBbGlnbixcbiAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiBsYWJlbFRleHRWZXJ0aWNhbEFsaWduXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGdyb3VwLmFkZCh0ZXh0RWwpOyAvLyBQYWNrIGRhdGEgZm9yIG1vdXNlIGV2ZW50XG5cbiAgICAgIGlmICh0cmlnZ2VyRXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50RGF0YSA9IEF4aXNCdWlsZGVyLm1ha2VBeGlzRXZlbnREYXRhQmFzZShhbmdsZUF4aXNNb2RlbCk7XG4gICAgICAgIGV2ZW50RGF0YS50YXJnZXRUeXBlID0gJ2F4aXNMYWJlbCc7XG4gICAgICAgIGV2ZW50RGF0YS52YWx1ZSA9IGxhYmVsSXRlbS5yYXdMYWJlbDtcbiAgICAgICAgZ2V0RUNEYXRhKHRleHRFbCkuZXZlbnREYXRhID0gZXZlbnREYXRhO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9LFxuICBzcGxpdExpbmU6IGZ1bmN0aW9uIChncm91cCwgYW5nbGVBeGlzTW9kZWwsIHBvbGFyLCB0aWNrc0FuZ2xlcywgbWlub3JUaWNrQW5nbGVzLCByYWRpdXNFeHRlbnQpIHtcbiAgICB2YXIgc3BsaXRMaW5lTW9kZWwgPSBhbmdsZUF4aXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRMaW5lJyk7XG4gICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gc3BsaXRMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICAgIHZhciBsaW5lQ29sb3JzID0gbGluZVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuICAgIHZhciBsaW5lQ291bnQgPSAwO1xuICAgIGxpbmVDb2xvcnMgPSBsaW5lQ29sb3JzIGluc3RhbmNlb2YgQXJyYXkgPyBsaW5lQ29sb3JzIDogW2xpbmVDb2xvcnNdO1xuICAgIHZhciBzcGxpdExpbmVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzQW5nbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29sb3JJbmRleCA9IGxpbmVDb3VudCsrICUgbGluZUNvbG9ycy5sZW5ndGg7XG4gICAgICBzcGxpdExpbmVzW2NvbG9ySW5kZXhdID0gc3BsaXRMaW5lc1tjb2xvckluZGV4XSB8fCBbXTtcbiAgICAgIHNwbGl0TGluZXNbY29sb3JJbmRleF0ucHVzaChuZXcgZ3JhcGhpYy5MaW5lKHtcbiAgICAgICAgc2hhcGU6IGdldEF4aXNMaW5lU2hhcGUocG9sYXIsIHJhZGl1c0V4dGVudCwgdGlja3NBbmdsZXNbaV0uY29vcmQpXG4gICAgICB9KSk7XG4gICAgfSAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXG4gICAgLy8gQmF0Y2hpbmcgdGhlIGxpbmVzIGlmIGNvbG9yIGFyZSB0aGUgc2FtZVxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdyb3VwLmFkZChncmFwaGljLm1lcmdlUGF0aChzcGxpdExpbmVzW2ldLCB7XG4gICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgIHN0cm9rZTogbGluZUNvbG9yc1tpICUgbGluZUNvbG9ycy5sZW5ndGhdXG4gICAgICAgIH0sIGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpKSxcbiAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICB6OiBhbmdsZUF4aXNNb2RlbC5nZXQoJ3onKVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSxcbiAgbWlub3JTcGxpdExpbmU6IGZ1bmN0aW9uIChncm91cCwgYW5nbGVBeGlzTW9kZWwsIHBvbGFyLCB0aWNrc0FuZ2xlcywgbWlub3JUaWNrQW5nbGVzLCByYWRpdXNFeHRlbnQpIHtcbiAgICBpZiAoIW1pbm9yVGlja0FuZ2xlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWlub3JTcGxpdExpbmVNb2RlbCA9IGFuZ2xlQXhpc01vZGVsLmdldE1vZGVsKCdtaW5vclNwbGl0TGluZScpO1xuICAgIHZhciBsaW5lU3R5bGVNb2RlbCA9IG1pbm9yU3BsaXRMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICAgIHZhciBsaW5lcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5vclRpY2tBbmdsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbWlub3JUaWNrQW5nbGVzW2ldLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGxpbmVzLnB1c2gobmV3IGdyYXBoaWMuTGluZSh7XG4gICAgICAgICAgc2hhcGU6IGdldEF4aXNMaW5lU2hhcGUocG9sYXIsIHJhZGl1c0V4dGVudCwgbWlub3JUaWNrQW5nbGVzW2ldW2tdLmNvb3JkKVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ3JvdXAuYWRkKGdyYXBoaWMubWVyZ2VQYXRoKGxpbmVzLCB7XG4gICAgICBzdHlsZTogbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCksXG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICB6OiBhbmdsZUF4aXNNb2RlbC5nZXQoJ3onKVxuICAgIH0pKTtcbiAgfSxcbiAgc3BsaXRBcmVhOiBmdW5jdGlvbiAoZ3JvdXAsIGFuZ2xlQXhpc01vZGVsLCBwb2xhciwgdGlja3NBbmdsZXMsIG1pbm9yVGlja0FuZ2xlcywgcmFkaXVzRXh0ZW50KSB7XG4gICAgaWYgKCF0aWNrc0FuZ2xlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3BsaXRBcmVhTW9kZWwgPSBhbmdsZUF4aXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRBcmVhJyk7XG4gICAgdmFyIGFyZWFTdHlsZU1vZGVsID0gc3BsaXRBcmVhTW9kZWwuZ2V0TW9kZWwoJ2FyZWFTdHlsZScpO1xuICAgIHZhciBhcmVhQ29sb3JzID0gYXJlYVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuICAgIHZhciBsaW5lQ291bnQgPSAwO1xuICAgIGFyZWFDb2xvcnMgPSBhcmVhQ29sb3JzIGluc3RhbmNlb2YgQXJyYXkgPyBhcmVhQ29sb3JzIDogW2FyZWFDb2xvcnNdO1xuICAgIHZhciBzcGxpdEFyZWFzID0gW107XG4gICAgdmFyIFJBRElBTiA9IE1hdGguUEkgLyAxODA7XG4gICAgdmFyIHByZXZBbmdsZSA9IC10aWNrc0FuZ2xlc1swXS5jb29yZCAqIFJBRElBTjtcbiAgICB2YXIgcjAgPSBNYXRoLm1pbihyYWRpdXNFeHRlbnRbMF0sIHJhZGl1c0V4dGVudFsxXSk7XG4gICAgdmFyIHIxID0gTWF0aC5tYXgocmFkaXVzRXh0ZW50WzBdLCByYWRpdXNFeHRlbnRbMV0pO1xuICAgIHZhciBjbG9ja3dpc2UgPSBhbmdsZUF4aXNNb2RlbC5nZXQoJ2Nsb2Nrd2lzZScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHRpY2tzQW5nbGVzLmxlbmd0aDsgaSA8PSBsZW47IGkrKykge1xuICAgICAgdmFyIGNvb3JkID0gaSA9PT0gbGVuID8gdGlja3NBbmdsZXNbMF0uY29vcmQgOiB0aWNrc0FuZ2xlc1tpXS5jb29yZDtcbiAgICAgIHZhciBjb2xvckluZGV4ID0gbGluZUNvdW50KysgJSBhcmVhQ29sb3JzLmxlbmd0aDtcbiAgICAgIHNwbGl0QXJlYXNbY29sb3JJbmRleF0gPSBzcGxpdEFyZWFzW2NvbG9ySW5kZXhdIHx8IFtdO1xuICAgICAgc3BsaXRBcmVhc1tjb2xvckluZGV4XS5wdXNoKG5ldyBncmFwaGljLlNlY3Rvcih7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgY3g6IHBvbGFyLmN4LFxuICAgICAgICAgIGN5OiBwb2xhci5jeSxcbiAgICAgICAgICByMDogcjAsXG4gICAgICAgICAgcjogcjEsXG4gICAgICAgICAgc3RhcnRBbmdsZTogcHJldkFuZ2xlLFxuICAgICAgICAgIGVuZEFuZ2xlOiAtY29vcmQgKiBSQURJQU4sXG4gICAgICAgICAgY2xvY2t3aXNlOiBjbG9ja3dpc2VcbiAgICAgICAgfSxcbiAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICB9KSk7XG4gICAgICBwcmV2QW5nbGUgPSAtY29vcmQgKiBSQURJQU47XG4gICAgfSAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXG4gICAgLy8gQmF0Y2hpbmcgdGhlIGxpbmVzIGlmIGNvbG9yIGFyZSB0aGUgc2FtZVxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0QXJlYXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdyb3VwLmFkZChncmFwaGljLm1lcmdlUGF0aChzcGxpdEFyZWFzW2ldLCB7XG4gICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgIGZpbGw6IGFyZWFDb2xvcnNbaSAlIGFyZWFDb2xvcnMubGVuZ3RoXVxuICAgICAgICB9LCBhcmVhU3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKSksXG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IEFuZ2xlQXhpc1ZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgQXhpc0J1aWxkZXIgZnJvbSAnLi9BeGlzQnVpbGRlcic7XG5pbXBvcnQgQXhpc1ZpZXcgZnJvbSAnLi9BeGlzVmlldyc7XG52YXIgYXhpc0J1aWxkZXJBdHRycyA9IFsnYXhpc0xpbmUnLCAnYXhpc1RpY2tMYWJlbCcsICdheGlzTmFtZSddO1xudmFyIHNlbGZCdWlsZGVyQXR0cnMgPSBbJ3NwbGl0TGluZScsICdzcGxpdEFyZWEnLCAnbWlub3JTcGxpdExpbmUnXTtcblxudmFyIFJhZGl1c0F4aXNWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFJhZGl1c0F4aXNWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFJhZGl1c0F4aXNWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IFJhZGl1c0F4aXNWaWV3LnR5cGU7XG4gICAgX3RoaXMuYXhpc1BvaW50ZXJDbGFzcyA9ICdQb2xhckF4aXNQb2ludGVyJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBSYWRpdXNBeGlzVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHJhZGl1c0F4aXNNb2RlbCwgZWNNb2RlbCkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICBpZiAoIXJhZGl1c0F4aXNNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvbGRBeGlzR3JvdXAgPSB0aGlzLl9heGlzR3JvdXA7XG4gICAgdmFyIG5ld0F4aXNHcm91cCA9IHRoaXMuX2F4aXNHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgdGhpcy5ncm91cC5hZGQobmV3QXhpc0dyb3VwKTtcbiAgICB2YXIgcmFkaXVzQXhpcyA9IHJhZGl1c0F4aXNNb2RlbC5heGlzO1xuICAgIHZhciBwb2xhciA9IHJhZGl1c0F4aXMucG9sYXI7XG4gICAgdmFyIGFuZ2xlQXhpcyA9IHBvbGFyLmdldEFuZ2xlQXhpcygpO1xuICAgIHZhciB0aWNrc0Nvb3JkcyA9IHJhZGl1c0F4aXMuZ2V0VGlja3NDb29yZHMoKTtcbiAgICB2YXIgbWlub3JUaWNrc0Nvb3JkcyA9IHJhZGl1c0F4aXMuZ2V0TWlub3JUaWNrc0Nvb3JkcygpO1xuICAgIHZhciBheGlzQW5nbGUgPSBhbmdsZUF4aXMuZ2V0RXh0ZW50KClbMF07XG4gICAgdmFyIHJhZGl1c0V4dGVudCA9IHJhZGl1c0F4aXMuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIGxheW91dCA9IGxheW91dEF4aXMocG9sYXIsIHJhZGl1c0F4aXNNb2RlbCwgYXhpc0FuZ2xlKTtcbiAgICB2YXIgYXhpc0J1aWxkZXIgPSBuZXcgQXhpc0J1aWxkZXIocmFkaXVzQXhpc01vZGVsLCBsYXlvdXQpO1xuICAgIHpyVXRpbC5lYWNoKGF4aXNCdWlsZGVyQXR0cnMsIGF4aXNCdWlsZGVyLmFkZCwgYXhpc0J1aWxkZXIpO1xuICAgIG5ld0F4aXNHcm91cC5hZGQoYXhpc0J1aWxkZXIuZ2V0R3JvdXAoKSk7XG4gICAgZ3JhcGhpYy5ncm91cFRyYW5zaXRpb24ob2xkQXhpc0dyb3VwLCBuZXdBeGlzR3JvdXAsIHJhZGl1c0F4aXNNb2RlbCk7XG4gICAgenJVdGlsLmVhY2goc2VsZkJ1aWxkZXJBdHRycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChyYWRpdXNBeGlzTW9kZWwuZ2V0KFtuYW1lLCAnc2hvdyddKSAmJiAhcmFkaXVzQXhpcy5zY2FsZS5pc0JsYW5rKCkpIHtcbiAgICAgICAgYXhpc0VsZW1lbnRCdWlsZGVyc1tuYW1lXSh0aGlzLmdyb3VwLCByYWRpdXNBeGlzTW9kZWwsIHBvbGFyLCBheGlzQW5nbGUsIHJhZGl1c0V4dGVudCwgdGlja3NDb29yZHMsIG1pbm9yVGlja3NDb29yZHMpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4gIFJhZGl1c0F4aXNWaWV3LnR5cGUgPSAncmFkaXVzQXhpcyc7XG4gIHJldHVybiBSYWRpdXNBeGlzVmlldztcbn0oQXhpc1ZpZXcpO1xuXG52YXIgYXhpc0VsZW1lbnRCdWlsZGVycyA9IHtcbiAgc3BsaXRMaW5lOiBmdW5jdGlvbiAoZ3JvdXAsIHJhZGl1c0F4aXNNb2RlbCwgcG9sYXIsIGF4aXNBbmdsZSwgcmFkaXVzRXh0ZW50LCB0aWNrc0Nvb3Jkcykge1xuICAgIHZhciBzcGxpdExpbmVNb2RlbCA9IHJhZGl1c0F4aXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRMaW5lJyk7XG4gICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gc3BsaXRMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICAgIHZhciBsaW5lQ29sb3JzID0gbGluZVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuICAgIHZhciBsaW5lQ291bnQgPSAwO1xuICAgIGxpbmVDb2xvcnMgPSBsaW5lQ29sb3JzIGluc3RhbmNlb2YgQXJyYXkgPyBsaW5lQ29sb3JzIDogW2xpbmVDb2xvcnNdO1xuICAgIHZhciBzcGxpdExpbmVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzQ29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29sb3JJbmRleCA9IGxpbmVDb3VudCsrICUgbGluZUNvbG9ycy5sZW5ndGg7XG4gICAgICBzcGxpdExpbmVzW2NvbG9ySW5kZXhdID0gc3BsaXRMaW5lc1tjb2xvckluZGV4XSB8fCBbXTtcbiAgICAgIHNwbGl0TGluZXNbY29sb3JJbmRleF0ucHVzaChuZXcgZ3JhcGhpYy5DaXJjbGUoe1xuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIGN4OiBwb2xhci5jeCxcbiAgICAgICAgICBjeTogcG9sYXIuY3ksXG4gICAgICAgICAgcjogdGlja3NDb29yZHNbaV0uY29vcmRcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH0gLy8gU2ltcGxlIG9wdGltaXphdGlvblxuICAgIC8vIEJhdGNoaW5nIHRoZSBsaW5lcyBpZiBjb2xvciBhcmUgdGhlIHNhbWVcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGxpdExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBncm91cC5hZGQoZ3JhcGhpYy5tZXJnZVBhdGgoc3BsaXRMaW5lc1tpXSwge1xuICAgICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgICBzdHJva2U6IGxpbmVDb2xvcnNbaSAlIGxpbmVDb2xvcnMubGVuZ3RoXSxcbiAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sIGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpKSxcbiAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICB9KSk7XG4gICAgfVxuICB9LFxuICBtaW5vclNwbGl0TGluZTogZnVuY3Rpb24gKGdyb3VwLCByYWRpdXNBeGlzTW9kZWwsIHBvbGFyLCBheGlzQW5nbGUsIHJhZGl1c0V4dGVudCwgdGlja3NDb29yZHMsIG1pbm9yVGlja3NDb29yZHMpIHtcbiAgICBpZiAoIW1pbm9yVGlja3NDb29yZHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1pbm9yU3BsaXRMaW5lTW9kZWwgPSByYWRpdXNBeGlzTW9kZWwuZ2V0TW9kZWwoJ21pbm9yU3BsaXRMaW5lJyk7XG4gICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gbWlub3JTcGxpdExpbmVNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJyk7XG4gICAgdmFyIGxpbmVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbm9yVGlja3NDb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbWlub3JUaWNrc0Nvb3Jkc1tpXS5sZW5ndGg7IGsrKykge1xuICAgICAgICBsaW5lcy5wdXNoKG5ldyBncmFwaGljLkNpcmNsZSh7XG4gICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIGN4OiBwb2xhci5jeCxcbiAgICAgICAgICAgIGN5OiBwb2xhci5jeSxcbiAgICAgICAgICAgIHI6IG1pbm9yVGlja3NDb29yZHNbaV1ba10uY29vcmRcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBncm91cC5hZGQoZ3JhcGhpYy5tZXJnZVBhdGgobGluZXMsIHtcbiAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICBmaWxsOiBudWxsXG4gICAgICB9LCBsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKSksXG4gICAgICBzaWxlbnQ6IHRydWVcbiAgICB9KSk7XG4gIH0sXG4gIHNwbGl0QXJlYTogZnVuY3Rpb24gKGdyb3VwLCByYWRpdXNBeGlzTW9kZWwsIHBvbGFyLCBheGlzQW5nbGUsIHJhZGl1c0V4dGVudCwgdGlja3NDb29yZHMpIHtcbiAgICBpZiAoIXRpY2tzQ29vcmRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzcGxpdEFyZWFNb2RlbCA9IHJhZGl1c0F4aXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRBcmVhJyk7XG4gICAgdmFyIGFyZWFTdHlsZU1vZGVsID0gc3BsaXRBcmVhTW9kZWwuZ2V0TW9kZWwoJ2FyZWFTdHlsZScpO1xuICAgIHZhciBhcmVhQ29sb3JzID0gYXJlYVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuICAgIHZhciBsaW5lQ291bnQgPSAwO1xuICAgIGFyZWFDb2xvcnMgPSBhcmVhQ29sb3JzIGluc3RhbmNlb2YgQXJyYXkgPyBhcmVhQ29sb3JzIDogW2FyZWFDb2xvcnNdO1xuICAgIHZhciBzcGxpdEFyZWFzID0gW107XG4gICAgdmFyIHByZXZSYWRpdXMgPSB0aWNrc0Nvb3Jkc1swXS5jb29yZDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGlja3NDb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb2xvckluZGV4ID0gbGluZUNvdW50KysgJSBhcmVhQ29sb3JzLmxlbmd0aDtcbiAgICAgIHNwbGl0QXJlYXNbY29sb3JJbmRleF0gPSBzcGxpdEFyZWFzW2NvbG9ySW5kZXhdIHx8IFtdO1xuICAgICAgc3BsaXRBcmVhc1tjb2xvckluZGV4XS5wdXNoKG5ldyBncmFwaGljLlNlY3Rvcih7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgY3g6IHBvbGFyLmN4LFxuICAgICAgICAgIGN5OiBwb2xhci5jeSxcbiAgICAgICAgICByMDogcHJldlJhZGl1cyxcbiAgICAgICAgICByOiB0aWNrc0Nvb3Jkc1tpXS5jb29yZCxcbiAgICAgICAgICBzdGFydEFuZ2xlOiAwLFxuICAgICAgICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMlxuICAgICAgICB9LFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICAgIHByZXZSYWRpdXMgPSB0aWNrc0Nvb3Jkc1tpXS5jb29yZDtcbiAgICB9IC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cbiAgICAvLyBCYXRjaGluZyB0aGUgbGluZXMgaWYgY29sb3IgYXJlIHRoZSBzYW1lXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaXRBcmVhcy5sZW5ndGg7IGkrKykge1xuICAgICAgZ3JvdXAuYWRkKGdyYXBoaWMubWVyZ2VQYXRoKHNwbGl0QXJlYXNbaV0sIHtcbiAgICAgICAgc3R5bGU6IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgICAgZmlsbDogYXJlYUNvbG9yc1tpICUgYXJlYUNvbG9ycy5sZW5ndGhdXG4gICAgICAgIH0sIGFyZWFTdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpKSxcbiAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5mdW5jdGlvbiBsYXlvdXRBeGlzKHBvbGFyLCByYWRpdXNBeGlzTW9kZWwsIGF4aXNBbmdsZSkge1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBbcG9sYXIuY3gsIHBvbGFyLmN5XSxcbiAgICByb3RhdGlvbjogYXhpc0FuZ2xlIC8gMTgwICogTWF0aC5QSSxcbiAgICBsYWJlbERpcmVjdGlvbjogLTEsXG4gICAgdGlja0RpcmVjdGlvbjogLTEsXG4gICAgbmFtZURpcmVjdGlvbjogMSxcbiAgICBsYWJlbFJvdGF0ZTogcmFkaXVzQXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwnKS5nZXQoJ3JvdGF0ZScpLFxuICAgIC8vIE92ZXIgc3BsaXRMaW5lIGFuZCBzcGxpdEFyZWFcbiAgICB6MjogMVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBSYWRpdXNBeGlzVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBBeGlzQnVpbGRlciBmcm9tICcuL0F4aXNCdWlsZGVyJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCAqIGFzIHNpbmdsZUF4aXNIZWxwZXIgZnJvbSAnLi4vLi4vY29vcmQvc2luZ2xlL3NpbmdsZUF4aXNIZWxwZXInO1xuaW1wb3J0IEF4aXNWaWV3IGZyb20gJy4vQXhpc1ZpZXcnO1xuaW1wb3J0IHsgcmVjdENvb3JkQXhpc0J1aWxkU3BsaXRBcmVhLCByZWN0Q29vcmRBeGlzSGFuZGxlUmVtb3ZlIH0gZnJvbSAnLi9heGlzU3BsaXRIZWxwZXInO1xudmFyIGF4aXNCdWlsZGVyQXR0cnMgPSBbJ2F4aXNMaW5lJywgJ2F4aXNUaWNrTGFiZWwnLCAnYXhpc05hbWUnXTtcbnZhciBzZWxmQnVpbGRlckF0dHJzID0gWydzcGxpdEFyZWEnLCAnc3BsaXRMaW5lJ107XG5cbnZhciBTaW5nbGVBeGlzVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTaW5nbGVBeGlzVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTaW5nbGVBeGlzVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBTaW5nbGVBeGlzVmlldy50eXBlO1xuICAgIF90aGlzLmF4aXNQb2ludGVyQ2xhc3MgPSAnU2luZ2xlQXhpc1BvaW50ZXInO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFNpbmdsZUF4aXNWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHZhciBvbGRBeGlzR3JvdXAgPSB0aGlzLl9heGlzR3JvdXA7XG4gICAgdGhpcy5fYXhpc0dyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICB2YXIgbGF5b3V0ID0gc2luZ2xlQXhpc0hlbHBlci5sYXlvdXQoYXhpc01vZGVsKTtcbiAgICB2YXIgYXhpc0J1aWxkZXIgPSBuZXcgQXhpc0J1aWxkZXIoYXhpc01vZGVsLCBsYXlvdXQpO1xuICAgIHpyVXRpbC5lYWNoKGF4aXNCdWlsZGVyQXR0cnMsIGF4aXNCdWlsZGVyLmFkZCwgYXhpc0J1aWxkZXIpO1xuICAgIGdyb3VwLmFkZCh0aGlzLl9heGlzR3JvdXApO1xuICAgIGdyb3VwLmFkZChheGlzQnVpbGRlci5nZXRHcm91cCgpKTtcbiAgICB6clV0aWwuZWFjaChzZWxmQnVpbGRlckF0dHJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKGF4aXNNb2RlbC5nZXQoW25hbWUsICdzaG93J10pKSB7XG4gICAgICAgIGF4aXNFbGVtZW50QnVpbGRlcnNbbmFtZV0odGhpcywgdGhpcy5ncm91cCwgdGhpcy5fYXhpc0dyb3VwLCBheGlzTW9kZWwpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIGdyYXBoaWMuZ3JvdXBUcmFuc2l0aW9uKG9sZEF4aXNHcm91cCwgdGhpcy5fYXhpc0dyb3VwLCBheGlzTW9kZWwpO1xuXG4gICAgX3N1cGVyLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzLCBheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gIH07XG5cbiAgU2luZ2xlQXhpc1ZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZWN0Q29vcmRBeGlzSGFuZGxlUmVtb3ZlKHRoaXMpO1xuICB9O1xuXG4gIFNpbmdsZUF4aXNWaWV3LnR5cGUgPSAnc2luZ2xlQXhpcyc7XG4gIHJldHVybiBTaW5nbGVBeGlzVmlldztcbn0oQXhpc1ZpZXcpO1xuXG52YXIgYXhpc0VsZW1lbnRCdWlsZGVycyA9IHtcbiAgc3BsaXRMaW5lOiBmdW5jdGlvbiAoYXhpc1ZpZXcsIGdyb3VwLCBheGlzR3JvdXAsIGF4aXNNb2RlbCkge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG5cbiAgICBpZiAoYXhpcy5zY2FsZS5pc0JsYW5rKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3BsaXRMaW5lTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ3NwbGl0TGluZScpO1xuICAgIHZhciBsaW5lU3R5bGVNb2RlbCA9IHNwbGl0TGluZU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgICB2YXIgbGluZUNvbG9ycyA9IGxpbmVTdHlsZU1vZGVsLmdldCgnY29sb3InKTtcbiAgICBsaW5lQ29sb3JzID0gbGluZUNvbG9ycyBpbnN0YW5jZW9mIEFycmF5ID8gbGluZUNvbG9ycyA6IFtsaW5lQ29sb3JzXTtcbiAgICB2YXIgZ3JpZFJlY3QgPSBheGlzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG4gICAgdmFyIGlzSG9yaXpvbnRhbCA9IGF4aXMuaXNIb3Jpem9udGFsKCk7XG4gICAgdmFyIHNwbGl0TGluZXMgPSBbXTtcbiAgICB2YXIgbGluZUNvdW50ID0gMDtcbiAgICB2YXIgdGlja3NDb29yZHMgPSBheGlzLmdldFRpY2tzQ29vcmRzKHtcbiAgICAgIHRpY2tNb2RlbDogc3BsaXRMaW5lTW9kZWxcbiAgICB9KTtcbiAgICB2YXIgcDEgPSBbXTtcbiAgICB2YXIgcDIgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3NDb29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLnRvR2xvYmFsQ29vcmQodGlja3NDb29yZHNbaV0uY29vcmQpO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHAxWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICBwMVsxXSA9IGdyaWRSZWN0Lnk7XG4gICAgICAgIHAyWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICBwMlsxXSA9IGdyaWRSZWN0LnkgKyBncmlkUmVjdC5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwMVswXSA9IGdyaWRSZWN0Lng7XG4gICAgICAgIHAxWzFdID0gdGlja0Nvb3JkO1xuICAgICAgICBwMlswXSA9IGdyaWRSZWN0LnggKyBncmlkUmVjdC53aWR0aDtcbiAgICAgICAgcDJbMV0gPSB0aWNrQ29vcmQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvckluZGV4ID0gbGluZUNvdW50KysgJSBsaW5lQ29sb3JzLmxlbmd0aDtcbiAgICAgIHNwbGl0TGluZXNbY29sb3JJbmRleF0gPSBzcGxpdExpbmVzW2NvbG9ySW5kZXhdIHx8IFtdO1xuICAgICAgc3BsaXRMaW5lc1tjb2xvckluZGV4XS5wdXNoKG5ldyBncmFwaGljLkxpbmUoe1xuICAgICAgICBzdWJQaXhlbE9wdGltaXplOiB0cnVlLFxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIHgxOiBwMVswXSxcbiAgICAgICAgICB5MTogcDFbMV0sXG4gICAgICAgICAgeDI6IHAyWzBdLFxuICAgICAgICAgIHkyOiBwMlsxXVxuICAgICAgICB9LFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB2YXIgbGluZVN0eWxlID0gbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKFsnY29sb3InXSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0TGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGdyb3VwLmFkZChncmFwaGljLm1lcmdlUGF0aChzcGxpdExpbmVzW2ldLCB7XG4gICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgIHN0cm9rZTogbGluZUNvbG9yc1tpICUgbGluZUNvbG9ycy5sZW5ndGhdXG4gICAgICAgIH0sIGxpbmVTdHlsZSksXG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSxcbiAgc3BsaXRBcmVhOiBmdW5jdGlvbiAoYXhpc1ZpZXcsIGdyb3VwLCBheGlzR3JvdXAsIGF4aXNNb2RlbCkge1xuICAgIHJlY3RDb29yZEF4aXNCdWlsZFNwbGl0QXJlYShheGlzVmlldywgYXhpc0dyb3VwLCBheGlzTW9kZWwsIGF4aXNNb2RlbCk7XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBTaW5nbGVBeGlzVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50JztcblxudmFyIEF4aXNQb2ludGVyTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQXhpc1BvaW50ZXJNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBBeGlzUG9pbnRlck1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IEF4aXNQb2ludGVyTW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBBeGlzUG9pbnRlck1vZGVsLnR5cGUgPSAnYXhpc1BvaW50ZXInO1xuICBBeGlzUG9pbnRlck1vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgLy8gJ2F1dG8nIG1lYW5zIHRoYXQgc2hvdyB3aGVuIHRyaWdnZXJlZCBieSB0b29sdGlwIG9yIGhhbmRsZS5cbiAgICBzaG93OiAnYXV0bycsXG4gICAgemxldmVsOiAwLFxuICAgIHo6IDUwLFxuICAgIHR5cGU6ICdsaW5lJyxcbiAgICAvLyBheGlzcG9pbnRlciB0cmlnZ2VyZWQgYnkgdG9vdGlwIGRldGVybWluZSBzbmFwIGF1dG9tYXRpY2FsbHksXG4gICAgLy8gc2VlIGBtb2RlbEhlbHBlcmAuXG4gICAgc25hcDogZmFsc2UsXG4gICAgdHJpZ2dlclRvb2x0aXA6IHRydWUsXG4gICAgdmFsdWU6IG51bGwsXG4gICAgc3RhdHVzOiBudWxsLFxuICAgIGxpbms6IFtdLFxuICAgIC8vIERvIG5vdCBzZXQgJ2F1dG8nIGhlcmUsIG90aGVyd2lzZSBnbG9iYWwgYW5pbWF0aW9uOiBmYWxzZVxuICAgIC8vIHdpbGwgbm90IGVmZmVjdCBhdCB0aGlzIGF4aXNwb2ludGVyLlxuICAgIGFuaW1hdGlvbjogbnVsbCxcbiAgICBhbmltYXRpb25EdXJhdGlvblVwZGF0ZTogMjAwLFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgY29sb3I6ICcjQjlCRUM5JyxcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgdHlwZTogJ2Rhc2hlZCdcbiAgICB9LFxuICAgIHNoYWRvd1N0eWxlOiB7XG4gICAgICBjb2xvcjogJ3JnYmEoMjEwLDIxOSwyMzgsMC4yKSdcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgZm9ybWF0dGVyOiBudWxsLFxuICAgICAgcHJlY2lzaW9uOiAnYXV0bycsXG4gICAgICBtYXJnaW46IDMsXG4gICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgcGFkZGluZzogWzUsIDcsIDUsIDddLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnYXV0bycsXG4gICAgICBib3JkZXJDb2xvcjogbnVsbCxcbiAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgYm9yZGVyUmFkaXVzOiAzXG4gICAgfSxcbiAgICBoYW5kbGU6IHtcbiAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBpY29uOiAnTTEwLjcsMTEuOXYtMS4zSDkuM3YxLjNjLTQuOSwwLjMtOC44LDQuNC04LjgsOS40YzAsNSwzLjksOS4xLDguOCw5LjRoMS4zYzQuOS0wLjMsOC44LTQuNCw4LjgtOS40QzE5LjUsMTYuMywxNS42LDEyLjIsMTAuNywxMS45eiBNMTMuMywyNC40SDYuN3YtMS4yaDYuNnogTTEzLjMsMjJINi43di0xLjJoNi42eiBNMTMuMywxOS42SDYuN3YtMS4yaDYuNnonLFxuICAgICAgc2l6ZTogNDUsXG4gICAgICAvLyBoYW5kbGUgbWFyZ2luIGlzIGZyb20gc3ltYm9sIGNlbnRlciB0byBheGlzLCB3aGljaCBpcyBzdGFibGUgd2hlbiBjaXJjdWxhciBtb3ZlLlxuICAgICAgbWFyZ2luOiA1MCxcbiAgICAgIC8vIGNvbG9yOiAnIzFiOGJiZCdcbiAgICAgIC8vIGNvbG9yOiAnIzJmNDU1NCdcbiAgICAgIGNvbG9yOiAnIzMzMycsXG4gICAgICBzaGFkb3dCbHVyOiAzLFxuICAgICAgc2hhZG93Q29sb3I6ICcjYWFhJyxcbiAgICAgIHNoYWRvd09mZnNldFg6IDAsXG4gICAgICBzaGFkb3dPZmZzZXRZOiAyLFxuICAgICAgLy8gRm9yIG1vYmlsZSBwZXJmb3JtYW5jZVxuICAgICAgdGhyb3R0bGU6IDQwXG4gICAgfVxuICB9O1xuICByZXR1cm4gQXhpc1BvaW50ZXJNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBBeGlzUG9pbnRlck1vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIGdsb2JhbExpc3RlbmVyIGZyb20gJy4vZ2xvYmFsTGlzdGVuZXInO1xuaW1wb3J0IENvbXBvbmVudFZpZXcgZnJvbSAnLi4vLi4vdmlldy9Db21wb25lbnQnO1xuXG52YXIgQXhpc1BvaW50ZXJWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEF4aXNQb2ludGVyVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBBeGlzUG9pbnRlclZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gQXhpc1BvaW50ZXJWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgQXhpc1BvaW50ZXJWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGdsb2JhbFRvb2x0aXBNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCd0b29sdGlwJyk7XG4gICAgdmFyIHRyaWdnZXJPbiA9IGdsb2JhbEF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0cmlnZ2VyT24nKSB8fCBnbG9iYWxUb29sdGlwTW9kZWwgJiYgZ2xvYmFsVG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlck9uJykgfHwgJ21vdXNlbW92ZXxjbGljayc7IC8vIFJlZ2lzdGVyIGdsb2JhbCBsaXN0ZW5lciBpbiBBeGlzUG9pbnRlclZpZXcgdG8gZW5hYmxlXG4gICAgLy8gQXhpc1BvaW50ZXJWaWV3IHRvIGJlIGluZGVwZW5kZW50IHRvIFRvb2x0aXAuXG5cbiAgICBnbG9iYWxMaXN0ZW5lci5yZWdpc3RlcignYXhpc1BvaW50ZXInLCBhcGksIGZ1bmN0aW9uIChjdXJyVHJpZ2dlciwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgIC8vIElmICdub25lJywgaXQgaXMgbm90IGNvbnRyb2xsZWQgYnkgbW91c2UgdG90YWxseS5cbiAgICAgIGlmICh0cmlnZ2VyT24gIT09ICdub25lJyAmJiAoY3VyclRyaWdnZXIgPT09ICdsZWF2ZScgfHwgdHJpZ2dlck9uLmluZGV4T2YoY3VyclRyaWdnZXIpID49IDApKSB7XG4gICAgICAgIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgICAgIGN1cnJUcmlnZ2VyOiBjdXJyVHJpZ2dlcixcbiAgICAgICAgICB4OiBlICYmIGUub2Zmc2V0WCxcbiAgICAgICAgICB5OiBlICYmIGUub2Zmc2V0WVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBBeGlzUG9pbnRlclZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBnbG9iYWxMaXN0ZW5lci51bnJlZ2lzdGVyKCdheGlzUG9pbnRlcicsIGFwaSk7XG4gIH07XG5cbiAgQXhpc1BvaW50ZXJWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIGdsb2JhbExpc3RlbmVyLnVucmVnaXN0ZXIoJ2F4aXNQb2ludGVyJywgYXBpKTtcbiAgfTtcblxuICBBeGlzUG9pbnRlclZpZXcudHlwZSA9ICdheGlzUG9pbnRlcic7XG4gIHJldHVybiBBeGlzUG9pbnRlclZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuXG5leHBvcnQgZGVmYXVsdCBBeGlzUG9pbnRlclZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0ICogYXMgYXhpc1BvaW50ZXJNb2RlbEhlbHBlciBmcm9tICcuL21vZGVsSGVscGVyJztcbmltcG9ydCAqIGFzIGV2ZW50VG9vbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL2V2ZW50JztcbmltcG9ydCAqIGFzIHRocm90dGxlVXRpbCBmcm9tICcuLi8uLi91dGlsL3Rocm90dGxlJztcbmltcG9ydCB7IG1ha2VJbm5lciB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwnO1xudmFyIGlubmVyID0gbWFrZUlubmVyKCk7XG52YXIgY2xvbmUgPSB6clV0aWwuY2xvbmU7XG52YXIgYmluZCA9IHpyVXRpbC5iaW5kO1xuLyoqXG4gKiBCYXNlIGF4aXMgcG9pbnRlciBjbGFzcyBpbiAyRC5cbiAqL1xuXG52YXIgQmFzZUF4aXNQb2ludGVyID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZUF4aXNQb2ludGVyKCkge1xuICAgIHRoaXMuX2RyYWdnaW5nID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogSW4gcHgsIGFyYml0cmFyeSB2YWx1ZS4gRG8gbm90IHNldCB0b28gc21hbGwsXG4gICAgICogbm8gYW5pbWF0aW9uIGlzIG9rIGZvciBtb3N0IGNhc2VzLlxuICAgICAqL1xuXG4gICAgdGhpcy5hbmltYXRpb25UaHJlc2hvbGQgPSAxNTtcbiAgfVxuICAvKipcbiAgICogQGltcGxlbWVudFxuICAgKi9cblxuXG4gIEJhc2VBeGlzUG9pbnRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpLCBmb3JjZVJlbmRlcikge1xuICAgIHZhciB2YWx1ZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd2YWx1ZScpO1xuICAgIHZhciBzdGF0dXMgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc3RhdHVzJyk7IC8vIEJpbmQgdGhlbSB0byBgdGhpc2AsIG5vdCBpbiBjbG9zdXJlLCBvdGhlcndpc2UgdGhleSB3aWxsIG5vdFxuICAgIC8vIGJlIHJlcGxhY2VkIHdoZW4gdXNlciBjYWxsaW5nIHNldE9wdGlvbiBpbiBub3QgbWVyZ2UgbW9kZS5cblxuICAgIHRoaXMuX2F4aXNNb2RlbCA9IGF4aXNNb2RlbDtcbiAgICB0aGlzLl9heGlzUG9pbnRlck1vZGVsID0gYXhpc1BvaW50ZXJNb2RlbDtcbiAgICB0aGlzLl9hcGkgPSBhcGk7IC8vIE9wdGltaXplOiBgcmVuZGVyYCB3aWxsIGJlIGNhbGxlZCByZXBlYXRseSBkdXJpbmcgbW91c2UgbW92ZS5cbiAgICAvLyBTbyBpdCBpcyBwb3dlciBjb25zdW1pbmcgaWYgcGVyZm9ybWluZyBgcmVuZGVyYCBlYWNoIHRpbWUsXG4gICAgLy8gZXNwZWNpYWxseSBvbiBtb2JpbGUgZGV2aWNlLlxuXG4gICAgaWYgKCFmb3JjZVJlbmRlciAmJiB0aGlzLl9sYXN0VmFsdWUgPT09IHZhbHVlICYmIHRoaXMuX2xhc3RTdGF0dXMgPT09IHN0YXR1cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2xhc3RWYWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuX2xhc3RTdGF0dXMgPSBzdGF0dXM7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5fZ3JvdXA7XG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcblxuICAgIGlmICghc3RhdHVzIHx8IHN0YXR1cyA9PT0gJ2hpZGUnKSB7XG4gICAgICAvLyBEbyBub3QgY2xlYXIgaGVyZSwgZm9yIGFuaW1hdGlvbiBiZXR0ZXIuXG4gICAgICBncm91cCAmJiBncm91cC5oaWRlKCk7XG4gICAgICBoYW5kbGUgJiYgaGFuZGxlLmhpZGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBncm91cCAmJiBncm91cC5zaG93KCk7XG4gICAgaGFuZGxlICYmIGhhbmRsZS5zaG93KCk7IC8vIE90aGVyd2lzZSBzdGF0dXMgaXMgJ3Nob3cnXG5cbiAgICB2YXIgZWxPcHRpb24gPSB7fTtcbiAgICB0aGlzLm1ha2VFbE9wdGlvbihlbE9wdGlvbiwgdmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpKTsgLy8gRW5hYmxlIGNoYW5nZSBheGlzIHBvaW50ZXIgdHlwZS5cblxuICAgIHZhciBncmFwaGljS2V5ID0gZWxPcHRpb24uZ3JhcGhpY0tleTtcblxuICAgIGlmIChncmFwaGljS2V5ICE9PSB0aGlzLl9sYXN0R3JhcGhpY0tleSkge1xuICAgICAgdGhpcy5jbGVhcihhcGkpO1xuICAgIH1cblxuICAgIHRoaXMuX2xhc3RHcmFwaGljS2V5ID0gZ3JhcGhpY0tleTtcbiAgICB2YXIgbW92ZUFuaW1hdGlvbiA9IHRoaXMuX21vdmVBbmltYXRpb24gPSB0aGlzLmRldGVybWluZUFuaW1hdGlvbihheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuXG4gICAgaWYgKCFncm91cCkge1xuICAgICAgZ3JvdXAgPSB0aGlzLl9ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgICB0aGlzLmNyZWF0ZVBvaW50ZXJFbChncm91cCwgZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICB0aGlzLmNyZWF0ZUxhYmVsRWwoZ3JvdXAsIGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgYXBpLmdldFpyKCkuYWRkKGdyb3VwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRvVXBkYXRlUHJvcHMgPSB6clV0aWwuY3VycnkodXBkYXRlUHJvcHMsIGF4aXNQb2ludGVyTW9kZWwsIG1vdmVBbmltYXRpb24pO1xuICAgICAgdGhpcy51cGRhdGVQb2ludGVyRWwoZ3JvdXAsIGVsT3B0aW9uLCBkb1VwZGF0ZVByb3BzKTtcbiAgICAgIHRoaXMudXBkYXRlTGFiZWxFbChncm91cCwgZWxPcHRpb24sIGRvVXBkYXRlUHJvcHMsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgIH1cblxuICAgIHVwZGF0ZU1hbmRhdG9yeVByb3BzKGdyb3VwLCBheGlzUG9pbnRlck1vZGVsLCB0cnVlKTtcblxuICAgIHRoaXMuX3JlbmRlckhhbmRsZSh2YWx1ZSk7XG4gIH07XG4gIC8qKlxuICAgKiBAaW1wbGVtZW50XG4gICAqL1xuXG5cbiAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoYXBpKSB7XG4gICAgdGhpcy5jbGVhcihhcGkpO1xuICB9O1xuICAvKipcbiAgICogQGltcGxlbWVudFxuICAgKi9cblxuXG4gIEJhc2VBeGlzUG9pbnRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB0aGlzLmNsZWFyKGFwaSk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cbiAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS5kZXRlcm1pbmVBbmltYXRpb24gPSBmdW5jdGlvbiAoYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsKSB7XG4gICAgdmFyIGFuaW1hdGlvbiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdhbmltYXRpb24nKTtcbiAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgIHZhciBpc0NhdGVnb3J5QXhpcyA9IGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgICB2YXIgdXNlU25hcCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzbmFwJyk7IC8vIFZhbHVlIGF4aXMgd2l0aG91dCBzbmFwIGFsd2F5cyBkbyBub3Qgc25hcC5cblxuICAgIGlmICghdXNlU25hcCAmJiAhaXNDYXRlZ29yeUF4aXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0aW9uID09PSAnYXV0bycgfHwgYW5pbWF0aW9uID09IG51bGwpIHtcbiAgICAgIHZhciBhbmltYXRpb25UaHJlc2hvbGQgPSB0aGlzLmFuaW1hdGlvblRocmVzaG9sZDtcblxuICAgICAgaWYgKGlzQ2F0ZWdvcnlBeGlzICYmIGF4aXMuZ2V0QmFuZFdpZHRoKCkgPiBhbmltYXRpb25UaHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIEl0IGlzIGltcG9ydGFudCB0byBhdXRvIGFuaW1hdGlvbiB3aGVuIHNuYXAgdXNlZC4gQ29uc2lkZXIgaWYgdGhlcmUgaXNcbiAgICAgIC8vIGEgZGF0YVpvb20sIGFuaW1hdGlvbiB3aWxsIGJlIGRpc2FibGVkIHdoZW4gdG9vIG1hbnkgcG9pbnRzIGV4aXN0LCB3aGlsZVxuICAgICAgLy8gaXQgd2lsbCBiZSBlbmFibGVkIGZvciBiZXR0ZXIgdmlzdWFsIGVmZmVjdCB3aGVuIGxpdHRsZSBwb2ludHMgZXhpc3QuXG5cblxuICAgICAgaWYgKHVzZVNuYXApIHtcbiAgICAgICAgdmFyIHNlcmllc0RhdGFDb3VudCA9IGF4aXNQb2ludGVyTW9kZWxIZWxwZXIuZ2V0QXhpc0luZm8oYXhpc01vZGVsKS5zZXJpZXNEYXRhQ291bnQ7XG4gICAgICAgIHZhciBheGlzRXh0ZW50ID0gYXhpcy5nZXRFeHRlbnQoKTsgLy8gQXBwcm94aW1hdGUgYmFuZCB3aWR0aFxuXG4gICAgICAgIHJldHVybiBNYXRoLmFicyhheGlzRXh0ZW50WzBdIC0gYXhpc0V4dGVudFsxXSkgLyBzZXJpZXNEYXRhQ291bnQgPiBhbmltYXRpb25UaHJlc2hvbGQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9uID09PSB0cnVlO1xuICB9O1xuICAvKipcbiAgICogYWRkIHtwb2ludGVyLCBsYWJlbCwgZ3JhcGhpY0tleX0gdG8gZWxPcHRpb25cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXG4gIEJhc2VBeGlzUG9pbnRlci5wcm90b3R5cGUubWFrZUVsT3B0aW9uID0gZnVuY3Rpb24gKGVsT3B0aW9uLCB2YWx1ZSwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGkpIHsvLyBTaG91bGUgYmUgaW1wbGVtZW5lbnRlZCBieSBzdWItY2xhc3MuXG4gIH07XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cbiAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS5jcmVhdGVQb2ludGVyRWwgPSBmdW5jdGlvbiAoZ3JvdXAsIGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICB2YXIgcG9pbnRlck9wdGlvbiA9IGVsT3B0aW9uLnBvaW50ZXI7XG5cbiAgICBpZiAocG9pbnRlck9wdGlvbikge1xuICAgICAgdmFyIHBvaW50ZXJFbCA9IGlubmVyKGdyb3VwKS5wb2ludGVyRWwgPSBuZXcgZ3JhcGhpY1twb2ludGVyT3B0aW9uLnR5cGVdKGNsb25lKGVsT3B0aW9uLnBvaW50ZXIpKTtcbiAgICAgIGdyb3VwLmFkZChwb2ludGVyRWwpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblxuICBCYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlLmNyZWF0ZUxhYmVsRWwgPSBmdW5jdGlvbiAoZ3JvdXAsIGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICBpZiAoZWxPcHRpb24ubGFiZWwpIHtcbiAgICAgIHZhciBsYWJlbEVsID0gaW5uZXIoZ3JvdXApLmxhYmVsRWwgPSBuZXcgZ3JhcGhpYy5UZXh0KGNsb25lKGVsT3B0aW9uLmxhYmVsKSk7XG4gICAgICBncm91cC5hZGQobGFiZWxFbCk7XG4gICAgICB1cGRhdGVMYWJlbFNob3dIaWRlKGxhYmVsRWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblxuICBCYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlLnVwZGF0ZVBvaW50ZXJFbCA9IGZ1bmN0aW9uIChncm91cCwgZWxPcHRpb24sIHVwZGF0ZVByb3BzKSB7XG4gICAgdmFyIHBvaW50ZXJFbCA9IGlubmVyKGdyb3VwKS5wb2ludGVyRWw7XG5cbiAgICBpZiAocG9pbnRlckVsICYmIGVsT3B0aW9uLnBvaW50ZXIpIHtcbiAgICAgIHBvaW50ZXJFbC5zZXRTdHlsZShlbE9wdGlvbi5wb2ludGVyLnN0eWxlKTtcbiAgICAgIHVwZGF0ZVByb3BzKHBvaW50ZXJFbCwge1xuICAgICAgICBzaGFwZTogZWxPcHRpb24ucG9pbnRlci5zaGFwZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXG4gIEJhc2VBeGlzUG9pbnRlci5wcm90b3R5cGUudXBkYXRlTGFiZWxFbCA9IGZ1bmN0aW9uIChncm91cCwgZWxPcHRpb24sIHVwZGF0ZVByb3BzLCBheGlzUG9pbnRlck1vZGVsKSB7XG4gICAgdmFyIGxhYmVsRWwgPSBpbm5lcihncm91cCkubGFiZWxFbDtcblxuICAgIGlmIChsYWJlbEVsKSB7XG4gICAgICBsYWJlbEVsLnNldFN0eWxlKGVsT3B0aW9uLmxhYmVsLnN0eWxlKTtcbiAgICAgIHVwZGF0ZVByb3BzKGxhYmVsRWwsIHtcbiAgICAgICAgLy8gQ29uc2lkZXIgdGV4dCBsZW5ndGggY2hhbmdlIGluIHZlcnRpY2FsIGF4aXMsIGFuaW1hdGlvbiBzaG91bGRcbiAgICAgICAgLy8gYmUgdXNlZCBvbiBzaGFwZSwgb3RoZXJ3aXNlIHRoZSBlZmZlY3Qgd2lsbCBiZSB3ZWlyZC5cbiAgICAgICAgLy8gVE9ET1RPRE9cbiAgICAgICAgLy8gc2hhcGU6IGVsT3B0aW9uLmxhYmVsLnNoYXBlLFxuICAgICAgICB4OiBlbE9wdGlvbi5sYWJlbC54LFxuICAgICAgICB5OiBlbE9wdGlvbi5sYWJlbC55XG4gICAgICB9KTtcbiAgICAgIHVwZGF0ZUxhYmVsU2hvd0hpZGUobGFiZWxFbCwgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBCYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlLl9yZW5kZXJIYW5kbGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fZHJhZ2dpbmcgfHwgIXRoaXMudXBkYXRlSGFuZGxlVHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF4aXNQb2ludGVyTW9kZWwgPSB0aGlzLl9heGlzUG9pbnRlck1vZGVsO1xuXG4gICAgdmFyIHpyID0gdGhpcy5fYXBpLmdldFpyKCk7XG5cbiAgICB2YXIgaGFuZGxlID0gdGhpcy5faGFuZGxlO1xuICAgIHZhciBoYW5kbGVNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0TW9kZWwoJ2hhbmRsZScpO1xuICAgIHZhciBzdGF0dXMgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc3RhdHVzJyk7XG5cbiAgICBpZiAoIWhhbmRsZU1vZGVsLmdldCgnc2hvdycpIHx8ICFzdGF0dXMgfHwgc3RhdHVzID09PSAnaGlkZScpIHtcbiAgICAgIGhhbmRsZSAmJiB6ci5yZW1vdmUoaGFuZGxlKTtcbiAgICAgIHRoaXMuX2hhbmRsZSA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdDtcblxuICAgIGlmICghdGhpcy5faGFuZGxlKSB7XG4gICAgICBpc0luaXQgPSB0cnVlO1xuICAgICAgaGFuZGxlID0gdGhpcy5faGFuZGxlID0gZ3JhcGhpYy5jcmVhdGVJY29uKGhhbmRsZU1vZGVsLmdldCgnaWNvbicpLCB7XG4gICAgICAgIGN1cnNvcjogJ21vdmUnLFxuICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgIG9ubW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIC8vIEZvdCBtb2JpbGUgZGV2aWNlbSwgcHJldmVudCBzY3JlZW4gc2xpZGVyIG9uIHRoZSBidXR0b24uXG4gICAgICAgICAgZXZlbnRUb29sLnN0b3AoZS5ldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9ubW91c2Vkb3duOiBiaW5kKHRoaXMuX29uSGFuZGxlRHJhZ01vdmUsIHRoaXMsIDAsIDApLFxuICAgICAgICBkcmlmdDogYmluZCh0aGlzLl9vbkhhbmRsZURyYWdNb3ZlLCB0aGlzKSxcbiAgICAgICAgb25kcmFnZW5kOiBiaW5kKHRoaXMuX29uSGFuZGxlRHJhZ0VuZCwgdGhpcylcbiAgICAgIH0pO1xuICAgICAgenIuYWRkKGhhbmRsZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlTWFuZGF0b3J5UHJvcHMoaGFuZGxlLCBheGlzUG9pbnRlck1vZGVsLCBmYWxzZSk7IC8vIHVwZGF0ZSBzdHlsZVxuXG4gICAgaGFuZGxlLnNldFN0eWxlKGhhbmRsZU1vZGVsLmdldEl0ZW1TdHlsZShudWxsLCBbJ2NvbG9yJywgJ2JvcmRlckNvbG9yJywgJ2JvcmRlcldpZHRoJywgJ29wYWNpdHknLCAnc2hhZG93Q29sb3InLCAnc2hhZG93Qmx1cicsICdzaGFkb3dPZmZzZXRYJywgJ3NoYWRvd09mZnNldFknXSkpOyAvLyB1cGRhdGUgcG9zaXRpb25cblxuICAgIHZhciBoYW5kbGVTaXplID0gaGFuZGxlTW9kZWwuZ2V0KCdzaXplJyk7XG5cbiAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGhhbmRsZVNpemUpKSB7XG4gICAgICBoYW5kbGVTaXplID0gW2hhbmRsZVNpemUsIGhhbmRsZVNpemVdO1xuICAgIH1cblxuICAgIGhhbmRsZS5zY2FsZVggPSBoYW5kbGVTaXplWzBdIC8gMjtcbiAgICBoYW5kbGUuc2NhbGVZID0gaGFuZGxlU2l6ZVsxXSAvIDI7XG4gICAgdGhyb3R0bGVVdGlsLmNyZWF0ZU9yVXBkYXRlKHRoaXMsICdfZG9EaXNwYXRjaEF4aXNQb2ludGVyJywgaGFuZGxlTW9kZWwuZ2V0KCd0aHJvdHRsZScpIHx8IDAsICdmaXhSYXRlJyk7XG5cbiAgICB0aGlzLl9tb3ZlSGFuZGxlVG9WYWx1ZSh2YWx1ZSwgaXNJbml0KTtcbiAgfTtcblxuICBCYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlLl9tb3ZlSGFuZGxlVG9WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaXNJbml0KSB7XG4gICAgdXBkYXRlUHJvcHModGhpcy5fYXhpc1BvaW50ZXJNb2RlbCwgIWlzSW5pdCAmJiB0aGlzLl9tb3ZlQW5pbWF0aW9uLCB0aGlzLl9oYW5kbGUsIGdldEhhbmRsZVRyYW5zUHJvcHModGhpcy5nZXRIYW5kbGVUcmFuc2Zvcm0odmFsdWUsIHRoaXMuX2F4aXNNb2RlbCwgdGhpcy5fYXhpc1BvaW50ZXJNb2RlbCkpKTtcbiAgfTtcblxuICBCYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlLl9vbkhhbmRsZURyYWdNb3ZlID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG5cbiAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYWdnaW5nID0gdHJ1ZTsgLy8gUGVyc2lzdGVudCBmb3IgdGhyb3R0bGUuXG5cbiAgICB2YXIgdHJhbnMgPSB0aGlzLnVwZGF0ZUhhbmRsZVRyYW5zZm9ybShnZXRIYW5kbGVUcmFuc1Byb3BzKGhhbmRsZSksIFtkeCwgZHldLCB0aGlzLl9heGlzTW9kZWwsIHRoaXMuX2F4aXNQb2ludGVyTW9kZWwpO1xuICAgIHRoaXMuX3BheWxvYWRJbmZvID0gdHJhbnM7XG4gICAgaGFuZGxlLnN0b3BBbmltYXRpb24oKTtcbiAgICBoYW5kbGUuYXR0cihnZXRIYW5kbGVUcmFuc1Byb3BzKHRyYW5zKSk7XG4gICAgaW5uZXIoaGFuZGxlKS5sYXN0UHJvcCA9IG51bGw7XG5cbiAgICB0aGlzLl9kb0Rpc3BhdGNoQXhpc1BvaW50ZXIoKTtcbiAgfTtcbiAgLyoqXG4gICAqIFRocm90dGxlZCBtZXRob2QuXG4gICAqL1xuXG5cbiAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS5fZG9EaXNwYXRjaEF4aXNQb2ludGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG5cbiAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXlsb2FkSW5mbyA9IHRoaXMuX3BheWxvYWRJbmZvO1xuICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLl9heGlzTW9kZWw7XG5cbiAgICB0aGlzLl9hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgICAgIHg6IHBheWxvYWRJbmZvLmN1cnNvclBvaW50WzBdLFxuICAgICAgeTogcGF5bG9hZEluZm8uY3Vyc29yUG9pbnRbMV0sXG4gICAgICB0b29sdGlwT3B0aW9uOiBwYXlsb2FkSW5mby50b29sdGlwT3B0aW9uLFxuICAgICAgYXhlc0luZm86IFt7XG4gICAgICAgIGF4aXNEaW06IGF4aXNNb2RlbC5heGlzLmRpbSxcbiAgICAgICAgYXhpc0luZGV4OiBheGlzTW9kZWwuY29tcG9uZW50SW5kZXhcbiAgICAgIH1dXG4gICAgfSk7XG4gIH07XG5cbiAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS5fb25IYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2RyYWdnaW5nID0gZmFsc2U7XG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcblxuICAgIGlmICghaGFuZGxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5fYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3ZhbHVlJyk7IC8vIENvbnNpZGVyIHNuYXAgb3IgY2F0ZWdyb3kgYXhpcywgaGFuZGxlIG1heSBiZSBub3QgY29uc2lzdGVudCB3aXRoXG4gICAgLy8gYXhpc1BvaW50ZXIuIFNvIG1vdmUgaGFuZGxlIHRvIGFsaWduIHRoZSBleGFjdCB2YWx1ZSBwb3NpdGlvbiB3aGVuXG4gICAgLy8gZHJhZyBlbmRlZC5cblxuXG4gICAgdGhpcy5fbW92ZUhhbmRsZVRvVmFsdWUodmFsdWUpOyAvLyBGb3IgdGhlIGVmZmVjdDogdG9vbHRpcCB3aWxsIGJlIHNob3duIHdoZW4gZmluZ2VyIGhvbGRpbmcgb24gaGFuZGxlXG4gICAgLy8gYnV0dG9uLCBhbmQgd2lsbCBiZSBoaWRkZW4gYWZ0ZXIgZmluZ2VyIGxlZnQgaGFuZGxlIGJ1dHRvbi5cblxuXG4gICAgdGhpcy5fYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdoaWRlVGlwJ1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBCYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKGFwaSkge1xuICAgIHRoaXMuX2xhc3RWYWx1ZSA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFN0YXR1cyA9IG51bGw7XG4gICAgdmFyIHpyID0gYXBpLmdldFpyKCk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5fZ3JvdXA7XG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcblxuICAgIGlmICh6ciAmJiBncm91cCkge1xuICAgICAgdGhpcy5fbGFzdEdyYXBoaWNLZXkgPSBudWxsO1xuICAgICAgZ3JvdXAgJiYgenIucmVtb3ZlKGdyb3VwKTtcbiAgICAgIGhhbmRsZSAmJiB6ci5yZW1vdmUoaGFuZGxlKTtcbiAgICAgIHRoaXMuX2dyb3VwID0gbnVsbDtcbiAgICAgIHRoaXMuX2hhbmRsZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYXlsb2FkSW5mbyA9IG51bGw7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXG4gIEJhc2VBeGlzUG9pbnRlci5wcm90b3R5cGUuZG9DbGVhciA9IGZ1bmN0aW9uICgpIHsvLyBJbXBsZW1lbnRlZCBieSBzdWItY2xhc3MgaWYgbmVjZXNzYXJ5LlxuICB9O1xuXG4gIEJhc2VBeGlzUG9pbnRlci5wcm90b3R5cGUuYnVpbGRMYWJlbCA9IGZ1bmN0aW9uICh4eSwgd2gsIHhEaW1JbmRleCkge1xuICAgIHhEaW1JbmRleCA9IHhEaW1JbmRleCB8fCAwO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4eVt4RGltSW5kZXhdLFxuICAgICAgeTogeHlbMSAtIHhEaW1JbmRleF0sXG4gICAgICB3aWR0aDogd2hbeERpbUluZGV4XSxcbiAgICAgIGhlaWdodDogd2hbMSAtIHhEaW1JbmRleF1cbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBCYXNlQXhpc1BvaW50ZXI7XG59KCk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGFuaW1hdGlvbk1vZGVsLCBtb3ZlQW5pbWF0aW9uLCBlbCwgcHJvcHMpIHtcbiAgLy8gQW5pbWF0aW9uIG9wdGltaXplLlxuICBpZiAoIXByb3BzRXF1YWwoaW5uZXIoZWwpLmxhc3RQcm9wLCBwcm9wcykpIHtcbiAgICBpbm5lcihlbCkubGFzdFByb3AgPSBwcm9wcztcbiAgICBtb3ZlQW5pbWF0aW9uID8gZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwgcHJvcHMsIGFuaW1hdGlvbk1vZGVsKSA6IChlbC5zdG9wQW5pbWF0aW9uKCksIGVsLmF0dHIocHJvcHMpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9wc0VxdWFsKGxhc3RQcm9wcywgbmV3UHJvcHMpIHtcbiAgaWYgKHpyVXRpbC5pc09iamVjdChsYXN0UHJvcHMpICYmIHpyVXRpbC5pc09iamVjdChuZXdQcm9wcykpIHtcbiAgICB2YXIgZXF1YWxzXzEgPSB0cnVlO1xuICAgIHpyVXRpbC5lYWNoKG5ld1Byb3BzLCBmdW5jdGlvbiAoaXRlbSwga2V5KSB7XG4gICAgICBlcXVhbHNfMSA9IGVxdWFsc18xICYmIHByb3BzRXF1YWwobGFzdFByb3BzW2tleV0sIGl0ZW0pO1xuICAgIH0pO1xuICAgIHJldHVybiAhIWVxdWFsc18xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXN0UHJvcHMgPT09IG5ld1Byb3BzO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxhYmVsU2hvd0hpZGUobGFiZWxFbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICBsYWJlbEVsW2F4aXNQb2ludGVyTW9kZWwuZ2V0KFsnbGFiZWwnLCAnc2hvdyddKSA/ICdzaG93JyA6ICdoaWRlJ10oKTtcbn1cblxuZnVuY3Rpb24gZ2V0SGFuZGxlVHJhbnNQcm9wcyh0cmFucykge1xuICByZXR1cm4ge1xuICAgIHg6IHRyYW5zLnggfHwgMCxcbiAgICB5OiB0cmFucy55IHx8IDAsXG4gICAgcm90YXRpb246IHRyYW5zLnJvdGF0aW9uIHx8IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWFuZGF0b3J5UHJvcHMoZ3JvdXAsIGF4aXNQb2ludGVyTW9kZWwsIHNpbGVudCkge1xuICB2YXIgeiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd6Jyk7XG4gIHZhciB6bGV2ZWwgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnemxldmVsJyk7XG4gIGdyb3VwICYmIGdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICB6ICE9IG51bGwgJiYgKGVsLnogPSB6KTtcbiAgICAgIHpsZXZlbCAhPSBudWxsICYmIChlbC56bGV2ZWwgPSB6bGV2ZWwpO1xuICAgICAgZWwuc2lsZW50ID0gc2lsZW50O1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VBeGlzUG9pbnRlcjsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQmFzZUF4aXNQb2ludGVyIGZyb20gJy4vQmFzZUF4aXNQb2ludGVyJztcbmltcG9ydCAqIGFzIHZpZXdIZWxwZXIgZnJvbSAnLi92aWV3SGVscGVyJztcbmltcG9ydCAqIGFzIGNhcnRlc2lhbkF4aXNIZWxwZXIgZnJvbSAnLi4vLi4vY29vcmQvY2FydGVzaWFuL2NhcnRlc2lhbkF4aXNIZWxwZXInO1xuXG52YXIgQ2FydGVzaWFuQXhpc1BvaW50ZXIgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ2FydGVzaWFuQXhpc1BvaW50ZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gQ2FydGVzaWFuQXhpc1BvaW50ZXIoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBDYXJ0ZXNpYW5BeGlzUG9pbnRlci5wcm90b3R5cGUubWFrZUVsT3B0aW9uID0gZnVuY3Rpb24gKGVsT3B0aW9uLCB2YWx1ZSwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGkpIHtcbiAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgIHZhciBncmlkID0gYXhpcy5ncmlkO1xuICAgIHZhciBheGlzUG9pbnRlclR5cGUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndHlwZScpO1xuICAgIHZhciBvdGhlckV4dGVudCA9IGdldENhcnRlc2lhbihncmlkLCBheGlzKS5nZXRPdGhlckF4aXMoYXhpcykuZ2V0R2xvYmFsRXh0ZW50KCk7XG4gICAgdmFyIHBpeGVsVmFsdWUgPSBheGlzLnRvR2xvYmFsQ29vcmQoYXhpcy5kYXRhVG9Db29yZCh2YWx1ZSwgdHJ1ZSkpO1xuXG4gICAgaWYgKGF4aXNQb2ludGVyVHlwZSAmJiBheGlzUG9pbnRlclR5cGUgIT09ICdub25lJykge1xuICAgICAgdmFyIGVsU3R5bGUgPSB2aWV3SGVscGVyLmJ1aWxkRWxTdHlsZShheGlzUG9pbnRlck1vZGVsKTtcbiAgICAgIHZhciBwb2ludGVyT3B0aW9uID0gcG9pbnRlclNoYXBlQnVpbGRlcltheGlzUG9pbnRlclR5cGVdKGF4aXMsIHBpeGVsVmFsdWUsIG90aGVyRXh0ZW50KTtcbiAgICAgIHBvaW50ZXJPcHRpb24uc3R5bGUgPSBlbFN0eWxlO1xuICAgICAgZWxPcHRpb24uZ3JhcGhpY0tleSA9IHBvaW50ZXJPcHRpb24udHlwZTtcbiAgICAgIGVsT3B0aW9uLnBvaW50ZXIgPSBwb2ludGVyT3B0aW9uO1xuICAgIH1cblxuICAgIHZhciBsYXlvdXRJbmZvID0gY2FydGVzaWFuQXhpc0hlbHBlci5sYXlvdXQoZ3JpZC5tb2RlbCwgYXhpc01vZGVsKTtcbiAgICB2aWV3SGVscGVyLmJ1aWxkQ2FydGVzaWFuU2luZ2xlTGFiZWxFbE9wdGlvbiggLy8gQHRzLWlnbm9yZVxuICAgIHZhbHVlLCBlbE9wdGlvbiwgbGF5b3V0SW5mbywgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGkpO1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgQ2FydGVzaWFuQXhpc1BvaW50ZXIucHJvdG90eXBlLmdldEhhbmRsZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsKSB7XG4gICAgdmFyIGxheW91dEluZm8gPSBjYXJ0ZXNpYW5BeGlzSGVscGVyLmxheW91dChheGlzTW9kZWwuYXhpcy5ncmlkLm1vZGVsLCBheGlzTW9kZWwsIHtcbiAgICAgIGxhYmVsSW5zaWRlOiBmYWxzZVxuICAgIH0pOyAvLyBAdHMtaWdub3JlXG5cbiAgICBsYXlvdXRJbmZvLmxhYmVsTWFyZ2luID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoWydoYW5kbGUnLCAnbWFyZ2luJ10pO1xuICAgIHZhciBwb3MgPSB2aWV3SGVscGVyLmdldFRyYW5zZm9ybWVkUG9zaXRpb24oYXhpc01vZGVsLmF4aXMsIHZhbHVlLCBsYXlvdXRJbmZvKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcG9zWzBdLFxuICAgICAgeTogcG9zWzFdLFxuICAgICAgcm90YXRpb246IGxheW91dEluZm8ucm90YXRpb24gKyAobGF5b3V0SW5mby5sYWJlbERpcmVjdGlvbiA8IDAgPyBNYXRoLlBJIDogMClcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgQ2FydGVzaWFuQXhpc1BvaW50ZXIucHJvdG90eXBlLnVwZGF0ZUhhbmRsZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIGRlbHRhLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgIHZhciBncmlkID0gYXhpcy5ncmlkO1xuICAgIHZhciBheGlzRXh0ZW50ID0gYXhpcy5nZXRHbG9iYWxFeHRlbnQodHJ1ZSk7XG4gICAgdmFyIG90aGVyRXh0ZW50ID0gZ2V0Q2FydGVzaWFuKGdyaWQsIGF4aXMpLmdldE90aGVyQXhpcyhheGlzKS5nZXRHbG9iYWxFeHRlbnQoKTtcbiAgICB2YXIgZGltSW5kZXggPSBheGlzLmRpbSA9PT0gJ3gnID8gMCA6IDE7XG4gICAgdmFyIGN1cnJQb3NpdGlvbiA9IFt0cmFuc2Zvcm0ueCwgdHJhbnNmb3JtLnldO1xuICAgIGN1cnJQb3NpdGlvbltkaW1JbmRleF0gKz0gZGVsdGFbZGltSW5kZXhdO1xuICAgIGN1cnJQb3NpdGlvbltkaW1JbmRleF0gPSBNYXRoLm1pbihheGlzRXh0ZW50WzFdLCBjdXJyUG9zaXRpb25bZGltSW5kZXhdKTtcbiAgICBjdXJyUG9zaXRpb25bZGltSW5kZXhdID0gTWF0aC5tYXgoYXhpc0V4dGVudFswXSwgY3VyclBvc2l0aW9uW2RpbUluZGV4XSk7XG4gICAgdmFyIGN1cnNvck90aGVyVmFsdWUgPSAob3RoZXJFeHRlbnRbMV0gKyBvdGhlckV4dGVudFswXSkgLyAyO1xuICAgIHZhciBjdXJzb3JQb2ludCA9IFtjdXJzb3JPdGhlclZhbHVlLCBjdXJzb3JPdGhlclZhbHVlXTtcbiAgICBjdXJzb3JQb2ludFtkaW1JbmRleF0gPSBjdXJyUG9zaXRpb25bZGltSW5kZXhdOyAvLyBNYWtlIHRvb2x0aXAgZG8gbm90IG92ZXJsYXAgYXhpc1BvaW50ZXIgYW5kIGluIHRoZSBtaWRkbGUgb2YgdGhlIGdyaWQuXG5cbiAgICB2YXIgdG9vbHRpcE9wdGlvbnMgPSBbe1xuICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICB9LCB7XG4gICAgICBhbGlnbjogJ2NlbnRlcidcbiAgICB9XTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogY3VyclBvc2l0aW9uWzBdLFxuICAgICAgeTogY3VyclBvc2l0aW9uWzFdLFxuICAgICAgcm90YXRpb246IHRyYW5zZm9ybS5yb3RhdGlvbixcbiAgICAgIGN1cnNvclBvaW50OiBjdXJzb3JQb2ludCxcbiAgICAgIHRvb2x0aXBPcHRpb246IHRvb2x0aXBPcHRpb25zW2RpbUluZGV4XVxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIENhcnRlc2lhbkF4aXNQb2ludGVyO1xufShCYXNlQXhpc1BvaW50ZXIpO1xuXG5mdW5jdGlvbiBnZXRDYXJ0ZXNpYW4oZ3JpZCwgYXhpcykge1xuICB2YXIgb3B0ID0ge307XG4gIG9wdFtheGlzLmRpbSArICdBeGlzSW5kZXgnXSA9IGF4aXMuaW5kZXg7XG4gIHJldHVybiBncmlkLmdldENhcnRlc2lhbihvcHQpO1xufVxuXG52YXIgcG9pbnRlclNoYXBlQnVpbGRlciA9IHtcbiAgbGluZTogZnVuY3Rpb24gKGF4aXMsIHBpeGVsVmFsdWUsIG90aGVyRXh0ZW50KSB7XG4gICAgdmFyIHRhcmdldFNoYXBlID0gdmlld0hlbHBlci5tYWtlTGluZVNoYXBlKFtwaXhlbFZhbHVlLCBvdGhlckV4dGVudFswXV0sIFtwaXhlbFZhbHVlLCBvdGhlckV4dGVudFsxXV0sIGdldEF4aXNEaW1JbmRleChheGlzKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdMaW5lJyxcbiAgICAgIHN1YlBpeGVsT3B0aW1pemU6IHRydWUsXG4gICAgICBzaGFwZTogdGFyZ2V0U2hhcGVcbiAgICB9O1xuICB9LFxuICBzaGFkb3c6IGZ1bmN0aW9uIChheGlzLCBwaXhlbFZhbHVlLCBvdGhlckV4dGVudCkge1xuICAgIHZhciBiYW5kV2lkdGggPSBNYXRoLm1heCgxLCBheGlzLmdldEJhbmRXaWR0aCgpKTtcbiAgICB2YXIgc3BhbiA9IG90aGVyRXh0ZW50WzFdIC0gb3RoZXJFeHRlbnRbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdSZWN0JyxcbiAgICAgIHNoYXBlOiB2aWV3SGVscGVyLm1ha2VSZWN0U2hhcGUoW3BpeGVsVmFsdWUgLSBiYW5kV2lkdGggLyAyLCBvdGhlckV4dGVudFswXV0sIFtiYW5kV2lkdGgsIHNwYW5dLCBnZXRBeGlzRGltSW5kZXgoYXhpcykpXG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0QXhpc0RpbUluZGV4KGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMuZGltID09PSAneCcgPyAwIDogMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FydGVzaWFuQXhpc1BvaW50ZXI7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IEJhc2VBeGlzUG9pbnRlciBmcm9tICcuL0Jhc2VBeGlzUG9pbnRlcic7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgKiBhcyB2aWV3SGVscGVyIGZyb20gJy4vdmlld0hlbHBlcic7XG5pbXBvcnQgKiBhcyBtYXRyaXggZnJvbSAnenJlbmRlci9saWIvY29yZS9tYXRyaXgnO1xuaW1wb3J0IEF4aXNCdWlsZGVyIGZyb20gJy4uL2F4aXMvQXhpc0J1aWxkZXInO1xuXG52YXIgUG9sYXJBeGlzUG9pbnRlciA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQb2xhckF4aXNQb2ludGVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFBvbGFyQXhpc1BvaW50ZXIoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBQb2xhckF4aXNQb2ludGVyLnByb3RvdHlwZS5tYWtlRWxPcHRpb24gPSBmdW5jdGlvbiAoZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSkge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG5cbiAgICBpZiAoYXhpcy5kaW0gPT09ICdhbmdsZScpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uVGhyZXNob2xkID0gTWF0aC5QSSAvIDE4O1xuICAgIH1cblxuICAgIHZhciBwb2xhciA9IGF4aXMucG9sYXI7XG4gICAgdmFyIG90aGVyQXhpcyA9IHBvbGFyLmdldE90aGVyQXhpcyhheGlzKTtcbiAgICB2YXIgb3RoZXJFeHRlbnQgPSBvdGhlckF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIGNvb3JkVmFsdWUgPSBheGlzLmRhdGFUb0Nvb3JkKHZhbHVlKTtcbiAgICB2YXIgYXhpc1BvaW50ZXJUeXBlID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3R5cGUnKTtcblxuICAgIGlmIChheGlzUG9pbnRlclR5cGUgJiYgYXhpc1BvaW50ZXJUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgIHZhciBlbFN0eWxlID0gdmlld0hlbHBlci5idWlsZEVsU3R5bGUoYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICB2YXIgcG9pbnRlck9wdGlvbiA9IHBvaW50ZXJTaGFwZUJ1aWxkZXJbYXhpc1BvaW50ZXJUeXBlXShheGlzLCBwb2xhciwgY29vcmRWYWx1ZSwgb3RoZXJFeHRlbnQpO1xuICAgICAgcG9pbnRlck9wdGlvbi5zdHlsZSA9IGVsU3R5bGU7XG4gICAgICBlbE9wdGlvbi5ncmFwaGljS2V5ID0gcG9pbnRlck9wdGlvbi50eXBlO1xuICAgICAgZWxPcHRpb24ucG9pbnRlciA9IHBvaW50ZXJPcHRpb247XG4gICAgfVxuXG4gICAgdmFyIGxhYmVsTWFyZ2luID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoWydsYWJlbCcsICdtYXJnaW4nXSk7XG4gICAgdmFyIGxhYmVsUG9zID0gZ2V0TGFiZWxQb3NpdGlvbih2YWx1ZSwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBwb2xhciwgbGFiZWxNYXJnaW4pO1xuICAgIHZpZXdIZWxwZXIuYnVpbGRMYWJlbEVsT3B0aW9uKGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSwgbGFiZWxQb3MpO1xuICB9O1xuXG4gIHJldHVybiBQb2xhckF4aXNQb2ludGVyO1xufShCYXNlQXhpc1BvaW50ZXIpO1xuXG47XG5cbmZ1bmN0aW9uIGdldExhYmVsUG9zaXRpb24odmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgcG9sYXIsIGxhYmVsTWFyZ2luKSB7XG4gIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gIHZhciBjb29yZCA9IGF4aXMuZGF0YVRvQ29vcmQodmFsdWUpO1xuICB2YXIgYXhpc0FuZ2xlID0gcG9sYXIuZ2V0QW5nbGVBeGlzKCkuZ2V0RXh0ZW50KClbMF07XG4gIGF4aXNBbmdsZSA9IGF4aXNBbmdsZSAvIDE4MCAqIE1hdGguUEk7XG4gIHZhciByYWRpdXNFeHRlbnQgPSBwb2xhci5nZXRSYWRpdXNBeGlzKCkuZ2V0RXh0ZW50KCk7XG4gIHZhciBwb3NpdGlvbjtcbiAgdmFyIGFsaWduO1xuICB2YXIgdmVydGljYWxBbGlnbjtcblxuICBpZiAoYXhpcy5kaW0gPT09ICdyYWRpdXMnKSB7XG4gICAgdmFyIHRyYW5zZm9ybSA9IG1hdHJpeC5jcmVhdGUoKTtcbiAgICBtYXRyaXgucm90YXRlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCBheGlzQW5nbGUpO1xuICAgIG1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIFtwb2xhci5jeCwgcG9sYXIuY3ldKTtcbiAgICBwb3NpdGlvbiA9IGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0oW2Nvb3JkLCAtbGFiZWxNYXJnaW5dLCB0cmFuc2Zvcm0pO1xuICAgIHZhciBsYWJlbFJvdGF0aW9uID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwnKS5nZXQoJ3JvdGF0ZScpIHx8IDA7IC8vIEB0cy1pZ25vcmVcblxuICAgIHZhciBsYWJlbExheW91dCA9IEF4aXNCdWlsZGVyLmlubmVyVGV4dExheW91dChheGlzQW5nbGUsIGxhYmVsUm90YXRpb24gKiBNYXRoLlBJIC8gMTgwLCAtMSk7XG4gICAgYWxpZ24gPSBsYWJlbExheW91dC50ZXh0QWxpZ247XG4gICAgdmVydGljYWxBbGlnbiA9IGxhYmVsTGF5b3V0LnRleHRWZXJ0aWNhbEFsaWduO1xuICB9IGVsc2Uge1xuICAgIC8vIGFuZ2xlIGF4aXNcbiAgICB2YXIgciA9IHJhZGl1c0V4dGVudFsxXTtcbiAgICBwb3NpdGlvbiA9IHBvbGFyLmNvb3JkVG9Qb2ludChbciArIGxhYmVsTWFyZ2luLCBjb29yZF0pO1xuICAgIHZhciBjeCA9IHBvbGFyLmN4O1xuICAgIHZhciBjeSA9IHBvbGFyLmN5O1xuICAgIGFsaWduID0gTWF0aC5hYnMocG9zaXRpb25bMF0gLSBjeCkgLyByIDwgMC4zID8gJ2NlbnRlcicgOiBwb3NpdGlvblswXSA+IGN4ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB2ZXJ0aWNhbEFsaWduID0gTWF0aC5hYnMocG9zaXRpb25bMV0gLSBjeSkgLyByIDwgMC4zID8gJ21pZGRsZScgOiBwb3NpdGlvblsxXSA+IGN5ID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgIGFsaWduOiBhbGlnbixcbiAgICB2ZXJ0aWNhbEFsaWduOiB2ZXJ0aWNhbEFsaWduXG4gIH07XG59XG5cbnZhciBwb2ludGVyU2hhcGVCdWlsZGVyID0ge1xuICBsaW5lOiBmdW5jdGlvbiAoYXhpcywgcG9sYXIsIGNvb3JkVmFsdWUsIG90aGVyRXh0ZW50KSB7XG4gICAgcmV0dXJuIGF4aXMuZGltID09PSAnYW5nbGUnID8ge1xuICAgICAgdHlwZTogJ0xpbmUnLFxuICAgICAgc2hhcGU6IHZpZXdIZWxwZXIubWFrZUxpbmVTaGFwZShwb2xhci5jb29yZFRvUG9pbnQoW290aGVyRXh0ZW50WzBdLCBjb29yZFZhbHVlXSksIHBvbGFyLmNvb3JkVG9Qb2ludChbb3RoZXJFeHRlbnRbMV0sIGNvb3JkVmFsdWVdKSlcbiAgICB9IDoge1xuICAgICAgdHlwZTogJ0NpcmNsZScsXG4gICAgICBzaGFwZToge1xuICAgICAgICBjeDogcG9sYXIuY3gsXG4gICAgICAgIGN5OiBwb2xhci5jeSxcbiAgICAgICAgcjogY29vcmRWYWx1ZVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHNoYWRvdzogZnVuY3Rpb24gKGF4aXMsIHBvbGFyLCBjb29yZFZhbHVlLCBvdGhlckV4dGVudCkge1xuICAgIHZhciBiYW5kV2lkdGggPSBNYXRoLm1heCgxLCBheGlzLmdldEJhbmRXaWR0aCgpKTtcbiAgICB2YXIgcmFkaWFuID0gTWF0aC5QSSAvIDE4MDtcbiAgICByZXR1cm4gYXhpcy5kaW0gPT09ICdhbmdsZScgPyB7XG4gICAgICB0eXBlOiAnU2VjdG9yJyxcbiAgICAgIHNoYXBlOiB2aWV3SGVscGVyLm1ha2VTZWN0b3JTaGFwZShwb2xhci5jeCwgcG9sYXIuY3ksIG90aGVyRXh0ZW50WzBdLCBvdGhlckV4dGVudFsxXSwgLy8gSW4gRUNoYXJ0cyB5IGlzIG5lZ2F0aXZlIGlmIGFuZ2xlIGlzIHBvc2l0aXZlXG4gICAgICAoLWNvb3JkVmFsdWUgLSBiYW5kV2lkdGggLyAyKSAqIHJhZGlhbiwgKC1jb29yZFZhbHVlICsgYmFuZFdpZHRoIC8gMikgKiByYWRpYW4pXG4gICAgfSA6IHtcbiAgICAgIHR5cGU6ICdTZWN0b3InLFxuICAgICAgc2hhcGU6IHZpZXdIZWxwZXIubWFrZVNlY3RvclNoYXBlKHBvbGFyLmN4LCBwb2xhci5jeSwgY29vcmRWYWx1ZSAtIGJhbmRXaWR0aCAvIDIsIGNvb3JkVmFsdWUgKyBiYW5kV2lkdGggLyAyLCAwLCBNYXRoLlBJICogMilcbiAgICB9O1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgUG9sYXJBeGlzUG9pbnRlcjsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQmFzZUF4aXNQb2ludGVyIGZyb20gJy4vQmFzZUF4aXNQb2ludGVyJztcbmltcG9ydCAqIGFzIHZpZXdIZWxwZXIgZnJvbSAnLi92aWV3SGVscGVyJztcbmltcG9ydCAqIGFzIHNpbmdsZUF4aXNIZWxwZXIgZnJvbSAnLi4vLi4vY29vcmQvc2luZ2xlL3NpbmdsZUF4aXNIZWxwZXInO1xudmFyIFhZID0gWyd4JywgJ3knXTtcbnZhciBXSCA9IFsnd2lkdGgnLCAnaGVpZ2h0J107XG5cbnZhciBTaW5nbGVBeGlzUG9pbnRlciA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTaW5nbGVBeGlzUG9pbnRlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTaW5nbGVBeGlzUG9pbnRlcigpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIFNpbmdsZUF4aXNQb2ludGVyLnByb3RvdHlwZS5tYWtlRWxPcHRpb24gPSBmdW5jdGlvbiAoZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSkge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgdmFyIGNvb3JkU3lzID0gYXhpcy5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBvdGhlckV4dGVudCA9IGdldEdsb2JhbEV4dGVudChjb29yZFN5cywgMSAtIGdldFBvaW50RGltSW5kZXgoYXhpcykpO1xuICAgIHZhciBwaXhlbFZhbHVlID0gY29vcmRTeXMuZGF0YVRvUG9pbnQodmFsdWUpWzBdO1xuICAgIHZhciBheGlzUG9pbnRlclR5cGUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndHlwZScpO1xuXG4gICAgaWYgKGF4aXNQb2ludGVyVHlwZSAmJiBheGlzUG9pbnRlclR5cGUgIT09ICdub25lJykge1xuICAgICAgdmFyIGVsU3R5bGUgPSB2aWV3SGVscGVyLmJ1aWxkRWxTdHlsZShheGlzUG9pbnRlck1vZGVsKTtcbiAgICAgIHZhciBwb2ludGVyT3B0aW9uID0gcG9pbnRlclNoYXBlQnVpbGRlcltheGlzUG9pbnRlclR5cGVdKGF4aXMsIHBpeGVsVmFsdWUsIG90aGVyRXh0ZW50KTtcbiAgICAgIHBvaW50ZXJPcHRpb24uc3R5bGUgPSBlbFN0eWxlO1xuICAgICAgZWxPcHRpb24uZ3JhcGhpY0tleSA9IHBvaW50ZXJPcHRpb24udHlwZTtcbiAgICAgIGVsT3B0aW9uLnBvaW50ZXIgPSBwb2ludGVyT3B0aW9uO1xuICAgIH1cblxuICAgIHZhciBsYXlvdXRJbmZvID0gc2luZ2xlQXhpc0hlbHBlci5sYXlvdXQoYXhpc01vZGVsKTtcbiAgICB2aWV3SGVscGVyLmJ1aWxkQ2FydGVzaWFuU2luZ2xlTGFiZWxFbE9wdGlvbiggLy8gQHRzLWlnbm9yZVxuICAgIHZhbHVlLCBlbE9wdGlvbiwgbGF5b3V0SW5mbywgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGkpO1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgU2luZ2xlQXhpc1BvaW50ZXIucHJvdG90eXBlLmdldEhhbmRsZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsKSB7XG4gICAgdmFyIGxheW91dEluZm8gPSBzaW5nbGVBeGlzSGVscGVyLmxheW91dChheGlzTW9kZWwsIHtcbiAgICAgIGxhYmVsSW5zaWRlOiBmYWxzZVxuICAgIH0pOyAvLyBAdHMtaWdub3JlXG5cbiAgICBsYXlvdXRJbmZvLmxhYmVsTWFyZ2luID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoWydoYW5kbGUnLCAnbWFyZ2luJ10pO1xuICAgIHZhciBwb3NpdGlvbiA9IHZpZXdIZWxwZXIuZ2V0VHJhbnNmb3JtZWRQb3NpdGlvbihheGlzTW9kZWwuYXhpcywgdmFsdWUsIGxheW91dEluZm8pO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwb3NpdGlvblswXSxcbiAgICAgIHk6IHBvc2l0aW9uWzFdLFxuICAgICAgcm90YXRpb246IGxheW91dEluZm8ucm90YXRpb24gKyAobGF5b3V0SW5mby5sYWJlbERpcmVjdGlvbiA8IDAgPyBNYXRoLlBJIDogMClcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgU2luZ2xlQXhpc1BvaW50ZXIucHJvdG90eXBlLnVwZGF0ZUhhbmRsZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIGRlbHRhLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgIHZhciBjb29yZFN5cyA9IGF4aXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgZGltSW5kZXggPSBnZXRQb2ludERpbUluZGV4KGF4aXMpO1xuICAgIHZhciBheGlzRXh0ZW50ID0gZ2V0R2xvYmFsRXh0ZW50KGNvb3JkU3lzLCBkaW1JbmRleCk7XG4gICAgdmFyIGN1cnJQb3NpdGlvbiA9IFt0cmFuc2Zvcm0ueCwgdHJhbnNmb3JtLnldO1xuICAgIGN1cnJQb3NpdGlvbltkaW1JbmRleF0gKz0gZGVsdGFbZGltSW5kZXhdO1xuICAgIGN1cnJQb3NpdGlvbltkaW1JbmRleF0gPSBNYXRoLm1pbihheGlzRXh0ZW50WzFdLCBjdXJyUG9zaXRpb25bZGltSW5kZXhdKTtcbiAgICBjdXJyUG9zaXRpb25bZGltSW5kZXhdID0gTWF0aC5tYXgoYXhpc0V4dGVudFswXSwgY3VyclBvc2l0aW9uW2RpbUluZGV4XSk7XG4gICAgdmFyIG90aGVyRXh0ZW50ID0gZ2V0R2xvYmFsRXh0ZW50KGNvb3JkU3lzLCAxIC0gZGltSW5kZXgpO1xuICAgIHZhciBjdXJzb3JPdGhlclZhbHVlID0gKG90aGVyRXh0ZW50WzFdICsgb3RoZXJFeHRlbnRbMF0pIC8gMjtcbiAgICB2YXIgY3Vyc29yUG9pbnQgPSBbY3Vyc29yT3RoZXJWYWx1ZSwgY3Vyc29yT3RoZXJWYWx1ZV07XG4gICAgY3Vyc29yUG9pbnRbZGltSW5kZXhdID0gY3VyclBvc2l0aW9uW2RpbUluZGV4XTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogY3VyclBvc2l0aW9uWzBdLFxuICAgICAgeTogY3VyclBvc2l0aW9uWzFdLFxuICAgICAgcm90YXRpb246IHRyYW5zZm9ybS5yb3RhdGlvbixcbiAgICAgIGN1cnNvclBvaW50OiBjdXJzb3JQb2ludCxcbiAgICAgIHRvb2x0aXBPcHRpb246IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBTaW5nbGVBeGlzUG9pbnRlcjtcbn0oQmFzZUF4aXNQb2ludGVyKTtcblxudmFyIHBvaW50ZXJTaGFwZUJ1aWxkZXIgPSB7XG4gIGxpbmU6IGZ1bmN0aW9uIChheGlzLCBwaXhlbFZhbHVlLCBvdGhlckV4dGVudCkge1xuICAgIHZhciB0YXJnZXRTaGFwZSA9IHZpZXdIZWxwZXIubWFrZUxpbmVTaGFwZShbcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnRbMF1dLCBbcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnRbMV1dLCBnZXRQb2ludERpbUluZGV4KGF4aXMpKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0xpbmUnLFxuICAgICAgc3ViUGl4ZWxPcHRpbWl6ZTogdHJ1ZSxcbiAgICAgIHNoYXBlOiB0YXJnZXRTaGFwZVxuICAgIH07XG4gIH0sXG4gIHNoYWRvdzogZnVuY3Rpb24gKGF4aXMsIHBpeGVsVmFsdWUsIG90aGVyRXh0ZW50KSB7XG4gICAgdmFyIGJhbmRXaWR0aCA9IGF4aXMuZ2V0QmFuZFdpZHRoKCk7XG4gICAgdmFyIHNwYW4gPSBvdGhlckV4dGVudFsxXSAtIG90aGVyRXh0ZW50WzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnUmVjdCcsXG4gICAgICBzaGFwZTogdmlld0hlbHBlci5tYWtlUmVjdFNoYXBlKFtwaXhlbFZhbHVlIC0gYmFuZFdpZHRoIC8gMiwgb3RoZXJFeHRlbnRbMF1dLCBbYmFuZFdpZHRoLCBzcGFuXSwgZ2V0UG9pbnREaW1JbmRleChheGlzKSlcbiAgICB9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRQb2ludERpbUluZGV4KGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMuaXNIb3Jpem9udGFsKCkgPyAwIDogMTtcbn1cblxuZnVuY3Rpb24gZ2V0R2xvYmFsRXh0ZW50KGNvb3JkU3lzLCBkaW1JbmRleCkge1xuICB2YXIgcmVjdCA9IGNvb3JkU3lzLmdldFJlY3QoKTtcbiAgcmV0dXJuIFtyZWN0W1hZW2RpbUluZGV4XV0sIHJlY3RbWFlbZGltSW5kZXhdXSArIHJlY3RbV0hbZGltSW5kZXhdXV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNpbmdsZUF4aXNQb2ludGVyOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbmltcG9ydCAqIGFzIG1vZGVsSGVscGVyIGZyb20gJy4vbW9kZWxIZWxwZXInO1xuaW1wb3J0IGZpbmRQb2ludEZyb21TZXJpZXMgZnJvbSAnLi9maW5kUG9pbnRGcm9tU2VyaWVzJztcbmltcG9ydCB7IGVhY2gsIGN1cnJ5LCBiaW5kLCBleHRlbmQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xudmFyIGlubmVyID0gbWFrZUlubmVyKCk7XG4vKipcbiAqIEJhc2ljIGxvZ2ljOiBjaGVjayBhbGwgYXhpcywgaWYgdGhleSBkbyBub3QgZGVtYW5kIHNob3cvaGlnaGxpZ2h0LFxuICogdGhlbiBoaWRlL2Rvd25wbGF5IHRoZW0uXG4gKlxuICogQHJldHVybiBjb250ZW50IG9mIGV2ZW50IG9iaiBmb3IgZWNoYXJ0cy5jb25uZWN0LlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGF4aXNUcmlnZ2VyKHBheWxvYWQsIGVjTW9kZWwsIGFwaSkge1xuICB2YXIgY3VyclRyaWdnZXIgPSBwYXlsb2FkLmN1cnJUcmlnZ2VyO1xuICB2YXIgcG9pbnQgPSBbcGF5bG9hZC54LCBwYXlsb2FkLnldO1xuICB2YXIgZmluZGVyID0gcGF5bG9hZDtcbiAgdmFyIGRpc3BhdGNoQWN0aW9uID0gcGF5bG9hZC5kaXNwYXRjaEFjdGlvbiB8fCBiaW5kKGFwaS5kaXNwYXRjaEFjdGlvbiwgYXBpKTtcbiAgdmFyIGNvb3JkU3lzQXhlc0luZm8gPSBlY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKS5jb29yZFN5c0F4ZXNJbmZvOyAvLyBQZW5kaW5nXG4gIC8vIFNlZSAjNjEyMS4gQnV0IHdlIGFyZSBub3QgYWJsZSB0byByZXByb2R1Y2UgaXQgeWV0LlxuXG4gIGlmICghY29vcmRTeXNBeGVzSW5mbykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbGxlZ2FsUG9pbnQocG9pbnQpKSB7XG4gICAgLy8gVXNlZCBpbiB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBgY29ubmVjdGlvbmA6IHVzZSB0aGUgc2FtcGxlIHNlcmllc0luZGV4XG4gICAgLy8gYW5kIGRhdGFJbmRleC4gQW5kIGFsc28gdXNlZCBpbiB0aGUgdG9vbHRpcFZpZXcgdHJpZ2dlci5cbiAgICBwb2ludCA9IGZpbmRQb2ludEZyb21TZXJpZXMoe1xuICAgICAgc2VyaWVzSW5kZXg6IGZpbmRlci5zZXJpZXNJbmRleCxcbiAgICAgIC8vIERvIG5vdCB1c2UgZGF0YUluZGV4SW5zaWRlIGZyb20gb3RoZXIgZWMgaW5zdGFuY2UuXG4gICAgICAvLyBGSVhNRTogYXV0byBkZXRlY3QgaXQ/XG4gICAgICBkYXRhSW5kZXg6IGZpbmRlci5kYXRhSW5kZXhcbiAgICB9LCBlY01vZGVsKS5wb2ludDtcbiAgfVxuXG4gIHZhciBpc0lsbGVnYWxQb2ludCA9IGlsbGVnYWxQb2ludChwb2ludCk7IC8vIEF4aXMgYW5kIHZhbHVlIGNhbiBiZSBzcGVjaWZpZWQgd2hlbiBjYWxsaW5nIGRpc3BhdGNoQWN0aW9uKHt0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInfSkuXG4gIC8vIE5vdGljZTogSW4gdGhpcyBjYXNlLCBpdCBpcyBkaWZmaWN1bHQgdG8gZ2V0IHRoZSBgcG9pbnRgICh3aGljaCBpcyBuZWNlc3NhcnkgdG8gc2hvd1xuICAvLyB0b29sdGlwLCBzbyBpZiBwb2ludCBpcyBub3QgZ2l2ZW4sIHdlIGp1c3QgdXNlIHRoZSBwb2ludCBmb3VuZCBieSBzYW1wbGUgc2VyaWVzSW5kZXhcbiAgLy8gYW5kIGRhdGFJbmRleC5cblxuICB2YXIgaW5wdXRBeGVzSW5mbyA9IGZpbmRlci5heGVzSW5mbztcbiAgdmFyIGF4ZXNJbmZvID0gY29vcmRTeXNBeGVzSW5mby5heGVzSW5mbztcbiAgdmFyIHNob3VsZEhpZGUgPSBjdXJyVHJpZ2dlciA9PT0gJ2xlYXZlJyB8fCBpbGxlZ2FsUG9pbnQocG9pbnQpO1xuICB2YXIgb3V0cHV0UGF5bG9hZCA9IHt9O1xuICB2YXIgc2hvd1ZhbHVlTWFwID0ge307XG4gIHZhciBkYXRhQnlDb29yZFN5cyA9IHtcbiAgICBsaXN0OiBbXSxcbiAgICBtYXA6IHt9XG4gIH07XG4gIHZhciB1cGRhdGVycyA9IHtcbiAgICBzaG93UG9pbnRlcjogY3Vycnkoc2hvd1BvaW50ZXIsIHNob3dWYWx1ZU1hcCksXG4gICAgc2hvd1Rvb2x0aXA6IGN1cnJ5KHNob3dUb29sdGlwLCBkYXRhQnlDb29yZFN5cylcbiAgfTsgLy8gUHJvY2VzcyBmb3IgdHJpZ2dlcmVkIGF4ZXMuXG5cbiAgZWFjaChjb29yZFN5c0F4ZXNJbmZvLmNvb3JkU3lzTWFwLCBmdW5jdGlvbiAoY29vcmRTeXMsIGNvb3JkU3lzS2V5KSB7XG4gICAgLy8gSWYgYSBwb2ludCBnaXZlbiwgaXQgbXVzdCBiZSBjb250YWluZWQgYnkgdGhlIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgIHZhciBjb29yZFN5c0NvbnRhaW5zUG9pbnQgPSBpc0lsbGVnYWxQb2ludCB8fCBjb29yZFN5cy5jb250YWluUG9pbnQocG9pbnQpO1xuICAgIGVhY2goY29vcmRTeXNBeGVzSW5mby5jb29yZFN5c0F4ZXNJbmZvW2Nvb3JkU3lzS2V5XSwgZnVuY3Rpb24gKGF4aXNJbmZvLCBrZXkpIHtcbiAgICAgIHZhciBheGlzID0gYXhpc0luZm8uYXhpcztcbiAgICAgIHZhciBpbnB1dEF4aXNJbmZvID0gZmluZElucHV0QXhpc0luZm8oaW5wdXRBeGVzSW5mbywgYXhpc0luZm8pOyAvLyBJZiBubyBpbnB1dEF4ZXNJbmZvLCBubyBheGlzIGlzIHJlc3RyaWN0ZWQuXG5cbiAgICAgIGlmICghc2hvdWxkSGlkZSAmJiBjb29yZFN5c0NvbnRhaW5zUG9pbnQgJiYgKCFpbnB1dEF4ZXNJbmZvIHx8IGlucHV0QXhpc0luZm8pKSB7XG4gICAgICAgIHZhciB2YWwgPSBpbnB1dEF4aXNJbmZvICYmIGlucHV0QXhpc0luZm8udmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbCA9PSBudWxsICYmICFpc0lsbGVnYWxQb2ludCkge1xuICAgICAgICAgIHZhbCA9IGF4aXMucG9pbnRUb0RhdGEocG9pbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsICE9IG51bGwgJiYgcHJvY2Vzc09uQXhpcyhheGlzSW5mbywgdmFsLCB1cGRhdGVycywgZmFsc2UsIG91dHB1dFBheWxvYWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTsgLy8gUHJvY2VzcyBmb3IgbGlua2VkIGF4ZXMuXG5cbiAgdmFyIGxpbmtUcmlnZ2VycyA9IHt9O1xuICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAodGFyQXhpc0luZm8sIHRhcktleSkge1xuICAgIHZhciBsaW5rR3JvdXAgPSB0YXJBeGlzSW5mby5saW5rR3JvdXA7IC8vIElmIGF4aXMgaGFzIGJlZW4gdHJpZ2dlcmVkIGluIHRoZSBwcmV2aW91cyBzdGFnZSwgaXQgc2hvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgYnkgbGluay5cblxuICAgIGlmIChsaW5rR3JvdXAgJiYgIXNob3dWYWx1ZU1hcFt0YXJLZXldKSB7XG4gICAgICBlYWNoKGxpbmtHcm91cC5heGVzSW5mbywgZnVuY3Rpb24gKHNyY0F4aXNJbmZvLCBzcmNLZXkpIHtcbiAgICAgICAgdmFyIHNyY1ZhbEl0ZW0gPSBzaG93VmFsdWVNYXBbc3JjS2V5XTsgLy8gSWYgc3JjVmFsSXRlbSBleGlzdCwgc291cmNlIGF4aXMgaXMgdHJpZ2dlcmVkLCBzbyBsaW5rIHRvIHRhcmdldCBheGlzLlxuXG4gICAgICAgIGlmIChzcmNBeGlzSW5mbyAhPT0gdGFyQXhpc0luZm8gJiYgc3JjVmFsSXRlbSkge1xuICAgICAgICAgIHZhciB2YWwgPSBzcmNWYWxJdGVtLnZhbHVlO1xuICAgICAgICAgIGxpbmtHcm91cC5tYXBwZXIgJiYgKHZhbCA9IHRhckF4aXNJbmZvLmF4aXMuc2NhbGUucGFyc2UobGlua0dyb3VwLm1hcHBlcih2YWwsIG1ha2VNYXBwZXJQYXJhbShzcmNBeGlzSW5mbyksIG1ha2VNYXBwZXJQYXJhbSh0YXJBeGlzSW5mbykpKSk7XG4gICAgICAgICAgbGlua1RyaWdnZXJzW3RhckF4aXNJbmZvLmtleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGVhY2gobGlua1RyaWdnZXJzLCBmdW5jdGlvbiAodmFsLCB0YXJLZXkpIHtcbiAgICBwcm9jZXNzT25BeGlzKGF4ZXNJbmZvW3RhcktleV0sIHZhbCwgdXBkYXRlcnMsIHRydWUsIG91dHB1dFBheWxvYWQpO1xuICB9KTtcbiAgdXBkYXRlTW9kZWxBY3R1YWxseShzaG93VmFsdWVNYXAsIGF4ZXNJbmZvLCBvdXRwdXRQYXlsb2FkKTtcbiAgZGlzcGF0Y2hUb29sdGlwQWN0dWFsbHkoZGF0YUJ5Q29vcmRTeXMsIHBvaW50LCBwYXlsb2FkLCBkaXNwYXRjaEFjdGlvbik7XG4gIGRpc3BhdGNoSGlnaERvd25BY3R1YWxseShheGVzSW5mbywgZGlzcGF0Y2hBY3Rpb24sIGFwaSk7XG4gIHJldHVybiBvdXRwdXRQYXlsb2FkO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25BeGlzKGF4aXNJbmZvLCBuZXdWYWx1ZSwgdXBkYXRlcnMsIG5vU25hcCwgb3V0cHV0RmluZGVyKSB7XG4gIHZhciBheGlzID0gYXhpc0luZm8uYXhpcztcblxuICBpZiAoYXhpcy5zY2FsZS5pc0JsYW5rKCkgfHwgIWF4aXMuY29udGFpbkRhdGEobmV3VmFsdWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFheGlzSW5mby5pbnZvbHZlU2VyaWVzKSB7XG4gICAgdXBkYXRlcnMuc2hvd1BvaW50ZXIoYXhpc0luZm8sIG5ld1ZhbHVlKTtcbiAgICByZXR1cm47XG4gIH0gLy8gSGVhdnkgY2FsY3VsYXRpb24uIFNvIHB1dCBpdCBhZnRlciBheGlzLmNvbnRhaW5EYXRhIGNoZWNraW5nLlxuXG5cbiAgdmFyIHBheWxvYWRJbmZvID0gYnVpbGRQYXlsb2Fkc0J5U2VyaWVzKG5ld1ZhbHVlLCBheGlzSW5mbyk7XG4gIHZhciBwYXlsb2FkQmF0Y2ggPSBwYXlsb2FkSW5mby5wYXlsb2FkQmF0Y2g7XG4gIHZhciBzbmFwVG9WYWx1ZSA9IHBheWxvYWRJbmZvLnNuYXBUb1ZhbHVlOyAvLyBGaWxsIGNvbnRlbnQgb2YgZXZlbnQgb2JqIGZvciBlY2hhcnRzLmNvbm5lY3QuXG4gIC8vIEJ5IGRlZmF1bHQgdXNlIHRoZSBmaXJzdCBpbnZvbHZlZCBzZXJpZXMgZGF0YSBhcyBhIHNhbXBsZSB0byBjb25uZWN0LlxuXG4gIGlmIChwYXlsb2FkQmF0Y2hbMF0gJiYgb3V0cHV0RmluZGVyLnNlcmllc0luZGV4ID09IG51bGwpIHtcbiAgICBleHRlbmQob3V0cHV0RmluZGVyLCBwYXlsb2FkQmF0Y2hbMF0pO1xuICB9IC8vIElmIG5vIGxpbmtTb3VyY2UgaW5wdXQsIHRoaXMgcHJvY2VzcyBpcyBmb3IgY29sbGVjdGluZyBsaW5rXG4gIC8vIHRhcmdldCwgd2hlcmUgc25hcCBzaG91bGQgbm90IGJlIGFjY2VwdGVkLlxuXG5cbiAgaWYgKCFub1NuYXAgJiYgYXhpc0luZm8uc25hcCkge1xuICAgIGlmIChheGlzLmNvbnRhaW5EYXRhKHNuYXBUb1ZhbHVlKSAmJiBzbmFwVG9WYWx1ZSAhPSBudWxsKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNuYXBUb1ZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZXJzLnNob3dQb2ludGVyKGF4aXNJbmZvLCBuZXdWYWx1ZSwgcGF5bG9hZEJhdGNoKTsgLy8gVG9vbHRpcCBzaG91bGQgYWx3YXlzIGJlIHNuYXBUb1ZhbHVlLCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgXCJheGlzIHZhbHVlIH4gc2VyaWVzIHZhbHVlXCIgbWFwcGluZyBkaXNwbGF5ZWQgaW4gdG9vbHRpcC5cblxuICB1cGRhdGVycy5zaG93VG9vbHRpcChheGlzSW5mbywgcGF5bG9hZEluZm8sIHNuYXBUb1ZhbHVlKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRQYXlsb2Fkc0J5U2VyaWVzKHZhbHVlLCBheGlzSW5mbykge1xuICB2YXIgYXhpcyA9IGF4aXNJbmZvLmF4aXM7XG4gIHZhciBkaW0gPSBheGlzLmRpbTtcbiAgdmFyIHNuYXBUb1ZhbHVlID0gdmFsdWU7XG4gIHZhciBwYXlsb2FkQmF0Y2ggPSBbXTtcbiAgdmFyIG1pbkRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICB2YXIgbWluRGlmZiA9IC0xO1xuICBlYWNoKGF4aXNJbmZvLnNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllcywgaWR4KSB7XG4gICAgdmFyIGRhdGFEaW0gPSBzZXJpZXMuZ2V0RGF0YSgpLm1hcERpbWVuc2lvbnNBbGwoZGltKTtcbiAgICB2YXIgc2VyaWVzTmVzdGVzdFZhbHVlO1xuICAgIHZhciBkYXRhSW5kaWNlcztcblxuICAgIGlmIChzZXJpZXMuZ2V0QXhpc1Rvb2x0aXBEYXRhKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gc2VyaWVzLmdldEF4aXNUb29sdGlwRGF0YShkYXRhRGltLCB2YWx1ZSwgYXhpcyk7XG4gICAgICBkYXRhSW5kaWNlcyA9IHJlc3VsdC5kYXRhSW5kaWNlcztcbiAgICAgIHNlcmllc05lc3Rlc3RWYWx1ZSA9IHJlc3VsdC5uZXN0ZXN0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFJbmRpY2VzID0gc2VyaWVzLmdldERhdGEoKS5pbmRpY2VzT2ZOZWFyZXN0KGRhdGFEaW1bMF0sIHZhbHVlLCAvLyBBZGQgYSB0aHJlc2hvbGQgdG8gYXZvaWQgZmluZCB0aGUgd3JvbmcgZGF0YUluZGV4XG4gICAgICAvLyB3aGVuIGRhdGEgbGVuZ3RoIGlzIG5vdCBzYW1lLlxuICAgICAgLy8gZmFsc2UsXG4gICAgICBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyAwLjUgOiBudWxsKTtcblxuICAgICAgaWYgKCFkYXRhSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZXJpZXNOZXN0ZXN0VmFsdWUgPSBzZXJpZXMuZ2V0RGF0YSgpLmdldChkYXRhRGltWzBdLCBkYXRhSW5kaWNlc1swXSk7XG4gICAgfVxuXG4gICAgaWYgKHNlcmllc05lc3Rlc3RWYWx1ZSA9PSBudWxsIHx8ICFpc0Zpbml0ZShzZXJpZXNOZXN0ZXN0VmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSB2YWx1ZSAtIHNlcmllc05lc3Rlc3RWYWx1ZTtcbiAgICB2YXIgZGlzdCA9IE1hdGguYWJzKGRpZmYpOyAvLyBDb25zaWRlciBjYXRlZ29yeSBjYXNlXG5cbiAgICBpZiAoZGlzdCA8PSBtaW5EaXN0KSB7XG4gICAgICBpZiAoZGlzdCA8IG1pbkRpc3QgfHwgZGlmZiA+PSAwICYmIG1pbkRpZmYgPCAwKSB7XG4gICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICBtaW5EaWZmID0gZGlmZjtcbiAgICAgICAgc25hcFRvVmFsdWUgPSBzZXJpZXNOZXN0ZXN0VmFsdWU7XG4gICAgICAgIHBheWxvYWRCYXRjaC5sZW5ndGggPSAwO1xuICAgICAgfVxuXG4gICAgICBlYWNoKGRhdGFJbmRpY2VzLCBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgIHBheWxvYWRCYXRjaC5wdXNoKHtcbiAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzLnNlcmllc0luZGV4LFxuICAgICAgICAgIGRhdGFJbmRleEluc2lkZTogZGF0YUluZGV4LFxuICAgICAgICAgIGRhdGFJbmRleDogc2VyaWVzLmdldERhdGEoKS5nZXRSYXdJbmRleChkYXRhSW5kZXgpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwYXlsb2FkQmF0Y2g6IHBheWxvYWRCYXRjaCxcbiAgICBzbmFwVG9WYWx1ZTogc25hcFRvVmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hvd1BvaW50ZXIoc2hvd1ZhbHVlTWFwLCBheGlzSW5mbywgdmFsdWUsIHBheWxvYWRCYXRjaCkge1xuICBzaG93VmFsdWVNYXBbYXhpc0luZm8ua2V5XSA9IHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgcGF5bG9hZEJhdGNoOiBwYXlsb2FkQmF0Y2hcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hvd1Rvb2x0aXAoZGF0YUJ5Q29vcmRTeXMsIGF4aXNJbmZvLCBwYXlsb2FkSW5mbywgdmFsdWUpIHtcbiAgdmFyIHBheWxvYWRCYXRjaCA9IHBheWxvYWRJbmZvLnBheWxvYWRCYXRjaDtcbiAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICB2YXIgYXhpc01vZGVsID0gYXhpcy5tb2RlbDtcbiAgdmFyIGF4aXNQb2ludGVyTW9kZWwgPSBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsOyAvLyBJZiBubyBkYXRhLCBkbyBub3QgY3JlYXRlIGFueXRoaW5nIGluIGRhdGFCeUNvb3JkU3lzLFxuICAvLyB3aG9zZSBsZW5ndGggd2lsbCBiZSB1c2VkIHRvIGp1ZGdlIHdoZXRoZXIgZGlzcGF0Y2ggYWN0aW9uLlxuXG4gIGlmICghYXhpc0luZm8udHJpZ2dlclRvb2x0aXAgfHwgIXBheWxvYWRCYXRjaC5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29vcmRTeXNNb2RlbCA9IGF4aXNJbmZvLmNvb3JkU3lzLm1vZGVsO1xuICB2YXIgY29vcmRTeXNLZXkgPSBtb2RlbEhlbHBlci5tYWtlS2V5KGNvb3JkU3lzTW9kZWwpO1xuICB2YXIgY29vcmRTeXNJdGVtID0gZGF0YUJ5Q29vcmRTeXMubWFwW2Nvb3JkU3lzS2V5XTtcblxuICBpZiAoIWNvb3JkU3lzSXRlbSkge1xuICAgIGNvb3JkU3lzSXRlbSA9IGRhdGFCeUNvb3JkU3lzLm1hcFtjb29yZFN5c0tleV0gPSB7XG4gICAgICBjb29yZFN5c0lkOiBjb29yZFN5c01vZGVsLmlkLFxuICAgICAgY29vcmRTeXNJbmRleDogY29vcmRTeXNNb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgIGNvb3JkU3lzVHlwZTogY29vcmRTeXNNb2RlbC50eXBlLFxuICAgICAgY29vcmRTeXNNYWluVHlwZTogY29vcmRTeXNNb2RlbC5tYWluVHlwZSxcbiAgICAgIGRhdGFCeUF4aXM6IFtdXG4gICAgfTtcbiAgICBkYXRhQnlDb29yZFN5cy5saXN0LnB1c2goY29vcmRTeXNJdGVtKTtcbiAgfVxuXG4gIGNvb3JkU3lzSXRlbS5kYXRhQnlBeGlzLnB1c2goe1xuICAgIGF4aXNEaW06IGF4aXMuZGltLFxuICAgIGF4aXNJbmRleDogYXhpc01vZGVsLmNvbXBvbmVudEluZGV4LFxuICAgIGF4aXNUeXBlOiBheGlzTW9kZWwudHlwZSxcbiAgICBheGlzSWQ6IGF4aXNNb2RlbC5pZCxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgLy8gQ2F1c3Rpb246IHZpZXdIZWxwZXIuZ2V0VmFsdWVMYWJlbCBpcyBhY3R1YWxseSBvbiBcInZpZXcgc3RhZ2VcIiwgd2hpY2hcbiAgICAvLyBkZXBlbmRzIHRoYXQgYWxsIG1vZGVscyBoYXZlIGJlZW4gdXBkYXRlZC4gU28gaXQgc2hvdWxkIG5vdCBiZSBwZXJmb3JtZWRcbiAgICAvLyBoZXJlLiBDb25zaWRlcmluZyBheGlzUG9pbnRlck1vZGVsIHVzZWQgaGVyZSBpcyB2b2xhdGlsZSwgd2hpY2ggaXMgaGFyZFxuICAgIC8vIHRvIGJlIHJldHJpZXZlIGluIFRvb2x0aXBWaWV3LCB3ZSBwcmVwYXJlIHBhcmFtZXRlcnMgaGVyZS5cbiAgICB2YWx1ZUxhYmVsT3B0OiB7XG4gICAgICBwcmVjaXNpb246IGF4aXNQb2ludGVyTW9kZWwuZ2V0KFsnbGFiZWwnLCAncHJlY2lzaW9uJ10pLFxuICAgICAgZm9ybWF0dGVyOiBheGlzUG9pbnRlck1vZGVsLmdldChbJ2xhYmVsJywgJ2Zvcm1hdHRlciddKVxuICAgIH0sXG4gICAgc2VyaWVzRGF0YUluZGljZXM6IHBheWxvYWRCYXRjaC5zbGljZSgpXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNb2RlbEFjdHVhbGx5KHNob3dWYWx1ZU1hcCwgYXhlc0luZm8sIG91dHB1dFBheWxvYWQpIHtcbiAgdmFyIG91dHB1dEF4ZXNJbmZvID0gb3V0cHV0UGF5bG9hZC5heGVzSW5mbyA9IFtdOyAvLyBCYXNpYyBsb2dpYzogSWYgbm8gJ3Nob3cnIHJlcXVpcmVkLCAnaGlkZScgdGhpcyBheGlzUG9pbnRlci5cblxuICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAoYXhpc0luZm8sIGtleSkge1xuICAgIHZhciBvcHRpb24gPSBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsLm9wdGlvbjtcbiAgICB2YXIgdmFsSXRlbSA9IHNob3dWYWx1ZU1hcFtrZXldO1xuXG4gICAgaWYgKHZhbEl0ZW0pIHtcbiAgICAgICFheGlzSW5mby51c2VIYW5kbGUgJiYgKG9wdGlvbi5zdGF0dXMgPSAnc2hvdycpO1xuICAgICAgb3B0aW9uLnZhbHVlID0gdmFsSXRlbS52YWx1ZTsgLy8gRm9yIGxhYmVsIGZvcm1hdHRlciBwYXJhbSBhbmQgaGlnaGxpZ2h0LlxuXG4gICAgICBvcHRpb24uc2VyaWVzRGF0YUluZGljZXMgPSAodmFsSXRlbS5wYXlsb2FkQmF0Y2ggfHwgW10pLnNsaWNlKCk7XG4gICAgfSAvLyBXaGVuIGFsd2F5cyBzaG93IChlLmcuLCBoYW5kbGUgdXNlZCksIHJlbWFpblxuICAgIC8vIG9yaWdpbmFsIHZhbHVlIGFuZCBzdGF0dXMuXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIGhpZGUsIHZhbHVlIHN0aWxsIG5lZWQgdG8gYmUgc2V0LCBjb25zaWRlclxuICAgICAgICAvLyBjbGljayBsZWdlbmQgdG8gdG9nZ2xlIGF4aXMgYmxhbmsuXG4gICAgICAgICFheGlzSW5mby51c2VIYW5kbGUgJiYgKG9wdGlvbi5zdGF0dXMgPSAnaGlkZScpO1xuICAgICAgfSAvLyBJZiBzdGF0dXMgaXMgJ2hpZGUnLCBzaG91bGQgYmUgbm8gaW5mbyBpbiBwYXlsb2FkLlxuXG5cbiAgICBvcHRpb24uc3RhdHVzID09PSAnc2hvdycgJiYgb3V0cHV0QXhlc0luZm8ucHVzaCh7XG4gICAgICBheGlzRGltOiBheGlzSW5mby5heGlzLmRpbSxcbiAgICAgIGF4aXNJbmRleDogYXhpc0luZm8uYXhpcy5tb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgIHZhbHVlOiBvcHRpb24udmFsdWVcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoVG9vbHRpcEFjdHVhbGx5KGRhdGFCeUNvb3JkU3lzLCBwb2ludCwgcGF5bG9hZCwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgLy8gQmFzaWMgbG9naWM6IElmIG5vIHNob3dUaXAgcmVxdWlyZWQsIGhpZGVUaXAgd2lsbCBiZSBkaXNwYXRjaGVkLlxuICBpZiAoaWxsZWdhbFBvaW50KHBvaW50KSB8fCAhZGF0YUJ5Q29vcmRTeXMubGlzdC5sZW5ndGgpIHtcbiAgICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnaGlkZVRpcCdcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH0gLy8gSW4gbW9zdCBjYXNlIG9ubHkgb25lIGF4aXMgKG9yIGV2ZW50IG9uZSBzZXJpZXMgaXMgdXNlZCkuIEl0IGlzXG4gIC8vIGNvbnZpbmllbnQgdG8gZmV0Y2ggcGF5bG9hZC5zZXJpZXNJbmRleCBhbmQgcGF5bG9hZC5kYXRhSW5kZXhcbiAgLy8gZGlydGVjdGx5LiBTbyBwdXQgdGhlIGZpcnN0IHNlcmllc0luZGV4IGFuZCBkYXRhSW5kZXggb2YgdGhlIGZpcnN0XG4gIC8vIGF4aXMgb24gdGhlIHBheWxvYWQuXG5cblxuICB2YXIgc2FtcGxlSXRlbSA9ICgoZGF0YUJ5Q29vcmRTeXMubGlzdFswXS5kYXRhQnlBeGlzWzBdIHx8IHt9KS5zZXJpZXNEYXRhSW5kaWNlcyB8fCBbXSlbMF0gfHwge307XG4gIGRpc3BhdGNoQWN0aW9uKHtcbiAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgZXNjYXBlQ29ubmVjdDogdHJ1ZSxcbiAgICB4OiBwb2ludFswXSxcbiAgICB5OiBwb2ludFsxXSxcbiAgICB0b29sdGlwT3B0aW9uOiBwYXlsb2FkLnRvb2x0aXBPcHRpb24sXG4gICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb24sXG4gICAgZGF0YUluZGV4SW5zaWRlOiBzYW1wbGVJdGVtLmRhdGFJbmRleEluc2lkZSxcbiAgICBkYXRhSW5kZXg6IHNhbXBsZUl0ZW0uZGF0YUluZGV4LFxuICAgIHNlcmllc0luZGV4OiBzYW1wbGVJdGVtLnNlcmllc0luZGV4LFxuICAgIGRhdGFCeUNvb3JkU3lzOiBkYXRhQnlDb29yZFN5cy5saXN0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEhpZ2hEb3duQWN0dWFsbHkoYXhlc0luZm8sIGRpc3BhdGNoQWN0aW9uLCBhcGkpIHtcbiAgLy8gRklYTUVcbiAgLy8gaGlnaGxpZ2h0IHN0YXR1cyBtb2RpZmljYXRpb24gc2hvdWxlIGJlIGEgc3RhZ2Ugb2YgbWFpbiBwcm9jZXNzP1xuICAvLyAoQ29uc2lkZXIgY29uZmlsY3QgKGUuZy4sIGxlZ2VuZCBhbmQgYXhpc1BvaW50ZXIpIGFuZCBzZXRPcHRpb24pXG4gIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICB2YXIgaGlnaERvd25LZXkgPSAnYXhpc1BvaW50ZXJMYXN0SGlnaGxpZ2h0cyc7XG4gIHZhciBsYXN0SGlnaGxpZ2h0cyA9IGlubmVyKHpyKVtoaWdoRG93bktleV0gfHwge307XG4gIHZhciBuZXdIaWdobGlnaHRzID0gaW5uZXIoenIpW2hpZ2hEb3duS2V5XSA9IHt9OyAvLyBVcGRhdGUgaGlnaGxpZ2h0L2Rvd25wbGF5IHN0YXR1cyBhY2NvcmRpbmcgdG8gYXhpc1BvaW50ZXIgbW9kZWwuXG4gIC8vIEJ1aWxkIGhhc2ggbWFwIGFuZCByZW1vdmUgZHVwbGljYXRlIGluY2lkZW50YWxseS5cblxuICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAoYXhpc0luZm8sIGtleSkge1xuICAgIHZhciBvcHRpb24gPSBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsLm9wdGlvbjtcbiAgICBvcHRpb24uc3RhdHVzID09PSAnc2hvdycgJiYgZWFjaChvcHRpb24uc2VyaWVzRGF0YUluZGljZXMsIGZ1bmN0aW9uIChiYXRjaEl0ZW0pIHtcbiAgICAgIHZhciBrZXkgPSBiYXRjaEl0ZW0uc2VyaWVzSW5kZXggKyAnIHwgJyArIGJhdGNoSXRlbS5kYXRhSW5kZXg7XG4gICAgICBuZXdIaWdobGlnaHRzW2tleV0gPSBiYXRjaEl0ZW07XG4gICAgfSk7XG4gIH0pOyAvLyBEaWZmLlxuXG4gIHZhciB0b0hpZ2hsaWdodCA9IFtdO1xuICB2YXIgdG9Eb3ducGxheSA9IFtdO1xuICBlYWNoKGxhc3RIaWdobGlnaHRzLCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBrZXkpIHtcbiAgICAhbmV3SGlnaGxpZ2h0c1trZXldICYmIHRvRG93bnBsYXkucHVzaChiYXRjaEl0ZW0pO1xuICB9KTtcbiAgZWFjaChuZXdIaWdobGlnaHRzLCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBrZXkpIHtcbiAgICAhbGFzdEhpZ2hsaWdodHNba2V5XSAmJiB0b0hpZ2hsaWdodC5wdXNoKGJhdGNoSXRlbSk7XG4gIH0pO1xuICB0b0Rvd25wbGF5Lmxlbmd0aCAmJiBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgIHR5cGU6ICdkb3ducGxheScsXG4gICAgZXNjYXBlQ29ubmVjdDogdHJ1ZSxcbiAgICAvLyBOb3QgYmx1ciBvdGhlcnMgd2hlbiBoaWdobGlnaHQgaW4gYXhpc1BvaW50ZXIuXG4gICAgbm90Qmx1cjogdHJ1ZSxcbiAgICBiYXRjaDogdG9Eb3ducGxheVxuICB9KTtcbiAgdG9IaWdobGlnaHQubGVuZ3RoICYmIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgdHlwZTogJ2hpZ2hsaWdodCcsXG4gICAgZXNjYXBlQ29ubmVjdDogdHJ1ZSxcbiAgICAvLyBOb3QgYmx1ciBvdGhlcnMgd2hlbiBoaWdobGlnaHQgaW4gYXhpc1BvaW50ZXIuXG4gICAgbm90Qmx1cjogdHJ1ZSxcbiAgICBiYXRjaDogdG9IaWdobGlnaHRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRJbnB1dEF4aXNJbmZvKGlucHV0QXhlc0luZm8sIGF4aXNJbmZvKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgKGlucHV0QXhlc0luZm8gfHwgW10pLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucHV0QXhpc0luZm8gPSBpbnB1dEF4ZXNJbmZvW2ldO1xuXG4gICAgaWYgKGF4aXNJbmZvLmF4aXMuZGltID09PSBpbnB1dEF4aXNJbmZvLmF4aXNEaW0gJiYgYXhpc0luZm8uYXhpcy5tb2RlbC5jb21wb25lbnRJbmRleCA9PT0gaW5wdXRBeGlzSW5mby5heGlzSW5kZXgpIHtcbiAgICAgIHJldHVybiBpbnB1dEF4aXNJbmZvO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlTWFwcGVyUGFyYW0oYXhpc0luZm8pIHtcbiAgdmFyIGF4aXNNb2RlbCA9IGF4aXNJbmZvLmF4aXMubW9kZWw7XG4gIHZhciBpdGVtID0ge307XG4gIHZhciBkaW0gPSBpdGVtLmF4aXNEaW0gPSBheGlzSW5mby5heGlzLmRpbTtcbiAgaXRlbS5heGlzSW5kZXggPSBpdGVtW2RpbSArICdBeGlzSW5kZXgnXSA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcbiAgaXRlbS5heGlzTmFtZSA9IGl0ZW1bZGltICsgJ0F4aXNOYW1lJ10gPSBheGlzTW9kZWwubmFtZTtcbiAgaXRlbS5heGlzSWQgPSBpdGVtW2RpbSArICdBeGlzSWQnXSA9IGF4aXNNb2RlbC5pZDtcbiAgcmV0dXJuIGl0ZW07XG59XG5cbmZ1bmN0aW9uIGlsbGVnYWxQb2ludChwb2ludCkge1xuICByZXR1cm4gIXBvaW50IHx8IHBvaW50WzBdID09IG51bGwgfHwgaXNOYU4ocG9pbnRbMF0pIHx8IHBvaW50WzFdID09IG51bGwgfHwgaXNOYU4ocG9pbnRbMV0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCAqIGFzIG1vZGVsVXRpbCBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbi8qKlxuICogQHBhcmFtIGZpbmRlciBjb250YWlucyB7c2VyaWVzSW5kZXgsIGRhdGFJbmRleCwgZGF0YUluZGV4SW5zaWRlfVxuICogQHBhcmFtIGVjTW9kZWxcbiAqIEByZXR1cm4gIHtwb2ludDogW3gsIHldLCBlbDogLi4ufSBwb2ludCBXaWxsIG5vdCBiZSBudWxsLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmRQb2ludEZyb21TZXJpZXMoZmluZGVyLCBlY01vZGVsKSB7XG4gIHZhciBwb2ludCA9IFtdO1xuICB2YXIgc2VyaWVzSW5kZXggPSBmaW5kZXIuc2VyaWVzSW5kZXg7XG4gIHZhciBzZXJpZXNNb2RlbDtcblxuICBpZiAoc2VyaWVzSW5kZXggPT0gbnVsbCB8fCAhKHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KHNlcmllc0luZGV4KSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnQ6IFtdXG4gICAgfTtcbiAgfVxuXG4gIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICB2YXIgZGF0YUluZGV4ID0gbW9kZWxVdGlsLnF1ZXJ5RGF0YUluZGV4KGRhdGEsIGZpbmRlcik7XG5cbiAgaWYgKGRhdGFJbmRleCA9PSBudWxsIHx8IGRhdGFJbmRleCA8IDAgfHwgenJVdGlsLmlzQXJyYXkoZGF0YUluZGV4KSkge1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludDogW11cbiAgICB9O1xuICB9XG5cbiAgdmFyIGVsID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCk7XG4gIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgaWYgKHNlcmllc01vZGVsLmdldFRvb2x0aXBQb3NpdGlvbikge1xuICAgIHBvaW50ID0gc2VyaWVzTW9kZWwuZ2V0VG9vbHRpcFBvc2l0aW9uKGRhdGFJbmRleCkgfHwgW107XG4gIH0gZWxzZSBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMuZGF0YVRvUG9pbnQpIHtcbiAgICBpZiAoZmluZGVyLmlzU3RhY2tlZCkge1xuICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgIHZhciB2YWx1ZUF4aXMgPSBjb29yZFN5cy5nZXRPdGhlckF4aXMoYmFzZUF4aXMpO1xuICAgICAgdmFyIHZhbHVlQXhpc0RpbSA9IHZhbHVlQXhpcy5kaW07XG4gICAgICB2YXIgYmFzZUF4aXNEaW0gPSBiYXNlQXhpcy5kaW07XG4gICAgICB2YXIgYmFzZURhdGFPZmZzZXQgPSB2YWx1ZUF4aXNEaW0gPT09ICd4JyB8fCB2YWx1ZUF4aXNEaW0gPT09ICdyYWRpdXMnID8gMSA6IDA7XG4gICAgICB2YXIgYmFzZURpbSA9IGRhdGEubWFwRGltZW5zaW9uKGJhc2VBeGlzRGltKTtcbiAgICAgIHZhciBzdGFja2VkRGF0YSA9IFtdO1xuICAgICAgc3RhY2tlZERhdGFbYmFzZURhdGFPZmZzZXRdID0gZGF0YS5nZXQoYmFzZURpbSwgZGF0YUluZGV4KTtcbiAgICAgIHN0YWNrZWREYXRhWzEgLSBiYXNlRGF0YU9mZnNldF0gPSBkYXRhLmdldChkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tSZXN1bHREaW1lbnNpb24nKSwgZGF0YUluZGV4KTtcbiAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoc3RhY2tlZERhdGEpIHx8IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KGRhdGEuZ2V0VmFsdWVzKHpyVXRpbC5tYXAoY29vcmRTeXMuZGltZW5zaW9ucywgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICByZXR1cm4gZGF0YS5tYXBEaW1lbnNpb24oZGltKTtcbiAgICAgIH0pLCBkYXRhSW5kZXgpKSB8fCBbXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAvLyBVc2UgZ3JhcGhpYyBib3VuZGluZyByZWN0XG4gICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xuICAgIHJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcbiAgICBwb2ludCA9IFtyZWN0LnggKyByZWN0LndpZHRoIC8gMiwgcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IHBvaW50LFxuICAgIGVsOiBlbFxuICB9O1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBlbnYgZnJvbSAnenJlbmRlci9saWIvY29yZS9lbnYnO1xuaW1wb3J0IHsgbWFrZUlubmVyIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqICAgICAgcGFyYW06IHtzdHJpbmd9IGN1cnJUcmlnZ2VyXG4gKiAgICAgIHBhcmFtOiB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKGtleSwgYXBpLCBoYW5kbGVyKSB7XG4gIGlmIChlbnYubm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICBpbm5lcih6cikucmVjb3JkcyB8fCAoaW5uZXIoenIpLnJlY29yZHMgPSB7fSk7XG4gIGluaXRHbG9iYWxMaXN0ZW5lcnMoenIsIGFwaSk7XG4gIHZhciByZWNvcmQgPSBpbm5lcih6cikucmVjb3Jkc1trZXldIHx8IChpbm5lcih6cikucmVjb3Jkc1trZXldID0ge30pO1xuICByZWNvcmQuaGFuZGxlciA9IGhhbmRsZXI7XG59XG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxMaXN0ZW5lcnMoenIsIGFwaSkge1xuICBpZiAoaW5uZXIoenIpLmluaXRpYWxpemVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaW5uZXIoenIpLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgdXNlSGFuZGxlcignY2xpY2snLCB6clV0aWwuY3VycnkoZG9FbnRlciwgJ2NsaWNrJykpO1xuICB1c2VIYW5kbGVyKCdtb3VzZW1vdmUnLCB6clV0aWwuY3VycnkoZG9FbnRlciwgJ21vdXNlbW92ZScpKTsgLy8gdXNlSGFuZGxlcignbW91c2VvdXQnLCBvbkxlYXZlKTtcblxuICB1c2VIYW5kbGVyKCdnbG9iYWxvdXQnLCBvbkxlYXZlKTtcblxuICBmdW5jdGlvbiB1c2VIYW5kbGVyKGV2ZW50VHlwZSwgY2IpIHtcbiAgICB6ci5vbihldmVudFR5cGUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgZGlzID0gbWFrZURpc3BhdGNoQWN0aW9uKGFwaSk7XG4gICAgICBlYWNoKGlubmVyKHpyKS5yZWNvcmRzLCBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgIHJlY29yZCAmJiBjYihyZWNvcmQsIGUsIGRpcy5kaXNwYXRjaEFjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIGRpc3BhdGNoVG9vbHRpcEZpbmFsbHkoZGlzLnBlbmRpbmdzLCBhcGkpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoVG9vbHRpcEZpbmFsbHkocGVuZGluZ3MsIGFwaSkge1xuICB2YXIgc2hvd0xlbiA9IHBlbmRpbmdzLnNob3dUaXAubGVuZ3RoO1xuICB2YXIgaGlkZUxlbiA9IHBlbmRpbmdzLmhpZGVUaXAubGVuZ3RoO1xuICB2YXIgYWN0dWFsbHlQYXlsb2FkO1xuXG4gIGlmIChzaG93TGVuKSB7XG4gICAgYWN0dWFsbHlQYXlsb2FkID0gcGVuZGluZ3Muc2hvd1RpcFtzaG93TGVuIC0gMV07XG4gIH0gZWxzZSBpZiAoaGlkZUxlbikge1xuICAgIGFjdHVhbGx5UGF5bG9hZCA9IHBlbmRpbmdzLmhpZGVUaXBbaGlkZUxlbiAtIDFdO1xuICB9XG5cbiAgaWYgKGFjdHVhbGx5UGF5bG9hZCkge1xuICAgIGFjdHVhbGx5UGF5bG9hZC5kaXNwYXRjaEFjdGlvbiA9IG51bGw7XG4gICAgYXBpLmRpc3BhdGNoQWN0aW9uKGFjdHVhbGx5UGF5bG9hZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25MZWF2ZShyZWNvcmQsIGUsIGRpc3BhdGNoQWN0aW9uKSB7XG4gIHJlY29yZC5oYW5kbGVyKCdsZWF2ZScsIG51bGwsIGRpc3BhdGNoQWN0aW9uKTtcbn1cblxuZnVuY3Rpb24gZG9FbnRlcihjdXJyVHJpZ2dlciwgcmVjb3JkLCBlLCBkaXNwYXRjaEFjdGlvbikge1xuICByZWNvcmQuaGFuZGxlcihjdXJyVHJpZ2dlciwgZSwgZGlzcGF0Y2hBY3Rpb24pO1xufVxuXG5mdW5jdGlvbiBtYWtlRGlzcGF0Y2hBY3Rpb24oYXBpKSB7XG4gIHZhciBwZW5kaW5ncyA9IHtcbiAgICBzaG93VGlwOiBbXSxcbiAgICBoaWRlVGlwOiBbXVxuICB9OyAvLyBGSVhNRVxuICAvLyBiZXR0ZXIgYXBwcm9hY2g/XG4gIC8vICdzaG93VGlwJyBhbmQgJ2hpZGVUaXAnIGNhbiBiZSB0cmlnZ2VyZWQgYnkgYXhpc1BvaW50ZXIgYW5kIHRvb2x0aXAsXG4gIC8vIHdoaWNoIG1heSBiZSBjb25mbGljdCwgKGF4aXNQb2ludGVyIGNhbGwgc2hvd1RpcCBidXQgdG9vbHRpcCBjYWxsIGhpZGVUaXApO1xuICAvLyBTbyB3ZSBoYXZlIHRvIGFkZCBcImZpbmFsIHN0YWdlXCIgdG8gbWVyZ2UgdGhvc2UgZGlzcGF0Y2hlZCBhY3Rpb25zLlxuXG4gIHZhciBkaXNwYXRjaEFjdGlvbiA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgdmFyIHBlbmRpbmdMaXN0ID0gcGVuZGluZ3NbcGF5bG9hZC50eXBlXTtcblxuICAgIGlmIChwZW5kaW5nTGlzdCkge1xuICAgICAgcGVuZGluZ0xpc3QucHVzaChwYXlsb2FkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF5bG9hZC5kaXNwYXRjaEFjdGlvbiA9IGRpc3BhdGNoQWN0aW9uO1xuICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHBheWxvYWQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGRpc3BhdGNoQWN0aW9uOiBkaXNwYXRjaEFjdGlvbixcbiAgICBwZW5kaW5nczogcGVuZGluZ3NcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVucmVnaXN0ZXIoa2V5LCBhcGkpIHtcbiAgaWYgKGVudi5ub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHpyID0gYXBpLmdldFpyKCk7XG4gIHZhciByZWNvcmQgPSAoaW5uZXIoenIpLnJlY29yZHMgfHwge30pW2tleV07XG5cbiAgaWYgKHJlY29yZCkge1xuICAgIGlubmVyKHpyKS5yZWNvcmRzW2tleV0gPSBudWxsO1xuICB9XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCBBeGlzVmlldyBmcm9tICcuLi9heGlzL0F4aXNWaWV3JztcbmltcG9ydCBDYXJ0ZXNpYW5BeGlzUG9pbnRlciBmcm9tICcuL0NhcnRlc2lhbkF4aXNQb2ludGVyJztcbmltcG9ydCBBeGlzUG9pbnRlck1vZGVsIGZyb20gJy4vQXhpc1BvaW50ZXJNb2RlbCc7XG5pbXBvcnQgQXhpc1BvaW50ZXJWaWV3IGZyb20gJy4vQXhpc1BvaW50ZXJWaWV3JztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgY29sbGVjdCB9IGZyb20gJy4vbW9kZWxIZWxwZXInO1xuaW1wb3J0IGF4aXNUcmlnZ2VyIGZyb20gJy4vYXhpc1RyaWdnZXInO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIC8vIENhcnRlc2lhbkF4aXNQb2ludGVyIGlzIG5vdCBzdXBwb3NlZCB0byBiZSByZXF1aXJlZCBoZXJlLiBCdXQgY29uc2lkZXJcbiAgLy8gZWNoYXJ0cy5zaW1wbGUuanMgYW5kIG9ubGluZSBidWlsZCB0b29sdGlwLCB3aGljaCBvbmx5IHJlcXVpcmUgZ3JpZFNpbXBsZSxcbiAgLy8gQ2FydGVzaWFuQXhpc1BvaW50ZXIgc2hvdWxkIGJlIGFibGUgdG8gcmVxdWlyZWQgc29tZXdoZXJlLlxuICBBeGlzVmlldy5yZWdpc3RlckF4aXNQb2ludGVyQ2xhc3MoJ0NhcnRlc2lhbkF4aXNQb2ludGVyJywgQ2FydGVzaWFuQXhpc1BvaW50ZXIpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChBeGlzUG9pbnRlck1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhBeGlzUG9pbnRlclZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJQcmVwcm9jZXNzb3IoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIC8vIEFsd2F5cyBoYXMgYSBnbG9iYWwgYXhpc1BvaW50ZXJNb2RlbCBmb3IgZGVmYXVsdCBzZXR0aW5nLlxuICAgIGlmIChvcHRpb24pIHtcbiAgICAgICghb3B0aW9uLmF4aXNQb2ludGVyIHx8IG9wdGlvbi5heGlzUG9pbnRlci5sZW5ndGggPT09IDApICYmIChvcHRpb24uYXhpc1BvaW50ZXIgPSB7fSk7XG4gICAgICB2YXIgbGluayA9IG9wdGlvbi5heGlzUG9pbnRlci5saW5rOyAvLyBOb3JtYWxpemUgdG8gYXJyYXkgdG8gYXZvaWQgb2JqZWN0IG1lcmdpbi4gQnV0IGlmIGxpbmtcbiAgICAgIC8vIGlzIG5vdCBzZXQsIHJlbWFpbiBudWxsL3VuZGVmaW5lZCwgb3RoZXJ3aXNlIGl0IHdpbGxcbiAgICAgIC8vIG92ZXJyaWRlIGV4aXN0ZW50IGxpbmsgc2V0dGluZy5cblxuICAgICAgaWYgKGxpbmsgJiYgIWlzQXJyYXkobGluaykpIHtcbiAgICAgICAgb3B0aW9uLmF4aXNQb2ludGVyLmxpbmsgPSBbbGlua107XG4gICAgICB9XG4gICAgfVxuICB9KTsgLy8gVGhpcyBwcm9jZXNzIHNob3VsZCBwcm9mb3JtZWQgYWZ0ZXIgY29vcmRpbmF0ZSBzeXN0ZW1zIGNyZWF0ZWRcbiAgLy8gYW5kIHNlcmllcyBkYXRhIHByb2Nlc3NlZC4gU28gcHV0IGl0IG9uIHN0YXRpc3RpYyBwcm9jZXNzaW5nIHN0YWdlLlxuXG4gIHJlZ2lzdGVycy5yZWdpc3RlclByb2Nlc3NvcihyZWdpc3RlcnMuUFJJT1JJVFkuUFJPQ0VTU09SLlNUQVRJU1RJQywgZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIC8vIEJ1aWxkIGF4aXNQb2ludGVyTW9kZWwsIG1lcmdpbiB0b29sdGlwLmF4aXNQb2ludGVyIG1vZGVsIGZvciBlYWNoIGF4aXMuXG4gICAgLy8gYWxsQXhlc0luZm8gc2hvdWxkIGJlIHVwZGF0ZWQgd2hlbiBzZXRPcHRpb24gcGVyZm9ybWVkLlxuICAgIGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpLmNvb3JkU3lzQXhlc0luZm8gPSBjb2xsZWN0KGVjTW9kZWwsIGFwaSk7XG4gIH0pOyAvLyBCcm9hZGNhc3QgdG8gYWxsIHZpZXdzLlxuXG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbih7XG4gICAgdHlwZTogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgICBldmVudDogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgICB1cGRhdGU6ICc6dXBkYXRlQXhpc1BvaW50ZXInXG4gIH0sIGF4aXNUcmlnZ2VyKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgKiBhcyB0ZXh0Q29udGFpbiBmcm9tICd6cmVuZGVyL2xpYi9jb250YWluL3RleHQnO1xuaW1wb3J0ICogYXMgZm9ybWF0VXRpbCBmcm9tICcuLi8uLi91dGlsL2Zvcm1hdCc7XG5pbXBvcnQgKiBhcyBtYXRyaXggZnJvbSAnenJlbmRlci9saWIvY29yZS9tYXRyaXgnO1xuaW1wb3J0ICogYXMgYXhpc0hlbHBlciBmcm9tICcuLi8uLi9jb29yZC9heGlzSGVscGVyJztcbmltcG9ydCBBeGlzQnVpbGRlciBmcm9tICcuLi9heGlzL0F4aXNCdWlsZGVyJztcbmltcG9ydCB7IGNyZWF0ZVRleHRTdHlsZSB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRWxTdHlsZShheGlzUG9pbnRlck1vZGVsKSB7XG4gIHZhciBheGlzUG9pbnRlclR5cGUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndHlwZScpO1xuICB2YXIgc3R5bGVNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0TW9kZWwoYXhpc1BvaW50ZXJUeXBlICsgJ1N0eWxlJyk7XG4gIHZhciBzdHlsZTtcblxuICBpZiAoYXhpc1BvaW50ZXJUeXBlID09PSAnbGluZScpIHtcbiAgICBzdHlsZSA9IHN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCk7XG4gICAgc3R5bGUuZmlsbCA9IG51bGw7XG4gIH0gZWxzZSBpZiAoYXhpc1BvaW50ZXJUeXBlID09PSAnc2hhZG93Jykge1xuICAgIHN0eWxlID0gc3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKTtcbiAgICBzdHlsZS5zdHJva2UgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsYWJlbFBvcyB7YWxpZ24sIHZlcnRpY2FsQWxpZ24sIHBvc2l0aW9ufVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZExhYmVsRWxPcHRpb24oZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpLCBsYWJlbFBvcykge1xuICB2YXIgdmFsdWUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTtcbiAgdmFyIHRleHQgPSBnZXRWYWx1ZUxhYmVsKHZhbHVlLCBheGlzTW9kZWwuYXhpcywgYXhpc01vZGVsLmVjTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzZXJpZXNEYXRhSW5kaWNlcycpLCB7XG4gICAgcHJlY2lzaW9uOiBheGlzUG9pbnRlck1vZGVsLmdldChbJ2xhYmVsJywgJ3ByZWNpc2lvbiddKSxcbiAgICBmb3JtYXR0ZXI6IGF4aXNQb2ludGVyTW9kZWwuZ2V0KFsnbGFiZWwnLCAnZm9ybWF0dGVyJ10pXG4gIH0pO1xuICB2YXIgbGFiZWxNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsJyk7XG4gIHZhciBwYWRkaW5ncyA9IGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkobGFiZWxNb2RlbC5nZXQoJ3BhZGRpbmcnKSB8fCAwKTtcbiAgdmFyIGZvbnQgPSBsYWJlbE1vZGVsLmdldEZvbnQoKTtcbiAgdmFyIHRleHRSZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRleHQsIGZvbnQpO1xuICB2YXIgcG9zaXRpb24gPSBsYWJlbFBvcy5wb3NpdGlvbjtcbiAgdmFyIHdpZHRoID0gdGV4dFJlY3Qud2lkdGggKyBwYWRkaW5nc1sxXSArIHBhZGRpbmdzWzNdO1xuICB2YXIgaGVpZ2h0ID0gdGV4dFJlY3QuaGVpZ2h0ICsgcGFkZGluZ3NbMF0gKyBwYWRkaW5nc1syXTsgLy8gQWRqdXN0IGJ5IGFsaWduLlxuXG4gIHZhciBhbGlnbiA9IGxhYmVsUG9zLmFsaWduO1xuICBhbGlnbiA9PT0gJ3JpZ2h0JyAmJiAocG9zaXRpb25bMF0gLT0gd2lkdGgpO1xuICBhbGlnbiA9PT0gJ2NlbnRlcicgJiYgKHBvc2l0aW9uWzBdIC09IHdpZHRoIC8gMik7XG4gIHZhciB2ZXJ0aWNhbEFsaWduID0gbGFiZWxQb3MudmVydGljYWxBbGlnbjtcbiAgdmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScgJiYgKHBvc2l0aW9uWzFdIC09IGhlaWdodCk7XG4gIHZlcnRpY2FsQWxpZ24gPT09ICdtaWRkbGUnICYmIChwb3NpdGlvblsxXSAtPSBoZWlnaHQgLyAyKTsgLy8gTm90IG92ZXJmbG93IGVjIGNvbnRhaW5lclxuXG4gIGNvbmZpbmVJbkNvbnRhaW5lcihwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCwgYXBpKTtcbiAgdmFyIGJnQ29sb3IgPSBsYWJlbE1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XG5cbiAgaWYgKCFiZ0NvbG9yIHx8IGJnQ29sb3IgPT09ICdhdXRvJykge1xuICAgIGJnQ29sb3IgPSBheGlzTW9kZWwuZ2V0KFsnYXhpc0xpbmUnLCAnbGluZVN0eWxlJywgJ2NvbG9yJ10pO1xuICB9XG5cbiAgZWxPcHRpb24ubGFiZWwgPSB7XG4gICAgLy8gc2hhcGU6IHt4OiAwLCB5OiAwLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCByOiBsYWJlbE1vZGVsLmdldCgnYm9yZGVyUmFkaXVzJyl9LFxuICAgIHg6IHBvc2l0aW9uWzBdLFxuICAgIHk6IHBvc2l0aW9uWzFdLFxuICAgIHN0eWxlOiBjcmVhdGVUZXh0U3R5bGUobGFiZWxNb2RlbCwge1xuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICBmaWxsOiBsYWJlbE1vZGVsLmdldFRleHRDb2xvcigpLFxuICAgICAgcGFkZGluZzogcGFkZGluZ3MsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJnQ29sb3JcbiAgICB9KSxcbiAgICAvLyBMYWJsZSBzaG91bGQgYmUgb3ZlciBheGlzUG9pbnRlci5cbiAgICB6MjogMTBcbiAgfTtcbn0gLy8gRG8gbm90IG92ZXJmbG93IGVjIGNvbnRhaW5lclxuXG5mdW5jdGlvbiBjb25maW5lSW5Db250YWluZXIocG9zaXRpb24sIHdpZHRoLCBoZWlnaHQsIGFwaSkge1xuICB2YXIgdmlld1dpZHRoID0gYXBpLmdldFdpZHRoKCk7XG4gIHZhciB2aWV3SGVpZ2h0ID0gYXBpLmdldEhlaWdodCgpO1xuICBwb3NpdGlvblswXSA9IE1hdGgubWluKHBvc2l0aW9uWzBdICsgd2lkdGgsIHZpZXdXaWR0aCkgLSB3aWR0aDtcbiAgcG9zaXRpb25bMV0gPSBNYXRoLm1pbihwb3NpdGlvblsxXSArIGhlaWdodCwgdmlld0hlaWdodCkgLSBoZWlnaHQ7XG4gIHBvc2l0aW9uWzBdID0gTWF0aC5tYXgocG9zaXRpb25bMF0sIDApO1xuICBwb3NpdGlvblsxXSA9IE1hdGgubWF4KHBvc2l0aW9uWzFdLCAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlTGFiZWwodmFsdWUsIGF4aXMsIGVjTW9kZWwsIHNlcmllc0RhdGFJbmRpY2VzLCBvcHQpIHtcbiAgdmFsdWUgPSBheGlzLnNjYWxlLnBhcnNlKHZhbHVlKTtcbiAgdmFyIHRleHQgPSBheGlzLnNjYWxlLmdldExhYmVsKHtcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSwge1xuICAgIC8vIElmIGBwcmVjaXNpb25gIGlzIHNldCwgd2lkdGggY2FuIGJlIGZpeGVkIChsaWtlICcxMi4wMDUwMCcpLCB3aGljaFxuICAgIC8vIGhlbHBzIHRvIGRlYm91bmNlIHdoZW4gd2hlbiBtb3ZpbmcgbGFiZWwuXG4gICAgcHJlY2lzaW9uOiBvcHQucHJlY2lzaW9uXG4gIH0pO1xuICB2YXIgZm9ybWF0dGVyID0gb3B0LmZvcm1hdHRlcjtcblxuICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgdmFyIHBhcmFtc18xID0ge1xuICAgICAgdmFsdWU6IGF4aXNIZWxwZXIuZ2V0QXhpc1Jhd1ZhbHVlKGF4aXMsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KSxcbiAgICAgIGF4aXNEaW1lbnNpb246IGF4aXMuZGltLFxuICAgICAgYXhpc0luZGV4OiBheGlzLmluZGV4LFxuICAgICAgc2VyaWVzRGF0YTogW11cbiAgICB9O1xuICAgIHpyVXRpbC5lYWNoKHNlcmllc0RhdGFJbmRpY2VzLCBmdW5jdGlvbiAoaWR4SXRlbSkge1xuICAgICAgdmFyIHNlcmllcyA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChpZHhJdGVtLnNlcmllc0luZGV4KTtcbiAgICAgIHZhciBkYXRhSW5kZXggPSBpZHhJdGVtLmRhdGFJbmRleEluc2lkZTtcbiAgICAgIHZhciBkYXRhUGFyYW1zID0gc2VyaWVzICYmIHNlcmllcy5nZXREYXRhUGFyYW1zKGRhdGFJbmRleCk7XG4gICAgICBkYXRhUGFyYW1zICYmIHBhcmFtc18xLnNlcmllc0RhdGEucHVzaChkYXRhUGFyYW1zKTtcbiAgICB9KTtcblxuICAgIGlmICh6clV0aWwuaXNTdHJpbmcoZm9ybWF0dGVyKSkge1xuICAgICAgdGV4dCA9IGZvcm1hdHRlci5yZXBsYWNlKCd7dmFsdWV9JywgdGV4dCk7XG4gICAgfSBlbHNlIGlmICh6clV0aWwuaXNGdW5jdGlvbihmb3JtYXR0ZXIpKSB7XG4gICAgICB0ZXh0ID0gZm9ybWF0dGVyKHBhcmFtc18xKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGV4dDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1lZFBvc2l0aW9uKGF4aXMsIHZhbHVlLCBsYXlvdXRJbmZvKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSBtYXRyaXguY3JlYXRlKCk7XG4gIG1hdHJpeC5yb3RhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIGxheW91dEluZm8ucm90YXRpb24pO1xuICBtYXRyaXgudHJhbnNsYXRlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCBsYXlvdXRJbmZvLnBvc2l0aW9uKTtcbiAgcmV0dXJuIGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0oW2F4aXMuZGF0YVRvQ29vcmQodmFsdWUpLCAobGF5b3V0SW5mby5sYWJlbE9mZnNldCB8fCAwKSArIChsYXlvdXRJbmZvLmxhYmVsRGlyZWN0aW9uIHx8IDEpICogKGxheW91dEluZm8ubGFiZWxNYXJnaW4gfHwgMCldLCB0cmFuc2Zvcm0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQ2FydGVzaWFuU2luZ2xlTGFiZWxFbE9wdGlvbih2YWx1ZSwgZWxPcHRpb24sIGxheW91dEluZm8sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgdmFyIHRleHRMYXlvdXQgPSBBeGlzQnVpbGRlci5pbm5lclRleHRMYXlvdXQobGF5b3V0SW5mby5yb3RhdGlvbiwgMCwgbGF5b3V0SW5mby5sYWJlbERpcmVjdGlvbik7XG4gIGxheW91dEluZm8ubGFiZWxNYXJnaW4gPSBheGlzUG9pbnRlck1vZGVsLmdldChbJ2xhYmVsJywgJ21hcmdpbiddKTtcbiAgYnVpbGRMYWJlbEVsT3B0aW9uKGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSwge1xuICAgIHBvc2l0aW9uOiBnZXRUcmFuc2Zvcm1lZFBvc2l0aW9uKGF4aXNNb2RlbC5heGlzLCB2YWx1ZSwgbGF5b3V0SW5mbyksXG4gICAgYWxpZ246IHRleHRMYXlvdXQudGV4dEFsaWduLFxuICAgIHZlcnRpY2FsQWxpZ246IHRleHRMYXlvdXQudGV4dFZlcnRpY2FsQWxpZ25cbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZUxpbmVTaGFwZShwMSwgcDIsIHhEaW1JbmRleCkge1xuICB4RGltSW5kZXggPSB4RGltSW5kZXggfHwgMDtcbiAgcmV0dXJuIHtcbiAgICB4MTogcDFbeERpbUluZGV4XSxcbiAgICB5MTogcDFbMSAtIHhEaW1JbmRleF0sXG4gICAgeDI6IHAyW3hEaW1JbmRleF0sXG4gICAgeTI6IHAyWzEgLSB4RGltSW5kZXhdXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlY3RTaGFwZSh4eSwgd2gsIHhEaW1JbmRleCkge1xuICB4RGltSW5kZXggPSB4RGltSW5kZXggfHwgMDtcbiAgcmV0dXJuIHtcbiAgICB4OiB4eVt4RGltSW5kZXhdLFxuICAgIHk6IHh5WzEgLSB4RGltSW5kZXhdLFxuICAgIHdpZHRoOiB3aFt4RGltSW5kZXhdLFxuICAgIGhlaWdodDogd2hbMSAtIHhEaW1JbmRleF1cbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlU2VjdG9yU2hhcGUoY3gsIGN5LCByMCwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcbiAgcmV0dXJuIHtcbiAgICBjeDogY3gsXG4gICAgY3k6IGN5LFxuICAgIHIwOiByMCxcbiAgICByOiByLFxuICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGU6IGVuZEFuZ2xlLFxuICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICB9O1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgdmlzdWFsU29sdXRpb24gZnJvbSAnLi4vLi4vdmlzdWFsL3Zpc3VhbFNvbHV0aW9uJztcbmltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Nb2RlbCc7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50JztcbnZhciBERUZBVUxUX09VVF9PRl9CUlVTSF9DT0xPUiA9ICcjZGRkJztcblxudmFyIEJydXNoTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQnJ1c2hNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBCcnVzaE1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IEJydXNoTW9kZWwudHlwZTtcbiAgICAvKipcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cblxuICAgIF90aGlzLmFyZWFzID0gW107XG4gICAgLyoqXG4gICAgICogQ3VycmVudCBicnVzaCBwYWludGluZyBhcmVhIHNldHRpbmdzLlxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuXG4gICAgX3RoaXMuYnJ1c2hPcHRpb24gPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBCcnVzaE1vZGVsLnByb3RvdHlwZS5vcHRpb25VcGRhdGVkID0gZnVuY3Rpb24gKG5ld09wdGlvbiwgaXNJbml0KSB7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAhaXNJbml0ICYmIHZpc3VhbFNvbHV0aW9uLnJlcGxhY2VWaXN1YWxPcHRpb24odGhpc09wdGlvbiwgbmV3T3B0aW9uLCBbJ2luQnJ1c2gnLCAnb3V0T2ZCcnVzaCddKTtcbiAgICB2YXIgaW5CcnVzaCA9IHRoaXNPcHRpb24uaW5CcnVzaCA9IHRoaXNPcHRpb24uaW5CcnVzaCB8fCB7fTsgLy8gQWx3YXlzIGdpdmUgZGVmYXVsdCB2aXN1YWwsIGNvbnNpZGVyIHNldE9wdGlvbiBhdCB0aGUgc2Vjb25kIHRpbWUuXG5cbiAgICB0aGlzT3B0aW9uLm91dE9mQnJ1c2ggPSB0aGlzT3B0aW9uLm91dE9mQnJ1c2ggfHwge1xuICAgICAgY29sb3I6IERFRkFVTFRfT1VUX09GX0JSVVNIX0NPTE9SXG4gICAgfTtcblxuICAgIGlmICghaW5CcnVzaC5oYXNPd25Qcm9wZXJ0eSgnbGlmdFonKSkge1xuICAgICAgLy8gQmlnZ2VyIHRoYW4gdGhlIGhpZ2hsaWdodCB6IGxpZnQsIG90aGVyd2lzZSBpdCB3aWxsXG4gICAgICAvLyBiZSBlZmZlY3RlZCBieSB0aGUgaGlnaGxpZ2h0IHogd2hlbiBicnVzaC5cbiAgICAgIGluQnJ1c2gubGlmdFogPSA1O1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIElmIGBhcmVhc2AgaXMgbnVsbC91bmRlZmluZWQsIHJhbmdlIHN0YXRlIHJlbWFpbi5cbiAgICovXG5cblxuICBCcnVzaE1vZGVsLnByb3RvdHlwZS5zZXRBcmVhcyA9IGZ1bmN0aW9uIChhcmVhcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB6clV0aWwuYXNzZXJ0KHpyVXRpbC5pc0FycmF5KGFyZWFzKSk7XG4gICAgICB6clV0aWwuZWFjaChhcmVhcywgZnVuY3Rpb24gKGFyZWEpIHtcbiAgICAgICAgenJVdGlsLmFzc2VydChhcmVhLmJydXNoVHlwZSwgJ0lsbGVnYWwgYXJlYXMnKTtcbiAgICAgIH0pO1xuICAgIH0gLy8gSWYgYXJlYXMgaXMgbnVsbC91bmRlZmluZWQsIHJhbmdlIHN0YXRlIHJlbWFpbi5cbiAgICAvLyBUaGlzIGhlbHBzIHVzZXIgdG8gZGlzcGF0Y2hBY3Rpb24oe3R5cGU6ICdicnVzaCd9KSB3aXRoIG5vIGFyZWFzXG4gICAgLy8gc2V0IGJ1dCBqdXN0IHdhbnQgdG8gZ2V0IHRoZSBjdXJyZW50IGJydXNoIHNlbGVjdCBpbmZvIGZyb20gYSBgYnJ1c2hgIGV2ZW50LlxuXG5cbiAgICBpZiAoIWFyZWFzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hcmVhcyA9IHpyVXRpbC5tYXAoYXJlYXMsIGZ1bmN0aW9uIChhcmVhKSB7XG4gICAgICByZXR1cm4gZ2VuZXJhdGVCcnVzaE9wdGlvbih0aGlzLm9wdGlvbiwgYXJlYSk7XG4gICAgfSwgdGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1cnJlbnQgcGFpbnRpbmcgYnJ1c2ggb3B0aW9uLlxuICAgKi9cblxuXG4gIEJydXNoTW9kZWwucHJvdG90eXBlLnNldEJydXNoT3B0aW9uID0gZnVuY3Rpb24gKGJydXNoT3B0aW9uKSB7XG4gICAgdGhpcy5icnVzaE9wdGlvbiA9IGdlbmVyYXRlQnJ1c2hPcHRpb24odGhpcy5vcHRpb24sIGJydXNoT3B0aW9uKTtcbiAgICB0aGlzLmJydXNoVHlwZSA9IHRoaXMuYnJ1c2hPcHRpb24uYnJ1c2hUeXBlO1xuICB9O1xuXG4gIEJydXNoTW9kZWwudHlwZSA9ICdicnVzaCc7XG4gIEJydXNoTW9kZWwuZGVwZW5kZW5jaWVzID0gWydnZW8nLCAnZ3JpZCcsICd4QXhpcycsICd5QXhpcycsICdwYXJhbGxlbCcsICdzZXJpZXMnXTtcbiAgQnJ1c2hNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIHNlcmllc0luZGV4OiAnYWxsJyxcbiAgICBicnVzaFR5cGU6ICdyZWN0JyxcbiAgICBicnVzaE1vZGU6ICdzaW5nbGUnLFxuICAgIHRyYW5zZm9ybWFibGU6IHRydWUsXG4gICAgYnJ1c2hTdHlsZToge1xuICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICBjb2xvcjogJ3JnYmEoMjEwLDIxOSwyMzgsMC4zKScsXG4gICAgICBib3JkZXJDb2xvcjogJyNEMkRCRUUnXG4gICAgfSxcbiAgICB0aHJvdHRsZVR5cGU6ICdmaXhSYXRlJyxcbiAgICB0aHJvdHRsZURlbGF5OiAwLFxuICAgIHJlbW92ZU9uQ2xpY2s6IHRydWUsXG4gICAgejogMTAwMDBcbiAgfTtcbiAgcmV0dXJuIEJydXNoTW9kZWw7XG59KENvbXBvbmVudE1vZGVsKTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVCcnVzaE9wdGlvbihvcHRpb24sIGJydXNoT3B0aW9uKSB7XG4gIHJldHVybiB6clV0aWwubWVyZ2Uoe1xuICAgIGJydXNoVHlwZTogb3B0aW9uLmJydXNoVHlwZSxcbiAgICBicnVzaE1vZGU6IG9wdGlvbi5icnVzaE1vZGUsXG4gICAgdHJhbnNmb3JtYWJsZTogb3B0aW9uLnRyYW5zZm9ybWFibGUsXG4gICAgYnJ1c2hTdHlsZTogbmV3IE1vZGVsKG9wdGlvbi5icnVzaFN0eWxlKS5nZXRJdGVtU3R5bGUoKSxcbiAgICByZW1vdmVPbkNsaWNrOiBvcHRpb24ucmVtb3ZlT25DbGljayxcbiAgICB6OiBvcHRpb24uelxuICB9LCBicnVzaE9wdGlvbiwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJydXNoTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgQnJ1c2hDb250cm9sbGVyIGZyb20gJy4uL2hlbHBlci9CcnVzaENvbnRyb2xsZXInO1xuaW1wb3J0IHsgbGF5b3V0Q292ZXJzIH0gZnJvbSAnLi92aXN1YWxFbmNvZGluZyc7XG5pbXBvcnQgQ29tcG9uZW50VmlldyBmcm9tICcuLi8uLi92aWV3L0NvbXBvbmVudCc7XG5cbnZhciBCcnVzaFZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQnJ1c2hWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEJydXNoVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBCcnVzaFZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBCcnVzaFZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgICB0aGlzLmFwaSA9IGFwaTtcbiAgICB0aGlzLm1vZGVsO1xuICAgICh0aGlzLl9icnVzaENvbnRyb2xsZXIgPSBuZXcgQnJ1c2hDb250cm9sbGVyKGFwaS5nZXRacigpKSkub24oJ2JydXNoJywgenJVdGlsLmJpbmQodGhpcy5fb25CcnVzaCwgdGhpcykpLm1vdW50KCk7XG4gIH07XG5cbiAgQnJ1c2hWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoYnJ1c2hNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdGhpcy5tb2RlbCA9IGJydXNoTW9kZWw7XG5cbiAgICB0aGlzLl91cGRhdGVDb250cm9sbGVyKGJydXNoTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gIH07XG5cbiAgQnJ1c2hWaWV3LnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoYnJ1c2hNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgLy8gUEVORElORzogYHVwZGF0ZVRyYW5zZm9ybWAgaXMgYSBsaXR0bGUgdHJpY2t5LCB3aG9zZSBsYXlvdXQgbmVlZFxuICAgIC8vIHRvIGJlIGNhbGN1bGF0ZSBtYW5kYXRvcmlseSBhbmQgb3RoZXIgc3RhZ2VzIHdpbGwgbm90IGJlIHBlcmZvcm1lZC5cbiAgICAvLyBUYWtlIGNhcmUgdGhlIGNvcnJlY3RuZXNzIG9mIHRoZSBsb2dpYy4gU2VlICMxMTc1NCAuXG4gICAgbGF5b3V0Q292ZXJzKGVjTW9kZWwpO1xuXG4gICAgdGhpcy5fdXBkYXRlQ29udHJvbGxlcihicnVzaE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICB9O1xuXG4gIEJydXNoVmlldy5wcm90b3R5cGUudXBkYXRlVmlzdWFsID0gZnVuY3Rpb24gKGJydXNoTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKGJydXNoTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gIH07XG5cbiAgQnJ1c2hWaWV3LnByb3RvdHlwZS51cGRhdGVWaWV3ID0gZnVuY3Rpb24gKGJydXNoTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRoaXMuX3VwZGF0ZUNvbnRyb2xsZXIoYnJ1c2hNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgfTtcblxuICBCcnVzaFZpZXcucHJvdG90eXBlLl91cGRhdGVDb250cm9sbGVyID0gZnVuY3Rpb24gKGJydXNoTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIC8vIERvIG5vdCB1cGRhdGUgY29udHJvbGxlciB3aGVuIGRyYXdpbmcuXG4gICAgKCFwYXlsb2FkIHx8IHBheWxvYWQuJGZyb20gIT09IGJydXNoTW9kZWwuaWQpICYmIHRoaXMuX2JydXNoQ29udHJvbGxlci5zZXRQYW5lbHMoYnJ1c2hNb2RlbC5icnVzaFRhcmdldE1hbmFnZXIubWFrZVBhbmVsT3B0cyhhcGkpKS5lbmFibGVCcnVzaChicnVzaE1vZGVsLmJydXNoT3B0aW9uKS51cGRhdGVDb3ZlcnMoYnJ1c2hNb2RlbC5hcmVhcy5zbGljZSgpKTtcbiAgfTsgLy8gdXBkYXRlTGF5b3V0OiB1cGRhdGVDb250cm9sbGVyLFxuICAvLyB1cGRhdGVWaXN1YWw6IHVwZGF0ZUNvbnRyb2xsZXIsXG5cblxuICBCcnVzaFZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYnJ1c2hDb250cm9sbGVyLmRpc3Bvc2UoKTtcbiAgfTtcblxuICBCcnVzaFZpZXcucHJvdG90eXBlLl9vbkJydXNoID0gZnVuY3Rpb24gKGV2ZW50UGFyYW0pIHtcbiAgICB2YXIgbW9kZWxJZCA9IHRoaXMubW9kZWwuaWQ7XG4gICAgdmFyIGFyZWFzID0gdGhpcy5tb2RlbC5icnVzaFRhcmdldE1hbmFnZXIuc2V0T3V0cHV0UmFuZ2VzKGV2ZW50UGFyYW0uYXJlYXMsIHRoaXMuZWNNb2RlbCk7IC8vIEFjdGlvbiBpcyBub3QgZGlzcGF0Y2hlZCBvbiBkcmFnIGVuZCwgYmVjYXVzZSB0aGUgZHJhZyBlbmRcbiAgICAvLyBlbWl0cyB0aGUgc2FtZSBwYXJhbXMgd2l0aCB0aGUgbGFzdCBkcmFnIG1vdmUgZXZlbnQsIGFuZFxuICAgIC8vIG1heSBoYXZlIHNvbWUgZGVsYXkgd2hlbiB1c2luZyB0b3VjaCBwYWQsIHdoaWNoIG1ha2VzXG4gICAgLy8gYW5pbWF0aW9uIG5vdCBzbW9vdGggKHdoZW4gdXNpbmcgZGVib3VuY2UpLlxuXG4gICAgKCFldmVudFBhcmFtLmlzRW5kIHx8IGV2ZW50UGFyYW0ucmVtb3ZlT25DbGljaykgJiYgdGhpcy5hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2JydXNoJyxcbiAgICAgIGJydXNoSWQ6IG1vZGVsSWQsXG4gICAgICBhcmVhczogenJVdGlsLmNsb25lKGFyZWFzKSxcbiAgICAgICRmcm9tOiBtb2RlbElkXG4gICAgfSk7XG4gICAgZXZlbnRQYXJhbS5pc0VuZCAmJiB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnYnJ1c2hFbmQnLFxuICAgICAgYnJ1c2hJZDogbW9kZWxJZCxcbiAgICAgIGFyZWFzOiB6clV0aWwuY2xvbmUoYXJlYXMpLFxuICAgICAgJGZyb206IG1vZGVsSWRcbiAgICB9KTtcbiAgfTtcblxuICBCcnVzaFZpZXcudHlwZSA9ICdicnVzaCc7XG4gIHJldHVybiBCcnVzaFZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuXG5leHBvcnQgZGVmYXVsdCBCcnVzaFZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCBicnVzaFByZXByb2Nlc3NvciBmcm9tICcuL3ByZXByb2Nlc3Nvcic7XG5pbXBvcnQgQnJ1c2hWaWV3IGZyb20gJy4vQnJ1c2hWaWV3JztcbmltcG9ydCBCcnVzaE1vZGVsIGZyb20gJy4vQnJ1c2hNb2RlbCc7XG5pbXBvcnQgYnJ1c2hWaXN1YWwgZnJvbSAnLi92aXN1YWxFbmNvZGluZyc7IC8vIFRPRE9cblxuaW1wb3J0IEJydXNoRmVhdHVyZSBmcm9tICcuLi90b29sYm94L2ZlYXR1cmUvQnJ1c2gnO1xuaW1wb3J0IHsgcmVnaXN0ZXJGZWF0dXJlIH0gZnJvbSAnLi4vdG9vbGJveC9mZWF0dXJlTWFuYWdlcic7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhCcnVzaFZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChCcnVzaE1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGJydXNoUHJlcHJvY2Vzc29yKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyVmlzdWFsKHJlZ2lzdGVycy5QUklPUklUWS5WSVNVQUwuQlJVU0gsIGJydXNoVmlzdWFsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgICB0eXBlOiAnYnJ1c2gnLFxuICAgIGV2ZW50OiAnYnJ1c2gnLFxuICAgIHVwZGF0ZTogJ3VwZGF0ZVZpc3VhbCdcbiAgfSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6ICdicnVzaCcsXG4gICAgICBxdWVyeTogcGF5bG9hZFxuICAgIH0sIGZ1bmN0aW9uIChicnVzaE1vZGVsKSB7XG4gICAgICBicnVzaE1vZGVsLnNldEFyZWFzKHBheWxvYWQuYXJlYXMpO1xuICAgIH0pO1xuICB9KTtcbiAgLyoqXG4gICAqIHBheWxvYWQ6IHtcbiAgICogICAgICBicnVzaENvbXBvbmVudHM6IFtcbiAgICogICAgICAgICAge1xuICAgKiAgICAgICAgICAgICAgYnJ1c2hJZCxcbiAgICogICAgICAgICAgICAgIGJydXNoSW5kZXgsXG4gICAqICAgICAgICAgICAgICBicnVzaE5hbWUsXG4gICAqICAgICAgICAgICAgICBzZXJpZXM6IFtcbiAgICogICAgICAgICAgICAgICAgICB7XG4gICAqICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0lkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTmFtZSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgcmF3SW5kaWNlczogWzIxLCAzNCwgLi4uXVxuICAgKiAgICAgICAgICAgICAgICAgIH0sXG4gICAqICAgICAgICAgICAgICAgICAgLi4uXG4gICAqICAgICAgICAgICAgICBdXG4gICAqICAgICAgICAgIH0sXG4gICAqICAgICAgICAgIC4uLlxuICAgKiAgICAgIF1cbiAgICogfVxuICAgKi9cblxuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oe1xuICAgIHR5cGU6ICdicnVzaFNlbGVjdCcsXG4gICAgZXZlbnQ6ICdicnVzaFNlbGVjdGVkJyxcbiAgICB1cGRhdGU6ICdub25lJ1xuICB9LCBmdW5jdGlvbiAoKSB7fSk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbih7XG4gICAgdHlwZTogJ2JydXNoRW5kJyxcbiAgICBldmVudDogJ2JydXNoRW5kJyxcbiAgICB1cGRhdGU6ICdub25lJ1xuICB9LCBmdW5jdGlvbiAoKSB7fSk7XG4gIHJlZ2lzdGVyRmVhdHVyZSgnYnJ1c2gnLCBCcnVzaEZlYXR1cmUpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCB7IG5vcm1hbGl6ZVRvQXJyYXkgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbnZhciBERUZBVUxUX1RPT0xCT1hfQlROUyA9IFsncmVjdCcsICdwb2x5Z29uJywgJ2tlZXAnLCAnY2xlYXInXTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJydXNoUHJlcHJvY2Vzc29yKG9wdGlvbiwgaXNOZXcpIHtcbiAgdmFyIGJydXNoQ29tcG9uZW50cyA9IG5vcm1hbGl6ZVRvQXJyYXkob3B0aW9uID8gb3B0aW9uLmJydXNoIDogW10pO1xuXG4gIGlmICghYnJ1c2hDb21wb25lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBicnVzaENvbXBvbmVudFNwZWNpZmllZEJ0bnMgPSBbXTtcbiAgenJVdGlsLmVhY2goYnJ1c2hDb21wb25lbnRzLCBmdW5jdGlvbiAoYnJ1c2hPcHQpIHtcbiAgICB2YXIgdGJzID0gYnJ1c2hPcHQuaGFzT3duUHJvcGVydHkoJ3Rvb2xib3gnKSA/IGJydXNoT3B0LnRvb2xib3ggOiBbXTtcblxuICAgIGlmICh0YnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgYnJ1c2hDb21wb25lbnRTcGVjaWZpZWRCdG5zID0gYnJ1c2hDb21wb25lbnRTcGVjaWZpZWRCdG5zLmNvbmNhdCh0YnMpO1xuICAgIH1cbiAgfSk7XG4gIHZhciB0b29sYm94ID0gb3B0aW9uICYmIG9wdGlvbi50b29sYm94O1xuXG4gIGlmICh6clV0aWwuaXNBcnJheSh0b29sYm94KSkge1xuICAgIHRvb2xib3ggPSB0b29sYm94WzBdO1xuICB9XG5cbiAgaWYgKCF0b29sYm94KSB7XG4gICAgdG9vbGJveCA9IHtcbiAgICAgIGZlYXR1cmU6IHt9XG4gICAgfTtcbiAgICBvcHRpb24udG9vbGJveCA9IFt0b29sYm94XTtcbiAgfVxuXG4gIHZhciB0b29sYm94RmVhdHVyZSA9IHRvb2xib3guZmVhdHVyZSB8fCAodG9vbGJveC5mZWF0dXJlID0ge30pO1xuICB2YXIgdG9vbGJveEJydXNoID0gdG9vbGJveEZlYXR1cmUuYnJ1c2ggfHwgKHRvb2xib3hGZWF0dXJlLmJydXNoID0ge30pO1xuICB2YXIgYnJ1c2hUeXBlcyA9IHRvb2xib3hCcnVzaC50eXBlIHx8ICh0b29sYm94QnJ1c2gudHlwZSA9IFtdKTtcbiAgYnJ1c2hUeXBlcy5wdXNoLmFwcGx5KGJydXNoVHlwZXMsIGJydXNoQ29tcG9uZW50U3BlY2lmaWVkQnRucyk7XG4gIHJlbW92ZUR1cGxpY2F0ZShicnVzaFR5cGVzKTtcblxuICBpZiAoaXNOZXcgJiYgIWJydXNoVHlwZXMubGVuZ3RoKSB7XG4gICAgYnJ1c2hUeXBlcy5wdXNoLmFwcGx5KGJydXNoVHlwZXMsIERFRkFVTFRfVE9PTEJPWF9CVE5TKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGUoYXJyKSB7XG4gIHZhciBtYXAgPSB7fTtcbiAgenJVdGlsLmVhY2goYXJyLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgbWFwW3ZhbF0gPSAxO1xuICB9KTtcbiAgYXJyLmxlbmd0aCA9IDA7XG4gIHpyVXRpbC5lYWNoKG1hcCwgZnVuY3Rpb24gKGZsYWcsIHZhbCkge1xuICAgIGFyci5wdXNoKHZhbCk7XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgKiBhcyBwb2x5Z29uQ29udGFpbiBmcm9tICd6cmVuZGVyL2xpYi9jb250YWluL3BvbHlnb24nO1xuaW1wb3J0IEJvdW5kaW5nUmVjdCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCc7XG5pbXBvcnQgeyBsaW5lUG9seWdvbkludGVyc2VjdCB9IGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5leHBvcnQgZnVuY3Rpb24gbWFrZUJydXNoQ29tbW9uU2VsZWN0b3JGb3JTZXJpZXMoYXJlYSkge1xuICB2YXIgYnJ1c2hUeXBlID0gYXJlYS5icnVzaFR5cGU7IC8vIERvIG5vdCB1c2UgZnVuY3Rpb24gYmluZGluZyBvciBjdXJyeSBmb3IgcGVyZm9ybWFuY2UuXG5cbiAgdmFyIHNlbGVjdG9ycyA9IHtcbiAgICBwb2ludDogZnVuY3Rpb24gKGl0ZW1MYXlvdXQpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvclticnVzaFR5cGVdLnBvaW50KGl0ZW1MYXlvdXQsIHNlbGVjdG9ycywgYXJlYSk7XG4gICAgfSxcbiAgICByZWN0OiBmdW5jdGlvbiAoaXRlbUxheW91dCkge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yW2JydXNoVHlwZV0ucmVjdChpdGVtTGF5b3V0LCBzZWxlY3RvcnMsIGFyZWEpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHNlbGVjdG9ycztcbn1cbnZhciBzZWxlY3RvciA9IHtcbiAgbGluZVg6IGdldExpbmVTZWxlY3RvcnMoMCksXG4gIGxpbmVZOiBnZXRMaW5lU2VsZWN0b3JzKDEpLFxuICByZWN0OiB7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uIChpdGVtTGF5b3V0LCBzZWxlY3RvcnMsIGFyZWEpIHtcbiAgICAgIHJldHVybiBpdGVtTGF5b3V0ICYmIGFyZWEuYm91bmRpbmdSZWN0LmNvbnRhaW4oaXRlbUxheW91dFswXSwgaXRlbUxheW91dFsxXSk7XG4gICAgfSxcbiAgICByZWN0OiBmdW5jdGlvbiAoaXRlbUxheW91dCwgc2VsZWN0b3JzLCBhcmVhKSB7XG4gICAgICByZXR1cm4gaXRlbUxheW91dCAmJiBhcmVhLmJvdW5kaW5nUmVjdC5pbnRlcnNlY3QoaXRlbUxheW91dCk7XG4gICAgfVxuICB9LFxuICBwb2x5Z29uOiB7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uIChpdGVtTGF5b3V0LCBzZWxlY3RvcnMsIGFyZWEpIHtcbiAgICAgIHJldHVybiBpdGVtTGF5b3V0ICYmIGFyZWEuYm91bmRpbmdSZWN0LmNvbnRhaW4oaXRlbUxheW91dFswXSwgaXRlbUxheW91dFsxXSkgJiYgcG9seWdvbkNvbnRhaW4uY29udGFpbihhcmVhLnJhbmdlLCBpdGVtTGF5b3V0WzBdLCBpdGVtTGF5b3V0WzFdKTtcbiAgICB9LFxuICAgIHJlY3Q6IGZ1bmN0aW9uIChpdGVtTGF5b3V0LCBzZWxlY3RvcnMsIGFyZWEpIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcmVhLnJhbmdlO1xuXG4gICAgICBpZiAoIWl0ZW1MYXlvdXQgfHwgcG9pbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBpdGVtTGF5b3V0Lng7XG4gICAgICB2YXIgeSA9IGl0ZW1MYXlvdXQueTtcbiAgICAgIHZhciB3aWR0aCA9IGl0ZW1MYXlvdXQud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gaXRlbUxheW91dC5oZWlnaHQ7XG4gICAgICB2YXIgcCA9IHBvaW50c1swXTtcblxuICAgICAgaWYgKHBvbHlnb25Db250YWluLmNvbnRhaW4ocG9pbnRzLCB4LCB5KSB8fCBwb2x5Z29uQ29udGFpbi5jb250YWluKHBvaW50cywgeCArIHdpZHRoLCB5KSB8fCBwb2x5Z29uQ29udGFpbi5jb250YWluKHBvaW50cywgeCwgeSArIGhlaWdodCkgfHwgcG9seWdvbkNvbnRhaW4uY29udGFpbihwb2ludHMsIHggKyB3aWR0aCwgeSArIGhlaWdodCkgfHwgQm91bmRpbmdSZWN0LmNyZWF0ZShpdGVtTGF5b3V0KS5jb250YWluKHBbMF0sIHBbMV0pIHx8IGxpbmVQb2x5Z29uSW50ZXJzZWN0KHgsIHksIHggKyB3aWR0aCwgeSwgcG9pbnRzKSB8fCBsaW5lUG9seWdvbkludGVyc2VjdCh4LCB5LCB4LCB5ICsgaGVpZ2h0LCBwb2ludHMpIHx8IGxpbmVQb2x5Z29uSW50ZXJzZWN0KHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCBwb2ludHMpIHx8IGxpbmVQb2x5Z29uSW50ZXJzZWN0KHgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCwgeSArIGhlaWdodCwgcG9pbnRzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldExpbmVTZWxlY3RvcnMoeHlJbmRleCkge1xuICB2YXIgeHkgPSBbJ3gnLCAneSddO1xuICB2YXIgd2ggPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xuICByZXR1cm4ge1xuICAgIHBvaW50OiBmdW5jdGlvbiAoaXRlbUxheW91dCwgc2VsZWN0b3JzLCBhcmVhKSB7XG4gICAgICBpZiAoaXRlbUxheW91dCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBhcmVhLnJhbmdlO1xuICAgICAgICB2YXIgcCA9IGl0ZW1MYXlvdXRbeHlJbmRleF07XG4gICAgICAgIHJldHVybiBpbkxpbmVSYW5nZShwLCByYW5nZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZWN0OiBmdW5jdGlvbiAoaXRlbUxheW91dCwgc2VsZWN0b3JzLCBhcmVhKSB7XG4gICAgICBpZiAoaXRlbUxheW91dCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBhcmVhLnJhbmdlO1xuICAgICAgICB2YXIgbGF5b3V0UmFuZ2UgPSBbaXRlbUxheW91dFt4eVt4eUluZGV4XV0sIGl0ZW1MYXlvdXRbeHlbeHlJbmRleF1dICsgaXRlbUxheW91dFt3aFt4eUluZGV4XV1dO1xuICAgICAgICBsYXlvdXRSYW5nZVsxXSA8IGxheW91dFJhbmdlWzBdICYmIGxheW91dFJhbmdlLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIGluTGluZVJhbmdlKGxheW91dFJhbmdlWzBdLCByYW5nZSkgfHwgaW5MaW5lUmFuZ2UobGF5b3V0UmFuZ2VbMV0sIHJhbmdlKSB8fCBpbkxpbmVSYW5nZShyYW5nZVswXSwgbGF5b3V0UmFuZ2UpIHx8IGluTGluZVJhbmdlKHJhbmdlWzFdLCBsYXlvdXRSYW5nZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbkxpbmVSYW5nZShwLCByYW5nZSkge1xuICByZXR1cm4gcmFuZ2VbMF0gPD0gcCAmJiBwIDw9IHJhbmdlWzFdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZWxlY3RvcjsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgQm91bmRpbmdSZWN0IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0JztcbmltcG9ydCAqIGFzIHZpc3VhbFNvbHV0aW9uIGZyb20gJy4uLy4uL3Zpc3VhbC92aXN1YWxTb2x1dGlvbic7XG5pbXBvcnQgeyBtYWtlQnJ1c2hDb21tb25TZWxlY3RvckZvclNlcmllcyB9IGZyb20gJy4vc2VsZWN0b3InO1xuaW1wb3J0ICogYXMgdGhyb3R0bGVVdGlsIGZyb20gJy4uLy4uL3V0aWwvdGhyb3R0bGUnO1xuaW1wb3J0IEJydXNoVGFyZ2V0TWFuYWdlciBmcm9tICcuLi9oZWxwZXIvQnJ1c2hUYXJnZXRNYW5hZ2VyJztcbnZhciBTVEFURV9MSVNUID0gWydpbkJydXNoJywgJ291dE9mQnJ1c2gnXTtcbnZhciBESVNQQVRDSF9NRVRIT0QgPSAnX19lY0JydXNoU2VsZWN0JztcbnZhciBESVNQQVRDSF9GTEFHID0gJ19fZWNJbkJydXNoU2VsZWN0RXZlbnQnO1xuO1xuZXhwb3J0IGZ1bmN0aW9uIGxheW91dENvdmVycyhlY01vZGVsKSB7XG4gIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgbWFpblR5cGU6ICdicnVzaCdcbiAgfSwgZnVuY3Rpb24gKGJydXNoTW9kZWwpIHtcbiAgICB2YXIgYnJ1c2hUYXJnZXRNYW5hZ2VyID0gYnJ1c2hNb2RlbC5icnVzaFRhcmdldE1hbmFnZXIgPSBuZXcgQnJ1c2hUYXJnZXRNYW5hZ2VyKGJydXNoTW9kZWwub3B0aW9uLCBlY01vZGVsKTtcbiAgICBicnVzaFRhcmdldE1hbmFnZXIuc2V0SW5wdXRSYW5nZXMoYnJ1c2hNb2RlbC5hcmVhcywgZWNNb2RlbCk7XG4gIH0pO1xufVxuLyoqXG4gKiBSZWdpc3RlciB0aGUgdmlzdWFsIGVuY29kaW5nIGlmIHRoaXMgbW9kdWxlcyByZXF1aXJlZC5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBicnVzaFZpc3VhbChlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgdmFyIGJydXNoU2VsZWN0ZWQgPSBbXTtcbiAgdmFyIHRocm90dGxlVHlwZTtcbiAgdmFyIHRocm90dGxlRGVsYXk7XG4gIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgbWFpblR5cGU6ICdicnVzaCdcbiAgfSwgZnVuY3Rpb24gKGJydXNoTW9kZWwpIHtcbiAgICBwYXlsb2FkICYmIHBheWxvYWQudHlwZSA9PT0gJ3Rha2VHbG9iYWxDdXJzb3InICYmIGJydXNoTW9kZWwuc2V0QnJ1c2hPcHRpb24ocGF5bG9hZC5rZXkgPT09ICdicnVzaCcgPyBwYXlsb2FkLmJydXNoT3B0aW9uIDoge1xuICAgICAgYnJ1c2hUeXBlOiBmYWxzZVxuICAgIH0pO1xuICB9KTtcbiAgbGF5b3V0Q292ZXJzKGVjTW9kZWwpO1xuICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgIG1haW5UeXBlOiAnYnJ1c2gnXG4gIH0sIGZ1bmN0aW9uIChicnVzaE1vZGVsLCBicnVzaEluZGV4KSB7XG4gICAgdmFyIHRoaXNCcnVzaFNlbGVjdGVkID0ge1xuICAgICAgYnJ1c2hJZDogYnJ1c2hNb2RlbC5pZCxcbiAgICAgIGJydXNoSW5kZXg6IGJydXNoSW5kZXgsXG4gICAgICBicnVzaE5hbWU6IGJydXNoTW9kZWwubmFtZSxcbiAgICAgIGFyZWFzOiB6clV0aWwuY2xvbmUoYnJ1c2hNb2RlbC5hcmVhcyksXG4gICAgICBzZWxlY3RlZDogW11cbiAgICB9OyAvLyBFdmVyeSBicnVzaCBjb21wb25lbnQgZXhpc3RzIGluIGV2ZW50IHBhcmFtcywgY29udmVuaWVudFxuICAgIC8vIGZvciB1c2VyIHRvIGZpbmQgYnkgaW5kZXguXG5cbiAgICBicnVzaFNlbGVjdGVkLnB1c2godGhpc0JydXNoU2VsZWN0ZWQpO1xuICAgIHZhciBicnVzaE9wdGlvbiA9IGJydXNoTW9kZWwub3B0aW9uO1xuICAgIHZhciBicnVzaExpbmsgPSBicnVzaE9wdGlvbi5icnVzaExpbms7XG4gICAgdmFyIGxpbmtlZFNlcmllc01hcCA9IFtdO1xuICAgIHZhciBzZWxlY3RlZERhdGFJbmRleEZvckxpbmsgPSBbXTtcbiAgICB2YXIgcmFuZ2VJbmZvQnlTZXJpZXMgPSBbXTtcbiAgICB2YXIgaGFzQnJ1c2hFeGlzdHMgPSBmYWxzZTtcblxuICAgIGlmICghYnJ1c2hJbmRleCkge1xuICAgICAgLy8gT25seSB0aGUgZmlyc3QgdGhyb3R0bGUgc2V0dGluZyB3b3Jrcy5cbiAgICAgIHRocm90dGxlVHlwZSA9IGJydXNoT3B0aW9uLnRocm90dGxlVHlwZTtcbiAgICAgIHRocm90dGxlRGVsYXkgPSBicnVzaE9wdGlvbi50aHJvdHRsZURlbGF5O1xuICAgIH0gLy8gQWRkIGJvdW5kaW5nUmVjdCBhbmQgc2VsZWN0b3JzIHRvIHJhbmdlLlxuXG5cbiAgICB2YXIgYXJlYXMgPSB6clV0aWwubWFwKGJydXNoTW9kZWwuYXJlYXMsIGZ1bmN0aW9uIChhcmVhKSB7XG4gICAgICB2YXIgYnVpbGRlciA9IGJvdW5kaW5nUmVjdEJ1aWxkZXJzW2FyZWEuYnJ1c2hUeXBlXTtcbiAgICAgIHZhciBzZWxlY3RhYmxlQXJlYSA9IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgIGJvdW5kaW5nUmVjdDogYnVpbGRlciA/IGJ1aWxkZXIoYXJlYSkgOiB2b2lkIDBcbiAgICAgIH0sIGFyZWEpO1xuICAgICAgc2VsZWN0YWJsZUFyZWEuc2VsZWN0b3JzID0gbWFrZUJydXNoQ29tbW9uU2VsZWN0b3JGb3JTZXJpZXMoc2VsZWN0YWJsZUFyZWEpO1xuICAgICAgcmV0dXJuIHNlbGVjdGFibGVBcmVhO1xuICAgIH0pO1xuICAgIHZhciB2aXN1YWxNYXBwaW5ncyA9IHZpc3VhbFNvbHV0aW9uLmNyZWF0ZVZpc3VhbE1hcHBpbmdzKGJydXNoTW9kZWwub3B0aW9uLCBTVEFURV9MSVNULCBmdW5jdGlvbiAobWFwcGluZ09wdGlvbikge1xuICAgICAgbWFwcGluZ09wdGlvbi5tYXBwaW5nTWV0aG9kID0gJ2ZpeGVkJztcbiAgICB9KTtcbiAgICB6clV0aWwuaXNBcnJheShicnVzaExpbmspICYmIHpyVXRpbC5lYWNoKGJydXNoTGluaywgZnVuY3Rpb24gKHNlcmllc0luZGV4KSB7XG4gICAgICBsaW5rZWRTZXJpZXNNYXBbc2VyaWVzSW5kZXhdID0gMTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGxpbmtPdGhlcnMoc2VyaWVzSW5kZXgpIHtcbiAgICAgIHJldHVybiBicnVzaExpbmsgPT09ICdhbGwnIHx8ICEhbGlua2VkU2VyaWVzTWFwW3Nlcmllc0luZGV4XTtcbiAgICB9IC8vIElmIG5vIHN1cHBvcnRlZCBicnVzaCBvciBubyBicnVzaCBvbiB0aGUgc2VyaWVzLFxuICAgIC8vIGFsbCB2aXN1YWxzIHNob3VsZCBiZSBpbiBvcmlnaW5hbCBzdGF0ZS5cblxuXG4gICAgZnVuY3Rpb24gYnJ1c2hlZChyYW5nZUluZm9MaXN0KSB7XG4gICAgICByZXR1cm4gISFyYW5nZUluZm9MaXN0Lmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9naWMgZm9yIGVhY2ggc2VyaWVzOiAoSWYgdGhlIGxvZ2ljIGhhcyB0byBiZSBtb2RpZmllZCBvbmUgZGF5LCBkbyBpdCBjYXJlZnVsbHkhKVxuICAgICAqXG4gICAgICogKCBicnVzaGVkIOKUrCAmJiDilKxoYXNCcnVzaEV4aXN0IOKUrCAmJiBsaW5rT3RoZXJzICApID0+IFN0ZXBBOiDilKxyZWNvcmQsIOKUrCBTdGVwQjog4pSsdmlzdWFsQnlSZWNvcmQuXG4gICAgICogICAhYnJ1c2hlZOKUmCAgICDilJxoYXNCcnVzaEV4aXN0IOKUpCAgICAgICAgICAgICAgICAgICAgICAgICAgICDilJRub3RoaW5nLOKUmCAgICAgICAg4pScdmlzdWFsQnlSZWNvcmQuXG4gICAgICogICAgICAgICAgICAgICAg4pSUIWhhc0JydXNoRXhpc3TilJggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSUbm90aGluZy5cbiAgICAgKiAoICFicnVzaGVkICAmJiDilKxoYXNCcnVzaEV4aXN0IOKUrCAmJiBsaW5rT3RoZXJzICApID0+IFN0ZXBBOiAgbm90aGluZywgIFN0ZXBCOiDilKx2aXN1YWxCeVJlY29yZC5cbiAgICAgKiAgICAgICAgICAgICAgICDilJQhaGFzQnJ1c2hFeGlzdOKUmCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilJRub3RoaW5nLlxuICAgICAqICggYnJ1c2hlZCDilKwgJiYgICAgICAgICAgICAgICAgICAgICAhbGlua090aGVycyApID0+IFN0ZXBBOiAgbm90aGluZywgIFN0ZXBCOiDilKx2aXN1YWxCeUNoZWNrLlxuICAgICAqICAgIWJydXNoZWTilJggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilJRub3RoaW5nLlxuICAgICAqICggIWJydXNoZWQgICYmICAgICAgICAgICAgICAgICAgICAgIWxpbmtPdGhlcnMgKSA9PiBTdGVwQTogIG5vdGhpbmcsICBTdGVwQjogIG5vdGhpbmcuXG4gICAgICovXG4gICAgLy8gU3RlcCBBXG5cblxuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIHNlcmllc0luZGV4KSB7XG4gICAgICB2YXIgcmFuZ2VJbmZvTGlzdCA9IHJhbmdlSW5mb0J5U2VyaWVzW3Nlcmllc0luZGV4XSA9IFtdO1xuICAgICAgc2VyaWVzTW9kZWwuc3ViVHlwZSA9PT0gJ3BhcmFsbGVsJyA/IHN0ZXBBUGFyYWxsZWwoc2VyaWVzTW9kZWwsIHNlcmllc0luZGV4KSA6IHN0ZXBBT3RoZXJzKHNlcmllc01vZGVsLCBzZXJpZXNJbmRleCwgcmFuZ2VJbmZvTGlzdCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBzdGVwQVBhcmFsbGVsKHNlcmllc01vZGVsLCBzZXJpZXNJbmRleCkge1xuICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgIGhhc0JydXNoRXhpc3RzID0gaGFzQnJ1c2hFeGlzdHMgfHwgY29vcmRTeXMuaGFzQXhpc0JydXNoZWQoKTtcbiAgICAgIGxpbmtPdGhlcnMoc2VyaWVzSW5kZXgpICYmIGNvb3JkU3lzLmVhY2hBY3RpdmVTdGF0ZShzZXJpZXNNb2RlbC5nZXREYXRhKCksIGZ1bmN0aW9uIChhY3RpdmVTdGF0ZSwgZGF0YUluZGV4KSB7XG4gICAgICAgIGFjdGl2ZVN0YXRlID09PSAnYWN0aXZlJyAmJiAoc2VsZWN0ZWREYXRhSW5kZXhGb3JMaW5rW2RhdGFJbmRleF0gPSAxKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0ZXBBT3RoZXJzKHNlcmllc01vZGVsLCBzZXJpZXNJbmRleCwgcmFuZ2VJbmZvTGlzdCkge1xuICAgICAgaWYgKCFzZXJpZXNNb2RlbC5icnVzaFNlbGVjdG9yIHx8IGJydXNoTW9kZWxOb3RDb250cm9sbChicnVzaE1vZGVsLCBzZXJpZXNJbmRleCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB6clV0aWwuZWFjaChhcmVhcywgZnVuY3Rpb24gKGFyZWEpIHtcbiAgICAgICAgaWYgKGJydXNoTW9kZWwuYnJ1c2hUYXJnZXRNYW5hZ2VyLmNvbnRyb2xTZXJpZXMoYXJlYSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwpKSB7XG4gICAgICAgICAgcmFuZ2VJbmZvTGlzdC5wdXNoKGFyZWEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzQnJ1c2hFeGlzdHMgPSBoYXNCcnVzaEV4aXN0cyB8fCBicnVzaGVkKHJhbmdlSW5mb0xpc3QpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChsaW5rT3RoZXJzKHNlcmllc0luZGV4KSAmJiBicnVzaGVkKHJhbmdlSW5mb0xpc3QpKSB7XG4gICAgICAgIHZhciBkYXRhXzEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgIGRhdGFfMS5lYWNoKGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgICBpZiAoY2hlY2tJblJhbmdlKHNlcmllc01vZGVsLCByYW5nZUluZm9MaXN0LCBkYXRhXzEsIGRhdGFJbmRleCkpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkRGF0YUluZGV4Rm9yTGlua1tkYXRhSW5kZXhdID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gLy8gU3RlcCBCXG5cblxuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIHNlcmllc0luZGV4KSB7XG4gICAgICB2YXIgc2VyaWVzQnJ1c2hTZWxlY3RlZCA9IHtcbiAgICAgICAgc2VyaWVzSWQ6IHNlcmllc01vZGVsLmlkLFxuICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXgsXG4gICAgICAgIHNlcmllc05hbWU6IHNlcmllc01vZGVsLm5hbWUsXG4gICAgICAgIGRhdGFJbmRleDogW11cbiAgICAgIH07IC8vIEV2ZXJ5IHNlcmllcyBleGlzdHMgaW4gZXZlbnQgcGFyYW1zLCBjb252ZW5pZW50XG4gICAgICAvLyBmb3IgdXNlciB0byBmaW5kIHNlcmllcyBieSBzZXJpZXNJbmRleC5cblxuICAgICAgdGhpc0JydXNoU2VsZWN0ZWQuc2VsZWN0ZWQucHVzaChzZXJpZXNCcnVzaFNlbGVjdGVkKTtcbiAgICAgIHZhciByYW5nZUluZm9MaXN0ID0gcmFuZ2VJbmZvQnlTZXJpZXNbc2VyaWVzSW5kZXhdO1xuICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB2YXIgZ2V0VmFsdWVTdGF0ZSA9IGxpbmtPdGhlcnMoc2VyaWVzSW5kZXgpID8gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWREYXRhSW5kZXhGb3JMaW5rW2RhdGFJbmRleF0gPyAoc2VyaWVzQnJ1c2hTZWxlY3RlZC5kYXRhSW5kZXgucHVzaChkYXRhLmdldFJhd0luZGV4KGRhdGFJbmRleCkpLCAnaW5CcnVzaCcpIDogJ291dE9mQnJ1c2gnO1xuICAgICAgfSA6IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrSW5SYW5nZShzZXJpZXNNb2RlbCwgcmFuZ2VJbmZvTGlzdCwgZGF0YSwgZGF0YUluZGV4KSA/IChzZXJpZXNCcnVzaFNlbGVjdGVkLmRhdGFJbmRleC5wdXNoKGRhdGEuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KSksICdpbkJydXNoJykgOiAnb3V0T2ZCcnVzaCc7XG4gICAgICB9OyAvLyBJZiBubyBzdXBwb3J0ZWQgYnJ1c2ggb3Igbm8gYnJ1c2gsIGFsbCB2aXN1YWxzIGFyZSBpbiBvcmlnaW5hbCBzdGF0ZS5cblxuICAgICAgKGxpbmtPdGhlcnMoc2VyaWVzSW5kZXgpID8gaGFzQnJ1c2hFeGlzdHMgOiBicnVzaGVkKHJhbmdlSW5mb0xpc3QpKSAmJiB2aXN1YWxTb2x1dGlvbi5hcHBseVZpc3VhbChTVEFURV9MSVNULCB2aXN1YWxNYXBwaW5ncywgZGF0YSwgZ2V0VmFsdWVTdGF0ZSk7XG4gICAgfSk7XG4gIH0pO1xuICBkaXNwYXRjaEFjdGlvbihhcGksIHRocm90dGxlVHlwZSwgdGhyb3R0bGVEZWxheSwgYnJ1c2hTZWxlY3RlZCwgcGF5bG9hZCk7XG59XG47XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uKGFwaSwgdGhyb3R0bGVUeXBlLCB0aHJvdHRsZURlbGF5LCBicnVzaFNlbGVjdGVkLCBwYXlsb2FkKSB7XG4gIC8vIFRoaXMgZXZlbnQgd2lsbCBub3QgYmUgdHJpZ2dlcmVkIHdoZW4gYHNldE9waW9uYCwgb3RoZXJ3aXNlIGRlYWQgbG9jayBtYXlcbiAgLy8gdHJpZ2dlcmVkIHdoZW4gZG8gYHNldE9wdGlvbmAgaW4gZXZlbnQgbGlzdGVuZXIsIHdoaWNoIHdlIGRvIG5vdCBmaW5kXG4gIC8vIHNhdGlzZmFjdG9yeSB3YXkgdG8gc29sdmUgeWV0LiBTb21lIGNvbnNpZGVyZWQgcmVzb2x1dGlvbnM6XG4gIC8vIChhKSBEaWZmIHdpdGggcHJldm9pdXMgc2VsZWN0ZWQgZGF0YSBhbnQgb25seSB0cmlnZ2VyIGV2ZW50IHdoZW4gY2hhbmdlZC5cbiAgLy8gQnV0IHN0b3JlIHByZXZpb3VzIGRhdGEgYW5kIGRpZmYgcHJlY2lzZWx5IChpLmUuLCBub3Qgb25seSBieSBkYXRhSW5kZXgsIGJ1dFxuICAvLyBhbHNvIGRldGVjdCB2YWx1ZSBjaGFuZ2VzIGluIHNlbGVjdGVkIGRhdGEpIG1pZ2h0IGJyaW5nIGNvbXBsZXhpdHkgb3IgZnJhZ2lsaXR5LlxuICAvLyAoYikgVXNlIHNwZWN0aWFsIHBhcmFtIGxpa2UgYHNpbGVudGAgdG8gc3VwcHJlc3MgZXZlbnQgdHJpZ2dlcmluZy5cbiAgLy8gQnV0IHN1Y2gga2luZCBvZiB2b2xhdGlsZSBwYXJhbSBtYXkgYmUgd2VpcmQgaW4gYHNldE9wdGlvbmAuXG4gIGlmICghcGF5bG9hZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB6ciA9IGFwaS5nZXRacigpO1xuXG4gIGlmICh6cltESVNQQVRDSF9GTEFHXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghenJbRElTUEFUQ0hfTUVUSE9EXSkge1xuICAgIHpyW0RJU1BBVENIX01FVEhPRF0gPSBkb0Rpc3BhdGNoO1xuICB9XG5cbiAgdmFyIGZuID0gdGhyb3R0bGVVdGlsLmNyZWF0ZU9yVXBkYXRlKHpyLCBESVNQQVRDSF9NRVRIT0QsIHRocm90dGxlRGVsYXksIHRocm90dGxlVHlwZSk7XG4gIGZuKGFwaSwgYnJ1c2hTZWxlY3RlZCk7XG59XG5cbmZ1bmN0aW9uIGRvRGlzcGF0Y2goYXBpLCBicnVzaFNlbGVjdGVkKSB7XG4gIGlmICghYXBpLmlzRGlzcG9zZWQoKSkge1xuICAgIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICAgIHpyW0RJU1BBVENIX0ZMQUddID0gdHJ1ZTtcbiAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2JydXNoU2VsZWN0JyxcbiAgICAgIGJhdGNoOiBicnVzaFNlbGVjdGVkXG4gICAgfSk7XG4gICAgenJbRElTUEFUQ0hfRkxBR10gPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luUmFuZ2Uoc2VyaWVzTW9kZWwsIHJhbmdlSW5mb0xpc3QsIGRhdGEsIGRhdGFJbmRleCkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmFuZ2VJbmZvTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBhcmVhID0gcmFuZ2VJbmZvTGlzdFtpXTtcblxuICAgIGlmIChzZXJpZXNNb2RlbC5icnVzaFNlbGVjdG9yKGRhdGFJbmRleCwgZGF0YSwgYXJlYS5zZWxlY3RvcnMsIGFyZWEpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnJ1c2hNb2RlbE5vdENvbnRyb2xsKGJydXNoTW9kZWwsIHNlcmllc0luZGV4KSB7XG4gIHZhciBzZXJpZXNJbmRpY2VzID0gYnJ1c2hNb2RlbC5vcHRpb24uc2VyaWVzSW5kZXg7XG4gIHJldHVybiBzZXJpZXNJbmRpY2VzICE9IG51bGwgJiYgc2VyaWVzSW5kaWNlcyAhPT0gJ2FsbCcgJiYgKHpyVXRpbC5pc0FycmF5KHNlcmllc0luZGljZXMpID8genJVdGlsLmluZGV4T2Yoc2VyaWVzSW5kaWNlcywgc2VyaWVzSW5kZXgpIDwgMCA6IHNlcmllc0luZGV4ICE9PSBzZXJpZXNJbmRpY2VzKTtcbn1cblxudmFyIGJvdW5kaW5nUmVjdEJ1aWxkZXJzID0ge1xuICByZWN0OiBmdW5jdGlvbiAoYXJlYSkge1xuICAgIHJldHVybiBnZXRCb3VuZGluZ1JlY3RGcm9tTWluTWF4KGFyZWEucmFuZ2UpO1xuICB9LFxuICBwb2x5Z29uOiBmdW5jdGlvbiAoYXJlYSkge1xuICAgIHZhciBtaW5NYXg7XG4gICAgdmFyIHJhbmdlID0gYXJlYS5yYW5nZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByYW5nZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWluTWF4ID0gbWluTWF4IHx8IFtbSW5maW5pdHksIC1JbmZpbml0eV0sIFtJbmZpbml0eSwgLUluZmluaXR5XV07XG4gICAgICB2YXIgcmcgPSByYW5nZVtpXTtcbiAgICAgIHJnWzBdIDwgbWluTWF4WzBdWzBdICYmIChtaW5NYXhbMF1bMF0gPSByZ1swXSk7XG4gICAgICByZ1swXSA+IG1pbk1heFswXVsxXSAmJiAobWluTWF4WzBdWzFdID0gcmdbMF0pO1xuICAgICAgcmdbMV0gPCBtaW5NYXhbMV1bMF0gJiYgKG1pbk1heFsxXVswXSA9IHJnWzFdKTtcbiAgICAgIHJnWzFdID4gbWluTWF4WzFdWzFdICYmIChtaW5NYXhbMV1bMV0gPSByZ1sxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbk1heCAmJiBnZXRCb3VuZGluZ1JlY3RGcm9tTWluTWF4KG1pbk1heCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nUmVjdEZyb21NaW5NYXgobWluTWF4KSB7XG4gIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KG1pbk1heFswXVswXSwgbWluTWF4WzFdWzBdLCBtaW5NYXhbMF1bMV0gLSBtaW5NYXhbMF1bMF0sIG1pbk1heFsxXVsxXSAtIG1pbk1heFsxXVswXSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgeyBjcmVhdGVUZXh0U3R5bGUgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlJztcbmltcG9ydCAqIGFzIGZvcm1hdFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9mb3JtYXQnO1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG5pbXBvcnQgQ29tcG9uZW50VmlldyBmcm9tICcuLi8uLi92aWV3L0NvbXBvbmVudCc7XG52YXIgTU9OVEhfVEVYVCA9IHtcbiAgRU46IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcbiAgQ046IFsn5LiA5pyIJywgJ+S6jOaciCcsICfkuInmnIgnLCAn5Zub5pyIJywgJ+S6lOaciCcsICflha3mnIgnLCAn5LiD5pyIJywgJ+WFq+aciCcsICfkuZ3mnIgnLCAn5Y2B5pyIJywgJ+WNgeS4gOaciCcsICfljYHkuozmnIgnXVxufTtcbnZhciBXRUVLX1RFWFQgPSB7XG4gIEVOOiBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXSxcbiAgQ046IFsn5pelJywgJ+S4gCcsICfkuownLCAn5LiJJywgJ+WbmycsICfkupQnLCAn5YWtJ11cbn07XG5cbnZhciBDYWxlbmRhclZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ2FsZW5kYXJWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIENhbGVuZGFyVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBDYWxlbmRhclZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBDYWxlbmRhclZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjYWxlbmRhck1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHZhciBjb29yZFN5cyA9IGNhbGVuZGFyTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTsgLy8gcmFuZ2UgaW5mb1xuXG4gICAgdmFyIHJhbmdlRGF0YSA9IGNvb3JkU3lzLmdldFJhbmdlSW5mbygpO1xuICAgIHZhciBvcmllbnQgPSBjb29yZFN5cy5nZXRPcmllbnQoKTtcblxuICAgIHRoaXMuX3JlbmRlckRheVJlY3QoY2FsZW5kYXJNb2RlbCwgcmFuZ2VEYXRhLCBncm91cCk7IC8vIF9yZW5kZXJMaW5lcyBtdXN0IGJlIGNhbGxlZCBwcmlvciB0byBmb2xsb3dpbmcgZnVuY3Rpb25cblxuXG4gICAgdGhpcy5fcmVuZGVyTGluZXMoY2FsZW5kYXJNb2RlbCwgcmFuZ2VEYXRhLCBvcmllbnQsIGdyb3VwKTtcblxuICAgIHRoaXMuX3JlbmRlclllYXJUZXh0KGNhbGVuZGFyTW9kZWwsIHJhbmdlRGF0YSwgb3JpZW50LCBncm91cCk7XG5cbiAgICB0aGlzLl9yZW5kZXJNb250aFRleHQoY2FsZW5kYXJNb2RlbCwgb3JpZW50LCBncm91cCk7XG5cbiAgICB0aGlzLl9yZW5kZXJXZWVrVGV4dChjYWxlbmRhck1vZGVsLCByYW5nZURhdGEsIG9yaWVudCwgZ3JvdXApO1xuICB9OyAvLyByZW5kZXIgZGF5IHJlY3RcblxuXG4gIENhbGVuZGFyVmlldy5wcm90b3R5cGUuX3JlbmRlckRheVJlY3QgPSBmdW5jdGlvbiAoY2FsZW5kYXJNb2RlbCwgcmFuZ2VEYXRhLCBncm91cCkge1xuICAgIHZhciBjb29yZFN5cyA9IGNhbGVuZGFyTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgaXRlbVJlY3RTdHlsZU1vZGVsID0gY2FsZW5kYXJNb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJykuZ2V0SXRlbVN0eWxlKCk7XG4gICAgdmFyIHN3ID0gY29vcmRTeXMuZ2V0Q2VsbFdpZHRoKCk7XG4gICAgdmFyIHNoID0gY29vcmRTeXMuZ2V0Q2VsbEhlaWdodCgpO1xuXG4gICAgZm9yICh2YXIgaSA9IHJhbmdlRGF0YS5zdGFydC50aW1lOyBpIDw9IHJhbmdlRGF0YS5lbmQudGltZTsgaSA9IGNvb3JkU3lzLmdldE5leHRORGF5KGksIDEpLnRpbWUpIHtcbiAgICAgIHZhciBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1JlY3QoW2ldLCBmYWxzZSkudGw7IC8vIGV2ZXJ5IHJlY3RcblxuICAgICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICB4OiBwb2ludFswXSxcbiAgICAgICAgICB5OiBwb2ludFsxXSxcbiAgICAgICAgICB3aWR0aDogc3csXG4gICAgICAgICAgaGVpZ2h0OiBzaFxuICAgICAgICB9LFxuICAgICAgICBjdXJzb3I6ICdkZWZhdWx0JyxcbiAgICAgICAgc3R5bGU6IGl0ZW1SZWN0U3R5bGVNb2RlbFxuICAgICAgfSk7XG4gICAgICBncm91cC5hZGQocmVjdCk7XG4gICAgfVxuICB9OyAvLyByZW5kZXIgc2VwYXJhdGUgbGluZVxuXG5cbiAgQ2FsZW5kYXJWaWV3LnByb3RvdHlwZS5fcmVuZGVyTGluZXMgPSBmdW5jdGlvbiAoY2FsZW5kYXJNb2RlbCwgcmFuZ2VEYXRhLCBvcmllbnQsIGdyb3VwKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb29yZFN5cyA9IGNhbGVuZGFyTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgbGluZVN0eWxlTW9kZWwgPSBjYWxlbmRhck1vZGVsLmdldE1vZGVsKFsnc3BsaXRMaW5lJywgJ2xpbmVTdHlsZSddKS5nZXRMaW5lU3R5bGUoKTtcbiAgICB2YXIgc2hvdyA9IGNhbGVuZGFyTW9kZWwuZ2V0KFsnc3BsaXRMaW5lJywgJ3Nob3cnXSk7XG4gICAgdmFyIGxpbmVXaWR0aCA9IGxpbmVTdHlsZU1vZGVsLmxpbmVXaWR0aDtcbiAgICB0aGlzLl90bHBvaW50cyA9IFtdO1xuICAgIHRoaXMuX2JscG9pbnRzID0gW107XG4gICAgdGhpcy5fZmlyc3REYXlPZk1vbnRoID0gW107XG4gICAgdGhpcy5fZmlyc3REYXlQb2ludHMgPSBbXTtcbiAgICB2YXIgZmlyc3REYXkgPSByYW5nZURhdGEuc3RhcnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgZmlyc3REYXkudGltZSA8PSByYW5nZURhdGEuZW5kLnRpbWU7IGkrKykge1xuICAgICAgYWRkUG9pbnRzKGZpcnN0RGF5LmZvcm1hdGVkRGF0ZSk7XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGZpcnN0RGF5ID0gY29vcmRTeXMuZ2V0RGF0ZUluZm8ocmFuZ2VEYXRhLnN0YXJ0LnkgKyAnLScgKyByYW5nZURhdGEuc3RhcnQubSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRlID0gZmlyc3REYXkuZGF0ZTtcbiAgICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgMSk7XG4gICAgICBmaXJzdERheSA9IGNvb3JkU3lzLmdldERhdGVJbmZvKGRhdGUpO1xuICAgIH1cblxuICAgIGFkZFBvaW50cyhjb29yZFN5cy5nZXROZXh0TkRheShyYW5nZURhdGEuZW5kLnRpbWUsIDEpLmZvcm1hdGVkRGF0ZSk7XG5cbiAgICBmdW5jdGlvbiBhZGRQb2ludHMoZGF0ZSkge1xuICAgICAgc2VsZi5fZmlyc3REYXlPZk1vbnRoLnB1c2goY29vcmRTeXMuZ2V0RGF0ZUluZm8oZGF0ZSkpO1xuXG4gICAgICBzZWxmLl9maXJzdERheVBvaW50cy5wdXNoKGNvb3JkU3lzLmRhdGFUb1JlY3QoW2RhdGVdLCBmYWxzZSkudGwpO1xuXG4gICAgICB2YXIgcG9pbnRzID0gc2VsZi5fZ2V0TGluZVBvaW50c09mT25lV2VlayhjYWxlbmRhck1vZGVsLCBkYXRlLCBvcmllbnQpO1xuXG4gICAgICBzZWxmLl90bHBvaW50cy5wdXNoKHBvaW50c1swXSk7XG5cbiAgICAgIHNlbGYuX2JscG9pbnRzLnB1c2gocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XG5cbiAgICAgIHNob3cgJiYgc2VsZi5fZHJhd1NwbGl0bGluZShwb2ludHMsIGxpbmVTdHlsZU1vZGVsLCBncm91cCk7XG4gICAgfSAvLyByZW5kZXIgdG9wL2xlZnQgbGluZVxuXG5cbiAgICBzaG93ICYmIHRoaXMuX2RyYXdTcGxpdGxpbmUoc2VsZi5fZ2V0RWRnZXNQb2ludHMoc2VsZi5fdGxwb2ludHMsIGxpbmVXaWR0aCwgb3JpZW50KSwgbGluZVN0eWxlTW9kZWwsIGdyb3VwKTsgLy8gcmVuZGVyIGJvdHRvbS9yaWdodCBsaW5lXG5cbiAgICBzaG93ICYmIHRoaXMuX2RyYXdTcGxpdGxpbmUoc2VsZi5fZ2V0RWRnZXNQb2ludHMoc2VsZi5fYmxwb2ludHMsIGxpbmVXaWR0aCwgb3JpZW50KSwgbGluZVN0eWxlTW9kZWwsIGdyb3VwKTtcbiAgfTsgLy8gZ2V0IHBvaW50cyBhdCBib3RoIGVuZHNcblxuXG4gIENhbGVuZGFyVmlldy5wcm90b3R5cGUuX2dldEVkZ2VzUG9pbnRzID0gZnVuY3Rpb24gKHBvaW50cywgbGluZVdpZHRoLCBvcmllbnQpIHtcbiAgICB2YXIgcnMgPSBbcG9pbnRzWzBdLnNsaWNlKCksIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0uc2xpY2UoKV07XG4gICAgdmFyIGlkeCA9IG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gMCA6IDE7IC8vIGJvdGggZW5kcyBvZiB0aGUgbGluZSBhcmUgZXh0ZW5kIGhhbGYgbGluZVdpZHRoXG5cbiAgICByc1swXVtpZHhdID0gcnNbMF1baWR4XSAtIGxpbmVXaWR0aCAvIDI7XG4gICAgcnNbMV1baWR4XSA9IHJzWzFdW2lkeF0gKyBsaW5lV2lkdGggLyAyO1xuICAgIHJldHVybiBycztcbiAgfTsgLy8gcmVuZGVyIHNwbGl0IGxpbmVcblxuXG4gIENhbGVuZGFyVmlldy5wcm90b3R5cGUuX2RyYXdTcGxpdGxpbmUgPSBmdW5jdGlvbiAocG9pbnRzLCBsaW5lU3R5bGUsIGdyb3VwKSB7XG4gICAgdmFyIHBveWxpbmUgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSh7XG4gICAgICB6MjogMjAsXG4gICAgICBzaGFwZToge1xuICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiBsaW5lU3R5bGVcbiAgICB9KTtcbiAgICBncm91cC5hZGQocG95bGluZSk7XG4gIH07IC8vIHJlbmRlciBtb250aCBsaW5lIG9mIG9uZSB3ZWVrIHBvaW50c1xuXG5cbiAgQ2FsZW5kYXJWaWV3LnByb3RvdHlwZS5fZ2V0TGluZVBvaW50c09mT25lV2VlayA9IGZ1bmN0aW9uIChjYWxlbmRhck1vZGVsLCBkYXRlLCBvcmllbnQpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBjYWxlbmRhck1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIHBhcnNlZERhdGUgPSBjb29yZFN5cy5nZXREYXRlSW5mbyhkYXRlKTtcbiAgICB2YXIgcG9pbnRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgdmFyIHRtcEQgPSBjb29yZFN5cy5nZXROZXh0TkRheShwYXJzZWREYXRlLnRpbWUsIGkpO1xuICAgICAgdmFyIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUmVjdChbdG1wRC50aW1lXSwgZmFsc2UpO1xuICAgICAgcG9pbnRzWzIgKiB0bXBELmRheV0gPSBwb2ludC50bDtcbiAgICAgIHBvaW50c1syICogdG1wRC5kYXkgKyAxXSA9IHBvaW50W29yaWVudCA9PT0gJ2hvcml6b250YWwnID8gJ2JsJyA6ICd0ciddO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludHM7XG4gIH07XG5cbiAgQ2FsZW5kYXJWaWV3LnByb3RvdHlwZS5fZm9ybWF0dGVyTGFiZWwgPSBmdW5jdGlvbiAoZm9ybWF0dGVyLCBwYXJhbXMpIHtcbiAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycgJiYgZm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gZm9ybWF0VXRpbC5mb3JtYXRUcGxTaW1wbGUoZm9ybWF0dGVyLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyKHBhcmFtcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcy5uYW1lTWFwO1xuICB9O1xuXG4gIENhbGVuZGFyVmlldy5wcm90b3R5cGUuX3llYXJUZXh0UG9zaXRpb25Db250cm9sID0gZnVuY3Rpb24gKHRleHRFbCwgcG9pbnQsIG9yaWVudCwgcG9zaXRpb24sIG1hcmdpbikge1xuICAgIHZhciB4ID0gcG9pbnRbMF07XG4gICAgdmFyIHkgPSBwb2ludFsxXTtcbiAgICB2YXIgYWxpZ25zID0gWydjZW50ZXInLCAnYm90dG9tJ107XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICB5ICs9IG1hcmdpbjtcbiAgICAgIGFsaWducyA9IFsnY2VudGVyJywgJ3RvcCddO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgeCAtPSBtYXJnaW47XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgeCArPSBtYXJnaW47XG4gICAgICBhbGlnbnMgPSBbJ2NlbnRlcicsICd0b3AnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdG9wXG4gICAgICB5IC09IG1hcmdpbjtcbiAgICB9XG5cbiAgICB2YXIgcm90YXRlID0gMDtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICByb3RhdGUgPSBNYXRoLlBJIC8gMjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRpb246IHJvdGF0ZSxcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYWxpZ246IGFsaWduc1swXSxcbiAgICAgICAgdmVydGljYWxBbGlnbjogYWxpZ25zWzFdXG4gICAgICB9XG4gICAgfTtcbiAgfTsgLy8gcmVuZGVyIHllYXJcblxuXG4gIENhbGVuZGFyVmlldy5wcm90b3R5cGUuX3JlbmRlclllYXJUZXh0ID0gZnVuY3Rpb24gKGNhbGVuZGFyTW9kZWwsIHJhbmdlRGF0YSwgb3JpZW50LCBncm91cCkge1xuICAgIHZhciB5ZWFyTGFiZWwgPSBjYWxlbmRhck1vZGVsLmdldE1vZGVsKCd5ZWFyTGFiZWwnKTtcblxuICAgIGlmICgheWVhckxhYmVsLmdldCgnc2hvdycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1hcmdpbiA9IHllYXJMYWJlbC5nZXQoJ21hcmdpbicpO1xuICAgIHZhciBwb3MgPSB5ZWFyTGFiZWwuZ2V0KCdwb3NpdGlvbicpO1xuXG4gICAgaWYgKCFwb3MpIHtcbiAgICAgIHBvcyA9IG9yaWVudCAhPT0gJ2hvcml6b250YWwnID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgfVxuXG4gICAgdmFyIHBvaW50cyA9IFt0aGlzLl90bHBvaW50c1t0aGlzLl90bHBvaW50cy5sZW5ndGggLSAxXSwgdGhpcy5fYmxwb2ludHNbMF1dO1xuICAgIHZhciB4YyA9IChwb2ludHNbMF1bMF0gKyBwb2ludHNbMV1bMF0pIC8gMjtcbiAgICB2YXIgeWMgPSAocG9pbnRzWzBdWzFdICsgcG9pbnRzWzFdWzFdKSAvIDI7XG4gICAgdmFyIGlkeCA9IG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gMCA6IDE7XG4gICAgdmFyIHBvc1BvaW50cyA9IHtcbiAgICAgIHRvcDogW3hjLCBwb2ludHNbaWR4XVsxXV0sXG4gICAgICBib3R0b206IFt4YywgcG9pbnRzWzEgLSBpZHhdWzFdXSxcbiAgICAgIGxlZnQ6IFtwb2ludHNbMSAtIGlkeF1bMF0sIHljXSxcbiAgICAgIHJpZ2h0OiBbcG9pbnRzW2lkeF1bMF0sIHljXVxuICAgIH07XG4gICAgdmFyIG5hbWUgPSByYW5nZURhdGEuc3RhcnQueTtcblxuICAgIGlmICgrcmFuZ2VEYXRhLmVuZC55ID4gK3JhbmdlRGF0YS5zdGFydC55KSB7XG4gICAgICBuYW1lID0gbmFtZSArICctJyArIHJhbmdlRGF0YS5lbmQueTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGVyID0geWVhckxhYmVsLmdldCgnZm9ybWF0dGVyJyk7XG4gICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgIHN0YXJ0OiByYW5nZURhdGEuc3RhcnQueSxcbiAgICAgIGVuZDogcmFuZ2VEYXRhLmVuZC55LFxuICAgICAgbmFtZU1hcDogbmFtZVxuICAgIH07XG5cbiAgICB2YXIgY29udGVudCA9IHRoaXMuX2Zvcm1hdHRlckxhYmVsKGZvcm1hdHRlciwgcGFyYW1zKTtcblxuICAgIHZhciB5ZWFyVGV4dCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgejI6IDMwLFxuICAgICAgc3R5bGU6IGNyZWF0ZVRleHRTdHlsZSh5ZWFyTGFiZWwsIHtcbiAgICAgICAgdGV4dDogY29udGVudFxuICAgICAgfSlcbiAgICB9KTtcbiAgICB5ZWFyVGV4dC5hdHRyKHRoaXMuX3llYXJUZXh0UG9zaXRpb25Db250cm9sKHllYXJUZXh0LCBwb3NQb2ludHNbcG9zXSwgb3JpZW50LCBwb3MsIG1hcmdpbikpO1xuICAgIGdyb3VwLmFkZCh5ZWFyVGV4dCk7XG4gIH07XG5cbiAgQ2FsZW5kYXJWaWV3LnByb3RvdHlwZS5fbW9udGhUZXh0UG9zaXRpb25Db250cm9sID0gZnVuY3Rpb24gKHBvaW50LCBpc0NlbnRlciwgb3JpZW50LCBwb3NpdGlvbiwgbWFyZ2luKSB7XG4gICAgdmFyIGFsaWduID0gJ2xlZnQnO1xuICAgIHZhciB2QWxpZ24gPSAndG9wJztcbiAgICB2YXIgeCA9IHBvaW50WzBdO1xuICAgIHZhciB5ID0gcG9pbnRbMV07XG5cbiAgICBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgIHkgPSB5ICsgbWFyZ2luO1xuXG4gICAgICBpZiAoaXNDZW50ZXIpIHtcbiAgICAgICAgYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc2l0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHZBbGlnbiA9ICdib3R0b20nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geCArIG1hcmdpbjtcblxuICAgICAgaWYgKGlzQ2VudGVyKSB7XG4gICAgICAgIHZBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zaXRpb24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgYWxpZ24gPSAncmlnaHQnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgIHZlcnRpY2FsQWxpZ246IHZBbGlnblxuICAgIH07XG4gIH07IC8vIHJlbmRlciBtb250aCBhbmQgeWVhciB0ZXh0XG5cblxuICBDYWxlbmRhclZpZXcucHJvdG90eXBlLl9yZW5kZXJNb250aFRleHQgPSBmdW5jdGlvbiAoY2FsZW5kYXJNb2RlbCwgb3JpZW50LCBncm91cCkge1xuICAgIHZhciBtb250aExhYmVsID0gY2FsZW5kYXJNb2RlbC5nZXRNb2RlbCgnbW9udGhMYWJlbCcpO1xuXG4gICAgaWYgKCFtb250aExhYmVsLmdldCgnc2hvdycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5hbWVNYXAgPSBtb250aExhYmVsLmdldCgnbmFtZU1hcCcpO1xuICAgIHZhciBtYXJnaW4gPSBtb250aExhYmVsLmdldCgnbWFyZ2luJyk7XG4gICAgdmFyIHBvcyA9IG1vbnRoTGFiZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgIHZhciBhbGlnbiA9IG1vbnRoTGFiZWwuZ2V0KCdhbGlnbicpO1xuICAgIHZhciB0ZXJtUG9pbnRzID0gW3RoaXMuX3RscG9pbnRzLCB0aGlzLl9ibHBvaW50c107XG5cbiAgICBpZiAoenJVdGlsLmlzU3RyaW5nKG5hbWVNYXApKSB7XG4gICAgICBuYW1lTWFwID0gTU9OVEhfVEVYVFtuYW1lTWFwLnRvVXBwZXJDYXNlKCldIHx8IFtdO1xuICAgIH1cblxuICAgIHZhciBpZHggPSBwb3MgPT09ICdzdGFydCcgPyAwIDogMTtcbiAgICB2YXIgYXhpcyA9IG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gMCA6IDE7XG4gICAgbWFyZ2luID0gcG9zID09PSAnc3RhcnQnID8gLW1hcmdpbiA6IG1hcmdpbjtcbiAgICB2YXIgaXNDZW50ZXIgPSBhbGlnbiA9PT0gJ2NlbnRlcic7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlcm1Qb2ludHNbaWR4XS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciB0bXAgPSB0ZXJtUG9pbnRzW2lkeF1baV0uc2xpY2UoKTtcbiAgICAgIHZhciBmaXJzdERheSA9IHRoaXMuX2ZpcnN0RGF5T2ZNb250aFtpXTtcblxuICAgICAgaWYgKGlzQ2VudGVyKSB7XG4gICAgICAgIHZhciBmaXJzdERheVBvaW50cyA9IHRoaXMuX2ZpcnN0RGF5UG9pbnRzW2ldO1xuICAgICAgICB0bXBbYXhpc10gPSAoZmlyc3REYXlQb2ludHNbYXhpc10gKyB0ZXJtUG9pbnRzWzBdW2kgKyAxXVtheGlzXSkgLyAyO1xuICAgICAgfVxuXG4gICAgICB2YXIgZm9ybWF0dGVyID0gbW9udGhMYWJlbC5nZXQoJ2Zvcm1hdHRlcicpO1xuICAgICAgdmFyIG5hbWVfMSA9IG5hbWVNYXBbK2ZpcnN0RGF5Lm0gLSAxXTtcbiAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgIHl5eXk6IGZpcnN0RGF5LnksXG4gICAgICAgIHl5OiAoZmlyc3REYXkueSArICcnKS5zbGljZSgyKSxcbiAgICAgICAgTU06IGZpcnN0RGF5Lm0sXG4gICAgICAgIE06ICtmaXJzdERheS5tLFxuICAgICAgICBuYW1lTWFwOiBuYW1lXzFcbiAgICAgIH07XG5cbiAgICAgIHZhciBjb250ZW50ID0gdGhpcy5fZm9ybWF0dGVyTGFiZWwoZm9ybWF0dGVyLCBwYXJhbXMpO1xuXG4gICAgICB2YXIgbW9udGhUZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgIHoyOiAzMCxcbiAgICAgICAgc3R5bGU6IHpyVXRpbC5leHRlbmQoY3JlYXRlVGV4dFN0eWxlKG1vbnRoTGFiZWwsIHtcbiAgICAgICAgICB0ZXh0OiBjb250ZW50XG4gICAgICAgIH0pLCB0aGlzLl9tb250aFRleHRQb3NpdGlvbkNvbnRyb2wodG1wLCBpc0NlbnRlciwgb3JpZW50LCBwb3MsIG1hcmdpbikpXG4gICAgICB9KTtcbiAgICAgIGdyb3VwLmFkZChtb250aFRleHQpO1xuICAgIH1cbiAgfTtcblxuICBDYWxlbmRhclZpZXcucHJvdG90eXBlLl93ZWVrVGV4dFBvc2l0aW9uQ29udHJvbCA9IGZ1bmN0aW9uIChwb2ludCwgb3JpZW50LCBwb3NpdGlvbiwgbWFyZ2luLCBjZWxsU2l6ZSkge1xuICAgIHZhciBhbGlnbiA9ICdjZW50ZXInO1xuICAgIHZhciB2QWxpZ24gPSAnbWlkZGxlJztcbiAgICB2YXIgeCA9IHBvaW50WzBdO1xuICAgIHZhciB5ID0gcG9pbnRbMV07XG4gICAgdmFyIGlzU3RhcnQgPSBwb3NpdGlvbiA9PT0gJ3N0YXJ0JztcblxuICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgeCA9IHggKyBtYXJnaW4gKyAoaXNTdGFydCA/IDEgOiAtMSkgKiBjZWxsU2l6ZVswXSAvIDI7XG4gICAgICBhbGlnbiA9IGlzU3RhcnQgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICB5ID0geSArIG1hcmdpbiArIChpc1N0YXJ0ID8gMSA6IC0xKSAqIGNlbGxTaXplWzFdIC8gMjtcbiAgICAgIHZBbGlnbiA9IGlzU3RhcnQgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgIHZlcnRpY2FsQWxpZ246IHZBbGlnblxuICAgIH07XG4gIH07IC8vIHJlbmRlciB3ZWVrc1xuXG5cbiAgQ2FsZW5kYXJWaWV3LnByb3RvdHlwZS5fcmVuZGVyV2Vla1RleHQgPSBmdW5jdGlvbiAoY2FsZW5kYXJNb2RlbCwgcmFuZ2VEYXRhLCBvcmllbnQsIGdyb3VwKSB7XG4gICAgdmFyIGRheUxhYmVsID0gY2FsZW5kYXJNb2RlbC5nZXRNb2RlbCgnZGF5TGFiZWwnKTtcblxuICAgIGlmICghZGF5TGFiZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29vcmRTeXMgPSBjYWxlbmRhck1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIHBvcyA9IGRheUxhYmVsLmdldCgncG9zaXRpb24nKTtcbiAgICB2YXIgbmFtZU1hcCA9IGRheUxhYmVsLmdldCgnbmFtZU1hcCcpO1xuICAgIHZhciBtYXJnaW4gPSBkYXlMYWJlbC5nZXQoJ21hcmdpbicpO1xuICAgIHZhciBmaXJzdERheU9mV2VlayA9IGNvb3JkU3lzLmdldEZpcnN0RGF5T2ZXZWVrKCk7XG5cbiAgICBpZiAoenJVdGlsLmlzU3RyaW5nKG5hbWVNYXApKSB7XG4gICAgICBuYW1lTWFwID0gV0VFS19URVhUW25hbWVNYXAudG9VcHBlckNhc2UoKV0gfHwgW107XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gY29vcmRTeXMuZ2V0TmV4dE5EYXkocmFuZ2VEYXRhLmVuZC50aW1lLCA3IC0gcmFuZ2VEYXRhLmx3ZWVrKS50aW1lO1xuICAgIHZhciBjZWxsU2l6ZSA9IFtjb29yZFN5cy5nZXRDZWxsV2lkdGgoKSwgY29vcmRTeXMuZ2V0Q2VsbEhlaWdodCgpXTtcbiAgICBtYXJnaW4gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChtYXJnaW4sIGNlbGxTaXplW29yaWVudCA9PT0gJ2hvcml6b250YWwnID8gMCA6IDFdKTtcblxuICAgIGlmIChwb3MgPT09ICdzdGFydCcpIHtcbiAgICAgIHN0YXJ0ID0gY29vcmRTeXMuZ2V0TmV4dE5EYXkocmFuZ2VEYXRhLnN0YXJ0LnRpbWUsIC0oNyArIHJhbmdlRGF0YS5md2VlaykpLnRpbWU7XG4gICAgICBtYXJnaW4gPSAtbWFyZ2luO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICB2YXIgdG1wRCA9IGNvb3JkU3lzLmdldE5leHRORGF5KHN0YXJ0LCBpKTtcbiAgICAgIHZhciBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1JlY3QoW3RtcEQudGltZV0sIGZhbHNlKS5jZW50ZXI7XG4gICAgICB2YXIgZGF5ID0gaTtcbiAgICAgIGRheSA9IE1hdGguYWJzKChpICsgZmlyc3REYXlPZldlZWspICUgNyk7XG4gICAgICB2YXIgd2Vla1RleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgejI6IDMwLFxuICAgICAgICBzdHlsZTogenJVdGlsLmV4dGVuZChjcmVhdGVUZXh0U3R5bGUoZGF5TGFiZWwsIHtcbiAgICAgICAgICB0ZXh0OiBuYW1lTWFwW2RheV1cbiAgICAgICAgfSksIHRoaXMuX3dlZWtUZXh0UG9zaXRpb25Db250cm9sKHBvaW50LCBvcmllbnQsIHBvcywgbWFyZ2luLCBjZWxsU2l6ZSkpXG4gICAgICB9KTtcbiAgICAgIGdyb3VwLmFkZCh3ZWVrVGV4dCk7XG4gICAgfVxuICB9O1xuXG4gIENhbGVuZGFyVmlldy50eXBlID0gJ2NhbGVuZGFyJztcbiAgcmV0dXJuIENhbGVuZGFyVmlldztcbn0oQ29tcG9uZW50Vmlldyk7XG5cbmV4cG9ydCBkZWZhdWx0IENhbGVuZGFyVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IENhbGVuZGFyTW9kZWwgZnJvbSAnLi4vLi4vY29vcmQvY2FsZW5kYXIvQ2FsZW5kYXJNb2RlbCc7XG5pbXBvcnQgQ2FsZW5kYXJWaWV3IGZyb20gJy4vQ2FsZW5kYXJWaWV3JztcbmltcG9ydCBDYWxlbmRhciBmcm9tICcuLi8uLi9jb29yZC9jYWxlbmRhci9DYWxlbmRhcic7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50TW9kZWwoQ2FsZW5kYXJNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoQ2FsZW5kYXJWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29vcmRpbmF0ZVN5c3RlbSgnY2FsZW5kYXInLCBDYWxlbmRhcik7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG5pbXBvcnQgc2xpZGVyTW92ZSBmcm9tICcuLi9oZWxwZXIvc2xpZGVyTW92ZSc7XG5pbXBvcnQgeyB1bmlvbkF4aXNFeHRlbnRGcm9tRGF0YSB9IGZyb20gJy4uLy4uL2Nvb3JkL2F4aXNIZWxwZXInO1xuaW1wb3J0IHsgZW5zdXJlU2NhbGVSYXdFeHRlbnRJbmZvIH0gZnJvbSAnLi4vLi4vY29vcmQvc2NhbGVSYXdFeHRlbnRJbmZvJztcbmltcG9ydCB7IGdldEF4aXNNYWluVHlwZSwgaXNDb29yZFN1cHBvcnRlZCB9IGZyb20gJy4vaGVscGVyJztcbmltcG9ydCB7IFNJTkdMRV9SRUZFUlJJTkcgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgYXNjID0gbnVtYmVyVXRpbC5hc2M7XG4vKipcbiAqIE9wZXJhdGUgc2luZ2xlIGF4aXMuXG4gKiBPbmUgYXhpcyBjYW4gb25seSBvcGVyYXRlZCBieSBvbmUgYXhpcyBvcGVyYXRvci5cbiAqIERpZmZlcmVudCBkYXRhWm9vbU1vZGVscyBtYXkgYmUgZGVmaW5lZCB0byBvcGVyYXRlIHRoZSBzYW1lIGF4aXMuXG4gKiAoaS5lLiAnaW5zaWRlJyBkYXRhIHpvb20gYW5kICdzbGlkZXInIGRhdGEgem9vbSBjb21wb25lbnRzKVxuICogU28gZGF0YVpvb21Nb2RlbHMgc2hhcmUgb25lIGF4aXNQcm94eSBpbiB0aGF0IGNhc2UuXG4gKi9cblxudmFyIEF4aXNQcm94eSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF4aXNQcm94eShkaW1OYW1lLCBheGlzSW5kZXgsIGRhdGFab29tTW9kZWwsIGVjTW9kZWwpIHtcbiAgICB0aGlzLl9kaW1OYW1lID0gZGltTmFtZTtcbiAgICB0aGlzLl9heGlzSW5kZXggPSBheGlzSW5kZXg7XG4gICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgICB0aGlzLl9kYXRhWm9vbU1vZGVsID0gZGF0YVpvb21Nb2RlbDsgLy8gLyoqXG4gICAgLy8gICogQHJlYWRPbmx5XG4gICAgLy8gICogQHByaXZhdGVcbiAgICAvLyAgKi9cbiAgICAvLyB0aGlzLmhhc1Nlcmllc1N0YWNrZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGF4aXNQcm94eSBpcyBob3N0ZWQgYnkgZGF0YVpvb21Nb2RlbC5cbiAgICovXG5cblxuICBBeGlzUHJveHkucHJvdG90eXBlLmhvc3RlZEJ5ID0gZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVpvb21Nb2RlbCA9PT0gZGF0YVpvb21Nb2RlbDtcbiAgfTtcbiAgLyoqXG4gICAqIEByZXR1cm4gVmFsdWUgY2FuIG9ubHkgYmUgTmFOIG9yIGZpbml0ZSB2YWx1ZS5cbiAgICovXG5cblxuICBBeGlzUHJveHkucHJvdG90eXBlLmdldERhdGFWYWx1ZVdpbmRvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVXaW5kb3cuc2xpY2UoKTtcbiAgfTtcbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cblxuXG4gIEF4aXNQcm94eS5wcm90b3R5cGUuZ2V0RGF0YVBlcmNlbnRXaW5kb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlcmNlbnRXaW5kb3cuc2xpY2UoKTtcbiAgfTtcblxuICBBeGlzUHJveHkucHJvdG90eXBlLmdldFRhcmdldFNlcmllc01vZGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VyaWVzTW9kZWxzID0gW107XG4gICAgdGhpcy5lY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICBpZiAoaXNDb29yZFN1cHBvcnRlZChzZXJpZXNNb2RlbCkpIHtcbiAgICAgICAgdmFyIGF4aXNNYWluVHlwZSA9IGdldEF4aXNNYWluVHlwZSh0aGlzLl9kaW1OYW1lKTtcbiAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoYXhpc01haW5UeXBlLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG5cbiAgICAgICAgaWYgKGF4aXNNb2RlbCAmJiB0aGlzLl9heGlzSW5kZXggPT09IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleCkge1xuICAgICAgICAgIHNlcmllc01vZGVscy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBzZXJpZXNNb2RlbHM7XG4gIH07XG5cbiAgQXhpc1Byb3h5LnByb3RvdHlwZS5nZXRBeGlzTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWNNb2RlbC5nZXRDb21wb25lbnQodGhpcy5fZGltTmFtZSArICdBeGlzJywgdGhpcy5fYXhpc0luZGV4KTtcbiAgfTtcblxuICBBeGlzUHJveHkucHJvdG90eXBlLmdldE1pbk1heFNwYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHpyVXRpbC5jbG9uZSh0aGlzLl9taW5NYXhTcGFuKTtcbiAgfTtcbiAgLyoqXG4gICAqIE9ubHkgY2FsY3VsYXRlIGJ5IGdpdmVuIHJhbmdlIGFuZCB0aGlzLl9kYXRhRXh0ZW50LCBkbyBub3QgY2hhbmdlIGFueXRoaW5nLlxuICAgKi9cblxuXG4gIEF4aXNQcm94eS5wcm90b3R5cGUuY2FsY3VsYXRlRGF0YVdpbmRvdyA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgZGF0YUV4dGVudCA9IHRoaXMuX2RhdGFFeHRlbnQ7XG4gICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuZ2V0QXhpc01vZGVsKCk7XG4gICAgdmFyIHNjYWxlID0gYXhpc01vZGVsLmF4aXMuc2NhbGU7XG5cbiAgICB2YXIgcmFuZ2VQcm9wTW9kZSA9IHRoaXMuX2RhdGFab29tTW9kZWwuZ2V0UmFuZ2VQcm9wTW9kZSgpO1xuXG4gICAgdmFyIHBlcmNlbnRFeHRlbnQgPSBbMCwgMTAwXTtcbiAgICB2YXIgcGVyY2VudFdpbmRvdyA9IFtdO1xuICAgIHZhciB2YWx1ZVdpbmRvdyA9IFtdO1xuICAgIHZhciBoYXNQcm9wTW9kZVZhbHVlO1xuICAgIGVhY2goWydzdGFydCcsICdlbmQnXSwgZnVuY3Rpb24gKHByb3AsIGlkeCkge1xuICAgICAgdmFyIGJvdW5kUGVyY2VudCA9IG9wdFtwcm9wXTtcbiAgICAgIHZhciBib3VuZFZhbHVlID0gb3B0W3Byb3AgKyAnVmFsdWUnXTsgLy8gTm90aWNlOiBkYXRhWm9vbSBpcyBiYXNlZCBlaXRoZXIgb24gYHBlcmNlbnRQcm9wYCAoJ3N0YXJ0JywgJ2VuZCcpIG9yXG4gICAgICAvLyBvbiBgdmFsdWVQcm9wYCAoJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnKS4gKFRoZXkgYXJlIGJhc2VkIG9uIHRoZSBkYXRhIGV4dGVudFxuICAgICAgLy8gYnV0IG5vdCBtaW4vbWF4IG9mIGF4aXMsIHdoaWNoIHdpbGwgYmUgY2FsY3VsYXRlZCBieSBkYXRhIHdpbmRvdyB0aGVuKS5cbiAgICAgIC8vIFRoZSBmb3JtZXIgb25lIGlzIHN1aXRhYmxlIGZvciBjYXNlcyB0aGF0IGEgZGF0YVpvb20gY29tcG9uZW50IGNvbnRyb2xzIG11bHRpcGxlXG4gICAgICAvLyBheGVzIHdpdGggZGlmZmVyZW50IHVuaXQgb3IgZXh0ZW50LCBhbmQgdGhlIGxhdHRlciBvbmUgaXMgc3VpdGFibGUgZm9yIGFjY3VyYXRlXG4gICAgICAvLyB6b29tIGJ5IHBpeGVsIChlLmcuLCBpbiBkYXRhWm9vbVNlbGVjdCkuXG4gICAgICAvLyB3ZSB1c2UgYGdldFJhbmdlUHJvcE1vZGUoKWAgdG8gbWFyayB3aGljaCBwcm9wIGlzIHVzZWQuIGByYW5nZVByb3BNb2RlYCBpcyB1cGRhdGVkXG4gICAgICAvLyBvbmx5IHdoZW4gc2V0T3B0aW9uIG9yIGRpc3BhdGNoQWN0aW9uLCBvdGhlcndpc2UgaXQgcmVtYWlucyBpdHMgb3JpZ2luYWwgdmFsdWUuXG4gICAgICAvLyAoV2h5IG5vdCBvbmx5IHJlY29yZCBgcGVyY2VudFByb3BgIGFuZCBhbHdheXMgbWFwIHRvIGB2YWx1ZVByb3BgPyBCZWNhdXNlXG4gICAgICAvLyB0aGUgbWFwIGB2YWx1ZVByb3BgIC0+IGBwZXJjZW50UHJvcGAgLT4gYHZhbHVlUHJvcGAgcHJvYmFibHkgbm90IHRoZSBvcmlnaW5hbFxuICAgICAgLy8gYHZhbHVlUHJvcGAuIGNvbnNpZGVyIHR3byBheGVzIGNvbnN0cm9sbGVkIGJ5IG9uZSBkYXRhWm9vbS4gVGhleSBoYXZlIGRpZmZlcmVudFxuICAgICAgLy8gZGF0YSBleHRlbnQuIEFsbCBvZiB2YWx1ZXMgdGhhdCBhcmUgb3ZlcmZsb3cgdGhlIGBkYXRhRXh0ZW50YCB3aWxsIGJlIGNhbGN1bGF0ZWRcbiAgICAgIC8vIHRvIHBlcmNlbnQgJzEwMCUnKS5cblxuICAgICAgaWYgKHJhbmdlUHJvcE1vZGVbaWR4XSA9PT0gJ3BlcmNlbnQnKSB7XG4gICAgICAgIGJvdW5kUGVyY2VudCA9PSBudWxsICYmIChib3VuZFBlcmNlbnQgPSBwZXJjZW50RXh0ZW50W2lkeF0pOyAvLyBVc2Ugc2NhbGUucGFyc2UgdG8gbWF0aCByb3VuZCBmb3IgY2F0ZWdvcnkgb3IgdGltZSBheGlzLlxuXG4gICAgICAgIGJvdW5kVmFsdWUgPSBzY2FsZS5wYXJzZShudW1iZXJVdGlsLmxpbmVhck1hcChib3VuZFBlcmNlbnQsIHBlcmNlbnRFeHRlbnQsIGRhdGFFeHRlbnQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1Byb3BNb2RlVmFsdWUgPSB0cnVlO1xuICAgICAgICBib3VuZFZhbHVlID0gYm91bmRWYWx1ZSA9PSBudWxsID8gZGF0YUV4dGVudFtpZHhdIDogc2NhbGUucGFyc2UoYm91bmRWYWx1ZSk7IC8vIENhbGN1bGF0aW5nIGBwZXJjZW50YCBmcm9tIGB2YWx1ZWAgbWF5IGJlIG5vdCBhY2N1cmF0ZSwgYmVjYXVzZVxuICAgICAgICAvLyBUaGlzIGNhbGN1bGF0aW9uIGNhbiBub3QgYmUgaW52ZXJzZWQsIGJlY2F1c2UgYWxsIG9mIHZhbHVlcyB0aGF0XG4gICAgICAgIC8vIGFyZSBvdmVyZmxvdyB0aGUgYGRhdGFFeHRlbnRgIHdpbGwgYmUgY2FsY3VsYXRlZCB0byBwZXJjZW50ICcxMDAlJ1xuXG4gICAgICAgIGJvdW5kUGVyY2VudCA9IG51bWJlclV0aWwubGluZWFyTWFwKGJvdW5kVmFsdWUsIGRhdGFFeHRlbnQsIHBlcmNlbnRFeHRlbnQpO1xuICAgICAgfSAvLyB2YWx1ZVdpbmRvd1tpZHhdID0gcm91bmQoYm91bmRWYWx1ZSk7XG4gICAgICAvLyBwZXJjZW50V2luZG93W2lkeF0gPSByb3VuZChib3VuZFBlcmNlbnQpO1xuXG5cbiAgICAgIHZhbHVlV2luZG93W2lkeF0gPSBib3VuZFZhbHVlO1xuICAgICAgcGVyY2VudFdpbmRvd1tpZHhdID0gYm91bmRQZXJjZW50O1xuICAgIH0pO1xuICAgIGFzYyh2YWx1ZVdpbmRvdyk7XG4gICAgYXNjKHBlcmNlbnRXaW5kb3cpOyAvLyBUaGUgd2luZG93cyBmcm9tIHVzZXIgY2FsbGluZyBvZiBgZGlzcGF0Y2hBY3Rpb25gIG1pZ2h0IGJlIG91dCBvZiB0aGUgZXh0ZW50LFxuICAgIC8vIG9yIGRvIG5vdCBvYmV5IHRoZSBgbWluL21heFNwYW5gLCBgbWluL21heFZhbHVlU3BhbmAuIEJ1dCB3ZSBkb250IHJlc3RyaWN0IHdpbmRvd1xuICAgIC8vIGJ5IGB6b29tTG9ja2AgaGVyZSwgYmVjYXVzZSB3ZSBzZWUgYHpvb21Mb2NrYCBqdXN0IGFzIGEgaW50ZXJhY3Rpb24gY29uc3RyYWludCxcbiAgICAvLyB3aGVyZSBBUEkgaXMgYWJsZSB0byBpbml0aWFsaXplL21vZGlmeSB0aGUgd2luZG93IHNpemUgZXZlbiB0aG91Z2ggYHpvb21Mb2NrYFxuICAgIC8vIHNwZWNpZmllZC5cblxuICAgIHZhciBzcGFucyA9IHRoaXMuX21pbk1heFNwYW47XG4gICAgaGFzUHJvcE1vZGVWYWx1ZSA/IHJlc3RyaWN0U2V0KHZhbHVlV2luZG93LCBwZXJjZW50V2luZG93LCBkYXRhRXh0ZW50LCBwZXJjZW50RXh0ZW50LCBmYWxzZSkgOiByZXN0cmljdFNldChwZXJjZW50V2luZG93LCB2YWx1ZVdpbmRvdywgcGVyY2VudEV4dGVudCwgZGF0YUV4dGVudCwgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiByZXN0cmljdFNldChmcm9tV2luZG93LCB0b1dpbmRvdywgZnJvbUV4dGVudCwgdG9FeHRlbnQsIHRvVmFsdWUpIHtcbiAgICAgIHZhciBzdWZmaXggPSB0b1ZhbHVlID8gJ1NwYW4nIDogJ1ZhbHVlU3Bhbic7XG4gICAgICBzbGlkZXJNb3ZlKDAsIGZyb21XaW5kb3csIGZyb21FeHRlbnQsICdhbGwnLCBzcGFuc1snbWluJyArIHN1ZmZpeF0sIHNwYW5zWydtYXgnICsgc3VmZml4XSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgIHRvV2luZG93W2ldID0gbnVtYmVyVXRpbC5saW5lYXJNYXAoZnJvbVdpbmRvd1tpXSwgZnJvbUV4dGVudCwgdG9FeHRlbnQsIHRydWUpO1xuICAgICAgICB0b1ZhbHVlICYmICh0b1dpbmRvd1tpXSA9IHNjYWxlLnBhcnNlKHRvV2luZG93W2ldKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlV2luZG93OiB2YWx1ZVdpbmRvdyxcbiAgICAgIHBlcmNlbnRXaW5kb3c6IHBlcmNlbnRXaW5kb3dcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogTm90aWNlOiByZXNldCBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmUgc2VyaWVzLnJlc3RvcmVEYXRhKCkgY2FsbGVkLFxuICAgKiBzbyBpdCBpcyByZWNvbW1hbmRlZCB0byBiZSBjYWxsZWQgaW4gXCJwcm9jZXNzIHN0YWdlXCIgYnV0IG5vdCBcIm1vZGVsIGluaXRcbiAgICogc3RhZ2VcIi5cbiAgICovXG5cblxuICBBeGlzUHJveHkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICBpZiAoZGF0YVpvb21Nb2RlbCAhPT0gdGhpcy5fZGF0YVpvb21Nb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRTZXJpZXMgPSB0aGlzLmdldFRhcmdldFNlcmllc01vZGVscygpOyAvLyBDdWxjdWxhdGUgZGF0YSB3aW5kb3cgYW5kIGRhdGEgZXh0ZW50LCBhbmQgcmVjb3JkIHRoZW0uXG5cbiAgICB0aGlzLl9kYXRhRXh0ZW50ID0gY2FsY3VsYXRlRGF0YUV4dGVudCh0aGlzLCB0aGlzLl9kaW1OYW1lLCB0YXJnZXRTZXJpZXMpOyAvLyB0aGlzLmhhc1Nlcmllc1N0YWNrZWQgPSBmYWxzZTtcbiAgICAvLyBlYWNoKHRhcmdldFNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuICAgIC8vIGxldCBkYXRhID0gc2VyaWVzLmdldERhdGEoKTtcbiAgICAvLyBsZXQgZGF0YURpbSA9IGRhdGEubWFwRGltZW5zaW9uKHRoaXMuX2RpbU5hbWUpO1xuICAgIC8vIGxldCBzdGFja2VkRGltZW5zaW9uID0gZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrZWREaW1lbnNpb24nKTtcbiAgICAvLyBpZiAoc3RhY2tlZERpbWVuc2lvbiAmJiBzdGFja2VkRGltZW5zaW9uID09PSBkYXRhRGltKSB7XG4gICAgLy8gdGhpcy5oYXNTZXJpZXNTdGFja2VkID0gdHJ1ZTtcbiAgICAvLyB9XG4gICAgLy8gfSwgdGhpcyk7XG4gICAgLy8gYGNhbGN1bGF0ZURhdGFXaW5kb3dgIHVzZXMgbWluL21heFNwYW4uXG5cbiAgICB0aGlzLl91cGRhdGVNaW5NYXhTcGFuKCk7XG5cbiAgICB2YXIgZGF0YVdpbmRvdyA9IHRoaXMuY2FsY3VsYXRlRGF0YVdpbmRvdyhkYXRhWm9vbU1vZGVsLnNldHRsZWRPcHRpb24pO1xuICAgIHRoaXMuX3ZhbHVlV2luZG93ID0gZGF0YVdpbmRvdy52YWx1ZVdpbmRvdztcbiAgICB0aGlzLl9wZXJjZW50V2luZG93ID0gZGF0YVdpbmRvdy5wZXJjZW50V2luZG93OyAvLyBVcGRhdGUgYXhpcyBzZXR0aW5nIHRoZW4uXG5cbiAgICB0aGlzLl9zZXRBeGlzTW9kZWwoKTtcbiAgfTtcblxuICBBeGlzUHJveHkucHJvdG90eXBlLmZpbHRlckRhdGEgPSBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgYXBpKSB7XG4gICAgaWYgKGRhdGFab29tTW9kZWwgIT09IHRoaXMuX2RhdGFab29tTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXhpc0RpbSA9IHRoaXMuX2RpbU5hbWU7XG4gICAgdmFyIHNlcmllc01vZGVscyA9IHRoaXMuZ2V0VGFyZ2V0U2VyaWVzTW9kZWxzKCk7XG4gICAgdmFyIGZpbHRlck1vZGUgPSBkYXRhWm9vbU1vZGVsLmdldCgnZmlsdGVyTW9kZScpO1xuICAgIHZhciB2YWx1ZVdpbmRvdyA9IHRoaXMuX3ZhbHVlV2luZG93O1xuXG4gICAgaWYgKGZpbHRlck1vZGUgPT09ICdub25lJykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRklYTUVcbiAgICAvLyBUb29sYm94IG1heSBoYXMgZGF0YVpvb20gaW5qZWN0ZWQuIEFuZCBpZiB0aGVyZSBhcmUgc3RhY2tlZCBiYXIgY2hhcnRcbiAgICAvLyB3aXRoIE5hTiBkYXRhLCBOYU4gd2lsbCBiZSBmaWx0ZXJlZCBhbmQgc3RhY2sgd2lsbCBiZSB3cm9uZy5cbiAgICAvLyBTbyB3ZSBuZWVkIHRvIGZvcmNlIHRoZSBtb2RlIHRvIGJlIHNldCBlbXB0eS5cbiAgICAvLyBJbiBmZWN0LCBpdCBpcyBub3QgYSBiaWcgZGVhbCB0aGF0IGRvIG5vdCBzdXBwb3J0IGZpbHRlck1vZGUtJ2ZpbHRlcidcbiAgICAvLyB3aGVuIHVzaW5nIHRvb2xib3gjZGF0YVpvb20sIHV0aWxsIHRvb2x0aXAjZGF0YVpvb20gc3VwcG9ydCBcInNpbmdsZSBheGlzXG4gICAgLy8gc2VsZWN0aW9uXCIgc29tZSBkYXksIHdoaWNoIG1pZ2h0IG5lZWQgXCJhZGFwdCB0byBkYXRhIGV4dGVudCBvbiB0aGVcbiAgICAvLyBvdGhlckF4aXNcIiwgd2hpY2ggaXMgZGlzYWJsZWQgYnkgZmlsdGVyTW9kZS0nZW1wdHknLlxuICAgIC8vIEJ1dCBjdXJyZW50bHksIHN0YWNrIGhhcyBiZWVuIGZpeGVkIHRvIGJhc2VkIG9uIHZhbHVlIGJ1dCBub3QgaW5kZXgsXG4gICAgLy8gc28gdGhpcyBpcyBub3QgYW4gaXNzdWUgYW55IG1vcmUuXG4gICAgLy8gbGV0IG90aGVyQXhpc01vZGVsID0gdGhpcy5nZXRPdGhlckF4aXNNb2RlbCgpO1xuICAgIC8vIGlmIChkYXRhWm9vbU1vZGVsLmdldCgnJGZyb21Ub29sYm94JylcbiAgICAvLyAgICAgJiYgb3RoZXJBeGlzTW9kZWxcbiAgICAvLyAgICAgJiYgb3RoZXJBeGlzTW9kZWwuaGFzU2VyaWVzU3RhY2tlZFxuICAgIC8vICkge1xuICAgIC8vICAgICBmaWx0ZXJNb2RlID0gJ2VtcHR5JztcbiAgICAvLyB9XG4gICAgLy8gVE9ET1xuICAgIC8vIGZpbHRlck1vZGUgJ3dlYWtGaWx0ZXInIGFuZCAnZW1wdHknIGlzIG5vdCBvcHRpbWl6ZWQgZm9yIGh1Z2UgZGF0YSB5ZXQuXG5cblxuICAgIGVhY2goc2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHZhciBzZXJpZXNEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgdmFyIGRhdGFEaW1zID0gc2VyaWVzRGF0YS5tYXBEaW1lbnNpb25zQWxsKGF4aXNEaW0pO1xuXG4gICAgICBpZiAoIWRhdGFEaW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWx0ZXJNb2RlID09PSAnd2Vha0ZpbHRlcicpIHtcbiAgICAgICAgc2VyaWVzRGF0YS5maWx0ZXJTZWxmKGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgICB2YXIgbGVmdE91dDtcbiAgICAgICAgICB2YXIgcmlnaHRPdXQ7XG4gICAgICAgICAgdmFyIGhhc1ZhbHVlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhRGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VyaWVzRGF0YS5nZXQoZGF0YURpbXNbaV0sIGRhdGFJbmRleCk7XG4gICAgICAgICAgICB2YXIgdGhpc0hhc1ZhbHVlID0gIWlzTmFOKHZhbHVlKTtcbiAgICAgICAgICAgIHZhciB0aGlzTGVmdE91dCA9IHZhbHVlIDwgdmFsdWVXaW5kb3dbMF07XG4gICAgICAgICAgICB2YXIgdGhpc1JpZ2h0T3V0ID0gdmFsdWUgPiB2YWx1ZVdpbmRvd1sxXTtcblxuICAgICAgICAgICAgaWYgKHRoaXNIYXNWYWx1ZSAmJiAhdGhpc0xlZnRPdXQgJiYgIXRoaXNSaWdodE91dCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpc0hhc1ZhbHVlICYmIChoYXNWYWx1ZSA9IHRydWUpO1xuICAgICAgICAgICAgdGhpc0xlZnRPdXQgJiYgKGxlZnRPdXQgPSB0cnVlKTtcbiAgICAgICAgICAgIHRoaXNSaWdodE91dCAmJiAocmlnaHRPdXQgPSB0cnVlKTtcbiAgICAgICAgICB9IC8vIElmIGJvdGggbGVmdCBvdXQgYW5kIHJpZ2h0IG91dCwgZG8gbm90IGZpbHRlci5cblxuXG4gICAgICAgICAgcmV0dXJuIGhhc1ZhbHVlICYmIGxlZnRPdXQgJiYgcmlnaHRPdXQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFjaChkYXRhRGltcywgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgIGlmIChmaWx0ZXJNb2RlID09PSAnZW1wdHknKSB7XG4gICAgICAgICAgICBzZXJpZXNNb2RlbC5zZXREYXRhKHNlcmllc0RhdGEgPSBzZXJpZXNEYXRhLm1hcChkaW0sIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gIWlzSW5XaW5kb3codmFsdWUpID8gTmFOIDogdmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHt9O1xuICAgICAgICAgICAgcmFuZ2VbZGltXSA9IHZhbHVlV2luZG93OyAvLyBjb25zb2xlLnRpbWUoJ3NlbGVjdCcpO1xuXG4gICAgICAgICAgICBzZXJpZXNEYXRhLnNlbGVjdFJhbmdlKHJhbmdlKTsgLy8gY29uc29sZS50aW1lRW5kKCdzZWxlY3QnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBlYWNoKGRhdGFEaW1zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIHNlcmllc0RhdGEuc2V0QXBwcm94aW1hdGVFeHRlbnQodmFsdWVXaW5kb3csIGRpbSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGlzSW5XaW5kb3codmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSB2YWx1ZVdpbmRvd1swXSAmJiB2YWx1ZSA8PSB2YWx1ZVdpbmRvd1sxXTtcbiAgICB9XG4gIH07XG5cbiAgQXhpc1Byb3h5LnByb3RvdHlwZS5fdXBkYXRlTWluTWF4U3BhbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWluTWF4U3BhbiA9IHRoaXMuX21pbk1heFNwYW4gPSB7fTtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuX2RhdGFab29tTW9kZWw7XG4gICAgdmFyIGRhdGFFeHRlbnQgPSB0aGlzLl9kYXRhRXh0ZW50O1xuICAgIGVhY2goWydtaW4nLCAnbWF4J10sIGZ1bmN0aW9uIChtaW5NYXgpIHtcbiAgICAgIHZhciBwZXJjZW50U3BhbiA9IGRhdGFab29tTW9kZWwuZ2V0KG1pbk1heCArICdTcGFuJyk7XG4gICAgICB2YXIgdmFsdWVTcGFuID0gZGF0YVpvb21Nb2RlbC5nZXQobWluTWF4ICsgJ1ZhbHVlU3BhbicpO1xuICAgICAgdmFsdWVTcGFuICE9IG51bGwgJiYgKHZhbHVlU3BhbiA9IHRoaXMuZ2V0QXhpc01vZGVsKCkuYXhpcy5zY2FsZS5wYXJzZSh2YWx1ZVNwYW4pKTsgLy8gbWluVmFsdWVTcGFuIGFuZCBtYXhWYWx1ZVNwYW4gaGFzIGhpZ2hlciBwcmlvcml0eSB0aGFuIG1pblNwYW4gYW5kIG1heFNwYW5cblxuICAgICAgaWYgKHZhbHVlU3BhbiAhPSBudWxsKSB7XG4gICAgICAgIHBlcmNlbnRTcGFuID0gbnVtYmVyVXRpbC5saW5lYXJNYXAoZGF0YUV4dGVudFswXSArIHZhbHVlU3BhbiwgZGF0YUV4dGVudCwgWzAsIDEwMF0sIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChwZXJjZW50U3BhbiAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlU3BhbiA9IG51bWJlclV0aWwubGluZWFyTWFwKHBlcmNlbnRTcGFuLCBbMCwgMTAwXSwgZGF0YUV4dGVudCwgdHJ1ZSkgLSBkYXRhRXh0ZW50WzBdO1xuICAgICAgfVxuXG4gICAgICBtaW5NYXhTcGFuW21pbk1heCArICdTcGFuJ10gPSBwZXJjZW50U3BhbjtcbiAgICAgIG1pbk1heFNwYW5bbWluTWF4ICsgJ1ZhbHVlU3BhbiddID0gdmFsdWVTcGFuO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4gIEF4aXNQcm94eS5wcm90b3R5cGUuX3NldEF4aXNNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5nZXRBeGlzTW9kZWwoKTtcbiAgICB2YXIgcGVyY2VudFdpbmRvdyA9IHRoaXMuX3BlcmNlbnRXaW5kb3c7XG4gICAgdmFyIHZhbHVlV2luZG93ID0gdGhpcy5fdmFsdWVXaW5kb3c7XG5cbiAgICBpZiAoIXBlcmNlbnRXaW5kb3cpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFswLCA1MDBdOiBhcmJpdHJhcnkgdmFsdWUsIGd1ZXNzIGF4aXMgZXh0ZW50LlxuXG5cbiAgICB2YXIgcHJlY2lzaW9uID0gbnVtYmVyVXRpbC5nZXRQaXhlbFByZWNpc2lvbih2YWx1ZVdpbmRvdywgWzAsIDUwMF0pO1xuICAgIHByZWNpc2lvbiA9IE1hdGgubWluKHByZWNpc2lvbiwgMjApOyAvLyBGb3IgdmFsdWUgYXhpcywgaWYgbWluL21heC9zY2FsZSBhcmUgbm90IHNldCwgd2UganVzdCB1c2UgdGhlIGV4dGVudCBvYnRhaW5lZFxuICAgIC8vIGJ5IHNlcmllcyBkYXRhLCB3aGljaCBtYXkgYmUgYSBsaXR0bGUgZGlmZmVyZW50IGZyb20gdGhlIGV4dGVudCBjYWxjdWxhdGVkIGJ5XG4gICAgLy8gYGF4aXNIZWxwZXIuZ2V0U2NhbGVFeHRlbnRgLiBCdXQgdGhlIGRpZmZlcmVudCBqdXN0IGFmZmVjdHMgdGhlIGV4cGVyaWVuY2UgYVxuICAgIC8vIGxpdHRsZSB3aGVuIHpvb21pbmcuIFNvIGl0IHdpbGwgbm90IGJlIGZpeGVkIHVudGlsIHNvbWUgdXNlcnMgcmVxdWlyZSBpdCBzdHJvbmdseS5cblxuICAgIHZhciByYXdFeHRlbnRJbmZvID0gYXhpc01vZGVsLmF4aXMuc2NhbGUucmF3RXh0ZW50SW5mbztcblxuICAgIGlmIChwZXJjZW50V2luZG93WzBdICE9PSAwKSB7XG4gICAgICByYXdFeHRlbnRJbmZvLnNldERldGVybWluZWRNaW5NYXgoJ21pbicsICt2YWx1ZVdpbmRvd1swXS50b0ZpeGVkKHByZWNpc2lvbikpO1xuICAgIH1cblxuICAgIGlmIChwZXJjZW50V2luZG93WzFdICE9PSAxMDApIHtcbiAgICAgIHJhd0V4dGVudEluZm8uc2V0RGV0ZXJtaW5lZE1pbk1heCgnbWF4JywgK3ZhbHVlV2luZG93WzFdLnRvRml4ZWQocHJlY2lzaW9uKSk7XG4gICAgfVxuXG4gICAgcmF3RXh0ZW50SW5mby5mcmVlemUoKTtcbiAgfTtcblxuICByZXR1cm4gQXhpc1Byb3h5O1xufSgpO1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVEYXRhRXh0ZW50KGF4aXNQcm94eSwgYXhpc0RpbSwgc2VyaWVzTW9kZWxzKSB7XG4gIHZhciBkYXRhRXh0ZW50ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICBlYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdW5pb25BeGlzRXh0ZW50RnJvbURhdGEoZGF0YUV4dGVudCwgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLCBheGlzRGltKTtcbiAgfSk7IC8vIEl0IGlzIGltcG9ydGFudCB0byBnZXQgXCJjb25zaXN0ZW50XCIgZXh0ZW50IHdoZW4gbW9yZSB0aGVuIG9uZSBheGVzIGlzXG4gIC8vIGNvbnRyb2xsZWQgYnkgYSBgZGF0YVpvb21gLCBvdGhlcndpc2UgdGhvc2UgYXhlcyB3aWxsIG5vdCBiZSBzeW5jaHJvbml6ZWRcbiAgLy8gd2hlbiB6b29taW5nLiBCdXQgaXQgaXMgZGlmZmljdWx0IHRvIGtub3cgd2hhdCBpcyBcImNvbnNpc3RlbnRcIiwgY29uc2lkZXJpbmdcbiAgLy8gYXhlcyBoYXZlIGRpZmZlcmVudCB0eXBlIG9yIGV2ZW4gZGlmZmVyZW50IG1lYW5pbmdzIChGb3IgZXhhbXBsZSwgdHdvXG4gIC8vIHRpbWUgYXhlcyBhcmUgdXNlZCB0byBjb21wYXJlIGRhdGEgb2YgdGhlIHNhbWUgZGF0ZSBpbiBkaWZmZXJlbnQgeWVhcnMpLlxuICAvLyBTbyBiYXNpY2FsbHkgZGF0YVpvb20ganVzdCBvYnRhaW5zIGV4dGVudCBieSBzZXJpZXMuZGF0YSAoaW4gY2F0ZWdvcnkgYXhpc1xuICAvLyBleHRlbnQgY2FuIGJlIG9idGFpbmVkIGZyb20gYXhpcy5kYXRhKS5cbiAgLy8gTmV2ZXJ0aGVsZXNzLCB1c2VyIGNhbiBzZXQgbWluL21heC9zY2FsZSBvbiBheGVzIHRvIG1ha2UgZXh0ZW50IG9mIGF4ZXNcbiAgLy8gY29uc2lzdGVudC5cblxuICB2YXIgYXhpc01vZGVsID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpO1xuICB2YXIgcmF3RXh0ZW50UmVzdWx0ID0gZW5zdXJlU2NhbGVSYXdFeHRlbnRJbmZvKGF4aXNNb2RlbC5heGlzLnNjYWxlLCBheGlzTW9kZWwsIGRhdGFFeHRlbnQpLmNhbGN1bGF0ZSgpO1xuICByZXR1cm4gW3Jhd0V4dGVudFJlc3VsdC5taW4sIHJhd0V4dGVudFJlc3VsdC5tYXhdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBBeGlzUHJveHk7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgZWFjaCwgY3JlYXRlSGFzaE1hcCwgbWVyZ2UsIGFzc2VydCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50JztcbmltcG9ydCB7IGdldEF4aXNNYWluVHlwZSwgREFUQV9aT09NX0FYSVNfRElNRU5TSU9OUyB9IGZyb20gJy4vaGVscGVyJztcbmltcG9ydCB7IE1VTFRJUExFX1JFRkVSUklORywgU0lOR0xFX1JFRkVSUklORyB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwnO1xuXG52YXIgRGF0YVpvb21BeGlzSW5mbyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGFab29tQXhpc0luZm8oKSB7XG4gICAgdGhpcy5pbmRleExpc3QgPSBbXTtcbiAgICB0aGlzLmluZGV4TWFwID0gW107XG4gIH1cblxuICBEYXRhWm9vbUF4aXNJbmZvLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYXhpc0NtcHRJZHgpIHtcbiAgICAvLyBSZW1vdmUgZHVwbGljYXRpb24uXG4gICAgaWYgKCF0aGlzLmluZGV4TWFwW2F4aXNDbXB0SWR4XSkge1xuICAgICAgdGhpcy5pbmRleExpc3QucHVzaChheGlzQ21wdElkeCk7XG4gICAgICB0aGlzLmluZGV4TWFwW2F4aXNDbXB0SWR4XSA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBEYXRhWm9vbUF4aXNJbmZvO1xufSgpO1xuXG52YXIgRGF0YVpvb21Nb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhEYXRhWm9vbU1vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIERhdGFab29tTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gRGF0YVpvb21Nb2RlbC50eXBlO1xuICAgIF90aGlzLl9hdXRvVGhyb3R0bGUgPSB0cnVlO1xuICAgIF90aGlzLl9ub1RhcmdldCA9IHRydWU7XG4gICAgLyoqXG4gICAgICogSXQgaXMgYFtyYW5nZU1vZGVGb3JNaW4sIHJhbmdlTW9kZUZvck1heF1gLlxuICAgICAqIFRoZSBvcHRpb25hbCB2YWx1ZXMgZm9yIGByYW5nZU1vZGVgOlxuICAgICAqICsgYCd2YWx1ZSdgIG1vZGU6IHRoZSBheGlzIGV4dGVudCB3aWxsIGFsd2F5cyBiZSBkZXRlcm1pbmVkIGJ5XG4gICAgICogICAgIGBkYXRhWm9vbS5zdGFydFZhbHVlYCBhbmQgYGRhdGFab29tLmVuZFZhbHVlYCwgZGVzcGl0ZVxuICAgICAqICAgICBob3cgZGF0YSBsaWtlIGFuZCBob3cgYGF4aXMubWluYCBhbmQgYGF4aXMubWF4YCBhcmUuXG4gICAgICogKyBgJ3BlcmNlbnQnYCBtb2RlOiBgMTAwYCByZXByZXNlbnRzIDEwMCUgb2YgdGhlIGBbZE1pbiwgZE1heF1gLFxuICAgICAqICAgICB3aGVyZSBgZE1pbmAgaXMgYGF4aXMubWluYCBpZiBgYXhpcy5taW5gIHNwZWNpZmllZCwgb3RoZXJ3aXNlIGBkYXRhLmV4dGVudFswXWAsXG4gICAgICogICAgIGFuZCBgZE1heGAgaXMgYGF4aXMubWF4YCBpZiBgYXhpcy5tYXhgIHNwZWNpZmllZCwgb3RoZXJ3aXNlIGBkYXRhLmV4dGVudFsxXWAuXG4gICAgICogICAgIEF4aXMgZXh0ZW50IHdpbGwgYmUgZGV0ZXJtaW5lZCBieSB0aGUgcmVzdWx0IG9mIHRoZSBwZXJjZW50IG9mIGBbZE1pbiwgZE1heF1gLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHdoZW4gdXNlcnMgYXJlIHVzaW5nIGR5bmFtaWMgZGF0YSAodXBkYXRlIGRhdGEgcGVyaW9kaWNhbGx5IHZpYSBgc2V0T3B0aW9uYCksXG4gICAgICogaWYgaW4gYCd2YWx1ZWAnIG1vZGUsIHRoZSB3aW5kb3cgd2lsbCBiZSBrZXB0IGluIGEgZml4ZWQgdmFsdWUgcmFuZ2UgZGVzcGl0ZSBob3dcbiAgICAgKiBkYXRhIGFyZSBhcHBlbmRlZCwgd2hpbGUgaWYgaW4gYCdwZXJjZW50J2AgbW9kZSwgd2hlIHdpbmRvdyByYW5nZSB3aWxsIGJlIGNoYW5nZWQgYWxvbmUgd2l0aFxuICAgICAqIHRoZSBhcHBlbmRlZCBkYXRhIChzdXBwb3NlIGBheGlzLm1pbmAgYW5kIGBheGlzLm1heGAgYXJlIG5vdCBzcGVjaWZpZWQpLlxuICAgICAqL1xuXG4gICAgX3RoaXMuX3JhbmdlUHJvcE1vZGUgPSBbJ3BlcmNlbnQnLCAncGVyY2VudCddO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIERhdGFab29tTW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCkge1xuICAgIHZhciBpbnB1dFJhd09wdGlvbiA9IHJldHJpZXZlUmF3T3B0aW9uKG9wdGlvbik7XG4gICAgLyoqXG4gICAgICogU3VwcG9zZSBhIFwibWFpbiBwcm9jZXNzXCIgc3RhcnQgYXQgdGhlIHBvaW50IHRoYXQgbW9kZWwgcHJlcGFyZWQgKHRoYXQgaXMsXG4gICAgICogbW9kZWwgaW5pdGlhbGl6ZWQgb3IgbWVyZ2VkIG9yIG1ldGhvZCBjYWxsZWQgaW4gYGFjdGlvbmApLlxuICAgICAqIFdlIHNob3VsZCBrZWVwIHRoZSBgbWFpbiBwcm9jZXNzYCBpZGVtcG90ZW50LCB0aGF0IGlzLCBnaXZlbiBhIHNldCBvZiB2YWx1ZXNcbiAgICAgKiBvbiBgb3B0aW9uYCwgd2UgZ2V0IHRoZSBzYW1lIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEJ1dCBzb21ldGltZXMsIHZhbHVlcyBvbiBgb3B0aW9uYCB3aWxsIGJlIHVwZGF0ZWQgZm9yIHByb3ZpZGluZyB1c2Vyc1xuICAgICAqIGEgXCJmaW5hbCBjYWxjdWxhdGVkIHZhbHVlXCIgKGBkYXRhWm9vbVByb2Nlc3NvcmAgd2lsbCBkbyB0aGF0KS4gVGhvc2UgdmFsdWVcbiAgICAgKiBzaG91bGQgbm90IGJlIHRoZSBiYXNlL2lucHV0IG9mIHRoZSBgbWFpbiBwcm9jZXNzYC5cbiAgICAgKlxuICAgICAqIFNvIGluIHRoYXQgY2FzZSB3ZSBzaG91bGQgc2F2ZSBhbmQga2VlcCB0aGUgaW5wdXQgb2YgdGhlIGBtYWluIHByb2Nlc3NgXG4gICAgICogc2VwYXJhdGVseSwgY2FsbGVkIGBzZXR0bGVkT3B0aW9uYC5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCBjb25zaWRlciB0aGUgY2FzZTpcbiAgICAgKiAoU3RlcF8xKSBicnVzaCB6b29tIHRoZSBncmlkIGJ5IGB0b29sYm94LmRhdGFab29tYCxcbiAgICAgKiAgICAgd2hlcmUgdGhlIG9yaWdpbmFsIGlucHV0IGBvcHRpb24uc3RhcnRWYWx1ZWAsIGBvcHRpb24uZW5kVmFsdWVgIGFyZSBlYXJzZWQgYnlcbiAgICAgKiAgICAgY2FsY3VsYXRlZCB2YWx1ZS5cbiAgICAgKiAoU3RlcCkyKSBjbGljayB0aGUgbGVnZW5kIHRvIGhpZGUgYW5kIHNob3cgYSBzZXJpZXMsXG4gICAgICogICAgIHdoZXJlIHRoZSBuZXcgcmFuZ2UgaXMgY2FsY3VsYXRlZCBieSB0aGUgZWFyc2VkIGBzdGFydFZhbHVlYCBhbmQgYGVuZFZhbHVlYCxcbiAgICAgKiAgICAgd2hpY2ggYnJpbmdzIGluY29ycmVjdCByZXN1bHQuXG4gICAgICovXG5cbiAgICB0aGlzLnNldHRsZWRPcHRpb24gPSBpbnB1dFJhd09wdGlvbjtcbiAgICB0aGlzLm1lcmdlRGVmYXVsdEFuZFRoZW1lKG9wdGlvbiwgZWNNb2RlbCk7XG5cbiAgICB0aGlzLl9kb0luaXQoaW5wdXRSYXdPcHRpb24pO1xuICB9O1xuXG4gIERhdGFab29tTW9kZWwucHJvdG90eXBlLm1lcmdlT3B0aW9uID0gZnVuY3Rpb24gKG5ld09wdGlvbikge1xuICAgIHZhciBpbnB1dFJhd09wdGlvbiA9IHJldHJpZXZlUmF3T3B0aW9uKG5ld09wdGlvbik7IC8vRklYICMyNTkxXG5cbiAgICBtZXJnZSh0aGlzLm9wdGlvbiwgbmV3T3B0aW9uLCB0cnVlKTtcbiAgICBtZXJnZSh0aGlzLnNldHRsZWRPcHRpb24sIGlucHV0UmF3T3B0aW9uLCB0cnVlKTtcblxuICAgIHRoaXMuX2RvSW5pdChpbnB1dFJhd09wdGlvbik7XG4gIH07XG5cbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuX2RvSW5pdCA9IGZ1bmN0aW9uIChpbnB1dFJhd09wdGlvbikge1xuICAgIHZhciB0aGlzT3B0aW9uID0gdGhpcy5vcHRpb247IC8vIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgIC8vICAgICB0aGlzT3B0aW9uLnJlYWx0aW1lID0gZmFsc2U7XG4gICAgLy8gfVxuXG4gICAgdGhpcy5fc2V0RGVmYXVsdFRocm90dGxlKGlucHV0UmF3T3B0aW9uKTtcblxuICAgIHRoaXMuX3VwZGF0ZVJhbmdlVXNlKGlucHV0UmF3T3B0aW9uKTtcblxuICAgIHZhciBzZXR0bGVkT3B0aW9uID0gdGhpcy5zZXR0bGVkT3B0aW9uO1xuICAgIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzLCBpbmRleCkge1xuICAgICAgLy8gc3RhcnQvZW5kIGhhcyBoaWdoZXIgcHJpb3JpdHkgb3ZlciBzdGFydFZhbHVlL2VuZFZhbHVlIGlmIHRoZXlcbiAgICAgIC8vIGJvdGggc2V0LCBidXQgd2Ugc2hvdWxkIG1ha2UgY2hhcnQuc2V0T3B0aW9uKHtlbmRWYWx1ZTogMTAwMH0pXG4gICAgICAvLyBlZmZlY3RpdmUsIHJhdGhlciB0aGFuIGNoYXJ0LnNldE9wdGlvbih7ZW5kVmFsdWU6IDEwMDAsIGVuZDogbnVsbH0pLlxuICAgICAgaWYgKHRoaXMuX3JhbmdlUHJvcE1vZGVbaW5kZXhdID09PSAndmFsdWUnKSB7XG4gICAgICAgIHRoaXNPcHRpb25bbmFtZXNbMF1dID0gc2V0dGxlZE9wdGlvbltuYW1lc1swXV0gPSBudWxsO1xuICAgICAgfSAvLyBPdGhlcndpc2UgZG8gbm90aGluZyBhbmQgdXNlIHRoZSBtZXJnZSByZXN1bHQuXG5cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX3Jlc2V0VGFyZ2V0KCk7XG4gIH07XG5cbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuX3Jlc2V0VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25PcmllbnQgPSB0aGlzLmdldCgnb3JpZW50JywgdHJ1ZSk7XG4gICAgdmFyIHRhcmdldEF4aXNJbmRleE1hcCA9IHRoaXMuX3RhcmdldEF4aXNJbmZvTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuXG4gICAgdmFyIGhhc0F4aXNTcGVjaWZpZWQgPSB0aGlzLl9maWxsU3BlY2lmaWVkVGFyZ2V0QXhpcyh0YXJnZXRBeGlzSW5kZXhNYXApO1xuXG4gICAgaWYgKGhhc0F4aXNTcGVjaWZpZWQpIHtcbiAgICAgIHRoaXMuX29yaWVudCA9IG9wdGlvbk9yaWVudCB8fCB0aGlzLl9tYWtlQXV0b09yaWVudEJ5VGFyZ2V0QXhpcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vcmllbnQgPSBvcHRpb25PcmllbnQgfHwgJ2hvcml6b250YWwnO1xuXG4gICAgICB0aGlzLl9maWxsQXV0b1RhcmdldEF4aXNCeU9yaWVudCh0YXJnZXRBeGlzSW5kZXhNYXAsIHRoaXMuX29yaWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbm9UYXJnZXQgPSB0cnVlO1xuICAgIHRhcmdldEF4aXNJbmRleE1hcC5lYWNoKGZ1bmN0aW9uIChheGlzSW5mbykge1xuICAgICAgaWYgKGF4aXNJbmZvLmluZGV4TGlzdC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbm9UYXJnZXQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuICBEYXRhWm9vbU1vZGVsLnByb3RvdHlwZS5fZmlsbFNwZWNpZmllZFRhcmdldEF4aXMgPSBmdW5jdGlvbiAodGFyZ2V0QXhpc0luZGV4TWFwKSB7XG4gICAgdmFyIGhhc0F4aXNTcGVjaWZpZWQgPSBmYWxzZTtcbiAgICBlYWNoKERBVEFfWk9PTV9BWElTX0RJTUVOU0lPTlMsIGZ1bmN0aW9uIChheGlzRGltKSB7XG4gICAgICB2YXIgcmVmZXJpbmcgPSB0aGlzLmdldFJlZmVycmluZ0NvbXBvbmVudHMoZ2V0QXhpc01haW5UeXBlKGF4aXNEaW0pLCBNVUxUSVBMRV9SRUZFUlJJTkcpOyAvLyBXaGVuIHVzZXIgc2V0IGF4aXNJbmRleCBhcyBhIGVtcHR5IGFycmF5LCB3ZSB0aGluayB0aGF0IHVzZXIgc3BlY2lmeSBheGlzSW5kZXhcbiAgICAgIC8vIGJ1dCBkbyBub3Qgd2FudCB1c2UgYXV0byBtb2RlLiBCZWNhdXNlIGVtcHR5IGFycmF5IG1heSBiZSBlbmNvdW50ZXJlZCB3aGVuXG4gICAgICAvLyBzb21lIGVycm9yIG9jY3VyZWQuXG5cbiAgICAgIGlmICghcmVmZXJpbmcuc3BlY2lmaWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaGFzQXhpc1NwZWNpZmllZCA9IHRydWU7XG4gICAgICB2YXIgYXhpc0luZm8gPSBuZXcgRGF0YVpvb21BeGlzSW5mbygpO1xuICAgICAgZWFjaChyZWZlcmluZy5tb2RlbHMsIGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICAgICAgYXhpc0luZm8uYWRkKGF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gICAgICB9KTtcbiAgICAgIHRhcmdldEF4aXNJbmRleE1hcC5zZXQoYXhpc0RpbSwgYXhpc0luZm8pO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBoYXNBeGlzU3BlY2lmaWVkO1xuICB9O1xuXG4gIERhdGFab29tTW9kZWwucHJvdG90eXBlLl9maWxsQXV0b1RhcmdldEF4aXNCeU9yaWVudCA9IGZ1bmN0aW9uICh0YXJnZXRBeGlzSW5kZXhNYXAsIG9yaWVudCkge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgIHZhciBuZWVkQXV0byA9IHRydWU7IC8vIEZpbmQgYXhpcyB0aGF0IHBhcmFsbGVsIHRvIGRhdGFab29tIGFzIGRlZmF1bHQuXG5cbiAgICBpZiAobmVlZEF1dG8pIHtcbiAgICAgIHZhciBheGlzRGltID0gb3JpZW50ID09PSAndmVydGljYWwnID8gJ3knIDogJ3gnO1xuICAgICAgdmFyIGF4aXNNb2RlbHMgPSBlY01vZGVsLmZpbmRDb21wb25lbnRzKHtcbiAgICAgICAgbWFpblR5cGU6IGF4aXNEaW0gKyAnQXhpcydcbiAgICAgIH0pO1xuICAgICAgc2V0UGFyYWxsZWxBeGlzKGF4aXNNb2RlbHMsIGF4aXNEaW0pO1xuICAgIH0gLy8gRmluZCBheGlzIHRoYXQgcGFyYWxsZWwgdG8gZGF0YVpvb20gYXMgZGVmYXVsdC5cblxuXG4gICAgaWYgKG5lZWRBdXRvKSB7XG4gICAgICB2YXIgYXhpc01vZGVscyA9IGVjTW9kZWwuZmluZENvbXBvbmVudHMoe1xuICAgICAgICBtYWluVHlwZTogJ3NpbmdsZUF4aXMnLFxuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICAgICAgICByZXR1cm4gYXhpc01vZGVsLmdldCgnb3JpZW50JywgdHJ1ZSkgPT09IG9yaWVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZXRQYXJhbGxlbEF4aXMoYXhpc01vZGVscywgJ3NpbmdsZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFBhcmFsbGVsQXhpcyhheGlzTW9kZWxzLCBheGlzRGltKSB7XG4gICAgICAvLyBBdCBsZWFzdCB1c2UgdGhlIGZpcnN0IHBhcmFsbGVsIGF4aXMgYXMgdGhlIHRhcmdldCBheGlzLlxuICAgICAgdmFyIGF4aXNNb2RlbCA9IGF4aXNNb2RlbHNbMF07XG5cbiAgICAgIGlmICghYXhpc01vZGVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGF4aXNJbmZvID0gbmV3IERhdGFab29tQXhpc0luZm8oKTtcbiAgICAgIGF4aXNJbmZvLmFkZChheGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgICAgdGFyZ2V0QXhpc0luZGV4TWFwLnNldChheGlzRGltLCBheGlzSW5mbyk7XG4gICAgICBuZWVkQXV0byA9IGZhbHNlOyAvLyBGaW5kIHBhcmFsbGVsIGF4ZXMgaW4gdGhlIHNhbWUgZ3JpZC5cblxuICAgICAgaWYgKGF4aXNEaW0gPT09ICd4JyB8fCBheGlzRGltID09PSAneScpIHtcbiAgICAgICAgdmFyIGdyaWRNb2RlbF8xID0gYXhpc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ2dyaWQnLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG4gICAgICAgIGdyaWRNb2RlbF8xICYmIGVhY2goYXhpc01vZGVscywgZnVuY3Rpb24gKGF4TW9kZWwpIHtcbiAgICAgICAgICBpZiAoYXhpc01vZGVsLmNvbXBvbmVudEluZGV4ICE9PSBheE1vZGVsLmNvbXBvbmVudEluZGV4ICYmIGdyaWRNb2RlbF8xID09PSBheE1vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ2dyaWQnLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF0pIHtcbiAgICAgICAgICAgIGF4aXNJbmZvLmFkZChheE1vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWVkQXV0bykge1xuICAgICAgLy8gSWYgbm8gcGFyYWxsZWwgYXhpcywgZmluZCB0aGUgZmlyc3QgY2F0ZWdvcnkgYXhpcyBhcyBkZWZhdWx0LiAoQWxzbyBjb25zaWRlciBwb2xhcikuXG4gICAgICBlYWNoKERBVEFfWk9PTV9BWElTX0RJTUVOU0lPTlMsIGZ1bmN0aW9uIChheGlzRGltKSB7XG4gICAgICAgIGlmICghbmVlZEF1dG8pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXhpc01vZGVscyA9IGVjTW9kZWwuZmluZENvbXBvbmVudHMoe1xuICAgICAgICAgIG1haW5UeXBlOiBnZXRBeGlzTWFpblR5cGUoYXhpc0RpbSksXG4gICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXhpc01vZGVsLmdldCgndHlwZScsIHRydWUpID09PSAnY2F0ZWdvcnknO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGF4aXNNb2RlbHNbMF0pIHtcbiAgICAgICAgICB2YXIgYXhpc0luZm8gPSBuZXcgRGF0YVpvb21BeGlzSW5mbygpO1xuICAgICAgICAgIGF4aXNJbmZvLmFkZChheGlzTW9kZWxzWzBdLmNvbXBvbmVudEluZGV4KTtcbiAgICAgICAgICB0YXJnZXRBeGlzSW5kZXhNYXAuc2V0KGF4aXNEaW0sIGF4aXNJbmZvKTtcbiAgICAgICAgICBuZWVkQXV0byA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuX21ha2VBdXRvT3JpZW50QnlUYXJnZXRBeGlzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaW07IC8vIEZpbmQgdGhlIGZpcnN0IGF4aXNcblxuICAgIHRoaXMuZWFjaFRhcmdldEF4aXMoZnVuY3Rpb24gKGF4aXNEaW0pIHtcbiAgICAgICFkaW0gJiYgKGRpbSA9IGF4aXNEaW0pO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBkaW0gPT09ICd5JyA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH07XG5cbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuX3NldERlZmF1bHRUaHJvdHRsZSA9IGZ1bmN0aW9uIChpbnB1dFJhd09wdGlvbikge1xuICAgIC8vIFdoZW4gZmlyc3QgdGltZSB1c2VyIHNldCB0aHJvdHRsZSwgYXV0byB0aHJvdHRsZSBlbmRzLlxuICAgIGlmIChpbnB1dFJhd09wdGlvbi5oYXNPd25Qcm9wZXJ0eSgndGhyb3R0bGUnKSkge1xuICAgICAgdGhpcy5fYXV0b1Rocm90dGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2F1dG9UaHJvdHRsZSkge1xuICAgICAgdmFyIGdsb2JhbE9wdGlvbiA9IHRoaXMuZWNNb2RlbC5vcHRpb247XG4gICAgICB0aGlzLm9wdGlvbi50aHJvdHRsZSA9IGdsb2JhbE9wdGlvbi5hbmltYXRpb24gJiYgZ2xvYmFsT3B0aW9uLmFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlID4gMCA/IDEwMCA6IDIwO1xuICAgIH1cbiAgfTtcblxuICBEYXRhWm9vbU1vZGVsLnByb3RvdHlwZS5fdXBkYXRlUmFuZ2VVc2UgPSBmdW5jdGlvbiAoaW5wdXRSYXdPcHRpb24pIHtcbiAgICB2YXIgcmFuZ2VQcm9wTW9kZSA9IHRoaXMuX3JhbmdlUHJvcE1vZGU7XG4gICAgdmFyIHJhbmdlTW9kZUluT3B0aW9uID0gdGhpcy5nZXQoJ3JhbmdlTW9kZScpO1xuICAgIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzLCBpbmRleCkge1xuICAgICAgdmFyIHBlcmNlbnRTcGVjaWZpZWQgPSBpbnB1dFJhd09wdGlvbltuYW1lc1swXV0gIT0gbnVsbDtcbiAgICAgIHZhciB2YWx1ZVNwZWNpZmllZCA9IGlucHV0UmF3T3B0aW9uW25hbWVzWzFdXSAhPSBudWxsO1xuXG4gICAgICBpZiAocGVyY2VudFNwZWNpZmllZCAmJiAhdmFsdWVTcGVjaWZpZWQpIHtcbiAgICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSAncGVyY2VudCc7XG4gICAgICB9IGVsc2UgaWYgKCFwZXJjZW50U3BlY2lmaWVkICYmIHZhbHVlU3BlY2lmaWVkKSB7XG4gICAgICAgIHJhbmdlUHJvcE1vZGVbaW5kZXhdID0gJ3ZhbHVlJztcbiAgICAgIH0gZWxzZSBpZiAocmFuZ2VNb2RlSW5PcHRpb24pIHtcbiAgICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSByYW5nZU1vZGVJbk9wdGlvbltpbmRleF07XG4gICAgICB9IGVsc2UgaWYgKHBlcmNlbnRTcGVjaWZpZWQpIHtcbiAgICAgICAgLy8gcGVyY2VudFNwZWNpZmllZCAmJiB2YWx1ZVNwZWNpZmllZFxuICAgICAgICByYW5nZVByb3BNb2RlW2luZGV4XSA9ICdwZXJjZW50JztcbiAgICAgIH0gLy8gZWxzZSByZW1haW4gaXRzIG9yaWdpbmFsIHNldHRpbmcuXG5cbiAgICB9KTtcbiAgfTtcblxuICBEYXRhWm9vbU1vZGVsLnByb3RvdHlwZS5ub1RhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9UYXJnZXQ7XG4gIH07XG5cbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuZ2V0Rmlyc3RUYXJnZXRBeGlzTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpcnN0QXhpc01vZGVsO1xuICAgIHRoaXMuZWFjaFRhcmdldEF4aXMoZnVuY3Rpb24gKGF4aXNEaW0sIGF4aXNJbmRleCkge1xuICAgICAgaWYgKGZpcnN0QXhpc01vZGVsID09IG51bGwpIHtcbiAgICAgICAgZmlyc3RBeGlzTW9kZWwgPSB0aGlzLmVjTW9kZWwuZ2V0Q29tcG9uZW50KGdldEF4aXNNYWluVHlwZShheGlzRGltKSwgYXhpc0luZGV4KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gZmlyc3RBeGlzTW9kZWw7XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBwYXJhbTogYXhpc01vZGVsLCBkaW1OYW1lcywgYXhpc0luZGV4LCBkYXRhWm9vbU1vZGVsLCBlY01vZGVsXG4gICAqL1xuXG5cbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuZWFjaFRhcmdldEF4aXMgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl90YXJnZXRBeGlzSW5mb01hcC5lYWNoKGZ1bmN0aW9uIChheGlzSW5mbywgYXhpc0RpbSkge1xuICAgICAgZWFjaChheGlzSW5mby5pbmRleExpc3QsIGZ1bmN0aW9uIChheGlzSW5kZXgpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBheGlzRGltLCBheGlzSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBAcmV0dXJuIElmIG5vdCBmb3VuZCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICAgKi9cblxuXG4gIERhdGFab29tTW9kZWwucHJvdG90eXBlLmdldEF4aXNQcm94eSA9IGZ1bmN0aW9uIChheGlzRGltLCBheGlzSW5kZXgpIHtcbiAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5nZXRBeGlzTW9kZWwoYXhpc0RpbSwgYXhpc0luZGV4KTtcblxuICAgIGlmIChheGlzTW9kZWwpIHtcbiAgICAgIHJldHVybiBheGlzTW9kZWwuX19kekF4aXNQcm94eTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcmV0dXJuIElmIG5vdCBmb3VuZCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICAgKi9cblxuXG4gIERhdGFab29tTW9kZWwucHJvdG90eXBlLmdldEF4aXNNb2RlbCA9IGZ1bmN0aW9uIChheGlzRGltLCBheGlzSW5kZXgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0KGF4aXNEaW0gJiYgYXhpc0luZGV4ICE9IG51bGwpO1xuICAgIH1cblxuICAgIHZhciBheGlzSW5mbyA9IHRoaXMuX3RhcmdldEF4aXNJbmZvTWFwLmdldChheGlzRGltKTtcblxuICAgIGlmIChheGlzSW5mbyAmJiBheGlzSW5mby5pbmRleE1hcFtheGlzSW5kZXhdKSB7XG4gICAgICByZXR1cm4gdGhpcy5lY01vZGVsLmdldENvbXBvbmVudChnZXRBeGlzTWFpblR5cGUoYXhpc0RpbSksIGF4aXNJbmRleCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogSWYgbm90IHNwZWNpZmllZCwgc2V0IHRvIHVuZGVmaW5lZC5cbiAgICovXG5cblxuICBEYXRhWm9vbU1vZGVsLnByb3RvdHlwZS5zZXRSYXdSYW5nZSA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIHZhciBzZXR0bGVkT3B0aW9uID0gdGhpcy5zZXR0bGVkT3B0aW9uO1xuICAgIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzKSB7XG4gICAgICAvLyBDb25zaWRlciB0aGUgcGFpciA8c3RhcnQsIHN0YXJ0VmFsdWU+OlxuICAgICAgLy8gSWYgb25lIGhhcyB2YWx1ZSBhbmQgdGhlIG90aGVyIG9uZSBpcyBgbnVsbC91bmRlZmluZWRgLCB3ZSBib3RoIHNldCB0aGVtXG4gICAgICAvLyB0byBgc2V0dGxlZE9wdGlvbmAuIFRoaXMgc3RyYXRlZ3kgZW5hYmxlcyB0aGUgZmVhdHVyZSB0byBjbGVhciB0aGUgb3JpZ2luYWxcbiAgICAgIC8vIHZhbHVlIGluIGBzZXR0bGVkT3B0aW9uYCB0byBgbnVsbC91bmRlZmluZWRgLlxuICAgICAgLy8gQnV0IGlmIGJvdGggb2YgdGhlbSBhcmUgYG51bGwvdW5kZWZpbmVkYCwgd2UgZG8gbm90IHNldCB0aGVtIHRvIGBzZXR0bGVkT3B0aW9uYFxuICAgICAgLy8gYW5kIGtlZXAgYHNldHRsZWRPcHRpb25gIHdpdGggdGhlIG9yaWdpbmFsIHZhbHVlLiBUaGlzIHN0cmF0ZWd5IGVuYWJsZXMgdXNlcnMgdG9cbiAgICAgIC8vIG9ubHkgc2V0IDxlbmQgb3IgZW5kVmFsdWU+IGJ1dCBub3Qgc2V0IDxzdGFydCBvciBzdGFydFZhbHVlPiB3aGVuIGNhbGxpbmdcbiAgICAgIC8vIGBkaXNwYXRjaEFjdGlvbmAuXG4gICAgICAvLyBUaGUgcGFpciA8ZW5kLCBlbmRWYWx1ZT4gaXMgdHJlYXRlZCBpbiB0aGUgc2FtZSB3YXkuXG4gICAgICBpZiAob3B0W25hbWVzWzBdXSAhPSBudWxsIHx8IG9wdFtuYW1lc1sxXV0gIT0gbnVsbCkge1xuICAgICAgICB0aGlzT3B0aW9uW25hbWVzWzBdXSA9IHNldHRsZWRPcHRpb25bbmFtZXNbMF1dID0gb3B0W25hbWVzWzBdXTtcbiAgICAgICAgdGhpc09wdGlvbltuYW1lc1sxXV0gPSBzZXR0bGVkT3B0aW9uW25hbWVzWzFdXSA9IG9wdFtuYW1lc1sxXV07XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl91cGRhdGVSYW5nZVVzZShvcHQpO1xuICB9O1xuXG4gIERhdGFab29tTW9kZWwucHJvdG90eXBlLnNldENhbGN1bGF0ZWRSYW5nZSA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgZWFjaChbJ3N0YXJ0JywgJ3N0YXJ0VmFsdWUnLCAnZW5kJywgJ2VuZFZhbHVlJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBvcHRpb25bbmFtZV0gPSBvcHRbbmFtZV07XG4gICAgfSk7XG4gIH07XG5cbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuZ2V0UGVyY2VudFJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBheGlzUHJveHkgPSB0aGlzLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuXG4gICAgaWYgKGF4aXNQcm94eSkge1xuICAgICAgcmV0dXJuIGF4aXNQcm94eS5nZXREYXRhUGVyY2VudFdpbmRvdygpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEZvciBleGFtcGxlLCBjaGFydC5nZXRNb2RlbCgpLmdldENvbXBvbmVudCgnZGF0YVpvb20nKS5nZXRWYWx1ZVJhbmdlKCd5JywgMCk7XG4gICAqXG4gICAqIEByZXR1cm4gW3N0YXJ0VmFsdWUsIGVuZFZhbHVlXSB2YWx1ZSBjYW4gb25seSBiZSAnLScgb3IgZmluaXRlIG51bWJlci5cbiAgICovXG5cblxuICBEYXRhWm9vbU1vZGVsLnByb3RvdHlwZS5nZXRWYWx1ZVJhbmdlID0gZnVuY3Rpb24gKGF4aXNEaW0sIGF4aXNJbmRleCkge1xuICAgIGlmIChheGlzRGltID09IG51bGwgJiYgYXhpc0luZGV4ID09IG51bGwpIHtcbiAgICAgIHZhciBheGlzUHJveHkgPSB0aGlzLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuXG4gICAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICAgIHJldHVybiBheGlzUHJveHkuZ2V0RGF0YVZhbHVlV2luZG93KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEF4aXNQcm94eShheGlzRGltLCBheGlzSW5kZXgpLmdldERhdGFWYWx1ZVdpbmRvdygpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSBheGlzTW9kZWwgSWYgYXhpc01vZGVsIGdpdmVuLCBmaW5kIGF4aXNQcm94eVxuICAgKiAgICAgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGF4aXNNb2RlbFxuICAgKi9cblxuXG4gIERhdGFab29tTW9kZWwucHJvdG90eXBlLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSA9IGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICBpZiAoYXhpc01vZGVsKSB7XG4gICAgICByZXR1cm4gYXhpc01vZGVsLl9fZHpBeGlzUHJveHk7XG4gICAgfSAvLyBGaW5kIHRoZSBmaXJzdCBob3N0ZWQgYXhpc1Byb3h5XG5cblxuICAgIHZhciBmaXJzdFByb3h5O1xuXG4gICAgdmFyIGF4aXNEaW1MaXN0ID0gdGhpcy5fdGFyZ2V0QXhpc0luZm9NYXAua2V5cygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGlzRGltTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF4aXNEaW0gPSBheGlzRGltTGlzdFtpXTtcblxuICAgICAgdmFyIGF4aXNJbmZvID0gdGhpcy5fdGFyZ2V0QXhpc0luZm9NYXAuZ2V0KGF4aXNEaW0pO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGF4aXNJbmZvLmluZGV4TGlzdC5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcHJveHkgPSB0aGlzLmdldEF4aXNQcm94eShheGlzRGltLCBheGlzSW5mby5pbmRleExpc3Rbal0pO1xuXG4gICAgICAgIGlmIChwcm94eS5ob3N0ZWRCeSh0aGlzKSkge1xuICAgICAgICAgIHJldHVybiBwcm94eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmlyc3RQcm94eSkge1xuICAgICAgICAgIGZpcnN0UHJveHkgPSBwcm94eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gSWYgbm8gaG9zdGVkIHByb3h5IGZvdW5kLCBzdGlsbCBuZWVkIHRvIHJldHVybiBhIHByb3h5LlxuICAgIC8vIFRoaXMgY2FzZSBhbHdheXMgaGFwcGVucyBpbiB0b29sYm94IGRhdGFab29tLCB3aGVyZSBheGVzIGFyZSBhbGwgaG9zdGVkIGJ5XG4gICAgLy8gb3RoZXIgZGF0YVpvb21zLlxuXG5cbiAgICByZXR1cm4gZmlyc3RQcm94eTtcbiAgfTtcblxuICBEYXRhWm9vbU1vZGVsLnByb3RvdHlwZS5nZXRSYW5nZVByb3BNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yYW5nZVByb3BNb2RlLnNsaWNlKCk7XG4gIH07XG5cbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuZ2V0T3JpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBTaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmUgaW5pdGlhbGl6ZWQuXG4gICAgICBhc3NlcnQodGhpcy5fb3JpZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fb3JpZW50O1xuICB9O1xuXG4gIERhdGFab29tTW9kZWwudHlwZSA9ICdkYXRhWm9vbSc7XG4gIERhdGFab29tTW9kZWwuZGVwZW5kZW5jaWVzID0gWyd4QXhpcycsICd5QXhpcycsICdyYWRpdXNBeGlzJywgJ2FuZ2xlQXhpcycsICdzaW5nbGVBeGlzJywgJ3NlcmllcycsICd0b29sYm94J107XG4gIERhdGFab29tTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogNCxcbiAgICBmaWx0ZXJNb2RlOiAnZmlsdGVyJyxcbiAgICBzdGFydDogMCxcbiAgICBlbmQ6IDEwMFxuICB9O1xuICByZXR1cm4gRGF0YVpvb21Nb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgdGhvc2UgcmF3IHBhcmFtcyBmcm9tIG9wdGlvbiwgd2hpY2ggd2lsbCBiZSBjYWNoZWQgc2VwYXJhdGVseS5cbiAqIGJlY2FzdWUgdGhleSB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IG5vcm1hbGl6ZWQvY2FsY3VsYXRlZCB2YWx1ZXMgaW4gdGhlIG1haW5cbiAqIHByb2Nlc3MuXG4gKi9cblxuXG5mdW5jdGlvbiByZXRyaWV2ZVJhd09wdGlvbihvcHRpb24pIHtcbiAgdmFyIHJldCA9IHt9O1xuICBlYWNoKFsnc3RhcnQnLCAnZW5kJywgJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnLCAndGhyb3R0bGUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBvcHRpb24uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgKHJldFtuYW1lXSA9IG9wdGlvbltuYW1lXSk7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhWm9vbU1vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50JztcblxudmFyIERhdGFab29tVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhEYXRhWm9vbVZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gRGF0YVpvb21WaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IERhdGFab29tVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIERhdGFab29tVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGRhdGFab29tTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRoaXMuZGF0YVpvb21Nb2RlbCA9IGRhdGFab29tTW9kZWw7XG4gICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgICB0aGlzLmFwaSA9IGFwaTtcbiAgfTtcblxuICBEYXRhWm9vbVZpZXcudHlwZSA9ICdkYXRhWm9vbSc7XG4gIHJldHVybiBEYXRhWm9vbVZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuXG5leHBvcnQgZGVmYXVsdCBEYXRhWm9vbVZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IERhdGFab29tTW9kZWwgZnJvbSAnLi9EYXRhWm9vbU1vZGVsJztcbmltcG9ydCB7IGluaGVyaXREZWZhdWx0T3B0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbC9jb21wb25lbnQnO1xuXG52YXIgSW5zaWRlWm9vbU1vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEluc2lkZVpvb21Nb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBJbnNpZGVab29tTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gSW5zaWRlWm9vbU1vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgSW5zaWRlWm9vbU1vZGVsLnR5cGUgPSAnZGF0YVpvb20uaW5zaWRlJztcbiAgSW5zaWRlWm9vbU1vZGVsLmRlZmF1bHRPcHRpb24gPSBpbmhlcml0RGVmYXVsdE9wdGlvbihEYXRhWm9vbU1vZGVsLmRlZmF1bHRPcHRpb24sIHtcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgem9vbUxvY2s6IGZhbHNlLFxuICAgIHpvb21Pbk1vdXNlV2hlZWw6IHRydWUsXG4gICAgbW92ZU9uTW91c2VNb3ZlOiB0cnVlLFxuICAgIG1vdmVPbk1vdXNlV2hlZWw6IGZhbHNlLFxuICAgIHByZXZlbnREZWZhdWx0TW91c2VNb3ZlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gSW5zaWRlWm9vbU1vZGVsO1xufShEYXRhWm9vbU1vZGVsKTtcblxuZXhwb3J0IGRlZmF1bHQgSW5zaWRlWm9vbU1vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBEYXRhWm9vbVZpZXcgZnJvbSAnLi9EYXRhWm9vbVZpZXcnO1xuaW1wb3J0IHNsaWRlck1vdmUgZnJvbSAnLi4vaGVscGVyL3NsaWRlck1vdmUnO1xuaW1wb3J0ICogYXMgcm9hbXMgZnJvbSAnLi9yb2Ftcyc7XG5pbXBvcnQgeyBiaW5kIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcblxudmFyIEluc2lkZVpvb21WaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEluc2lkZVpvb21WaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEluc2lkZVpvb21WaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9ICdkYXRhWm9vbS5pbnNpZGUnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEluc2lkZVpvb21WaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmIChkYXRhWm9vbU1vZGVsLm5vVGFyZ2V0KCkpIHtcbiAgICAgIHRoaXMuX2NsZWFyKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEhlbmNlIHRoZSBgdGhyb3R0bGVgIHV0aWwgZW5zdXJlcyB0byBwcmVzZXJ2ZSBjb21tYW5kIG9yZGVyLFxuICAgIC8vIGhlcmUgc2ltcGx5IHVwZGF0aW5nIHJhbmdlIGFsbCB0aGUgdGltZSB3aWxsIG5vdCBjYXVzZSBtaXNzaW5nXG4gICAgLy8gYW55IG9mIHRoZSB0aGUgcm9hbSBjaGFuZ2UuXG5cblxuICAgIHRoaXMucmFuZ2UgPSBkYXRhWm9vbU1vZGVsLmdldFBlcmNlbnRSYW5nZSgpOyAvLyBSZXNldCBjb250cm9sbGVycy5cblxuICAgIHJvYW1zLnNldFZpZXdJbmZvVG9Db29yZFN5c1JlY29yZChhcGksIGRhdGFab29tTW9kZWwsIHtcbiAgICAgIHBhbjogYmluZChnZXRSYW5nZUhhbmRsZXJzLnBhbiwgdGhpcyksXG4gICAgICB6b29tOiBiaW5kKGdldFJhbmdlSGFuZGxlcnMuem9vbSwgdGhpcyksXG4gICAgICBzY3JvbGxNb3ZlOiBiaW5kKGdldFJhbmdlSGFuZGxlcnMuc2Nyb2xsTW92ZSwgdGhpcylcbiAgICB9KTtcbiAgfTtcblxuICBJbnNpZGVab29tVmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jbGVhcigpO1xuXG4gICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgSW5zaWRlWm9vbVZpZXcucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICByb2Ftcy5kaXNwb3NlQ29vcmRTeXNSZWNvcmRJZk5lZWRlZCh0aGlzLmFwaSwgdGhpcy5kYXRhWm9vbU1vZGVsKTtcbiAgICB0aGlzLnJhbmdlID0gbnVsbDtcbiAgfTtcblxuICBJbnNpZGVab29tVmlldy50eXBlID0gJ2RhdGFab29tLmluc2lkZSc7XG4gIHJldHVybiBJbnNpZGVab29tVmlldztcbn0oRGF0YVpvb21WaWV3KTtcblxudmFyIGdldFJhbmdlSGFuZGxlcnMgPSB7XG4gIHpvb206IGZ1bmN0aW9uIChjb29yZFN5c0luZm8sIGNvb3JkU3lzTWFpblR5cGUsIGNvbnRyb2xsZXIsIGUpIHtcbiAgICB2YXIgbGFzdFJhbmdlID0gdGhpcy5yYW5nZTtcbiAgICB2YXIgcmFuZ2UgPSBsYXN0UmFuZ2Uuc2xpY2UoKTsgLy8gQ2FsY3VsYXRlIHRyYW5zZm9ybSBieSB0aGUgZmlyc3QgYXhpcy5cblxuICAgIHZhciBheGlzTW9kZWwgPSBjb29yZFN5c0luZm8uYXhpc01vZGVsc1swXTtcblxuICAgIGlmICghYXhpc01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRpcmVjdGlvbkluZm8gPSBnZXREaXJlY3Rpb25JbmZvW2Nvb3JkU3lzTWFpblR5cGVdKG51bGwsIFtlLm9yaWdpblgsIGUub3JpZ2luWV0sIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRTeXNJbmZvKTtcbiAgICB2YXIgcGVyY2VudFBvaW50ID0gKGRpcmVjdGlvbkluZm8uc2lnbmFsID4gMCA/IGRpcmVjdGlvbkluZm8ucGl4ZWxTdGFydCArIGRpcmVjdGlvbkluZm8ucGl4ZWxMZW5ndGggLSBkaXJlY3Rpb25JbmZvLnBpeGVsIDogZGlyZWN0aW9uSW5mby5waXhlbCAtIGRpcmVjdGlvbkluZm8ucGl4ZWxTdGFydCkgLyBkaXJlY3Rpb25JbmZvLnBpeGVsTGVuZ3RoICogKHJhbmdlWzFdIC0gcmFuZ2VbMF0pICsgcmFuZ2VbMF07XG4gICAgdmFyIHNjYWxlID0gTWF0aC5tYXgoMSAvIGUuc2NhbGUsIDApO1xuICAgIHJhbmdlWzBdID0gKHJhbmdlWzBdIC0gcGVyY2VudFBvaW50KSAqIHNjYWxlICsgcGVyY2VudFBvaW50O1xuICAgIHJhbmdlWzFdID0gKHJhbmdlWzFdIC0gcGVyY2VudFBvaW50KSAqIHNjYWxlICsgcGVyY2VudFBvaW50OyAvLyBSZXN0cmljdCByYW5nZS5cblxuICAgIHZhciBtaW5NYXhTcGFuID0gdGhpcy5kYXRhWm9vbU1vZGVsLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpLmdldE1pbk1heFNwYW4oKTtcbiAgICBzbGlkZXJNb3ZlKDAsIHJhbmdlLCBbMCwgMTAwXSwgMCwgbWluTWF4U3Bhbi5taW5TcGFuLCBtaW5NYXhTcGFuLm1heFNwYW4pO1xuICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcblxuICAgIGlmIChsYXN0UmFuZ2VbMF0gIT09IHJhbmdlWzBdIHx8IGxhc3RSYW5nZVsxXSAhPT0gcmFuZ2VbMV0pIHtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gIH0sXG4gIHBhbjogbWFrZU1vdmVyKGZ1bmN0aW9uIChyYW5nZSwgYXhpc01vZGVsLCBjb29yZFN5c0luZm8sIGNvb3JkU3lzTWFpblR5cGUsIGNvbnRyb2xsZXIsIGUpIHtcbiAgICB2YXIgZGlyZWN0aW9uSW5mbyA9IGdldERpcmVjdGlvbkluZm9bY29vcmRTeXNNYWluVHlwZV0oW2Uub2xkWCwgZS5vbGRZXSwgW2UubmV3WCwgZS5uZXdZXSwgYXhpc01vZGVsLCBjb250cm9sbGVyLCBjb29yZFN5c0luZm8pO1xuICAgIHJldHVybiBkaXJlY3Rpb25JbmZvLnNpZ25hbCAqIChyYW5nZVsxXSAtIHJhbmdlWzBdKSAqIGRpcmVjdGlvbkluZm8ucGl4ZWwgLyBkaXJlY3Rpb25JbmZvLnBpeGVsTGVuZ3RoO1xuICB9KSxcbiAgc2Nyb2xsTW92ZTogbWFrZU1vdmVyKGZ1bmN0aW9uIChyYW5nZSwgYXhpc01vZGVsLCBjb29yZFN5c0luZm8sIGNvb3JkU3lzTWFpblR5cGUsIGNvbnRyb2xsZXIsIGUpIHtcbiAgICB2YXIgZGlyZWN0aW9uSW5mbyA9IGdldERpcmVjdGlvbkluZm9bY29vcmRTeXNNYWluVHlwZV0oWzAsIDBdLCBbZS5zY3JvbGxEZWx0YSwgZS5zY3JvbGxEZWx0YV0sIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRTeXNJbmZvKTtcbiAgICByZXR1cm4gZGlyZWN0aW9uSW5mby5zaWduYWwgKiAocmFuZ2VbMV0gLSByYW5nZVswXSkgKiBlLnNjcm9sbERlbHRhO1xuICB9KVxufTtcblxuZnVuY3Rpb24gbWFrZU1vdmVyKGdldFBlcmNlbnREZWx0YSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGNvb3JkU3lzSW5mbywgY29vcmRTeXNNYWluVHlwZSwgY29udHJvbGxlciwgZSkge1xuICAgIHZhciBsYXN0UmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgIHZhciByYW5nZSA9IGxhc3RSYW5nZS5zbGljZSgpOyAvLyBDYWxjdWxhdGUgdHJhbnNmb3JtIGJ5IHRoZSBmaXJzdCBheGlzLlxuXG4gICAgdmFyIGF4aXNNb2RlbCA9IGNvb3JkU3lzSW5mby5heGlzTW9kZWxzWzBdO1xuXG4gICAgaWYgKCFheGlzTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGVyY2VudERlbHRhID0gZ2V0UGVyY2VudERlbHRhKHJhbmdlLCBheGlzTW9kZWwsIGNvb3JkU3lzSW5mbywgY29vcmRTeXNNYWluVHlwZSwgY29udHJvbGxlciwgZSk7XG4gICAgc2xpZGVyTW92ZShwZXJjZW50RGVsdGEsIHJhbmdlLCBbMCwgMTAwXSwgJ2FsbCcpO1xuICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcblxuICAgIGlmIChsYXN0UmFuZ2VbMF0gIT09IHJhbmdlWzBdIHx8IGxhc3RSYW5nZVsxXSAhPT0gcmFuZ2VbMV0pIHtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBnZXREaXJlY3Rpb25JbmZvID0ge1xuICBncmlkOiBmdW5jdGlvbiAob2xkUG9pbnQsIG5ld1BvaW50LCBheGlzTW9kZWwsIGNvbnRyb2xsZXIsIGNvb3JkU3lzSW5mbykge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIHZhciByZWN0ID0gY29vcmRTeXNJbmZvLm1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpO1xuICAgIG9sZFBvaW50ID0gb2xkUG9pbnQgfHwgWzAsIDBdO1xuXG4gICAgaWYgKGF4aXMuZGltID09PSAneCcpIHtcbiAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzBdIC0gb2xkUG9pbnRbMF07XG4gICAgICByZXQucGl4ZWxMZW5ndGggPSByZWN0LndpZHRoO1xuICAgICAgcmV0LnBpeGVsU3RhcnQgPSByZWN0Lng7XG4gICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gMSA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBheGlzLmRpbSA9PT0gJ3knXG4gICAgICByZXQucGl4ZWwgPSBuZXdQb2ludFsxXSAtIG9sZFBvaW50WzFdO1xuICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gcmVjdC5oZWlnaHQ7XG4gICAgICByZXQucGl4ZWxTdGFydCA9IHJlY3QueTtcbiAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgcG9sYXI6IGZ1bmN0aW9uIChvbGRQb2ludCwgbmV3UG9pbnQsIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRTeXNJbmZvKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICB2YXIgcmV0ID0ge307XG4gICAgdmFyIHBvbGFyID0gY29vcmRTeXNJbmZvLm1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIHJhZGl1c0V4dGVudCA9IHBvbGFyLmdldFJhZGl1c0F4aXMoKS5nZXRFeHRlbnQoKTtcbiAgICB2YXIgYW5nbGVFeHRlbnQgPSBwb2xhci5nZXRBbmdsZUF4aXMoKS5nZXRFeHRlbnQoKTtcbiAgICBvbGRQb2ludCA9IG9sZFBvaW50ID8gcG9sYXIucG9pbnRUb0Nvb3JkKG9sZFBvaW50KSA6IFswLCAwXTtcbiAgICBuZXdQb2ludCA9IHBvbGFyLnBvaW50VG9Db29yZChuZXdQb2ludCk7XG5cbiAgICBpZiAoYXhpc01vZGVsLm1haW5UeXBlID09PSAncmFkaXVzQXhpcycpIHtcbiAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzBdIC0gb2xkUG9pbnRbMF07IC8vIHJldC5waXhlbExlbmd0aCA9IE1hdGguYWJzKHJhZGl1c0V4dGVudFsxXSAtIHJhZGl1c0V4dGVudFswXSk7XG4gICAgICAvLyByZXQucGl4ZWxTdGFydCA9IE1hdGgubWluKHJhZGl1c0V4dGVudFswXSwgcmFkaXVzRXh0ZW50WzFdKTtcblxuICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gcmFkaXVzRXh0ZW50WzFdIC0gcmFkaXVzRXh0ZW50WzBdO1xuICAgICAgcmV0LnBpeGVsU3RhcnQgPSByYWRpdXNFeHRlbnRbMF07XG4gICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gMSA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAnYW5nbGVBeGlzJ1xuICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMV0gLSBvbGRQb2ludFsxXTsgLy8gcmV0LnBpeGVsTGVuZ3RoID0gTWF0aC5hYnMoYW5nbGVFeHRlbnRbMV0gLSBhbmdsZUV4dGVudFswXSk7XG4gICAgICAvLyByZXQucGl4ZWxTdGFydCA9IE1hdGgubWluKGFuZ2xlRXh0ZW50WzBdLCBhbmdsZUV4dGVudFsxXSk7XG5cbiAgICAgIHJldC5waXhlbExlbmd0aCA9IGFuZ2xlRXh0ZW50WzFdIC0gYW5nbGVFeHRlbnRbMF07XG4gICAgICByZXQucGl4ZWxTdGFydCA9IGFuZ2xlRXh0ZW50WzBdO1xuICAgICAgcmV0LnNpZ25hbCA9IGF4aXMuaW52ZXJzZSA/IC0xIDogMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICBzaW5nbGVBeGlzOiBmdW5jdGlvbiAob2xkUG9pbnQsIG5ld1BvaW50LCBheGlzTW9kZWwsIGNvbnRyb2xsZXIsIGNvb3JkU3lzSW5mbykge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgdmFyIHJlY3QgPSBjb29yZFN5c0luZm8ubW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG9sZFBvaW50ID0gb2xkUG9pbnQgfHwgWzAsIDBdO1xuXG4gICAgaWYgKGF4aXMub3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzBdIC0gb2xkUG9pbnRbMF07XG4gICAgICByZXQucGl4ZWxMZW5ndGggPSByZWN0LndpZHRoO1xuICAgICAgcmV0LnBpeGVsU3RhcnQgPSByZWN0Lng7XG4gICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gMSA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAndmVydGljYWwnXG4gICAgICByZXQucGl4ZWwgPSBuZXdQb2ludFsxXSAtIG9sZFBvaW50WzFdO1xuICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gcmVjdC5oZWlnaHQ7XG4gICAgICByZXQucGl4ZWxTdGFydCA9IHJlY3QueTtcbiAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IEluc2lkZVpvb21WaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBEYXRhWm9vbU1vZGVsIGZyb20gJy4vRGF0YVpvb21Nb2RlbCc7XG5cbnZhciBTZWxlY3REYXRhWm9vbU1vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNlbGVjdERhdGFab29tTW9kZWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU2VsZWN0RGF0YVpvb21Nb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBTZWxlY3REYXRhWm9vbU1vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU2VsZWN0RGF0YVpvb21Nb2RlbC50eXBlID0gJ2RhdGFab29tLnNlbGVjdCc7XG4gIHJldHVybiBTZWxlY3REYXRhWm9vbU1vZGVsO1xufShEYXRhWm9vbU1vZGVsKTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0RGF0YVpvb21Nb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgRGF0YVpvb21WaWV3IGZyb20gJy4vRGF0YVpvb21WaWV3JztcblxudmFyIFNlbGVjdERhdGFab29tVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTZWxlY3REYXRhWm9vbVZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU2VsZWN0RGF0YVpvb21WaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IFNlbGVjdERhdGFab29tVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFNlbGVjdERhdGFab29tVmlldy50eXBlID0gJ2RhdGFab29tLnNlbGVjdCc7XG4gIHJldHVybiBTZWxlY3REYXRhWm9vbVZpZXc7XG59KERhdGFab29tVmlldyk7XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdERhdGFab29tVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgRGF0YVpvb21Nb2RlbCBmcm9tICcuL0RhdGFab29tTW9kZWwnO1xuaW1wb3J0IHsgaW5oZXJpdERlZmF1bHRPcHRpb24gfSBmcm9tICcuLi8uLi91dGlsL2NvbXBvbmVudCc7XG5cbnZhciBTbGlkZXJab29tTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2xpZGVyWm9vbU1vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFNsaWRlclpvb21Nb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBTbGlkZXJab29tTW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBTbGlkZXJab29tTW9kZWwudHlwZSA9ICdkYXRhWm9vbS5zbGlkZXInO1xuICBTbGlkZXJab29tTW9kZWwubGF5b3V0TW9kZSA9ICdib3gnO1xuICBTbGlkZXJab29tTW9kZWwuZGVmYXVsdE9wdGlvbiA9IGluaGVyaXREZWZhdWx0T3B0aW9uKERhdGFab29tTW9kZWwuZGVmYXVsdE9wdGlvbiwge1xuICAgIHNob3c6IHRydWUsXG4gICAgLy8gZGVhdWx0IHZhbHVlIGNhbiBvbmx5IGJlIGRyaXZlZCBpbiB2aWV3IHN0YWdlLlxuICAgIHJpZ2h0OiAncGgnLFxuICAgIHRvcDogJ3BoJyxcbiAgICB3aWR0aDogJ3BoJyxcbiAgICBoZWlnaHQ6ICdwaCcsXG4gICAgbGVmdDogbnVsbCxcbiAgICBib3R0b206IG51bGwsXG4gICAgYm9yZGVyQ29sb3I6ICcjZDJkYmVlJyxcbiAgICBib3JkZXJSYWRpdXM6IDMsXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSg0Nyw2OSw4NCwwKScsXG4gICAgLy8gZGF0YUJhY2tncm91bmRDb2xvcjogJyNkZGQnLFxuICAgIGRhdGFCYWNrZ3JvdW5kOiB7XG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgY29sb3I6ICcjZDJkYmVlJyxcbiAgICAgICAgd2lkdGg6IDAuNVxuICAgICAgfSxcbiAgICAgIGFyZWFTdHlsZToge1xuICAgICAgICBjb2xvcjogJyNkMmRiZWUnLFxuICAgICAgICBvcGFjaXR5OiAwLjJcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdGVkRGF0YUJhY2tncm91bmQ6IHtcbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBjb2xvcjogJyM4ZmIwZjcnLFxuICAgICAgICB3aWR0aDogMC41XG4gICAgICB9LFxuICAgICAgYXJlYVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAnIzhmYjBmNycsXG4gICAgICAgIG9wYWNpdHk6IDAuMlxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQ29sb3Igb2Ygc2VsZWN0ZWQgd2luZG93LlxuICAgIGZpbGxlckNvbG9yOiAncmdiYSgxMzUsMTc1LDI3NCwwLjIpJyxcbiAgICBoYW5kbGVJY29uOiAncGF0aDovL00tOS4zNSwzNC41NlY0Mm0wLTQwVjkuNW0tMiwwaDRhMiwyLDAsMCwxLDIsMnYyMWEyLDIsMCwwLDEtMiwyaC00YTIsMiwwLDAsMS0yLTJ2LTIxQTIsMiwwLDAsMS0xMS4zNSw5LjVaJyxcbiAgICAvLyBQZXJjZW50IG9mIHRoZSBzbGlkZXIgaGVpZ2h0XG4gICAgaGFuZGxlU2l6ZTogJzEwMCUnLFxuICAgIGhhbmRsZVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgYm9yZGVyQ29sb3I6ICcjQUNCOEQxJ1xuICAgIH0sXG4gICAgbW92ZUhhbmRsZVNpemU6IDcsXG4gICAgbW92ZUhhbmRsZUljb246ICdwYXRoOi8vTS0zMjAuOS01MEwtMzIwLjktNTBjMTguMSwwLDI3LjEsOSwyNy4xLDI3LjFWODUuN2MwLDE4LjEtOSwyNy4xLTI3LjEsMjcuMWwwLDBjLTE4LjEsMC0yNy4xLTktMjcuMS0yNy4xVi0yMi45Qy0zNDgtNDEtMzM5LTUwLTMyMC45LTUweiBNLTIxMi4zLTUwTC0yMTIuMy01MGMxOC4xLDAsMjcuMSw5LDI3LjEsMjcuMVY4NS43YzAsMTguMS05LDI3LjEtMjcuMSwyNy4xbDAsMGMtMTguMSwwLTI3LjEtOS0yNy4xLTI3LjFWLTIyLjlDLTIzOS40LTQxLTIzMC40LTUwLTIxMi4zLTUweiBNLTEwMy43LTUwTC0xMDMuNy01MGMxOC4xLDAsMjcuMSw5LDI3LjEsMjcuMVY4NS43YzAsMTguMS05LDI3LjEtMjcuMSwyNy4xbDAsMGMtMTguMSwwLTI3LjEtOS0yNy4xLTI3LjFWLTIyLjlDLTEzMC45LTQxLTEyMS44LTUwLTEwMy43LTUweicsXG4gICAgbW92ZUhhbmRsZVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNEMkRCRUUnLFxuICAgICAgb3BhY2l0eTogMC43XG4gICAgfSxcbiAgICBzaG93RGV0YWlsOiB0cnVlLFxuICAgIHNob3dEYXRhU2hhZG93OiAnYXV0bycsXG4gICAgcmVhbHRpbWU6IHRydWUsXG4gICAgem9vbUxvY2s6IGZhbHNlLFxuICAgIHRleHRTdHlsZToge1xuICAgICAgY29sb3I6ICcjNkU3MDc5J1xuICAgIH0sXG4gICAgYnJ1c2hTZWxlY3Q6IHRydWUsXG4gICAgYnJ1c2hTdHlsZToge1xuICAgICAgY29sb3I6ICdyZ2JhKDEzNSwxNzUsMjc0LDAuMTUpJ1xuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIGhhbmRsZVN0eWxlOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzhGQjBGNydcbiAgICAgIH0sXG4gICAgICBtb3ZlSGFuZGxlU3R5bGU6IHtcbiAgICAgICAgY29sb3I6ICcjOEZCMEY3J1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBTbGlkZXJab29tTW9kZWw7XG59KERhdGFab29tTW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBTbGlkZXJab29tTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgYmluZCwgZWFjaCwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGluZGV4T2YgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgZXZlbnRUb29sIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0ICogYXMgdGhyb3R0bGUgZnJvbSAnLi4vLi4vdXRpbC90aHJvdHRsZSc7XG5pbXBvcnQgRGF0YVpvb21WaWV3IGZyb20gJy4vRGF0YVpvb21WaWV3JztcbmltcG9ydCB7IGxpbmVhck1hcCwgYXNjLCBwYXJzZVBlcmNlbnQgfSBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG5pbXBvcnQgKiBhcyBsYXlvdXQgZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQnO1xuaW1wb3J0IHNsaWRlck1vdmUgZnJvbSAnLi4vaGVscGVyL3NsaWRlck1vdmUnO1xuaW1wb3J0IHsgZ2V0QXhpc01haW5UeXBlLCBjb2xsZWN0UmVmZXJDb29yZFN5c01vZGVsSW5mbyB9IGZyb20gJy4vaGVscGVyJztcbmltcG9ydCB7IGVuYWJsZUhvdmVyRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcyc7XG5pbXBvcnQgeyBjcmVhdGVTeW1ib2wsIHN5bWJvbEJ1aWxkUHJveGllcyB9IGZyb20gJy4uLy4uL3V0aWwvc3ltYm9sJztcbmltcG9ydCB7IGRlcHJlY2F0ZUxvZyB9IGZyb20gJy4uLy4uL3V0aWwvbG9nJztcbnZhciBSZWN0ID0gZ3JhcGhpYy5SZWN0OyAvLyBDb25zdGFudHNcblxudmFyIERFRkFVTFRfTE9DQVRJT05fRURHRV9HQVAgPSA3O1xudmFyIERFRkFVTFRfRlJBTUVfQk9SREVSX1dJRFRIID0gMTtcbnZhciBERUZBVUxUX0ZJTExFUl9TSVpFID0gMzA7XG52YXIgREVGQVVMVF9NT1ZFX0hBTkRMRV9TSVpFID0gNztcbnZhciBIT1JJWk9OVEFMID0gJ2hvcml6b250YWwnO1xudmFyIFZFUlRJQ0FMID0gJ3ZlcnRpY2FsJztcbnZhciBMQUJFTF9HQVAgPSA1O1xudmFyIFNIT1dfREFUQV9TSEFET1dfU0VSSUVTX1RZUEUgPSBbJ2xpbmUnLCAnYmFyJywgJ2NhbmRsZXN0aWNrJywgJ3NjYXR0ZXInXTtcbnZhciBSRUFMVElNRV9BTklNQVRJT05fQ09ORklHID0ge1xuICBlYXNpbmc6ICdjdWJpY091dCcsXG4gIGR1cmF0aW9uOiAxMDBcbn07XG5cbnZhciBTbGlkZXJab29tVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTbGlkZXJab29tVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTbGlkZXJab29tVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBTbGlkZXJab29tVmlldy50eXBlO1xuICAgIF90aGlzLl9kaXNwbGF5YWJsZXMgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLmFwaSA9IGFwaTsgLy8gQSB1bmlxdWUgaGFuZGxlciBmb3IgZWFjaCBkYXRhWm9vbSBjb21wb25lbnRcblxuICAgIHRoaXMuX29uQnJ1c2ggPSBiaW5kKHRoaXMuX29uQnJ1c2gsIHRoaXMpO1xuICAgIHRoaXMuX29uQnJ1c2hFbmQgPSBiaW5kKHRoaXMuX29uQnJ1c2hFbmQsIHRoaXMpO1xuICB9O1xuXG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRocm90dGxlLmNyZWF0ZU9yVXBkYXRlKHRoaXMsICdfZGlzcGF0Y2hab29tQWN0aW9uJywgZGF0YVpvb21Nb2RlbC5nZXQoJ3Rocm90dGxlJyksICdmaXhSYXRlJyk7XG4gICAgdGhpcy5fb3JpZW50ID0gZGF0YVpvb21Nb2RlbC5nZXRPcmllbnQoKTtcblxuICAgIGlmIChkYXRhWm9vbU1vZGVsLmdldCgnc2hvdycpID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YVpvb21Nb2RlbC5ub1RhcmdldCgpKSB7XG4gICAgICB0aGlzLl9jbGVhcigpO1xuXG4gICAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gTm90aWNlOiB0aGlzLl9yZXNldEludGVydmFsKCkgc2hvdWxkIG5vdCBiZSBleGVjdXRlZCB3aGVuIHBheWxvYWQudHlwZVxuICAgIC8vIGlzICdkYXRhWm9vbScsIG9yaWdpbiB0aGlzLl9yYW5nZSBzaG91bGQgYmUgbWFpbnRhaW5lZCwgb3RoZXJ3aXNlICdwYW4nXG4gICAgLy8gb3IgJ3pvb20nIGluZm8gd2lsbCBiZSBtaXNzZWQgYmVjYXVzZSBvZiAndGhyb3R0bGUnIG9mIHRoaXMuZGlzcGF0Y2hBY3Rpb24sXG5cblxuICAgIGlmICghcGF5bG9hZCB8fCBwYXlsb2FkLnR5cGUgIT09ICdkYXRhWm9vbScgfHwgcGF5bG9hZC5mcm9tICE9PSB0aGlzLnVpZCkge1xuICAgICAgdGhpcy5fYnVpbGRWaWV3KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlVmlldygpO1xuICB9O1xuXG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NsZWFyKCk7XG5cbiAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUuX2NsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm90dGxlLmNsZWFyKHRoaXMsICdfZGlzcGF0Y2hab29tQWN0aW9uJyk7XG4gICAgdmFyIHpyID0gdGhpcy5hcGkuZ2V0WnIoKTtcbiAgICB6ci5vZmYoJ21vdXNlbW92ZScsIHRoaXMuX29uQnJ1c2gpO1xuICAgIHpyLm9mZignbW91c2V1cCcsIHRoaXMuX29uQnJ1c2hFbmQpO1xuICB9O1xuXG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fYnVpbGRWaWV3ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGlzR3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHRoaXNHcm91cC5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLl9icnVzaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2Rpc3BsYXlhYmxlcy5icnVzaFJlY3QgPSBudWxsO1xuXG4gICAgdGhpcy5fcmVzZXRMb2NhdGlvbigpO1xuXG4gICAgdGhpcy5fcmVzZXRJbnRlcnZhbCgpO1xuXG4gICAgdmFyIGJhckdyb3VwID0gdGhpcy5fZGlzcGxheWFibGVzLnNsaWRlckdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcblxuICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQoKTtcblxuICAgIHRoaXMuX3JlbmRlckhhbmRsZSgpO1xuXG4gICAgdGhpcy5fcmVuZGVyRGF0YVNoYWRvdygpO1xuXG4gICAgdGhpc0dyb3VwLmFkZChiYXJHcm91cCk7XG5cbiAgICB0aGlzLl9wb3NpdGlvbkdyb3VwKCk7XG4gIH07XG5cbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl9yZXNldExvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBhcGkgPSB0aGlzLmFwaTtcbiAgICB2YXIgc2hvd01vdmVIYW5kbGUgPSBkYXRhWm9vbU1vZGVsLmdldCgnYnJ1c2hTZWxlY3QnKTtcbiAgICB2YXIgbW92ZUhhbmRsZVNpemUgPSBzaG93TW92ZUhhbmRsZSA/IERFRkFVTFRfTU9WRV9IQU5ETEVfU0laRSA6IDA7IC8vIElmIHNvbWUgb2YgeC95L3dpZHRoL2hlaWdodCBhcmUgbm90IHNwZWNpZmllZCxcbiAgICAvLyBhdXRvLWFkYXB0IGFjY29yZGluZyB0byB0YXJnZXQgZ3JpZC5cblxuICAgIHZhciBjb29yZFJlY3QgPSB0aGlzLl9maW5kQ29vcmRSZWN0KCk7XG5cbiAgICB2YXIgZWNTaXplID0ge1xuICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICB9OyAvLyBEZWZhdWx0IGFsaWduIGJ5IGNvb3JkaW5hdGUgc3lzdGVtIHJlY3QuXG5cbiAgICB2YXIgcG9zaXRpb25JbmZvID0gdGhpcy5fb3JpZW50ID09PSBIT1JJWk9OVEFMID8ge1xuICAgICAgLy8gV2h5IHVzaW5nICdyaWdodCcsIGJlY2F1c2UgcmlnaHQgc2hvdWxkIGJlIHVzZWQgaW4gdmVydGljYWwsXG4gICAgICAvLyBhbmQgaXQgaXMgYmV0dGVyIHRvIGJlIGNvbnNpc3RlbnQgZm9yIGRlYWxpbmcgd2l0aCBwb3NpdGlvbiBwYXJhbSBtZXJnZS5cbiAgICAgIHJpZ2h0OiBlY1NpemUud2lkdGggLSBjb29yZFJlY3QueCAtIGNvb3JkUmVjdC53aWR0aCxcbiAgICAgIHRvcDogZWNTaXplLmhlaWdodCAtIERFRkFVTFRfRklMTEVSX1NJWkUgLSBERUZBVUxUX0xPQ0FUSU9OX0VER0VfR0FQIC0gbW92ZUhhbmRsZVNpemUsXG4gICAgICB3aWR0aDogY29vcmRSZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiBERUZBVUxUX0ZJTExFUl9TSVpFXG4gICAgfSA6IHtcbiAgICAgIHJpZ2h0OiBERUZBVUxUX0xPQ0FUSU9OX0VER0VfR0FQLFxuICAgICAgdG9wOiBjb29yZFJlY3QueSxcbiAgICAgIHdpZHRoOiBERUZBVUxUX0ZJTExFUl9TSVpFLFxuICAgICAgaGVpZ2h0OiBjb29yZFJlY3QuaGVpZ2h0XG4gICAgfTsgLy8gRG8gbm90IHdyaXRlIGJhY2sgdG8gb3B0aW9uIGFuZCByZXBsYWNlIHZhbHVlICdwaCcsIGJlY2F1c2VcbiAgICAvLyB0aGUgJ3BoJyB2YWx1ZSBzaG91bGQgYmUgcmVjYWxjdWxhdGVkIHdoZW4gcmVzaXplLlxuXG4gICAgdmFyIGxheW91dFBhcmFtcyA9IGxheW91dC5nZXRMYXlvdXRQYXJhbXMoZGF0YVpvb21Nb2RlbC5vcHRpb24pOyAvLyBSZXBsYWNlIHRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cblxuICAgIGVhY2goWydyaWdodCcsICd0b3AnLCAnd2lkdGgnLCAnaGVpZ2h0J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAobGF5b3V0UGFyYW1zW25hbWVdID09PSAncGgnKSB7XG4gICAgICAgIGxheW91dFBhcmFtc1tuYW1lXSA9IHBvc2l0aW9uSW5mb1tuYW1lXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbGF5b3V0UmVjdCA9IGxheW91dC5nZXRMYXlvdXRSZWN0KGxheW91dFBhcmFtcywgZWNTaXplKTtcbiAgICB0aGlzLl9sb2NhdGlvbiA9IHtcbiAgICAgIHg6IGxheW91dFJlY3QueCxcbiAgICAgIHk6IGxheW91dFJlY3QueVxuICAgIH07XG4gICAgdGhpcy5fc2l6ZSA9IFtsYXlvdXRSZWN0LndpZHRoLCBsYXlvdXRSZWN0LmhlaWdodF07XG4gICAgdGhpcy5fb3JpZW50ID09PSBWRVJUSUNBTCAmJiB0aGlzLl9zaXplLnJldmVyc2UoKTtcbiAgfTtcblxuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUuX3Bvc2l0aW9uR3JvdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoaXNHcm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5fbG9jYXRpb247XG4gICAgdmFyIG9yaWVudCA9IHRoaXMuX29yaWVudDsgLy8gSnVzdCB1c2UgdGhlIGZpcnN0IGF4aXMgdG8gZGV0ZXJtaW5lIG1hcHBpbmcuXG5cbiAgICB2YXIgdGFyZ2V0QXhpc01vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsLmdldEZpcnN0VGFyZ2V0QXhpc01vZGVsKCk7XG4gICAgdmFyIGludmVyc2UgPSB0YXJnZXRBeGlzTW9kZWwgJiYgdGFyZ2V0QXhpc01vZGVsLmdldCgnaW52ZXJzZScpO1xuICAgIHZhciBzbGlkZXJHcm91cCA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5zbGlkZXJHcm91cDtcbiAgICB2YXIgb3RoZXJBeGlzSW52ZXJzZSA9ICh0aGlzLl9kYXRhU2hhZG93SW5mbyB8fCB7fSkub3RoZXJBeGlzSW52ZXJzZTsgLy8gVHJhbnNmb3JtIGJhckdyb3VwLlxuXG4gICAgc2xpZGVyR3JvdXAuYXR0cihvcmllbnQgPT09IEhPUklaT05UQUwgJiYgIWludmVyc2UgPyB7XG4gICAgICBzY2FsZVk6IG90aGVyQXhpc0ludmVyc2UgPyAxIDogLTEsXG4gICAgICBzY2FsZVg6IDFcbiAgICB9IDogb3JpZW50ID09PSBIT1JJWk9OVEFMICYmIGludmVyc2UgPyB7XG4gICAgICBzY2FsZVk6IG90aGVyQXhpc0ludmVyc2UgPyAxIDogLTEsXG4gICAgICBzY2FsZVg6IC0xXG4gICAgfSA6IG9yaWVudCA9PT0gVkVSVElDQUwgJiYgIWludmVyc2UgPyB7XG4gICAgICBzY2FsZVk6IG90aGVyQXhpc0ludmVyc2UgPyAtMSA6IDEsXG4gICAgICBzY2FsZVg6IDEsXG4gICAgICByb3RhdGlvbjogTWF0aC5QSSAvIDJcbiAgICB9IC8vIERvbnQgdXNlIE1hdGguUEksIGNvbnNpZGVyaW5nIHNoYWRvdyBkaXJlY3Rpb24uXG4gICAgOiB7XG4gICAgICBzY2FsZVk6IG90aGVyQXhpc0ludmVyc2UgPyAtMSA6IDEsXG4gICAgICBzY2FsZVg6IC0xLFxuICAgICAgcm90YXRpb246IE1hdGguUEkgLyAyXG4gICAgfSk7IC8vIFBvc2l0aW9uIGJhckdyb3VwXG5cbiAgICB2YXIgcmVjdCA9IHRoaXNHcm91cC5nZXRCb3VuZGluZ1JlY3QoW3NsaWRlckdyb3VwXSk7XG4gICAgdGhpc0dyb3VwLnggPSBsb2NhdGlvbi54IC0gcmVjdC54O1xuICAgIHRoaXNHcm91cC55ID0gbG9jYXRpb24ueSAtIHJlY3QueTtcbiAgICB0aGlzR3JvdXAubWFya1JlZHJhdygpO1xuICB9O1xuXG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fZ2V0Vmlld0V4dGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gWzAsIHRoaXMuX3NpemVbMF1dO1xuICB9O1xuXG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fcmVuZGVyQmFja2dyb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgdmFyIGJhckdyb3VwID0gdGhpcy5fZGlzcGxheWFibGVzLnNsaWRlckdyb3VwO1xuICAgIHZhciBicnVzaFNlbGVjdCA9IGRhdGFab29tTW9kZWwuZ2V0KCdicnVzaFNlbGVjdCcpO1xuICAgIGJhckdyb3VwLmFkZChuZXcgUmVjdCh7XG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICBzaGFwZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogc2l6ZVswXSxcbiAgICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZmlsbDogZGF0YVpvb21Nb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpXG4gICAgICB9LFxuICAgICAgejI6IC00MFxuICAgIH0pKTsgLy8gQ2xpY2sgcGFuZWwsIG92ZXIgc2hhZG93LCBiZWxvdyBoYW5kbGVzLlxuXG4gICAgdmFyIGNsaWNrUGFuZWwgPSBuZXcgUmVjdCh7XG4gICAgICBzaGFwZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogc2l6ZVswXSxcbiAgICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50J1xuICAgICAgfSxcbiAgICAgIHoyOiAwLFxuICAgICAgb25jbGljazogYmluZCh0aGlzLl9vbkNsaWNrUGFuZWwsIHRoaXMpXG4gICAgfSk7XG4gICAgdmFyIHpyID0gdGhpcy5hcGkuZ2V0WnIoKTtcblxuICAgIGlmIChicnVzaFNlbGVjdCkge1xuICAgICAgY2xpY2tQYW5lbC5vbignbW91c2Vkb3duJywgdGhpcy5fb25CcnVzaFN0YXJ0LCB0aGlzKTtcbiAgICAgIGNsaWNrUGFuZWwuY3Vyc29yID0gJ2Nyb3NzaGFpcic7XG4gICAgICB6ci5vbignbW91c2Vtb3ZlJywgdGhpcy5fb25CcnVzaCk7XG4gICAgICB6ci5vbignbW91c2V1cCcsIHRoaXMuX29uQnJ1c2hFbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB6ci5vZmYoJ21vdXNlbW92ZScsIHRoaXMuX29uQnJ1c2gpO1xuICAgICAgenIub2ZmKCdtb3VzZXVwJywgdGhpcy5fb25CcnVzaEVuZCk7XG4gICAgfVxuXG4gICAgYmFyR3JvdXAuYWRkKGNsaWNrUGFuZWwpO1xuICB9O1xuXG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fcmVuZGVyRGF0YVNoYWRvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMuX2RhdGFTaGFkb3dJbmZvID0gdGhpcy5fcHJlcGFyZURhdGFTaGFkb3dJbmZvKCk7XG5cbiAgICB0aGlzLl9kaXNwbGF5YWJsZXMuZGF0YVNoYWRvd1NlZ3MgPSBbXTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICB2YXIgc2VyaWVzTW9kZWwgPSBpbmZvLnNlcmllcztcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldFJhd0RhdGEoKTtcbiAgICB2YXIgb3RoZXJEaW0gPSBzZXJpZXNNb2RlbC5nZXRTaGFkb3dEaW0gPyBzZXJpZXNNb2RlbC5nZXRTaGFkb3dEaW0oKSAvLyBAc2VlIGNhbmRsZXN0aWNrXG4gICAgOiBpbmZvLm90aGVyRGltO1xuXG4gICAgaWYgKG90aGVyRGltID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3RoZXJEYXRhRXh0ZW50ID0gZGF0YS5nZXREYXRhRXh0ZW50KG90aGVyRGltKTsgLy8gTmljZSBleHRlbnQuXG5cbiAgICB2YXIgb3RoZXJPZmZzZXQgPSAob3RoZXJEYXRhRXh0ZW50WzFdIC0gb3RoZXJEYXRhRXh0ZW50WzBdKSAqIDAuMztcbiAgICBvdGhlckRhdGFFeHRlbnQgPSBbb3RoZXJEYXRhRXh0ZW50WzBdIC0gb3RoZXJPZmZzZXQsIG90aGVyRGF0YUV4dGVudFsxXSArIG90aGVyT2Zmc2V0XTtcbiAgICB2YXIgb3RoZXJTaGFkb3dFeHRlbnQgPSBbMCwgc2l6ZVsxXV07XG4gICAgdmFyIHRoaXNTaGFkb3dFeHRlbnQgPSBbMCwgc2l6ZVswXV07XG4gICAgdmFyIGFyZWFQb2ludHMgPSBbW3NpemVbMF0sIDBdLCBbMCwgMF1dO1xuICAgIHZhciBsaW5lUG9pbnRzID0gW107XG4gICAgdmFyIHN0ZXAgPSB0aGlzU2hhZG93RXh0ZW50WzFdIC8gKGRhdGEuY291bnQoKSAtIDEpO1xuICAgIHZhciB0aGlzQ29vcmQgPSAwOyAvLyBPcHRpbWl6ZSBmb3IgbGFyZ2UgZGF0YSBzaGFkb3dcblxuICAgIHZhciBzdHJpZGUgPSBNYXRoLnJvdW5kKGRhdGEuY291bnQoKSAvIHNpemVbMF0pO1xuICAgIHZhciBsYXN0SXNFbXB0eTtcbiAgICBkYXRhLmVhY2goW290aGVyRGltXSwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgaWYgKHN0cmlkZSA+IDAgJiYgaW5kZXggJSBzdHJpZGUpIHtcbiAgICAgICAgdGhpc0Nvb3JkICs9IHN0ZXA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRklYTUVcbiAgICAgIC8vIFNob3VsZCBjb25zaWRlciBheGlzLm1pbi9heGlzLm1heCB3aGVuIGRyYXdpbmcgZGF0YVNoYWRvdy5cbiAgICAgIC8vIEZJWE1FXG4gICAgICAvLyDlupTor6Xkvb/nlKjnu5/kuIDnmoTnqbrliKTmlq3vvJ/ov5jmmK/lnKhsaXN06YeM6L+b6KGM56m65Yik5pat77yfXG5cblxuICAgICAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJyc7IC8vIFNlZSAjNDIzNS5cblxuICAgICAgdmFyIG90aGVyQ29vcmQgPSBpc0VtcHR5ID8gMCA6IGxpbmVhck1hcCh2YWx1ZSwgb3RoZXJEYXRhRXh0ZW50LCBvdGhlclNoYWRvd0V4dGVudCwgdHJ1ZSk7IC8vIEF0dGVtcHQgdG8gZHJhdyBkYXRhIHNoYWRvdyBwcmVjaXNlbHkgd2hlbiB0aGVyZSBhcmUgZW1wdHkgdmFsdWUuXG5cbiAgICAgIGlmIChpc0VtcHR5ICYmICFsYXN0SXNFbXB0eSAmJiBpbmRleCkge1xuICAgICAgICBhcmVhUG9pbnRzLnB1c2goW2FyZWFQb2ludHNbYXJlYVBvaW50cy5sZW5ndGggLSAxXVswXSwgMF0pO1xuICAgICAgICBsaW5lUG9pbnRzLnB1c2goW2xpbmVQb2ludHNbbGluZVBvaW50cy5sZW5ndGggLSAxXVswXSwgMF0pO1xuICAgICAgfSBlbHNlIGlmICghaXNFbXB0eSAmJiBsYXN0SXNFbXB0eSkge1xuICAgICAgICBhcmVhUG9pbnRzLnB1c2goW3RoaXNDb29yZCwgMF0pO1xuICAgICAgICBsaW5lUG9pbnRzLnB1c2goW3RoaXNDb29yZCwgMF0pO1xuICAgICAgfVxuXG4gICAgICBhcmVhUG9pbnRzLnB1c2goW3RoaXNDb29yZCwgb3RoZXJDb29yZF0pO1xuICAgICAgbGluZVBvaW50cy5wdXNoKFt0aGlzQ29vcmQsIG90aGVyQ29vcmRdKTtcbiAgICAgIHRoaXNDb29yZCArPSBzdGVwO1xuICAgICAgbGFzdElzRW1wdHkgPSBpc0VtcHR5O1xuICAgIH0pO1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0YVNoYWRvd0dyb3VwKGlzU2VsZWN0ZWRBcmVhKSB7XG4gICAgICB2YXIgbW9kZWwgPSBkYXRhWm9vbU1vZGVsLmdldE1vZGVsKGlzU2VsZWN0ZWRBcmVhID8gJ3NlbGVjdGVkRGF0YUJhY2tncm91bmQnIDogJ2RhdGFCYWNrZ3JvdW5kJyk7XG4gICAgICB2YXIgZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgICAgdmFyIHBvbHlnb24gPSBuZXcgZ3JhcGhpYy5Qb2x5Z29uKHtcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICBwb2ludHM6IGFyZWFQb2ludHNcbiAgICAgICAgfSxcbiAgICAgICAgc2VnbWVudElnbm9yZVRocmVzaG9sZDogMSxcbiAgICAgICAgc3R5bGU6IG1vZGVsLmdldE1vZGVsKCdhcmVhU3R5bGUnKS5nZXRBcmVhU3R5bGUoKSxcbiAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICB6MjogLTIwXG4gICAgICB9KTtcbiAgICAgIHZhciBwb2x5bGluZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHtcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICBwb2ludHM6IGxpbmVQb2ludHNcbiAgICAgICAgfSxcbiAgICAgICAgc2VnbWVudElnbm9yZVRocmVzaG9sZDogMSxcbiAgICAgICAgc3R5bGU6IG1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKSxcbiAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICB6MjogLTE5XG4gICAgICB9KTtcbiAgICAgIGdyb3VwLmFkZChwb2x5Z29uKTtcbiAgICAgIGdyb3VwLmFkZChwb2x5bGluZSk7XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSAvLyBsZXQgZGF0YUJhY2tncm91bmRNb2RlbCA9IGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoJ2RhdGFCYWNrZ3JvdW5kJyk7XG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBjcmVhdGVEYXRhU2hhZG93R3JvdXAoaSA9PT0gMSk7XG5cbiAgICAgIHRoaXMuX2Rpc3BsYXlhYmxlcy5zbGlkZXJHcm91cC5hZGQoZ3JvdXApO1xuXG4gICAgICB0aGlzLl9kaXNwbGF5YWJsZXMuZGF0YVNoYWRvd1NlZ3MucHVzaChncm91cCk7XG4gICAgfVxuICB9O1xuXG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fcHJlcGFyZURhdGFTaGFkb3dJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBzaG93RGF0YVNoYWRvdyA9IGRhdGFab29tTW9kZWwuZ2V0KCdzaG93RGF0YVNoYWRvdycpO1xuXG4gICAgaWYgKHNob3dEYXRhU2hhZG93ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmluZCBhIHJlcHJlc2VudGF0aXZlIHNlcmllcy5cblxuXG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChheGlzRGltLCBheGlzSW5kZXgpIHtcbiAgICAgIHZhciBzZXJpZXNNb2RlbHMgPSBkYXRhWm9vbU1vZGVsLmdldEF4aXNQcm94eShheGlzRGltLCBheGlzSW5kZXgpLmdldFRhcmdldFNlcmllc01vZGVscygpO1xuICAgICAgZWFjaChzZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3dEYXRhU2hhZG93ICE9PSB0cnVlICYmIGluZGV4T2YoU0hPV19EQVRBX1NIQURPV19TRVJJRVNfVFlQRSwgc2VyaWVzTW9kZWwuZ2V0KCd0eXBlJykpIDwgMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGlzQXhpcyA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KGdldEF4aXNNYWluVHlwZShheGlzRGltKSwgYXhpc0luZGV4KS5heGlzO1xuICAgICAgICB2YXIgb3RoZXJEaW0gPSBnZXRPdGhlckRpbShheGlzRGltKTtcbiAgICAgICAgdmFyIG90aGVyQXhpc0ludmVyc2U7XG4gICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICAgICAgaWYgKG90aGVyRGltICE9IG51bGwgJiYgY29vcmRTeXMuZ2V0T3RoZXJBeGlzKSB7XG4gICAgICAgICAgb3RoZXJBeGlzSW52ZXJzZSA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyh0aGlzQXhpcykuaW52ZXJzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyRGltID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLm1hcERpbWVuc2lvbihvdGhlckRpbSk7XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICB0aGlzQXhpczogdGhpc0F4aXMsXG4gICAgICAgICAgc2VyaWVzOiBzZXJpZXNNb2RlbCxcbiAgICAgICAgICB0aGlzRGltOiBheGlzRGltLFxuICAgICAgICAgIG90aGVyRGltOiBvdGhlckRpbSxcbiAgICAgICAgICBvdGhlckF4aXNJbnZlcnNlOiBvdGhlckF4aXNJbnZlcnNlXG4gICAgICAgIH07XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fcmVuZGVySGFuZGxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGlzR3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBkaXNwbGF5YWJsZXMgPSB0aGlzLl9kaXNwbGF5YWJsZXM7XG4gICAgdmFyIGhhbmRsZXMgPSBkaXNwbGF5YWJsZXMuaGFuZGxlcyA9IFtudWxsLCBudWxsXTtcbiAgICB2YXIgaGFuZGxlTGFiZWxzID0gZGlzcGxheWFibGVzLmhhbmRsZUxhYmVscyA9IFtudWxsLCBudWxsXTtcbiAgICB2YXIgc2xpZGVyR3JvdXAgPSB0aGlzLl9kaXNwbGF5YWJsZXMuc2xpZGVyR3JvdXA7XG4gICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBhcGkgPSB0aGlzLmFwaTtcbiAgICB2YXIgYm9yZGVyUmFkaXVzID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2JvcmRlclJhZGl1cycpIHx8IDA7XG4gICAgdmFyIGJydXNoU2VsZWN0ID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2JydXNoU2VsZWN0Jyk7XG4gICAgdmFyIGZpbGxlciA9IGRpc3BsYXlhYmxlcy5maWxsZXIgPSBuZXcgUmVjdCh7XG4gICAgICBzaWxlbnQ6IGJydXNoU2VsZWN0LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZmlsbDogZGF0YVpvb21Nb2RlbC5nZXQoJ2ZpbGxlckNvbG9yJylcbiAgICAgIH0sXG4gICAgICB0ZXh0Q29uZmlnOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnaW5zaWRlJ1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNsaWRlckdyb3VwLmFkZChmaWxsZXIpOyAvLyBGcmFtZSBib3JkZXIuXG5cbiAgICBzbGlkZXJHcm91cC5hZGQobmV3IFJlY3Qoe1xuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgc3ViUGl4ZWxPcHRpbWl6ZTogdHJ1ZSxcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiBzaXplWzBdLFxuICAgICAgICBoZWlnaHQ6IHNpemVbMV0sXG4gICAgICAgIHI6IGJvcmRlclJhZGl1c1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHN0cm9rZTogZGF0YVpvb21Nb2RlbC5nZXQoJ2RhdGFCYWNrZ3JvdW5kQ29sb3InKSAvLyBkZXByZWNhdGVkIG9wdGlvblxuICAgICAgICB8fCBkYXRhWm9vbU1vZGVsLmdldCgnYm9yZGVyQ29sb3InKSxcbiAgICAgICAgbGluZVdpZHRoOiBERUZBVUxUX0ZSQU1FX0JPUkRFUl9XSURUSCxcbiAgICAgICAgZmlsbDogJ3JnYmEoMCwwLDAsMCknXG4gICAgICB9XG4gICAgfSkpOyAvLyBMZWZ0IGFuZCByaWdodCBoYW5kbGUgdG8gcmVzaXplXG5cbiAgICBlYWNoKFswLCAxXSwgZnVuY3Rpb24gKGhhbmRsZUluZGV4KSB7XG4gICAgICB2YXIgaWNvblN0ciA9IGRhdGFab29tTW9kZWwuZ2V0KCdoYW5kbGVJY29uJyk7XG5cbiAgICAgIGlmICghc3ltYm9sQnVpbGRQcm94aWVzW2ljb25TdHJdICYmIGljb25TdHIuaW5kZXhPZigncGF0aDovLycpIDwgMCAmJiBpY29uU3RyLmluZGV4T2YoJ2ltYWdlOi8vJykgPCAwKSB7XG4gICAgICAgIC8vIENvbXBhdGl0YWJsZSB3aXRoIHRoZSBvbGQgaWNvbiBwYXJzZXJzLiBXaGljaCBjYW4gdXNlIGEgcGF0aCBzdHJpbmcgd2l0aG91dCBwYXRoOi8vXG4gICAgICAgIGljb25TdHIgPSAncGF0aDovLycgKyBpY29uU3RyO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgZGVwcmVjYXRlTG9nKCdoYW5kbGVJY29uIG5vdyBuZWVkcyBcXCdwYXRoOi8vXFwnIHByZWZpeCB3aGVuIHVzaW5nIGEgcGF0aCBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZVN5bWJvbChpY29uU3RyLCAtMSwgMCwgMiwgMiwgbnVsbCwgdHJ1ZSk7XG4gICAgICBwYXRoLmF0dHIoe1xuICAgICAgICBjdXJzb3I6IGdldEN1cnNvcih0aGlzLl9vcmllbnQpLFxuICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgIGRyaWZ0OiBiaW5kKHRoaXMuX29uRHJhZ01vdmUsIHRoaXMsIGhhbmRsZUluZGV4KSxcbiAgICAgICAgb25kcmFnZW5kOiBiaW5kKHRoaXMuX29uRHJhZ0VuZCwgdGhpcyksXG4gICAgICAgIG9ubW91c2VvdmVyOiBiaW5kKHRoaXMuX3Nob3dEYXRhSW5mbywgdGhpcywgdHJ1ZSksXG4gICAgICAgIG9ubW91c2VvdXQ6IGJpbmQodGhpcy5fc2hvd0RhdGFJbmZvLCB0aGlzLCBmYWxzZSksXG4gICAgICAgIHoyOiA1XG4gICAgICB9KTtcbiAgICAgIHZhciBiUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICB2YXIgaGFuZGxlU2l6ZSA9IGRhdGFab29tTW9kZWwuZ2V0KCdoYW5kbGVTaXplJyk7XG4gICAgICB0aGlzLl9oYW5kbGVIZWlnaHQgPSBwYXJzZVBlcmNlbnQoaGFuZGxlU2l6ZSwgdGhpcy5fc2l6ZVsxXSk7XG4gICAgICB0aGlzLl9oYW5kbGVXaWR0aCA9IGJSZWN0LndpZHRoIC8gYlJlY3QuaGVpZ2h0ICogdGhpcy5faGFuZGxlSGVpZ2h0O1xuICAgICAgcGF0aC5zZXRTdHlsZShkYXRhWm9vbU1vZGVsLmdldE1vZGVsKCdoYW5kbGVTdHlsZScpLmdldEl0ZW1TdHlsZSgpKTtcbiAgICAgIHBhdGguc3R5bGUuc3Ryb2tlTm9TY2FsZSA9IHRydWU7XG4gICAgICBwYXRoLnJlY3RIb3ZlciA9IHRydWU7XG4gICAgICBwYXRoLmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpLnN0eWxlID0gZGF0YVpvb21Nb2RlbC5nZXRNb2RlbChbJ2VtcGhhc2lzJywgJ2hhbmRsZVN0eWxlJ10pLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgZW5hYmxlSG92ZXJFbXBoYXNpcyhwYXRoKTtcbiAgICAgIHZhciBoYW5kbGVDb2xvciA9IGRhdGFab29tTW9kZWwuZ2V0KCdoYW5kbGVDb2xvcicpOyAvLyBkZXByZWNhdGVkIG9wdGlvblxuICAgICAgLy8gQ29tcGF0aXRhYmxlIHdpdGggcHJldmlvdXMgdmVyc2lvblxuXG4gICAgICBpZiAoaGFuZGxlQ29sb3IgIT0gbnVsbCkge1xuICAgICAgICBwYXRoLnN0eWxlLmZpbGwgPSBoYW5kbGVDb2xvcjtcbiAgICAgIH1cblxuICAgICAgc2xpZGVyR3JvdXAuYWRkKGhhbmRsZXNbaGFuZGxlSW5kZXhdID0gcGF0aCk7XG4gICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBkYXRhWm9vbU1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICAgIHRoaXNHcm91cC5hZGQoaGFuZGxlTGFiZWxzW2hhbmRsZUluZGV4XSA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgIGludmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgIGZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpLFxuICAgICAgICAgIGZvbnQ6IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKVxuICAgICAgICB9LFxuICAgICAgICB6MjogMTBcbiAgICAgIH0pKTtcbiAgICB9LCB0aGlzKTsgLy8gSGFuZGxlIHRvIG1vdmUuIE9ubHkgdmlzaWJsZSB3aGVuIGJydXNoU2VsZWN0IGlzIHNldCB0cnVlLlxuXG4gICAgdmFyIGFjdHVhbE1vdmVab25lID0gZmlsbGVyO1xuXG4gICAgaWYgKGJydXNoU2VsZWN0KSB7XG4gICAgICB2YXIgbW92ZUhhbmRsZUhlaWdodCA9IHBhcnNlUGVyY2VudChkYXRhWm9vbU1vZGVsLmdldCgnbW92ZUhhbmRsZVNpemUnKSwgc2l6ZVsxXSk7XG4gICAgICB2YXIgbW92ZUhhbmRsZV8xID0gZGlzcGxheWFibGVzLm1vdmVIYW5kbGUgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgc3R5bGU6IGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoJ21vdmVIYW5kbGVTdHlsZScpLmdldEl0ZW1TdHlsZSgpLFxuICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgcjogWzAsIDAsIDIsIDJdLFxuICAgICAgICAgIHk6IHNpemVbMV0gLSAwLjUsXG4gICAgICAgICAgaGVpZ2h0OiBtb3ZlSGFuZGxlSGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGljb25TaXplID0gbW92ZUhhbmRsZUhlaWdodCAqIDAuODtcbiAgICAgIHZhciBtb3ZlSGFuZGxlSWNvbiA9IGRpc3BsYXlhYmxlcy5tb3ZlSGFuZGxlSWNvbiA9IGNyZWF0ZVN5bWJvbChkYXRhWm9vbU1vZGVsLmdldCgnbW92ZUhhbmRsZUljb24nKSwgLWljb25TaXplIC8gMiwgLWljb25TaXplIC8gMiwgaWNvblNpemUsIGljb25TaXplLCAnI2ZmZicsIHRydWUpO1xuICAgICAgbW92ZUhhbmRsZUljb24uc2lsZW50ID0gdHJ1ZTtcbiAgICAgIG1vdmVIYW5kbGVJY29uLnkgPSBzaXplWzFdICsgbW92ZUhhbmRsZUhlaWdodCAvIDIgLSAwLjU7XG4gICAgICBtb3ZlSGFuZGxlXzEuZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJykuc3R5bGUgPSBkYXRhWm9vbU1vZGVsLmdldE1vZGVsKFsnZW1waGFzaXMnLCAnbW92ZUhhbmRsZVN0eWxlJ10pLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgdmFyIG1vdmVab25lRXhwYW5kU2l6ZSA9IE1hdGgubWluKHNpemVbMV0gLyAyLCBNYXRoLm1heChtb3ZlSGFuZGxlSGVpZ2h0LCAxMCkpO1xuICAgICAgYWN0dWFsTW92ZVpvbmUgPSBkaXNwbGF5YWJsZXMubW92ZVpvbmUgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgaW52aXNpYmxlOiB0cnVlLFxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIHk6IHNpemVbMV0gLSBtb3ZlWm9uZUV4cGFuZFNpemUsXG4gICAgICAgICAgaGVpZ2h0OiBtb3ZlSGFuZGxlSGVpZ2h0ICsgbW92ZVpvbmVFeHBhbmRTaXplXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYWN0dWFsTW92ZVpvbmUub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXBpLmVudGVyRW1waGFzaXMobW92ZUhhbmRsZV8xKTtcbiAgICAgIH0pLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXBpLmxlYXZlRW1waGFzaXMobW92ZUhhbmRsZV8xKTtcbiAgICAgIH0pO1xuICAgICAgc2xpZGVyR3JvdXAuYWRkKG1vdmVIYW5kbGVfMSk7XG4gICAgICBzbGlkZXJHcm91cC5hZGQobW92ZUhhbmRsZUljb24pO1xuICAgICAgc2xpZGVyR3JvdXAuYWRkKGFjdHVhbE1vdmVab25lKTtcbiAgICB9XG5cbiAgICBhY3R1YWxNb3ZlWm9uZS5hdHRyKHtcbiAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgIGN1cnNvcjogZ2V0Q3Vyc29yKHRoaXMuX29yaWVudCksXG4gICAgICBkcmlmdDogYmluZCh0aGlzLl9vbkRyYWdNb3ZlLCB0aGlzLCAnYWxsJyksXG4gICAgICBvbmRyYWdzdGFydDogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIHRydWUpLFxuICAgICAgb25kcmFnZW5kOiBiaW5kKHRoaXMuX29uRHJhZ0VuZCwgdGhpcyksXG4gICAgICBvbm1vdXNlb3ZlcjogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIHRydWUpLFxuICAgICAgb25tb3VzZW91dDogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIGZhbHNlKVxuICAgIH0pO1xuICB9O1xuXG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fcmVzZXRJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZSA9IHRoaXMuZGF0YVpvb21Nb2RlbC5nZXRQZXJjZW50UmFuZ2UoKTtcblxuICAgIHZhciB2aWV3RXh0ZW50ID0gdGhpcy5fZ2V0Vmlld0V4dGVudCgpO1xuXG4gICAgdGhpcy5faGFuZGxlRW5kcyA9IFtsaW5lYXJNYXAocmFuZ2VbMF0sIFswLCAxMDBdLCB2aWV3RXh0ZW50LCB0cnVlKSwgbGluZWFyTWFwKHJhbmdlWzFdLCBbMCwgMTAwXSwgdmlld0V4dGVudCwgdHJ1ZSldO1xuICB9O1xuXG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fdXBkYXRlSW50ZXJ2YWwgPSBmdW5jdGlvbiAoaGFuZGxlSW5kZXgsIGRlbHRhKSB7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgdmFyIGhhbmRsZUVuZHMgPSB0aGlzLl9oYW5kbGVFbmRzO1xuXG4gICAgdmFyIHZpZXdFeHRlbmQgPSB0aGlzLl9nZXRWaWV3RXh0ZW50KCk7XG5cbiAgICB2YXIgbWluTWF4U3BhbiA9IGRhdGFab29tTW9kZWwuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCkuZ2V0TWluTWF4U3BhbigpO1xuICAgIHZhciBwZXJjZW50RXh0ZW50ID0gWzAsIDEwMF07XG4gICAgc2xpZGVyTW92ZShkZWx0YSwgaGFuZGxlRW5kcywgdmlld0V4dGVuZCwgZGF0YVpvb21Nb2RlbC5nZXQoJ3pvb21Mb2NrJykgPyAnYWxsJyA6IGhhbmRsZUluZGV4LCBtaW5NYXhTcGFuLm1pblNwYW4gIT0gbnVsbCA/IGxpbmVhck1hcChtaW5NYXhTcGFuLm1pblNwYW4sIHBlcmNlbnRFeHRlbnQsIHZpZXdFeHRlbmQsIHRydWUpIDogbnVsbCwgbWluTWF4U3Bhbi5tYXhTcGFuICE9IG51bGwgPyBsaW5lYXJNYXAobWluTWF4U3Bhbi5tYXhTcGFuLCBwZXJjZW50RXh0ZW50LCB2aWV3RXh0ZW5kLCB0cnVlKSA6IG51bGwpO1xuICAgIHZhciBsYXN0UmFuZ2UgPSB0aGlzLl9yYW5nZTtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZSA9IGFzYyhbbGluZWFyTWFwKGhhbmRsZUVuZHNbMF0sIHZpZXdFeHRlbmQsIHBlcmNlbnRFeHRlbnQsIHRydWUpLCBsaW5lYXJNYXAoaGFuZGxlRW5kc1sxXSwgdmlld0V4dGVuZCwgcGVyY2VudEV4dGVudCwgdHJ1ZSldKTtcbiAgICByZXR1cm4gIWxhc3RSYW5nZSB8fCBsYXN0UmFuZ2VbMF0gIT09IHJhbmdlWzBdIHx8IGxhc3RSYW5nZVsxXSAhPT0gcmFuZ2VbMV07XG4gIH07XG5cbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl91cGRhdGVWaWV3ID0gZnVuY3Rpb24gKG5vblJlYWx0aW1lKSB7XG4gICAgdmFyIGRpc3BsYXlibGVzID0gdGhpcy5fZGlzcGxheWFibGVzO1xuICAgIHZhciBoYW5kbGVFbmRzID0gdGhpcy5faGFuZGxlRW5kcztcbiAgICB2YXIgaGFuZGxlSW50ZXJ2YWwgPSBhc2MoaGFuZGxlRW5kcy5zbGljZSgpKTtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgZWFjaChbMCwgMV0sIGZ1bmN0aW9uIChoYW5kbGVJbmRleCkge1xuICAgICAgLy8gSGFuZGxlc1xuICAgICAgdmFyIGhhbmRsZSA9IGRpc3BsYXlibGVzLmhhbmRsZXNbaGFuZGxlSW5kZXhdO1xuICAgICAgdmFyIGhhbmRsZUhlaWdodCA9IHRoaXMuX2hhbmRsZUhlaWdodDtcbiAgICAgIGhhbmRsZS5hdHRyKHtcbiAgICAgICAgc2NhbGVYOiBoYW5kbGVIZWlnaHQgLyAyLFxuICAgICAgICBzY2FsZVk6IGhhbmRsZUhlaWdodCAvIDIsXG4gICAgICAgIC8vIFRoaXMgaXMgYSB0cmljaywgYnkgYWRkaW5nIGFuIGV4dHJhIHRpbnkgb2Zmc2V0IHRvIGxldCB0aGUgZGVmYXVsdCBoYW5kbGUncyBlbmQgcG9pbnQgYWxpZ24gdG8gdGhlIGRyYWcgd2luZG93LlxuICAgICAgICAvLyBOT1RFOiBJdCBtYXkgYWZmZWN0IHNvbWUgY3VzdG9tIHNoYXBlcyBhIGJpdC4gQnV0IHdlIHByZWZlciB0byBoYXZlIGJldHRlciByZXN1bHQgYnkgZGVmYXVsdC5cbiAgICAgICAgeDogaGFuZGxlRW5kc1toYW5kbGVJbmRleF0gKyAoaGFuZGxlSW5kZXggPyAtMSA6IDEpLFxuICAgICAgICB5OiBzaXplWzFdIC8gMiAtIGhhbmRsZUhlaWdodCAvIDJcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMpOyAvLyBGaWxsZXJcblxuICAgIGRpc3BsYXlibGVzLmZpbGxlci5zZXRTaGFwZSh7XG4gICAgICB4OiBoYW5kbGVJbnRlcnZhbFswXSxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogaGFuZGxlSW50ZXJ2YWxbMV0gLSBoYW5kbGVJbnRlcnZhbFswXSxcbiAgICAgIGhlaWdodDogc2l6ZVsxXVxuICAgIH0pO1xuICAgIHZhciB2aWV3RXh0ZW50ID0ge1xuICAgICAgeDogaGFuZGxlSW50ZXJ2YWxbMF0sXG4gICAgICB3aWR0aDogaGFuZGxlSW50ZXJ2YWxbMV0gLSBoYW5kbGVJbnRlcnZhbFswXVxuICAgIH07IC8vIE1vdmUgaGFuZGxlXG5cbiAgICBpZiAoZGlzcGxheWJsZXMubW92ZUhhbmRsZSkge1xuICAgICAgZGlzcGxheWJsZXMubW92ZUhhbmRsZS5zZXRTaGFwZSh2aWV3RXh0ZW50KTtcbiAgICAgIGRpc3BsYXlibGVzLm1vdmVab25lLnNldFNoYXBlKHZpZXdFeHRlbnQpOyAvLyBGb3JjZSB1cGRhdGUgcGF0aCBvbiB0aGUgaW52aXNpYmxlIG9iamVjdFxuXG4gICAgICBkaXNwbGF5Ymxlcy5tb3ZlWm9uZS5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgIGRpc3BsYXlibGVzLm1vdmVIYW5kbGVJY29uICYmIGRpc3BsYXlibGVzLm1vdmVIYW5kbGVJY29uLmF0dHIoJ3gnLCB2aWV3RXh0ZW50LnggKyB2aWV3RXh0ZW50LndpZHRoIC8gMik7XG4gICAgfSAvLyB1cGRhdGUgY2xpcCBwYXRoIG9mIHNoYWRvdy5cblxuXG4gICAgdmFyIGRhdGFTaGFkb3dTZWdzID0gZGlzcGxheWJsZXMuZGF0YVNoYWRvd1NlZ3M7XG4gICAgdmFyIHNlZ0ludGVydmFscyA9IFswLCBoYW5kbGVJbnRlcnZhbFswXSwgaGFuZGxlSW50ZXJ2YWxbMV0sIHNpemVbMF1dO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhU2hhZG93U2Vncy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlZ0dyb3VwID0gZGF0YVNoYWRvd1NlZ3NbaV07XG4gICAgICB2YXIgY2xpcFBhdGggPSBzZWdHcm91cC5nZXRDbGlwUGF0aCgpO1xuXG4gICAgICBpZiAoIWNsaXBQYXRoKSB7XG4gICAgICAgIGNsaXBQYXRoID0gbmV3IGdyYXBoaWMuUmVjdCgpO1xuICAgICAgICBzZWdHcm91cC5zZXRDbGlwUGF0aChjbGlwUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGNsaXBQYXRoLnNldFNoYXBlKHtcbiAgICAgICAgeDogc2VnSW50ZXJ2YWxzW2ldLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogc2VnSW50ZXJ2YWxzW2kgKyAxXSAtIHNlZ0ludGVydmFsc1tpXSxcbiAgICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVEYXRhSW5mbyhub25SZWFsdGltZSk7XG4gIH07XG5cbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl91cGRhdGVEYXRhSW5mbyA9IGZ1bmN0aW9uIChub25SZWFsdGltZSkge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBkaXNwbGF5YmxlcyA9IHRoaXMuX2Rpc3BsYXlhYmxlcztcbiAgICB2YXIgaGFuZGxlTGFiZWxzID0gZGlzcGxheWJsZXMuaGFuZGxlTGFiZWxzO1xuICAgIHZhciBvcmllbnQgPSB0aGlzLl9vcmllbnQ7XG4gICAgdmFyIGxhYmVsVGV4dHMgPSBbJycsICcnXTsgLy8gRklYTUVcbiAgICAvLyBkYXRl5Z6L77yM5pSv5oyBZm9ybWF0dGVy77yMYXV0b2Zvcm1hdHRlcu+8iGVjMiBkYXRlLmdldEF1dG9Gb3JtYXR0ZXLvvIlcblxuICAgIGlmIChkYXRhWm9vbU1vZGVsLmdldCgnc2hvd0RldGFpbCcpKSB7XG4gICAgICB2YXIgYXhpc1Byb3h5ID0gZGF0YVpvb21Nb2RlbC5maW5kUmVwcmVzZW50YXRpdmVBeGlzUHJveHkoKTtcblxuICAgICAgaWYgKGF4aXNQcm94eSkge1xuICAgICAgICB2YXIgYXhpcyA9IGF4aXNQcm94eS5nZXRBeGlzTW9kZWwoKS5heGlzO1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZTtcbiAgICAgICAgdmFyIGRhdGFJbnRlcnZhbCA9IG5vblJlYWx0aW1lIC8vIFNlZSAjNDQzNCwgZGF0YSBhbmQgYXhpcyBhcmUgbm90IHByb2Nlc3NlZCBhbmQgcmVzZXQgeWV0IGluIG5vbi1yZWFsdGltZSBtb2RlLlxuICAgICAgICA/IGF4aXNQcm94eS5jYWxjdWxhdGVEYXRhV2luZG93KHtcbiAgICAgICAgICBzdGFydDogcmFuZ2VbMF0sXG4gICAgICAgICAgZW5kOiByYW5nZVsxXVxuICAgICAgICB9KS52YWx1ZVdpbmRvdyA6IGF4aXNQcm94eS5nZXREYXRhVmFsdWVXaW5kb3coKTtcbiAgICAgICAgbGFiZWxUZXh0cyA9IFt0aGlzLl9mb3JtYXRMYWJlbChkYXRhSW50ZXJ2YWxbMF0sIGF4aXMpLCB0aGlzLl9mb3JtYXRMYWJlbChkYXRhSW50ZXJ2YWxbMV0sIGF4aXMpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb3JkZXJlZEhhbmRsZUVuZHMgPSBhc2ModGhpcy5faGFuZGxlRW5kcy5zbGljZSgpKTtcbiAgICBzZXRMYWJlbC5jYWxsKHRoaXMsIDApO1xuICAgIHNldExhYmVsLmNhbGwodGhpcywgMSk7XG5cbiAgICBmdW5jdGlvbiBzZXRMYWJlbChoYW5kbGVJbmRleCkge1xuICAgICAgLy8gTGFiZWxcbiAgICAgIC8vIFRleHQgc2hvdWxkIG5vdCB0cmFuc2Zvcm0gYnkgYmFyR3JvdXAuXG4gICAgICAvLyBJZ25vcmUgaGFuZGxlcnMgdHJhbnNmb3JtXG4gICAgICB2YXIgYmFyVHJhbnNmb3JtID0gZ3JhcGhpYy5nZXRUcmFuc2Zvcm0oZGlzcGxheWJsZXMuaGFuZGxlc1toYW5kbGVJbmRleF0ucGFyZW50LCB0aGlzLmdyb3VwKTtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBncmFwaGljLnRyYW5zZm9ybURpcmVjdGlvbihoYW5kbGVJbmRleCA9PT0gMCA/ICdyaWdodCcgOiAnbGVmdCcsIGJhclRyYW5zZm9ybSk7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5faGFuZGxlV2lkdGggLyAyICsgTEFCRUxfR0FQO1xuICAgICAgdmFyIHRleHRQb2ludCA9IGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0oW29yZGVyZWRIYW5kbGVFbmRzW2hhbmRsZUluZGV4XSArIChoYW5kbGVJbmRleCA9PT0gMCA/IC1vZmZzZXQgOiBvZmZzZXQpLCB0aGlzLl9zaXplWzFdIC8gMl0sIGJhclRyYW5zZm9ybSk7XG4gICAgICBoYW5kbGVMYWJlbHNbaGFuZGxlSW5kZXhdLnNldFN0eWxlKHtcbiAgICAgICAgeDogdGV4dFBvaW50WzBdLFxuICAgICAgICB5OiB0ZXh0UG9pbnRbMV0sXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IG9yaWVudCA9PT0gSE9SSVpPTlRBTCA/ICdtaWRkbGUnIDogZGlyZWN0aW9uLFxuICAgICAgICBhbGlnbjogb3JpZW50ID09PSBIT1JJWk9OVEFMID8gZGlyZWN0aW9uIDogJ2NlbnRlcicsXG4gICAgICAgIHRleHQ6IGxhYmVsVGV4dHNbaGFuZGxlSW5kZXhdXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl9mb3JtYXRMYWJlbCA9IGZ1bmN0aW9uICh2YWx1ZSwgYXhpcykge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBsYWJlbEZvcm1hdHRlciA9IGRhdGFab29tTW9kZWwuZ2V0KCdsYWJlbEZvcm1hdHRlcicpO1xuICAgIHZhciBsYWJlbFByZWNpc2lvbiA9IGRhdGFab29tTW9kZWwuZ2V0KCdsYWJlbFByZWNpc2lvbicpO1xuXG4gICAgaWYgKGxhYmVsUHJlY2lzaW9uID09IG51bGwgfHwgbGFiZWxQcmVjaXNpb24gPT09ICdhdXRvJykge1xuICAgICAgbGFiZWxQcmVjaXNpb24gPSBheGlzLmdldFBpeGVsUHJlY2lzaW9uKCk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlU3RyID0gdmFsdWUgPT0gbnVsbCB8fCBpc05hTih2YWx1ZSkgPyAnJyAvLyBGSVhNRSBHbHVlIGNvZGVcbiAgICA6IGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyB8fCBheGlzLnR5cGUgPT09ICd0aW1lJyA/IGF4aXMuc2NhbGUuZ2V0TGFiZWwoe1xuICAgICAgdmFsdWU6IE1hdGgucm91bmQodmFsdWUpXG4gICAgfSkgLy8gcGFyYW0gb2YgdG9GaXhlZCBzaG91bGQgbGVzcyB0aGVuIDIwLlxuICAgIDogdmFsdWUudG9GaXhlZChNYXRoLm1pbihsYWJlbFByZWNpc2lvbiwgMjApKTtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihsYWJlbEZvcm1hdHRlcikgPyBsYWJlbEZvcm1hdHRlcih2YWx1ZSwgdmFsdWVTdHIpIDogaXNTdHJpbmcobGFiZWxGb3JtYXR0ZXIpID8gbGFiZWxGb3JtYXR0ZXIucmVwbGFjZSgne3ZhbHVlfScsIHZhbHVlU3RyKSA6IHZhbHVlU3RyO1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHNob3dPckhpZGUgdHJ1ZTogc2hvdywgZmFsc2U6IGhpZGVcbiAgICovXG5cblxuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUuX3Nob3dEYXRhSW5mbyA9IGZ1bmN0aW9uIChzaG93T3JIaWRlKSB7XG4gICAgLy8gQWx3YXlzIHNob3cgd2hlbiBkcmdnaW5nLlxuICAgIHNob3dPckhpZGUgPSB0aGlzLl9kcmFnZ2luZyB8fCBzaG93T3JIaWRlO1xuICAgIHZhciBkaXNwbGF5YWJsZXMgPSB0aGlzLl9kaXNwbGF5YWJsZXM7XG4gICAgdmFyIGhhbmRsZUxhYmVscyA9IGRpc3BsYXlhYmxlcy5oYW5kbGVMYWJlbHM7XG4gICAgaGFuZGxlTGFiZWxzWzBdLmF0dHIoJ2ludmlzaWJsZScsICFzaG93T3JIaWRlKTtcbiAgICBoYW5kbGVMYWJlbHNbMV0uYXR0cignaW52aXNpYmxlJywgIXNob3dPckhpZGUpOyAvLyBIaWdobGlnaHQgbW92ZSBoYW5kbGVcblxuICAgIGRpc3BsYXlhYmxlcy5tb3ZlSGFuZGxlICYmIHRoaXMuYXBpW3Nob3dPckhpZGUgPyAnZW50ZXJFbXBoYXNpcycgOiAnbGVhdmVFbXBoYXNpcyddKGRpc3BsYXlhYmxlcy5tb3ZlSGFuZGxlLCAxKTtcbiAgfTtcblxuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUuX29uRHJhZ01vdmUgPSBmdW5jdGlvbiAoaGFuZGxlSW5kZXgsIGR4LCBkeSwgZXZlbnQpIHtcbiAgICB0aGlzLl9kcmFnZ2luZyA9IHRydWU7IC8vIEZvciBtb2JpbGUgZGV2aWNlLCBwcmV2ZW50IHNjcmVlbiBzbGlkZXIgb24gdGhlIGJ1dHRvbi5cblxuICAgIGV2ZW50VG9vbC5zdG9wKGV2ZW50LmV2ZW50KTsgLy8gVHJhbnNmb3JtIGR4LCBkeSB0byBiYXIgY29vcmRpbmF0aW9uLlxuXG4gICAgdmFyIGJhclRyYW5zZm9ybSA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5zbGlkZXJHcm91cC5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuXG4gICAgdmFyIHZlcnRleCA9IGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0oW2R4LCBkeV0sIGJhclRyYW5zZm9ybSwgdHJ1ZSk7XG5cbiAgICB2YXIgY2hhbmdlZCA9IHRoaXMuX3VwZGF0ZUludGVydmFsKGhhbmRsZUluZGV4LCB2ZXJ0ZXhbMF0pO1xuXG4gICAgdmFyIHJlYWx0aW1lID0gdGhpcy5kYXRhWm9vbU1vZGVsLmdldCgncmVhbHRpbWUnKTtcblxuICAgIHRoaXMuX3VwZGF0ZVZpZXcoIXJlYWx0aW1lKTsgLy8gQXZvaWQgZGlzcGF0Y2ggZGF0YVpvb20gcmVwZWF0bHkgYnV0IHJhbmdlIG5vdCBjaGFuZ2VkLFxuICAgIC8vIHdoaWNoIGNhdXNlIGJhZCB2aXN1YWwgZWZmZWN0IHdoZW4gcHJvZ3Jlc3NpdmUgZW5hYmxlZC5cblxuXG4gICAgY2hhbmdlZCAmJiByZWFsdGltZSAmJiB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24odHJ1ZSk7XG4gIH07XG5cbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl9vbkRyYWdFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgIHRoaXMuX3Nob3dEYXRhSW5mbyhmYWxzZSk7IC8vIFdoaWxlIGluIHJlYWx0aW1lIG1vZGUgYW5kIHN0cmVhbSBtb2RlLCBkaXNwYXRjaCBhY3Rpb24gd2hlblxuICAgIC8vIGRyYWcgZW5kIHdpbGwgY2F1c2UgdGhlIHdob2xlIHZpZXcgcmVyZW5kZXIsIHdoaWNoIGlzIHVubmVjZXNzYXJ5LlxuXG5cbiAgICB2YXIgcmVhbHRpbWUgPSB0aGlzLmRhdGFab29tTW9kZWwuZ2V0KCdyZWFsdGltZScpO1xuICAgICFyZWFsdGltZSAmJiB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oZmFsc2UpO1xuICB9O1xuXG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fb25DbGlja1BhbmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cbiAgICB2YXIgbG9jYWxQb2ludCA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5zbGlkZXJHcm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xuXG4gICAgaWYgKGxvY2FsUG9pbnRbMF0gPCAwIHx8IGxvY2FsUG9pbnRbMF0gPiBzaXplWzBdIHx8IGxvY2FsUG9pbnRbMV0gPCAwIHx8IGxvY2FsUG9pbnRbMV0gPiBzaXplWzFdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZUVuZHMgPSB0aGlzLl9oYW5kbGVFbmRzO1xuICAgIHZhciBjZW50ZXIgPSAoaGFuZGxlRW5kc1swXSArIGhhbmRsZUVuZHNbMV0pIC8gMjtcblxuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5fdXBkYXRlSW50ZXJ2YWwoJ2FsbCcsIGxvY2FsUG9pbnRbMF0gLSBjZW50ZXIpO1xuXG4gICAgdGhpcy5fdXBkYXRlVmlldygpO1xuXG4gICAgY2hhbmdlZCAmJiB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oZmFsc2UpO1xuICB9O1xuXG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fb25CcnVzaFN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgICB2YXIgeSA9IGUub2Zmc2V0WTtcbiAgICB0aGlzLl9icnVzaFN0YXJ0ID0gbmV3IGdyYXBoaWMuUG9pbnQoeCwgeSk7XG4gICAgdGhpcy5fYnJ1c2hpbmcgPSB0cnVlO1xuICAgIHRoaXMuX2JydXNoU3RhcnRUaW1lID0gK25ldyBEYXRlKCk7IC8vIHRoaXMuX3VwZGF0ZUJydXNoUmVjdCh4LCB5KTtcbiAgfTtcblxuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUuX29uQnJ1c2hFbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmICghdGhpcy5fYnJ1c2hpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYnJ1c2hSZWN0ID0gdGhpcy5fZGlzcGxheWFibGVzLmJydXNoUmVjdDtcbiAgICB0aGlzLl9icnVzaGluZyA9IGZhbHNlO1xuXG4gICAgaWYgKCFicnVzaFJlY3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBicnVzaFJlY3QuYXR0cignaWdub3JlJywgdHJ1ZSk7XG4gICAgdmFyIGJydXNoU2hhcGUgPSBicnVzaFJlY3Quc2hhcGU7XG4gICAgdmFyIGJydXNoRW5kVGltZSA9ICtuZXcgRGF0ZSgpOyAvLyBjb25zb2xlLmxvZyhicnVzaEVuZFRpbWUgLSB0aGlzLl9icnVzaFN0YXJ0VGltZSk7XG5cbiAgICBpZiAoYnJ1c2hFbmRUaW1lIC0gdGhpcy5fYnJ1c2hTdGFydFRpbWUgPCAyMDAgJiYgTWF0aC5hYnMoYnJ1c2hTaGFwZS53aWR0aCkgPCA1KSB7XG4gICAgICAvLyBXaWxsIHRyZWF0IGl0IGFzIGEgY2xpY2tcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdmlld0V4dGVuZCA9IHRoaXMuX2dldFZpZXdFeHRlbnQoKTtcblxuICAgIHZhciBwZXJjZW50RXh0ZW50ID0gWzAsIDEwMF07XG4gICAgdGhpcy5fcmFuZ2UgPSBhc2MoW2xpbmVhck1hcChicnVzaFNoYXBlLngsIHZpZXdFeHRlbmQsIHBlcmNlbnRFeHRlbnQsIHRydWUpLCBsaW5lYXJNYXAoYnJ1c2hTaGFwZS54ICsgYnJ1c2hTaGFwZS53aWR0aCwgdmlld0V4dGVuZCwgcGVyY2VudEV4dGVudCwgdHJ1ZSldKTtcbiAgICB0aGlzLl9oYW5kbGVFbmRzID0gW2JydXNoU2hhcGUueCwgYnJ1c2hTaGFwZS54ICsgYnJ1c2hTaGFwZS53aWR0aF07XG5cbiAgICB0aGlzLl91cGRhdGVWaWV3KCk7XG5cbiAgICB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oZmFsc2UpO1xuICB9O1xuXG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fb25CcnVzaCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHRoaXMuX2JydXNoaW5nKSB7XG4gICAgICAvLyBGb3IgbW9iaWxlIGRldmljZSwgcHJldmVudCBzY3JlZW4gc2xpZGVyIG9uIHRoZSBidXR0b24uXG4gICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcblxuICAgICAgdGhpcy5fdXBkYXRlQnJ1c2hSZWN0KGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcbiAgICB9XG4gIH07XG5cbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl91cGRhdGVCcnVzaFJlY3QgPSBmdW5jdGlvbiAobW91c2VYLCBtb3VzZVkpIHtcbiAgICB2YXIgZGlzcGxheWFibGVzID0gdGhpcy5fZGlzcGxheWFibGVzO1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgIHZhciBicnVzaFJlY3QgPSBkaXNwbGF5YWJsZXMuYnJ1c2hSZWN0O1xuXG4gICAgaWYgKCFicnVzaFJlY3QpIHtcbiAgICAgIGJydXNoUmVjdCA9IGRpc3BsYXlhYmxlcy5icnVzaFJlY3QgPSBuZXcgUmVjdCh7XG4gICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgc3R5bGU6IGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoJ2JydXNoU3R5bGUnKS5nZXRJdGVtU3R5bGUoKVxuICAgICAgfSk7XG4gICAgICBkaXNwbGF5YWJsZXMuc2xpZGVyR3JvdXAuYWRkKGJydXNoUmVjdCk7XG4gICAgfVxuXG4gICAgYnJ1c2hSZWN0LmF0dHIoJ2lnbm9yZScsIGZhbHNlKTtcbiAgICB2YXIgYnJ1c2hTdGFydCA9IHRoaXMuX2JydXNoU3RhcnQ7XG4gICAgdmFyIHNsaWRlckdyb3VwID0gdGhpcy5fZGlzcGxheWFibGVzLnNsaWRlckdyb3VwO1xuICAgIHZhciBlbmRQb2ludCA9IHNsaWRlckdyb3VwLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbChtb3VzZVgsIG1vdXNlWSk7XG4gICAgdmFyIHN0YXJ0UG9pbnQgPSBzbGlkZXJHcm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoYnJ1c2hTdGFydC54LCBicnVzaFN0YXJ0LnkpO1xuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICBlbmRQb2ludFswXSA9IE1hdGgubWF4KE1hdGgubWluKHNpemVbMF0sIGVuZFBvaW50WzBdKSwgMCk7XG4gICAgYnJ1c2hSZWN0LnNldFNoYXBlKHtcbiAgICAgIHg6IHN0YXJ0UG9pbnRbMF0sXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGVuZFBvaW50WzBdIC0gc3RhcnRQb2ludFswXSxcbiAgICAgIGhlaWdodDogc2l6ZVsxXVxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogVGhpcyBhY3Rpb24gd2lsbCBiZSB0aHJvdHRsZWQuXG4gICAqL1xuXG5cbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl9kaXNwYXRjaFpvb21BY3Rpb24gPSBmdW5jdGlvbiAocmVhbHRpbWUpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZTtcbiAgICB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnZGF0YVpvb20nLFxuICAgICAgZnJvbTogdGhpcy51aWQsXG4gICAgICBkYXRhWm9vbUlkOiB0aGlzLmRhdGFab29tTW9kZWwuaWQsXG4gICAgICBhbmltYXRpb246IHJlYWx0aW1lID8gUkVBTFRJTUVfQU5JTUFUSU9OX0NPTkZJRyA6IG51bGwsXG4gICAgICBzdGFydDogcmFuZ2VbMF0sXG4gICAgICBlbmQ6IHJhbmdlWzFdXG4gICAgfSk7XG4gIH07XG5cbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl9maW5kQ29vcmRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEZpbmQgdGhlIGdyaWQgY29yZXNwb25kaW5nIHRvIHRoZSBmaXJzdCBheGlzIHJlZmVycmVkIGJ5IGRhdGFab29tLlxuICAgIHZhciByZWN0O1xuICAgIHZhciBjb29yZFN5c0luZm9MaXN0ID0gY29sbGVjdFJlZmVyQ29vcmRTeXNNb2RlbEluZm8odGhpcy5kYXRhWm9vbU1vZGVsKS5pbmZvTGlzdDtcblxuICAgIGlmICghcmVjdCAmJiBjb29yZFN5c0luZm9MaXN0Lmxlbmd0aCkge1xuICAgICAgdmFyIGNvb3JkU3lzID0gY29vcmRTeXNJbmZvTGlzdFswXS5tb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgcmVjdCA9IGNvb3JkU3lzLmdldFJlY3QgJiYgY29vcmRTeXMuZ2V0UmVjdCgpO1xuICAgIH1cblxuICAgIGlmICghcmVjdCkge1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5hcGkuZ2V0V2lkdGgoKTtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmFwaS5nZXRIZWlnaHQoKTtcbiAgICAgIHJlY3QgPSB7XG4gICAgICAgIHg6IHdpZHRoICogMC4yLFxuICAgICAgICB5OiBoZWlnaHQgKiAwLjIsXG4gICAgICAgIHdpZHRoOiB3aWR0aCAqIDAuNixcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKiAwLjZcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3Q7XG4gIH07XG5cbiAgU2xpZGVyWm9vbVZpZXcudHlwZSA9ICdkYXRhWm9vbS5zbGlkZXInO1xuICByZXR1cm4gU2xpZGVyWm9vbVZpZXc7XG59KERhdGFab29tVmlldyk7XG5cbmZ1bmN0aW9uIGdldE90aGVyRGltKHRoaXNEaW0pIHtcbiAgLy8gRklYTUVcbiAgLy8g6L+Z5Liq6YC76L6R5ZKMZ2V0T3RoZXJBeGlz6YeM5LiA6Ie077yM5L2G5piv5YaZ5Zyo6L+Z6YeM5piv5ZCm5LiN5aW9XG4gIHZhciBtYXAgPSB7XG4gICAgeDogJ3knLFxuICAgIHk6ICd4JyxcbiAgICByYWRpdXM6ICdhbmdsZScsXG4gICAgYW5nbGU6ICdyYWRpdXMnXG4gIH07XG4gIHJldHVybiBtYXBbdGhpc0RpbV07XG59XG5cbmZ1bmN0aW9uIGdldEN1cnNvcihvcmllbnQpIHtcbiAgcmV0dXJuIG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/ICducy1yZXNpemUnIDogJ2V3LXJlc2l6ZSc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNsaWRlclpvb21WaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBmaW5kRWZmZWN0ZWREYXRhWm9vbXMgfSBmcm9tICcuL2hlbHBlcic7XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluc3RhbGxEYXRhWm9vbUFjdGlvbihyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKCdkYXRhWm9vbScsIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgdmFyIGVmZmVjdGVkTW9kZWxzID0gZmluZEVmZmVjdGVkRGF0YVpvb21zKGVjTW9kZWwsIHBheWxvYWQpO1xuICAgIGVhY2goZWZmZWN0ZWRNb2RlbHMsIGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICBkYXRhWm9vbU1vZGVsLnNldFJhd1JhbmdlKHtcbiAgICAgICAgc3RhcnQ6IHBheWxvYWQuc3RhcnQsXG4gICAgICAgIGVuZDogcGF5bG9hZC5lbmQsXG4gICAgICAgIHN0YXJ0VmFsdWU6IHBheWxvYWQuc3RhcnRWYWx1ZSxcbiAgICAgICAgZW5kVmFsdWU6IHBheWxvYWQuZW5kVmFsdWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgY3JlYXRlSGFzaE1hcCwgZWFjaCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBnZXRBeGlzTWFpblR5cGUgfSBmcm9tICcuL2hlbHBlcic7XG5pbXBvcnQgQXhpc1Byb3h5IGZyb20gJy4vQXhpc1Byb3h5JztcbnZhciBkYXRhWm9vbVByb2Nlc3NvciA9IHtcbiAgLy8gYGRhdGFab29tUHJvY2Vzc29yYCB3aWxsIG9ubHkgYmUgcGVyZm9ybWVkIGluIG5lZWRlZCBzZXJpZXMuIENvbnNpZGVyIGlmXG4gIC8vIHRoZXJlIGlzIGEgbGluZSBzZXJpZXMgYW5kIGEgcGllIHNlcmllcywgaXQgaXMgYmV0dGVyIG5vdCB0byB1cGRhdGUgdGhlXG4gIC8vIGxpbmUgc2VyaWVzIGlmIG9ubHkgcGllIHNlcmllcyBpcyBuZWVkZWQgdG8gYmUgdXBkYXRlZC5cbiAgZ2V0VGFyZ2V0U2VyaWVzOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIGZ1bmN0aW9uIGVhY2hBeGlzTW9kZWwoY2IpIHtcbiAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnZGF0YVpvb20nLCBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgICAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChheGlzRGltLCBheGlzSW5kZXgpIHtcbiAgICAgICAgICB2YXIgYXhpc01vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoZ2V0QXhpc01haW5UeXBlKGF4aXNEaW0pLCBheGlzSW5kZXgpO1xuICAgICAgICAgIGNiKGF4aXNEaW0sIGF4aXNJbmRleCwgYXhpc01vZGVsLCBkYXRhWm9vbU1vZGVsKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIEZJWE1FOiBpdCBicmluZ3Mgc2lkZS1lZmZlY3QgdG8gYGdldFRhcmdldFNlcmllc2AuXG4gICAgLy8gUHJlcGFyZSBheGlzIHByb3hpZXMuXG5cblxuICAgIGVhY2hBeGlzTW9kZWwoZnVuY3Rpb24gKGF4aXNEaW0sIGF4aXNJbmRleCwgYXhpc01vZGVsLCBkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAvLyBkaXNwb3NlIGFsbCBsYXN0IGF4aXMgcHJveHksIGluIGNhc2UgdGhhdCBzb21lIGF4aXMgYXJlIGRlbGV0ZWQuXG4gICAgICBheGlzTW9kZWwuX19kekF4aXNQcm94eSA9IG51bGw7XG4gICAgfSk7XG4gICAgdmFyIHByb3h5TGlzdCA9IFtdO1xuICAgIGVhY2hBeGlzTW9kZWwoZnVuY3Rpb24gKGF4aXNEaW0sIGF4aXNJbmRleCwgYXhpc01vZGVsLCBkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAvLyBEaWZmZXJlbnQgZGF0YVpvb21zIG1heSBjb25zdHJvbCB0aGUgc2FtZSBheGlzLiBJbiB0aGF0IGNhc2UsXG4gICAgICAvLyBhbiBheGlzUHJveHkgc2VydmVzIGJvdGggb2YgdGhlbS5cbiAgICAgIGlmICghYXhpc01vZGVsLl9fZHpBeGlzUHJveHkpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBmaXJzdCBkYXRhWm9vbU1vZGVsIGFzIHRoZSBtYWluIG1vZGVsIG9mIGF4aXNQcm94eS5cbiAgICAgICAgYXhpc01vZGVsLl9fZHpBeGlzUHJveHkgPSBuZXcgQXhpc1Byb3h5KGF4aXNEaW0sIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCk7XG4gICAgICAgIHByb3h5TGlzdC5wdXNoKGF4aXNNb2RlbC5fX2R6QXhpc1Byb3h5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgc2VyaWVzTW9kZWxNYXAgPSBjcmVhdGVIYXNoTWFwKCk7XG4gICAgZWFjaChwcm94eUxpc3QsIGZ1bmN0aW9uIChheGlzUHJveHkpIHtcbiAgICAgIGVhY2goYXhpc1Byb3h5LmdldFRhcmdldFNlcmllc01vZGVscygpLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgc2VyaWVzTW9kZWxNYXAuc2V0KHNlcmllc01vZGVsLnVpZCwgc2VyaWVzTW9kZWwpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlcmllc01vZGVsTWFwO1xuICB9LFxuICAvLyBDb25zaWRlciBhcHBlbmREYXRhLCB3aGVyZSBmaWx0ZXIgc2hvdWxkIGJlIHBlcmZvcm1lZC4gQmVjYXVzZSBkYXRhIHByb2Nlc3MgaXNcbiAgLy8gaW4gYmxvY2sgbW9kZSBjdXJyZW50bHksIGl0IGlzIG5vdCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoYXQgdGhlIG92ZXJhbGxQcm9ncmVzc1xuICAvLyBleGVjdXRlIGV2ZXJ5IGZyYW1lLlxuICBvdmVyYWxsUmVzZXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ2RhdGFab29tJywgZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICAgIC8vIFdlIGNhbGN1bGF0ZSB3aW5kb3cgYW5kIHJlc2V0IGF4aXMgaGVyZSBidXQgbm90IGluIG1vZGVsXG4gICAgICAvLyBpbml0IHN0YWdlIGFuZCBub3QgYWZ0ZXIgYWN0aW9uIGRpc3BhdGNoIGhhbmRsZXIsIGJlY2F1c2VcbiAgICAgIC8vIHJlc2V0IHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgc2VyaWVzRGF0YS5yZXN0b3JlRGF0YS5cbiAgICAgIGRhdGFab29tTW9kZWwuZWFjaFRhcmdldEF4aXMoZnVuY3Rpb24gKGF4aXNEaW0sIGF4aXNJbmRleCkge1xuICAgICAgICBkYXRhWm9vbU1vZGVsLmdldEF4aXNQcm94eShheGlzRGltLCBheGlzSW5kZXgpLnJlc2V0KGRhdGFab29tTW9kZWwpO1xuICAgICAgfSk7IC8vIENhdXRpb246IGRhdGEgem9vbSBmaWx0ZXJpbmcgaXMgb3JkZXIgc2Vuc2l0aXZlIHdoZW4gdXNpbmdcbiAgICAgIC8vIHBlcmNlbnQgcmFuZ2UgYW5kIG5vIG1pbi9tYXgvc2NhbGUgc2V0IG9uIGF4aXMuXG4gICAgICAvLyBGb3IgZXhhbXBsZSwgd2UgaGF2ZSBkYXRhWm9vbSBkZWZpbml0aW9uOlxuICAgICAgLy8gW1xuICAgICAgLy8gICAgICB7eEF4aXNJbmRleDogMCwgc3RhcnQ6IDMwLCBlbmQ6IDcwfSxcbiAgICAgIC8vICAgICAge3lBeGlzSW5kZXg6IDAsIHN0YXJ0OiAyMCwgZW5kOiA4MH1cbiAgICAgIC8vIF1cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgWzIwLCA4MF0gb2YgeS1kYXRhWm9vbSBzaG91bGQgYmUgYmFzZWQgb24gZGF0YVxuICAgICAgLy8gdGhhdCBoYXZlIGZpbHRlcmVkIGJ5IHgtZGF0YVpvb20gdXNpbmcgcmFuZ2Ugb2YgWzMwLCA3MF0sXG4gICAgICAvLyBidXQgc2hvdWxkIG5vdCBiZSBiYXNlZCBvbiBmdWxsIHJhdyBkYXRhLiBUaHVzIHNsaWRpbmdcbiAgICAgIC8vIHgtZGF0YVpvb20gd2lsbCBjaGFuZ2UgYm90aCByYW5nZXMgb2YgeEF4aXMgYW5kIHlBeGlzLFxuICAgICAgLy8gd2hpbGUgc2xpZGluZyB5LWRhdGFab29tIHdpbGwgb25seSBjaGFuZ2UgdGhlIHJhbmdlIG9mIHlBeGlzLlxuICAgICAgLy8gU28gd2Ugc2hvdWxkIGZpbHRlciB4LWF4aXMgYWZ0ZXIgcmVzZXQgeC1heGlzIGltbWVkaWF0ZWx5LFxuICAgICAgLy8gYW5kIHRoZW4gcmVzZXQgeS1heGlzIGFuZCBmaWx0ZXIgeS1heGlzLlxuXG4gICAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChheGlzRGltLCBheGlzSW5kZXgpIHtcbiAgICAgICAgZGF0YVpvb21Nb2RlbC5nZXRBeGlzUHJveHkoYXhpc0RpbSwgYXhpc0luZGV4KS5maWx0ZXJEYXRhKGRhdGFab29tTW9kZWwsIGFwaSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ2RhdGFab29tJywgZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICAgIC8vIEZ1bGxmaWxsIGFsbCBvZiB0aGUgcmFuZ2UgcHJvcHMgc28gdGhhdCB1c2VyXG4gICAgICAvLyBpcyBhYmxlIHRvIGdldCB0aGVtIGZyb20gY2hhcnQuZ2V0T3B0aW9uKCkuXG4gICAgICB2YXIgYXhpc1Byb3h5ID0gZGF0YVpvb21Nb2RlbC5maW5kUmVwcmVzZW50YXRpdmVBeGlzUHJveHkoKTtcblxuICAgICAgaWYgKGF4aXNQcm94eSkge1xuICAgICAgICB2YXIgcGVyY2VudFJhbmdlID0gYXhpc1Byb3h5LmdldERhdGFQZXJjZW50V2luZG93KCk7XG4gICAgICAgIHZhciB2YWx1ZVJhbmdlID0gYXhpc1Byb3h5LmdldERhdGFWYWx1ZVdpbmRvdygpO1xuICAgICAgICBkYXRhWm9vbU1vZGVsLnNldENhbGN1bGF0ZWRSYW5nZSh7XG4gICAgICAgICAgc3RhcnQ6IHBlcmNlbnRSYW5nZVswXSxcbiAgICAgICAgICBlbmQ6IHBlcmNlbnRSYW5nZVsxXSxcbiAgICAgICAgICBzdGFydFZhbHVlOiB2YWx1ZVJhbmdlWzBdLFxuICAgICAgICAgIGVuZFZhbHVlOiB2YWx1ZVJhbmdlWzFdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgZGF0YVpvb21Qcm9jZXNzb3I7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IGluZGV4T2YsIGNyZWF0ZUhhc2hNYXAsIGFzc2VydCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5leHBvcnQgdmFyIERBVEFfWk9PTV9BWElTX0RJTUVOU0lPTlMgPSBbJ3gnLCAneScsICdyYWRpdXMnLCAnYW5nbGUnLCAnc2luZ2xlJ107IC8vIFN1cHBvcnRlZCBjb29yZHMuXG4vLyBGSVhNRTogcG9sYXIgaGFzIGJlZW4gYnJva2VuIChidXQgcmFyZWx5IHVzZWQpLlxuXG52YXIgU0VSSUVTX0NPT1JEUyA9IFsnY2FydGVzaWFuMmQnLCAncG9sYXInLCAnc2luZ2xlQXhpcyddO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29vcmRTdXBwb3J0ZWQoc2VyaWVzTW9kZWwpIHtcbiAgdmFyIGNvb3JkVHlwZSA9IHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpO1xuICByZXR1cm4gaW5kZXhPZihTRVJJRVNfQ09PUkRTLCBjb29yZFR5cGUpID49IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QXhpc01haW5UeXBlKGF4aXNEaW0pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoYXhpc0RpbSk7XG4gIH1cblxuICByZXR1cm4gYXhpc0RpbSArICdBeGlzJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBeGlzSW5kZXhQcm9wTmFtZShheGlzRGltKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KGF4aXNEaW0pO1xuICB9XG5cbiAgcmV0dXJuIGF4aXNEaW0gKyAnQXhpc0luZGV4Jztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBeGlzSWRQcm9wTmFtZShheGlzRGltKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KGF4aXNEaW0pO1xuICB9XG5cbiAgcmV0dXJuIGF4aXNEaW0gKyAnQXhpc0lkJztcbn1cbi8qKlxuICogSWYgdHdvIGRhdGFab29tTW9kZWxzIGhhcyB0aGUgc2FtZSBheGlzIGNvbnRyb2xsZWQsIHdlIHNheSB0aGF0IHRoZXkgYXJlICdsaW5rZWQnLlxuICogVGhpcyBmdW5jdGlvbiBmaW5kcyBhbGwgbGlua2VkIGRhdGFab29tTW9kZWxzIHN0YXJ0IGZyb20gdGhlIGdpdmVuIHBheWxvYWQuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFZmZlY3RlZERhdGFab29tcyhlY01vZGVsLCBwYXlsb2FkKSB7XG4gIC8vIEtleTogYERhdGFab29tQXhpc0RpbWVuc2lvbmBcbiAgdmFyIGF4aXNSZWNvcmRzID0gY3JlYXRlSGFzaE1hcCgpO1xuICB2YXIgZWZmZWN0ZWRNb2RlbHMgPSBbXTsgLy8gS2V5OiB1aWQgb2YgZGF0YVpvb21Nb2RlbFxuXG4gIHZhciBlZmZlY3RlZE1vZGVsTWFwID0gY3JlYXRlSGFzaE1hcCgpOyAvLyBGaW5kIHRoZSBkYXRhWm9vbXMgc3BlY2lmaWVkIGJ5IHBheWxvYWQuXG5cbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICBtYWluVHlwZTogJ2RhdGFab29tJyxcbiAgICBxdWVyeTogcGF5bG9hZFxuICB9LCBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgIGlmICghZWZmZWN0ZWRNb2RlbE1hcC5nZXQoZGF0YVpvb21Nb2RlbC51aWQpKSB7XG4gICAgICBhZGRUb0VmZmVjdGVkKGRhdGFab29tTW9kZWwpO1xuICAgIH1cbiAgfSk7IC8vIFN0YXJ0IGZyb20gdGhlIGdpdmVuIGRhdGFab29tTW9kZWxzLCB0cmF2ZWwgdGhlIGdyYXBoIHRvIGZpbmRcbiAgLy8gYWxsIG9mIHRoZSBsaW5rZWQgZGF0YVpvb20gbW9kZWxzLlxuXG4gIHZhciBmb3VuZE5ld0xpbms7XG5cbiAgZG8ge1xuICAgIGZvdW5kTmV3TGluayA9IGZhbHNlO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnZGF0YVpvb20nLCBwcm9jZXNzU2luZ2xlKTtcbiAgfSB3aGlsZSAoZm91bmROZXdMaW5rKTtcblxuICBmdW5jdGlvbiBwcm9jZXNzU2luZ2xlKGRhdGFab29tTW9kZWwpIHtcbiAgICBpZiAoIWVmZmVjdGVkTW9kZWxNYXAuZ2V0KGRhdGFab29tTW9kZWwudWlkKSAmJiBpc0xpbmtlZChkYXRhWm9vbU1vZGVsKSkge1xuICAgICAgYWRkVG9FZmZlY3RlZChkYXRhWm9vbU1vZGVsKTtcbiAgICAgIGZvdW5kTmV3TGluayA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVG9FZmZlY3RlZChkYXRhWm9vbSkge1xuICAgIGVmZmVjdGVkTW9kZWxNYXAuc2V0KGRhdGFab29tLnVpZCwgdHJ1ZSk7XG4gICAgZWZmZWN0ZWRNb2RlbHMucHVzaChkYXRhWm9vbSk7XG4gICAgbWFya0F4aXNDb250cm9sbGVkKGRhdGFab29tKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTGlua2VkKGRhdGFab29tTW9kZWwpIHtcbiAgICB2YXIgaXNMaW5rID0gZmFsc2U7XG4gICAgZGF0YVpvb21Nb2RlbC5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoYXhpc0RpbSwgYXhpc0luZGV4KSB7XG4gICAgICB2YXIgYXhpc0lkeEFyciA9IGF4aXNSZWNvcmRzLmdldChheGlzRGltKTtcblxuICAgICAgaWYgKGF4aXNJZHhBcnIgJiYgYXhpc0lkeEFycltheGlzSW5kZXhdKSB7XG4gICAgICAgIGlzTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzTGluaztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtBeGlzQ29udHJvbGxlZChkYXRhWm9vbU1vZGVsKSB7XG4gICAgZGF0YVpvb21Nb2RlbC5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoYXhpc0RpbSwgYXhpc0luZGV4KSB7XG4gICAgICAoYXhpc1JlY29yZHMuZ2V0KGF4aXNEaW0pIHx8IGF4aXNSZWNvcmRzLnNldChheGlzRGltLCBbXSkpW2F4aXNJbmRleF0gPSB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVmZmVjdGVkTW9kZWxzO1xufVxuLyoqXG4gKiBGaW5kIHRoZSBmaXJzdCB0YXJnZXQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gKiBBdmFpbGFibGUgYWZ0ZXIgbW9kZWwgYnVpbHQuXG4gKlxuICogQHJldHVybiBMaWtlIHtcbiAqICAgICAgICAgICAgICAgICAgZ3JpZDogW1xuICogICAgICAgICAgICAgICAgICAgICAge21vZGVsOiBjb29yZDAsIGF4aXNNb2RlbHM6IFtheGlzMSwgYXhpczNdLCBjb29yZEluZGV4OiAxfSxcbiAqICAgICAgICAgICAgICAgICAgICAgIHttb2RlbDogY29vcmQxLCBheGlzTW9kZWxzOiBbYXhpczAsIGF4aXMyXSwgY29vcmRJbmRleDogMH0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgICAgICAgICAgXSwgIC8vIGNhcnRlc2lhbnMgbXVzdCBub3QgYmUgbnVsbC91bmRlZmluZWQuXG4gKiAgICAgICAgICAgICAgICAgIHBvbGFyOiBbXG4gKiAgICAgICAgICAgICAgICAgICAgICB7bW9kZWw6IGNvb3JkMCwgYXhpc01vZGVsczogW2F4aXM0XSwgY29vcmRJbmRleDogMH0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgICAgICAgICAgXSwgIC8vIHBvbGFycyBtdXN0IG5vdCBiZSBudWxsL3VuZGVmaW5lZC5cbiAqICAgICAgICAgICAgICAgICAgc2luZ2xlQXhpczogW1xuICogICAgICAgICAgICAgICAgICAgICAge21vZGVsOiBjb29yZDAsIGF4aXNNb2RlbHM6IFtdLCBjb29yZEluZGV4OiAwfVxuICogICAgICAgICAgICAgICAgICBdXG4gKiAgICAgICAgICAgICAgfVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb2xsZWN0UmVmZXJDb29yZFN5c01vZGVsSW5mbyhkYXRhWm9vbU1vZGVsKSB7XG4gIHZhciBlY01vZGVsID0gZGF0YVpvb21Nb2RlbC5lY01vZGVsO1xuICB2YXIgY29vcmRTeXNJbmZvV3JhcCA9IHtcbiAgICBpbmZvTGlzdDogW10sXG4gICAgaW5mb01hcDogY3JlYXRlSGFzaE1hcCgpXG4gIH07XG4gIGRhdGFab29tTW9kZWwuZWFjaFRhcmdldEF4aXMoZnVuY3Rpb24gKGF4aXNEaW0sIGF4aXNJbmRleCkge1xuICAgIHZhciBheGlzTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudChnZXRBeGlzTWFpblR5cGUoYXhpc0RpbSksIGF4aXNJbmRleCk7XG5cbiAgICBpZiAoIWF4aXNNb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb29yZFN5c01vZGVsID0gYXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKTtcblxuICAgIGlmICghY29vcmRTeXNNb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb29yZFN5c1VpZCA9IGNvb3JkU3lzTW9kZWwudWlkO1xuICAgIHZhciBjb29yZFN5c0luZm8gPSBjb29yZFN5c0luZm9XcmFwLmluZm9NYXAuZ2V0KGNvb3JkU3lzVWlkKTtcblxuICAgIGlmICghY29vcmRTeXNJbmZvKSB7XG4gICAgICBjb29yZFN5c0luZm8gPSB7XG4gICAgICAgIG1vZGVsOiBjb29yZFN5c01vZGVsLFxuICAgICAgICBheGlzTW9kZWxzOiBbXVxuICAgICAgfTtcbiAgICAgIGNvb3JkU3lzSW5mb1dyYXAuaW5mb0xpc3QucHVzaChjb29yZFN5c0luZm8pO1xuICAgICAgY29vcmRTeXNJbmZvV3JhcC5pbmZvTWFwLnNldChjb29yZFN5c1VpZCwgY29vcmRTeXNJbmZvKTtcbiAgICB9XG5cbiAgICBjb29yZFN5c0luZm8uYXhpc01vZGVscy5wdXNoKGF4aXNNb2RlbCk7XG4gIH0pO1xuICByZXR1cm4gY29vcmRTeXNJbmZvV3JhcDtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcbi8qKlxuICogQHBhcmFtIGVjTW9kZWxcbiAqIEBwYXJhbSBuZXdTbmFwc2hvdCBrZXkgaXMgZGF0YVpvb21JZFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwdXNoKGVjTW9kZWwsIG5ld1NuYXBzaG90KSB7XG4gIHZhciBzdG9yZWRTbmFwc2hvdHMgPSBnZXRTdG9yZVNuYXBzaG90cyhlY01vZGVsKTsgLy8gSWYgcHJldmlvdXMgZGF0YVpvb20gY2FuIG5vdCBiZSBmb3VuZCxcbiAgLy8gY29tcGxldGUgYW4gcmFuZ2Ugd2l0aCBjdXJyZW50IHJhbmdlLlxuXG4gIGVhY2gobmV3U25hcHNob3QsIGZ1bmN0aW9uIChiYXRjaEl0ZW0sIGRhdGFab29tSWQpIHtcbiAgICB2YXIgaSA9IHN0b3JlZFNuYXBzaG90cy5sZW5ndGggLSAxO1xuXG4gICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgc25hcHNob3QgPSBzdG9yZWRTbmFwc2hvdHNbaV07XG5cbiAgICAgIGlmIChzbmFwc2hvdFtkYXRhWm9vbUlkXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIC8vIE5vIG9yaWdpbiByYW5nZSBzZXQsIGNyZWF0ZSBvbmUgYnkgY3VycmVudCByYW5nZS5cbiAgICAgIHZhciBkYXRhWm9vbU1vZGVsID0gZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgICBtYWluVHlwZTogJ2RhdGFab29tJyxcbiAgICAgICAgc3ViVHlwZTogJ3NlbGVjdCcsXG4gICAgICAgIGlkOiBkYXRhWm9vbUlkXG4gICAgICB9KVswXTtcblxuICAgICAgaWYgKGRhdGFab29tTW9kZWwpIHtcbiAgICAgICAgdmFyIHBlcmNlbnRSYW5nZSA9IGRhdGFab29tTW9kZWwuZ2V0UGVyY2VudFJhbmdlKCk7XG4gICAgICAgIHN0b3JlZFNuYXBzaG90c1swXVtkYXRhWm9vbUlkXSA9IHtcbiAgICAgICAgICBkYXRhWm9vbUlkOiBkYXRhWm9vbUlkLFxuICAgICAgICAgIHN0YXJ0OiBwZXJjZW50UmFuZ2VbMF0sXG4gICAgICAgICAgZW5kOiBwZXJjZW50UmFuZ2VbMV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBzdG9yZWRTbmFwc2hvdHMucHVzaChuZXdTbmFwc2hvdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9wKGVjTW9kZWwpIHtcbiAgdmFyIHN0b3JlZFNuYXBzaG90cyA9IGdldFN0b3JlU25hcHNob3RzKGVjTW9kZWwpO1xuICB2YXIgaGVhZCA9IHN0b3JlZFNuYXBzaG90c1tzdG9yZWRTbmFwc2hvdHMubGVuZ3RoIC0gMV07XG4gIHN0b3JlZFNuYXBzaG90cy5sZW5ndGggPiAxICYmIHN0b3JlZFNuYXBzaG90cy5wb3AoKTsgLy8gRmluZCB0b3AgZm9yIGFsbCBkYXRhWm9vbS5cblxuICB2YXIgc25hcHNob3QgPSB7fTtcbiAgZWFjaChoZWFkLCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBkYXRhWm9vbUlkKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0b3JlZFNuYXBzaG90cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgYmF0Y2hJdGVtID0gc3RvcmVkU25hcHNob3RzW2ldW2RhdGFab29tSWRdO1xuXG4gICAgICBpZiAoYmF0Y2hJdGVtKSB7XG4gICAgICAgIHNuYXBzaG90W2RhdGFab29tSWRdID0gYmF0Y2hJdGVtO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc25hcHNob3Q7XG59XG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoZWNNb2RlbCkge1xuICBpbm5lcihlY01vZGVsKS5zbmFwc2hvdHMgPSBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50KGVjTW9kZWwpIHtcbiAgcmV0dXJuIGdldFN0b3JlU25hcHNob3RzKGVjTW9kZWwpLmxlbmd0aDtcbn1cbi8qKlxuICogSGlzdG9yeSBsZW5ndGggb2YgZWFjaCBkYXRhWm9vbSBtYXkgYmUgZGlmZmVyZW50LlxuICogdGhpcy5faGlzdG9yeVswXSBpcyB1c2VkIHRvIHN0b3JlIG9yaWdpbiByYW5nZS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRTdG9yZVNuYXBzaG90cyhlY01vZGVsKSB7XG4gIHZhciBzdG9yZSA9IGlubmVyKGVjTW9kZWwpO1xuXG4gIGlmICghc3RvcmUuc25hcHNob3RzKSB7XG4gICAgc3RvcmUuc25hcHNob3RzID0gW3t9XTtcbiAgfVxuXG4gIHJldHVybiBzdG9yZS5zbmFwc2hvdHM7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IHVzZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbic7XG5pbXBvcnQgeyBpbnN0YWxsIGFzIGluc3RhbGxEYXRhWm9vbUluc2lkZSB9IGZyb20gJy4vaW5zdGFsbERhdGFab29tSW5zaWRlJztcbmltcG9ydCB7IGluc3RhbGwgYXMgaW5zdGFsbERhdGFab29tU2xpZGVyIH0gZnJvbSAnLi9pbnN0YWxsRGF0YVpvb21TbGlkZXInO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHVzZShpbnN0YWxsRGF0YVpvb21JbnNpZGUpO1xuICB1c2UoaW5zdGFsbERhdGFab29tU2xpZGVyKTsgLy8gRG8gbm90IGluc3RhbGwgJy4vZGF0YVpvb21TZWxlY3QnLFxuICAvLyBzaW5jZSBpdCBvbmx5IHdvcmsgZm9yIHRvb2xib3ggZGF0YVpvb20uXG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCBkYXRhWm9vbVByb2Nlc3NvciBmcm9tICcuL2RhdGFab29tUHJvY2Vzc29yJztcbmltcG9ydCBpbnN0YWxsRGF0YVpvb21BY3Rpb24gZnJvbSAnLi9kYXRhWm9vbUFjdGlvbic7XG52YXIgaW5zdGFsbGVkID0gZmFsc2U7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbnN0YWxsQ29tbW9uKHJlZ2lzdGVycykge1xuICBpZiAoaW5zdGFsbGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaW5zdGFsbGVkID0gdHJ1ZTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJvY2Vzc29yKHJlZ2lzdGVycy5QUklPUklUWS5QUk9DRVNTT1IuRklMVEVSLCBkYXRhWm9vbVByb2Nlc3Nvcik7XG4gIGluc3RhbGxEYXRhWm9vbUFjdGlvbihyZWdpc3RlcnMpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTdWJUeXBlRGVmYXVsdGVyKCdkYXRhWm9vbScsIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBEZWZhdWx0ICdzbGlkZXInIHdoZW4gbm8gdHlwZSBzcGVjaWZpZWQuXG4gICAgcmV0dXJuICdzbGlkZXInO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IEluc2lkZVpvb21Nb2RlbCBmcm9tICcuL0luc2lkZVpvb21Nb2RlbCc7XG5pbXBvcnQgSW5zaWRlWm9vbVZpZXcgZnJvbSAnLi9JbnNpZGVab29tVmlldyc7XG5pbXBvcnQgeyBpbnN0YWxsRGF0YVpvb21Sb2FtUHJvY2Vzc29yIH0gZnJvbSAnLi9yb2Ftcyc7XG5pbXBvcnQgaW5zdGFsbENvbW1vbiBmcm9tICcuL2luc3RhbGxDb21tb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIGluc3RhbGxDb21tb24ocmVnaXN0ZXJzKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50TW9kZWwoSW5zaWRlWm9vbU1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhJbnNpZGVab29tVmlldyk7XG4gIGluc3RhbGxEYXRhWm9vbVJvYW1Qcm9jZXNzb3IocmVnaXN0ZXJzKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IFNlbGVjdFpvb21Nb2RlbCBmcm9tICcuL1NlbGVjdFpvb21Nb2RlbCc7XG5pbXBvcnQgU2VsZWN0Wm9vbVZpZXcgZnJvbSAnLi9TZWxlY3Rab29tVmlldyc7XG5pbXBvcnQgaW5zdGFsbENvbW1vbiBmcm9tICcuL2luc3RhbGxDb21tb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKFNlbGVjdFpvb21Nb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoU2VsZWN0Wm9vbVZpZXcpO1xuICBpbnN0YWxsQ29tbW9uKHJlZ2lzdGVycyk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCBTbGlkZXJab29tTW9kZWwgZnJvbSAnLi9TbGlkZXJab29tTW9kZWwnO1xuaW1wb3J0IFNsaWRlclpvb21WaWV3IGZyb20gJy4vU2xpZGVyWm9vbVZpZXcnO1xuaW1wb3J0IGluc3RhbGxDb21tb24gZnJvbSAnLi9pbnN0YWxsQ29tbW9uJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChTbGlkZXJab29tTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KFNsaWRlclpvb21WaWV3KTtcbiAgaW5zdGFsbENvbW1vbihyZWdpc3RlcnMpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBPbmx5IGNyZWF0ZSBvbmUgcm9hbSBjb250cm9sbGVyIGZvciBlYWNoIGNvb3JkaW5hdGUgc3lzdGVtLlxuLy8gb25lIHJvYW0gY29udHJvbGxlciBtaWdodCBiZSByZWZlcmVkIGJ5IHR3byBpbnNpZGUgZGF0YSB6b29tXG4vLyBjb21wb25lbnRzIChmb3IgZXhhbXBsZSwgb25lIGZvciB4IGFuZCBvbmUgZm9yIHkpLiBXaGVuIHVzZXJcbi8vIHBhbiBvciB6b29tLCBvbmx5IGRpc3BhdGNoIG9uZSBhY3Rpb24gZm9yIHRob3NlIGRhdGEgem9vbVxuLy8gY29tcG9uZW50cy5cbmltcG9ydCBSb2FtQ29udHJvbGxlciBmcm9tICcuLi8uLi9jb21wb25lbnQvaGVscGVyL1JvYW1Db250cm9sbGVyJztcbmltcG9ydCAqIGFzIHRocm90dGxlVXRpbCBmcm9tICcuLi8uLi91dGlsL3Rocm90dGxlJztcbmltcG9ydCB7IG1ha2VJbm5lciB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwnO1xuaW1wb3J0IHsgZWFjaCwgY3VycnksIGNyZWF0ZUhhc2hNYXAgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgY29sbGVjdFJlZmVyQ29vcmRTeXNNb2RlbEluZm8gfSBmcm9tICcuL2hlbHBlcic7XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcbmV4cG9ydCBmdW5jdGlvbiBzZXRWaWV3SW5mb1RvQ29vcmRTeXNSZWNvcmQoYXBpLCBkYXRhWm9vbU1vZGVsLCBnZXRSYW5nZSkge1xuICBpbm5lcihhcGkpLmNvb3JkU3lzUmVjb3JkTWFwLmVhY2goZnVuY3Rpb24gKGNvb3JkU3lzUmVjb3JkKSB7XG4gICAgdmFyIGR6SW5mbyA9IGNvb3JkU3lzUmVjb3JkLmRhdGFab29tSW5mb01hcC5nZXQoZGF0YVpvb21Nb2RlbC51aWQpO1xuXG4gICAgaWYgKGR6SW5mbykge1xuICAgICAgZHpJbmZvLmdldFJhbmdlID0gZ2V0UmFuZ2U7XG4gICAgfVxuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlQ29vcmRTeXNSZWNvcmRJZk5lZWRlZChhcGksIGRhdGFab29tTW9kZWwpIHtcbiAgdmFyIGNvb3JkU3lzUmVjb3JkTWFwID0gaW5uZXIoYXBpKS5jb29yZFN5c1JlY29yZE1hcDtcbiAgdmFyIGNvb3JkU3lzS2V5QXJyID0gY29vcmRTeXNSZWNvcmRNYXAua2V5cygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRTeXNLZXlBcnIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29vcmRTeXNLZXkgPSBjb29yZFN5c0tleUFycltpXTtcbiAgICB2YXIgY29vcmRTeXNSZWNvcmQgPSBjb29yZFN5c1JlY29yZE1hcC5nZXQoY29vcmRTeXNLZXkpO1xuICAgIHZhciBkYXRhWm9vbUluZm9NYXAgPSBjb29yZFN5c1JlY29yZC5kYXRhWm9vbUluZm9NYXA7XG5cbiAgICBpZiAoZGF0YVpvb21JbmZvTWFwKSB7XG4gICAgICB2YXIgZHpVaWQgPSBkYXRhWm9vbU1vZGVsLnVpZDtcbiAgICAgIHZhciBkekluZm8gPSBkYXRhWm9vbUluZm9NYXAuZ2V0KGR6VWlkKTtcblxuICAgICAgaWYgKGR6SW5mbykge1xuICAgICAgICBkYXRhWm9vbUluZm9NYXAucmVtb3ZlS2V5KGR6VWlkKTtcblxuICAgICAgICBpZiAoIWRhdGFab29tSW5mb01hcC5rZXlzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgZGlzcG9zZUNvb3JkU3lzUmVjb3JkKGNvb3JkU3lzUmVjb3JkTWFwLCBjb29yZFN5c1JlY29yZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcG9zZUNvb3JkU3lzUmVjb3JkKGNvb3JkU3lzUmVjb3JkTWFwLCBjb29yZFN5c1JlY29yZCkge1xuICBpZiAoY29vcmRTeXNSZWNvcmQpIHtcbiAgICBjb29yZFN5c1JlY29yZE1hcC5yZW1vdmVLZXkoY29vcmRTeXNSZWNvcmQubW9kZWwudWlkKTtcbiAgICB2YXIgY29udHJvbGxlciA9IGNvb3JkU3lzUmVjb3JkLmNvbnRyb2xsZXI7XG4gICAgY29udHJvbGxlciAmJiBjb250cm9sbGVyLmRpc3Bvc2UoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb29yZFN5c1JlY29yZChhcGksIGNvb3JkU3lzTW9kZWwpIHtcbiAgLy8gVGhlc2UgaW5pdCBwcm9wcyB3aWxsIG5ldmVyIGNoYW5nZSBhZnRlciByZWNvcmQgY3JlYXRlZC5cbiAgdmFyIGNvb3JkU3lzUmVjb3JkID0ge1xuICAgIG1vZGVsOiBjb29yZFN5c01vZGVsLFxuICAgIGNvbnRhaW5zUG9pbnQ6IGN1cnJ5KGNvbnRhaW5zUG9pbnQsIGNvb3JkU3lzTW9kZWwpLFxuICAgIGRpc3BhdGNoQWN0aW9uOiBjdXJyeShkaXNwYXRjaEFjdGlvbiwgYXBpKSxcbiAgICBkYXRhWm9vbUluZm9NYXA6IG51bGwsXG4gICAgY29udHJvbGxlcjogbnVsbFxuICB9OyAvLyBNdXN0IG5vdCBkbyBhbnl0aGluZyBkZXBlbmRzIG9uIGNvb3JkU3lzUmVjb3JkIG91dHNpZGUgdGhlIGV2ZW50IGhhbmRsZXIgaGVyZSxcbiAgLy8gYmVjYXVzZSBjb29yZFN5c1JlY29yZCBub3QgY29tcGxldGVkIHlldC5cblxuICB2YXIgY29udHJvbGxlciA9IGNvb3JkU3lzUmVjb3JkLmNvbnRyb2xsZXIgPSBuZXcgUm9hbUNvbnRyb2xsZXIoYXBpLmdldFpyKCkpO1xuICBlYWNoKFsncGFuJywgJ3pvb20nLCAnc2Nyb2xsTW92ZSddLCBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgY29udHJvbGxlci5vbihldmVudE5hbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGJhdGNoID0gW107XG4gICAgICBjb29yZFN5c1JlY29yZC5kYXRhWm9vbUluZm9NYXAuZWFjaChmdW5jdGlvbiAoZHpJbmZvKSB7XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGJlaGF2aW9ycyAoem9vbU9uTW91c2VXaGVlbCwgbW92ZU9uTW91c2VNb3ZlLFxuICAgICAgICAvLyBtb3ZlT25Nb3VzZVdoZWVsLCAuLi4pIGVuYWJsZWQuXG4gICAgICAgIGlmICghZXZlbnQuaXNBdmFpbGFibGVCZWhhdmlvcihkekluZm8ubW9kZWwub3B0aW9uKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXRob2QgPSAoZHpJbmZvLmdldFJhbmdlIHx8IHt9KVtldmVudE5hbWVdO1xuICAgICAgICB2YXIgcmFuZ2UgPSBtZXRob2QgJiYgbWV0aG9kKGR6SW5mby5kelJlZmVyQ29vcmRTeXNJbmZvLCBjb29yZFN5c1JlY29yZC5tb2RlbC5tYWluVHlwZSwgY29vcmRTeXNSZWNvcmQuY29udHJvbGxlciwgZXZlbnQpO1xuICAgICAgICAhZHpJbmZvLm1vZGVsLmdldCgnZGlzYWJsZWQnLCB0cnVlKSAmJiByYW5nZSAmJiBiYXRjaC5wdXNoKHtcbiAgICAgICAgICBkYXRhWm9vbUlkOiBkekluZm8ubW9kZWwuaWQsXG4gICAgICAgICAgc3RhcnQ6IHJhbmdlWzBdLFxuICAgICAgICAgIGVuZDogcmFuZ2VbMV1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGJhdGNoLmxlbmd0aCAmJiBjb29yZFN5c1JlY29yZC5kaXNwYXRjaEFjdGlvbihiYXRjaCk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gY29vcmRTeXNSZWNvcmQ7XG59XG4vKipcbiAqIFRoaXMgYWN0aW9uIHdpbGwgYmUgdGhyb3R0bGVkLlxuICovXG5cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oYXBpLCBiYXRjaCkge1xuICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgIHR5cGU6ICdkYXRhWm9vbScsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBlYXNpbmc6ICdjdWJpY091dCcsXG4gICAgICBkdXJhdGlvbjogMTAwXG4gICAgfSxcbiAgICBiYXRjaDogYmF0Y2hcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zUG9pbnQoY29vcmRTeXNNb2RlbCwgZSwgeCwgeSkge1xuICByZXR1cm4gY29vcmRTeXNNb2RlbC5jb29yZGluYXRlU3lzdGVtLmNvbnRhaW5Qb2ludChbeCwgeV0pO1xufVxuLyoqXG4gKiBNZXJnZSByb2FtQ29udHJvbGxlciBzZXR0aW5ncyB3aGVuIG11bHRpcGxlIGRhdGFab29tcyBzaGFyZSBvbmUgcm9hbUNvbnRyb2xsZXIuXG4gKi9cblxuXG5mdW5jdGlvbiBtZXJnZUNvbnRyb2xsZXJQYXJhbXMoZGF0YVpvb21JbmZvTWFwKSB7XG4gIHZhciBjb250cm9sVHlwZTsgLy8gRE8gTk9UIHVzZSByZXNlcnZlZCB3b3JkICh0cnVlLCBmYWxzZSwgdW5kZWZpbmVkKSBhcyBrZXkgbGl0ZXJhbGx5LiBFdmVuIGlmIGVuY2Fwc3VsYXRlZFxuICAvLyBhcyBzdHJpbmcsIGl0IGlzIHByb2JhYmx5IHJldmVydCB0byByZXNlcnZlZCB3b3JkIGJ5IGNvbXByZXNzIHRvb2wuIFNlZSAjNzQxMS5cblxuICB2YXIgcHJlZml4ID0gJ3R5cGVfJztcbiAgdmFyIHR5cGVQcmlvcml0eSA9IHtcbiAgICAndHlwZV90cnVlJzogMixcbiAgICAndHlwZV9tb3ZlJzogMSxcbiAgICAndHlwZV9mYWxzZSc6IDAsXG4gICAgJ3R5cGVfdW5kZWZpbmVkJzogLTFcbiAgfTtcbiAgdmFyIHByZXZlbnREZWZhdWx0TW91c2VNb3ZlID0gdHJ1ZTtcbiAgZGF0YVpvb21JbmZvTWFwLmVhY2goZnVuY3Rpb24gKGRhdGFab29tSW5mbykge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gZGF0YVpvb21JbmZvLm1vZGVsO1xuICAgIHZhciBvbmVUeXBlID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2Rpc2FibGVkJywgdHJ1ZSkgPyBmYWxzZSA6IGRhdGFab29tTW9kZWwuZ2V0KCd6b29tTG9jaycsIHRydWUpID8gJ21vdmUnIDogdHJ1ZTtcblxuICAgIGlmICh0eXBlUHJpb3JpdHlbcHJlZml4ICsgb25lVHlwZV0gPiB0eXBlUHJpb3JpdHlbcHJlZml4ICsgY29udHJvbFR5cGVdKSB7XG4gICAgICBjb250cm9sVHlwZSA9IG9uZVR5cGU7XG4gICAgfSAvLyBQcmV2ZW50IGRlZmF1bHQgbW92ZSBldmVudCBieSBkZWZhdWx0LiBJZiBvbmUgZmFsc2UsIGRvIG5vdCBwcmV2ZW50LiBPdGhlcndpc2VcbiAgICAvLyB1c2VycyBtYXkgYmUgY29uZnVzZWQgd2h5IGl0IGRvZXMgbm90IHdvcmsgd2hlbiBtdWx0aXBsZSBpbnNpZGVab29tcyBleGlzdC5cblxuXG4gICAgcHJldmVudERlZmF1bHRNb3VzZU1vdmUgPSBwcmV2ZW50RGVmYXVsdE1vdXNlTW92ZSAmJiBkYXRhWm9vbU1vZGVsLmdldCgncHJldmVudERlZmF1bHRNb3VzZU1vdmUnLCB0cnVlKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY29udHJvbFR5cGU6IGNvbnRyb2xUeXBlLFxuICAgIG9wdDoge1xuICAgICAgLy8gUm9hbUNvbnRyb2xsZXIgd2lsbCBlbmFibGUgYWxsIG9mIHRoZXNlIGZ1bmN0aW9uYWxpdGllcyxcbiAgICAgIC8vIGFuZCB0aGUgZmluYWwgYmVoYXZpb3IgaXMgZGV0ZXJtaW5lZCBieSBpdHMgZXZlbnQgbGlzdGVuZXJcbiAgICAgIC8vIHByb3ZpZGVkIGJ5IGVhY2ggaW5zaWRlIHpvb20uXG4gICAgICB6b29tT25Nb3VzZVdoZWVsOiB0cnVlLFxuICAgICAgbW92ZU9uTW91c2VNb3ZlOiB0cnVlLFxuICAgICAgbW92ZU9uTW91c2VXaGVlbDogdHJ1ZSxcbiAgICAgIHByZXZlbnREZWZhdWx0TW91c2VNb3ZlOiAhIXByZXZlbnREZWZhdWx0TW91c2VNb3ZlXG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbERhdGFab29tUm9hbVByb2Nlc3NvcihyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJvY2Vzc29yKHJlZ2lzdGVycy5QUklPUklUWS5QUk9DRVNTT1IuRklMVEVSLCBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGFwaUlubmVyID0gaW5uZXIoYXBpKTtcbiAgICB2YXIgY29vcmRTeXNSZWNvcmRNYXAgPSBhcGlJbm5lci5jb29yZFN5c1JlY29yZE1hcCB8fCAoYXBpSW5uZXIuY29vcmRTeXNSZWNvcmRNYXAgPSBjcmVhdGVIYXNoTWFwKCkpO1xuICAgIGNvb3JkU3lzUmVjb3JkTWFwLmVhY2goZnVuY3Rpb24gKGNvb3JkU3lzUmVjb3JkKSB7XG4gICAgICAvLyBgY29vcmRTeXNSZWNvcmRNYXBgIGFsd2F5cyBleGlzdHMgKGJlY3Vhc2UgaXQgaG9sZCB0aGUgYHJvYW0gY29udHJvbGxlcmAsIHdoaWNoIHNob3VsZFxuICAgICAgLy8gYmV0dGVyIG5vdCByZS1jcmVhdGUgZWFjaCB0aW1lKSwgYnV0IGNsZWFyIGBkYXRhWm9vbUluZm9NYXBgIGVhY2ggcm91bmQgb2YgdGhlIHdvcmtmbG93LlxuICAgICAgY29vcmRTeXNSZWNvcmQuZGF0YVpvb21JbmZvTWFwID0gbnVsbDtcbiAgICB9KTtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6ICdkYXRhWm9vbScsXG4gICAgICBzdWJUeXBlOiAnaW5zaWRlJ1xuICAgIH0sIGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICB2YXIgZHpSZWZlckNvb3JkU3lzV3JhcCA9IGNvbGxlY3RSZWZlckNvb3JkU3lzTW9kZWxJbmZvKGRhdGFab29tTW9kZWwpO1xuICAgICAgZWFjaChkelJlZmVyQ29vcmRTeXNXcmFwLmluZm9MaXN0LCBmdW5jdGlvbiAoZHpDb29yZFN5c0luZm8pIHtcbiAgICAgICAgdmFyIGNvb3JkU3lzVWlkID0gZHpDb29yZFN5c0luZm8ubW9kZWwudWlkO1xuICAgICAgICB2YXIgY29vcmRTeXNSZWNvcmQgPSBjb29yZFN5c1JlY29yZE1hcC5nZXQoY29vcmRTeXNVaWQpIHx8IGNvb3JkU3lzUmVjb3JkTWFwLnNldChjb29yZFN5c1VpZCwgY3JlYXRlQ29vcmRTeXNSZWNvcmQoYXBpLCBkekNvb3JkU3lzSW5mby5tb2RlbCkpO1xuICAgICAgICB2YXIgZGF0YVpvb21JbmZvTWFwID0gY29vcmRTeXNSZWNvcmQuZGF0YVpvb21JbmZvTWFwIHx8IChjb29yZFN5c1JlY29yZC5kYXRhWm9vbUluZm9NYXAgPSBjcmVhdGVIYXNoTWFwKCkpOyAvLyBOb3RpY2UgdGhlc2UgcHJvcHMgbWlnaHQgYmUgY2hhbmdlZCBlYWNoIHRpbWUgZm9yIGEgc2luZ2xlIGRhdGFab29tTW9kZWwuXG5cbiAgICAgICAgZGF0YVpvb21JbmZvTWFwLnNldChkYXRhWm9vbU1vZGVsLnVpZCwge1xuICAgICAgICAgIGR6UmVmZXJDb29yZFN5c0luZm86IGR6Q29vcmRTeXNJbmZvLFxuICAgICAgICAgIG1vZGVsOiBkYXRhWm9vbU1vZGVsLFxuICAgICAgICAgIGdldFJhbmdlOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7IC8vICgxKSBNZXJnZSBkYXRhWm9vbSBzZXR0aW5ncyBmb3IgZWFjaCBjb29yZCBzeXMgYW5kIHNldCB0byB0aGUgcm9hbSBjb250cm9sbGVyLlxuICAgIC8vICgyKSBDbGVhciBjb29yZCBzeXMgaWYgbm90IHJlZmVyZWQgYnkgYW55IGRhdGFab29tLlxuXG4gICAgY29vcmRTeXNSZWNvcmRNYXAuZWFjaChmdW5jdGlvbiAoY29vcmRTeXNSZWNvcmQpIHtcbiAgICAgIHZhciBjb250cm9sbGVyID0gY29vcmRTeXNSZWNvcmQuY29udHJvbGxlcjtcbiAgICAgIHZhciBmaXJzdER6SW5mbztcbiAgICAgIHZhciBkYXRhWm9vbUluZm9NYXAgPSBjb29yZFN5c1JlY29yZC5kYXRhWm9vbUluZm9NYXA7XG5cbiAgICAgIGlmIChkYXRhWm9vbUluZm9NYXApIHtcbiAgICAgICAgdmFyIGZpcnN0RHpLZXkgPSBkYXRhWm9vbUluZm9NYXAua2V5cygpWzBdO1xuXG4gICAgICAgIGlmIChmaXJzdER6S2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBmaXJzdER6SW5mbyA9IGRhdGFab29tSW5mb01hcC5nZXQoZmlyc3REektleSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmaXJzdER6SW5mbykge1xuICAgICAgICBkaXNwb3NlQ29vcmRTeXNSZWNvcmQoY29vcmRTeXNSZWNvcmRNYXAsIGNvb3JkU3lzUmVjb3JkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udHJvbGxlclBhcmFtcyA9IG1lcmdlQ29udHJvbGxlclBhcmFtcyhkYXRhWm9vbUluZm9NYXApO1xuICAgICAgY29udHJvbGxlci5lbmFibGUoY29udHJvbGxlclBhcmFtcy5jb250cm9sVHlwZSwgY29udHJvbGxlclBhcmFtcy5vcHQpO1xuICAgICAgY29udHJvbGxlci5zZXRQb2ludGVyQ2hlY2tlcihjb29yZFN5c1JlY29yZC5jb250YWluc1BvaW50KTtcbiAgICAgIHRocm90dGxlVXRpbC5jcmVhdGVPclVwZGF0ZShjb29yZFN5c1JlY29yZCwgJ2Rpc3BhdGNoQWN0aW9uJywgZmlyc3REekluZm8ubW9kZWwuZ2V0KCd0aHJvdHRsZScsIHRydWUpLCAnZml4UmF0ZScpO1xuICAgIH0pO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG4vKipcbiAqIFRoaXMgbW9kdWxlIGlzIGltcG9ydGVkIGJ5IGVjaGFydHMgZGlyZWN0bHkuXG4gKlxuICogTm90aWNlOlxuICogQWx3YXlzIGtlZXAgdGhpcyBmaWxlIGV4aXN0cyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAqIEJlY2F1c2UgYmVmb3JlIDQuMS4wLCBkYXRhc2V0IGlzIGFuIG9wdGlvbmFsIGNvbXBvbmVudCxcbiAqIHNvbWUgdXNlcnMgbWF5IGltcG9ydCB0aGlzIG1vZHVsZSBtYW51YWxseS5cbiAqL1xuXG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50JztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50JztcbmltcG9ydCB7IFNFUklFU19MQVlPVVRfQllfQ09MVU1OIH0gZnJvbSAnLi4vLi4vdXRpbC90eXBlcyc7XG5pbXBvcnQgeyBkaXNhYmxlVHJhbnNmb3JtT3B0aW9uTWVyZ2UsIFNvdXJjZU1hbmFnZXIgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9zb3VyY2VNYW5hZ2VyJztcblxudmFyIERhdGFzZXRNb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhEYXRhc2V0TW9kZWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gRGF0YXNldE1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9ICdkYXRhc2V0JztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBEYXRhc2V0TW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpO1xuXG4gICAgdGhpcy5fc291cmNlTWFuYWdlciA9IG5ldyBTb3VyY2VNYW5hZ2VyKHRoaXMpO1xuICAgIGRpc2FibGVUcmFuc2Zvcm1PcHRpb25NZXJnZSh0aGlzKTtcbiAgfTtcblxuICBEYXRhc2V0TW9kZWwucHJvdG90eXBlLm1lcmdlT3B0aW9uID0gZnVuY3Rpb24gKG5ld09wdGlvbiwgZWNNb2RlbCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUubWVyZ2VPcHRpb24uY2FsbCh0aGlzLCBuZXdPcHRpb24sIGVjTW9kZWwpO1xuXG4gICAgZGlzYWJsZVRyYW5zZm9ybU9wdGlvbk1lcmdlKHRoaXMpO1xuICB9O1xuXG4gIERhdGFzZXRNb2RlbC5wcm90b3R5cGUub3B0aW9uVXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zb3VyY2VNYW5hZ2VyLmRpcnR5KCk7XG4gIH07XG5cbiAgRGF0YXNldE1vZGVsLnByb3RvdHlwZS5nZXRTb3VyY2VNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VNYW5hZ2VyO1xuICB9O1xuXG4gIERhdGFzZXRNb2RlbC50eXBlID0gJ2RhdGFzZXQnO1xuICBEYXRhc2V0TW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICBzZXJpZXNMYXlvdXRCeTogU0VSSUVTX0xBWU9VVF9CWV9DT0xVTU5cbiAgfTtcbiAgcmV0dXJuIERhdGFzZXRNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuXG5leHBvcnQgeyBEYXRhc2V0TW9kZWwgfTtcblxudmFyIERhdGFzZXRWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKERhdGFzZXRWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIERhdGFzZXRWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9ICdkYXRhc2V0JztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBEYXRhc2V0Vmlldy50eXBlID0gJ2RhdGFzZXQnO1xuICByZXR1cm4gRGF0YXNldFZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50TW9kZWwoRGF0YXNldE1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhEYXRhc2V0Vmlldyk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgKiBhcyBtb2RlbFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG5pbXBvcnQgKiBhcyBncmFwaGljVXRpbCBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0ICogYXMgbGF5b3V0VXRpbCBmcm9tICcuLi8uLi91dGlsL2xheW91dCc7XG5pbXBvcnQgeyBwYXJzZVBlcmNlbnQgfSBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50JztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50JztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZSc7XG5pbXBvcnQgeyBpc0VDNENvbXBhdGlibGVTdHlsZSwgY29udmVydEZyb21FQzRDb21wYXRpYmxlU3R5bGUgfSBmcm9tICcuLi8uLi91dGlsL3N0eWxlQ29tcGF0JztcbnZhciBUUkFOU0ZPUk1fUFJPUFMgPSB7XG4gIHg6IDEsXG4gIHk6IDEsXG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxLFxuICBvcmlnaW5YOiAxLFxuICBvcmlnaW5ZOiAxLFxuICByb3RhdGlvbjogMVxufTtcbjtcbnZhciBpbm5lciA9IG1vZGVsVXRpbC5tYWtlSW5uZXIoKTtcbnZhciBfbm9uU2hhcGVHcmFwaGljRWxlbWVudHMgPSB7XG4gIC8vIFJlc2VydmVkIGJ1dCBub3Qgc3VwcG9ydGVkIGluIGdyYXBoaWMgY29tcG9uZW50LlxuICBwYXRoOiBudWxsLFxuICBjb21wb3VuZFBhdGg6IG51bGwsXG4gIC8vIFN1cHBvcnRlZCBpbiBncmFwaGljIGNvbXBvbmVudC5cbiAgZ3JvdXA6IGdyYXBoaWNVdGlsLkdyb3VwLFxuICBpbWFnZTogZ3JhcGhpY1V0aWwuSW1hZ2UsXG4gIHRleHQ6IGdyYXBoaWNVdGlsLlRleHRcbn07IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJlcHJvY2Vzc29yXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHByZXByb2Nlc3NvciA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgdmFyIGdyYXBoaWNPcHRpb24gPSBvcHRpb24uZ3JhcGhpYzsgLy8gQ29udmVydFxuICAvLyB7Z3JhcGhpYzogW3tsZWZ0OiAxMCwgdHlwZTogJ2NpcmNsZSd9LCAuLi5dfVxuICAvLyBvclxuICAvLyB7Z3JhcGhpYzoge2xlZnQ6IDEwLCB0eXBlOiAnY2lyY2xlJ319XG4gIC8vIHRvXG4gIC8vIHtncmFwaGljOiBbe2VsZW1lbnRzOiBbe2xlZnQ6IDEwLCB0eXBlOiAnY2lyY2xlJ30sIC4uLl19XX1cblxuICBpZiAoenJVdGlsLmlzQXJyYXkoZ3JhcGhpY09wdGlvbikpIHtcbiAgICBpZiAoIWdyYXBoaWNPcHRpb25bMF0gfHwgIWdyYXBoaWNPcHRpb25bMF0uZWxlbWVudHMpIHtcbiAgICAgIG9wdGlvbi5ncmFwaGljID0gW3tcbiAgICAgICAgZWxlbWVudHM6IGdyYXBoaWNPcHRpb25cbiAgICAgIH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPbmx5IG9uZSBncmFwaGljIGluc3RhbmNlIGNhbiBiZSBpbnN0YW50aWF0ZWQuIChXZSBkb250XG4gICAgICAvLyB3YW50IHRoYXQgdG9vIG1hbnkgdmlld3MgYXJlIGNyZWF0ZWQgaW4gZWNoYXJ0cy5fdmlld01hcClcbiAgICAgIG9wdGlvbi5ncmFwaGljID0gW29wdGlvbi5ncmFwaGljWzBdXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ3JhcGhpY09wdGlvbiAmJiAhZ3JhcGhpY09wdGlvbi5lbGVtZW50cykge1xuICAgIG9wdGlvbi5ncmFwaGljID0gW3tcbiAgICAgIGVsZW1lbnRzOiBbZ3JhcGhpY09wdGlvbl1cbiAgICB9XTtcbiAgfVxufTtcblxuO1xuXG52YXIgR3JhcGhpY0NvbXBvbmVudE1vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEdyYXBoaWNDb21wb25lbnRNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBHcmFwaGljQ29tcG9uZW50TW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gR3JhcGhpY0NvbXBvbmVudE1vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgR3JhcGhpY0NvbXBvbmVudE1vZGVsLnByb3RvdHlwZS5tZXJnZU9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICAvLyBQcmV2ZW50IGRlZmF1bHQgbWVyZ2UgdG8gZWxlbWVudHNcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLm9wdGlvbi5lbGVtZW50cztcbiAgICB0aGlzLm9wdGlvbi5lbGVtZW50cyA9IG51bGw7XG5cbiAgICBfc3VwZXIucHJvdG90eXBlLm1lcmdlT3B0aW9uLmNhbGwodGhpcywgb3B0aW9uLCBlY01vZGVsKTtcblxuICAgIHRoaXMub3B0aW9uLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gIH07XG5cbiAgR3JhcGhpY0NvbXBvbmVudE1vZGVsLnByb3RvdHlwZS5vcHRpb25VcGRhdGVkID0gZnVuY3Rpb24gKG5ld09wdGlvbiwgaXNJbml0KSB7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgbmV3TGlzdCA9IChpc0luaXQgPyB0aGlzT3B0aW9uIDogbmV3T3B0aW9uKS5lbGVtZW50cztcbiAgICB2YXIgZXhpc3RMaXN0ID0gdGhpc09wdGlvbi5lbGVtZW50cyA9IGlzSW5pdCA/IFtdIDogdGhpc09wdGlvbi5lbGVtZW50cztcbiAgICB2YXIgZmxhdHRlbmVkTGlzdCA9IFtdO1xuXG4gICAgdGhpcy5fZmxhdHRlbihuZXdMaXN0LCBmbGF0dGVuZWRMaXN0LCBudWxsKTtcblxuICAgIHZhciBtYXBwaW5nUmVzdWx0ID0gbW9kZWxVdGlsLm1hcHBpbmdUb0V4aXN0cyhleGlzdExpc3QsIGZsYXR0ZW5lZExpc3QsICdub3JtYWxNZXJnZScpOyAvLyBDbGVhciBlbE9wdGlvbnNUb1VwZGF0ZVxuXG4gICAgdmFyIGVsT3B0aW9uc1RvVXBkYXRlID0gdGhpcy5fZWxPcHRpb25zVG9VcGRhdGUgPSBbXTtcbiAgICB6clV0aWwuZWFjaChtYXBwaW5nUmVzdWx0LCBmdW5jdGlvbiAocmVzdWx0SXRlbSwgaW5kZXgpIHtcbiAgICAgIHZhciBuZXdFbE9wdGlvbiA9IHJlc3VsdEl0ZW0ubmV3T3B0aW9uO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB6clV0aWwuYXNzZXJ0KHpyVXRpbC5pc09iamVjdChuZXdFbE9wdGlvbikgfHwgcmVzdWx0SXRlbS5leGlzdGluZywgJ0VtcHR5IGdyYXBoaWMgb3B0aW9uIGRlZmluaXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFuZXdFbE9wdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGVsT3B0aW9uc1RvVXBkYXRlLnB1c2gobmV3RWxPcHRpb24pO1xuICAgICAgc2V0S2V5SW5mb1RvTmV3RWxPcHRpb24ocmVzdWx0SXRlbSwgbmV3RWxPcHRpb24pO1xuICAgICAgbWVyZ2VOZXdFbE9wdGlvblRvRXhpc3QoZXhpc3RMaXN0LCBpbmRleCwgbmV3RWxPcHRpb24pO1xuICAgICAgc2V0TGF5b3V0SW5mb1RvRXhpc3QoZXhpc3RMaXN0W2luZGV4XSwgbmV3RWxPcHRpb24pO1xuICAgIH0sIHRoaXMpOyAvLyBDbGVhblxuXG4gICAgZm9yICh2YXIgaSA9IGV4aXN0TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGV4aXN0TGlzdFtpXSA9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0TGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAkYWN0aW9uIHNob3VsZCBiZSB2b2xhdGlsZSwgb3RoZXJ3aXNlIG9wdGlvbiBnb3R0ZW4gZnJvbVxuICAgICAgICAvLyBgZ2V0T3B0aW9uYCB3aWxsIGNvbnRhaW4gdW5leHBlY3RlZCAkYWN0aW9uLlxuICAgICAgICBkZWxldGUgZXhpc3RMaXN0W2ldLiRhY3Rpb247XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQ29udmVydFxuICAgKiBbe1xuICAgKiAgdHlwZTogJ2dyb3VwJyxcbiAgICogIGlkOiAneHgnLFxuICAgKiAgY2hpbGRyZW46IFt7dHlwZTogJ2NpcmNsZSd9LCB7dHlwZTogJ3BvbHlnb24nfV1cbiAgICogfV1cbiAgICogdG9cbiAgICogW1xuICAgKiAge3R5cGU6ICdncm91cCcsIGlkOiAneHgnfSxcbiAgICogIHt0eXBlOiAnY2lyY2xlJywgcGFyZW50SWQ6ICd4eCd9LFxuICAgKiAge3R5cGU6ICdwb2x5Z29uJywgcGFyZW50SWQ6ICd4eCd9XG4gICAqIF1cbiAgICovXG5cblxuICBHcmFwaGljQ29tcG9uZW50TW9kZWwucHJvdG90eXBlLl9mbGF0dGVuID0gZnVuY3Rpb24gKG9wdGlvbkxpc3QsIHJlc3VsdCwgcGFyZW50T3B0aW9uKSB7XG4gICAgenJVdGlsLmVhY2gob3B0aW9uTGlzdCwgZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50T3B0aW9uKSB7XG4gICAgICAgIG9wdGlvbi5wYXJlbnRPcHRpb24gPSBwYXJlbnRPcHRpb247XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5wdXNoKG9wdGlvbik7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBvcHRpb24uY2hpbGRyZW47XG5cbiAgICAgIGlmIChvcHRpb24udHlwZSA9PT0gJ2dyb3VwJyAmJiBjaGlsZHJlbikge1xuICAgICAgICB0aGlzLl9mbGF0dGVuKGNoaWxkcmVuLCByZXN1bHQsIG9wdGlvbik7XG4gICAgICB9IC8vIERlbGV0aW5nIGZvciBKU09OIG91dHB1dCwgYW5kIGZvciBub3QgYWZmZWN0aW5nIGdyb3VwIGNyZWF0aW9uLlxuXG5cbiAgICAgIGRlbGV0ZSBvcHRpb24uY2hpbGRyZW47XG4gICAgfSwgdGhpcyk7XG4gIH07IC8vIEZJWE1FXG4gIC8vIFBhc3MgdG8gdmlldyB1c2luZyBwYXlsb2FkPyBzZXRPcHRpb24gaGFzIGEgcGF5bG9hZD9cblxuXG4gIEdyYXBoaWNDb21wb25lbnRNb2RlbC5wcm90b3R5cGUudXNlRWxPcHRpb25zVG9VcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVscyA9IHRoaXMuX2VsT3B0aW9uc1RvVXBkYXRlOyAvLyBDbGVhciB0byBhdm9pZCByZW5kZXIgZHVwbGljYXRlbHkgd2hlbiB6b29taW5nLlxuXG4gICAgdGhpcy5fZWxPcHRpb25zVG9VcGRhdGUgPSBudWxsO1xuICAgIHJldHVybiBlbHM7XG4gIH07XG5cbiAgR3JhcGhpY0NvbXBvbmVudE1vZGVsLnR5cGUgPSAnZ3JhcGhpYyc7XG4gIEdyYXBoaWNDb21wb25lbnRNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIGVsZW1lbnRzOiBbXSAvLyBwYXJlbnRJZDogbnVsbFxuXG4gIH07XG4gIHJldHVybiBHcmFwaGljQ29tcG9uZW50TW9kZWw7XG59KENvbXBvbmVudE1vZGVsKTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBWaWV3XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG52YXIgR3JhcGhpY0NvbXBvbmVudFZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoR3JhcGhpY0NvbXBvbmVudFZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gR3JhcGhpY0NvbXBvbmVudFZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gR3JhcGhpY0NvbXBvbmVudFZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBHcmFwaGljQ29tcG9uZW50Vmlldy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9lbE1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gIH07XG5cbiAgR3JhcGhpY0NvbXBvbmVudFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChncmFwaGljTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIC8vIEhhdmluZyBsZXZlcmFnZWQgYmV0d2VlbiB1c2UgY2FzZXMgYW5kIGFsZ29yaXRobSBjb21wbGV4aXR5LCBhIHZlcnlcbiAgICAvLyBzaW1wbGUgbGF5b3V0IG1lY2hhbmlzbSBpcyB1c2VkOlxuICAgIC8vIFRoZSBzaXplKHdpZHRoL2hlaWdodCkgY2FuIGJlIGRldGVybWluZWQgYnkgaXRzZWxmIG9yIGl0cyBwYXJlbnQgKG5vdFxuICAgIC8vIGltcGxlbWVudGVkIHlldCksIGJ1dCBjYW4gbm90IGJ5IGl0cyBjaGlsZHJlbi4gKFRvcC1kb3duIHRyYXZlbClcbiAgICAvLyBUaGUgbG9jYXRpb24oeC95KSBjYW4gYmUgZGV0ZXJtaW5lZCBieSB0aGUgYm91bmRpbmcgcmVjdCBvZiBpdHNlbGZcbiAgICAvLyAoY2FuIGluY2x1ZGluZyBpdHMgZGVzY2VuZGFudHMgb3Igbm90KSBhbmQgdGhlIHNpemUgb2YgaXRzIHBhcmVudC5cbiAgICAvLyAoQm90dG9tLXVwIHRyYXZlbClcbiAgICAvLyBXaGVuIGBjaGFydC5jbGVhcigpYCBvciBgY2hhcnQuc2V0T3B0aW9uKHsuLi59LCB0cnVlKWAgd2l0aCB0aGUgc2FtZSBpZCxcbiAgICAvLyB2aWV3IHdpbGwgYmUgcmV1c2VkLlxuICAgIGlmIChncmFwaGljTW9kZWwgIT09IHRoaXMuX2xhc3RHcmFwaGljTW9kZWwpIHtcbiAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbGFzdEdyYXBoaWNNb2RlbCA9IGdyYXBoaWNNb2RlbDtcblxuICAgIHRoaXMuX3VwZGF0ZUVsZW1lbnRzKGdyYXBoaWNNb2RlbCk7XG5cbiAgICB0aGlzLl9yZWxvY2F0ZShncmFwaGljTW9kZWwsIGFwaSk7XG4gIH07XG4gIC8qKlxuICAgKiBVcGRhdGUgZ3JhcGhpYyBlbGVtZW50cy5cbiAgICovXG5cblxuICBHcmFwaGljQ29tcG9uZW50Vmlldy5wcm90b3R5cGUuX3VwZGF0ZUVsZW1lbnRzID0gZnVuY3Rpb24gKGdyYXBoaWNNb2RlbCkge1xuICAgIHZhciBlbE9wdGlvbnNUb1VwZGF0ZSA9IGdyYXBoaWNNb2RlbC51c2VFbE9wdGlvbnNUb1VwZGF0ZSgpO1xuXG4gICAgaWYgKCFlbE9wdGlvbnNUb1VwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbE1hcCA9IHRoaXMuX2VsTWFwO1xuICAgIHZhciByb290R3JvdXAgPSB0aGlzLmdyb3VwOyAvLyBUb3AtZG93biB0cmFudmVyc2UgdG8gYXNzaWduIGdyYXBoaWMgc2V0dGluZ3MgdG8gZWFjaCBlbGVtZW50cy5cblxuICAgIHpyVXRpbC5lYWNoKGVsT3B0aW9uc1RvVXBkYXRlLCBmdW5jdGlvbiAoZWxPcHRpb24pIHtcbiAgICAgIHZhciBpZCA9IG1vZGVsVXRpbC5jb252ZXJ0T3B0aW9uSWROYW1lKGVsT3B0aW9uLmlkLCBudWxsKTtcbiAgICAgIHZhciBlbEV4aXN0aW5nID0gaWQgIT0gbnVsbCA/IGVsTWFwLmdldChpZCkgOiBudWxsO1xuICAgICAgdmFyIHBhcmVudElkID0gbW9kZWxVdGlsLmNvbnZlcnRPcHRpb25JZE5hbWUoZWxPcHRpb24ucGFyZW50SWQsIG51bGwpO1xuICAgICAgdmFyIHRhcmdldEVsUGFyZW50ID0gcGFyZW50SWQgIT0gbnVsbCA/IGVsTWFwLmdldChwYXJlbnRJZCkgOiByb290R3JvdXA7XG4gICAgICB2YXIgZWxUeXBlID0gZWxPcHRpb24udHlwZTtcbiAgICAgIHZhciBlbE9wdGlvblN0eWxlID0gZWxPcHRpb24uc3R5bGU7XG5cbiAgICAgIGlmIChlbFR5cGUgPT09ICd0ZXh0JyAmJiBlbE9wdGlvblN0eWxlKSB7XG4gICAgICAgIC8vIEluIHRvcC9ib3R0b20gbW9kZSwgdGV4dFZlcnRpY2FsQWxpZ24gc2hvdWxkIG5vdCBiZSB1c2VkLCB3aGljaCBjYXVzZVxuICAgICAgICAvLyBpbmFjY3VyYXRlbHkgbG9jYXRpbmcuXG4gICAgICAgIGlmIChlbE9wdGlvbi5odiAmJiBlbE9wdGlvbi5odlsxXSkge1xuICAgICAgICAgIGVsT3B0aW9uU3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gPSBlbE9wdGlvblN0eWxlLnRleHRCYXNlbGluZSA9IGVsT3B0aW9uU3R5bGUudmVydGljYWxBbGlnbiA9IGVsT3B0aW9uU3R5bGUuYWxpZ24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0Q29udGVudE9wdGlvbiA9IGVsT3B0aW9uLnRleHRDb250ZW50O1xuICAgICAgdmFyIHRleHRDb25maWcgPSBlbE9wdGlvbi50ZXh0Q29uZmlnO1xuXG4gICAgICBpZiAoZWxPcHRpb25TdHlsZSAmJiBpc0VDNENvbXBhdGlibGVTdHlsZShlbE9wdGlvblN0eWxlLCBlbFR5cGUsICEhdGV4dENvbmZpZywgISF0ZXh0Q29udGVudE9wdGlvbikpIHtcbiAgICAgICAgdmFyIGNvbnZlcnRSZXN1bHQgPSBjb252ZXJ0RnJvbUVDNENvbXBhdGlibGVTdHlsZShlbE9wdGlvblN0eWxlLCBlbFR5cGUsIHRydWUpO1xuXG4gICAgICAgIGlmICghdGV4dENvbmZpZyAmJiBjb252ZXJ0UmVzdWx0LnRleHRDb25maWcpIHtcbiAgICAgICAgICB0ZXh0Q29uZmlnID0gZWxPcHRpb24udGV4dENvbmZpZyA9IGNvbnZlcnRSZXN1bHQudGV4dENvbmZpZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGV4dENvbnRlbnRPcHRpb24gJiYgY29udmVydFJlc3VsdC50ZXh0Q29udGVudCkge1xuICAgICAgICAgIHRleHRDb250ZW50T3B0aW9uID0gY29udmVydFJlc3VsdC50ZXh0Q29udGVudDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZW1vdmUgdW5uZWNlc3NhcnkgcHJvcHMgdG8gYXZvaWQgcG90ZW50aWFsIHByb2JsZW1zLlxuXG5cbiAgICAgIHZhciBlbE9wdGlvbkNsZWFuZWQgPSBnZXRDbGVhbmVkRWxPcHRpb24oZWxPcHRpb24pOyAvLyBGb3Igc2ltcGxlLCBkbyBub3Qgc3VwcG9ydCBwYXJlbnQgY2hhbmdlLCBvdGhlcndpc2UgcmVvcmRlciBpcyBuZWVkZWQuXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVsRXhpc3RpbmcgJiYgenJVdGlsLmFzc2VydCh0YXJnZXRFbFBhcmVudCA9PT0gZWxFeGlzdGluZy5wYXJlbnQsICdDaGFuZ2luZyBwYXJlbnQgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyICRhY3Rpb24gPSBlbE9wdGlvbi4kYWN0aW9uIHx8ICdtZXJnZSc7XG5cbiAgICAgIGlmICgkYWN0aW9uID09PSAnbWVyZ2UnKSB7XG4gICAgICAgIGVsRXhpc3RpbmcgPyBlbEV4aXN0aW5nLmF0dHIoZWxPcHRpb25DbGVhbmVkKSA6IGNyZWF0ZUVsKGlkLCB0YXJnZXRFbFBhcmVudCwgZWxPcHRpb25DbGVhbmVkLCBlbE1hcCk7XG4gICAgICB9IGVsc2UgaWYgKCRhY3Rpb24gPT09ICdyZXBsYWNlJykge1xuICAgICAgICByZW1vdmVFbChlbEV4aXN0aW5nLCBlbE1hcCk7XG4gICAgICAgIGNyZWF0ZUVsKGlkLCB0YXJnZXRFbFBhcmVudCwgZWxPcHRpb25DbGVhbmVkLCBlbE1hcCk7XG4gICAgICB9IGVsc2UgaWYgKCRhY3Rpb24gPT09ICdyZW1vdmUnKSB7XG4gICAgICAgIHJlbW92ZUVsKGVsRXhpc3RpbmcsIGVsTWFwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsID0gZWxNYXAuZ2V0KGlkKTtcblxuICAgICAgaWYgKGVsICYmIHRleHRDb250ZW50T3B0aW9uKSB7XG4gICAgICAgIGlmICgkYWN0aW9uID09PSAnbWVyZ2UnKSB7XG4gICAgICAgICAgdmFyIHRleHRDb250ZW50RXhpc3RpbmcgPSBlbC5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICAgIHRleHRDb250ZW50RXhpc3RpbmcgPyB0ZXh0Q29udGVudEV4aXN0aW5nLmF0dHIodGV4dENvbnRlbnRPcHRpb24pIDogZWwuc2V0VGV4dENvbnRlbnQobmV3IGdyYXBoaWNVdGlsLlRleHQodGV4dENvbnRlbnRPcHRpb24pKTtcbiAgICAgICAgfSBlbHNlIGlmICgkYWN0aW9uID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgICBlbC5zZXRUZXh0Q29udGVudChuZXcgZ3JhcGhpY1V0aWwuVGV4dCh0ZXh0Q29udGVudE9wdGlvbikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbCkge1xuICAgICAgICB2YXIgZWxJbm5lciA9IGlubmVyKGVsKTtcbiAgICAgICAgZWxJbm5lci5fX2VjR3JhcGhpY1dpZHRoT3B0aW9uID0gZWxPcHRpb24ud2lkdGg7XG4gICAgICAgIGVsSW5uZXIuX19lY0dyYXBoaWNIZWlnaHRPcHRpb24gPSBlbE9wdGlvbi5oZWlnaHQ7XG4gICAgICAgIHNldEV2ZW50RGF0YShlbCwgZ3JhcGhpY01vZGVsLCBlbE9wdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBMb2NhdGUgZ3JhcGhpYyBlbGVtZW50cy5cbiAgICovXG5cblxuICBHcmFwaGljQ29tcG9uZW50Vmlldy5wcm90b3R5cGUuX3JlbG9jYXRlID0gZnVuY3Rpb24gKGdyYXBoaWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGVsT3B0aW9ucyA9IGdyYXBoaWNNb2RlbC5vcHRpb24uZWxlbWVudHM7XG4gICAgdmFyIHJvb3RHcm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGVsTWFwID0gdGhpcy5fZWxNYXA7XG4gICAgdmFyIGFwaVdpZHRoID0gYXBpLmdldFdpZHRoKCk7XG4gICAgdmFyIGFwaUhlaWdodCA9IGFwaS5nZXRIZWlnaHQoKTsgLy8gVG9wLWRvd24gdG8gY2FsY3VsYXRlIHBlcmNlbnRhZ2Ugd2lkdGgvaGVpZ2h0IG9mIGdyb3VwXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsT3B0aW9uID0gZWxPcHRpb25zW2ldO1xuICAgICAgdmFyIGlkID0gbW9kZWxVdGlsLmNvbnZlcnRPcHRpb25JZE5hbWUoZWxPcHRpb24uaWQsIG51bGwpO1xuICAgICAgdmFyIGVsID0gaWQgIT0gbnVsbCA/IGVsTWFwLmdldChpZCkgOiBudWxsO1xuXG4gICAgICBpZiAoIWVsIHx8ICFlbC5pc0dyb3VwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50RWwgPSBlbC5wYXJlbnQ7XG4gICAgICB2YXIgaXNQYXJlbnRSb290ID0gcGFyZW50RWwgPT09IHJvb3RHcm91cDsgLy8gTGlrZSAncG9zaXRpb246YWJzb2x1dCcgaW4gY3NzLCBkZWZhdWx0IDAuXG5cbiAgICAgIHZhciBlbElubmVyID0gaW5uZXIoZWwpO1xuICAgICAgdmFyIHBhcmVudEVsSW5uZXIgPSBpbm5lcihwYXJlbnRFbCk7XG4gICAgICBlbElubmVyLl9fZWNHcmFwaGljV2lkdGggPSBwYXJzZVBlcmNlbnQoZWxJbm5lci5fX2VjR3JhcGhpY1dpZHRoT3B0aW9uLCBpc1BhcmVudFJvb3QgPyBhcGlXaWR0aCA6IHBhcmVudEVsSW5uZXIuX19lY0dyYXBoaWNXaWR0aCkgfHwgMDtcbiAgICAgIGVsSW5uZXIuX19lY0dyYXBoaWNIZWlnaHQgPSBwYXJzZVBlcmNlbnQoZWxJbm5lci5fX2VjR3JhcGhpY0hlaWdodE9wdGlvbiwgaXNQYXJlbnRSb290ID8gYXBpSGVpZ2h0IDogcGFyZW50RWxJbm5lci5fX2VjR3JhcGhpY0hlaWdodCkgfHwgMDtcbiAgICB9IC8vIEJvdHRvbS11cCB0cmFudmVzZSBhbGwgZWxlbWVudHMgKGNvbnNpZGVyIGVjIHJlc2l6ZSkgdG8gbG9jYXRlIGVsZW1lbnRzLlxuXG5cbiAgICBmb3IgKHZhciBpID0gZWxPcHRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZWxPcHRpb24gPSBlbE9wdGlvbnNbaV07XG4gICAgICB2YXIgaWQgPSBtb2RlbFV0aWwuY29udmVydE9wdGlvbklkTmFtZShlbE9wdGlvbi5pZCwgbnVsbCk7XG4gICAgICB2YXIgZWwgPSBpZCAhPSBudWxsID8gZWxNYXAuZ2V0KGlkKSA6IG51bGw7XG5cbiAgICAgIGlmICghZWwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnRFbCA9IGVsLnBhcmVudDtcbiAgICAgIHZhciBwYXJlbnRFbElubmVyID0gaW5uZXIocGFyZW50RWwpO1xuICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwYXJlbnRFbCA9PT0gcm9vdEdyb3VwID8ge1xuICAgICAgICB3aWR0aDogYXBpV2lkdGgsXG4gICAgICAgIGhlaWdodDogYXBpSGVpZ2h0XG4gICAgICB9IDoge1xuICAgICAgICB3aWR0aDogcGFyZW50RWxJbm5lci5fX2VjR3JhcGhpY1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHBhcmVudEVsSW5uZXIuX19lY0dyYXBoaWNIZWlnaHRcbiAgICAgIH07IC8vIFBFTkRJTkdcbiAgICAgIC8vIEN1cnJlbnRseSwgd2hlbiBgYm91bmRpbmc6ICdhbGwnYCwgdGhlIHVuaW9uIGJvdW5kaW5nIHJlY3Qgb2YgdGhlIGdyb3VwXG4gICAgICAvLyBkb2VzIG5vdCBpbmNsdWRlIHRoZSByZWN0IG9mIFswLCAwLCBncm91cC53aWR0aCwgZ3JvdXAuaGVpZ2h0XSwgd2hpY2hcbiAgICAgIC8vIGlzIHByb2JhYmx5IHdlaXJkIGZvciB1c2Vycy4gU2hvdWxkIHdlIG1ha2UgYSBicmVhayBjaGFuZ2UgZm9yIGl0P1xuXG4gICAgICBsYXlvdXRVdGlsLnBvc2l0aW9uRWxlbWVudChlbCwgZWxPcHRpb24sIGNvbnRhaW5lckluZm8sIG51bGwsIHtcbiAgICAgICAgaHY6IGVsT3B0aW9uLmh2LFxuICAgICAgICBib3VuZGluZ01vZGU6IGVsT3B0aW9uLmJvdW5kaW5nXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBDbGVhciBhbGwgZWxlbWVudHMuXG4gICAqL1xuXG5cbiAgR3JhcGhpY0NvbXBvbmVudFZpZXcucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxNYXAgPSB0aGlzLl9lbE1hcDtcbiAgICBlbE1hcC5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmVtb3ZlRWwoZWwsIGVsTWFwKTtcbiAgICB9KTtcbiAgICB0aGlzLl9lbE1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gIH07XG5cbiAgR3JhcGhpY0NvbXBvbmVudFZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xlYXIoKTtcbiAgfTtcblxuICBHcmFwaGljQ29tcG9uZW50Vmlldy50eXBlID0gJ2dyYXBoaWMnO1xuICByZXR1cm4gR3JhcGhpY0NvbXBvbmVudFZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuXG5mdW5jdGlvbiBjcmVhdGVFbChpZCwgdGFyZ2V0RWxQYXJlbnQsIGVsT3B0aW9uLCBlbE1hcCkge1xuICB2YXIgZ3JhcGhpY1R5cGUgPSBlbE9wdGlvbi50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgenJVdGlsLmFzc2VydChncmFwaGljVHlwZSwgJ2dyYXBoaWMgdHlwZSBNVVNUIGJlIHNldCcpO1xuICB9XG5cbiAgdmFyIENseiA9IHpyVXRpbC5oYXNPd24oX25vblNoYXBlR3JhcGhpY0VsZW1lbnRzLCBncmFwaGljVHlwZSkgLy8gVGhvc2UgZ3JhcGhpYyBlbGVtZW50cyBhcmUgbm90IHNoYXBlcy4gVGhleSBzaG91bGQgbm90IGJlXG4gIC8vIG92ZXJ3cml0dGVuIGJ5IHVzZXJzLCBzbyBkbyB0aGVtIGZpcnN0LlxuICA/IF9ub25TaGFwZUdyYXBoaWNFbGVtZW50c1tncmFwaGljVHlwZV0gOiBncmFwaGljVXRpbC5nZXRTaGFwZUNsYXNzKGdyYXBoaWNUeXBlKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHpyVXRpbC5hc3NlcnQoQ2x6LCAnZ3JhcGhpYyB0eXBlIGNhbiBub3QgYmUgZm91bmQnKTtcbiAgfVxuXG4gIHZhciBlbCA9IG5ldyBDbHooZWxPcHRpb24pO1xuICB0YXJnZXRFbFBhcmVudC5hZGQoZWwpO1xuICBlbE1hcC5zZXQoaWQsIGVsKTtcbiAgaW5uZXIoZWwpLl9fZWNHcmFwaGljSWQgPSBpZDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRWwoZWxFeGlzdGluZywgZWxNYXApIHtcbiAgdmFyIGV4aXN0RWxQYXJlbnQgPSBlbEV4aXN0aW5nICYmIGVsRXhpc3RpbmcucGFyZW50O1xuXG4gIGlmIChleGlzdEVsUGFyZW50KSB7XG4gICAgZWxFeGlzdGluZy50eXBlID09PSAnZ3JvdXAnICYmIGVsRXhpc3RpbmcudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZW1vdmVFbChlbCwgZWxNYXApO1xuICAgIH0pO1xuICAgIGVsTWFwLnJlbW92ZUtleShpbm5lcihlbEV4aXN0aW5nKS5fX2VjR3JhcGhpY0lkKTtcbiAgICBleGlzdEVsUGFyZW50LnJlbW92ZShlbEV4aXN0aW5nKTtcbiAgfVxufSAvLyBSZW1vdmUgdW5uZWNlc3NhcnkgcHJvcHMgdG8gYXZvaWQgcG90ZW50aWFsIHByb2JsZW1zLlxuXG5cbmZ1bmN0aW9uIGdldENsZWFuZWRFbE9wdGlvbihlbE9wdGlvbikge1xuICBlbE9wdGlvbiA9IHpyVXRpbC5leHRlbmQoe30sIGVsT3B0aW9uKTtcbiAgenJVdGlsLmVhY2goWydpZCcsICdwYXJlbnRJZCcsICckYWN0aW9uJywgJ2h2JywgJ2JvdW5kaW5nJywgJ3RleHRDb250ZW50J10uY29uY2F0KGxheW91dFV0aWwuTE9DQVRJT05fUEFSQU1TKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBkZWxldGUgZWxPcHRpb25bbmFtZV07XG4gIH0pO1xuICByZXR1cm4gZWxPcHRpb247XG59XG5cbmZ1bmN0aW9uIGlzU2V0TG9jKG9iaiwgcHJvcHMpIHtcbiAgdmFyIGlzU2V0O1xuICB6clV0aWwuZWFjaChwcm9wcywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICBvYmpbcHJvcF0gIT0gbnVsbCAmJiBvYmpbcHJvcF0gIT09ICdhdXRvJyAmJiAoaXNTZXQgPSB0cnVlKTtcbiAgfSk7XG4gIHJldHVybiBpc1NldDtcbn1cblxuZnVuY3Rpb24gc2V0S2V5SW5mb1RvTmV3RWxPcHRpb24ocmVzdWx0SXRlbSwgbmV3RWxPcHRpb24pIHtcbiAgdmFyIGV4aXN0RWxPcHRpb24gPSByZXN1bHRJdGVtLmV4aXN0aW5nOyAvLyBTZXQgaWQgYW5kIHR5cGUgYWZ0ZXIgaWQgYXNzaWduZWQuXG5cbiAgbmV3RWxPcHRpb24uaWQgPSByZXN1bHRJdGVtLmtleUluZm8uaWQ7XG4gICFuZXdFbE9wdGlvbi50eXBlICYmIGV4aXN0RWxPcHRpb24gJiYgKG5ld0VsT3B0aW9uLnR5cGUgPSBleGlzdEVsT3B0aW9uLnR5cGUpOyAvLyBTZXQgcGFyZW50IGlkIGlmIG5vdCBzcGVjaWZpZWRcblxuICBpZiAobmV3RWxPcHRpb24ucGFyZW50SWQgPT0gbnVsbCkge1xuICAgIHZhciBuZXdFbFBhcmVudE9wdGlvbiA9IG5ld0VsT3B0aW9uLnBhcmVudE9wdGlvbjtcblxuICAgIGlmIChuZXdFbFBhcmVudE9wdGlvbikge1xuICAgICAgbmV3RWxPcHRpb24ucGFyZW50SWQgPSBuZXdFbFBhcmVudE9wdGlvbi5pZDtcbiAgICB9IGVsc2UgaWYgKGV4aXN0RWxPcHRpb24pIHtcbiAgICAgIG5ld0VsT3B0aW9uLnBhcmVudElkID0gZXhpc3RFbE9wdGlvbi5wYXJlbnRJZDtcbiAgICB9XG4gIH0gLy8gQ2xlYXJcblxuXG4gIG5ld0VsT3B0aW9uLnBhcmVudE9wdGlvbiA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIG1lcmdlTmV3RWxPcHRpb25Ub0V4aXN0KGV4aXN0TGlzdCwgaW5kZXgsIG5ld0VsT3B0aW9uKSB7XG4gIC8vIFVwZGF0ZSBleGlzdGluZyBvcHRpb25zLCBmb3IgYGdldE9wdGlvbmAgZmVhdHVyZS5cbiAgdmFyIG5ld0VsT3B0Q29weSA9IHpyVXRpbC5leHRlbmQoe30sIG5ld0VsT3B0aW9uKTtcbiAgdmFyIGV4aXN0RWxPcHRpb24gPSBleGlzdExpc3RbaW5kZXhdO1xuICB2YXIgJGFjdGlvbiA9IG5ld0VsT3B0aW9uLiRhY3Rpb24gfHwgJ21lcmdlJztcblxuICBpZiAoJGFjdGlvbiA9PT0gJ21lcmdlJykge1xuICAgIGlmIChleGlzdEVsT3B0aW9uKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgbmV3VHlwZSA9IG5ld0VsT3B0aW9uLnR5cGU7XG4gICAgICAgIHpyVXRpbC5hc3NlcnQoIW5ld1R5cGUgfHwgZXhpc3RFbE9wdGlvbi50eXBlID09PSBuZXdUeXBlLCAnUGxlYXNlIHNldCAkYWN0aW9uOiBcInJlcGxhY2VcIiB0byBjaGFuZ2UgYHR5cGVgJyk7XG4gICAgICB9IC8vIFdlIGNhbiBlbnN1cmUgdGhhdCBuZXdFbE9wdENvcHkgYW5kIGV4aXN0RWxPcHRpb24gYXJlIG5vdFxuICAgICAgLy8gdGhlIHNhbWUgb2JqZWN0LCBzbyBgbWVyZ2VgIHdpbGwgbm90IGNoYW5nZSBuZXdFbE9wdENvcHkuXG5cblxuICAgICAgenJVdGlsLm1lcmdlKGV4aXN0RWxPcHRpb24sIG5ld0VsT3B0Q29weSwgdHJ1ZSk7IC8vIFJpZ2lkIGJvZHksIHVzZSBpZ25vcmVTaXplLlxuXG4gICAgICBsYXlvdXRVdGlsLm1lcmdlTGF5b3V0UGFyYW0oZXhpc3RFbE9wdGlvbiwgbmV3RWxPcHRDb3B5LCB7XG4gICAgICAgIGlnbm9yZVNpemU6IHRydWVcbiAgICAgIH0pOyAvLyBXaWxsIGJlIHVzZWQgaW4gcmVuZGVyLlxuXG4gICAgICBsYXlvdXRVdGlsLmNvcHlMYXlvdXRQYXJhbXMobmV3RWxPcHRpb24sIGV4aXN0RWxPcHRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdExpc3RbaW5kZXhdID0gbmV3RWxPcHRDb3B5O1xuICAgIH1cbiAgfSBlbHNlIGlmICgkYWN0aW9uID09PSAncmVwbGFjZScpIHtcbiAgICBleGlzdExpc3RbaW5kZXhdID0gbmV3RWxPcHRDb3B5O1xuICB9IGVsc2UgaWYgKCRhY3Rpb24gPT09ICdyZW1vdmUnKSB7XG4gICAgLy8gbnVsbCB3aWxsIGJlIGNsZWFuZWQgbGF0ZXIuXG4gICAgZXhpc3RFbE9wdGlvbiAmJiAoZXhpc3RMaXN0W2luZGV4XSA9IG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldExheW91dEluZm9Ub0V4aXN0KGV4aXN0SXRlbSwgbmV3RWxPcHRpb24pIHtcbiAgaWYgKCFleGlzdEl0ZW0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBleGlzdEl0ZW0uaHYgPSBuZXdFbE9wdGlvbi5odiA9IFsvLyBSaWdpZCBib2R5LCBkb250IGNhcmUgYHdpZHRoYC5cbiAgaXNTZXRMb2MobmV3RWxPcHRpb24sIFsnbGVmdCcsICdyaWdodCddKSwgLy8gUmlnaWQgYm9keSwgZG9udCBjYXJlIGBoZWlnaHRgLlxuICBpc1NldExvYyhuZXdFbE9wdGlvbiwgWyd0b3AnLCAnYm90dG9tJ10pXTsgLy8gR2l2ZSBkZWZhdWx0IGdyb3VwIHNpemUuIE90aGVyd2lzZSBsYXlvdXQgZXJyb3IgbWF5IG9jY3VyLlxuXG4gIGlmIChleGlzdEl0ZW0udHlwZSA9PT0gJ2dyb3VwJykge1xuICAgIHZhciBleGlzdGluZ0dyb3VwT3B0ID0gZXhpc3RJdGVtO1xuICAgIHZhciBuZXdHcm91cE9wdCA9IG5ld0VsT3B0aW9uO1xuICAgIGV4aXN0aW5nR3JvdXBPcHQud2lkdGggPT0gbnVsbCAmJiAoZXhpc3RpbmdHcm91cE9wdC53aWR0aCA9IG5ld0dyb3VwT3B0LndpZHRoID0gMCk7XG4gICAgZXhpc3RpbmdHcm91cE9wdC5oZWlnaHQgPT0gbnVsbCAmJiAoZXhpc3RpbmdHcm91cE9wdC5oZWlnaHQgPSBuZXdHcm91cE9wdC5oZWlnaHQgPSAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRFdmVudERhdGEoZWwsIGdyYXBoaWNNb2RlbCwgZWxPcHRpb24pIHtcbiAgdmFyIGV2ZW50RGF0YSA9IGdldEVDRGF0YShlbCkuZXZlbnREYXRhOyAvLyBTaW1wbGUgb3B0aW1pemUgZm9yIGxhcmdlIGFtb3VudCBvZiBlbGVtZW50cyB0aGF0IG5vIG5lZWQgZXZlbnQuXG5cbiAgaWYgKCFlbC5zaWxlbnQgJiYgIWVsLmlnbm9yZSAmJiAhZXZlbnREYXRhKSB7XG4gICAgZXZlbnREYXRhID0gZ2V0RUNEYXRhKGVsKS5ldmVudERhdGEgPSB7XG4gICAgICBjb21wb25lbnRUeXBlOiAnZ3JhcGhpYycsXG4gICAgICBjb21wb25lbnRJbmRleDogZ3JhcGhpY01vZGVsLmNvbXBvbmVudEluZGV4LFxuICAgICAgbmFtZTogZWwubmFtZVxuICAgIH07XG4gIH0gLy8gYGVsT3B0aW9uLmluZm9gIGVuYWJsZXMgdXNlciB0byBtb3VudCBzb21lIGluZm8gb25cbiAgLy8gZWxlbWVudHMgYW5kIHVzZSB0aGVtIGluIGV2ZW50IGhhbmRsZXJzLlxuXG5cbiAgaWYgKGV2ZW50RGF0YSkge1xuICAgIGV2ZW50RGF0YS5pbmZvID0gZWxPcHRpb24uaW5mbztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50TW9kZWwoR3JhcGhpY0NvbXBvbmVudE1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhHcmFwaGljQ29tcG9uZW50Vmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByZXByb2Nlc3NvcihwcmVwcm9jZXNzb3IpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBpbnN0YWxsIGFzIGluc3RhbGxTaW1wbGUgfSBmcm9tICcuL2luc3RhbGxTaW1wbGUnO1xuaW1wb3J0IHsgaW5zdGFsbCBhcyBpbnN0YWxsQXhpc1BvaW50ZXIgfSBmcm9tICcuLi9heGlzUG9pbnRlci9pbnN0YWxsJztcbmltcG9ydCB7IHVzZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbic7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgdXNlKGluc3RhbGxTaW1wbGUpO1xuICB1c2UoaW5zdGFsbEF4aXNQb2ludGVyKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgZWFjaCwgaW5kZXhPZiwgY3VycnksIGFzc2VydCwgbWFwLCBjcmVhdGVIYXNoTWFwIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCAqIGFzIGJydXNoSGVscGVyIGZyb20gJy4vYnJ1c2hIZWxwZXInO1xuaW1wb3J0IHsgcGFyc2VGaW5kZXIgYXMgbW9kZWxVdGlsUGFyc2VGaW5kZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbnZhciBDT09SRF9DT05WRVJUUyA9IFsnZGF0YVRvUG9pbnQnLCAncG9pbnRUb0RhdGEnXTsgLy8gRklYTUVcbi8vIGhvdyB0byBnZW5hcmlhbGl6ZSB0byBtb3JlIGNvb3JkaW5hdGUgc3lzdGVtcy5cblxudmFyIElOQ0xVREVfRklOREVSX01BSU5fVFlQRVMgPSBbJ2dyaWQnLCAneEF4aXMnLCAneUF4aXMnLCAnZ2VvJywgJ2dyYXBoJywgJ3BvbGFyJywgJ3JhZGl1c0F4aXMnLCAnYW5nbGVBeGlzJywgJ2JtYXAnXTtcblxudmFyIEJydXNoVGFyZ2V0TWFuYWdlciA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gZmluZGVyIGNvbnRhaW5zIEluZGV4L0lkL05hbWUgb2YgeEF4aXMveUF4aXMvZ2VvL2dyaWRcbiAgICogICAgICAgIEVhY2ggY2FuIGJlIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59LiBsaWtlOiB7eEF4aXNJbmRleDogWzMsIDRdfVxuICAgKiBAcGFyYW0gb3B0LmluY2x1ZGUgaW5jbHVkZSBjb29yZGluYXRlIHN5c3RlbSB0eXBlcy5cbiAgICovXG4gIGZ1bmN0aW9uIEJydXNoVGFyZ2V0TWFuYWdlcihmaW5kZXIsIGVjTW9kZWwsIG9wdCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl90YXJnZXRJbmZvTGlzdCA9IFtdO1xuICAgIHZhciBmb3VuZENwdHMgPSBwYXJzZUZpbmRlcihlY01vZGVsLCBmaW5kZXIpO1xuICAgIGVhY2godGFyZ2V0SW5mb0J1aWxkZXJzLCBmdW5jdGlvbiAoYnVpbGRlciwgdHlwZSkge1xuICAgICAgaWYgKCFvcHQgfHwgIW9wdC5pbmNsdWRlIHx8IGluZGV4T2Yob3B0LmluY2x1ZGUsIHR5cGUpID49IDApIHtcbiAgICAgICAgYnVpbGRlcihmb3VuZENwdHMsIF90aGlzLl90YXJnZXRJbmZvTGlzdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBCcnVzaFRhcmdldE1hbmFnZXIucHJvdG90eXBlLnNldE91dHB1dFJhbmdlcyA9IGZ1bmN0aW9uIChhcmVhcywgZWNNb2RlbCkge1xuICAgIHRoaXMubWF0Y2hPdXRwdXRSYW5nZXMoYXJlYXMsIGVjTW9kZWwsIGZ1bmN0aW9uIChhcmVhLCBjb29yZFJhbmdlLCBjb29yZFN5cykge1xuICAgICAgKGFyZWEuY29vcmRSYW5nZXMgfHwgKGFyZWEuY29vcmRSYW5nZXMgPSBbXSkpLnB1c2goY29vcmRSYW5nZSk7IC8vIGFyZWEuY29vcmRSYW5nZSBpcyB0aGUgZmlyc3Qgb2YgYXJlYS5jb29yZFJhbmdlc1xuXG4gICAgICBpZiAoIWFyZWEuY29vcmRSYW5nZSkge1xuICAgICAgICBhcmVhLmNvb3JkUmFuZ2UgPSBjb29yZFJhbmdlOyAvLyBJbiAnY2F0ZWdvcnknIGF4aXMsIGNvb3JkIHRvIHBpeGVsIGlzIG5vdCByZXZlcnNpYmxlLCBzbyB3ZSBjYW4gbm90XG4gICAgICAgIC8vIHJlYnVpbGQgcmFuZ2UgYnkgY29vcmRSYW5nZSBhY2NyYXRlbHksIHdoaWNoIG1heSBicmluZyB0cm91YmxlIHdoZW5cbiAgICAgICAgLy8gYnJ1c2hpbmcgb25seSBvbmUgaXRlbS4gU28gd2UgdXNlIF9fcmFuZ2VPZmZzZXQgdG8gcmVidWlsZGluZyByYW5nZVxuICAgICAgICAvLyBieSBjb29yZFJhbmdlLiBBbmQgdGhpcyBpdCBvbmx5IHVzZWQgaW4gYnJ1c2ggY29tcG9uZW50IHNvIGl0IGlzIG5vXG4gICAgICAgIC8vIG5lZWQgdG8gYmUgYWRhcHRlZCB0byBjb29yZFJhbmdlcy5cblxuICAgICAgICB2YXIgcmVzdWx0ID0gY29vcmRDb252ZXJ0W2FyZWEuYnJ1c2hUeXBlXSgwLCBjb29yZFN5cywgY29vcmRSYW5nZSk7XG4gICAgICAgIGFyZWEuX19yYW5nZU9mZnNldCA9IHtcbiAgICAgICAgICBvZmZzZXQ6IGRpZmZQcm9jZXNzb3JbYXJlYS5icnVzaFR5cGVdKHJlc3VsdC52YWx1ZXMsIGFyZWEucmFuZ2UsIFsxLCAxXSksXG4gICAgICAgICAgeHlNaW5NYXg6IHJlc3VsdC54eU1pbk1heFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhcmVhcztcbiAgfTtcblxuICBCcnVzaFRhcmdldE1hbmFnZXIucHJvdG90eXBlLm1hdGNoT3V0cHV0UmFuZ2VzID0gZnVuY3Rpb24gKGFyZWFzLCBlY01vZGVsLCBjYikge1xuICAgIGVhY2goYXJlYXMsIGZ1bmN0aW9uIChhcmVhKSB7XG4gICAgICB2YXIgdGFyZ2V0SW5mbyA9IHRoaXMuZmluZFRhcmdldEluZm8oYXJlYSwgZWNNb2RlbCk7XG5cbiAgICAgIGlmICh0YXJnZXRJbmZvICYmIHRhcmdldEluZm8gIT09IHRydWUpIHtcbiAgICAgICAgZWFjaCh0YXJnZXRJbmZvLmNvb3JkU3lzZXMsIGZ1bmN0aW9uIChjb29yZFN5cykge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjb29yZENvbnZlcnRbYXJlYS5icnVzaFR5cGVdKDEsIGNvb3JkU3lzLCBhcmVhLnJhbmdlKTtcbiAgICAgICAgICBjYihhcmVhLCByZXN1bHQudmFsdWVzLCBjb29yZFN5cywgZWNNb2RlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuICAvKipcbiAgICogdGhlIGBhcmVhc2AgaXMgYEJydXNoTW9kZWwuYXJlYXNgLlxuICAgKiBDYWxsZWQgaW4gbGF5b3V0IHN0YWdlLlxuICAgKiBjb252ZXJ0IGBhcmVhLmNvb3JkUmFuZ2VgIHRvIGdsb2JhbCByYW5nZSBhbmQgc2V0IHBhbmVsSWQgdG8gYGFyZWEucmFuZ2VgLlxuICAgKi9cblxuXG4gIEJydXNoVGFyZ2V0TWFuYWdlci5wcm90b3R5cGUuc2V0SW5wdXRSYW5nZXMgPSBmdW5jdGlvbiAoYXJlYXMsIGVjTW9kZWwpIHtcbiAgICBlYWNoKGFyZWFzLCBmdW5jdGlvbiAoYXJlYSkge1xuICAgICAgdmFyIHRhcmdldEluZm8gPSB0aGlzLmZpbmRUYXJnZXRJbmZvKGFyZWEsIGVjTW9kZWwpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhc3NlcnQoIXRhcmdldEluZm8gfHwgdGFyZ2V0SW5mbyA9PT0gdHJ1ZSB8fCBhcmVhLmNvb3JkUmFuZ2UsICdjb29yZFJhbmdlIG11c3QgYmUgc3BlY2lmaWVkIHdoZW4gY29vcmQgaW5kZXggc3BlY2lmaWVkLicpO1xuICAgICAgICBhc3NlcnQoIXRhcmdldEluZm8gfHwgdGFyZ2V0SW5mbyAhPT0gdHJ1ZSB8fCBhcmVhLnJhbmdlLCAncmFuZ2UgbXVzdCBiZSBzcGVjaWZpZWQgaW4gZ2xvYmFsIGJydXNoLicpO1xuICAgICAgfVxuXG4gICAgICBhcmVhLnJhbmdlID0gYXJlYS5yYW5nZSB8fCBbXTsgLy8gY29udmVydCBjb29yZFJhbmdlIHRvIGdsb2JhbCByYW5nZSBhbmQgc2V0IHBhbmVsSWQuXG5cbiAgICAgIGlmICh0YXJnZXRJbmZvICYmIHRhcmdldEluZm8gIT09IHRydWUpIHtcbiAgICAgICAgYXJlYS5wYW5lbElkID0gdGFyZ2V0SW5mby5wYW5lbElkOyAvLyAoMSkgYXJlYS5yYW5nZSBzaG91bGUgYWx3YXlzIGJlIGNhbGN1bGF0ZSBmcm9tIGNvb3JkUmFuZ2UgYnV0IGRvZXNcbiAgICAgICAgLy8gbm90IGtlZXAgaXRzIG9yaWdpbmFsIHZhbHVlLCBmb3IgdGhlIHNha2Ugb2YgdGhlIGRhdGFab29tIHNjZW5hcmlvLFxuICAgICAgICAvLyB3aGVyZSBhcmVhLmNvb3JkUmFuZ2UgcmVtYWlucyB1bmNoYW5nZWQgYnV0IGFyZWEucmFuZ2UgbWF5IGJlIGNoYW5nZWQuXG4gICAgICAgIC8vICgyKSBPbmx5IHN1cHBvcnQgY29udmVydGluZyBvbmUgY29vcmRSYW5nZSB0byBwaXhlbCByYW5nZSBpbiBicnVzaFxuICAgICAgICAvLyBjb21wb25lbnQuIFNvIGRvIG5vdCBjb25zaWRlciBgY29vcmRSYW5nZXNgLlxuICAgICAgICAvLyAoMykgQWJvdXQgX19yYW5nZU9mZnNldCwgc2VlIGNvbW1lbnQgYWJvdmUuXG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvb3JkQ29udmVydFthcmVhLmJydXNoVHlwZV0oMCwgdGFyZ2V0SW5mby5jb29yZFN5cywgYXJlYS5jb29yZFJhbmdlKTtcbiAgICAgICAgdmFyIHJhbmdlT2Zmc2V0ID0gYXJlYS5fX3JhbmdlT2Zmc2V0O1xuICAgICAgICBhcmVhLnJhbmdlID0gcmFuZ2VPZmZzZXQgPyBkaWZmUHJvY2Vzc29yW2FyZWEuYnJ1c2hUeXBlXShyZXN1bHQudmFsdWVzLCByYW5nZU9mZnNldC5vZmZzZXQsIGdldFNjYWxlcyhyZXN1bHQueHlNaW5NYXgsIHJhbmdlT2Zmc2V0Lnh5TWluTWF4KSkgOiByZXN1bHQudmFsdWVzO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4gIEJydXNoVGFyZ2V0TWFuYWdlci5wcm90b3R5cGUubWFrZVBhbmVsT3B0cyA9IGZ1bmN0aW9uIChhcGksIGdldERlZmF1bHRCcnVzaFR5cGUpIHtcbiAgICByZXR1cm4gbWFwKHRoaXMuX3RhcmdldEluZm9MaXN0LCBmdW5jdGlvbiAodGFyZ2V0SW5mbykge1xuICAgICAgdmFyIHJlY3QgPSB0YXJnZXRJbmZvLmdldFBhbmVsUmVjdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFuZWxJZDogdGFyZ2V0SW5mby5wYW5lbElkLFxuICAgICAgICBkZWZhdWx0QnJ1c2hUeXBlOiBnZXREZWZhdWx0QnJ1c2hUeXBlID8gZ2V0RGVmYXVsdEJydXNoVHlwZSh0YXJnZXRJbmZvKSA6IG51bGwsXG4gICAgICAgIGNsaXBQYXRoOiBicnVzaEhlbHBlci5tYWtlUmVjdFBhbmVsQ2xpcFBhdGgocmVjdCksXG4gICAgICAgIGlzVGFyZ2V0QnlDdXJzb3I6IGJydXNoSGVscGVyLm1ha2VSZWN0SXNUYXJnZXRCeUN1cnNvcihyZWN0LCBhcGksIHRhcmdldEluZm8uY29vcmRTeXNNb2RlbCksXG4gICAgICAgIGdldExpbmVhckJydXNoT3RoZXJFeHRlbnQ6IGJydXNoSGVscGVyLm1ha2VMaW5lYXJCcnVzaE90aGVyRXh0ZW50KHJlY3QpXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIEJydXNoVGFyZ2V0TWFuYWdlci5wcm90b3R5cGUuY29udHJvbFNlcmllcyA9IGZ1bmN0aW9uIChhcmVhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgIC8vIENoZWNrIHdoZXRoZXIgYXJlYSBpcyBib3VuZCBpbiBjb29yZCwgYW5kIHNlcmllcyBkbyBub3QgYmVsb25nIHRvIHRoYXQgY29vcmQuXG4gICAgLy8gSWYgZG8gbm90IGRvIHRoaXMgY2hlY2ssIHNvbWUgYnJ1c2ggKGxpa2UgbGluZVgpIHdpbGwgY29udHJvbGwgYWxsIGF4ZXMuXG4gICAgdmFyIHRhcmdldEluZm8gPSB0aGlzLmZpbmRUYXJnZXRJbmZvKGFyZWEsIGVjTW9kZWwpO1xuICAgIHJldHVybiB0YXJnZXRJbmZvID09PSB0cnVlIHx8IHRhcmdldEluZm8gJiYgaW5kZXhPZih0YXJnZXRJbmZvLmNvb3JkU3lzZXMsIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0pID49IDA7XG4gIH07XG4gIC8qKlxuICAgKiBJZiByZXR1cm4gT2JqZWN0LCBhIGNvb3JkIGZvdW5kLlxuICAgKiBJZiByZXV0cm4gdHJ1ZSwgZ2xvYmFsIGZvdW5kLlxuICAgKiBPdGhlcndpc2Ugbm90aGluZyBmb3VuZC5cbiAgICovXG5cblxuICBCcnVzaFRhcmdldE1hbmFnZXIucHJvdG90eXBlLmZpbmRUYXJnZXRJbmZvID0gZnVuY3Rpb24gKGFyZWEsIGVjTW9kZWwpIHtcbiAgICB2YXIgdGFyZ2V0SW5mb0xpc3QgPSB0aGlzLl90YXJnZXRJbmZvTGlzdDtcbiAgICB2YXIgZm91bmRDcHRzID0gcGFyc2VGaW5kZXIoZWNNb2RlbCwgYXJlYSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldEluZm9MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGFyZ2V0SW5mbyA9IHRhcmdldEluZm9MaXN0W2ldO1xuICAgICAgdmFyIGFyZWFQYW5lbElkID0gYXJlYS5wYW5lbElkO1xuXG4gICAgICBpZiAoYXJlYVBhbmVsSWQpIHtcbiAgICAgICAgaWYgKHRhcmdldEluZm8ucGFuZWxJZCA9PT0gYXJlYVBhbmVsSWQpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0SW5mbztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0YXJnZXRJbmZvTWF0Y2hlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodGFyZ2V0SW5mb01hdGNoZXJzW2pdKGZvdW5kQ3B0cywgdGFyZ2V0SW5mbykpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRJbmZvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHJldHVybiBCcnVzaFRhcmdldE1hbmFnZXI7XG59KCk7XG5cbmZ1bmN0aW9uIGZvcm1hdE1pbk1heChtaW5NYXgpIHtcbiAgbWluTWF4WzBdID4gbWluTWF4WzFdICYmIG1pbk1heC5yZXZlcnNlKCk7XG4gIHJldHVybiBtaW5NYXg7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRmluZGVyKGVjTW9kZWwsIGZpbmRlcikge1xuICByZXR1cm4gbW9kZWxVdGlsUGFyc2VGaW5kZXIoZWNNb2RlbCwgZmluZGVyLCB7XG4gICAgaW5jbHVkZU1haW5UeXBlczogSU5DTFVERV9GSU5ERVJfTUFJTl9UWVBFU1xuICB9KTtcbn1cblxudmFyIHRhcmdldEluZm9CdWlsZGVycyA9IHtcbiAgZ3JpZDogZnVuY3Rpb24gKGZvdW5kQ3B0cywgdGFyZ2V0SW5mb0xpc3QpIHtcbiAgICB2YXIgeEF4aXNNb2RlbHMgPSBmb3VuZENwdHMueEF4aXNNb2RlbHM7XG4gICAgdmFyIHlBeGlzTW9kZWxzID0gZm91bmRDcHRzLnlBeGlzTW9kZWxzO1xuICAgIHZhciBncmlkTW9kZWxzID0gZm91bmRDcHRzLmdyaWRNb2RlbHM7IC8vIFJlbW92ZSBkdXBsaWNhdGVkLlxuXG4gICAgdmFyIGdyaWRNb2RlbE1hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgICB2YXIgeEF4ZXNIYXMgPSB7fTtcbiAgICB2YXIgeUF4ZXNIYXMgPSB7fTtcblxuICAgIGlmICgheEF4aXNNb2RlbHMgJiYgIXlBeGlzTW9kZWxzICYmICFncmlkTW9kZWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWFjaCh4QXhpc01vZGVscywgZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgICAgdmFyIGdyaWRNb2RlbCA9IGF4aXNNb2RlbC5heGlzLmdyaWQubW9kZWw7XG4gICAgICBncmlkTW9kZWxNYXAuc2V0KGdyaWRNb2RlbC5pZCwgZ3JpZE1vZGVsKTtcbiAgICAgIHhBeGVzSGFzW2dyaWRNb2RlbC5pZF0gPSB0cnVlO1xuICAgIH0pO1xuICAgIGVhY2goeUF4aXNNb2RlbHMsIGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICAgIHZhciBncmlkTW9kZWwgPSBheGlzTW9kZWwuYXhpcy5ncmlkLm1vZGVsO1xuICAgICAgZ3JpZE1vZGVsTWFwLnNldChncmlkTW9kZWwuaWQsIGdyaWRNb2RlbCk7XG4gICAgICB5QXhlc0hhc1tncmlkTW9kZWwuaWRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBlYWNoKGdyaWRNb2RlbHMsIGZ1bmN0aW9uIChncmlkTW9kZWwpIHtcbiAgICAgIGdyaWRNb2RlbE1hcC5zZXQoZ3JpZE1vZGVsLmlkLCBncmlkTW9kZWwpO1xuICAgICAgeEF4ZXNIYXNbZ3JpZE1vZGVsLmlkXSA9IHRydWU7XG4gICAgICB5QXhlc0hhc1tncmlkTW9kZWwuaWRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBncmlkTW9kZWxNYXAuZWFjaChmdW5jdGlvbiAoZ3JpZE1vZGVsKSB7XG4gICAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgdmFyIGNhcnRlc2lhbnMgPSBbXTtcbiAgICAgIGVhY2goZ3JpZC5nZXRDYXJ0ZXNpYW5zKCksIGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleE9mKHhBeGlzTW9kZWxzLCBjYXJ0ZXNpYW4uZ2V0QXhpcygneCcpLm1vZGVsKSA+PSAwIHx8IGluZGV4T2YoeUF4aXNNb2RlbHMsIGNhcnRlc2lhbi5nZXRBeGlzKCd5JykubW9kZWwpID49IDApIHtcbiAgICAgICAgICBjYXJ0ZXNpYW5zLnB1c2goY2FydGVzaWFuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0YXJnZXRJbmZvTGlzdC5wdXNoKHtcbiAgICAgICAgcGFuZWxJZDogJ2dyaWQtLScgKyBncmlkTW9kZWwuaWQsXG4gICAgICAgIGdyaWRNb2RlbDogZ3JpZE1vZGVsLFxuICAgICAgICBjb29yZFN5c01vZGVsOiBncmlkTW9kZWwsXG4gICAgICAgIC8vIFVzZSB0aGUgZmlyc3Qgb25lIGFzIHRoZSByZXByZXNlbnRpdGl2ZSBjb29yZFN5cy5cbiAgICAgICAgY29vcmRTeXM6IGNhcnRlc2lhbnNbMF0sXG4gICAgICAgIGNvb3JkU3lzZXM6IGNhcnRlc2lhbnMsXG4gICAgICAgIGdldFBhbmVsUmVjdDogcGFuZWxSZWN0QnVpbGRlcnMuZ3JpZCxcbiAgICAgICAgeEF4aXNEZWNsYXJlZDogeEF4ZXNIYXNbZ3JpZE1vZGVsLmlkXSxcbiAgICAgICAgeUF4aXNEZWNsYXJlZDogeUF4ZXNIYXNbZ3JpZE1vZGVsLmlkXVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG4gIGdlbzogZnVuY3Rpb24gKGZvdW5kQ3B0cywgdGFyZ2V0SW5mb0xpc3QpIHtcbiAgICBlYWNoKGZvdW5kQ3B0cy5nZW9Nb2RlbHMsIGZ1bmN0aW9uIChnZW9Nb2RlbCkge1xuICAgICAgdmFyIGNvb3JkU3lzID0gZ2VvTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgIHRhcmdldEluZm9MaXN0LnB1c2goe1xuICAgICAgICBwYW5lbElkOiAnZ2VvLS0nICsgZ2VvTW9kZWwuaWQsXG4gICAgICAgIGdlb01vZGVsOiBnZW9Nb2RlbCxcbiAgICAgICAgY29vcmRTeXNNb2RlbDogZ2VvTW9kZWwsXG4gICAgICAgIGNvb3JkU3lzOiBjb29yZFN5cyxcbiAgICAgICAgY29vcmRTeXNlczogW2Nvb3JkU3lzXSxcbiAgICAgICAgZ2V0UGFuZWxSZWN0OiBwYW5lbFJlY3RCdWlsZGVycy5nZW9cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xudmFyIHRhcmdldEluZm9NYXRjaGVycyA9IFsvLyBncmlkXG5mdW5jdGlvbiAoZm91bmRDcHRzLCB0YXJnZXRJbmZvKSB7XG4gIHZhciB4QXhpc01vZGVsID0gZm91bmRDcHRzLnhBeGlzTW9kZWw7XG4gIHZhciB5QXhpc01vZGVsID0gZm91bmRDcHRzLnlBeGlzTW9kZWw7XG4gIHZhciBncmlkTW9kZWwgPSBmb3VuZENwdHMuZ3JpZE1vZGVsO1xuICAhZ3JpZE1vZGVsICYmIHhBeGlzTW9kZWwgJiYgKGdyaWRNb2RlbCA9IHhBeGlzTW9kZWwuYXhpcy5ncmlkLm1vZGVsKTtcbiAgIWdyaWRNb2RlbCAmJiB5QXhpc01vZGVsICYmIChncmlkTW9kZWwgPSB5QXhpc01vZGVsLmF4aXMuZ3JpZC5tb2RlbCk7XG4gIHJldHVybiBncmlkTW9kZWwgJiYgZ3JpZE1vZGVsID09PSB0YXJnZXRJbmZvLmdyaWRNb2RlbDtcbn0sIC8vIGdlb1xuZnVuY3Rpb24gKGZvdW5kQ3B0cywgdGFyZ2V0SW5mbykge1xuICB2YXIgZ2VvTW9kZWwgPSBmb3VuZENwdHMuZ2VvTW9kZWw7XG4gIHJldHVybiBnZW9Nb2RlbCAmJiBnZW9Nb2RlbCA9PT0gdGFyZ2V0SW5mby5nZW9Nb2RlbDtcbn1dO1xudmFyIHBhbmVsUmVjdEJ1aWxkZXJzID0ge1xuICBncmlkOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZ3JpZCBpcyBub3QgVHJhbnNmb3JtYWJsZS5cbiAgICByZXR1cm4gdGhpcy5jb29yZFN5cy5tYXN0ZXIuZ2V0UmVjdCgpLmNsb25lKCk7XG4gIH0sXG4gIGdlbzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb29yZFN5cyA9IHRoaXMuY29vcmRTeXM7XG4gICAgdmFyIHJlY3QgPSBjb29yZFN5cy5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpOyAvLyBnZW8gcm9hbSBhbmQgem9vbSB0cmFuc2Zvcm1cblxuICAgIHJlY3QuYXBwbHlUcmFuc2Zvcm0oZ3JhcGhpYy5nZXRUcmFuc2Zvcm0oY29vcmRTeXMpKTtcbiAgICByZXR1cm4gcmVjdDtcbiAgfVxufTtcbnZhciBjb29yZENvbnZlcnQgPSB7XG4gIGxpbmVYOiBjdXJyeShheGlzQ29udmVydCwgMCksXG4gIGxpbmVZOiBjdXJyeShheGlzQ29udmVydCwgMSksXG4gIHJlY3Q6IGZ1bmN0aW9uICh0bywgY29vcmRTeXMsIHJhbmdlT3JDb29yZFJhbmdlKSB7XG4gICAgdmFyIHhtaW55bWluID0gY29vcmRTeXNbQ09PUkRfQ09OVkVSVFNbdG9dXShbcmFuZ2VPckNvb3JkUmFuZ2VbMF1bMF0sIHJhbmdlT3JDb29yZFJhbmdlWzFdWzBdXSk7XG4gICAgdmFyIHhtYXh5bWF4ID0gY29vcmRTeXNbQ09PUkRfQ09OVkVSVFNbdG9dXShbcmFuZ2VPckNvb3JkUmFuZ2VbMF1bMV0sIHJhbmdlT3JDb29yZFJhbmdlWzFdWzFdXSk7XG4gICAgdmFyIHZhbHVlcyA9IFtmb3JtYXRNaW5NYXgoW3htaW55bWluWzBdLCB4bWF4eW1heFswXV0pLCBmb3JtYXRNaW5NYXgoW3htaW55bWluWzFdLCB4bWF4eW1heFsxXV0pXTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICB4eU1pbk1heDogdmFsdWVzXG4gICAgfTtcbiAgfSxcbiAgcG9seWdvbjogZnVuY3Rpb24gKHRvLCBjb29yZFN5cywgcmFuZ2VPckNvb3JkUmFuZ2UpIHtcbiAgICB2YXIgeHlNaW5NYXggPSBbW0luZmluaXR5LCAtSW5maW5pdHldLCBbSW5maW5pdHksIC1JbmZpbml0eV1dO1xuICAgIHZhciB2YWx1ZXMgPSBtYXAocmFuZ2VPckNvb3JkUmFuZ2UsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgcCA9IGNvb3JkU3lzW0NPT1JEX0NPTlZFUlRTW3RvXV0oaXRlbSk7XG4gICAgICB4eU1pbk1heFswXVswXSA9IE1hdGgubWluKHh5TWluTWF4WzBdWzBdLCBwWzBdKTtcbiAgICAgIHh5TWluTWF4WzFdWzBdID0gTWF0aC5taW4oeHlNaW5NYXhbMV1bMF0sIHBbMV0pO1xuICAgICAgeHlNaW5NYXhbMF1bMV0gPSBNYXRoLm1heCh4eU1pbk1heFswXVsxXSwgcFswXSk7XG4gICAgICB4eU1pbk1heFsxXVsxXSA9IE1hdGgubWF4KHh5TWluTWF4WzFdWzFdLCBwWzFdKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgIHh5TWluTWF4OiB4eU1pbk1heFxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGF4aXNDb252ZXJ0KGF4aXNOYW1lSW5kZXgsIHRvLCBjb29yZFN5cywgcmFuZ2VPckNvb3JkUmFuZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJywgJ2xpbmVYL2xpbmVZIGJydXNoIGlzIGF2YWlsYWJsZSBvbmx5IGluIGNhcnRlc2lhbjJkLicpO1xuICB9XG5cbiAgdmFyIGF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKFsneCcsICd5J11bYXhpc05hbWVJbmRleF0pO1xuICB2YXIgdmFsdWVzID0gZm9ybWF0TWluTWF4KG1hcChbMCwgMV0sIGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIHRvID8gYXhpcy5jb29yZFRvRGF0YShheGlzLnRvTG9jYWxDb29yZChyYW5nZU9yQ29vcmRSYW5nZVtpXSkpIDogYXhpcy50b0dsb2JhbENvb3JkKGF4aXMuZGF0YVRvQ29vcmQocmFuZ2VPckNvb3JkUmFuZ2VbaV0pKTtcbiAgfSkpO1xuICB2YXIgeHlNaW5NYXggPSBbXTtcbiAgeHlNaW5NYXhbYXhpc05hbWVJbmRleF0gPSB2YWx1ZXM7XG4gIHh5TWluTWF4WzEgLSBheGlzTmFtZUluZGV4XSA9IFtOYU4sIE5hTl07XG4gIHJldHVybiB7XG4gICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgeHlNaW5NYXg6IHh5TWluTWF4XG4gIH07XG59XG5cbnZhciBkaWZmUHJvY2Vzc29yID0ge1xuICBsaW5lWDogY3VycnkoYXhpc0RpZmZQcm9jZXNzb3IsIDApLFxuICBsaW5lWTogY3VycnkoYXhpc0RpZmZQcm9jZXNzb3IsIDEpLFxuICByZWN0OiBmdW5jdGlvbiAodmFsdWVzLCByZWZlciwgc2NhbGVzKSB7XG4gICAgcmV0dXJuIFtbdmFsdWVzWzBdWzBdIC0gc2NhbGVzWzBdICogcmVmZXJbMF1bMF0sIHZhbHVlc1swXVsxXSAtIHNjYWxlc1swXSAqIHJlZmVyWzBdWzFdXSwgW3ZhbHVlc1sxXVswXSAtIHNjYWxlc1sxXSAqIHJlZmVyWzFdWzBdLCB2YWx1ZXNbMV1bMV0gLSBzY2FsZXNbMV0gKiByZWZlclsxXVsxXV1dO1xuICB9LFxuICBwb2x5Z29uOiBmdW5jdGlvbiAodmFsdWVzLCByZWZlciwgc2NhbGVzKSB7XG4gICAgcmV0dXJuIG1hcCh2YWx1ZXMsIGZ1bmN0aW9uIChpdGVtLCBpZHgpIHtcbiAgICAgIHJldHVybiBbaXRlbVswXSAtIHNjYWxlc1swXSAqIHJlZmVyW2lkeF1bMF0sIGl0ZW1bMV0gLSBzY2FsZXNbMV0gKiByZWZlcltpZHhdWzFdXTtcbiAgICB9KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXhpc0RpZmZQcm9jZXNzb3IoYXhpc05hbWVJbmRleCwgdmFsdWVzLCByZWZlciwgc2NhbGVzKSB7XG4gIHJldHVybiBbdmFsdWVzWzBdIC0gc2NhbGVzW2F4aXNOYW1lSW5kZXhdICogcmVmZXJbMF0sIHZhbHVlc1sxXSAtIHNjYWxlc1theGlzTmFtZUluZGV4XSAqIHJlZmVyWzFdXTtcbn0gLy8gV2UgaGF2ZSB0byBwcm9jZXNzIHNjYWxlIGNhdXNlZCBieSBkYXRhWm9vbSBtYW51YWxseSxcbi8vIGFsdGhvdWdoIGl0IG1pZ2h0IGJlIG5vdCBhY2N1cmF0ZS5cbi8vIFJldHVybiBbMH4xLCAwfjFdXG5cblxuZnVuY3Rpb24gZ2V0U2NhbGVzKHh5TWluTWF4Q3VyciwgeHlNaW5NYXhPcmlnaW4pIHtcbiAgdmFyIHNpemVDdXJyID0gZ2V0U2l6ZSh4eU1pbk1heEN1cnIpO1xuICB2YXIgc2l6ZU9yaWdpbiA9IGdldFNpemUoeHlNaW5NYXhPcmlnaW4pO1xuICB2YXIgc2NhbGVzID0gW3NpemVDdXJyWzBdIC8gc2l6ZU9yaWdpblswXSwgc2l6ZUN1cnJbMV0gLyBzaXplT3JpZ2luWzFdXTtcbiAgaXNOYU4oc2NhbGVzWzBdKSAmJiAoc2NhbGVzWzBdID0gMSk7XG4gIGlzTmFOKHNjYWxlc1sxXSkgJiYgKHNjYWxlc1sxXSA9IDEpO1xuICByZXR1cm4gc2NhbGVzO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplKHh5TWluTWF4KSB7XG4gIHJldHVybiB4eU1pbk1heCA/IFt4eU1pbk1heFswXVsxXSAtIHh5TWluTWF4WzBdWzBdLCB4eU1pbk1heFsxXVsxXSAtIHh5TWluTWF4WzFdWzBdXSA6IFtOYU4sIE5hTl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJydXNoVGFyZ2V0TWFuYWdlcjsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gQHRzLW5vY2hlY2tcbmltcG9ydCB7IGdldExheW91dFJlY3QsIGJveCBhcyBsYXlvdXRCb3gsIHBvc2l0aW9uRWxlbWVudCB9IGZyb20gJy4uLy4uL3V0aWwvbGF5b3V0JztcbmltcG9ydCAqIGFzIGZvcm1hdFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9mb3JtYXQnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuLyoqXG4gKiBMYXlvdXQgbGlzdCBsaWtlIGNvbXBvbmVudC5cbiAqIEl0IHdpbGwgYm94IGxheW91dCBlYWNoIGl0ZW1zIGluIGdyb3VwIG9mIGNvbXBvbmVudCBhbmQgdGhlbiBwb3NpdGlvbiB0aGUgd2hvbGUgZ3JvdXAgaW4gdGhlIHZpZXdwb3J0XG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyb3VwL0dyb3VwfSBncm91cFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9IGNvbXBvbmVudE1vZGVsXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGF5b3V0KGdyb3VwLCBjb21wb25lbnRNb2RlbCwgYXBpKSB7XG4gIHZhciBib3hMYXlvdXRQYXJhbXMgPSBjb21wb25lbnRNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKTtcbiAgdmFyIHBhZGRpbmcgPSBjb21wb25lbnRNb2RlbC5nZXQoJ3BhZGRpbmcnKTtcbiAgdmFyIHZpZXdwb3J0U2l6ZSA9IHtcbiAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgfTtcbiAgdmFyIHJlY3QgPSBnZXRMYXlvdXRSZWN0KGJveExheW91dFBhcmFtcywgdmlld3BvcnRTaXplLCBwYWRkaW5nKTtcbiAgbGF5b3V0Qm94KGNvbXBvbmVudE1vZGVsLmdldCgnb3JpZW50JyksIGdyb3VwLCBjb21wb25lbnRNb2RlbC5nZXQoJ2l0ZW1HYXAnKSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICBwb3NpdGlvbkVsZW1lbnQoZ3JvdXAsIGJveExheW91dFBhcmFtcywgdmlld3BvcnRTaXplLCBwYWRkaW5nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQmFja2dyb3VuZChyZWN0LCBjb21wb25lbnRNb2RlbCkge1xuICB2YXIgcGFkZGluZyA9IGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkoY29tcG9uZW50TW9kZWwuZ2V0KCdwYWRkaW5nJykpO1xuICB2YXIgc3R5bGUgPSBjb21wb25lbnRNb2RlbC5nZXRJdGVtU3R5bGUoWydjb2xvcicsICdvcGFjaXR5J10pO1xuICBzdHlsZS5maWxsID0gY29tcG9uZW50TW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgIHNoYXBlOiB7XG4gICAgICB4OiByZWN0LnggLSBwYWRkaW5nWzNdLFxuICAgICAgeTogcmVjdC55IC0gcGFkZGluZ1swXSxcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoICsgcGFkZGluZ1sxXSArIHBhZGRpbmdbM10sXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICsgcGFkZGluZ1swXSArIHBhZGRpbmdbMl0sXG4gICAgICByOiBjb21wb25lbnRNb2RlbC5nZXQoJ2JvcmRlclJhZGl1cycpXG4gICAgfSxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgc2lsZW50OiB0cnVlLFxuICAgIHoyOiAtMVxuICB9KTsgLy8gRklYTUVcbiAgLy8gYHN1YlBpeGVsT3B0aW1pemVSZWN0YCBtYXkgYnJpbmcgc29tZSBnYXAgYmV0d2VlbiBlZGdlIG9mIHZpZXdwYXJ0XG4gIC8vIGFuZCBiYWNrZ3JvdW5kIHJlY3Qgd2hlbiBzZXR0aW5nIGxpa2UgYGxlZnQ6IDBgLCBgdG9wOiAwYC5cbiAgLy8gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdChyZWN0KTtcblxuICByZXR1cm4gcmVjdDtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Nb2RlbCc7XG5pbXBvcnQgeyBpc05hbWVTcGVjaWZpZWQgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbmltcG9ydCBDb21wb25lbnRNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Db21wb25lbnQnO1xuXG52YXIgZ2V0RGVmYXVsdFNlbGVjdG9yT3B0aW9ucyA9IGZ1bmN0aW9uIChlY01vZGVsLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnYWxsJykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnYWxsJyxcbiAgICAgIHRpdGxlOiBlY01vZGVsLmdldExvY2FsZShbJ2xlZ2VuZCcsICdzZWxlY3RvcicsICdhbGwnXSlcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpbnZlcnNlJykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnaW52ZXJzZScsXG4gICAgICB0aXRsZTogZWNNb2RlbC5nZXRMb2NhbGUoWydsZWdlbmQnLCAnc2VsZWN0b3InLCAnaW52ZXJzZSddKVxuICAgIH07XG4gIH1cbn07XG5cbnZhciBMZWdlbmRNb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhMZWdlbmRNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBMZWdlbmRNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBMZWdlbmRNb2RlbC50eXBlO1xuICAgIF90aGlzLmxheW91dE1vZGUgPSB7XG4gICAgICB0eXBlOiAnYm94JyxcbiAgICAgIC8vIGxlZ2VuZC53aWR0aC9oZWlnaHQgYXJlIG1heFdpZHRoL21heEhlaWdodCBhY3R1YWxseSxcbiAgICAgIC8vIHdoZXJlYXMgcmVhbHkgd2lkdGgvaGVpZ2h0IGlzIGNhbGN1bGF0ZWQgYnkgaXRzIGNvbnRlbnQuXG4gICAgICAvLyAoU2V0dGluZyB7bGVmdDogMTAsIHJpZ2h0OiAxMH0gZG9lcyBub3QgbWFrZSBzZW5zZSkuXG4gICAgICAvLyBTbyBjb25zaWRlciB0aGUgY2FzZTpcbiAgICAgIC8vIGBzZXRPcHRpb24oe2xlZ2VuZDoge2xlZnQ6IDEwfSk7YFxuICAgICAgLy8gdGhlbiBgc2V0T3B0aW9uKHtsZWdlbmQ6IHtyaWdodDogMTB9KTtgXG4gICAgICAvLyBUaGUgcHJldmlvdXMgYGxlZnRgIHNob3VsZCBiZSBjbGVhcmVkIGJ5IHNldHRpbmcgYGlnbm9yZVNpemVgLlxuICAgICAgaWdub3JlU2l6ZTogdHJ1ZVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgTGVnZW5kTW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCkge1xuICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcbiAgICBvcHRpb24uc2VsZWN0ZWQgPSBvcHRpb24uc2VsZWN0ZWQgfHwge307XG5cbiAgICB0aGlzLl91cGRhdGVTZWxlY3RvcihvcHRpb24pO1xuICB9O1xuXG4gIExlZ2VuZE1vZGVsLnByb3RvdHlwZS5tZXJnZU9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLm1lcmdlT3B0aW9uLmNhbGwodGhpcywgb3B0aW9uLCBlY01vZGVsKTtcblxuICAgIHRoaXMuX3VwZGF0ZVNlbGVjdG9yKG9wdGlvbik7XG4gIH07XG5cbiAgTGVnZW5kTW9kZWwucHJvdG90eXBlLl91cGRhdGVTZWxlY3RvciA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBvcHRpb24uc2VsZWN0b3I7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG5cbiAgICBpZiAoc2VsZWN0b3IgPT09IHRydWUpIHtcbiAgICAgIHNlbGVjdG9yID0gb3B0aW9uLnNlbGVjdG9yID0gWydhbGwnLCAnaW52ZXJzZSddO1xuICAgIH1cblxuICAgIGlmICh6clV0aWwuaXNBcnJheShzZWxlY3RvcikpIHtcbiAgICAgIHpyVXRpbC5lYWNoKHNlbGVjdG9yLCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgenJVdGlsLmlzU3RyaW5nKGl0ZW0pICYmIChpdGVtID0ge1xuICAgICAgICAgIHR5cGU6IGl0ZW1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGVjdG9yW2luZGV4XSA9IHpyVXRpbC5tZXJnZShpdGVtLCBnZXREZWZhdWx0U2VsZWN0b3JPcHRpb25zKGVjTW9kZWwsIGl0ZW0udHlwZSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIExlZ2VuZE1vZGVsLnByb3RvdHlwZS5vcHRpb25VcGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZURhdGEodGhpcy5lY01vZGVsKTtcblxuICAgIHZhciBsZWdlbmREYXRhID0gdGhpcy5fZGF0YTsgLy8gSWYgc2VsZWN0ZWRNb2RlIGlzIHNpbmdsZSwgdHJ5IHRvIHNlbGVjdCBvbmVcblxuICAgIGlmIChsZWdlbmREYXRhWzBdICYmIHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIHZhciBoYXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBJZiBoYXMgYW55IHNlbGVjdGVkIGluIG9wdGlvbi5zZWxlY3RlZFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZ2VuZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWVfMSA9IGxlZ2VuZERhdGFbaV0uZ2V0KCduYW1lJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZChuYW1lXzEpKSB7XG4gICAgICAgICAgLy8gRm9yY2UgdG8gdW5zZWxlY3Qgb3RoZXJzXG4gICAgICAgICAgdGhpcy5zZWxlY3QobmFtZV8xKTtcbiAgICAgICAgICBoYXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVHJ5IHNlbGVjdCB0aGUgZmlyc3QgaWYgc2VsZWN0ZWRNb2RlIGlzIHNpbmdsZVxuXG5cbiAgICAgICFoYXNTZWxlY3RlZCAmJiB0aGlzLnNlbGVjdChsZWdlbmREYXRhWzBdLmdldCgnbmFtZScpKTtcbiAgICB9XG4gIH07XG5cbiAgTGVnZW5kTW9kZWwucHJvdG90eXBlLl91cGRhdGVEYXRhID0gZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICB2YXIgcG90ZW50aWFsRGF0YSA9IFtdO1xuICAgIHZhciBhdmFpbGFibGVOYW1lcyA9IFtdO1xuICAgIGVjTW9kZWwuZWFjaFJhd1NlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHZhciBzZXJpZXNOYW1lID0gc2VyaWVzTW9kZWwubmFtZTtcbiAgICAgIGF2YWlsYWJsZU5hbWVzLnB1c2goc2VyaWVzTmFtZSk7XG4gICAgICB2YXIgaXNQb3RlbnRpYWw7XG5cbiAgICAgIGlmIChzZXJpZXNNb2RlbC5sZWdlbmRWaXN1YWxQcm92aWRlcikge1xuICAgICAgICB2YXIgcHJvdmlkZXIgPSBzZXJpZXNNb2RlbC5sZWdlbmRWaXN1YWxQcm92aWRlcjtcbiAgICAgICAgdmFyIG5hbWVzID0gcHJvdmlkZXIuZ2V0QWxsTmFtZXMoKTtcblxuICAgICAgICBpZiAoIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbCkpIHtcbiAgICAgICAgICBhdmFpbGFibGVOYW1lcyA9IGF2YWlsYWJsZU5hbWVzLmNvbmNhdChuYW1lcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcG90ZW50aWFsRGF0YSA9IHBvdGVudGlhbERhdGEuY29uY2F0KG5hbWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc1BvdGVudGlhbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzUG90ZW50aWFsID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUG90ZW50aWFsICYmIGlzTmFtZVNwZWNpZmllZChzZXJpZXNNb2RlbCkpIHtcbiAgICAgICAgcG90ZW50aWFsRGF0YS5wdXNoKHNlcmllc01vZGVsLm5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fYXZhaWxhYmxlTmFtZXMgPSBhdmFpbGFibGVOYW1lczsgLy8gSWYgbGVnZW5kLmRhdGEgbm90IHNwZWNpZmllZCBpbiBvcHRpb24sIHVzZSBhdmFpbGFibGVOYW1lcyBhcyBkYXRhLFxuICAgIC8vIHdoaWNoIGlzIGNvbnZpbmllbnQgZm9yIHVzZXIgcHJlcGFyaW5nIG9wdGlvbi5cblxuICAgIHZhciByYXdEYXRhID0gdGhpcy5nZXQoJ2RhdGEnKSB8fCBwb3RlbnRpYWxEYXRhO1xuICAgIHZhciBsZWdlbmREYXRhID0genJVdGlsLm1hcChyYXdEYXRhLCBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcbiAgICAgIC8vIENhbiBiZSBzdHJpbmcgb3IgbnVtYmVyXG4gICAgICBpZiAodHlwZW9mIGRhdGFJdGVtID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGF0YUl0ZW0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRhdGFJdGVtID0ge1xuICAgICAgICAgIG5hbWU6IGRhdGFJdGVtXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTW9kZWwoZGF0YUl0ZW0sIHRoaXMsIHRoaXMuZWNNb2RlbCk7XG4gICAgfSwgdGhpcyk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2RhdGEgPSBsZWdlbmREYXRhO1xuICB9O1xuXG4gIExlZ2VuZE1vZGVsLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9O1xuXG4gIExlZ2VuZE1vZGVsLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzZWxlY3RlZCA9IHRoaXMub3B0aW9uLnNlbGVjdGVkO1xuICAgIHZhciBzZWxlY3RlZE1vZGUgPSB0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG5cbiAgICBpZiAoc2VsZWN0ZWRNb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgenJVdGlsLmVhY2goZGF0YSwgZnVuY3Rpb24gKGRhdGFJdGVtKSB7XG4gICAgICAgIHNlbGVjdGVkW2RhdGFJdGVtLmdldCgnbmFtZScpXSA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRbbmFtZV0gPSB0cnVlO1xuICB9O1xuXG4gIExlZ2VuZE1vZGVsLnByb3RvdHlwZS51blNlbGVjdCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKSAhPT0gJ3NpbmdsZScpIHtcbiAgICAgIHRoaXMub3B0aW9uLnNlbGVjdGVkW25hbWVdID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIExlZ2VuZE1vZGVsLnByb3RvdHlwZS50b2dnbGVTZWxlY3RlZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gdGhpcy5vcHRpb24uc2VsZWN0ZWQ7IC8vIERlZmF1bHQgaXMgdHJ1ZVxuXG4gICAgaWYgKCFzZWxlY3RlZC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgc2VsZWN0ZWRbbmFtZV0gPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXNbc2VsZWN0ZWRbbmFtZV0gPyAndW5TZWxlY3QnIDogJ3NlbGVjdCddKG5hbWUpO1xuICB9O1xuXG4gIExlZ2VuZE1vZGVsLnByb3RvdHlwZS5hbGxTZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBzZWxlY3RlZCA9IHRoaXMub3B0aW9uLnNlbGVjdGVkO1xuICAgIHpyVXRpbC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgc2VsZWN0ZWRbZGF0YUl0ZW0uZ2V0KCduYW1lJywgdHJ1ZSldID0gdHJ1ZTtcbiAgICB9KTtcbiAgfTtcblxuICBMZWdlbmRNb2RlbC5wcm90b3R5cGUuaW52ZXJzZVNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgdmFyIHNlbGVjdGVkID0gdGhpcy5vcHRpb24uc2VsZWN0ZWQ7XG4gICAgenJVdGlsLmVhY2goZGF0YSwgZnVuY3Rpb24gKGRhdGFJdGVtKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGFJdGVtLmdldCgnbmFtZScsIHRydWUpOyAvLyBJbml0aWFsbHksIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuXG4gICAgICBpZiAoIXNlbGVjdGVkLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHNlbGVjdGVkW25hbWVdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0ZWRbbmFtZV0gPSAhc2VsZWN0ZWRbbmFtZV07XG4gICAgfSk7XG4gIH07XG5cbiAgTGVnZW5kTW9kZWwucHJvdG90eXBlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzZWxlY3RlZCA9IHRoaXMub3B0aW9uLnNlbGVjdGVkO1xuICAgIHJldHVybiAhKHNlbGVjdGVkLmhhc093blByb3BlcnR5KG5hbWUpICYmICFzZWxlY3RlZFtuYW1lXSkgJiYgenJVdGlsLmluZGV4T2YodGhpcy5fYXZhaWxhYmxlTmFtZXMsIG5hbWUpID49IDA7XG4gIH07XG5cbiAgTGVnZW5kTW9kZWwucHJvdG90eXBlLmdldE9yaWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ29yaWVudCcpID09PSAndmVydGljYWwnID8ge1xuICAgICAgaW5kZXg6IDEsXG4gICAgICBuYW1lOiAndmVydGljYWwnXG4gICAgfSA6IHtcbiAgICAgIGluZGV4OiAwLFxuICAgICAgbmFtZTogJ2hvcml6b250YWwnXG4gICAgfTtcbiAgfTtcblxuICBMZWdlbmRNb2RlbC50eXBlID0gJ2xlZ2VuZC5wbGFpbic7XG4gIExlZ2VuZE1vZGVsLmRlcGVuZGVuY2llcyA9IFsnc2VyaWVzJ107XG4gIExlZ2VuZE1vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDQsXG4gICAgc2hvdzogdHJ1ZSxcbiAgICBvcmllbnQ6ICdob3Jpem9udGFsJyxcbiAgICBsZWZ0OiAnY2VudGVyJyxcbiAgICAvLyByaWdodDogJ2NlbnRlcicsXG4gICAgdG9wOiAwLFxuICAgIC8vIGJvdHRvbTogbnVsbCxcbiAgICBhbGlnbjogJ2F1dG8nLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIHBhZGRpbmc6IDUsXG4gICAgaXRlbUdhcDogMTAsXG4gICAgaXRlbVdpZHRoOiAyNSxcbiAgICBpdGVtSGVpZ2h0OiAxNCxcbiAgICBpbmFjdGl2ZUNvbG9yOiAnI2NjYycsXG4gICAgaW5hY3RpdmVCb3JkZXJDb2xvcjogJyNjY2MnLFxuICAgIGl0ZW1TdHlsZToge1xuICAgICAgYm9yZGVyV2lkdGg6IDBcbiAgICB9LFxuICAgIHRleHRTdHlsZToge1xuICAgICAgY29sb3I6ICcjMzMzJ1xuICAgIH0sXG4gICAgc2VsZWN0ZWRNb2RlOiB0cnVlLFxuICAgIHNlbGVjdG9yOiBmYWxzZSxcbiAgICBzZWxlY3RvckxhYmVsOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgYm9yZGVyUmFkaXVzOiAxMCxcbiAgICAgIHBhZGRpbmc6IFszLCA1LCAzLCA1XSxcbiAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgIGZvbnRGYW1pbHk6ICcgc2Fucy1zZXJpZicsXG4gICAgICBjb2xvcjogJyM2NjYnLFxuICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICBib3JkZXJDb2xvcjogJyM2NjYnXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgc2VsZWN0b3JMYWJlbDoge1xuICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICBjb2xvcjogJyNlZWUnLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjNjY2J1xuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0b3JQb3NpdGlvbjogJ2F1dG8nLFxuICAgIHNlbGVjdG9ySXRlbUdhcDogNyxcbiAgICBzZWxlY3RvckJ1dHRvbkdhcDogMTAsXG4gICAgdG9vbHRpcDoge1xuICAgICAgc2hvdzogZmFsc2VcbiAgICB9XG4gIH07XG4gIHJldHVybiBMZWdlbmRNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBMZWdlbmRNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCB7IGNyZWF0ZVN5bWJvbCB9IGZyb20gJy4uLy4uL3V0aWwvc3ltYm9sJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCB7IGVuYWJsZUhvdmVyRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcyc7XG5pbXBvcnQgeyBzZXRMYWJlbFN0eWxlLCBjcmVhdGVUZXh0U3R5bGUgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlJztcbmltcG9ydCB7IG1ha2VCYWNrZ3JvdW5kIH0gZnJvbSAnLi4vaGVscGVyL2xpc3RDb21wb25lbnQnO1xuaW1wb3J0ICogYXMgbGF5b3V0VXRpbCBmcm9tICcuLi8uLi91dGlsL2xheW91dCc7XG5pbXBvcnQgQ29tcG9uZW50VmlldyBmcm9tICcuLi8uLi92aWV3L0NvbXBvbmVudCc7XG5pbXBvcnQgeyBwYXJzZSwgc3RyaW5naWZ5IH0gZnJvbSAnenJlbmRlci9saWIvdG9vbC9jb2xvcic7XG52YXIgY3VycnkgPSB6clV0aWwuY3Vycnk7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIEdyb3VwID0gZ3JhcGhpYy5Hcm91cDtcblxudmFyIExlZ2VuZFZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTGVnZW5kVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBMZWdlbmRWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IExlZ2VuZFZpZXcudHlwZTtcbiAgICBfdGhpcy5uZXdsaW5lRGlzYWJsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBMZWdlbmRWaWV3LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2NvbnRlbnRHcm91cCA9IG5ldyBHcm91cCgpKTtcbiAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLl9zZWxlY3Rvckdyb3VwID0gbmV3IEdyb3VwKCkpO1xuICAgIHRoaXMuX2lzRmlyc3RSZW5kZXIgPSB0cnVlO1xuICB9O1xuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXG4gIExlZ2VuZFZpZXcucHJvdG90eXBlLmdldENvbnRlbnRHcm91cCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudEdyb3VwO1xuICB9O1xuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXG4gIExlZ2VuZFZpZXcucHJvdG90eXBlLmdldFNlbGVjdG9yR3JvdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdG9yR3JvdXA7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBMZWdlbmRWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAobGVnZW5kTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBpc0ZpcnN0UmVuZGVyID0gdGhpcy5faXNGaXJzdFJlbmRlcjtcbiAgICB0aGlzLl9pc0ZpcnN0UmVuZGVyID0gZmFsc2U7XG4gICAgdGhpcy5yZXNldElubmVyKCk7XG5cbiAgICBpZiAoIWxlZ2VuZE1vZGVsLmdldCgnc2hvdycsIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGl0ZW1BbGlnbiA9IGxlZ2VuZE1vZGVsLmdldCgnYWxpZ24nKTtcbiAgICB2YXIgb3JpZW50ID0gbGVnZW5kTW9kZWwuZ2V0KCdvcmllbnQnKTtcblxuICAgIGlmICghaXRlbUFsaWduIHx8IGl0ZW1BbGlnbiA9PT0gJ2F1dG8nKSB7XG4gICAgICBpdGVtQWxpZ24gPSBsZWdlbmRNb2RlbC5nZXQoJ2xlZnQnKSA9PT0gJ3JpZ2h0JyAmJiBvcmllbnQgPT09ICd2ZXJ0aWNhbCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIH0gLy8gc2VsZWN0b3IgaGFzIGJlZW4gbm9ybWFsaXplZCB0byBhbiBhcnJheSBpbiBtb2RlbFxuXG5cbiAgICB2YXIgc2VsZWN0b3IgPSBsZWdlbmRNb2RlbC5nZXQoJ3NlbGVjdG9yJywgdHJ1ZSk7XG4gICAgdmFyIHNlbGVjdG9yUG9zaXRpb24gPSBsZWdlbmRNb2RlbC5nZXQoJ3NlbGVjdG9yUG9zaXRpb24nLCB0cnVlKTtcblxuICAgIGlmIChzZWxlY3RvciAmJiAoIXNlbGVjdG9yUG9zaXRpb24gfHwgc2VsZWN0b3JQb3NpdGlvbiA9PT0gJ2F1dG8nKSkge1xuICAgICAgc2VsZWN0b3JQb3NpdGlvbiA9IG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gJ2VuZCcgOiAnc3RhcnQnO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVySW5uZXIoaXRlbUFsaWduLCBsZWdlbmRNb2RlbCwgZWNNb2RlbCwgYXBpLCBzZWxlY3Rvciwgb3JpZW50LCBzZWxlY3RvclBvc2l0aW9uKTsgLy8gUGVyZm9ybSBsYXlvdXQuXG5cbiAgICB2YXIgcG9zaXRpb25JbmZvID0gbGVnZW5kTW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCk7XG4gICAgdmFyIHZpZXdwb3J0U2l6ZSA9IHtcbiAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgfTtcbiAgICB2YXIgcGFkZGluZyA9IGxlZ2VuZE1vZGVsLmdldCgncGFkZGluZycpO1xuICAgIHZhciBtYXhTaXplID0gbGF5b3V0VXRpbC5nZXRMYXlvdXRSZWN0KHBvc2l0aW9uSW5mbywgdmlld3BvcnRTaXplLCBwYWRkaW5nKTtcbiAgICB2YXIgbWFpblJlY3QgPSB0aGlzLmxheW91dElubmVyKGxlZ2VuZE1vZGVsLCBpdGVtQWxpZ24sIG1heFNpemUsIGlzRmlyc3RSZW5kZXIsIHNlbGVjdG9yLCBzZWxlY3RvclBvc2l0aW9uKTsgLy8gUGxhY2UgbWFpbkdyb3VwLCBiYXNlZCBvbiB0aGUgY2FsY3VsYXRlZCBgbWFpblJlY3RgLlxuXG4gICAgdmFyIGxheW91dFJlY3QgPSBsYXlvdXRVdGlsLmdldExheW91dFJlY3QoenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgIHdpZHRoOiBtYWluUmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogbWFpblJlY3QuaGVpZ2h0XG4gICAgfSwgcG9zaXRpb25JbmZvKSwgdmlld3BvcnRTaXplLCBwYWRkaW5nKTtcbiAgICB0aGlzLmdyb3VwLnggPSBsYXlvdXRSZWN0LnggLSBtYWluUmVjdC54O1xuICAgIHRoaXMuZ3JvdXAueSA9IGxheW91dFJlY3QueSAtIG1haW5SZWN0Lnk7XG4gICAgdGhpcy5ncm91cC5tYXJrUmVkcmF3KCk7IC8vIFJlbmRlciBiYWNrZ3JvdW5kIGFmdGVyIGdyb3VwIGlzIGxheW91dC5cblxuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2JhY2tncm91bmRFbCA9IG1ha2VCYWNrZ3JvdW5kKG1haW5SZWN0LCBsZWdlbmRNb2RlbCkpO1xuICB9O1xuXG4gIExlZ2VuZFZpZXcucHJvdG90eXBlLnJlc2V0SW5uZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5nZXRDb250ZW50R3JvdXAoKS5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kRWwgJiYgdGhpcy5ncm91cC5yZW1vdmUodGhpcy5fYmFja2dyb3VuZEVsKTtcbiAgICB0aGlzLmdldFNlbGVjdG9yR3JvdXAoKS5yZW1vdmVBbGwoKTtcbiAgfTtcblxuICBMZWdlbmRWaWV3LnByb3RvdHlwZS5yZW5kZXJJbm5lciA9IGZ1bmN0aW9uIChpdGVtQWxpZ24sIGxlZ2VuZE1vZGVsLCBlY01vZGVsLCBhcGksIHNlbGVjdG9yLCBvcmllbnQsIHNlbGVjdG9yUG9zaXRpb24pIHtcbiAgICB2YXIgY29udGVudEdyb3VwID0gdGhpcy5nZXRDb250ZW50R3JvdXAoKTtcbiAgICB2YXIgbGVnZW5kRHJhd25NYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICAgIHZhciBzZWxlY3RNb2RlID0gbGVnZW5kTW9kZWwuZ2V0KCdzZWxlY3RlZE1vZGUnKTtcbiAgICB2YXIgZXhjbHVkZVNlcmllc0lkID0gW107XG4gICAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgIXNlcmllc01vZGVsLmdldCgnbGVnZW5kSG92ZXJMaW5rJykgJiYgZXhjbHVkZVNlcmllc0lkLnB1c2goc2VyaWVzTW9kZWwuaWQpO1xuICAgIH0pO1xuICAgIGVhY2gobGVnZW5kTW9kZWwuZ2V0RGF0YSgpLCBmdW5jdGlvbiAoaXRlbU1vZGVsLCBkYXRhSW5kZXgpIHtcbiAgICAgIHZhciBuYW1lID0gaXRlbU1vZGVsLmdldCgnbmFtZScpOyAvLyBVc2UgZW1wdHkgc3RyaW5nIG9yIFxcbiBhcyBhIG5ld2xpbmUgc3RyaW5nXG5cbiAgICAgIGlmICghdGhpcy5uZXdsaW5lRGlzYWJsZWQgJiYgKG5hbWUgPT09ICcnIHx8IG5hbWUgPT09ICdcXG4nKSkge1xuICAgICAgICB2YXIgZyA9IG5ldyBHcm91cCgpOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgICAgZy5uZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgY29udGVudEdyb3VwLmFkZChnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBSZXByZXNlbnRpdGl2ZSBzZXJpZXMuXG5cblxuICAgICAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeU5hbWUobmFtZSlbMF07XG5cbiAgICAgIGlmIChsZWdlbmREcmF3bk1hcC5nZXQobmFtZSkpIHtcbiAgICAgICAgLy8gSGF2ZSBiZWVuIGRyYXdlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIExlZ2VuZCB0byBjb250cm9sIHNlcmllcy5cblxuXG4gICAgICBpZiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgIHZhciBzdHlsZSA9IGRhdGEuZ2V0VmlzdWFsKCdzdHlsZScpO1xuICAgICAgICB2YXIgY29sb3IgPSBzdHlsZVtkYXRhLmdldFZpc3VhbCgnZHJhd1R5cGUnKV0gfHwgc3R5bGUuZmlsbDtcbiAgICAgICAgdmFyIGJvcmRlckNvbG9yID0gc3R5bGUuc3Ryb2tlO1xuICAgICAgICB2YXIgZGVjYWwgPSBzdHlsZS5kZWNhbDsgLy8gVXNpbmcgcmVjdCBzeW1ib2wgZGVmYXVsdGx5XG5cbiAgICAgICAgdmFyIGxlZ2VuZFN5bWJvbFR5cGUgPSBkYXRhLmdldFZpc3VhbCgnbGVnZW5kU3ltYm9sJykgfHwgJ3JvdW5kUmVjdCc7XG4gICAgICAgIHZhciBzeW1ib2xUeXBlID0gZGF0YS5nZXRWaXN1YWwoJ3N5bWJvbCcpO1xuXG4gICAgICAgIHZhciBpdGVtR3JvdXAgPSB0aGlzLl9jcmVhdGVJdGVtKG5hbWUsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBsZWdlbmRNb2RlbCwgbGVnZW5kU3ltYm9sVHlwZSwgc3ltYm9sVHlwZSwgaXRlbUFsaWduLCBjb2xvciwgYm9yZGVyQ29sb3IsIGRlY2FsLCBzZWxlY3RNb2RlKTtcblxuICAgICAgICBpdGVtR3JvdXAub24oJ2NsaWNrJywgY3VycnkoZGlzcGF0Y2hTZWxlY3RBY3Rpb24sIG5hbWUsIG51bGwsIGFwaSwgZXhjbHVkZVNlcmllc0lkKSkub24oJ21vdXNlb3ZlcicsIGN1cnJ5KGRpc3BhdGNoSGlnaGxpZ2h0QWN0aW9uLCBzZXJpZXNNb2RlbC5uYW1lLCBudWxsLCBhcGksIGV4Y2x1ZGVTZXJpZXNJZCkpLm9uKCdtb3VzZW91dCcsIGN1cnJ5KGRpc3BhdGNoRG93bnBsYXlBY3Rpb24sIHNlcmllc01vZGVsLm5hbWUsIG51bGwsIGFwaSwgZXhjbHVkZVNlcmllc0lkKSk7XG4gICAgICAgIGxlZ2VuZERyYXduTWFwLnNldChuYW1lLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExlZ2VuZCB0byBjb250cm9sIGRhdGEuIEluIHBpZSBhbmQgZnVubmVsLlxuICAgICAgICBlY01vZGVsLmVhY2hSYXdTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgLy8gSW4gY2FzZSBtdWx0aXBsZSBzZXJpZXMgaGFzIHNhbWUgZGF0YSBuYW1lXG4gICAgICAgICAgaWYgKGxlZ2VuZERyYXduTWFwLmdldChuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZXJpZXNNb2RlbC5sZWdlbmRWaXN1YWxQcm92aWRlcikge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gc2VyaWVzTW9kZWwubGVnZW5kVmlzdWFsUHJvdmlkZXI7XG5cbiAgICAgICAgICAgIGlmICghcHJvdmlkZXIuY29udGFpbk5hbWUobmFtZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaWR4ID0gcHJvdmlkZXIuaW5kZXhPZk5hbWUobmFtZSk7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBwcm92aWRlci5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJyk7XG4gICAgICAgICAgICB2YXIgYm9yZGVyQ29sb3IgPSBzdHlsZS5zdHJva2U7XG4gICAgICAgICAgICB2YXIgZGVjYWwgPSBzdHlsZS5kZWNhbDtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IHN0eWxlLmZpbGw7XG4gICAgICAgICAgICB2YXIgY29sb3JBcnIgPSBwYXJzZShzdHlsZS5maWxsKTsgLy8gQ29sb3IgbWF5IGJlIHNldCB0byB0cmFuc3BhcmVudCBpbiB2aXN1YWxNYXAgd2hlbiBkYXRhIGlzIG91dCBvZiByYW5nZS5cbiAgICAgICAgICAgIC8vIERvIG5vdCBzaG93IG5vdGhpbmcuXG5cbiAgICAgICAgICAgIGlmIChjb2xvckFyciAmJiBjb2xvckFyclszXSA9PT0gMCkge1xuICAgICAgICAgICAgICBjb2xvckFyclszXSA9IDAuMjsgLy8gVE9ETyBjb2xvciBpcyBzZXQgdG8gMCwgMCwgMCwgMC4gU2hvdWxkIHNob3cgY29ycmVjdCBSR0JBXG5cbiAgICAgICAgICAgICAgY29sb3IgPSBzdHJpbmdpZnkoY29sb3JBcnIsICdyZ2JhJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsZWdlbmRTeW1ib2xUeXBlID0gJ3JvdW5kUmVjdCc7XG5cbiAgICAgICAgICAgIHZhciBpdGVtR3JvdXAgPSB0aGlzLl9jcmVhdGVJdGVtKG5hbWUsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBsZWdlbmRNb2RlbCwgbGVnZW5kU3ltYm9sVHlwZSwgbnVsbCwgaXRlbUFsaWduLCBjb2xvciwgYm9yZGVyQ29sb3IsIGRlY2FsLCBzZWxlY3RNb2RlKTsgLy8gRklYTUU6IGNvbnNpZGVyIGRpZmZlcmVudCBzZXJpZXMgaGFzIGl0ZW1zIHdpdGggdGhlIHNhbWUgbmFtZS5cblxuXG4gICAgICAgICAgICBpdGVtR3JvdXAub24oJ2NsaWNrJywgY3VycnkoZGlzcGF0Y2hTZWxlY3RBY3Rpb24sIG51bGwsIG5hbWUsIGFwaSwgZXhjbHVkZVNlcmllc0lkKSkgLy8gU2hvdWxkIG5vdCBzcGVjaWZ5IHRoZSBzZXJpZXMgbmFtZSwgY29uc2lkZXIgbGVnZW5kIGNvbnRyb2xzXG4gICAgICAgICAgICAvLyBtb3JlIHRoYW4gb25lIHBpZSBzZXJpZXMuXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGN1cnJ5KGRpc3BhdGNoSGlnaGxpZ2h0QWN0aW9uLCBudWxsLCBuYW1lLCBhcGksIGV4Y2x1ZGVTZXJpZXNJZCkpLm9uKCdtb3VzZW91dCcsIGN1cnJ5KGRpc3BhdGNoRG93bnBsYXlBY3Rpb24sIG51bGwsIG5hbWUsIGFwaSwgZXhjbHVkZVNlcmllc0lkKSk7XG4gICAgICAgICAgICBsZWdlbmREcmF3bk1hcC5zZXQobmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKCFsZWdlbmREcmF3bk1hcC5nZXQobmFtZSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArICcgc2VyaWVzIG5vdCBleGlzdHMuIExlZ2VuZCBkYXRhIHNob3VsZCBiZSBzYW1lIHdpdGggc2VyaWVzIG5hbWUgb3IgZGF0YSBuYW1lLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVNlbGVjdG9yKHNlbGVjdG9yLCBsZWdlbmRNb2RlbCwgYXBpLCBvcmllbnQsIHNlbGVjdG9yUG9zaXRpb24pO1xuICAgIH1cbiAgfTtcblxuICBMZWdlbmRWaWV3LnByb3RvdHlwZS5fY3JlYXRlU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGxlZ2VuZE1vZGVsLCBhcGksIG9yaWVudCwgc2VsZWN0b3JQb3NpdGlvbikge1xuICAgIHZhciBzZWxlY3Rvckdyb3VwID0gdGhpcy5nZXRTZWxlY3Rvckdyb3VwKCk7XG4gICAgZWFjaChzZWxlY3RvciwgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JCdXR0b24oc2VsZWN0b3JJdGVtKSB7XG4gICAgICB2YXIgdHlwZSA9IHNlbGVjdG9ySXRlbS50eXBlO1xuICAgICAgdmFyIGxhYmVsVGV4dCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICAgICAgfSxcbiAgICAgICAgb25jbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICB0eXBlOiB0eXBlID09PSAnYWxsJyA/ICdsZWdlbmRBbGxTZWxlY3QnIDogJ2xlZ2VuZEludmVyc2VTZWxlY3QnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2VsZWN0b3JHcm91cC5hZGQobGFiZWxUZXh0KTtcbiAgICAgIHZhciBsYWJlbE1vZGVsID0gbGVnZW5kTW9kZWwuZ2V0TW9kZWwoJ3NlbGVjdG9yTGFiZWwnKTtcbiAgICAgIHZhciBlbXBoYXNpc0xhYmVsTW9kZWwgPSBsZWdlbmRNb2RlbC5nZXRNb2RlbChbJ2VtcGhhc2lzJywgJ3NlbGVjdG9yTGFiZWwnXSk7XG4gICAgICBzZXRMYWJlbFN0eWxlKGxhYmVsVGV4dCwge1xuICAgICAgICBub3JtYWw6IGxhYmVsTW9kZWwsXG4gICAgICAgIGVtcGhhc2lzOiBlbXBoYXNpc0xhYmVsTW9kZWxcbiAgICAgIH0sIHtcbiAgICAgICAgZGVmYXVsdFRleHQ6IHNlbGVjdG9ySXRlbS50aXRsZVxuICAgICAgfSk7XG4gICAgICBlbmFibGVIb3ZlckVtcGhhc2lzKGxhYmVsVGV4dCk7XG4gICAgfSk7XG4gIH07XG5cbiAgTGVnZW5kVmlldy5wcm90b3R5cGUuX2NyZWF0ZUl0ZW0gPSBmdW5jdGlvbiAobmFtZSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLCBsZWdlbmRTeW1ib2xUeXBlLCBzeW1ib2xUeXBlLCBpdGVtQWxpZ24sIGNvbG9yLCBib3JkZXJDb2xvciwgZGVjYWwsIHNlbGVjdE1vZGUpIHtcbiAgICB2YXIgaXRlbVdpZHRoID0gbGVnZW5kTW9kZWwuZ2V0KCdpdGVtV2lkdGgnKTtcbiAgICB2YXIgaXRlbUhlaWdodCA9IGxlZ2VuZE1vZGVsLmdldCgnaXRlbUhlaWdodCcpO1xuICAgIHZhciBpbmFjdGl2ZUNvbG9yID0gbGVnZW5kTW9kZWwuZ2V0KCdpbmFjdGl2ZUNvbG9yJyk7XG4gICAgdmFyIGluYWN0aXZlQm9yZGVyQ29sb3IgPSBsZWdlbmRNb2RlbC5nZXQoJ2luYWN0aXZlQm9yZGVyQ29sb3InKTtcbiAgICB2YXIgc3ltYm9sS2VlcEFzcGVjdCA9IGxlZ2VuZE1vZGVsLmdldCgnc3ltYm9sS2VlcEFzcGVjdCcpO1xuICAgIHZhciBsZWdlbmRNb2RlbEl0ZW1TdHlsZSA9IGxlZ2VuZE1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKTtcbiAgICB2YXIgaXNTZWxlY3RlZCA9IGxlZ2VuZE1vZGVsLmlzU2VsZWN0ZWQobmFtZSk7XG4gICAgdmFyIGl0ZW1Hcm91cCA9IG5ldyBHcm91cCgpO1xuICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgdmFyIGl0ZW1JY29uID0gaXRlbU1vZGVsLmdldCgnaWNvbicpO1xuICAgIHZhciB0b29sdGlwTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ3Rvb2x0aXAnKTtcbiAgICB2YXIgbGVnZW5kR2xvYmFsVG9vbHRpcE1vZGVsID0gdG9vbHRpcE1vZGVsLnBhcmVudE1vZGVsOyAvLyBVc2UgdXNlciBnaXZlbiBpY29uIGZpcnN0XG5cbiAgICBsZWdlbmRTeW1ib2xUeXBlID0gaXRlbUljb24gfHwgbGVnZW5kU3ltYm9sVHlwZTtcbiAgICB2YXIgbGVnZW5kU3ltYm9sID0gY3JlYXRlU3ltYm9sKGxlZ2VuZFN5bWJvbFR5cGUsIDAsIDAsIGl0ZW1XaWR0aCwgaXRlbUhlaWdodCwgaXNTZWxlY3RlZCA/IGNvbG9yIDogaW5hY3RpdmVDb2xvciwgLy8gc3ltYm9sS2VlcEFzcGVjdCBkZWZhdWx0IHRydWUgZm9yIGxlZ2VuZFxuICAgIHN5bWJvbEtlZXBBc3BlY3QgPT0gbnVsbCA/IHRydWUgOiBzeW1ib2xLZWVwQXNwZWN0KTtcbiAgICBpdGVtR3JvdXAuYWRkKHNldFN5bWJvbFN0eWxlKGxlZ2VuZFN5bWJvbCwgbGVnZW5kU3ltYm9sVHlwZSwgbGVnZW5kTW9kZWxJdGVtU3R5bGUsIGJvcmRlckNvbG9yLCBpbmFjdGl2ZUJvcmRlckNvbG9yLCBkZWNhbCwgaXNTZWxlY3RlZCkpOyAvLyBDb21wb3NlIHN5bWJvbHNcbiAgICAvLyBQRU5ESU5HXG5cbiAgICBpZiAoIWl0ZW1JY29uICYmIHN5bWJvbFR5cGUgLy8gQXQgbGVhc3Qgc2hvdyBvbmUgc3ltYm9sLCBjYW4ndCBiZSBhbGwgbm9uZVxuICAgICYmIChzeW1ib2xUeXBlICE9PSBsZWdlbmRTeW1ib2xUeXBlIHx8IHN5bWJvbFR5cGUgPT09ICdub25lJykpIHtcbiAgICAgIHZhciBzaXplID0gaXRlbUhlaWdodCAqIDAuODtcblxuICAgICAgaWYgKHN5bWJvbFR5cGUgPT09ICdub25lJykge1xuICAgICAgICBzeW1ib2xUeXBlID0gJ2NpcmNsZSc7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWdlbmRTeW1ib2xDZW50ZXIgPSBjcmVhdGVTeW1ib2woc3ltYm9sVHlwZSwgKGl0ZW1XaWR0aCAtIHNpemUpIC8gMiwgKGl0ZW1IZWlnaHQgLSBzaXplKSAvIDIsIHNpemUsIHNpemUsIGlzU2VsZWN0ZWQgPyBjb2xvciA6IGluYWN0aXZlQ29sb3IsIC8vIHN5bWJvbEtlZXBBc3BlY3QgZGVmYXVsdCB0cnVlIGZvciBsZWdlbmRcbiAgICAgIHN5bWJvbEtlZXBBc3BlY3QgPT0gbnVsbCA/IHRydWUgOiBzeW1ib2xLZWVwQXNwZWN0KTsgLy8gUHV0IHN5bWJvbCBpbiB0aGUgY2VudGVyXG5cbiAgICAgIGl0ZW1Hcm91cC5hZGQoc2V0U3ltYm9sU3R5bGUobGVnZW5kU3ltYm9sQ2VudGVyLCBzeW1ib2xUeXBlLCBsZWdlbmRNb2RlbEl0ZW1TdHlsZSwgYm9yZGVyQ29sb3IsIGluYWN0aXZlQm9yZGVyQ29sb3IsIGRlY2FsLCBpc1NlbGVjdGVkKSk7XG4gICAgfVxuXG4gICAgdmFyIHRleHRYID0gaXRlbUFsaWduID09PSAnbGVmdCcgPyBpdGVtV2lkdGggKyA1IDogLTU7XG4gICAgdmFyIHRleHRBbGlnbiA9IGl0ZW1BbGlnbjtcbiAgICB2YXIgZm9ybWF0dGVyID0gbGVnZW5kTW9kZWwuZ2V0KCdmb3JtYXR0ZXInKTtcbiAgICB2YXIgY29udGVudCA9IG5hbWU7XG5cbiAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycgJiYgZm9ybWF0dGVyKSB7XG4gICAgICBjb250ZW50ID0gZm9ybWF0dGVyLnJlcGxhY2UoJ3tuYW1lfScsIG5hbWUgIT0gbnVsbCA/IG5hbWUgOiAnJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250ZW50ID0gZm9ybWF0dGVyKG5hbWUpO1xuICAgIH1cblxuICAgIGl0ZW1Hcm91cC5hZGQobmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICBzdHlsZTogY3JlYXRlVGV4dFN0eWxlKHRleHRTdHlsZU1vZGVsLCB7XG4gICAgICAgIHRleHQ6IGNvbnRlbnQsXG4gICAgICAgIHg6IHRleHRYLFxuICAgICAgICB5OiBpdGVtSGVpZ2h0IC8gMixcbiAgICAgICAgZmlsbDogaXNTZWxlY3RlZCA/IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpIDogaW5hY3RpdmVDb2xvcixcbiAgICAgICAgYWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICAgIH0pXG4gICAgfSkpOyAvLyBBZGQgYSBpbnZpc2libGUgcmVjdCB0byBpbmNyZWFzZSB0aGUgYXJlYSBvZiBtb3VzZSBob3ZlclxuXG4gICAgdmFyIGhpdFJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgIHNoYXBlOiBpdGVtR3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCksXG4gICAgICBpbnZpc2libGU6IHRydWVcbiAgICB9KTtcblxuICAgIGlmICh0b29sdGlwTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgIHZhciBmb3JtYXR0ZXJQYXJhbXMgPSB7XG4gICAgICAgIGNvbXBvbmVudFR5cGU6ICdsZWdlbmQnLFxuICAgICAgICBsZWdlbmRJbmRleDogbGVnZW5kTW9kZWwuY29tcG9uZW50SW5kZXgsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICR2YXJzOiBbJ25hbWUnXVxuICAgICAgfTtcbiAgICAgIGhpdFJlY3QudG9vbHRpcCA9IHpyVXRpbC5leHRlbmQoe1xuICAgICAgICBjb250ZW50OiBuYW1lLFxuICAgICAgICAvLyBEZWZhdWwgZm9ybWF0dGVyXG4gICAgICAgIGZvcm1hdHRlcjogbGVnZW5kR2xvYmFsVG9vbHRpcE1vZGVsLmdldCgnZm9ybWF0dGVyJywgdHJ1ZSkgfHwgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgIHJldHVybiBwYXJhbXMubmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0dGVyUGFyYW1zOiBmb3JtYXR0ZXJQYXJhbXNcbiAgICAgIH0sIHRvb2x0aXBNb2RlbC5vcHRpb24pO1xuICAgIH1cblxuICAgIGl0ZW1Hcm91cC5hZGQoaGl0UmVjdCk7XG4gICAgaXRlbUdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGNoaWxkLnNpbGVudCA9IHRydWU7XG4gICAgfSk7XG4gICAgaGl0UmVjdC5zaWxlbnQgPSAhc2VsZWN0TW9kZTtcbiAgICB0aGlzLmdldENvbnRlbnRHcm91cCgpLmFkZChpdGVtR3JvdXApO1xuICAgIGVuYWJsZUhvdmVyRW1waGFzaXMoaXRlbUdyb3VwKTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgaXRlbUdyb3VwLl9fbGVnZW5kRGF0YUluZGV4ID0gZGF0YUluZGV4O1xuICAgIHJldHVybiBpdGVtR3JvdXA7XG4gIH07XG5cbiAgTGVnZW5kVmlldy5wcm90b3R5cGUubGF5b3V0SW5uZXIgPSBmdW5jdGlvbiAobGVnZW5kTW9kZWwsIGl0ZW1BbGlnbiwgbWF4U2l6ZSwgaXNGaXJzdFJlbmRlciwgc2VsZWN0b3IsIHNlbGVjdG9yUG9zaXRpb24pIHtcbiAgICB2YXIgY29udGVudEdyb3VwID0gdGhpcy5nZXRDb250ZW50R3JvdXAoKTtcbiAgICB2YXIgc2VsZWN0b3JHcm91cCA9IHRoaXMuZ2V0U2VsZWN0b3JHcm91cCgpOyAvLyBQbGFjZSBpdGVtcyBpbiBjb250ZW50R3JvdXAuXG5cbiAgICBsYXlvdXRVdGlsLmJveChsZWdlbmRNb2RlbC5nZXQoJ29yaWVudCcpLCBjb250ZW50R3JvdXAsIGxlZ2VuZE1vZGVsLmdldCgnaXRlbUdhcCcpLCBtYXhTaXplLndpZHRoLCBtYXhTaXplLmhlaWdodCk7XG4gICAgdmFyIGNvbnRlbnRSZWN0ID0gY29udGVudEdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBjb250ZW50UG9zID0gWy1jb250ZW50UmVjdC54LCAtY29udGVudFJlY3QueV07XG4gICAgc2VsZWN0b3JHcm91cC5tYXJrUmVkcmF3KCk7XG4gICAgY29udGVudEdyb3VwLm1hcmtSZWRyYXcoKTtcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgLy8gUGxhY2UgYnV0dG9ucyBpbiBzZWxlY3Rvckdyb3VwXG4gICAgICBsYXlvdXRVdGlsLmJveCggLy8gQnV0dG9ucyBpbiBzZWxlY3Rvckdyb3VwIGFsd2F5cyBsYXlvdXQgaG9yaXpvbnRhbGx5XG4gICAgICAnaG9yaXpvbnRhbCcsIHNlbGVjdG9yR3JvdXAsIGxlZ2VuZE1vZGVsLmdldCgnc2VsZWN0b3JJdGVtR2FwJywgdHJ1ZSkpO1xuICAgICAgdmFyIHNlbGVjdG9yUmVjdCA9IHNlbGVjdG9yR3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICB2YXIgc2VsZWN0b3JQb3MgPSBbLXNlbGVjdG9yUmVjdC54LCAtc2VsZWN0b3JSZWN0LnldO1xuICAgICAgdmFyIHNlbGVjdG9yQnV0dG9uR2FwID0gbGVnZW5kTW9kZWwuZ2V0KCdzZWxlY3RvckJ1dHRvbkdhcCcsIHRydWUpO1xuICAgICAgdmFyIG9yaWVudElkeCA9IGxlZ2VuZE1vZGVsLmdldE9yaWVudCgpLmluZGV4O1xuICAgICAgdmFyIHdoID0gb3JpZW50SWR4ID09PSAwID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgdmFyIGh3ID0gb3JpZW50SWR4ID09PSAwID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgdmFyIHl4ID0gb3JpZW50SWR4ID09PSAwID8gJ3knIDogJ3gnO1xuXG4gICAgICBpZiAoc2VsZWN0b3JQb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgc2VsZWN0b3JQb3Nbb3JpZW50SWR4XSArPSBjb250ZW50UmVjdFt3aF0gKyBzZWxlY3RvckJ1dHRvbkdhcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnRQb3Nbb3JpZW50SWR4XSArPSBzZWxlY3RvclJlY3Rbd2hdICsgc2VsZWN0b3JCdXR0b25HYXA7XG4gICAgICB9IC8vQWx3YXlzIGFsaWduIHNlbGVjdG9yIHRvIGNvbnRlbnQgYXMgJ21pZGRsZSdcblxuXG4gICAgICBzZWxlY3RvclBvc1sxIC0gb3JpZW50SWR4XSArPSBjb250ZW50UmVjdFtod10gLyAyIC0gc2VsZWN0b3JSZWN0W2h3XSAvIDI7XG4gICAgICBzZWxlY3Rvckdyb3VwLnggPSBzZWxlY3RvclBvc1swXTtcbiAgICAgIHNlbGVjdG9yR3JvdXAueSA9IHNlbGVjdG9yUG9zWzFdO1xuICAgICAgY29udGVudEdyb3VwLnggPSBjb250ZW50UG9zWzBdO1xuICAgICAgY29udGVudEdyb3VwLnkgPSBjb250ZW50UG9zWzFdO1xuICAgICAgdmFyIG1haW5SZWN0ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgbWFpblJlY3Rbd2hdID0gY29udGVudFJlY3Rbd2hdICsgc2VsZWN0b3JCdXR0b25HYXAgKyBzZWxlY3RvclJlY3Rbd2hdO1xuICAgICAgbWFpblJlY3RbaHddID0gTWF0aC5tYXgoY29udGVudFJlY3RbaHddLCBzZWxlY3RvclJlY3RbaHddKTtcbiAgICAgIG1haW5SZWN0W3l4XSA9IE1hdGgubWluKDAsIHNlbGVjdG9yUmVjdFt5eF0gKyBzZWxlY3RvclBvc1sxIC0gb3JpZW50SWR4XSk7XG4gICAgICByZXR1cm4gbWFpblJlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnRHcm91cC54ID0gY29udGVudFBvc1swXTtcbiAgICAgIGNvbnRlbnRHcm91cC55ID0gY29udGVudFBvc1sxXTtcbiAgICAgIHJldHVybiB0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblxuICBMZWdlbmRWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5nZXRDb250ZW50R3JvdXAoKS5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLl9pc0ZpcnN0UmVuZGVyID0gdHJ1ZTtcbiAgfTtcblxuICBMZWdlbmRWaWV3LnR5cGUgPSAnbGVnZW5kLnBsYWluJztcbiAgcmV0dXJuIExlZ2VuZFZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuXG5mdW5jdGlvbiBzZXRTeW1ib2xTdHlsZShzeW1ib2wsIHN5bWJvbFR5cGUsIGxlZ2VuZE1vZGVsSXRlbVN0eWxlLCBib3JkZXJDb2xvciwgaW5hY3RpdmVCb3JkZXJDb2xvciwgZGVjYWwsIGlzU2VsZWN0ZWQpIHtcbiAgdmFyIGl0ZW1TdHlsZTtcblxuICBpZiAoc3ltYm9sVHlwZSAhPT0gJ2xpbmUnICYmIHN5bWJvbFR5cGUuaW5kZXhPZignZW1wdHknKSA8IDApIHtcbiAgICBpdGVtU3R5bGUgPSBsZWdlbmRNb2RlbEl0ZW1TdHlsZS5nZXRJdGVtU3R5bGUoKTtcbiAgICBzeW1ib2wuc3R5bGUuc3Ryb2tlID0gYm9yZGVyQ29sb3I7XG4gICAgc3ltYm9sLnN0eWxlLmRlY2FsID0gZGVjYWw7XG5cbiAgICBpZiAoIWlzU2VsZWN0ZWQpIHtcbiAgICAgIGl0ZW1TdHlsZS5zdHJva2UgPSBpbmFjdGl2ZUJvcmRlckNvbG9yO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpdGVtU3R5bGUgPSBsZWdlbmRNb2RlbEl0ZW1TdHlsZS5nZXRJdGVtU3R5bGUoWydib3JkZXJXaWR0aCcsICdib3JkZXJDb2xvciddKTtcbiAgfVxuXG4gIHN5bWJvbC5zZXRTdHlsZShpdGVtU3R5bGUpO1xuICByZXR1cm4gc3ltYm9sO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFNlbGVjdEFjdGlvbihzZXJpZXNOYW1lLCBkYXRhTmFtZSwgYXBpLCBleGNsdWRlU2VyaWVzSWQpIHtcbiAgLy8gZG93bnBsYXkgYmVmb3JlIHVuc2VsZWN0XG4gIGRpc3BhdGNoRG93bnBsYXlBY3Rpb24oc2VyaWVzTmFtZSwgZGF0YU5hbWUsIGFwaSwgZXhjbHVkZVNlcmllc0lkKTtcbiAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICB0eXBlOiAnbGVnZW5kVG9nZ2xlU2VsZWN0JyxcbiAgICBuYW1lOiBzZXJpZXNOYW1lICE9IG51bGwgPyBzZXJpZXNOYW1lIDogZGF0YU5hbWVcbiAgfSk7IC8vIGhpZ2hsaWdodCBhZnRlciBzZWxlY3RcbiAgLy8gVE9ETyBoaWdsaWdodCBpbW1lZGlhdGVseSBtYXkgY2F1c2UgYW5pbWF0aW9uIGxvc3MuXG5cbiAgZGlzcGF0Y2hIaWdobGlnaHRBY3Rpb24oc2VyaWVzTmFtZSwgZGF0YU5hbWUsIGFwaSwgZXhjbHVkZVNlcmllc0lkKTtcbn1cblxuZnVuY3Rpb24gaXNVc2VIb3ZlckxheWVyKGFwaSkge1xuICB2YXIgbGlzdCA9IGFwaS5nZXRacigpLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTtcbiAgdmFyIGVtcGhhc2lzU3RhdGU7XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuXG4gIHdoaWxlIChpIDwgbGVuICYmICEoZW1waGFzaXNTdGF0ZSA9IGxpc3RbaV0uc3RhdGVzLmVtcGhhc2lzKSkge1xuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiBlbXBoYXNpc1N0YXRlICYmIGVtcGhhc2lzU3RhdGUuaG92ZXJMYXllcjtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hIaWdobGlnaHRBY3Rpb24oc2VyaWVzTmFtZSwgZGF0YU5hbWUsIGFwaSwgZXhjbHVkZVNlcmllc0lkKSB7XG4gIC8vIElmIGVsZW1lbnQgaG92ZXIgd2lsbCBtb3ZlIHRvIGEgaG92ZXJMYXllci5cbiAgaWYgKCFpc1VzZUhvdmVyTGF5ZXIoYXBpKSkge1xuICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnaGlnaGxpZ2h0JyxcbiAgICAgIHNlcmllc05hbWU6IHNlcmllc05hbWUsXG4gICAgICBuYW1lOiBkYXRhTmFtZSxcbiAgICAgIGV4Y2x1ZGVTZXJpZXNJZDogZXhjbHVkZVNlcmllc0lkXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hEb3ducGxheUFjdGlvbihzZXJpZXNOYW1lLCBkYXRhTmFtZSwgYXBpLCBleGNsdWRlU2VyaWVzSWQpIHtcbiAgLy8gSWYgZWxlbWVudCBob3ZlciB3aWxsIG1vdmUgdG8gYSBob3ZlckxheWVyLlxuICBpZiAoIWlzVXNlSG92ZXJMYXllcihhcGkpKSB7XG4gICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdkb3ducGxheScsXG4gICAgICBzZXJpZXNOYW1lOiBzZXJpZXNOYW1lLFxuICAgICAgbmFtZTogZGF0YU5hbWUsXG4gICAgICBleGNsdWRlU2VyaWVzSWQ6IGV4Y2x1ZGVTZXJpZXNJZFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExlZ2VuZFZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IExlZ2VuZE1vZGVsIGZyb20gJy4vTGVnZW5kTW9kZWwnO1xuaW1wb3J0IHsgbWVyZ2VMYXlvdXRQYXJhbSwgZ2V0TGF5b3V0UGFyYW1zIH0gZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQnO1xuaW1wb3J0IHsgaW5oZXJpdERlZmF1bHRPcHRpb24gfSBmcm9tICcuLi8uLi91dGlsL2NvbXBvbmVudCc7XG5cbnZhciBTY3JvbGxhYmxlTGVnZW5kTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFNjcm9sbGFibGVMZWdlbmRNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBTY3JvbGxhYmxlTGVnZW5kTW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxEYXRhSW5kZXhcbiAgICovXG5cblxuICBTY3JvbGxhYmxlTGVnZW5kTW9kZWwucHJvdG90eXBlLnNldFNjcm9sbERhdGFJbmRleCA9IGZ1bmN0aW9uIChzY3JvbGxEYXRhSW5kZXgpIHtcbiAgICB0aGlzLm9wdGlvbi5zY3JvbGxEYXRhSW5kZXggPSBzY3JvbGxEYXRhSW5kZXg7XG4gIH07XG5cbiAgU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpIHtcbiAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGdldExheW91dFBhcmFtcyhvcHRpb24pO1xuXG4gICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgb3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCk7XG5cbiAgICBtZXJnZUFuZE5vcm1hbGl6ZUxheW91dFBhcmFtcyh0aGlzLCBvcHRpb24sIGlucHV0UG9zaXRpb25QYXJhbXMpO1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsLnByb3RvdHlwZS5tZXJnZU9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLm1lcmdlT3B0aW9uLmNhbGwodGhpcywgb3B0aW9uLCBlY01vZGVsKTtcblxuICAgIG1lcmdlQW5kTm9ybWFsaXplTGF5b3V0UGFyYW1zKHRoaXMsIHRoaXMub3B0aW9uLCBvcHRpb24pO1xuICB9O1xuXG4gIFNjcm9sbGFibGVMZWdlbmRNb2RlbC50eXBlID0gJ2xlZ2VuZC5zY3JvbGwnO1xuICBTY3JvbGxhYmxlTGVnZW5kTW9kZWwuZGVmYXVsdE9wdGlvbiA9IGluaGVyaXREZWZhdWx0T3B0aW9uKExlZ2VuZE1vZGVsLmRlZmF1bHRPcHRpb24sIHtcbiAgICBzY3JvbGxEYXRhSW5kZXg6IDAsXG4gICAgcGFnZUJ1dHRvbkl0ZW1HYXA6IDUsXG4gICAgcGFnZUJ1dHRvbkdhcDogbnVsbCxcbiAgICBwYWdlQnV0dG9uUG9zaXRpb246ICdlbmQnLFxuICAgIHBhZ2VGb3JtYXR0ZXI6ICd7Y3VycmVudH0ve3RvdGFsfScsXG4gICAgcGFnZUljb25zOiB7XG4gICAgICBob3Jpem9udGFsOiBbJ00wLDBMMTIsLTEwTDEyLDEweicsICdNMCwwTC0xMiwtMTBMLTEyLDEweiddLFxuICAgICAgdmVydGljYWw6IFsnTTAsMEwyMCwwTDEwLC0yMHonLCAnTTAsMEwyMCwwTDEwLDIweiddXG4gICAgfSxcbiAgICBwYWdlSWNvbkNvbG9yOiAnIzJmNDU1NCcsXG4gICAgcGFnZUljb25JbmFjdGl2ZUNvbG9yOiAnI2FhYScsXG4gICAgcGFnZUljb25TaXplOiAxNSxcbiAgICBwYWdlVGV4dFN0eWxlOiB7XG4gICAgICBjb2xvcjogJyMzMzMnXG4gICAgfSxcbiAgICBhbmltYXRpb25EdXJhdGlvblVwZGF0ZTogODAwXG4gIH0pO1xuICByZXR1cm4gU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsO1xufShMZWdlbmRNb2RlbCk7XG5cbjsgLy8gRG8gbm90IGBpZ25vcmVTaXplYCB0byBlbmFibGUgc2V0dGluZyB7bGVmdDogMTAsIHJpZ2h0OiAxMH0uXG5cbmZ1bmN0aW9uIG1lcmdlQW5kTm9ybWFsaXplTGF5b3V0UGFyYW1zKGxlZ2VuZE1vZGVsLCB0YXJnZXQsIHJhdykge1xuICB2YXIgb3JpZW50ID0gbGVnZW5kTW9kZWwuZ2V0T3JpZW50KCk7XG4gIHZhciBpZ25vcmVTaXplID0gWzEsIDFdO1xuICBpZ25vcmVTaXplW29yaWVudC5pbmRleF0gPSAwO1xuICBtZXJnZUxheW91dFBhcmFtKHRhcmdldCwgcmF3LCB7XG4gICAgdHlwZTogJ2JveCcsXG4gICAgaWdub3JlU2l6ZTogISFpZ25vcmVTaXplXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxhYmxlTGVnZW5kTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuLyoqXG4gKiBTZXBhcmF0ZSBsZWdlbmQgYW5kIHNjcm9sbGFibGUgbGVnZW5kIHRvIHJlZHVjZSBwYWNrYWdlIHNpemUuXG4gKi9cblxuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgKiBhcyBsYXlvdXRVdGlsIGZyb20gJy4uLy4uL3V0aWwvbGF5b3V0JztcbmltcG9ydCBMZWdlbmRWaWV3IGZyb20gJy4vTGVnZW5kVmlldyc7XG52YXIgR3JvdXAgPSBncmFwaGljLkdyb3VwO1xudmFyIFdIID0gWyd3aWR0aCcsICdoZWlnaHQnXTtcbnZhciBYWSA9IFsneCcsICd5J107XG5cbnZhciBTY3JvbGxhYmxlTGVnZW5kVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTY3JvbGxhYmxlTGVnZW5kVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTY3JvbGxhYmxlTGVnZW5kVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBTY3JvbGxhYmxlTGVnZW5kVmlldy50eXBlO1xuICAgIF90aGlzLm5ld2xpbmVEaXNhYmxlZCA9IHRydWU7XG4gICAgX3RoaXMuX2N1cnJlbnRJbmRleCA9IDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLl9jb250YWluZXJHcm91cCA9IG5ldyBHcm91cCgpKTtcblxuICAgIHRoaXMuX2NvbnRhaW5lckdyb3VwLmFkZCh0aGlzLmdldENvbnRlbnRHcm91cCgpKTtcblxuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2NvbnRyb2xsZXJHcm91cCA9IG5ldyBHcm91cCgpKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIFNjcm9sbGFibGVMZWdlbmRWaWV3LnByb3RvdHlwZS5yZXNldElubmVyID0gZnVuY3Rpb24gKCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUucmVzZXRJbm5lci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fY29udHJvbGxlckdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgdGhpcy5fY29udGFpbmVyR3JvdXAucmVtb3ZlQ2xpcFBhdGgoKTtcblxuICAgIHRoaXMuX2NvbnRhaW5lckdyb3VwLl9fcmVjdFNpemUgPSBudWxsO1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcucHJvdG90eXBlLnJlbmRlcklubmVyID0gZnVuY3Rpb24gKGl0ZW1BbGlnbiwgbGVnZW5kTW9kZWwsIGVjTW9kZWwsIGFwaSwgc2VsZWN0b3IsIG9yaWVudCwgc2VsZWN0b3JQb3NpdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpczsgLy8gUmVuZGVyIGNvbnRlbnQgaXRlbXMuXG5cbiAgICBfc3VwZXIucHJvdG90eXBlLnJlbmRlcklubmVyLmNhbGwodGhpcywgaXRlbUFsaWduLCBsZWdlbmRNb2RlbCwgZWNNb2RlbCwgYXBpLCBzZWxlY3Rvciwgb3JpZW50LCBzZWxlY3RvclBvc2l0aW9uKTtcblxuICAgIHZhciBjb250cm9sbGVyR3JvdXAgPSB0aGlzLl9jb250cm9sbGVyR3JvdXA7IC8vIEZJWE1FOiBzdXBwb3J0IGJlICdhdXRvJyBhZGFwdCB0byBzaXplIG51bWJlciB0ZXh0IGxlbmd0aCxcbiAgICAvLyBlLmcuLCAnMy8xMjM0NScgc2hvdWxkIG5vdCBvdmVybGFwIHdpdGggdGhlIGNvbnRyb2wgYXJyb3cgYnV0dG9uLlxuXG4gICAgdmFyIHBhZ2VJY29uU2l6ZSA9IGxlZ2VuZE1vZGVsLmdldCgncGFnZUljb25TaXplJywgdHJ1ZSk7XG4gICAgdmFyIHBhZ2VJY29uU2l6ZUFyciA9IHpyVXRpbC5pc0FycmF5KHBhZ2VJY29uU2l6ZSkgPyBwYWdlSWNvblNpemUgOiBbcGFnZUljb25TaXplLCBwYWdlSWNvblNpemVdO1xuICAgIGNyZWF0ZVBhZ2VCdXR0b24oJ3BhZ2VQcmV2JywgMCk7XG4gICAgdmFyIHBhZ2VUZXh0U3R5bGVNb2RlbCA9IGxlZ2VuZE1vZGVsLmdldE1vZGVsKCdwYWdlVGV4dFN0eWxlJyk7XG4gICAgY29udHJvbGxlckdyb3VwLmFkZChuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIG5hbWU6ICdwYWdlVGV4dCcsXG4gICAgICBzdHlsZToge1xuICAgICAgICAvLyBQbGFjZWhvbGRlciB0byBjYWxjdWxhdGUgYSBwcm9wZXIgbGF5b3V0LlxuICAgICAgICB0ZXh0OiAneHgveHgnLFxuICAgICAgICBmaWxsOiBwYWdlVGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCksXG4gICAgICAgIGZvbnQ6IHBhZ2VUZXh0U3R5bGVNb2RlbC5nZXRGb250KCksXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICBhbGlnbjogJ2NlbnRlcidcbiAgICAgIH0sXG4gICAgICBzaWxlbnQ6IHRydWVcbiAgICB9KSk7XG4gICAgY3JlYXRlUGFnZUJ1dHRvbigncGFnZU5leHQnLCAxKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZ2VCdXR0b24obmFtZSwgaWNvbklkeCkge1xuICAgICAgdmFyIHBhZ2VEYXRhSW5kZXhOYW1lID0gbmFtZSArICdEYXRhSW5kZXgnO1xuICAgICAgdmFyIGljb24gPSBncmFwaGljLmNyZWF0ZUljb24obGVnZW5kTW9kZWwuZ2V0KCdwYWdlSWNvbnMnLCB0cnVlKVtsZWdlbmRNb2RlbC5nZXRPcmllbnQoKS5uYW1lXVtpY29uSWR4XSwge1xuICAgICAgICAvLyBCdXR0b25zIHdpbGwgYmUgY3JlYXRlZCBpbiBlYWNoIHJlbmRlciwgc28gd2UgZG8gbm90IG5lZWRcbiAgICAgICAgLy8gdG8gd29ycnkgYWJvdXQgYXZvaWRpbmcgdXNpbmcgbGVnZW5kTW9kZWwga2VwdCBpbiBzY29wZS5cbiAgICAgICAgb25jbGljazogenJVdGlsLmJpbmQoc2VsZi5fcGFnZUdvLCBzZWxmLCBwYWdlRGF0YUluZGV4TmFtZSwgbGVnZW5kTW9kZWwsIGFwaSlcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLXBhZ2VJY29uU2l6ZUFyclswXSAvIDIsXG4gICAgICAgIHk6IC1wYWdlSWNvblNpemVBcnJbMV0gLyAyLFxuICAgICAgICB3aWR0aDogcGFnZUljb25TaXplQXJyWzBdLFxuICAgICAgICBoZWlnaHQ6IHBhZ2VJY29uU2l6ZUFyclsxXVxuICAgICAgfSk7XG4gICAgICBpY29uLm5hbWUgPSBuYW1lO1xuICAgICAgY29udHJvbGxlckdyb3VwLmFkZChpY29uKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBTY3JvbGxhYmxlTGVnZW5kVmlldy5wcm90b3R5cGUubGF5b3V0SW5uZXIgPSBmdW5jdGlvbiAobGVnZW5kTW9kZWwsIGl0ZW1BbGlnbiwgbWF4U2l6ZSwgaXNGaXJzdFJlbmRlciwgc2VsZWN0b3IsIHNlbGVjdG9yUG9zaXRpb24pIHtcbiAgICB2YXIgc2VsZWN0b3JHcm91cCA9IHRoaXMuZ2V0U2VsZWN0b3JHcm91cCgpO1xuICAgIHZhciBvcmllbnRJZHggPSBsZWdlbmRNb2RlbC5nZXRPcmllbnQoKS5pbmRleDtcbiAgICB2YXIgd2ggPSBXSFtvcmllbnRJZHhdO1xuICAgIHZhciB4eSA9IFhZW29yaWVudElkeF07XG4gICAgdmFyIGh3ID0gV0hbMSAtIG9yaWVudElkeF07XG4gICAgdmFyIHl4ID0gWFlbMSAtIG9yaWVudElkeF07XG4gICAgc2VsZWN0b3IgJiYgbGF5b3V0VXRpbC5ib3goIC8vIEJ1dHRvbnMgaW4gc2VsZWN0b3JHcm91cCBhbHdheXMgbGF5b3V0IGhvcml6b250YWxseVxuICAgICdob3Jpem9udGFsJywgc2VsZWN0b3JHcm91cCwgbGVnZW5kTW9kZWwuZ2V0KCdzZWxlY3Rvckl0ZW1HYXAnLCB0cnVlKSk7XG4gICAgdmFyIHNlbGVjdG9yQnV0dG9uR2FwID0gbGVnZW5kTW9kZWwuZ2V0KCdzZWxlY3RvckJ1dHRvbkdhcCcsIHRydWUpO1xuICAgIHZhciBzZWxlY3RvclJlY3QgPSBzZWxlY3Rvckdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBzZWxlY3RvclBvcyA9IFstc2VsZWN0b3JSZWN0LngsIC1zZWxlY3RvclJlY3QueV07XG4gICAgdmFyIHByb2Nlc3NNYXhTaXplID0genJVdGlsLmNsb25lKG1heFNpemUpO1xuICAgIHNlbGVjdG9yICYmIChwcm9jZXNzTWF4U2l6ZVt3aF0gPSBtYXhTaXplW3doXSAtIHNlbGVjdG9yUmVjdFt3aF0gLSBzZWxlY3RvckJ1dHRvbkdhcCk7XG5cbiAgICB2YXIgbWFpblJlY3QgPSB0aGlzLl9sYXlvdXRDb250ZW50QW5kQ29udHJvbGxlcihsZWdlbmRNb2RlbCwgaXNGaXJzdFJlbmRlciwgcHJvY2Vzc01heFNpemUsIG9yaWVudElkeCwgd2gsIGh3LCB5eCwgeHkpO1xuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc2VsZWN0b3JQb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgc2VsZWN0b3JQb3Nbb3JpZW50SWR4XSArPSBtYWluUmVjdFt3aF0gKyBzZWxlY3RvckJ1dHRvbkdhcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBzZWxlY3RvclJlY3Rbd2hdICsgc2VsZWN0b3JCdXR0b25HYXA7XG4gICAgICAgIHNlbGVjdG9yUG9zW29yaWVudElkeF0gLT0gb2Zmc2V0O1xuICAgICAgICBtYWluUmVjdFt4eV0gLT0gb2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBtYWluUmVjdFt3aF0gKz0gc2VsZWN0b3JSZWN0W3doXSArIHNlbGVjdG9yQnV0dG9uR2FwO1xuICAgICAgc2VsZWN0b3JQb3NbMSAtIG9yaWVudElkeF0gKz0gbWFpblJlY3RbeXhdICsgbWFpblJlY3RbaHddIC8gMiAtIHNlbGVjdG9yUmVjdFtod10gLyAyO1xuICAgICAgbWFpblJlY3RbaHddID0gTWF0aC5tYXgobWFpblJlY3RbaHddLCBzZWxlY3RvclJlY3RbaHddKTtcbiAgICAgIG1haW5SZWN0W3l4XSA9IE1hdGgubWluKG1haW5SZWN0W3l4XSwgc2VsZWN0b3JSZWN0W3l4XSArIHNlbGVjdG9yUG9zWzEgLSBvcmllbnRJZHhdKTtcbiAgICAgIHNlbGVjdG9yR3JvdXAueCA9IHNlbGVjdG9yUG9zWzBdO1xuICAgICAgc2VsZWN0b3JHcm91cC55ID0gc2VsZWN0b3JQb3NbMV07XG4gICAgICBzZWxlY3Rvckdyb3VwLm1hcmtSZWRyYXcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFpblJlY3Q7XG4gIH07XG5cbiAgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcucHJvdG90eXBlLl9sYXlvdXRDb250ZW50QW5kQ29udHJvbGxlciA9IGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgaXNGaXJzdFJlbmRlciwgbWF4U2l6ZSwgb3JpZW50SWR4LCB3aCwgaHcsIHl4LCB4eSkge1xuICAgIHZhciBjb250ZW50R3JvdXAgPSB0aGlzLmdldENvbnRlbnRHcm91cCgpO1xuICAgIHZhciBjb250YWluZXJHcm91cCA9IHRoaXMuX2NvbnRhaW5lckdyb3VwO1xuICAgIHZhciBjb250cm9sbGVyR3JvdXAgPSB0aGlzLl9jb250cm9sbGVyR3JvdXA7IC8vIFBsYWNlIGl0ZW1zIGluIGNvbnRlbnRHcm91cC5cblxuICAgIGxheW91dFV0aWwuYm94KGxlZ2VuZE1vZGVsLmdldCgnb3JpZW50JyksIGNvbnRlbnRHcm91cCwgbGVnZW5kTW9kZWwuZ2V0KCdpdGVtR2FwJyksICFvcmllbnRJZHggPyBudWxsIDogbWF4U2l6ZS53aWR0aCwgb3JpZW50SWR4ID8gbnVsbCA6IG1heFNpemUuaGVpZ2h0KTtcbiAgICBsYXlvdXRVdGlsLmJveCggLy8gQnV0dG9ucyBpbiBjb250cm9sbGVyIGFyZSBsYXlvdXQgYWx3YXlzIGhvcml6b250YWxseS5cbiAgICAnaG9yaXpvbnRhbCcsIGNvbnRyb2xsZXJHcm91cCwgbGVnZW5kTW9kZWwuZ2V0KCdwYWdlQnV0dG9uSXRlbUdhcCcsIHRydWUpKTtcbiAgICB2YXIgY29udGVudFJlY3QgPSBjb250ZW50R3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIGNvbnRyb2xsZXJSZWN0ID0gY29udHJvbGxlckdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBzaG93Q29udHJvbGxlciA9IHRoaXMuX3Nob3dDb250cm9sbGVyID0gY29udGVudFJlY3Rbd2hdID4gbWF4U2l6ZVt3aF07IC8vIEluIGNhc2UgdGhhdCB0aGUgaW5uZXIgZWxlbWVudHMgb2YgY29udGVudEdyb3VwIGxheW91dCBkbyBub3QgYmFzZWQgb24gWzAsIDBdXG5cbiAgICB2YXIgY29udGVudFBvcyA9IFstY29udGVudFJlY3QueCwgLWNvbnRlbnRSZWN0LnldOyAvLyBSZW1haW4gY29udGVudFBvcyB3aGVuIHNjcm9sbCBhbmltYXRpb24gcGVyZnJvbWluZy5cbiAgICAvLyBJZiBmaXJzdCByZW5kZXJpbmcsIGBjb250ZW50R3JvdXAucG9zaXRpb25gIGlzIFswLCAwXSwgd2hpY2hcbiAgICAvLyBkb2VzIG5vdCBtYWtlIHNlbnNlIGFuZCBtYXkgY2F1c2UgdW5leGVwY3RlZCBhbmltYXRpb24gaWYgYWRvcHRlZC5cblxuICAgIGlmICghaXNGaXJzdFJlbmRlcikge1xuICAgICAgY29udGVudFBvc1tvcmllbnRJZHhdID0gY29udGVudEdyb3VwW3h5XTtcbiAgICB9IC8vIExheW91dCBjb250YWluZXIgZ3JvdXAgYmFzZWQgb24gMC5cblxuXG4gICAgdmFyIGNvbnRhaW5lclBvcyA9IFswLCAwXTtcbiAgICB2YXIgY29udHJvbGxlclBvcyA9IFstY29udHJvbGxlclJlY3QueCwgLWNvbnRyb2xsZXJSZWN0LnldO1xuICAgIHZhciBwYWdlQnV0dG9uR2FwID0genJVdGlsLnJldHJpZXZlMihsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VCdXR0b25HYXAnLCB0cnVlKSwgbGVnZW5kTW9kZWwuZ2V0KCdpdGVtR2FwJywgdHJ1ZSkpOyAvLyBQbGFjZSBjb250YWluZXJHcm91cCBhbmQgY29udHJvbGxlckdyb3VwIGFuZCBjb250ZW50R3JvdXAuXG5cbiAgICBpZiAoc2hvd0NvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBwYWdlQnV0dG9uUG9zaXRpb24gPSBsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VCdXR0b25Qb3NpdGlvbicsIHRydWUpOyAvLyBjb250cm9sbGVyIGlzIG9uIHRoZSByaWdodCAvIGJvdHRvbS5cblxuICAgICAgaWYgKHBhZ2VCdXR0b25Qb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgY29udHJvbGxlclBvc1tvcmllbnRJZHhdICs9IG1heFNpemVbd2hdIC0gY29udHJvbGxlclJlY3Rbd2hdO1xuICAgICAgfSAvLyBjb250cm9sbGVyIGlzIG9uIHRoZSBsZWZ0IC8gdG9wLlxuICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGFpbmVyUG9zW29yaWVudElkeF0gKz0gY29udHJvbGxlclJlY3Rbd2hdICsgcGFnZUJ1dHRvbkdhcDtcbiAgICAgICAgfVxuICAgIH0gLy8gQWx3YXlzIGFsaWduIGNvbnRyb2xsZXIgdG8gY29udGVudCBhcyAnbWlkZGxlJy5cblxuXG4gICAgY29udHJvbGxlclBvc1sxIC0gb3JpZW50SWR4XSArPSBjb250ZW50UmVjdFtod10gLyAyIC0gY29udHJvbGxlclJlY3RbaHddIC8gMjtcbiAgICBjb250ZW50R3JvdXAuc2V0UG9zaXRpb24oY29udGVudFBvcyk7XG4gICAgY29udGFpbmVyR3JvdXAuc2V0UG9zaXRpb24oY29udGFpbmVyUG9zKTtcbiAgICBjb250cm9sbGVyR3JvdXAuc2V0UG9zaXRpb24oY29udHJvbGxlclBvcyk7IC8vIENhbGN1bGF0ZSBgbWFpblJlY3RgIGFuZCBzZXQgYGNsaXBQYXRoYC5cbiAgICAvLyBtYWluUmVjdCBzaG91bGQgbm90IGJlIGNhbGN1bGF0ZWQgYnkgYHRoaXMuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KClgXG4gICAgLy8gZm9yIHNha2Ugb2YgdGhlIG92ZXJmbG93LlxuXG4gICAgdmFyIG1haW5SZWN0ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9OyAvLyBDb25zaWRlciBjb250ZW50IG1heSBiZSBvdmVyZmxvdyAoc2hvdWxkIGJlIGNsaXBwZWQpLlxuXG4gICAgbWFpblJlY3Rbd2hdID0gc2hvd0NvbnRyb2xsZXIgPyBtYXhTaXplW3doXSA6IGNvbnRlbnRSZWN0W3doXTtcbiAgICBtYWluUmVjdFtod10gPSBNYXRoLm1heChjb250ZW50UmVjdFtod10sIGNvbnRyb2xsZXJSZWN0W2h3XSk7IC8vIGBjb250YWluZXJSZWN0W3l4XSArIGNvbnRhaW5lclBvc1sxIC0gb3JpZW50SWR4XWAgaXMgMC5cblxuICAgIG1haW5SZWN0W3l4XSA9IE1hdGgubWluKDAsIGNvbnRyb2xsZXJSZWN0W3l4XSArIGNvbnRyb2xsZXJQb3NbMSAtIG9yaWVudElkeF0pO1xuICAgIGNvbnRhaW5lckdyb3VwLl9fcmVjdFNpemUgPSBtYXhTaXplW3doXTtcblxuICAgIGlmIChzaG93Q29udHJvbGxlcikge1xuICAgICAgdmFyIGNsaXBTaGFwZSA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIGNsaXBTaGFwZVt3aF0gPSBNYXRoLm1heChtYXhTaXplW3doXSAtIGNvbnRyb2xsZXJSZWN0W3doXSAtIHBhZ2VCdXR0b25HYXAsIDApO1xuICAgICAgY2xpcFNoYXBlW2h3XSA9IG1haW5SZWN0W2h3XTtcbiAgICAgIGNvbnRhaW5lckdyb3VwLnNldENsaXBQYXRoKG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgICBzaGFwZTogY2xpcFNoYXBlXG4gICAgICB9KSk7IC8vIENvbnNpZGVyIGNvbnRlbnQgbWF5IGJlIGxhcmdlciB0aGFuIGNvbnRhaW5lciwgY29udGFpbmVyIHJlY3RcbiAgICAgIC8vIGNhbiBub3QgYmUgb2J0YWluZWQgZnJvbSBgY29udGFpbmVyR3JvdXAuZ2V0Qm91bmRpbmdSZWN0KClgLlxuXG4gICAgICBjb250YWluZXJHcm91cC5fX3JlY3RTaXplID0gY2xpcFNoYXBlW3doXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRG8gbm90IHJlbW92ZSBvciBpZ25vcmUgY29udHJvbGxlci4gS2VlcCB0aGVtIHNldCBhcyBwbGFjZWhvbGRlcnMuXG4gICAgICBjb250cm9sbGVyR3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZC5hdHRyKHtcbiAgICAgICAgICBpbnZpc2libGU6IHRydWUsXG4gICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSAvLyBDb250ZW50IHRyYW5zbGF0ZSBhbmltYXRpb24uXG5cblxuICAgIHZhciBwYWdlSW5mbyA9IHRoaXMuX2dldFBhZ2VJbmZvKGxlZ2VuZE1vZGVsKTtcblxuICAgIHBhZ2VJbmZvLnBhZ2VJbmRleCAhPSBudWxsICYmIGdyYXBoaWMudXBkYXRlUHJvcHMoY29udGVudEdyb3VwLCB7XG4gICAgICB4OiBwYWdlSW5mby5jb250ZW50UG9zaXRpb25bMF0sXG4gICAgICB5OiBwYWdlSW5mby5jb250ZW50UG9zaXRpb25bMV1cbiAgICB9LCAvLyBXaGVuIHN3aXRjaCBmcm9tIFwic2hvdyBjb250cm9sbGVyXCIgdG8gXCJub3Qgc2hvdyBjb250cm9sbGVyXCIsIHZpZXcgc2hvdWxkIGJlXG4gICAgLy8gdXBkYXRlZCBpbW1lZGlhdGVseSB3aXRob3V0IGFuaW1hdGlvbiwgb3RoZXJ3aXNlIGNhdXNlcyB3ZWlyZCBlZmZlY3QuXG4gICAgc2hvd0NvbnRyb2xsZXIgPyBsZWdlbmRNb2RlbCA6IG51bGwpO1xuXG4gICAgdGhpcy5fdXBkYXRlUGFnZUluZm9WaWV3KGxlZ2VuZE1vZGVsLCBwYWdlSW5mbyk7XG5cbiAgICByZXR1cm4gbWFpblJlY3Q7XG4gIH07XG5cbiAgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcucHJvdG90eXBlLl9wYWdlR28gPSBmdW5jdGlvbiAodG8sIGxlZ2VuZE1vZGVsLCBhcGkpIHtcbiAgICB2YXIgc2Nyb2xsRGF0YUluZGV4ID0gdGhpcy5fZ2V0UGFnZUluZm8obGVnZW5kTW9kZWwpW3RvXTtcblxuICAgIHNjcm9sbERhdGFJbmRleCAhPSBudWxsICYmIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnbGVnZW5kU2Nyb2xsJyxcbiAgICAgIHNjcm9sbERhdGFJbmRleDogc2Nyb2xsRGF0YUluZGV4LFxuICAgICAgbGVnZW5kSWQ6IGxlZ2VuZE1vZGVsLmlkXG4gICAgfSk7XG4gIH07XG5cbiAgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcucHJvdG90eXBlLl91cGRhdGVQYWdlSW5mb1ZpZXcgPSBmdW5jdGlvbiAobGVnZW5kTW9kZWwsIHBhZ2VJbmZvKSB7XG4gICAgdmFyIGNvbnRyb2xsZXJHcm91cCA9IHRoaXMuX2NvbnRyb2xsZXJHcm91cDtcbiAgICB6clV0aWwuZWFjaChbJ3BhZ2VQcmV2JywgJ3BhZ2VOZXh0J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIga2V5ID0gbmFtZSArICdEYXRhSW5kZXgnO1xuICAgICAgdmFyIGNhbkp1bXAgPSBwYWdlSW5mb1trZXldICE9IG51bGw7XG4gICAgICB2YXIgaWNvbiA9IGNvbnRyb2xsZXJHcm91cC5jaGlsZE9mTmFtZShuYW1lKTtcblxuICAgICAgaWYgKGljb24pIHtcbiAgICAgICAgaWNvbi5zZXRTdHlsZSgnZmlsbCcsIGNhbkp1bXAgPyBsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VJY29uQ29sb3InLCB0cnVlKSA6IGxlZ2VuZE1vZGVsLmdldCgncGFnZUljb25JbmFjdGl2ZUNvbG9yJywgdHJ1ZSkpO1xuICAgICAgICBpY29uLmN1cnNvciA9IGNhbkp1bXAgPyAncG9pbnRlcicgOiAnZGVmYXVsdCc7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHBhZ2VUZXh0ID0gY29udHJvbGxlckdyb3VwLmNoaWxkT2ZOYW1lKCdwYWdlVGV4dCcpO1xuICAgIHZhciBwYWdlRm9ybWF0dGVyID0gbGVnZW5kTW9kZWwuZ2V0KCdwYWdlRm9ybWF0dGVyJyk7XG4gICAgdmFyIHBhZ2VJbmRleCA9IHBhZ2VJbmZvLnBhZ2VJbmRleDtcbiAgICB2YXIgY3VycmVudCA9IHBhZ2VJbmRleCAhPSBudWxsID8gcGFnZUluZGV4ICsgMSA6IDA7XG4gICAgdmFyIHRvdGFsID0gcGFnZUluZm8ucGFnZUNvdW50O1xuICAgIHBhZ2VUZXh0ICYmIHBhZ2VGb3JtYXR0ZXIgJiYgcGFnZVRleHQuc2V0U3R5bGUoJ3RleHQnLCB6clV0aWwuaXNTdHJpbmcocGFnZUZvcm1hdHRlcikgPyBwYWdlRm9ybWF0dGVyLnJlcGxhY2UoJ3tjdXJyZW50fScsIGN1cnJlbnQgPT0gbnVsbCA/ICcnIDogY3VycmVudCArICcnKS5yZXBsYWNlKCd7dG90YWx9JywgdG90YWwgPT0gbnVsbCA/ICcnIDogdG90YWwgKyAnJykgOiBwYWdlRm9ybWF0dGVyKHtcbiAgICAgIGN1cnJlbnQ6IGN1cnJlbnQsXG4gICAgICB0b3RhbDogdG90YWxcbiAgICB9KSk7XG4gIH07XG4gIC8qKlxuICAgKiAgY29udGVudFBvc2l0aW9uOiBBcnJheS48bnVtYmVyPiwgbnVsbCB3aGVuIGRhdGEgaXRlbSBub3QgZm91bmQuXG4gICAqICBwYWdlSW5kZXg6IG51bWJlciwgbnVsbCB3aGVuIGRhdGEgaXRlbSBub3QgZm91bmQuXG4gICAqICBwYWdlQ291bnQ6IG51bWJlciwgYWx3YXlzIGJlIGEgbnVtYmVyLCBjYW4gYmUgMC5cbiAgICogIHBhZ2VQcmV2RGF0YUluZGV4OiBudW1iZXIsIG51bGwgd2hlbiBubyBwcmV2aW91cyBwYWdlLlxuICAgKiAgcGFnZU5leHREYXRhSW5kZXg6IG51bWJlciwgbnVsbCB3aGVuIG5vIG5leHQgcGFnZS5cbiAgICogfVxuICAgKi9cblxuXG4gIFNjcm9sbGFibGVMZWdlbmRWaWV3LnByb3RvdHlwZS5fZ2V0UGFnZUluZm8gPSBmdW5jdGlvbiAobGVnZW5kTW9kZWwpIHtcbiAgICB2YXIgc2Nyb2xsRGF0YUluZGV4ID0gbGVnZW5kTW9kZWwuZ2V0KCdzY3JvbGxEYXRhSW5kZXgnLCB0cnVlKTtcbiAgICB2YXIgY29udGVudEdyb3VwID0gdGhpcy5nZXRDb250ZW50R3JvdXAoKTtcbiAgICB2YXIgY29udGFpbmVyUmVjdFNpemUgPSB0aGlzLl9jb250YWluZXJHcm91cC5fX3JlY3RTaXplO1xuICAgIHZhciBvcmllbnRJZHggPSBsZWdlbmRNb2RlbC5nZXRPcmllbnQoKS5pbmRleDtcbiAgICB2YXIgd2ggPSBXSFtvcmllbnRJZHhdO1xuICAgIHZhciB4eSA9IFhZW29yaWVudElkeF07XG5cbiAgICB2YXIgdGFyZ2V0SXRlbUluZGV4ID0gdGhpcy5fZmluZFRhcmdldEl0ZW1JbmRleChzY3JvbGxEYXRhSW5kZXgpO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gY29udGVudEdyb3VwLmNoaWxkcmVuKCk7XG4gICAgdmFyIHRhcmdldEl0ZW0gPSBjaGlsZHJlblt0YXJnZXRJdGVtSW5kZXhdO1xuICAgIHZhciBpdGVtQ291bnQgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgdmFyIHBDb3VudCA9ICFpdGVtQ291bnQgPyAwIDogMTtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgY29udGVudFBvc2l0aW9uOiBbY29udGVudEdyb3VwLngsIGNvbnRlbnRHcm91cC55XSxcbiAgICAgIHBhZ2VDb3VudDogcENvdW50LFxuICAgICAgcGFnZUluZGV4OiBwQ291bnQgLSAxLFxuICAgICAgcGFnZVByZXZEYXRhSW5kZXg6IG51bGwsXG4gICAgICBwYWdlTmV4dERhdGFJbmRleDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAoIXRhcmdldEl0ZW0pIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldEl0ZW1JbmZvID0gZ2V0SXRlbUluZm8odGFyZ2V0SXRlbSk7XG4gICAgcmVzdWx0LmNvbnRlbnRQb3NpdGlvbltvcmllbnRJZHhdID0gLXRhcmdldEl0ZW1JbmZvLnM7IC8vIFN0cmF0ZWd5OlxuICAgIC8vICgxKSBBbHdheXMgYWxpZ24gYmFzZWQgb24gdGhlIGxlZnQvdG9wIG1vc3QgaXRlbS5cbiAgICAvLyAoMikgSXQgaXMgdXNlci1mcmllbmRseSB0aGF0IHRoZSBsYXN0IGl0ZW0gc2hvd24gaW4gdGhlXG4gICAgLy8gY3VycmVudCB3aW5kb3cgaXMgc2hvd24gYXQgdGhlIGJlZ2luaW5nIG9mIG5leHQgd2luZG93LlxuICAgIC8vIE90aGVyd2lzZSBpZiBoYWxmIG9mIHRoZSBsYXN0IGl0ZW0gaXMgY3V0IGJ5IHRoZSB3aW5kb3csXG4gICAgLy8gaXQgd2lsbCBoYXZlIG5vIGNoYW5jZSB0byBkaXNwbGF5IGVudGlyZWx5LlxuICAgIC8vICgzKSBDb25zaWRlciB0aGF0IGl0ZW0gc2l6ZSBwcm9iYWJseSBiZSBkaWZmZXJlbnQsIHdlXG4gICAgLy8gaGF2ZSBjYWxjdWxhdGUgcGFnZUluZGV4IGJ5IHNpemUgcmF0aGVyIHRoYW4gaXRlbSBpbmRleCxcbiAgICAvLyBhbmQgd2UgY2FuIG5vdCBnZXQgcGFnZSBpbmRleCBkaXJlY3RseSBieSBkaXZpc2lvbi5cbiAgICAvLyAoNCkgVGhlIHdpbmRvdyBpcyB0byBuYXJyb3cgdG8gY29udGFpbiBtb3JlIHRoYW5cbiAgICAvLyBvbmUgaXRlbSwgd2Ugc2hvdWxkIG1ha2Ugc3VyZSB0aGF0IHRoZSBwYWdlIGNhbiBiZSBmbGlwZWQuXG5cbiAgICBmb3IgKHZhciBpID0gdGFyZ2V0SXRlbUluZGV4ICsgMSwgd2luU3RhcnRJdGVtSW5mbyA9IHRhcmdldEl0ZW1JbmZvLCB3aW5FbmRJdGVtSW5mbyA9IHRhcmdldEl0ZW1JbmZvLCBjdXJySXRlbUluZm8gPSBudWxsOyBpIDw9IGl0ZW1Db3VudDsgKytpKSB7XG4gICAgICBjdXJySXRlbUluZm8gPSBnZXRJdGVtSW5mbyhjaGlsZHJlbltpXSk7XG5cbiAgICAgIGlmICggLy8gSGFsZiBvZiB0aGUgbGFzdCBpdGVtIGlzIG91dCBvZiB0aGUgd2luZG93LlxuICAgICAgIWN1cnJJdGVtSW5mbyAmJiB3aW5FbmRJdGVtSW5mby5lID4gd2luU3RhcnRJdGVtSW5mby5zICsgY29udGFpbmVyUmVjdFNpemUgfHwgLy8gSWYgdGhlIGN1cnJlbnQgaXRlbSBkb2VzIG5vdCBpbnRlcnNlY3Qgd2l0aCB0aGUgd2luZG93LCB0aGUgbmV3IHBhZ2VcbiAgICAgIC8vIGNhbiBiZSBzdGFydGVkIGF0IHRoZSBjdXJyZW50IGl0ZW0gb3IgdGhlIGxhc3QgaXRlbS5cbiAgICAgIGN1cnJJdGVtSW5mbyAmJiAhaW50ZXJzZWN0KGN1cnJJdGVtSW5mbywgd2luU3RhcnRJdGVtSW5mby5zKSkge1xuICAgICAgICBpZiAod2luRW5kSXRlbUluZm8uaSA+IHdpblN0YXJ0SXRlbUluZm8uaSkge1xuICAgICAgICAgIHdpblN0YXJ0SXRlbUluZm8gPSB3aW5FbmRJdGVtSW5mbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlLmcuLCB3aGVuIHBhZ2Ugc2l6ZSBpcyBzbWFsbGVyIHRoYW4gaXRlbSBzaXplLlxuICAgICAgICAgIHdpblN0YXJ0SXRlbUluZm8gPSBjdXJySXRlbUluZm87XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2luU3RhcnRJdGVtSW5mbykge1xuICAgICAgICAgIGlmIChyZXN1bHQucGFnZU5leHREYXRhSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnBhZ2VOZXh0RGF0YUluZGV4ID0gd2luU3RhcnRJdGVtSW5mby5pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICsrcmVzdWx0LnBhZ2VDb3VudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aW5FbmRJdGVtSW5mbyA9IGN1cnJJdGVtSW5mbztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gdGFyZ2V0SXRlbUluZGV4IC0gMSwgd2luU3RhcnRJdGVtSW5mbyA9IHRhcmdldEl0ZW1JbmZvLCB3aW5FbmRJdGVtSW5mbyA9IHRhcmdldEl0ZW1JbmZvLCBjdXJySXRlbUluZm8gPSBudWxsOyBpID49IC0xOyAtLWkpIHtcbiAgICAgIGN1cnJJdGVtSW5mbyA9IGdldEl0ZW1JbmZvKGNoaWxkcmVuW2ldKTtcblxuICAgICAgaWYgKCAvLyBJZiB0aGUgdGhlIGVuZCBpdGVtIGRvZXMgbm90IGludGVyc2VjdCB3aXRoIHRoZSB3aW5kb3cgc3RhcnRlZFxuICAgICAgLy8gZnJvbSB0aGUgY3VycmVudCBpdGVtLCBhIHBhZ2UgY2FuIGJlIHNldHRsZWQuXG4gICAgICAoIWN1cnJJdGVtSW5mbyB8fCAhaW50ZXJzZWN0KHdpbkVuZEl0ZW1JbmZvLCBjdXJySXRlbUluZm8ucykpICYmIC8vIGUuZy4sIHdoZW4gcGFnZSBzaXplIGlzIHNtYWxsZXIgdGhhbiBpdGVtIHNpemUuXG4gICAgICB3aW5TdGFydEl0ZW1JbmZvLmkgPCB3aW5FbmRJdGVtSW5mby5pKSB7XG4gICAgICAgIHdpbkVuZEl0ZW1JbmZvID0gd2luU3RhcnRJdGVtSW5mbztcblxuICAgICAgICBpZiAocmVzdWx0LnBhZ2VQcmV2RGF0YUluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQucGFnZVByZXZEYXRhSW5kZXggPSB3aW5TdGFydEl0ZW1JbmZvLmk7XG4gICAgICAgIH1cblxuICAgICAgICArK3Jlc3VsdC5wYWdlQ291bnQ7XG4gICAgICAgICsrcmVzdWx0LnBhZ2VJbmRleDtcbiAgICAgIH1cblxuICAgICAgd2luU3RhcnRJdGVtSW5mbyA9IGN1cnJJdGVtSW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgZnVuY3Rpb24gZ2V0SXRlbUluZm8oZWwpIHtcbiAgICAgIGlmIChlbCkge1xuICAgICAgICB2YXIgaXRlbVJlY3QgPSBlbC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gaXRlbVJlY3RbeHldICsgZWxbeHldO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHM6IHN0YXJ0LFxuICAgICAgICAgIGU6IHN0YXJ0ICsgaXRlbVJlY3Rbd2hdLFxuICAgICAgICAgIGk6IGVsLl9fbGVnZW5kRGF0YUluZGV4XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0KGl0ZW1JbmZvLCB3aW5TdGFydCkge1xuICAgICAgcmV0dXJuIGl0ZW1JbmZvLmUgPj0gd2luU3RhcnQgJiYgaXRlbUluZm8ucyA8PSB3aW5TdGFydCArIGNvbnRhaW5lclJlY3RTaXplO1xuICAgIH1cbiAgfTtcblxuICBTY3JvbGxhYmxlTGVnZW5kVmlldy5wcm90b3R5cGUuX2ZpbmRUYXJnZXRJdGVtSW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0RGF0YUluZGV4KSB7XG4gICAgaWYgKCF0aGlzLl9zaG93Q29udHJvbGxlcikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4O1xuICAgIHZhciBjb250ZW50R3JvdXAgPSB0aGlzLmdldENvbnRlbnRHcm91cCgpO1xuICAgIHZhciBkZWZhdWx0SW5kZXg7XG4gICAgY29udGVudEdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQsIGlkeCkge1xuICAgICAgdmFyIGxlZ2VuZERhdGFJZHggPSBjaGlsZC5fX2xlZ2VuZERhdGFJbmRleDsgLy8gRklYTUVcbiAgICAgIC8vIElmIHRoZSBnaXZlbiB0YXJnZXREYXRhSW5kZXggKGZyb20gbW9kZWwpIGlzIGlsbGVnYWwsXG4gICAgICAvLyB3ZSB1c2UgZGVmYXVsdEluZGV4LiBCdXQgdGhlIGluZGV4IG9uIHRoZSBsZWdlbmQgbW9kZWwgYW5kXG4gICAgICAvLyBhY3Rpb24gcGF5bG9hZCBpcyBzdGlsbCBpbGxlZ2FsLiBUaGF0IGNhc2Ugd2lsbCBub3QgYmVcbiAgICAgIC8vIGNoYW5nZWQgdW50aWwgc29tZSBzY2VuYXJpbyByZXF1aXJlcy5cblxuICAgICAgaWYgKGRlZmF1bHRJbmRleCA9PSBudWxsICYmIGxlZ2VuZERhdGFJZHggIT0gbnVsbCkge1xuICAgICAgICBkZWZhdWx0SW5kZXggPSBpZHg7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZWdlbmREYXRhSWR4ID09PSB0YXJnZXREYXRhSW5kZXgpIHtcbiAgICAgICAgaW5kZXggPSBpZHg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGluZGV4ICE9IG51bGwgPyBpbmRleCA6IGRlZmF1bHRJbmRleDtcbiAgfTtcblxuICBTY3JvbGxhYmxlTGVnZW5kVmlldy50eXBlID0gJ2xlZ2VuZC5zY3JvbGwnO1xuICByZXR1cm4gU2Nyb2xsYWJsZUxlZ2VuZFZpZXc7XG59KExlZ2VuZFZpZXcpO1xuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxhYmxlTGVnZW5kVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgdXNlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9uJztcbmltcG9ydCB7IGluc3RhbGwgYXMgaW5zdGFsbExlZ2VuZFBsYWluIH0gZnJvbSAnLi9pbnN0YWxsTGVnZW5kUGxhaW4nO1xuaW1wb3J0IHsgaW5zdGFsbCBhcyBpbnN0YWxsTGVnZW5kU2Nyb2xsIH0gZnJvbSAnLi9pbnN0YWxsTGVnZW5kU2Nyb2xsJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICB1c2UoaW5zdGFsbExlZ2VuZFBsYWluKTtcbiAgdXNlKGluc3RhbGxMZWdlbmRTY3JvbGwpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgTGVnZW5kTW9kZWwgZnJvbSAnLi9MZWdlbmRNb2RlbCc7XG5pbXBvcnQgTGVnZW5kVmlldyBmcm9tICcuL0xlZ2VuZFZpZXcnO1xuaW1wb3J0IGxlZ2VuZEZpbHRlciBmcm9tICcuL2xlZ2VuZEZpbHRlcic7XG5pbXBvcnQgeyBpbnN0YWxsTGVnZW5kQWN0aW9uIH0gZnJvbSAnLi9sZWdlbmRBY3Rpb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKExlZ2VuZE1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhMZWdlbmRWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJvY2Vzc29yKHJlZ2lzdGVycy5QUklPUklUWS5QUk9DRVNTT1IuU0VSSUVTX0ZJTFRFUiwgbGVnZW5kRmlsdGVyKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlcignbGVnZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAncGxhaW4nO1xuICB9KTtcbiAgaW5zdGFsbExlZ2VuZEFjdGlvbihyZWdpc3RlcnMpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyB1c2UgfSBmcm9tICcuLi8uLi9leHRlbnNpb24nO1xuaW1wb3J0IHsgaW5zdGFsbCBhcyBpbnN0YWxsTGVnZW5kUGxhaW4gfSBmcm9tICcuL2luc3RhbGxMZWdlbmRQbGFpbic7XG5pbXBvcnQgU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsIGZyb20gJy4vU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsJztcbmltcG9ydCBTY3JvbGxhYmxlTGVnZW5kVmlldyBmcm9tICcuL1Njcm9sbGFibGVMZWdlbmRWaWV3JztcbmltcG9ydCBpbnN0YWxsU2Nyb2xsYWJsZUxlZ2VuZEFjdGlvbiBmcm9tICcuL3Njcm9sbGFibGVMZWdlbmRBY3Rpb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHVzZShpbnN0YWxsTGVnZW5kUGxhaW4pO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChTY3JvbGxhYmxlTGVnZW5kTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KFNjcm9sbGFibGVMZWdlbmRWaWV3KTtcbiAgaW5zdGFsbFNjcm9sbGFibGVMZWdlbmRBY3Rpb24ocmVnaXN0ZXJzKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gQHRzLW5vY2hlY2tcbmltcG9ydCB7IGN1cnJ5LCBlYWNoIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcblxuZnVuY3Rpb24gbGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlcihtZXRob2ROYW1lLCBwYXlsb2FkLCBlY01vZGVsKSB7XG4gIHZhciBzZWxlY3RlZE1hcCA9IHt9O1xuICB2YXIgaXNUb2dnbGVTZWxlY3QgPSBtZXRob2ROYW1lID09PSAndG9nZ2xlU2VsZWN0ZWQnO1xuICB2YXIgaXNTZWxlY3RlZDsgLy8gVXBkYXRlIGFsbCBsZWdlbmQgY29tcG9uZW50c1xuXG4gIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnbGVnZW5kJywgZnVuY3Rpb24gKGxlZ2VuZE1vZGVsKSB7XG4gICAgaWYgKGlzVG9nZ2xlU2VsZWN0ICYmIGlzU2VsZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgLy8gRm9yY2Ugb3RoZXIgbGVnZW5kIGhhcyBzYW1lIHNlbGVjdGVkIHN0YXR1c1xuICAgICAgLy8gT3IgdGhlIGZpcnN0IGlzIHRvZ2dsZWQgdG8gdHJ1ZSBhbmQgb3RoZXIgYXJlIHRvZ2dsZWQgdG8gZmFsc2VcbiAgICAgIC8vIEluIHRoZSBjYXNlIG9uZSBsZWdlbmQgaGFzIHNvbWUgaXRlbSB1blNlbGVjdGVkIGluIG9wdGlvbi4gQW5kIGlmIG90aGVyIGxlZ2VuZFxuICAgICAgLy8gZG9lc24ndCBoYXMgdGhlIGl0ZW0sIHRoZXkgd2lsbCBhc3N1bWUgaXQgaXMgc2VsZWN0ZWQuXG4gICAgICBsZWdlbmRNb2RlbFtpc1NlbGVjdGVkID8gJ3NlbGVjdCcgOiAndW5TZWxlY3QnXShwYXlsb2FkLm5hbWUpO1xuICAgIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ2FsbFNlbGVjdCcgfHwgbWV0aG9kTmFtZSA9PT0gJ2ludmVyc2VTZWxlY3QnKSB7XG4gICAgICBsZWdlbmRNb2RlbFttZXRob2ROYW1lXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWdlbmRNb2RlbFttZXRob2ROYW1lXShwYXlsb2FkLm5hbWUpO1xuICAgICAgaXNTZWxlY3RlZCA9IGxlZ2VuZE1vZGVsLmlzU2VsZWN0ZWQocGF5bG9hZC5uYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgbGVnZW5kRGF0YSA9IGxlZ2VuZE1vZGVsLmdldERhdGEoKTtcbiAgICBlYWNoKGxlZ2VuZERhdGEsIGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgdmFyIG5hbWUgPSBtb2RlbC5nZXQoJ25hbWUnKTsgLy8gV3JhcCBlbGVtZW50XG5cbiAgICAgIGlmIChuYW1lID09PSAnXFxuJyB8fCBuYW1lID09PSAnJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0l0ZW1TZWxlY3RlZCA9IGxlZ2VuZE1vZGVsLmlzU2VsZWN0ZWQobmFtZSk7XG5cbiAgICAgIGlmIChzZWxlY3RlZE1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAvLyBVbnNlbGVjdGVkIGlmIGFueSBsZWdlbmQgaXMgdW5zZWxlY3RlZFxuICAgICAgICBzZWxlY3RlZE1hcFtuYW1lXSA9IHNlbGVjdGVkTWFwW25hbWVdICYmIGlzSXRlbVNlbGVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWRNYXBbbmFtZV0gPSBpc0l0ZW1TZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7IC8vIFJldHVybiB0aGUgZXZlbnQgZXhwbGljaXRseVxuXG4gIHJldHVybiBtZXRob2ROYW1lID09PSAnYWxsU2VsZWN0JyB8fCBtZXRob2ROYW1lID09PSAnaW52ZXJzZVNlbGVjdCcgPyB7XG4gICAgc2VsZWN0ZWQ6IHNlbGVjdGVkTWFwXG4gIH0gOiB7XG4gICAgbmFtZTogcGF5bG9hZC5uYW1lLFxuICAgIHNlbGVjdGVkOiBzZWxlY3RlZE1hcFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbExlZ2VuZEFjdGlvbihyZWdpc3RlcnMpIHtcbiAgLyoqXG4gICAqIEBldmVudCBsZWdlbmRUb2dnbGVTZWxlY3RcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgJ2xlZ2VuZFRvZ2dsZVNlbGVjdCdcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmcm9tXVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBTZXJpZXMgbmFtZSBvciBkYXRhIGl0ZW0gbmFtZVxuICAgKi9cbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKCdsZWdlbmRUb2dnbGVTZWxlY3QnLCAnbGVnZW5kc2VsZWN0Y2hhbmdlZCcsIGN1cnJ5KGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIsICd0b2dnbGVTZWxlY3RlZCcpKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKCdsZWdlbmRBbGxTZWxlY3QnLCAnbGVnZW5kc2VsZWN0YWxsJywgY3VycnkobGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlciwgJ2FsbFNlbGVjdCcpKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKCdsZWdlbmRJbnZlcnNlU2VsZWN0JywgJ2xlZ2VuZGludmVyc2VzZWxlY3QnLCBjdXJyeShsZWdlbmRTZWxlY3RBY3Rpb25IYW5kbGVyLCAnaW52ZXJzZVNlbGVjdCcpKTtcbiAgLyoqXG4gICAqIEBldmVudCBsZWdlbmRTZWxlY3RcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgJ2xlZ2VuZFNlbGVjdCdcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgU2VyaWVzIG5hbWUgb3IgZGF0YSBpdGVtIG5hbWVcbiAgICovXG5cbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKCdsZWdlbmRTZWxlY3QnLCAnbGVnZW5kc2VsZWN0ZWQnLCBjdXJyeShsZWdlbmRTZWxlY3RBY3Rpb25IYW5kbGVyLCAnc2VsZWN0JykpO1xuICAvKipcbiAgICogQGV2ZW50IGxlZ2VuZFVuU2VsZWN0XG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlICdsZWdlbmRVblNlbGVjdCdcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgU2VyaWVzIG5hbWUgb3IgZGF0YSBpdGVtIG5hbWVcbiAgICovXG5cbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKCdsZWdlbmRVblNlbGVjdCcsICdsZWdlbmR1bnNlbGVjdGVkJywgY3VycnkobGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlciwgJ3VuU2VsZWN0JykpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsZWdlbmRGaWx0ZXIoZWNNb2RlbCkge1xuICB2YXIgbGVnZW5kTW9kZWxzID0gZWNNb2RlbC5maW5kQ29tcG9uZW50cyh7XG4gICAgbWFpblR5cGU6ICdsZWdlbmQnXG4gIH0pO1xuXG4gIGlmIChsZWdlbmRNb2RlbHMgJiYgbGVnZW5kTW9kZWxzLmxlbmd0aCkge1xuICAgIGVjTW9kZWwuZmlsdGVyU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgIC8vIElmIGluIGFueSBsZWdlbmQgY29tcG9uZW50IHRoZSBzdGF0dXMgaXMgbm90IHNlbGVjdGVkLlxuICAgICAgLy8gQmVjYXVzZSBpbiBsZWdlbmQgc2VyaWVzIGlzIGFzc3VtZWQgc2VsZWN0ZWQgd2hlbiBpdCBpcyBub3QgaW4gdGhlIGxlZ2VuZCBkYXRhLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWdlbmRNb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFsZWdlbmRNb2RlbHNbaV0uaXNTZWxlY3RlZChzZXJpZXMubmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5zdGFsbFNjcm9sbGFibGVMZWdlbmRBY3Rpb24ocmVnaXN0ZXJzKSB7XG4gIC8qKlxuICAgKiBAZXZlbnQgbGVnZW5kU2Nyb2xsXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlICdsZWdlbmRTY3JvbGwnXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzY3JvbGxEYXRhSW5kZXhcbiAgICovXG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbignbGVnZW5kU2Nyb2xsJywgJ2xlZ2VuZHNjcm9sbCcsIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgdmFyIHNjcm9sbERhdGFJbmRleCA9IHBheWxvYWQuc2Nyb2xsRGF0YUluZGV4O1xuICAgIHNjcm9sbERhdGFJbmRleCAhPSBudWxsICYmIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgICBtYWluVHlwZTogJ2xlZ2VuZCcsXG4gICAgICBzdWJUeXBlOiAnc2Nyb2xsJyxcbiAgICAgIHF1ZXJ5OiBwYXlsb2FkXG4gICAgfSwgZnVuY3Rpb24gKGxlZ2VuZE1vZGVsKSB7XG4gICAgICBsZWdlbmRNb2RlbC5zZXRTY3JvbGxEYXRhSW5kZXgoc2Nyb2xsRGF0YUluZGV4KTtcbiAgICB9KTtcbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IE1hcmtlck1vZGVsIGZyb20gJy4vTWFya2VyTW9kZWwnO1xuXG52YXIgTWFya0FyZWFNb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNYXJrQXJlYU1vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE1hcmtBcmVhTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gTWFya0FyZWFNb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIE1hcmtBcmVhTW9kZWwucHJvdG90eXBlLmNyZWF0ZU1hcmtlck1vZGVsRnJvbVNlcmllcyA9IGZ1bmN0aW9uIChtYXJrZXJPcHQsIG1hc3Rlck1hcmtlck1vZGVsLCBlY01vZGVsKSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrQXJlYU1vZGVsKG1hcmtlck9wdCwgbWFzdGVyTWFya2VyTW9kZWwsIGVjTW9kZWwpO1xuICB9O1xuXG4gIE1hcmtBcmVhTW9kZWwudHlwZSA9ICdtYXJrQXJlYSc7XG4gIE1hcmtBcmVhTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgLy8gUEVORElOR1xuICAgIHo6IDEsXG4gICAgdG9vbHRpcDoge1xuICAgICAgdHJpZ2dlcjogJ2l0ZW0nXG4gICAgfSxcbiAgICAvLyBtYXJrQXJlYSBzaG91bGQgZml4ZWQgb24gdGhlIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgYW5pbWF0aW9uOiBmYWxzZSxcbiAgICBsYWJlbDoge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIHBvc2l0aW9uOiAndG9wJ1xuICAgIH0sXG4gICAgaXRlbVN0eWxlOiB7XG4gICAgICAvLyBjb2xvciBhbmQgYm9yZGVyQ29sb3IgZGVmYXVsdCB0byB1c2UgY29sb3IgZnJvbSBzZXJpZXNcbiAgICAgIC8vIGNvbG9yOiAnYXV0bydcbiAgICAgIC8vIGJvcmRlckNvbG9yOiAnYXV0bydcbiAgICAgIGJvcmRlcldpZHRoOiAwXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246ICd0b3AnXG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gTWFya0FyZWFNb2RlbDtcbn0oTWFya2VyTW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBNYXJrQXJlYU1vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjsgLy8gVE9ETyBPcHRpbWl6ZSBvbiBwb2xhclxuXG5pbXBvcnQgKiBhcyBjb2xvclV0aWwgZnJvbSAnenJlbmRlci9saWIvdG9vbC9jb2xvcic7XG5pbXBvcnQgTGlzdCBmcm9tICcuLi8uLi9kYXRhL0xpc3QnO1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgeyBlbmFibGVIb3ZlckVtcGhhc2lzLCBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcyc7XG5pbXBvcnQgKiBhcyBtYXJrZXJIZWxwZXIgZnJvbSAnLi9tYXJrZXJIZWxwZXInO1xuaW1wb3J0IE1hcmtlclZpZXcgZnJvbSAnLi9NYXJrZXJWaWV3JztcbmltcG9ydCB7IHJldHJpZXZlLCBtZXJnZUFsbCwgbWFwLCBkZWZhdWx0cywgY3VycnksIGZpbHRlciwgZWFjaCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBpc0Nvb3JkaW5hdGVTeXN0ZW1UeXBlIH0gZnJvbSAnLi4vLi4vY29vcmQvQ29vcmRpbmF0ZVN5c3RlbSc7XG5pbXBvcnQgTWFya2VyTW9kZWwgZnJvbSAnLi9NYXJrZXJNb2RlbCc7XG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbmltcG9ydCB7IGdldFZpc3VhbEZyb21EYXRhIH0gZnJvbSAnLi4vLi4vdmlzdWFsL2hlbHBlcic7XG5pbXBvcnQgeyBzZXRMYWJlbFN0eWxlLCBnZXRMYWJlbFN0YXRlc01vZGVscyB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlJztcbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xuXG52YXIgbWFya0FyZWFUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGNvb3JkU3lzLCBtYU1vZGVsLCBpdGVtKSB7XG4gIHZhciBsdCA9IG1hcmtlckhlbHBlci5kYXRhVHJhbnNmb3JtKHNlcmllc01vZGVsLCBpdGVtWzBdKTtcbiAgdmFyIHJiID0gbWFya2VySGVscGVyLmRhdGFUcmFuc2Zvcm0oc2VyaWVzTW9kZWwsIGl0ZW1bMV0pOyAvLyBGSVhNRSBtYWtlIHN1cmUgbHQgaXMgbGVzcyB0aGFuIHJiXG5cbiAgdmFyIGx0Q29vcmQgPSBsdC5jb29yZDtcbiAgdmFyIHJiQ29vcmQgPSByYi5jb29yZDtcbiAgbHRDb29yZFswXSA9IHJldHJpZXZlKGx0Q29vcmRbMF0sIC1JbmZpbml0eSk7XG4gIGx0Q29vcmRbMV0gPSByZXRyaWV2ZShsdENvb3JkWzFdLCAtSW5maW5pdHkpO1xuICByYkNvb3JkWzBdID0gcmV0cmlldmUocmJDb29yZFswXSwgSW5maW5pdHkpO1xuICByYkNvb3JkWzFdID0gcmV0cmlldmUocmJDb29yZFsxXSwgSW5maW5pdHkpOyAvLyBNZXJnZSBvcHRpb24gaW50byBvbmVcblxuICB2YXIgcmVzdWx0ID0gbWVyZ2VBbGwoW3t9LCBsdCwgcmJdKTtcbiAgcmVzdWx0LmNvb3JkID0gW2x0LmNvb3JkLCByYi5jb29yZF07XG4gIHJlc3VsdC54MCA9IGx0Lng7XG4gIHJlc3VsdC55MCA9IGx0Lnk7XG4gIHJlc3VsdC54MSA9IHJiLng7XG4gIHJlc3VsdC55MSA9IHJiLnk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBpc0luaWZpbml0eSh2YWwpIHtcbiAgcmV0dXJuICFpc05hTih2YWwpICYmICFpc0Zpbml0ZSh2YWwpO1xufSAvLyBJZiBhIG1hcmtBcmVhIGhhcyBvbmUgZGltXG5cblxuZnVuY3Rpb24gaWZNYXJrQXJlYUhhc09ubHlEaW0oZGltSW5kZXgsIGZyb21Db29yZCwgdG9Db29yZCwgY29vcmRTeXMpIHtcbiAgdmFyIG90aGVyRGltSW5kZXggPSAxIC0gZGltSW5kZXg7XG4gIHJldHVybiBpc0luaWZpbml0eShmcm9tQ29vcmRbb3RoZXJEaW1JbmRleF0pICYmIGlzSW5pZmluaXR5KHRvQ29vcmRbb3RoZXJEaW1JbmRleF0pO1xufVxuXG5mdW5jdGlvbiBtYXJrQXJlYUZpbHRlcihjb29yZFN5cywgaXRlbSkge1xuICB2YXIgZnJvbUNvb3JkID0gaXRlbS5jb29yZFswXTtcbiAgdmFyIHRvQ29vcmQgPSBpdGVtLmNvb3JkWzFdO1xuXG4gIGlmIChpc0Nvb3JkaW5hdGVTeXN0ZW1UeXBlKGNvb3JkU3lzLCAnY2FydGVzaWFuMmQnKSkge1xuICAgIC8vIEluIGNhc2VcbiAgICAvLyB7XG4gICAgLy8gIG1hcmtBcmVhOiB7XG4gICAgLy8gICAgZGF0YTogW3sgeUF4aXM6IDIgfV1cbiAgICAvLyAgfVxuICAgIC8vIH1cbiAgICBpZiAoZnJvbUNvb3JkICYmIHRvQ29vcmQgJiYgKGlmTWFya0FyZWFIYXNPbmx5RGltKDEsIGZyb21Db29yZCwgdG9Db29yZCwgY29vcmRTeXMpIHx8IGlmTWFya0FyZWFIYXNPbmx5RGltKDAsIGZyb21Db29yZCwgdG9Db29yZCwgY29vcmRTeXMpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hcmtlckhlbHBlci5kYXRhRmlsdGVyKGNvb3JkU3lzLCB7XG4gICAgY29vcmQ6IGZyb21Db29yZCxcbiAgICB4OiBpdGVtLngwLFxuICAgIHk6IGl0ZW0ueTBcbiAgfSkgfHwgbWFya2VySGVscGVyLmRhdGFGaWx0ZXIoY29vcmRTeXMsIHtcbiAgICBjb29yZDogdG9Db29yZCxcbiAgICB4OiBpdGVtLngxLFxuICAgIHk6IGl0ZW0ueTFcbiAgfSk7XG59IC8vIGRpbXMgY2FuIGJlIFsneDAnLCAneTAnXSwgWyd4MScsICd5MSddLCBbJ3gwJywgJ3kxJ10sIFsneDEnLCAneTAnXVxuXG5cbmZ1bmN0aW9uIGdldFNpbmdsZU1hcmtlckVuZFBvaW50KGRhdGEsIGlkeCwgZGltcywgc2VyaWVzTW9kZWwsIGFwaSkge1xuICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgdmFyIHBvaW50O1xuICB2YXIgeFB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldChkaW1zWzBdKSwgYXBpLmdldFdpZHRoKCkpO1xuICB2YXIgeVB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldChkaW1zWzFdKSwgYXBpLmdldEhlaWdodCgpKTtcblxuICBpZiAoIWlzTmFOKHhQeCkgJiYgIWlzTmFOKHlQeCkpIHtcbiAgICBwb2ludCA9IFt4UHgsIHlQeF07XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2hhcnQgbGlrZSBiYXIgbWF5IGhhdmUgdGhlcmUgb3duIG1hcmtlciBwb3NpdGlvbmluZyBsb2dpY1xuICAgIGlmIChzZXJpZXNNb2RlbC5nZXRNYXJrZXJQb3NpdGlvbikge1xuICAgICAgLy8gVXNlIHRoZSBnZXRNYXJrZXJQb2lzaXRpb25cbiAgICAgIHBvaW50ID0gc2VyaWVzTW9kZWwuZ2V0TWFya2VyUG9zaXRpb24oZGF0YS5nZXRWYWx1ZXMoZGltcywgaWR4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4ID0gZGF0YS5nZXQoZGltc1swXSwgaWR4KTtcbiAgICAgIHZhciB5ID0gZGF0YS5nZXQoZGltc1sxXSwgaWR4KTtcbiAgICAgIHZhciBwdCA9IFt4LCB5XTtcbiAgICAgIGNvb3JkU3lzLmNsYW1wRGF0YSAmJiBjb29yZFN5cy5jbGFtcERhdGEocHQsIHB0KTtcbiAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQocHQsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChpc0Nvb3JkaW5hdGVTeXN0ZW1UeXBlKGNvb3JkU3lzLCAnY2FydGVzaWFuMmQnKSkge1xuICAgICAgLy8gVE9ETzogVFlQRSB0c0A0LjEgbWF5IHN0aWxsIGluZmVyIGl0IGFzIEF4aXMgaW5zdGVhZCBvZiBBeGlzMkQuIE5vdCBzdXJlIGlmIGl0J3MgYSBidWdcbiAgICAgIHZhciB4QXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoJ3gnKTtcbiAgICAgIHZhciB5QXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoJ3knKTtcbiAgICAgIHZhciB4ID0gZGF0YS5nZXQoZGltc1swXSwgaWR4KTtcbiAgICAgIHZhciB5ID0gZGF0YS5nZXQoZGltc1sxXSwgaWR4KTtcblxuICAgICAgaWYgKGlzSW5pZmluaXR5KHgpKSB7XG4gICAgICAgIHBvaW50WzBdID0geEF4aXMudG9HbG9iYWxDb29yZCh4QXhpcy5nZXRFeHRlbnQoKVtkaW1zWzBdID09PSAneDAnID8gMCA6IDFdKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNJbmlmaW5pdHkoeSkpIHtcbiAgICAgICAgcG9pbnRbMV0gPSB5QXhpcy50b0dsb2JhbENvb3JkKHlBeGlzLmdldEV4dGVudCgpW2RpbXNbMV0gPT09ICd5MCcgPyAwIDogMV0pO1xuICAgICAgfVxuICAgIH0gLy8gVXNlIHgsIHkgaWYgaGFzIGFueVxuXG5cbiAgICBpZiAoIWlzTmFOKHhQeCkpIHtcbiAgICAgIHBvaW50WzBdID0geFB4O1xuICAgIH1cblxuICAgIGlmICghaXNOYU4oeVB4KSkge1xuICAgICAgcG9pbnRbMV0gPSB5UHg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvaW50O1xufVxuXG52YXIgZGltUGVybXV0YXRpb25zID0gW1sneDAnLCAneTAnXSwgWyd4MScsICd5MCddLCBbJ3gxJywgJ3kxJ10sIFsneDAnLCAneTEnXV07XG5cbnZhciBNYXJrQXJlYVZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTWFya0FyZWFWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE1hcmtBcmVhVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBNYXJrQXJlYVZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBNYXJrQXJlYVZpZXcucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtYXJrQXJlYU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgbWFNb2RlbCA9IE1hcmtlck1vZGVsLmdldE1hcmtlck1vZGVsRnJvbVNlcmllcyhzZXJpZXNNb2RlbCwgJ21hcmtBcmVhJyk7XG5cbiAgICAgIGlmIChtYU1vZGVsKSB7XG4gICAgICAgIHZhciBhcmVhRGF0YV8xID0gbWFNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgIGFyZWFEYXRhXzEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgdmFyIHBvaW50cyA9IG1hcChkaW1QZXJtdXRhdGlvbnMsIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTaW5nbGVNYXJrZXJFbmRQb2ludChhcmVhRGF0YV8xLCBpZHgsIGRpbSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgICAgICAgfSk7IC8vIExheW91dFxuXG4gICAgICAgICAgYXJlYURhdGFfMS5zZXRJdGVtTGF5b3V0KGlkeCwgcG9pbnRzKTtcbiAgICAgICAgICB2YXIgZWwgPSBhcmVhRGF0YV8xLmdldEl0ZW1HcmFwaGljRWwoaWR4KTtcbiAgICAgICAgICBlbC5zZXRTaGFwZSgncG9pbnRzJywgcG9pbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbiAgTWFya0FyZWFWaWV3LnByb3RvdHlwZS5yZW5kZXJTZXJpZXMgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIG1hTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIHNlcmllc0lkID0gc2VyaWVzTW9kZWwuaWQ7XG4gICAgdmFyIHNlcmllc0RhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGFyZWFHcm91cE1hcCA9IHRoaXMubWFya2VyR3JvdXBNYXA7XG4gICAgdmFyIHBvbHlnb25Hcm91cCA9IGFyZWFHcm91cE1hcC5nZXQoc2VyaWVzSWQpIHx8IGFyZWFHcm91cE1hcC5zZXQoc2VyaWVzSWQsIHtcbiAgICAgIGdyb3VwOiBuZXcgZ3JhcGhpYy5Hcm91cCgpXG4gICAgfSk7XG4gICAgdGhpcy5ncm91cC5hZGQocG9seWdvbkdyb3VwLmdyb3VwKTtcbiAgICB0aGlzLm1hcmtLZWVwKHBvbHlnb25Hcm91cCk7XG4gICAgdmFyIGFyZWFEYXRhID0gY3JlYXRlTGlzdChjb29yZFN5cywgc2VyaWVzTW9kZWwsIG1hTW9kZWwpOyAvLyBMaW5lIGRhdGEgZm9yIHRvb2x0aXAgYW5kIGZvcm1hdHRlclxuXG4gICAgbWFNb2RlbC5zZXREYXRhKGFyZWFEYXRhKTsgLy8gVXBkYXRlIHZpc3VhbCBhbmQgbGF5b3V0IG9mIGxpbmVcblxuICAgIGFyZWFEYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgLy8gTGF5b3V0XG4gICAgICB2YXIgcG9pbnRzID0gbWFwKGRpbVBlcm11dGF0aW9ucywgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICByZXR1cm4gZ2V0U2luZ2xlTWFya2VyRW5kUG9pbnQoYXJlYURhdGEsIGlkeCwgZGltLCBzZXJpZXNNb2RlbCwgYXBpKTtcbiAgICAgIH0pOyAvLyBJZiBub25lIG9mIHRoZSBhcmVhIGlzIGluc2lkZSBjb29yZFN5cywgYWxsQ2xpcHBlZCBpcyBzZXQgdG8gYmUgdHJ1ZVxuICAgICAgLy8gaW4gbGF5b3V0IHNvIHRoYXQgbGFiZWwgd2lsbCBub3QgYmUgZGlzcGxheWVkLiBTZWUgIzEyNTkxXG5cbiAgICAgIHZhciBhbGxDbGlwcGVkID0gdHJ1ZTtcbiAgICAgIGVhY2goZGltUGVybXV0YXRpb25zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIGlmICghYWxsQ2xpcHBlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4VmFsdWUgPSBhcmVhRGF0YS5nZXQoZGltWzBdLCBpZHgpO1xuICAgICAgICB2YXIgeVZhbHVlID0gYXJlYURhdGEuZ2V0KGRpbVsxXSwgaWR4KTsgLy8gSWYgaXMgaW5maW5pdHksIHRoZSBheGlzIHNob3VsZCBiZSBjb25zaWRlcmVkIG5vdCBjbGlwcGVkXG5cbiAgICAgICAgaWYgKChpc0luaWZpbml0eSh4VmFsdWUpIHx8IGNvb3JkU3lzLmdldEF4aXMoJ3gnKS5jb250YWluRGF0YSh4VmFsdWUpKSAmJiAoaXNJbmlmaW5pdHkoeVZhbHVlKSB8fCBjb29yZFN5cy5nZXRBeGlzKCd5JykuY29udGFpbkRhdGEoeVZhbHVlKSkpIHtcbiAgICAgICAgICBhbGxDbGlwcGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYXJlYURhdGEuc2V0SXRlbUxheW91dChpZHgsIHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgIGFsbENsaXBwZWQ6IGFsbENsaXBwZWRcbiAgICAgIH0pO1xuICAgICAgdmFyIHN0eWxlID0gYXJlYURhdGEuZ2V0SXRlbU1vZGVsKGlkeCkuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgdmFyIGNvbG9yID0gZ2V0VmlzdWFsRnJvbURhdGEoc2VyaWVzRGF0YSwgJ2NvbG9yJyk7XG5cbiAgICAgIGlmICghc3R5bGUuZmlsbCkge1xuICAgICAgICBzdHlsZS5maWxsID0gY29sb3I7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdHlsZS5maWxsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHN0eWxlLmZpbGwgPSBjb2xvclV0aWwubW9kaWZ5QWxwaGEoc3R5bGUuZmlsbCwgMC40KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXN0eWxlLnN0cm9rZSkge1xuICAgICAgICBzdHlsZS5zdHJva2UgPSBjb2xvcjtcbiAgICAgIH0gLy8gVmlzdWFsXG5cblxuICAgICAgYXJlYURhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdzdHlsZScsIHN0eWxlKTtcbiAgICB9KTtcbiAgICBhcmVhRGF0YS5kaWZmKGlubmVyKHBvbHlnb25Hcm91cCkuZGF0YSkuYWRkKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBsYXlvdXQgPSBhcmVhRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG5cbiAgICAgIGlmICghbGF5b3V0LmFsbENsaXBwZWQpIHtcbiAgICAgICAgdmFyIHBvbHlnb24gPSBuZXcgZ3JhcGhpYy5Qb2x5Z29uKHtcbiAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgcG9pbnRzOiBsYXlvdXQucG9pbnRzXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXJlYURhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIHBvbHlnb24pO1xuICAgICAgICBwb2x5Z29uR3JvdXAuZ3JvdXAuYWRkKHBvbHlnb24pO1xuICAgICAgfVxuICAgIH0pLnVwZGF0ZShmdW5jdGlvbiAobmV3SWR4LCBvbGRJZHgpIHtcbiAgICAgIHZhciBwb2x5Z29uID0gaW5uZXIocG9seWdvbkdyb3VwKS5kYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICAgIHZhciBsYXlvdXQgPSBhcmVhRGF0YS5nZXRJdGVtTGF5b3V0KG5ld0lkeCk7XG5cbiAgICAgIGlmICghbGF5b3V0LmFsbENsaXBwZWQpIHtcbiAgICAgICAgaWYgKHBvbHlnb24pIHtcbiAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHBvbHlnb24sIHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgIHBvaW50czogbGF5b3V0LnBvaW50c1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIG1hTW9kZWwsIG5ld0lkeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9seWdvbiA9IG5ldyBncmFwaGljLlBvbHlnb24oe1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgcG9pbnRzOiBsYXlvdXQucG9pbnRzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmVhRGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgcG9seWdvbik7XG4gICAgICAgIHBvbHlnb25Hcm91cC5ncm91cC5hZGQocG9seWdvbik7XG4gICAgICB9IGVsc2UgaWYgKHBvbHlnb24pIHtcbiAgICAgICAgcG9seWdvbkdyb3VwLmdyb3VwLnJlbW92ZShwb2x5Z29uKTtcbiAgICAgIH1cbiAgICB9KS5yZW1vdmUoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIHBvbHlnb24gPSBpbm5lcihwb2x5Z29uR3JvdXApLmRhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpO1xuICAgICAgcG9seWdvbkdyb3VwLmdyb3VwLnJlbW92ZShwb2x5Z29uKTtcbiAgICB9KS5leGVjdXRlKCk7XG4gICAgYXJlYURhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKHBvbHlnb24sIGlkeCkge1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGFyZWFEYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgdmFyIHN0eWxlID0gYXJlYURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzdHlsZScpO1xuICAgICAgcG9seWdvbi51c2VTdHlsZShhcmVhRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJykpO1xuICAgICAgc2V0TGFiZWxTdHlsZShwb2x5Z29uLCBnZXRMYWJlbFN0YXRlc01vZGVscyhpdGVtTW9kZWwpLCB7XG4gICAgICAgIGxhYmVsRmV0Y2hlcjogbWFNb2RlbCxcbiAgICAgICAgbGFiZWxEYXRhSW5kZXg6IGlkeCxcbiAgICAgICAgZGVmYXVsdFRleHQ6IGFyZWFEYXRhLmdldE5hbWUoaWR4KSB8fCAnJyxcbiAgICAgICAgaW5oZXJpdENvbG9yOiB0eXBlb2Ygc3R5bGUuZmlsbCA9PT0gJ3N0cmluZycgPyBjb2xvclV0aWwubW9kaWZ5QWxwaGEoc3R5bGUuZmlsbCwgMSkgOiAnIzAwMCdcbiAgICAgIH0pO1xuICAgICAgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsKHBvbHlnb24sIGl0ZW1Nb2RlbCk7XG4gICAgICBlbmFibGVIb3ZlckVtcGhhc2lzKHBvbHlnb24pO1xuICAgICAgZ2V0RUNEYXRhKHBvbHlnb24pLmRhdGFNb2RlbCA9IG1hTW9kZWw7XG4gICAgfSk7XG4gICAgaW5uZXIocG9seWdvbkdyb3VwKS5kYXRhID0gYXJlYURhdGE7XG4gICAgcG9seWdvbkdyb3VwLmdyb3VwLnNpbGVudCA9IG1hTW9kZWwuZ2V0KCdzaWxlbnQnKSB8fCBzZXJpZXNNb2RlbC5nZXQoJ3NpbGVudCcpO1xuICB9O1xuXG4gIE1hcmtBcmVhVmlldy50eXBlID0gJ21hcmtBcmVhJztcbiAgcmV0dXJuIE1hcmtBcmVhVmlldztcbn0oTWFya2VyVmlldyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpc3QoY29vcmRTeXMsIHNlcmllc01vZGVsLCBtYU1vZGVsKSB7XG4gIHZhciBjb29yZERpbXNJbmZvcztcbiAgdmFyIGFyZWFEYXRhO1xuICB2YXIgZGltcyA9IFsneDAnLCAneTAnLCAneDEnLCAneTEnXTtcblxuICBpZiAoY29vcmRTeXMpIHtcbiAgICBjb29yZERpbXNJbmZvcyA9IG1hcChjb29yZFN5cyAmJiBjb29yZFN5cy5kaW1lbnNpb25zLCBmdW5jdGlvbiAoY29vcmREaW0pIHtcbiAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgdmFyIGluZm8gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oZGF0YS5tYXBEaW1lbnNpb24oY29vcmREaW0pKSB8fCB7fTsgLy8gSW4gbWFwIHNlcmllcyBkYXRhIGRvbid0IGhhdmUgbG5nIGFuZCBsYXQgZGltZW5zaW9uLiBGYWxsYmFjayB0byBzYW1lIHdpdGggY29vcmRTeXNcblxuICAgICAgcmV0dXJuIGRlZmF1bHRzKHtcbiAgICAgICAgbmFtZTogY29vcmREaW1cbiAgICAgIH0sIGluZm8pO1xuICAgIH0pO1xuICAgIGFyZWFEYXRhID0gbmV3IExpc3QobWFwKGRpbXMsIGZ1bmN0aW9uIChkaW0sIGlkeCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZGltLFxuICAgICAgICB0eXBlOiBjb29yZERpbXNJbmZvc1tpZHggJSAyXS50eXBlXG4gICAgICB9O1xuICAgIH0pLCBtYU1vZGVsKTtcbiAgfSBlbHNlIHtcbiAgICBjb29yZERpbXNJbmZvcyA9IFt7XG4gICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgdHlwZTogJ2Zsb2F0J1xuICAgIH1dO1xuICAgIGFyZWFEYXRhID0gbmV3IExpc3QoY29vcmREaW1zSW5mb3MsIG1hTW9kZWwpO1xuICB9XG5cbiAgdmFyIG9wdERhdGEgPSBtYXAobWFNb2RlbC5nZXQoJ2RhdGEnKSwgY3VycnkobWFya0FyZWFUcmFuc2Zvcm0sIHNlcmllc01vZGVsLCBjb29yZFN5cywgbWFNb2RlbCkpO1xuXG4gIGlmIChjb29yZFN5cykge1xuICAgIG9wdERhdGEgPSBmaWx0ZXIob3B0RGF0YSwgY3VycnkobWFya0FyZWFGaWx0ZXIsIGNvb3JkU3lzKSk7XG4gIH1cblxuICB2YXIgZGltVmFsdWVHZXR0ZXIgPSBjb29yZFN5cyA/IGZ1bmN0aW9uIChpdGVtLCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgLy8gVE9ETyBzaG91bGQgY29udmVydCB0byBQYXJzZWRWYWx1ZT9cbiAgICByZXR1cm4gaXRlbS5jb29yZFtNYXRoLmZsb29yKGRpbUluZGV4IC8gMildW2RpbUluZGV4ICUgMl07XG4gIH0gOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICB9O1xuICBhcmVhRGF0YS5pbml0RGF0YShvcHREYXRhLCBudWxsLCBkaW1WYWx1ZUdldHRlcik7XG4gIGFyZWFEYXRhLmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuICByZXR1cm4gYXJlYURhdGE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcmtBcmVhVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgTWFya2VyTW9kZWwgZnJvbSAnLi9NYXJrZXJNb2RlbCc7XG5cbnZhciBNYXJrTGluZU1vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKE1hcmtMaW5lTW9kZWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gTWFya0xpbmVNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBNYXJrTGluZU1vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgTWFya0xpbmVNb2RlbC5wcm90b3R5cGUuY3JlYXRlTWFya2VyTW9kZWxGcm9tU2VyaWVzID0gZnVuY3Rpb24gKG1hcmtlck9wdCwgbWFzdGVyTWFya2VyTW9kZWwsIGVjTW9kZWwpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtMaW5lTW9kZWwobWFya2VyT3B0LCBtYXN0ZXJNYXJrZXJNb2RlbCwgZWNNb2RlbCk7XG4gIH07XG5cbiAgTWFya0xpbmVNb2RlbC50eXBlID0gJ21hcmtMaW5lJztcbiAgTWFya0xpbmVNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIHpsZXZlbDogMCxcbiAgICB6OiA1LFxuICAgIHN5bWJvbDogWydjaXJjbGUnLCAnYXJyb3cnXSxcbiAgICBzeW1ib2xTaXplOiBbOCwgMTZdLFxuICAgIC8vc3ltYm9sUm90YXRlOiAwLFxuICAgIHByZWNpc2lvbjogMixcbiAgICB0b29sdGlwOiB7XG4gICAgICB0cmlnZ2VyOiAnaXRlbSdcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgcG9zaXRpb246ICdlbmQnLFxuICAgICAgZGlzdGFuY2U6IDVcbiAgICB9LFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgdHlwZTogJ2Rhc2hlZCdcbiAgICB9LFxuICAgIGVtcGhhc2lzOiB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICBzaG93OiB0cnVlXG4gICAgICB9LFxuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiAzXG4gICAgICB9XG4gICAgfSxcbiAgICBhbmltYXRpb25FYXNpbmc6ICdsaW5lYXInXG4gIH07XG4gIHJldHVybiBNYXJrTGluZU1vZGVsO1xufShNYXJrZXJNb2RlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcmtMaW5lTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IExpc3QgZnJvbSAnLi4vLi4vZGF0YS9MaXN0JztcbmltcG9ydCAqIGFzIG51bWJlclV0aWwgZnJvbSAnLi4vLi4vdXRpbC9udW1iZXInO1xuaW1wb3J0ICogYXMgbWFya2VySGVscGVyIGZyb20gJy4vbWFya2VySGVscGVyJztcbmltcG9ydCBMaW5lRHJhdyBmcm9tICcuLi8uLi9jaGFydC9oZWxwZXIvTGluZURyYXcnO1xuaW1wb3J0IE1hcmtlclZpZXcgZnJvbSAnLi9NYXJrZXJWaWV3JztcbmltcG9ydCB7IGdldFN0YWNrZWREaW1lbnNpb24gfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9kYXRhU3RhY2tIZWxwZXInO1xuaW1wb3J0IHsgaXNDb29yZGluYXRlU3lzdGVtVHlwZSB9IGZyb20gJy4uLy4uL2Nvb3JkL0Nvb3JkaW5hdGVTeXN0ZW0nO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlJztcbmltcG9ydCBNYXJrZXJNb2RlbCBmcm9tICcuL01hcmtlck1vZGVsJztcbmltcG9ydCB7IGlzQXJyYXksIHJldHJpZXZlLCBjbG9uZSwgZXh0ZW5kLCBsb2dFcnJvciwgbWVyZ2UsIG1hcCwgZGVmYXVsdHMsIGN1cnJ5LCBmaWx0ZXIgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgbWFrZUlubmVyIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG5pbXBvcnQgeyBnZXRWaXN1YWxGcm9tRGF0YSB9IGZyb20gJy4uLy4uL3Zpc3VhbC9oZWxwZXInO1xudmFyIGlubmVyID0gbWFrZUlubmVyKCk7XG5cbnZhciBtYXJrTGluZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgY29vcmRTeXMsIG1sTW9kZWwsIGl0ZW0pIHtcbiAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gIHZhciBpdGVtQXJyYXk7XG5cbiAgaWYgKCFpc0FycmF5KGl0ZW0pKSB7XG4gICAgLy8gU3BlY2lhbCB0eXBlIG1hcmtMaW5lIGxpa2UgJ21pbicsICdtYXgnLCAnYXZlcmFnZScsICdtZWRpYW4nXG4gICAgdmFyIG1sVHlwZSA9IGl0ZW0udHlwZTtcblxuICAgIGlmIChtbFR5cGUgPT09ICdtaW4nIHx8IG1sVHlwZSA9PT0gJ21heCcgfHwgbWxUeXBlID09PSAnYXZlcmFnZScgfHwgbWxUeXBlID09PSAnbWVkaWFuJyAvLyBJbiBjYXNlXG4gICAgLy8gZGF0YTogW3tcbiAgICAvLyAgIHlBeGlzOiAxMFxuICAgIC8vIH1dXG4gICAgfHwgaXRlbS54QXhpcyAhPSBudWxsIHx8IGl0ZW0ueUF4aXMgIT0gbnVsbCkge1xuICAgICAgdmFyIHZhbHVlQXhpcyA9IHZvaWQgMDtcbiAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcblxuICAgICAgaWYgKGl0ZW0ueUF4aXMgIT0gbnVsbCB8fCBpdGVtLnhBeGlzICE9IG51bGwpIHtcbiAgICAgICAgdmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0QXhpcyhpdGVtLnlBeGlzICE9IG51bGwgPyAneScgOiAneCcpO1xuICAgICAgICB2YWx1ZSA9IHJldHJpZXZlKGl0ZW0ueUF4aXMsIGl0ZW0ueEF4aXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGF4aXNJbmZvID0gbWFya2VySGVscGVyLmdldEF4aXNJbmZvKGl0ZW0sIGRhdGEsIGNvb3JkU3lzLCBzZXJpZXNNb2RlbCk7XG4gICAgICAgIHZhbHVlQXhpcyA9IGF4aXNJbmZvLnZhbHVlQXhpcztcbiAgICAgICAgdmFyIHZhbHVlRGF0YURpbSA9IGdldFN0YWNrZWREaW1lbnNpb24oZGF0YSwgYXhpc0luZm8udmFsdWVEYXRhRGltKTtcbiAgICAgICAgdmFsdWUgPSBtYXJrZXJIZWxwZXIubnVtQ2FsY3VsYXRlKGRhdGEsIHZhbHVlRGF0YURpbSwgbWxUeXBlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlSW5kZXggPSB2YWx1ZUF4aXMuZGltID09PSAneCcgPyAwIDogMTtcbiAgICAgIHZhciBiYXNlSW5kZXggPSAxIC0gdmFsdWVJbmRleDsgLy8gTm9ybWl6ZWQgdG8gMmQgZGF0YSB3aXRoIHN0YXJ0IGFuZCBlbmQgcG9pbnRcblxuICAgICAgdmFyIG1sRnJvbSA9IGNsb25lKGl0ZW0pO1xuICAgICAgdmFyIG1sVG8gPSB7XG4gICAgICAgIGNvb3JkOiBbXVxuICAgICAgfTtcbiAgICAgIG1sRnJvbS50eXBlID0gbnVsbDtcbiAgICAgIG1sRnJvbS5jb29yZCA9IFtdO1xuICAgICAgbWxGcm9tLmNvb3JkW2Jhc2VJbmRleF0gPSAtSW5maW5pdHk7XG4gICAgICBtbFRvLmNvb3JkW2Jhc2VJbmRleF0gPSBJbmZpbml0eTtcbiAgICAgIHZhciBwcmVjaXNpb24gPSBtbE1vZGVsLmdldCgncHJlY2lzaW9uJyk7XG5cbiAgICAgIGlmIChwcmVjaXNpb24gPj0gMCAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhbHVlID0gK3ZhbHVlLnRvRml4ZWQoTWF0aC5taW4ocHJlY2lzaW9uLCAyMCkpO1xuICAgICAgfVxuXG4gICAgICBtbEZyb20uY29vcmRbdmFsdWVJbmRleF0gPSBtbFRvLmNvb3JkW3ZhbHVlSW5kZXhdID0gdmFsdWU7XG4gICAgICBpdGVtQXJyYXkgPSBbbWxGcm9tLCBtbFRvLCB7XG4gICAgICAgIHR5cGU6IG1sVHlwZSxcbiAgICAgICAgdmFsdWVJbmRleDogaXRlbS52YWx1ZUluZGV4LFxuICAgICAgICAvLyBGb3JjZSB0byB1c2UgdGhlIHZhbHVlIG9mIGNhbGN1bGF0ZWQgdmFsdWUuXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEludmFsaWQgZGF0YVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbG9nRXJyb3IoJ0ludmFsaWQgbWFya0xpbmUgZGF0YS4nKTtcbiAgICAgIH1cblxuICAgICAgaXRlbUFycmF5ID0gW107XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGl0ZW1BcnJheSA9IGl0ZW07XG4gIH1cblxuICB2YXIgbm9ybWFsaXplZEl0ZW0gPSBbbWFya2VySGVscGVyLmRhdGFUcmFuc2Zvcm0oc2VyaWVzTW9kZWwsIGl0ZW1BcnJheVswXSksIG1hcmtlckhlbHBlci5kYXRhVHJhbnNmb3JtKHNlcmllc01vZGVsLCBpdGVtQXJyYXlbMV0pLCBleHRlbmQoe30sIGl0ZW1BcnJheVsyXSldOyAvLyBBdm9pZCBsaW5lIGRhdGEgdHlwZSBpcyBleHRlbmRlZCBieSBmcm9tKHRvKSBkYXRhIHR5cGVcblxuICBub3JtYWxpemVkSXRlbVsyXS50eXBlID0gbm9ybWFsaXplZEl0ZW1bMl0udHlwZSB8fCBudWxsOyAvLyBNZXJnZSBmcm9tIG9wdGlvbiBhbmQgdG8gb3B0aW9uIGludG8gbGluZSBvcHRpb25cblxuICBtZXJnZShub3JtYWxpemVkSXRlbVsyXSwgbm9ybWFsaXplZEl0ZW1bMF0pO1xuICBtZXJnZShub3JtYWxpemVkSXRlbVsyXSwgbm9ybWFsaXplZEl0ZW1bMV0pO1xuICByZXR1cm4gbm9ybWFsaXplZEl0ZW07XG59O1xuXG5mdW5jdGlvbiBpc0luaWZpbml0eSh2YWwpIHtcbiAgcmV0dXJuICFpc05hTih2YWwpICYmICFpc0Zpbml0ZSh2YWwpO1xufSAvLyBJZiBhIG1hcmtMaW5lIGhhcyBvbmUgZGltXG5cblxuZnVuY3Rpb24gaWZNYXJrTGluZUhhc09ubHlEaW0oZGltSW5kZXgsIGZyb21Db29yZCwgdG9Db29yZCwgY29vcmRTeXMpIHtcbiAgdmFyIG90aGVyRGltSW5kZXggPSAxIC0gZGltSW5kZXg7XG4gIHZhciBkaW1OYW1lID0gY29vcmRTeXMuZGltZW5zaW9uc1tkaW1JbmRleF07XG4gIHJldHVybiBpc0luaWZpbml0eShmcm9tQ29vcmRbb3RoZXJEaW1JbmRleF0pICYmIGlzSW5pZmluaXR5KHRvQ29vcmRbb3RoZXJEaW1JbmRleF0pICYmIGZyb21Db29yZFtkaW1JbmRleF0gPT09IHRvQ29vcmRbZGltSW5kZXhdICYmIGNvb3JkU3lzLmdldEF4aXMoZGltTmFtZSkuY29udGFpbkRhdGEoZnJvbUNvb3JkW2RpbUluZGV4XSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtMaW5lRmlsdGVyKGNvb3JkU3lzLCBpdGVtKSB7XG4gIGlmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgdmFyIGZyb21Db29yZCA9IGl0ZW1bMF0uY29vcmQ7XG4gICAgdmFyIHRvQ29vcmQgPSBpdGVtWzFdLmNvb3JkOyAvLyBJbiBjYXNlXG4gICAgLy8ge1xuICAgIC8vICBtYXJrTGluZToge1xuICAgIC8vICAgIGRhdGE6IFt7IHlBeGlzOiAyIH1dXG4gICAgLy8gIH1cbiAgICAvLyB9XG5cbiAgICBpZiAoZnJvbUNvb3JkICYmIHRvQ29vcmQgJiYgKGlmTWFya0xpbmVIYXNPbmx5RGltKDEsIGZyb21Db29yZCwgdG9Db29yZCwgY29vcmRTeXMpIHx8IGlmTWFya0xpbmVIYXNPbmx5RGltKDAsIGZyb21Db29yZCwgdG9Db29yZCwgY29vcmRTeXMpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hcmtlckhlbHBlci5kYXRhRmlsdGVyKGNvb3JkU3lzLCBpdGVtWzBdKSAmJiBtYXJrZXJIZWxwZXIuZGF0YUZpbHRlcihjb29yZFN5cywgaXRlbVsxXSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNpbmdsZU1hcmtlckVuZExheW91dChkYXRhLCBpZHgsIGlzRnJvbSwgc2VyaWVzTW9kZWwsIGFwaSkge1xuICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgdmFyIHBvaW50O1xuICB2YXIgeFB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldCgneCcpLCBhcGkuZ2V0V2lkdGgoKSk7XG4gIHZhciB5UHggPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChpdGVtTW9kZWwuZ2V0KCd5JyksIGFwaS5nZXRIZWlnaHQoKSk7XG5cbiAgaWYgKCFpc05hTih4UHgpICYmICFpc05hTih5UHgpKSB7XG4gICAgcG9pbnQgPSBbeFB4LCB5UHhdO1xuICB9IGVsc2Uge1xuICAgIC8vIENoYXJ0IGxpa2UgYmFyIG1heSBoYXZlIHRoZXJlIG93biBtYXJrZXIgcG9zaXRpb25pbmcgbG9naWNcbiAgICBpZiAoc2VyaWVzTW9kZWwuZ2V0TWFya2VyUG9zaXRpb24pIHtcbiAgICAgIC8vIFVzZSB0aGUgZ2V0TWFya2VyUG9pc2l0aW9uXG4gICAgICBwb2ludCA9IHNlcmllc01vZGVsLmdldE1hcmtlclBvc2l0aW9uKGRhdGEuZ2V0VmFsdWVzKGRhdGEuZGltZW5zaW9ucywgaWR4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaW1zID0gY29vcmRTeXMuZGltZW5zaW9ucztcbiAgICAgIHZhciB4ID0gZGF0YS5nZXQoZGltc1swXSwgaWR4KTtcbiAgICAgIHZhciB5ID0gZGF0YS5nZXQoZGltc1sxXSwgaWR4KTtcbiAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoW3gsIHldKTtcbiAgICB9IC8vIEV4cGFuZCBsaW5lIHRvIHRoZSBlZGdlIG9mIGdyaWQgaWYgdmFsdWUgb24gb25lIGF4aXMgaXMgSW5pZm5pdHlcbiAgICAvLyBJbiBjYXNlXG4gICAgLy8gIG1hcmtMaW5lOiB7XG4gICAgLy8gICAgZGF0YTogW3tcbiAgICAvLyAgICAgIHlBeGlzOiAyXG4gICAgLy8gICAgICAvLyBvclxuICAgIC8vICAgICAgdHlwZTogJ2F2ZXJhZ2UnXG4gICAgLy8gICAgfV1cbiAgICAvLyAgfVxuXG5cbiAgICBpZiAoaXNDb29yZGluYXRlU3lzdGVtVHlwZShjb29yZFN5cywgJ2NhcnRlc2lhbjJkJykpIHtcbiAgICAgIC8vIFRPRE86IFRZUEUgdHNANC4xIG1heSBzdGlsbCBpbmZlciBpdCBhcyBBeGlzIGluc3RlYWQgb2YgQXhpczJELiBOb3Qgc3VyZSBpZiBpdCdzIGEgYnVnXG4gICAgICB2YXIgeEF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKCd4Jyk7XG4gICAgICB2YXIgeUF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKCd5Jyk7XG4gICAgICB2YXIgZGltcyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7XG5cbiAgICAgIGlmIChpc0luaWZpbml0eShkYXRhLmdldChkaW1zWzBdLCBpZHgpKSkge1xuICAgICAgICBwb2ludFswXSA9IHhBeGlzLnRvR2xvYmFsQ29vcmQoeEF4aXMuZ2V0RXh0ZW50KClbaXNGcm9tID8gMCA6IDFdKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNJbmlmaW5pdHkoZGF0YS5nZXQoZGltc1sxXSwgaWR4KSkpIHtcbiAgICAgICAgcG9pbnRbMV0gPSB5QXhpcy50b0dsb2JhbENvb3JkKHlBeGlzLmdldEV4dGVudCgpW2lzRnJvbSA/IDAgOiAxXSk7XG4gICAgICB9XG4gICAgfSAvLyBVc2UgeCwgeSBpZiBoYXMgYW55XG5cblxuICAgIGlmICghaXNOYU4oeFB4KSkge1xuICAgICAgcG9pbnRbMF0gPSB4UHg7XG4gICAgfVxuXG4gICAgaWYgKCFpc05hTih5UHgpKSB7XG4gICAgICBwb2ludFsxXSA9IHlQeDtcbiAgICB9XG4gIH1cblxuICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBwb2ludCk7XG59XG5cbnZhciBNYXJrTGluZVZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTWFya0xpbmVWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE1hcmtMaW5lVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBNYXJrTGluZVZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBNYXJrTGluZVZpZXcucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtYXJrTGluZU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgbWxNb2RlbCA9IE1hcmtlck1vZGVsLmdldE1hcmtlck1vZGVsRnJvbVNlcmllcyhzZXJpZXNNb2RlbCwgJ21hcmtMaW5lJyk7XG5cbiAgICAgIGlmIChtbE1vZGVsKSB7XG4gICAgICAgIHZhciBtbERhdGFfMSA9IG1sTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICB2YXIgZnJvbURhdGFfMSA9IGlubmVyKG1sTW9kZWwpLmZyb207XG4gICAgICAgIHZhciB0b0RhdGFfMSA9IGlubmVyKG1sTW9kZWwpLnRvOyAvLyBVcGRhdGUgdmlzdWFsIGFuZCBsYXlvdXQgb2YgZnJvbSBzeW1ib2wgYW5kIHRvIHN5bWJvbFxuXG4gICAgICAgIGZyb21EYXRhXzEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgdXBkYXRlU2luZ2xlTWFya2VyRW5kTGF5b3V0KGZyb21EYXRhXzEsIGlkeCwgdHJ1ZSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgICAgICAgdXBkYXRlU2luZ2xlTWFya2VyRW5kTGF5b3V0KHRvRGF0YV8xLCBpZHgsIGZhbHNlLCBzZXJpZXNNb2RlbCwgYXBpKTtcbiAgICAgICAgfSk7IC8vIFVwZGF0ZSBsYXlvdXQgb2YgbGluZVxuXG4gICAgICAgIG1sRGF0YV8xLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgIG1sRGF0YV8xLnNldEl0ZW1MYXlvdXQoaWR4LCBbZnJvbURhdGFfMS5nZXRJdGVtTGF5b3V0KGlkeCksIHRvRGF0YV8xLmdldEl0ZW1MYXlvdXQoaWR4KV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXJrZXJHcm91cE1hcC5nZXQoc2VyaWVzTW9kZWwuaWQpLnVwZGF0ZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4gIE1hcmtMaW5lVmlldy5wcm90b3R5cGUucmVuZGVyU2VyaWVzID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBtbE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBzZXJpZXNJZCA9IHNlcmllc01vZGVsLmlkO1xuICAgIHZhciBzZXJpZXNEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBsaW5lRHJhd01hcCA9IHRoaXMubWFya2VyR3JvdXBNYXA7XG4gICAgdmFyIGxpbmVEcmF3ID0gbGluZURyYXdNYXAuZ2V0KHNlcmllc0lkKSB8fCBsaW5lRHJhd01hcC5zZXQoc2VyaWVzSWQsIG5ldyBMaW5lRHJhdygpKTtcbiAgICB0aGlzLmdyb3VwLmFkZChsaW5lRHJhdy5ncm91cCk7XG4gICAgdmFyIG1sRGF0YSA9IGNyZWF0ZUxpc3QoY29vcmRTeXMsIHNlcmllc01vZGVsLCBtbE1vZGVsKTtcbiAgICB2YXIgZnJvbURhdGEgPSBtbERhdGEuZnJvbTtcbiAgICB2YXIgdG9EYXRhID0gbWxEYXRhLnRvO1xuICAgIHZhciBsaW5lRGF0YSA9IG1sRGF0YS5saW5lO1xuICAgIGlubmVyKG1sTW9kZWwpLmZyb20gPSBmcm9tRGF0YTtcbiAgICBpbm5lcihtbE1vZGVsKS50byA9IHRvRGF0YTsgLy8gTGluZSBkYXRhIGZvciB0b29sdGlwIGFuZCBmb3JtYXR0ZXJcblxuICAgIG1sTW9kZWwuc2V0RGF0YShsaW5lRGF0YSk7XG4gICAgdmFyIHN5bWJvbFR5cGUgPSBtbE1vZGVsLmdldCgnc3ltYm9sJyk7XG4gICAgdmFyIHN5bWJvbFNpemUgPSBtbE1vZGVsLmdldCgnc3ltYm9sU2l6ZScpO1xuXG4gICAgaWYgKCFpc0FycmF5KHN5bWJvbFR5cGUpKSB7XG4gICAgICBzeW1ib2xUeXBlID0gW3N5bWJvbFR5cGUsIHN5bWJvbFR5cGVdO1xuICAgIH1cblxuICAgIGlmICghaXNBcnJheShzeW1ib2xTaXplKSkge1xuICAgICAgc3ltYm9sU2l6ZSA9IFtzeW1ib2xTaXplLCBzeW1ib2xTaXplXTtcbiAgICB9IC8vIFVwZGF0ZSB2aXN1YWwgYW5kIGxheW91dCBvZiBmcm9tIHN5bWJvbCBhbmQgdG8gc3ltYm9sXG5cblxuICAgIG1sRGF0YS5mcm9tLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdXBkYXRlRGF0YVZpc3VhbEFuZExheW91dChmcm9tRGF0YSwgaWR4LCB0cnVlKTtcbiAgICAgIHVwZGF0ZURhdGFWaXN1YWxBbmRMYXlvdXQodG9EYXRhLCBpZHgsIGZhbHNlKTtcbiAgICB9KTsgLy8gVXBkYXRlIHZpc3VhbCBhbmQgbGF5b3V0IG9mIGxpbmVcblxuICAgIGxpbmVEYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIGxpbmVTdHlsZSA9IGxpbmVEYXRhLmdldEl0ZW1Nb2RlbChpZHgpLmdldE1vZGVsKCdsaW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKTsgLy8gbGluZURhdGEuc2V0SXRlbVZpc3VhbChpZHgsIHtcbiAgICAgIC8vICAgICBjb2xvcjogbGluZUNvbG9yIHx8IGZyb21EYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKVxuICAgICAgLy8gfSk7XG5cbiAgICAgIGxpbmVEYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBbZnJvbURhdGEuZ2V0SXRlbUxheW91dChpZHgpLCB0b0RhdGEuZ2V0SXRlbUxheW91dChpZHgpXSk7XG5cbiAgICAgIGlmIChsaW5lU3R5bGUuc3Ryb2tlID09IG51bGwpIHtcbiAgICAgICAgbGluZVN0eWxlLnN0cm9rZSA9IGZyb21EYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3R5bGUnKS5maWxsO1xuICAgICAgfVxuXG4gICAgICBsaW5lRGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwge1xuICAgICAgICBmcm9tU3ltYm9sUm90YXRlOiBmcm9tRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFJvdGF0ZScpLFxuICAgICAgICBmcm9tU3ltYm9sU2l6ZTogZnJvbURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xTaXplJyksXG4gICAgICAgIGZyb21TeW1ib2w6IGZyb21EYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJyksXG4gICAgICAgIHRvU3ltYm9sUm90YXRlOiB0b0RhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xSb3RhdGUnKSxcbiAgICAgICAgdG9TeW1ib2xTaXplOiB0b0RhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xTaXplJyksXG4gICAgICAgIHRvU3ltYm9sOiB0b0RhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKSxcbiAgICAgICAgc3R5bGU6IGxpbmVTdHlsZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbGluZURyYXcudXBkYXRlRGF0YShsaW5lRGF0YSk7IC8vIFNldCBob3N0IG1vZGVsIGZvciB0b29sdGlwXG4gICAgLy8gRklYTUVcblxuICAgIG1sRGF0YS5saW5lLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgZ2V0RUNEYXRhKGNoaWxkKS5kYXRhTW9kZWwgPSBtbE1vZGVsO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVEYXRhVmlzdWFsQW5kTGF5b3V0KGRhdGEsIGlkeCwgaXNGcm9tKSB7XG4gICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgIHVwZGF0ZVNpbmdsZU1hcmtlckVuZExheW91dChkYXRhLCBpZHgsIGlzRnJvbSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgICB2YXIgc3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZSgpO1xuXG4gICAgICBpZiAoc3R5bGUuZmlsbCA9PSBudWxsKSB7XG4gICAgICAgIHN0eWxlLmZpbGwgPSBnZXRWaXN1YWxGcm9tRGF0YShzZXJpZXNEYXRhLCAnY29sb3InKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwge1xuICAgICAgICBzeW1ib2xSb3RhdGU6IGl0ZW1Nb2RlbC5nZXQoJ3N5bWJvbFJvdGF0ZScpLFxuICAgICAgICBzeW1ib2xTaXplOiBpdGVtTW9kZWwuZ2V0KCdzeW1ib2xTaXplJykgfHwgc3ltYm9sU2l6ZVtpc0Zyb20gPyAwIDogMV0sXG4gICAgICAgIHN5bWJvbDogaXRlbU1vZGVsLmdldCgnc3ltYm9sJywgdHJ1ZSkgfHwgc3ltYm9sVHlwZVtpc0Zyb20gPyAwIDogMV0sXG4gICAgICAgIHN0eWxlOiBzdHlsZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5tYXJrS2VlcChsaW5lRHJhdyk7XG4gICAgbGluZURyYXcuZ3JvdXAuc2lsZW50ID0gbWxNb2RlbC5nZXQoJ3NpbGVudCcpIHx8IHNlcmllc01vZGVsLmdldCgnc2lsZW50Jyk7XG4gIH07XG5cbiAgTWFya0xpbmVWaWV3LnR5cGUgPSAnbWFya0xpbmUnO1xuICByZXR1cm4gTWFya0xpbmVWaWV3O1xufShNYXJrZXJWaWV3KTtcblxuZnVuY3Rpb24gY3JlYXRlTGlzdChjb29yZFN5cywgc2VyaWVzTW9kZWwsIG1sTW9kZWwpIHtcbiAgdmFyIGNvb3JkRGltc0luZm9zO1xuXG4gIGlmIChjb29yZFN5cykge1xuICAgIGNvb3JkRGltc0luZm9zID0gbWFwKGNvb3JkU3lzICYmIGNvb3JkU3lzLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChjb29yZERpbSkge1xuICAgICAgdmFyIGluZm8gPSBzZXJpZXNNb2RlbC5nZXREYXRhKCkuZ2V0RGltZW5zaW9uSW5mbyhzZXJpZXNNb2RlbC5nZXREYXRhKCkubWFwRGltZW5zaW9uKGNvb3JkRGltKSkgfHwge307IC8vIEluIG1hcCBzZXJpZXMgZGF0YSBkb24ndCBoYXZlIGxuZyBhbmQgbGF0IGRpbWVuc2lvbi4gRmFsbGJhY2sgdG8gc2FtZSB3aXRoIGNvb3JkU3lzXG5cbiAgICAgIHJldHVybiBkZWZhdWx0cyh7XG4gICAgICAgIG5hbWU6IGNvb3JkRGltXG4gICAgICB9LCBpbmZvKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb29yZERpbXNJbmZvcyA9IFt7XG4gICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgdHlwZTogJ2Zsb2F0J1xuICAgIH1dO1xuICB9XG5cbiAgdmFyIGZyb21EYXRhID0gbmV3IExpc3QoY29vcmREaW1zSW5mb3MsIG1sTW9kZWwpO1xuICB2YXIgdG9EYXRhID0gbmV3IExpc3QoY29vcmREaW1zSW5mb3MsIG1sTW9kZWwpOyAvLyBObyBkaW1lbnNpb25zXG5cbiAgdmFyIGxpbmVEYXRhID0gbmV3IExpc3QoW10sIG1sTW9kZWwpO1xuICB2YXIgb3B0RGF0YSA9IG1hcChtbE1vZGVsLmdldCgnZGF0YScpLCBjdXJyeShtYXJrTGluZVRyYW5zZm9ybSwgc2VyaWVzTW9kZWwsIGNvb3JkU3lzLCBtbE1vZGVsKSk7XG5cbiAgaWYgKGNvb3JkU3lzKSB7XG4gICAgb3B0RGF0YSA9IGZpbHRlcihvcHREYXRhLCBjdXJyeShtYXJrTGluZUZpbHRlciwgY29vcmRTeXMpKTtcbiAgfVxuXG4gIHZhciBkaW1WYWx1ZUdldHRlciA9IGNvb3JkU3lzID8gbWFya2VySGVscGVyLmRpbVZhbHVlR2V0dGVyIDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgfTtcbiAgZnJvbURhdGEuaW5pdERhdGEobWFwKG9wdERhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1bMF07XG4gIH0pLCBudWxsLCBkaW1WYWx1ZUdldHRlcik7XG4gIHRvRGF0YS5pbml0RGF0YShtYXAob3B0RGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbVsxXTtcbiAgfSksIG51bGwsIGRpbVZhbHVlR2V0dGVyKTtcbiAgbGluZURhdGEuaW5pdERhdGEobWFwKG9wdERhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1bMl07XG4gIH0pKTtcbiAgbGluZURhdGEuaGFzSXRlbU9wdGlvbiA9IHRydWU7XG4gIHJldHVybiB7XG4gICAgZnJvbTogZnJvbURhdGEsXG4gICAgdG86IHRvRGF0YSxcbiAgICBsaW5lOiBsaW5lRGF0YVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBNYXJrTGluZVZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IE1hcmtlck1vZGVsIGZyb20gJy4vTWFya2VyTW9kZWwnO1xuXG52YXIgTWFya1BvaW50TW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTWFya1BvaW50TW9kZWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gTWFya1BvaW50TW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gTWFya1BvaW50TW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBNYXJrUG9pbnRNb2RlbC5wcm90b3R5cGUuY3JlYXRlTWFya2VyTW9kZWxGcm9tU2VyaWVzID0gZnVuY3Rpb24gKG1hcmtlck9wdCwgbWFzdGVyTWFya2VyTW9kZWwsIGVjTW9kZWwpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtQb2ludE1vZGVsKG1hcmtlck9wdCwgbWFzdGVyTWFya2VyTW9kZWwsIGVjTW9kZWwpO1xuICB9O1xuXG4gIE1hcmtQb2ludE1vZGVsLnR5cGUgPSAnbWFya1BvaW50JztcbiAgTWFya1BvaW50TW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogNSxcbiAgICBzeW1ib2w6ICdwaW4nLFxuICAgIHN5bWJvbFNpemU6IDUwLFxuICAgIC8vc3ltYm9sUm90YXRlOiAwLFxuICAgIC8vc3ltYm9sT2Zmc2V0OiBbMCwgMF1cbiAgICB0b29sdGlwOiB7XG4gICAgICB0cmlnZ2VyOiAnaXRlbSdcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgcG9zaXRpb246ICdpbnNpZGUnXG4gICAgfSxcbiAgICBpdGVtU3R5bGU6IHtcbiAgICAgIGJvcmRlcldpZHRoOiAyXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE1hcmtQb2ludE1vZGVsO1xufShNYXJrZXJNb2RlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcmtQb2ludE1vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBTeW1ib2xEcmF3IGZyb20gJy4uLy4uL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3JztcbmltcG9ydCAqIGFzIG51bWJlclV0aWwgZnJvbSAnLi4vLi4vdXRpbC9udW1iZXInO1xuaW1wb3J0IExpc3QgZnJvbSAnLi4vLi4vZGF0YS9MaXN0JztcbmltcG9ydCAqIGFzIG1hcmtlckhlbHBlciBmcm9tICcuL21hcmtlckhlbHBlcic7XG5pbXBvcnQgTWFya2VyVmlldyBmcm9tICcuL01hcmtlclZpZXcnO1xuaW1wb3J0IE1hcmtlck1vZGVsIGZyb20gJy4vTWFya2VyTW9kZWwnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiwgbWFwLCBkZWZhdWx0cywgZmlsdGVyLCBjdXJyeSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBnZXRFQ0RhdGEgfSBmcm9tICcuLi8uLi91dGlsL2lubmVyU3RvcmUnO1xuaW1wb3J0IHsgZ2V0VmlzdWFsRnJvbURhdGEgfSBmcm9tICcuLi8uLi92aXN1YWwvaGVscGVyJztcblxuZnVuY3Rpb24gdXBkYXRlTWFya2VyTGF5b3V0KG1wRGF0YSwgc2VyaWVzTW9kZWwsIGFwaSkge1xuICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICBtcERhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgdmFyIGl0ZW1Nb2RlbCA9IG1wRGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICB2YXIgcG9pbnQ7XG4gICAgdmFyIHhQeCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGl0ZW1Nb2RlbC5nZXQoJ3gnKSwgYXBpLmdldFdpZHRoKCkpO1xuICAgIHZhciB5UHggPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChpdGVtTW9kZWwuZ2V0KCd5JyksIGFwaS5nZXRIZWlnaHQoKSk7XG5cbiAgICBpZiAoIWlzTmFOKHhQeCkgJiYgIWlzTmFOKHlQeCkpIHtcbiAgICAgIHBvaW50ID0gW3hQeCwgeVB4XTtcbiAgICB9IC8vIENoYXJ0IGxpa2UgYmFyIG1heSBoYXZlIHRoZXJlIG93biBtYXJrZXIgcG9zaXRpb25pbmcgbG9naWNcbiAgICBlbHNlIGlmIChzZXJpZXNNb2RlbC5nZXRNYXJrZXJQb3NpdGlvbikge1xuICAgICAgICAvLyBVc2UgdGhlIGdldE1hcmtlclBvaXNpdGlvblxuICAgICAgICBwb2ludCA9IHNlcmllc01vZGVsLmdldE1hcmtlclBvc2l0aW9uKG1wRGF0YS5nZXRWYWx1ZXMobXBEYXRhLmRpbWVuc2lvbnMsIGlkeCkpO1xuICAgICAgfSBlbHNlIGlmIChjb29yZFN5cykge1xuICAgICAgICB2YXIgeCA9IG1wRGF0YS5nZXQoY29vcmRTeXMuZGltZW5zaW9uc1swXSwgaWR4KTtcbiAgICAgICAgdmFyIHkgPSBtcERhdGEuZ2V0KGNvb3JkU3lzLmRpbWVuc2lvbnNbMV0sIGlkeCk7XG4gICAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoW3gsIHldKTtcbiAgICAgIH0gLy8gVXNlIHgsIHkgaWYgaGFzIGFueVxuXG5cbiAgICBpZiAoIWlzTmFOKHhQeCkpIHtcbiAgICAgIHBvaW50WzBdID0geFB4O1xuICAgIH1cblxuICAgIGlmICghaXNOYU4oeVB4KSkge1xuICAgICAgcG9pbnRbMV0gPSB5UHg7XG4gICAgfVxuXG4gICAgbXBEYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBwb2ludCk7XG4gIH0pO1xufVxuXG52YXIgTWFya1BvaW50VmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNYXJrUG9pbnRWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE1hcmtQb2ludFZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gTWFya1BvaW50Vmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIE1hcmtQb2ludFZpZXcucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtYXJrUG9pbnRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIG1wTW9kZWwgPSBNYXJrZXJNb2RlbC5nZXRNYXJrZXJNb2RlbEZyb21TZXJpZXMoc2VyaWVzTW9kZWwsICdtYXJrUG9pbnQnKTtcblxuICAgICAgaWYgKG1wTW9kZWwpIHtcbiAgICAgICAgdXBkYXRlTWFya2VyTGF5b3V0KG1wTW9kZWwuZ2V0RGF0YSgpLCBzZXJpZXNNb2RlbCwgYXBpKTtcbiAgICAgICAgdGhpcy5tYXJrZXJHcm91cE1hcC5nZXQoc2VyaWVzTW9kZWwuaWQpLnVwZGF0ZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4gIE1hcmtQb2ludFZpZXcucHJvdG90eXBlLnJlbmRlclNlcmllcyA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgbXBNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgc2VyaWVzSWQgPSBzZXJpZXNNb2RlbC5pZDtcbiAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgc3ltYm9sRHJhd01hcCA9IHRoaXMubWFya2VyR3JvdXBNYXA7XG4gICAgdmFyIHN5bWJvbERyYXcgPSBzeW1ib2xEcmF3TWFwLmdldChzZXJpZXNJZCkgfHwgc3ltYm9sRHJhd01hcC5zZXQoc2VyaWVzSWQsIG5ldyBTeW1ib2xEcmF3KCkpO1xuICAgIHZhciBtcERhdGEgPSBjcmVhdGVMaXN0KGNvb3JkU3lzLCBzZXJpZXNNb2RlbCwgbXBNb2RlbCk7IC8vIEZJWE1FXG5cbiAgICBtcE1vZGVsLnNldERhdGEobXBEYXRhKTtcbiAgICB1cGRhdGVNYXJrZXJMYXlvdXQobXBNb2RlbC5nZXREYXRhKCksIHNlcmllc01vZGVsLCBhcGkpO1xuICAgIG1wRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBtcERhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICB2YXIgc3ltYm9sID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbCcpO1xuICAgICAgdmFyIHN5bWJvbFNpemUgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnc3ltYm9sU2l6ZScpO1xuICAgICAgdmFyIHN5bWJvbFJvdGF0ZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2xSb3RhdGUnKTtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24oc3ltYm9sKSB8fCBpc0Z1bmN0aW9uKHN5bWJvbFNpemUpIHx8IGlzRnVuY3Rpb24oc3ltYm9sUm90YXRlKSkge1xuICAgICAgICB2YXIgcmF3SWR4ID0gbXBNb2RlbC5nZXRSYXdWYWx1ZShpZHgpO1xuICAgICAgICB2YXIgZGF0YVBhcmFtcyA9IG1wTW9kZWwuZ2V0RGF0YVBhcmFtcyhpZHgpO1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHN5bWJvbCkpIHtcbiAgICAgICAgICBzeW1ib2wgPSBzeW1ib2wocmF3SWR4LCBkYXRhUGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHN5bWJvbFNpemUpKSB7XG4gICAgICAgICAgLy8gRklYTUUg6L+Z6YeM5LiN5YW85a65IEVDaGFydHMgMi5477yMMi54IOiyjOS8vOWPguaVsOaYr+aVtOS4quaVsOaNru+8n1xuICAgICAgICAgIHN5bWJvbFNpemUgPSBzeW1ib2xTaXplKHJhd0lkeCwgZGF0YVBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihzeW1ib2xSb3RhdGUpKSB7XG4gICAgICAgICAgc3ltYm9sUm90YXRlID0gc3ltYm9sUm90YXRlKHJhd0lkeCwgZGF0YVBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgIHZhciBjb2xvciA9IGdldFZpc3VhbEZyb21EYXRhKHNlcmllc0RhdGEsICdjb2xvcicpO1xuXG4gICAgICBpZiAoIXN0eWxlLmZpbGwpIHtcbiAgICAgICAgc3R5bGUuZmlsbCA9IGNvbG9yO1xuICAgICAgfVxuXG4gICAgICBtcERhdGEuc2V0SXRlbVZpc3VhbChpZHgsIHtcbiAgICAgICAgc3ltYm9sOiBzeW1ib2wsXG4gICAgICAgIHN5bWJvbFNpemU6IHN5bWJvbFNpemUsXG4gICAgICAgIHN5bWJvbFJvdGF0ZTogc3ltYm9sUm90YXRlLFxuICAgICAgICBzdHlsZTogc3R5bGVcbiAgICAgIH0pO1xuICAgIH0pOyAvLyBUT0RPIFRleHQgYXJlIHdyb25nXG5cbiAgICBzeW1ib2xEcmF3LnVwZGF0ZURhdGEobXBEYXRhKTtcbiAgICB0aGlzLmdyb3VwLmFkZChzeW1ib2xEcmF3Lmdyb3VwKTsgLy8gU2V0IGhvc3QgbW9kZWwgZm9yIHRvb2x0aXBcbiAgICAvLyBGSVhNRVxuXG4gICAgbXBEYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGdldEVDRGF0YShjaGlsZCkuZGF0YU1vZGVsID0gbXBNb2RlbDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMubWFya0tlZXAoc3ltYm9sRHJhdyk7XG4gICAgc3ltYm9sRHJhdy5ncm91cC5zaWxlbnQgPSBtcE1vZGVsLmdldCgnc2lsZW50JykgfHwgc2VyaWVzTW9kZWwuZ2V0KCdzaWxlbnQnKTtcbiAgfTtcblxuICBNYXJrUG9pbnRWaWV3LnR5cGUgPSAnbWFya1BvaW50JztcbiAgcmV0dXJuIE1hcmtQb2ludFZpZXc7XG59KE1hcmtlclZpZXcpO1xuXG5mdW5jdGlvbiBjcmVhdGVMaXN0KGNvb3JkU3lzLCBzZXJpZXNNb2RlbCwgbXBNb2RlbCkge1xuICB2YXIgY29vcmREaW1zSW5mb3M7XG5cbiAgaWYgKGNvb3JkU3lzKSB7XG4gICAgY29vcmREaW1zSW5mb3MgPSBtYXAoY29vcmRTeXMgJiYgY29vcmRTeXMuZGltZW5zaW9ucywgZnVuY3Rpb24gKGNvb3JkRGltKSB7XG4gICAgICB2YXIgaW5mbyA9IHNlcmllc01vZGVsLmdldERhdGEoKS5nZXREaW1lbnNpb25JbmZvKHNlcmllc01vZGVsLmdldERhdGEoKS5tYXBEaW1lbnNpb24oY29vcmREaW0pKSB8fCB7fTsgLy8gSW4gbWFwIHNlcmllcyBkYXRhIGRvbid0IGhhdmUgbG5nIGFuZCBsYXQgZGltZW5zaW9uLiBGYWxsYmFjayB0byBzYW1lIHdpdGggY29vcmRTeXNcblxuICAgICAgcmV0dXJuIGRlZmF1bHRzKHtcbiAgICAgICAgbmFtZTogY29vcmREaW1cbiAgICAgIH0sIGluZm8pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvb3JkRGltc0luZm9zID0gW3tcbiAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICB0eXBlOiAnZmxvYXQnXG4gICAgfV07XG4gIH1cblxuICB2YXIgbXBEYXRhID0gbmV3IExpc3QoY29vcmREaW1zSW5mb3MsIG1wTW9kZWwpO1xuICB2YXIgZGF0YU9wdCA9IG1hcChtcE1vZGVsLmdldCgnZGF0YScpLCBjdXJyeShtYXJrZXJIZWxwZXIuZGF0YVRyYW5zZm9ybSwgc2VyaWVzTW9kZWwpKTtcblxuICBpZiAoY29vcmRTeXMpIHtcbiAgICBkYXRhT3B0ID0gZmlsdGVyKGRhdGFPcHQsIGN1cnJ5KG1hcmtlckhlbHBlci5kYXRhRmlsdGVyLCBjb29yZFN5cykpO1xuICB9XG5cbiAgbXBEYXRhLmluaXREYXRhKGRhdGFPcHQsIG51bGwsIGNvb3JkU3lzID8gbWFya2VySGVscGVyLmRpbVZhbHVlR2V0dGVyIDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBtcERhdGE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcmtQb2ludFZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgZW52IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvZW52JztcbmltcG9ydCB7IERhdGFGb3JtYXRNaXhpbiB9IGZyb20gJy4uLy4uL21vZGVsL21peGluL2RhdGFGb3JtYXQnO1xuaW1wb3J0IENvbXBvbmVudE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL0NvbXBvbmVudCc7XG5pbXBvcnQgeyBtYWtlSW5uZXIsIGRlZmF1bHRFbXBoYXNpcyB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwnO1xuaW1wb3J0IHsgY3JlYXRlVG9vbHRpcE1hcmt1cCB9IGZyb20gJy4uL3Rvb2x0aXAvdG9vbHRpcE1hcmt1cCc7XG5cbmZ1bmN0aW9uIGZpbGxMYWJlbChvcHQpIHtcbiAgZGVmYXVsdEVtcGhhc2lzKG9wdCwgJ2xhYmVsJywgWydzaG93J10pO1xufSAvLyB7IFtjb21wb25lbnRUeXBlXTogTWFya2VyTW9kZWwgfVxuXG5cbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xuXG52YXIgTWFya2VyTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTWFya2VyTW9kZWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gTWFya2VyTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gTWFya2VyTW9kZWwudHlwZTtcbiAgICAvKipcbiAgICAgKiBJZiBtYXJrZXIgbW9kZWwgaXMgY3JlYXRlZCBieSBzZWxmIGZyb20gc2VyaWVzXG4gICAgICovXG5cbiAgICBfdGhpcy5jcmVhdGVkQnlTZWxmID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAb3ZlcnJpdGVcbiAgICovXG5cblxuICBNYXJrZXJNb2RlbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdtYXJrZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWFya2VyIGNvbXBvbmVudCBpcyBhYnN0cmFjdCBjb21wb25lbnQuIFVzZSBtYXJrTGluZSwgbWFya1BvaW50LCBtYXJrQXJlYSBpbnN0ZWFkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcblxuICAgIHRoaXMuX21lcmdlT3B0aW9uKG9wdGlvbiwgZWNNb2RlbCwgZmFsc2UsIHRydWUpO1xuICB9O1xuXG4gIE1hcmtlck1vZGVsLnByb3RvdHlwZS5pc0FuaW1hdGlvbkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGhvc3RTZXJpZXMgPSB0aGlzLl9faG9zdFNlcmllcztcbiAgICByZXR1cm4gdGhpcy5nZXRTaGFsbG93KCdhbmltYXRpb24nKSAmJiBob3N0U2VyaWVzICYmIGhvc3RTZXJpZXMuaXNBbmltYXRpb25FbmFibGVkKCk7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpdGVcbiAgICovXG5cblxuICBNYXJrZXJNb2RlbC5wcm90b3R5cGUubWVyZ2VPcHRpb24gPSBmdW5jdGlvbiAobmV3T3B0LCBlY01vZGVsKSB7XG4gICAgdGhpcy5fbWVyZ2VPcHRpb24obmV3T3B0LCBlY01vZGVsLCBmYWxzZSwgZmFsc2UpO1xuICB9O1xuXG4gIE1hcmtlck1vZGVsLnByb3RvdHlwZS5fbWVyZ2VPcHRpb24gPSBmdW5jdGlvbiAobmV3T3B0LCBlY01vZGVsLCBjcmVhdGVkQnlTZWxmLCBpc0luaXQpIHtcbiAgICB2YXIgY29tcG9uZW50VHlwZSA9IHRoaXMubWFpblR5cGU7XG5cbiAgICBpZiAoIWNyZWF0ZWRCeVNlbGYpIHtcbiAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgLy8gbWFpblR5cGUgY2FuIGJlIG1hcmtQb2ludCwgbWFya0xpbmUsIG1hcmtBcmVhXG4gICAgICAgIHZhciBtYXJrZXJPcHQgPSBzZXJpZXNNb2RlbC5nZXQodGhpcy5tYWluVHlwZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBtYXJrZXJNb2RlbCA9IGlubmVyKHNlcmllc01vZGVsKVtjb21wb25lbnRUeXBlXTtcblxuICAgICAgICBpZiAoIW1hcmtlck9wdCB8fCAhbWFya2VyT3B0LmRhdGEpIHtcbiAgICAgICAgICBpbm5lcihzZXJpZXNNb2RlbClbY29tcG9uZW50VHlwZV0gPSBudWxsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWFya2VyTW9kZWwpIHtcbiAgICAgICAgICBpZiAoaXNJbml0KSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGxhYmVsIGVtcGhhc2lzIGBwb3NpdGlvbmAgYW5kIGBzaG93YFxuICAgICAgICAgICAgZmlsbExhYmVsKG1hcmtlck9wdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgenJVdGlsLmVhY2gobWFya2VyT3B0LmRhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBPdmVyd3JpdGUgZmlsbExhYmVsIG1ldGhvZCA/XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgIGZpbGxMYWJlbChpdGVtWzBdKTtcbiAgICAgICAgICAgICAgZmlsbExhYmVsKGl0ZW1bMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmlsbExhYmVsKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1hcmtlck1vZGVsID0gdGhpcy5jcmVhdGVNYXJrZXJNb2RlbEZyb21TZXJpZXMobWFya2VyT3B0LCB0aGlzLCBlY01vZGVsKTsgLy8gbWFya2VyTW9kZWwgPSBuZXcgSW1wbGVtZW50ZWRNYXJrZXJNb2RlbChcbiAgICAgICAgICAvLyAgICAgbWFya2VyT3B0LCB0aGlzLCBlY01vZGVsXG4gICAgICAgICAgLy8gKTtcblxuICAgICAgICAgIHpyVXRpbC5leHRlbmQobWFya2VyTW9kZWwsIHtcbiAgICAgICAgICAgIG1haW5UeXBlOiB0aGlzLm1haW5UeXBlLFxuICAgICAgICAgICAgLy8gVXNlIHRoZSBzYW1lIHNlcmllcyBpbmRleCBhbmQgbmFtZVxuICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc01vZGVsLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgbmFtZTogc2VyaWVzTW9kZWwubmFtZSxcbiAgICAgICAgICAgIGNyZWF0ZWRCeVNlbGY6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtYXJrZXJNb2RlbC5fX2hvc3RTZXJpZXMgPSBzZXJpZXNNb2RlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXJrZXJNb2RlbC5fbWVyZ2VPcHRpb24obWFya2VyT3B0LCBlY01vZGVsLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlubmVyKHNlcmllc01vZGVsKVtjb21wb25lbnRUeXBlXSA9IG1hcmtlck1vZGVsO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIE1hcmtlck1vZGVsLnByb3RvdHlwZS5mb3JtYXRUb29sdGlwID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgbXVsdGlwbGVTZXJpZXMsIGRhdGFUeXBlKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoKTtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFJhd1ZhbHVlKGRhdGFJbmRleCk7XG4gICAgdmFyIGl0ZW1OYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCk7XG4gICAgcmV0dXJuIGNyZWF0ZVRvb2x0aXBNYXJrdXAoJ3NlY3Rpb24nLCB7XG4gICAgICBoZWFkZXI6IHRoaXMubmFtZSxcbiAgICAgIGJsb2NrczogW2NyZWF0ZVRvb2x0aXBNYXJrdXAoJ25hbWVWYWx1ZScsIHtcbiAgICAgICAgbmFtZTogaXRlbU5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbm9OYW1lOiAhaXRlbU5hbWUsXG4gICAgICAgIG5vVmFsdWU6IHZhbHVlID09IG51bGxcbiAgICAgIH0pXVxuICAgIH0pO1xuICB9O1xuXG4gIE1hcmtlck1vZGVsLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9O1xuXG4gIE1hcmtlck1vZGVsLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfTtcblxuICBNYXJrZXJNb2RlbC5nZXRNYXJrZXJNb2RlbEZyb21TZXJpZXMgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIC8vIFN1cHBvcnQgdGhyZWUgdHlwZXMgb2YgbWFya2Vycy4gU3RyaWN0IGNoZWNrLlxuICBjb21wb25lbnRUeXBlKSB7XG4gICAgcmV0dXJuIGlubmVyKHNlcmllc01vZGVsKVtjb21wb25lbnRUeXBlXTtcbiAgfTtcblxuICBNYXJrZXJNb2RlbC50eXBlID0gJ21hcmtlcic7XG4gIE1hcmtlck1vZGVsLmRlcGVuZGVuY2llcyA9IFsnc2VyaWVzJywgJ2dyaWQnLCAncG9sYXInLCAnZ2VvJ107XG4gIHJldHVybiBNYXJrZXJNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuXG56clV0aWwubWl4aW4oTWFya2VyTW9kZWwsIERhdGFGb3JtYXRNaXhpbi5wcm90b3R5cGUpO1xuZXhwb3J0IGRlZmF1bHQgTWFya2VyTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IENvbXBvbmVudFZpZXcgZnJvbSAnLi4vLi4vdmlldy9Db21wb25lbnQnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaE1hcCwgZWFjaCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgTWFya2VyTW9kZWwgZnJvbSAnLi9NYXJrZXJNb2RlbCc7XG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbmltcG9ydCB7IGVudGVyQmx1ciB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdGVzJztcbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xuXG52YXIgTWFya2VyVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNYXJrZXJWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE1hcmtlclZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gTWFya2VyVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIE1hcmtlclZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5tYXJrZXJHcm91cE1hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgfTtcblxuICBNYXJrZXJWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAobWFya2VyTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgbWFya2VyR3JvdXBNYXAgPSB0aGlzLm1hcmtlckdyb3VwTWFwO1xuICAgIG1hcmtlckdyb3VwTWFwLmVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlubmVyKGl0ZW0pLmtlZXAgPSBmYWxzZTtcbiAgICB9KTtcbiAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgbWFya2VyTW9kZWwgPSBNYXJrZXJNb2RlbC5nZXRNYXJrZXJNb2RlbEZyb21TZXJpZXMoc2VyaWVzTW9kZWwsIF90aGlzLnR5cGUpO1xuICAgICAgbWFya2VyTW9kZWwgJiYgX3RoaXMucmVuZGVyU2VyaWVzKHNlcmllc01vZGVsLCBtYXJrZXJNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICB9KTtcbiAgICBtYXJrZXJHcm91cE1hcC5lYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAhaW5uZXIoaXRlbSkua2VlcCAmJiBfdGhpcy5ncm91cC5yZW1vdmUoaXRlbS5ncm91cCk7XG4gICAgfSk7XG4gIH07XG5cbiAgTWFya2VyVmlldy5wcm90b3R5cGUubWFya0tlZXAgPSBmdW5jdGlvbiAoZHJhd0dyb3VwKSB7XG4gICAgaW5uZXIoZHJhd0dyb3VwKS5rZWVwID0gdHJ1ZTtcbiAgfTtcblxuICBNYXJrZXJWaWV3LnByb3RvdHlwZS5ibHVyU2VyaWVzID0gZnVuY3Rpb24gKHNlcmllc01vZGVsTGlzdCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBlYWNoKHNlcmllc01vZGVsTGlzdCwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgbWFya2VyTW9kZWwgPSBNYXJrZXJNb2RlbC5nZXRNYXJrZXJNb2RlbEZyb21TZXJpZXMoc2VyaWVzTW9kZWwsIF90aGlzLnR5cGUpO1xuXG4gICAgICBpZiAobWFya2VyTW9kZWwpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXJrZXJNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBlbnRlckJsdXIoZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgTWFya2VyVmlldy50eXBlID0gJ21hcmtlcic7XG4gIHJldHVybiBNYXJrZXJWaWV3O1xufShDb21wb25lbnRWaWV3KTtcblxuZXhwb3J0IGRlZmF1bHQgTWFya2VyVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IE1hcmtBcmVhTW9kZWwgZnJvbSAnLi9NYXJrQXJlYU1vZGVsJztcbmltcG9ydCBNYXJrQXJlYVZpZXcgZnJvbSAnLi9NYXJrQXJlYVZpZXcnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKE1hcmtBcmVhTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KE1hcmtBcmVhVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0KSB7XG4gICAgLy8gTWFrZSBzdXJlIG1hcmtBcmVhIGNvbXBvbmVudCBpcyBlbmFibGVkXG4gICAgb3B0Lm1hcmtBcmVhID0gb3B0Lm1hcmtBcmVhIHx8IHt9O1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuaW1wb3J0IE1hcmtMaW5lTW9kZWwgZnJvbSAnLi9NYXJrTGluZU1vZGVsJztcbmltcG9ydCBNYXJrTGluZVZpZXcgZnJvbSAnLi9NYXJrTGluZVZpZXcnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKE1hcmtMaW5lTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KE1hcmtMaW5lVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0KSB7XG4gICAgLy8gTWFrZSBzdXJlIG1hcmtMaW5lIGNvbXBvbmVudCBpcyBlbmFibGVkXG4gICAgb3B0Lm1hcmtMaW5lID0gb3B0Lm1hcmtMaW5lIHx8IHt9O1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuaW1wb3J0IE1hcmtQb2ludE1vZGVsIGZyb20gJy4vTWFya1BvaW50TW9kZWwnO1xuaW1wb3J0IE1hcmtQb2ludFZpZXcgZnJvbSAnLi9NYXJrUG9pbnRWaWV3JztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChNYXJrUG9pbnRNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoTWFya1BvaW50Vmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0KSB7XG4gICAgLy8gTWFrZSBzdXJlIG1hcmtQb2ludCBjb21wb25lbnQgaXMgZW5hYmxlZFxuICAgIG9wdC5tYXJrUG9pbnQgPSBvcHQubWFya1BvaW50IHx8IHt9O1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG5pbXBvcnQgeyBpc0RpbWVuc2lvblN0YWNrZWQgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9kYXRhU3RhY2tIZWxwZXInO1xuaW1wb3J0IHsgaW5kZXhPZiwgY3VycnksIGNsb25lLCBpc0FycmF5IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcblxuZnVuY3Rpb24gaGFzWE9yWShpdGVtKSB7XG4gIHJldHVybiAhKGlzTmFOKHBhcnNlRmxvYXQoaXRlbS54KSkgJiYgaXNOYU4ocGFyc2VGbG9hdChpdGVtLnkpKSk7XG59XG5cbmZ1bmN0aW9uIGhhc1hBbmRZKGl0ZW0pIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KGl0ZW0ueCkpICYmICFpc05hTihwYXJzZUZsb2F0KGl0ZW0ueSkpO1xufSAvLyBNYWtlIGl0IHNpbXBsZSwgZG8gbm90IHZpc2l0IGFsbCBzdGFja2VkIHZhbHVlIHRvIGNvdW50IHByZWNpc2lvbi5cbi8vIGZ1bmN0aW9uIGdldFByZWNpc2lvbihkYXRhLCB2YWx1ZUF4aXNEaW0sIGRhdGFJbmRleCkge1xuLy8gICAgIGxldCBwcmVjaXNpb24gPSAtMTtcbi8vICAgICBsZXQgc3RhY2tlZERpbSA9IGRhdGEubWFwRGltZW5zaW9uKHZhbHVlQXhpc0RpbSk7XG4vLyAgICAgZG8ge1xuLy8gICAgICAgICBwcmVjaXNpb24gPSBNYXRoLm1heChcbi8vICAgICAgICAgICAgIG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uKGRhdGEuZ2V0KHN0YWNrZWREaW0sIGRhdGFJbmRleCkpLFxuLy8gICAgICAgICAgICAgcHJlY2lzaW9uXG4vLyAgICAgICAgICk7XG4vLyAgICAgICAgIGxldCBzdGFja2VkT25TZXJpZXMgPSBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZE9uU2VyaWVzJyk7XG4vLyAgICAgICAgIGlmIChzdGFja2VkT25TZXJpZXMpIHtcbi8vICAgICAgICAgICAgIGxldCBieVZhbHVlID0gZGF0YS5nZXQoZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrZWRCeURpbWVuc2lvbicpLCBkYXRhSW5kZXgpO1xuLy8gICAgICAgICAgICAgZGF0YSA9IHN0YWNrZWRPblNlcmllcy5nZXREYXRhKCk7XG4vLyAgICAgICAgICAgICBkYXRhSW5kZXggPSBkYXRhLmluZGV4T2YoZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrZWRCeURpbWVuc2lvbicpLCBieVZhbHVlKTtcbi8vICAgICAgICAgICAgIHN0YWNrZWREaW0gPSBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZERpbWVuc2lvbicpO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgZGF0YSA9IG51bGw7XG4vLyAgICAgICAgIH1cbi8vICAgICB9IHdoaWxlIChkYXRhKTtcbi8vICAgICByZXR1cm4gcHJlY2lzaW9uO1xuLy8gfVxuXG5cbmZ1bmN0aW9uIG1hcmtlclR5cGVDYWxjdWxhdG9yV2l0aEV4dGVudChtYXJrZXJUeXBlLCBkYXRhLCBvdGhlckRhdGFEaW0sIHRhcmdldERhdGFEaW0sIG90aGVyQ29vcmRJbmRleCwgdGFyZ2V0Q29vcmRJbmRleCkge1xuICB2YXIgY29vcmRBcnIgPSBbXTtcbiAgdmFyIHN0YWNrZWQgPSBpc0RpbWVuc2lvblN0YWNrZWQoZGF0YSwgdGFyZ2V0RGF0YURpbVxuICAvKiwgb3RoZXJEYXRhRGltKi9cbiAgKTtcbiAgdmFyIGNhbGNEYXRhRGltID0gc3RhY2tlZCA/IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja1Jlc3VsdERpbWVuc2lvbicpIDogdGFyZ2V0RGF0YURpbTtcbiAgdmFyIHZhbHVlID0gbnVtQ2FsY3VsYXRlKGRhdGEsIGNhbGNEYXRhRGltLCBtYXJrZXJUeXBlKTtcbiAgdmFyIGRhdGFJbmRleCA9IGRhdGEuaW5kaWNlc09mTmVhcmVzdChjYWxjRGF0YURpbSwgdmFsdWUpWzBdO1xuICBjb29yZEFycltvdGhlckNvb3JkSW5kZXhdID0gZGF0YS5nZXQob3RoZXJEYXRhRGltLCBkYXRhSW5kZXgpO1xuICBjb29yZEFyclt0YXJnZXRDb29yZEluZGV4XSA9IGRhdGEuZ2V0KGNhbGNEYXRhRGltLCBkYXRhSW5kZXgpO1xuICB2YXIgY29vcmRBcnJWYWx1ZSA9IGRhdGEuZ2V0KHRhcmdldERhdGFEaW0sIGRhdGFJbmRleCk7IC8vIE1ha2UgaXQgc2ltcGxlLCBkbyBub3QgdmlzaXQgYWxsIHN0YWNrZWQgdmFsdWUgdG8gY291bnQgcHJlY2lzaW9uLlxuXG4gIHZhciBwcmVjaXNpb24gPSBudW1iZXJVdGlsLmdldFByZWNpc2lvbihkYXRhLmdldCh0YXJnZXREYXRhRGltLCBkYXRhSW5kZXgpKTtcbiAgcHJlY2lzaW9uID0gTWF0aC5taW4ocHJlY2lzaW9uLCAyMCk7XG5cbiAgaWYgKHByZWNpc2lvbiA+PSAwKSB7XG4gICAgY29vcmRBcnJbdGFyZ2V0Q29vcmRJbmRleF0gPSArY29vcmRBcnJbdGFyZ2V0Q29vcmRJbmRleF0udG9GaXhlZChwcmVjaXNpb24pO1xuICB9XG5cbiAgcmV0dXJuIFtjb29yZEFyciwgY29vcmRBcnJWYWx1ZV07XG59IC8vIFRPRE8gU3BlY2lmaWVkIHBlcmNlbnRcblxuXG52YXIgbWFya2VyVHlwZUNhbGN1bGF0b3IgPSB7XG4gIG1pbjogY3VycnkobWFya2VyVHlwZUNhbGN1bGF0b3JXaXRoRXh0ZW50LCAnbWluJyksXG4gIG1heDogY3VycnkobWFya2VyVHlwZUNhbGN1bGF0b3JXaXRoRXh0ZW50LCAnbWF4JyksXG4gIGF2ZXJhZ2U6IGN1cnJ5KG1hcmtlclR5cGVDYWxjdWxhdG9yV2l0aEV4dGVudCwgJ2F2ZXJhZ2UnKSxcbiAgbWVkaWFuOiBjdXJyeShtYXJrZXJUeXBlQ2FsY3VsYXRvcldpdGhFeHRlbnQsICdtZWRpYW4nKVxufTtcbi8qKlxuICogVHJhbnNmb3JtIG1hcmtQb2ludCBkYXRhIGl0ZW0gdG8gZm9ybWF0IHVzZWQgaW4gTGlzdCBieSBkbyB0aGUgZm9sbG93aW5nXG4gKiAxLiBDYWxjdWxhdGUgc3RhdGlzdGljIGxpa2UgYG1heGAsIGBtaW5gLCBgYXZlcmFnZWBcbiAqIDIuIENvbnZlcnQgYGl0ZW0ueEF4aXNgLCBgaXRlbS55QXhpc2AgdG8gYGl0ZW0uY29vcmRgIGFycmF5XG4gKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC8qfSBbY29vcmRTeXNdXG4gKiBAcGFyYW0gIHtPYmplY3R9IGl0ZW1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGF0YVRyYW5zZm9ybShzZXJpZXNNb2RlbCwgaXRlbSkge1xuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTsgLy8gMS4gSWYgbm90IHNwZWNpZnkgdGhlIHBvc2l0aW9uIHdpdGggcGl4ZWwgZGlyZWN0bHlcbiAgLy8gMi4gSWYgYGNvb3JkYCBpcyBub3QgYSBkYXRhIGFycmF5LiBXaGljaCB1c2VzIGB4QXhpc2AsXG4gIC8vIGB5QXhpc2AgdG8gc3BlY2lmeSB0aGUgY29vcmQgb24gZWFjaCBkaW1lbnNpb25cbiAgLy8gcGFyc2VGbG9hdCBmaXJzdCBiZWNhdXNlIGl0ZW0ueCBhbmQgaXRlbS55IGNhbiBiZSBwZXJjZW50IHN0cmluZyBsaWtlICcyMCUnXG5cbiAgaWYgKGl0ZW0gJiYgIWhhc1hBbmRZKGl0ZW0pICYmICFpc0FycmF5KGl0ZW0uY29vcmQpICYmIGNvb3JkU3lzKSB7XG4gICAgdmFyIGRpbXMgPSBjb29yZFN5cy5kaW1lbnNpb25zO1xuICAgIHZhciBheGlzSW5mbyA9IGdldEF4aXNJbmZvKGl0ZW0sIGRhdGEsIGNvb3JkU3lzLCBzZXJpZXNNb2RlbCk7IC8vIENsb25lIHRoZSBvcHRpb25cbiAgICAvLyBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgeEF4aXMsIHlBeGlzLCByYWRpdXNBeGlzLCBhbmdsZUF4aXMsIGdlb0Nvb3JkIHRvIHZhbHVlXG5cbiAgICBpdGVtID0gY2xvbmUoaXRlbSk7XG5cbiAgICBpZiAoaXRlbS50eXBlICYmIG1hcmtlclR5cGVDYWxjdWxhdG9yW2l0ZW0udHlwZV0gJiYgYXhpc0luZm8uYmFzZUF4aXMgJiYgYXhpc0luZm8udmFsdWVBeGlzKSB7XG4gICAgICB2YXIgb3RoZXJDb29yZEluZGV4ID0gaW5kZXhPZihkaW1zLCBheGlzSW5mby5iYXNlQXhpcy5kaW0pO1xuICAgICAgdmFyIHRhcmdldENvb3JkSW5kZXggPSBpbmRleE9mKGRpbXMsIGF4aXNJbmZvLnZhbHVlQXhpcy5kaW0pO1xuICAgICAgdmFyIGNvb3JkSW5mbyA9IG1hcmtlclR5cGVDYWxjdWxhdG9yW2l0ZW0udHlwZV0oZGF0YSwgYXhpc0luZm8uYmFzZURhdGFEaW0sIGF4aXNJbmZvLnZhbHVlRGF0YURpbSwgb3RoZXJDb29yZEluZGV4LCB0YXJnZXRDb29yZEluZGV4KTtcbiAgICAgIGl0ZW0uY29vcmQgPSBjb29yZEluZm9bMF07IC8vIEZvcmNlIHRvIHVzZSB0aGUgdmFsdWUgb2YgY2FsY3VsYXRlZCB2YWx1ZS5cbiAgICAgIC8vIGxldCBpdGVtIHVzZSB0aGUgdmFsdWUgd2l0aG91dCBzdGFjay5cblxuICAgICAgaXRlbS52YWx1ZSA9IGNvb3JkSW5mb1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRklYTUUgT25seSBoYXMgb25lIG9mIHhBeGlzIGFuZCB5QXhpcy5cbiAgICAgIHZhciBjb29yZCA9IFtpdGVtLnhBeGlzICE9IG51bGwgPyBpdGVtLnhBeGlzIDogaXRlbS5yYWRpdXNBeGlzLCBpdGVtLnlBeGlzICE9IG51bGwgPyBpdGVtLnlBeGlzIDogaXRlbS5hbmdsZUF4aXNdOyAvLyBFYWNoIGNvb3JkIHN1cHBvcnQgbWF4LCBtaW4sIGF2ZXJhZ2VcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgaWYgKG1hcmtlclR5cGVDYWxjdWxhdG9yW2Nvb3JkW2ldXSkge1xuICAgICAgICAgIGNvb3JkW2ldID0gbnVtQ2FsY3VsYXRlKGRhdGEsIGRhdGEubWFwRGltZW5zaW9uKGRpbXNbaV0pLCBjb29yZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXRlbS5jb29yZCA9IGNvb3JkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpdGVtO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEF4aXNJbmZvKGl0ZW0sIGRhdGEsIGNvb3JkU3lzLCBzZXJpZXNNb2RlbCkge1xuICB2YXIgcmV0ID0ge307XG5cbiAgaWYgKGl0ZW0udmFsdWVJbmRleCAhPSBudWxsIHx8IGl0ZW0udmFsdWVEaW0gIT0gbnVsbCkge1xuICAgIHJldC52YWx1ZURhdGFEaW0gPSBpdGVtLnZhbHVlSW5kZXggIT0gbnVsbCA/IGRhdGEuZ2V0RGltZW5zaW9uKGl0ZW0udmFsdWVJbmRleCkgOiBpdGVtLnZhbHVlRGltO1xuICAgIHJldC52YWx1ZUF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKGRhdGFEaW1Ub0Nvb3JkRGltKHNlcmllc01vZGVsLCByZXQudmFsdWVEYXRhRGltKSk7XG4gICAgcmV0LmJhc2VBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKHJldC52YWx1ZUF4aXMpO1xuICAgIHJldC5iYXNlRGF0YURpbSA9IGRhdGEubWFwRGltZW5zaW9uKHJldC5iYXNlQXhpcy5kaW0pO1xuICB9IGVsc2Uge1xuICAgIHJldC5iYXNlQXhpcyA9IHNlcmllc01vZGVsLmdldEJhc2VBeGlzKCk7XG4gICAgcmV0LnZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhyZXQuYmFzZUF4aXMpO1xuICAgIHJldC5iYXNlRGF0YURpbSA9IGRhdGEubWFwRGltZW5zaW9uKHJldC5iYXNlQXhpcy5kaW0pO1xuICAgIHJldC52YWx1ZURhdGFEaW0gPSBkYXRhLm1hcERpbWVuc2lvbihyZXQudmFsdWVBeGlzLmRpbSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkYXRhRGltVG9Db29yZERpbShzZXJpZXNNb2RlbCwgZGF0YURpbSkge1xuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIGRpbWVuc2lvbnMgPSBkYXRhLmRpbWVuc2lvbnM7XG4gIGRhdGFEaW0gPSBkYXRhLmdldERpbWVuc2lvbihkYXRhRGltKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGltSXRlbSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1lbnNpb25zW2ldKTtcblxuICAgIGlmIChkaW1JdGVtLm5hbWUgPT09IGRhdGFEaW0pIHtcbiAgICAgIHJldHVybiBkaW1JdGVtLmNvb3JkRGltO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGaWx0ZXIgZGF0YSB3aGljaCBpcyBvdXQgb2YgY29vcmRpbmF0ZVN5c3RlbSByYW5nZVxuICogW2RhdGFGaWx0ZXIgZGVzY3JpcHRpb25dXG4gKi9cblxuXG5leHBvcnQgZnVuY3Rpb24gZGF0YUZpbHRlciggLy8gQ3VycmVudGx5IG9ubHkgcG9sYXIgYW5kIGNhcnRlc2lhbiBoYXMgY29udGFpbkRhdGEuXG5jb29yZFN5cywgaXRlbSkge1xuICAvLyBBbHdhbHlzIHJldHVybiB0cnVlIGlmIHRoZXJlIGlzIG5vIGNvb3JkU3lzXG4gIHJldHVybiBjb29yZFN5cyAmJiBjb29yZFN5cy5jb250YWluRGF0YSAmJiBpdGVtLmNvb3JkICYmICFoYXNYT3JZKGl0ZW0pID8gY29vcmRTeXMuY29udGFpbkRhdGEoaXRlbS5jb29yZCkgOiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRpbVZhbHVlR2V0dGVyKGl0ZW0sIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpIHtcbiAgLy8geCwgeSwgcmFkaXVzLCBhbmdsZVxuICBpZiAoZGltSW5kZXggPCAyKSB7XG4gICAgcmV0dXJuIGl0ZW0uY29vcmQgJiYgaXRlbS5jb29yZFtkaW1JbmRleF07XG4gIH1cblxuICByZXR1cm4gaXRlbS52YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1DYWxjdWxhdGUoZGF0YSwgdmFsdWVEYXRhRGltLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnYXZlcmFnZScpIHtcbiAgICB2YXIgc3VtXzEgPSAwO1xuICAgIHZhciBjb3VudF8xID0gMDtcbiAgICBkYXRhLmVhY2godmFsdWVEYXRhRGltLCBmdW5jdGlvbiAodmFsLCBpZHgpIHtcbiAgICAgIGlmICghaXNOYU4odmFsKSkge1xuICAgICAgICBzdW1fMSArPSB2YWw7XG4gICAgICAgIGNvdW50XzErKztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3VtXzEgLyBjb3VudF8xO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtZWRpYW4nKSB7XG4gICAgcmV0dXJuIGRhdGEuZ2V0TWVkaWFuKHZhbHVlRGF0YURpbSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWF4ICYgbWluXG4gICAgcmV0dXJuIGRhdGEuZ2V0RGF0YUV4dGVudCh2YWx1ZURhdGFEaW0pW3R5cGUgPT09ICdtYXgnID8gMSA6IDBdO1xuICB9XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgdXNlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9uJztcbmltcG9ydCBBeGlzVmlldyBmcm9tICcuLi9heGlzL0F4aXNWaWV3JztcbmltcG9ydCBQb2xhckF4aXNQb2ludGVyIGZyb20gJy4uL2F4aXNQb2ludGVyL1BvbGFyQXhpc1BvaW50ZXInO1xuaW1wb3J0IHsgaW5zdGFsbCBhcyBpbnN0YWxsQXhpc1BvaW50ZXIgfSBmcm9tICcuLi9heGlzUG9pbnRlci9pbnN0YWxsJztcbmltcG9ydCBQb2xhck1vZGVsIGZyb20gJy4uLy4uL2Nvb3JkL3BvbGFyL1BvbGFyTW9kZWwnO1xuaW1wb3J0IGF4aXNNb2RlbENyZWF0b3IgZnJvbSAnLi4vLi4vY29vcmQvYXhpc01vZGVsQ3JlYXRvcic7XG5pbXBvcnQgeyBBbmdsZUF4aXNNb2RlbCwgUmFkaXVzQXhpc01vZGVsIH0gZnJvbSAnLi4vLi4vY29vcmQvcG9sYXIvQXhpc01vZGVsJztcbmltcG9ydCBwb2xhckNyZWF0b3IgZnJvbSAnLi4vLi4vY29vcmQvcG9sYXIvcG9sYXJDcmVhdG9yJztcbmltcG9ydCBBbmdsZUF4aXNWaWV3IGZyb20gJy4uL2F4aXMvQW5nbGVBeGlzVmlldyc7XG5pbXBvcnQgUmFkaXVzQXhpc1ZpZXcgZnJvbSAnLi4vYXhpcy9SYWRpdXNBeGlzVmlldyc7XG5pbXBvcnQgQ29tcG9uZW50VmlldyBmcm9tICcuLi8uLi92aWV3L0NvbXBvbmVudCc7XG5pbXBvcnQgeyBjdXJyeSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgYmFyTGF5b3V0UG9sYXIgZnJvbSAnLi4vLi4vbGF5b3V0L2JhclBvbGFyJztcbnZhciBhbmdsZUF4aXNFeHRyYU9wdGlvbiA9IHtcbiAgc3RhcnRBbmdsZTogOTAsXG4gIGNsb2Nrd2lzZTogdHJ1ZSxcbiAgc3BsaXROdW1iZXI6IDEyLFxuICBheGlzTGFiZWw6IHtcbiAgICByb3RhdGU6IDBcbiAgfVxufTtcbnZhciByYWRpdXNBeGlzRXh0cmFPcHRpb24gPSB7XG4gIHNwbGl0TnVtYmVyOiA1XG59O1xuXG52YXIgUG9sYXJWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBvbGFyVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBQb2xhclZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gUG9sYXJWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUG9sYXJWaWV3LnR5cGUgPSAncG9sYXInO1xuICByZXR1cm4gUG9sYXJWaWV3O1xufShDb21wb25lbnRWaWV3KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHVzZShpbnN0YWxsQXhpc1BvaW50ZXIpO1xuICBBeGlzVmlldy5yZWdpc3RlckF4aXNQb2ludGVyQ2xhc3MoJ1BvbGFyQXhpc1BvaW50ZXInLCBQb2xhckF4aXNQb2ludGVyKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29vcmRpbmF0ZVN5c3RlbSgncG9sYXInLCBwb2xhckNyZWF0b3IpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChQb2xhck1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhQb2xhclZpZXcpOyAvLyBNb2RlbCBhbmQgdmlldyBmb3IgYW5nbGVBeGlzIGFuZCByYWRpdXNBeGlzXG5cbiAgYXhpc01vZGVsQ3JlYXRvcihyZWdpc3RlcnMsICdhbmdsZScsIEFuZ2xlQXhpc01vZGVsLCBhbmdsZUF4aXNFeHRyYU9wdGlvbik7XG4gIGF4aXNNb2RlbENyZWF0b3IocmVnaXN0ZXJzLCAncmFkaXVzJywgUmFkaXVzQXhpc01vZGVsLCByYWRpdXNBeGlzRXh0cmFPcHRpb24pO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KEFuZ2xlQXhpc1ZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KFJhZGl1c0F4aXNWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KGN1cnJ5KGJhckxheW91dFBvbGFyLCAnYmFyJykpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IHVzZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbic7XG5pbXBvcnQgQ29tcG9uZW50VmlldyBmcm9tICcuLi8uLi92aWV3L0NvbXBvbmVudCc7XG5pbXBvcnQgU2luZ2xlQXhpc1ZpZXcgZnJvbSAnLi4vYXhpcy9TaW5nbGVBeGlzVmlldyc7XG5pbXBvcnQgYXhpc01vZGVsQ3JlYXRvciBmcm9tICcuLi8uLi9jb29yZC9heGlzTW9kZWxDcmVhdG9yJztcbmltcG9ydCBTaW5nbGVBeGlzTW9kZWwgZnJvbSAnLi4vLi4vY29vcmQvc2luZ2xlL0F4aXNNb2RlbCc7XG5pbXBvcnQgc2luZ2xlQ3JlYXRvciBmcm9tICcuLi8uLi9jb29yZC9zaW5nbGUvc2luZ2xlQ3JlYXRvcic7XG5pbXBvcnQgeyBpbnN0YWxsIGFzIGluc3RhbGxBeGlzUG9pbnRlciB9IGZyb20gJy4uL2F4aXNQb2ludGVyL2luc3RhbGwnO1xuaW1wb3J0IEF4aXNWaWV3IGZyb20gJy4uL2F4aXMvQXhpc1ZpZXcnO1xuaW1wb3J0IFNpbmdsZUF4aXNQb2ludGVyIGZyb20gJy4uL2F4aXNQb2ludGVyL1NpbmdsZUF4aXNQb2ludGVyJztcblxudmFyIFNpbmdsZVZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2luZ2xlVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTaW5nbGVWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IFNpbmdsZVZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBTaW5nbGVWaWV3LnR5cGUgPSAnc2luZ2xlJztcbiAgcmV0dXJuIFNpbmdsZVZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgdXNlKGluc3RhbGxBeGlzUG9pbnRlcik7XG4gIEF4aXNWaWV3LnJlZ2lzdGVyQXhpc1BvaW50ZXJDbGFzcygnU2luZ2xlQXhpc1BvaW50ZXInLCBTaW5nbGVBeGlzUG9pbnRlcik7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoU2luZ2xlVmlldyk7IC8vIEF4aXNcblxuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KFNpbmdsZUF4aXNWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50TW9kZWwoU2luZ2xlQXhpc01vZGVsKTtcbiAgYXhpc01vZGVsQ3JlYXRvcihyZWdpc3RlcnMsICdzaW5nbGUnLCBTaW5nbGVBeGlzTW9kZWwsIFNpbmdsZUF4aXNNb2RlbC5kZWZhdWx0T3B0aW9uKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29vcmRpbmF0ZVN5c3RlbSgnc2luZ2xlJywgc2luZ2xlQ3JlYXRvcik7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFRpbWVsaW5lTW9kZWwgZnJvbSAnLi9UaW1lbGluZU1vZGVsJztcbmltcG9ydCB7IERhdGFGb3JtYXRNaXhpbiB9IGZyb20gJy4uLy4uL21vZGVsL21peGluL2RhdGFGb3JtYXQnO1xuaW1wb3J0IHsgbWl4aW4gfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgaW5oZXJpdERlZmF1bHRPcHRpb24gfSBmcm9tICcuLi8uLi91dGlsL2NvbXBvbmVudCc7XG5cbnZhciBTbGlkZXJUaW1lbGluZU1vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNsaWRlclRpbWVsaW5lTW9kZWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU2xpZGVyVGltZWxpbmVNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBTbGlkZXJUaW1lbGluZU1vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU2xpZGVyVGltZWxpbmVNb2RlbC50eXBlID0gJ3RpbWVsaW5lLnNsaWRlcic7XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG4gIFNsaWRlclRpbWVsaW5lTW9kZWwuZGVmYXVsdE9wdGlvbiA9IGluaGVyaXREZWZhdWx0T3B0aW9uKFRpbWVsaW5lTW9kZWwuZGVmYXVsdE9wdGlvbiwge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgb3JpZW50OiAnaG9yaXpvbnRhbCcsXG4gICAgaW52ZXJzZTogZmFsc2UsXG4gICAgdG9vbHRpcDoge1xuICAgICAgdHJpZ2dlcjogJ2l0ZW0nIC8vIGRhdGEgaXRlbSBtYXkgYWxzbyBoYXZlIHRvb3RpcCBhdHRyLlxuXG4gICAgfSxcbiAgICBzeW1ib2w6ICdjaXJjbGUnLFxuICAgIHN5bWJvbFNpemU6IDEyLFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIHdpZHRoOiAyLFxuICAgICAgY29sb3I6ICcjREFFMUY1J1xuICAgIH0sXG4gICAgbGFiZWw6IHtcbiAgICAgIHBvc2l0aW9uOiAnYXV0bycsXG4gICAgICAvLyBXaGVuIHVzaW5nIG51bWJlciwgbGFiZWwgcG9zaXRpb24gaXMgbm90XG4gICAgICAvLyByZXN0cmljdGVkIGJ5IHZpZXdSZWN0LlxuICAgICAgLy8gcG9zaXRpdmU6IHJpZ2h0L2JvdHRvbSwgbmVnYXRpdmU6IGxlZnQvdG9wXG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgaW50ZXJ2YWw6ICdhdXRvJyxcbiAgICAgIHJvdGF0ZTogMCxcbiAgICAgIC8vIGZvcm1hdHRlcjogbnVsbCxcbiAgICAgIC8vIOWFtuS9meWxnuaAp+m7mOiupOS9v+eUqOWFqOWxgOaWh+acrOagt+W8j++8jOivpuingVRFWFRTVFlMRVxuICAgICAgY29sb3I6ICcjQTRCMUQ3J1xuICAgIH0sXG4gICAgaXRlbVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNBNEIxRDcnLFxuICAgICAgYm9yZGVyV2lkdGg6IDFcbiAgICB9LFxuICAgIGNoZWNrcG9pbnRTdHlsZToge1xuICAgICAgc3ltYm9sOiAnY2lyY2xlJyxcbiAgICAgIHN5bWJvbFNpemU6IDE1LFxuICAgICAgY29sb3I6ICcjMzE2YmYzJyxcbiAgICAgIGJvcmRlckNvbG9yOiAnI2ZmZicsXG4gICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgIHNoYWRvd0JsdXI6IDIsXG4gICAgICBzaGFkb3dPZmZzZXRYOiAxLFxuICAgICAgc2hhZG93T2Zmc2V0WTogMSxcbiAgICAgIHNoYWRvd0NvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjMpJyxcbiAgICAgIC8vIGJvcmRlckNvbG9yOiAncmdiYSgxOTQsNTMsNDksIDAuNSknLFxuICAgICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgICAgYW5pbWF0aW9uRHVyYXRpb246IDMwMCxcbiAgICAgIGFuaW1hdGlvbkVhc2luZzogJ3F1aW50aWNJbk91dCdcbiAgICB9LFxuICAgIGNvbnRyb2xTdHlsZToge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIHNob3dQbGF5QnRuOiB0cnVlLFxuICAgICAgc2hvd1ByZXZCdG46IHRydWUsXG4gICAgICBzaG93TmV4dEJ0bjogdHJ1ZSxcbiAgICAgIGl0ZW1TaXplOiAyNCxcbiAgICAgIGl0ZW1HYXA6IDEyLFxuICAgICAgcG9zaXRpb246ICdsZWZ0JyxcbiAgICAgIHBsYXlJY29uOiAncGF0aDovL00zMS42LDUzQzE3LjUsNTMsNiw0MS41LDYsMjcuNFMxNy41LDEuOCwzMS42LDEuOEM0NS43LDEuOCw1Ny4yLDEzLjMsNTcuMiwyNy40UzQ1LjcsNTMsMzEuNiw1M3ogTTMxLjYsMy4zIEMxOC40LDMuMyw3LjUsMTQuMSw3LjUsMjcuNGMwLDEzLjMsMTAuOCwyNC4xLDI0LjEsMjQuMUM0NC45LDUxLjUsNTUuNyw0MC43LDU1LjcsMjcuNEM1NS43LDE0LjEsNDQuOSwzLjMsMzEuNiwzLjN6IE0yNC45LDIxLjMgYzAtMi4yLDEuNi0zLjEsMy41LTJsMTAuNSw2LjFjMS44OTksMS4xLDEuODk5LDIuOSwwLDRsLTEwLjUsNi4xYy0xLjksMS4xLTMuNSwwLjItMy41LTJWMjEuM3onLFxuICAgICAgc3RvcEljb246ICdwYXRoOi8vTTMwLjksNTMuMkMxNi44LDUzLjIsNS4zLDQxLjcsNS4zLDI3LjZTMTYuOCwyLDMwLjksMkM0NSwyLDU2LjQsMTMuNSw1Ni40LDI3LjZTNDUsNTMuMiwzMC45LDUzLjJ6IE0zMC45LDMuNUMxNy42LDMuNSw2LjgsMTQuNCw2LjgsMjcuNmMwLDEzLjMsMTAuOCwyNC4xLDI0LjEwMSwyNC4xQzQ0LjIsNTEuNyw1NSw0MC45LDU1LDI3LjZDNTQuOSwxNC40LDQ0LjEsMy41LDMwLjksMy41eiBNMzYuOSwzNS44YzAsMC42MDEtMC40LDEtMC45LDFoLTEuM2MtMC41LDAtMC45LTAuMzk5LTAuOS0xVjE5LjVjMC0wLjYsMC40LTEsMC45LTFIMzZjMC41LDAsMC45LDAuNCwwLjksMVYzNS44eiBNMjcuOCwzNS44IGMwLDAuNjAxLTAuNCwxLTAuOSwxaC0xLjNjLTAuNSwwLTAuOS0wLjM5OS0wLjktMVYxOS41YzAtMC42LDAuNC0xLDAuOS0xSDI3YzAuNSwwLDAuOSwwLjQsMC45LDFMMjcuOCwzNS44TDI3LjgsMzUuOHonLFxuICAgICAgbmV4dEljb246ICdNMiwxOC41QTEuNTIsMS41MiwwLDAsMSwuOTIsMThhMS40OSwxLjQ5LDAsMCwxLDAtMi4xMkw3LjgxLDkuMzYsMSwzLjExQTEuNSwxLjUsMCwxLDEsMywuODlsOCw3LjM0YTEuNDgsMS40OCwwLDAsMSwuNDksMS4wOSwxLjUxLDEuNTEsMCwwLDEtLjQ2LDEuMUwzLDE4LjA4QTEuNSwxLjUsMCwwLDEsMiwxOC41WicsXG4gICAgICBwcmV2SWNvbjogJ00xMCwuNUExLjUyLDEuNTIsMCwwLDEsMTEuMDgsMWExLjQ5LDEuNDksMCwwLDEsMCwyLjEyTDQuMTksOS42NCwxMSwxNS44OWExLjUsMS41LDAsMSwxLTIsMi4yMkwxLDEwLjc3QTEuNDgsMS40OCwwLDAsMSwuNSw5LjY4LDEuNTEsMS41MSwwLDAsMSwxLDguNThMOSwuOTJBMS41LDEuNSwwLDAsMSwxMCwuNVonLFxuICAgICAgcHJldkJ0blNpemU6IDE4LFxuICAgICAgbmV4dEJ0blNpemU6IDE4LFxuICAgICAgY29sb3I6ICcjQTRCMUQ3JyxcbiAgICAgIGJvcmRlckNvbG9yOiAnI0E0QjFENycsXG4gICAgICBib3JkZXJXaWR0aDogMVxuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIC8vIOWFtuS9meWxnuaAp+m7mOiupOS9v+eUqOWFqOWxgOaWh+acrOagt+W8j++8jOivpuingVRFWFRTVFlMRVxuICAgICAgICBjb2xvcjogJyM2Zjc3OGQnXG4gICAgICB9LFxuICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAnIzMxNkJGMydcbiAgICAgIH0sXG4gICAgICBjb250cm9sU3R5bGU6IHtcbiAgICAgICAgY29sb3I6ICcjMzE2QkYzJyxcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMzE2QkYzJyxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDJcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb2dyZXNzOiB7XG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgY29sb3I6ICcjMzE2QkYzJ1xuICAgICAgfSxcbiAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICBjb2xvcjogJyMzMTZCRjMnXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgY29sb3I6ICcjNmY3NzhkJ1xuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogW11cbiAgfSk7XG4gIHJldHVybiBTbGlkZXJUaW1lbGluZU1vZGVsO1xufShUaW1lbGluZU1vZGVsKTtcblxubWl4aW4oU2xpZGVyVGltZWxpbmVNb2RlbCwgRGF0YUZvcm1hdE1peGluLnByb3RvdHlwZSk7XG5leHBvcnQgZGVmYXVsdCBTbGlkZXJUaW1lbGluZU1vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBCb3VuZGluZ1JlY3QgZnJvbSAnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnO1xuaW1wb3J0ICogYXMgbWF0cml4IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4JztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCB7IGNyZWF0ZVRleHRTdHlsZSB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUnO1xuaW1wb3J0ICogYXMgbGF5b3V0IGZyb20gJy4uLy4uL3V0aWwvbGF5b3V0JztcbmltcG9ydCBUaW1lbGluZVZpZXcgZnJvbSAnLi9UaW1lbGluZVZpZXcnO1xuaW1wb3J0IFRpbWVsaW5lQXhpcyBmcm9tICcuL1RpbWVsaW5lQXhpcyc7XG5pbXBvcnQgeyBjcmVhdGVTeW1ib2wgfSBmcm9tICcuLi8uLi91dGlsL3N5bWJvbCc7XG5pbXBvcnQgKiBhcyBudW1iZXJVdGlsIGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyJztcbmltcG9ydCB7IG1lcmdlLCBlYWNoLCBleHRlbmQsIGlzU3RyaW5nLCBiaW5kLCBkZWZhdWx0cywgcmV0cmlldmUyIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBPcmRpbmFsU2NhbGUgZnJvbSAnLi4vLi4vc2NhbGUvT3JkaW5hbCc7XG5pbXBvcnQgVGltZVNjYWxlIGZyb20gJy4uLy4uL3NjYWxlL1RpbWUnO1xuaW1wb3J0IEludGVydmFsU2NhbGUgZnJvbSAnLi4vLi4vc2NhbGUvSW50ZXJ2YWwnO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50IH0gZnJvbSAnenJlbmRlci9saWIvY29udGFpbi90ZXh0JztcbmltcG9ydCB7IG1ha2VJbm5lciB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlJztcbmltcG9ydCB7IGVuYWJsZUhvdmVyRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcyc7XG5pbXBvcnQgeyBjcmVhdGVUb29sdGlwTWFya3VwIH0gZnJvbSAnLi4vdG9vbHRpcC90b29sdGlwTWFya3VwJztcbnZhciBQSSA9IE1hdGguUEk7XG52YXIgbGFiZWxEYXRhSW5kZXhTdG9yZSA9IG1ha2VJbm5lcigpO1xuXG52YXIgU2xpZGVyVGltZWxpbmVWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNsaWRlclRpbWVsaW5lVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTbGlkZXJUaW1lbGluZVZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gU2xpZGVyVGltZWxpbmVWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuYXBpID0gYXBpO1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodGltZWxpbmVNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5tb2RlbCA9IHRpbWVsaW5lTW9kZWw7XG4gICAgdGhpcy5hcGkgPSBhcGk7XG4gICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgaWYgKHRpbWVsaW5lTW9kZWwuZ2V0KCdzaG93JywgdHJ1ZSkpIHtcbiAgICAgIHZhciBsYXlvdXRJbmZvXzEgPSB0aGlzLl9sYXlvdXQodGltZWxpbmVNb2RlbCwgYXBpKTtcblxuICAgICAgdmFyIG1haW5Hcm91cF8xID0gdGhpcy5fY3JlYXRlR3JvdXAoJ19tYWluR3JvdXAnKTtcblxuICAgICAgdmFyIGxhYmVsR3JvdXAgPSB0aGlzLl9jcmVhdGVHcm91cCgnX2xhYmVsR3JvdXAnKTtcblxuICAgICAgdmFyIGF4aXNfMSA9IHRoaXMuX2F4aXMgPSB0aGlzLl9jcmVhdGVBeGlzKGxheW91dEluZm9fMSwgdGltZWxpbmVNb2RlbCk7XG5cbiAgICAgIHRpbWVsaW5lTW9kZWwuZm9ybWF0VG9vbHRpcCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBheGlzXzEuc2NhbGUuZ2V0TGFiZWwoe1xuICAgICAgICAgIHZhbHVlOiBkYXRhSW5kZXhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVUb29sdGlwTWFya3VwKCduYW1lVmFsdWUnLCB7XG4gICAgICAgICAgbm9OYW1lOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBuYW1lXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZWFjaChbJ0F4aXNMaW5lJywgJ0F4aXNUaWNrJywgJ0NvbnRyb2wnLCAnQ3VycmVudFBvaW50ZXInXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpc1snX3JlbmRlcicgKyBuYW1lXShsYXlvdXRJbmZvXzEsIG1haW5Hcm91cF8xLCBheGlzXzEsIHRpbWVsaW5lTW9kZWwpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHRoaXMuX3JlbmRlckF4aXNMYWJlbChsYXlvdXRJbmZvXzEsIGxhYmVsR3JvdXAsIGF4aXNfMSwgdGltZWxpbmVNb2RlbCk7XG5cbiAgICAgIHRoaXMuX3Bvc2l0aW9uKGxheW91dEluZm9fMSwgdGltZWxpbmVNb2RlbCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZG9QbGF5U3RvcCgpO1xuXG4gICAgdGhpcy5fdXBkYXRlVGlja3NTdGF0dXMoKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIFNsaWRlclRpbWVsaW5lVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NsZWFyVGltZXIoKTtcblxuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xlYXJUaW1lcigpO1xuICB9O1xuXG4gIFNsaWRlclRpbWVsaW5lVmlldy5wcm90b3R5cGUuX2xheW91dCA9IGZ1bmN0aW9uICh0aW1lbGluZU1vZGVsLCBhcGkpIHtcbiAgICB2YXIgbGFiZWxQb3NPcHQgPSB0aW1lbGluZU1vZGVsLmdldChbJ2xhYmVsJywgJ3Bvc2l0aW9uJ10pO1xuICAgIHZhciBvcmllbnQgPSB0aW1lbGluZU1vZGVsLmdldCgnb3JpZW50Jyk7XG4gICAgdmFyIHZpZXdSZWN0ID0gZ2V0Vmlld1JlY3QodGltZWxpbmVNb2RlbCwgYXBpKTtcbiAgICB2YXIgcGFyc2VkTGFiZWxQb3M7IC8vIEF1dG8gbGFiZWwgb2Zmc2V0LlxuXG4gICAgaWYgKGxhYmVsUG9zT3B0ID09IG51bGwgfHwgbGFiZWxQb3NPcHQgPT09ICdhdXRvJykge1xuICAgICAgcGFyc2VkTGFiZWxQb3MgPSBvcmllbnQgPT09ICdob3Jpem9udGFsJyA/IHZpZXdSZWN0LnkgKyB2aWV3UmVjdC5oZWlnaHQgLyAyIDwgYXBpLmdldEhlaWdodCgpIC8gMiA/ICctJyA6ICcrJyA6IHZpZXdSZWN0LnggKyB2aWV3UmVjdC53aWR0aCAvIDIgPCBhcGkuZ2V0V2lkdGgoKSAvIDIgPyAnKycgOiAnLSc7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhsYWJlbFBvc09wdCkpIHtcbiAgICAgIHBhcnNlZExhYmVsUG9zID0ge1xuICAgICAgICBob3Jpem9udGFsOiB7XG4gICAgICAgICAgdG9wOiAnLScsXG4gICAgICAgICAgYm90dG9tOiAnKydcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWw6IHtcbiAgICAgICAgICBsZWZ0OiAnLScsXG4gICAgICAgICAgcmlnaHQ6ICcrJ1xuICAgICAgICB9XG4gICAgICB9W29yaWVudF1bbGFiZWxQb3NPcHRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpcyBudW1iZXJcbiAgICAgIHBhcnNlZExhYmVsUG9zID0gbGFiZWxQb3NPcHQ7XG4gICAgfVxuXG4gICAgdmFyIGxhYmVsQWxpZ25NYXAgPSB7XG4gICAgICBob3Jpem9udGFsOiAnY2VudGVyJyxcbiAgICAgIHZlcnRpY2FsOiBwYXJzZWRMYWJlbFBvcyA+PSAwIHx8IHBhcnNlZExhYmVsUG9zID09PSAnKycgPyAnbGVmdCcgOiAncmlnaHQnXG4gICAgfTtcbiAgICB2YXIgbGFiZWxCYXNlbGluZU1hcCA9IHtcbiAgICAgIGhvcml6b250YWw6IHBhcnNlZExhYmVsUG9zID49IDAgfHwgcGFyc2VkTGFiZWxQb3MgPT09ICcrJyA/ICd0b3AnIDogJ2JvdHRvbScsXG4gICAgICB2ZXJ0aWNhbDogJ21pZGRsZSdcbiAgICB9O1xuICAgIHZhciByb3RhdGlvbk1hcCA9IHtcbiAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICB2ZXJ0aWNhbDogUEkgLyAyXG4gICAgfTsgLy8gUG9zaXRpb25cblxuICAgIHZhciBtYWluTGVuZ3RoID0gb3JpZW50ID09PSAndmVydGljYWwnID8gdmlld1JlY3QuaGVpZ2h0IDogdmlld1JlY3Qud2lkdGg7XG4gICAgdmFyIGNvbnRyb2xNb2RlbCA9IHRpbWVsaW5lTW9kZWwuZ2V0TW9kZWwoJ2NvbnRyb2xTdHlsZScpO1xuICAgIHZhciBzaG93Q29udHJvbCA9IGNvbnRyb2xNb2RlbC5nZXQoJ3Nob3cnLCB0cnVlKTtcbiAgICB2YXIgY29udHJvbFNpemUgPSBzaG93Q29udHJvbCA/IGNvbnRyb2xNb2RlbC5nZXQoJ2l0ZW1TaXplJykgOiAwO1xuICAgIHZhciBjb250cm9sR2FwID0gc2hvd0NvbnRyb2wgPyBjb250cm9sTW9kZWwuZ2V0KCdpdGVtR2FwJykgOiAwO1xuICAgIHZhciBzaXplUGx1c0dhcCA9IGNvbnRyb2xTaXplICsgY29udHJvbEdhcDsgLy8gU3BlY2lhbCBsYWJlbCByb3RhdGUuXG5cbiAgICB2YXIgbGFiZWxSb3RhdGlvbiA9IHRpbWVsaW5lTW9kZWwuZ2V0KFsnbGFiZWwnLCAncm90YXRlJ10pIHx8IDA7XG4gICAgbGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb24gKiBQSSAvIDE4MDsgLy8gVG8gcmFkaWFuLlxuXG4gICAgdmFyIHBsYXlQb3NpdGlvbjtcbiAgICB2YXIgcHJldkJ0blBvc2l0aW9uO1xuICAgIHZhciBuZXh0QnRuUG9zaXRpb247XG4gICAgdmFyIGNvbnRyb2xQb3NpdGlvbiA9IGNvbnRyb2xNb2RlbC5nZXQoJ3Bvc2l0aW9uJywgdHJ1ZSk7XG4gICAgdmFyIHNob3dQbGF5QnRuID0gc2hvd0NvbnRyb2wgJiYgY29udHJvbE1vZGVsLmdldCgnc2hvd1BsYXlCdG4nLCB0cnVlKTtcbiAgICB2YXIgc2hvd1ByZXZCdG4gPSBzaG93Q29udHJvbCAmJiBjb250cm9sTW9kZWwuZ2V0KCdzaG93UHJldkJ0bicsIHRydWUpO1xuICAgIHZhciBzaG93TmV4dEJ0biA9IHNob3dDb250cm9sICYmIGNvbnRyb2xNb2RlbC5nZXQoJ3Nob3dOZXh0QnRuJywgdHJ1ZSk7XG4gICAgdmFyIHhMZWZ0ID0gMDtcbiAgICB2YXIgeFJpZ2h0ID0gbWFpbkxlbmd0aDsgLy8gcG9zaXRpb25bMF0gbWVhbnMgbGVmdCwgcG9zaXRpb25bMV0gbWVhbnMgbWlkZGxlLlxuXG4gICAgaWYgKGNvbnRyb2xQb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IGNvbnRyb2xQb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHNob3dQbGF5QnRuICYmIChwbGF5UG9zaXRpb24gPSBbMCwgMF0sIHhMZWZ0ICs9IHNpemVQbHVzR2FwKTtcbiAgICAgIHNob3dQcmV2QnRuICYmIChwcmV2QnRuUG9zaXRpb24gPSBbeExlZnQsIDBdLCB4TGVmdCArPSBzaXplUGx1c0dhcCk7XG4gICAgICBzaG93TmV4dEJ0biAmJiAobmV4dEJ0blBvc2l0aW9uID0gW3hSaWdodCAtIGNvbnRyb2xTaXplLCAwXSwgeFJpZ2h0IC09IHNpemVQbHVzR2FwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gJ3RvcCcgJ3JpZ2h0J1xuICAgICAgc2hvd1BsYXlCdG4gJiYgKHBsYXlQb3NpdGlvbiA9IFt4UmlnaHQgLSBjb250cm9sU2l6ZSwgMF0sIHhSaWdodCAtPSBzaXplUGx1c0dhcCk7XG4gICAgICBzaG93UHJldkJ0biAmJiAocHJldkJ0blBvc2l0aW9uID0gWzAsIDBdLCB4TGVmdCArPSBzaXplUGx1c0dhcCk7XG4gICAgICBzaG93TmV4dEJ0biAmJiAobmV4dEJ0blBvc2l0aW9uID0gW3hSaWdodCAtIGNvbnRyb2xTaXplLCAwXSwgeFJpZ2h0IC09IHNpemVQbHVzR2FwKTtcbiAgICB9XG5cbiAgICB2YXIgYXhpc0V4dGVudCA9IFt4TGVmdCwgeFJpZ2h0XTtcblxuICAgIGlmICh0aW1lbGluZU1vZGVsLmdldCgnaW52ZXJzZScpKSB7XG4gICAgICBheGlzRXh0ZW50LnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmlld1JlY3Q6IHZpZXdSZWN0LFxuICAgICAgbWFpbkxlbmd0aDogbWFpbkxlbmd0aCxcbiAgICAgIG9yaWVudDogb3JpZW50LFxuICAgICAgcm90YXRpb246IHJvdGF0aW9uTWFwW29yaWVudF0sXG4gICAgICBsYWJlbFJvdGF0aW9uOiBsYWJlbFJvdGF0aW9uLFxuICAgICAgbGFiZWxQb3NPcHQ6IHBhcnNlZExhYmVsUG9zLFxuICAgICAgbGFiZWxBbGlnbjogdGltZWxpbmVNb2RlbC5nZXQoWydsYWJlbCcsICdhbGlnbiddKSB8fCBsYWJlbEFsaWduTWFwW29yaWVudF0sXG4gICAgICBsYWJlbEJhc2VsaW5lOiB0aW1lbGluZU1vZGVsLmdldChbJ2xhYmVsJywgJ3ZlcnRpY2FsQWxpZ24nXSkgfHwgdGltZWxpbmVNb2RlbC5nZXQoWydsYWJlbCcsICdiYXNlbGluZSddKSB8fCBsYWJlbEJhc2VsaW5lTWFwW29yaWVudF0sXG4gICAgICAvLyBCYXNlZCBvbiBtYWluR3JvdXAuXG4gICAgICBwbGF5UG9zaXRpb246IHBsYXlQb3NpdGlvbixcbiAgICAgIHByZXZCdG5Qb3NpdGlvbjogcHJldkJ0blBvc2l0aW9uLFxuICAgICAgbmV4dEJ0blBvc2l0aW9uOiBuZXh0QnRuUG9zaXRpb24sXG4gICAgICBheGlzRXh0ZW50OiBheGlzRXh0ZW50LFxuICAgICAgY29udHJvbFNpemU6IGNvbnRyb2xTaXplLFxuICAgICAgY29udHJvbEdhcDogY29udHJvbEdhcFxuICAgIH07XG4gIH07XG5cbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5fcG9zaXRpb24gPSBmdW5jdGlvbiAobGF5b3V0SW5mbywgdGltZWxpbmVNb2RlbCkge1xuICAgIC8vIFBvc2l0aW9uIGlzIGJlIGNhbGxlZCBmaW5hbGx5LCBiZWNhdXNlIGJvdW5kaW5nIHJlY3QgaXMgbmVlZGVkIGZvclxuICAgIC8vIGFkYXB0IGNvbnRlbnQgdG8gZmlsbCB2aWV3UmVjdCAoYXV0byBhZGFwdCBvZmZzZXQpLlxuICAgIC8vIFRpbWVsaW5lIG1heSBiZSBub3QgYWxsIGluIHRoZSB2aWV3UmVjdCB3aGVuICdvZmZzZXQnIGlzIHNwZWNpZmllZFxuICAgIC8vIGFzIGEgbnVtYmVyLCBiZWNhdXNlIGl0IGlzIG1vcmUgYXBwcm9wcmlhdGUgdGhhdCBsYWJlbCBhbGlnbnMgYXRcbiAgICAvLyAnb2Zmc2V0JyBidXQgbm90IHRoZSBvdGhlciBlZGdlIGRlZmluZWQgYnkgdmlld1JlY3QuXG4gICAgdmFyIG1haW5Hcm91cCA9IHRoaXMuX21haW5Hcm91cDtcbiAgICB2YXIgbGFiZWxHcm91cCA9IHRoaXMuX2xhYmVsR3JvdXA7XG4gICAgdmFyIHZpZXdSZWN0ID0gbGF5b3V0SW5mby52aWV3UmVjdDtcblxuICAgIGlmIChsYXlvdXRJbmZvLm9yaWVudCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgLy8gdHJhbnNmb3JtIHRvIGhvcml6b250YWwsIGludmVyc2Ugcm90YXRlIGJ5IGxlZnQtdG9wIHBvaW50LlxuICAgICAgdmFyIG0gPSBtYXRyaXguY3JlYXRlKCk7XG4gICAgICB2YXIgcm90YXRlT3JpZ2luWCA9IHZpZXdSZWN0Lng7XG4gICAgICB2YXIgcm90YXRlT3JpZ2luWSA9IHZpZXdSZWN0LnkgKyB2aWV3UmVjdC5oZWlnaHQ7XG4gICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstcm90YXRlT3JpZ2luWCwgLXJvdGF0ZU9yaWdpblldKTtcbiAgICAgIG1hdHJpeC5yb3RhdGUobSwgbSwgLVBJIC8gMik7XG4gICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFtyb3RhdGVPcmlnaW5YLCByb3RhdGVPcmlnaW5ZXSk7XG4gICAgICB2aWV3UmVjdCA9IHZpZXdSZWN0LmNsb25lKCk7XG4gICAgICB2aWV3UmVjdC5hcHBseVRyYW5zZm9ybShtKTtcbiAgICB9XG5cbiAgICB2YXIgdmlld0JvdW5kID0gZ2V0Qm91bmQodmlld1JlY3QpO1xuICAgIHZhciBtYWluQm91bmQgPSBnZXRCb3VuZChtYWluR3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgIHZhciBsYWJlbEJvdW5kID0gZ2V0Qm91bmQobGFiZWxHcm91cC5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgdmFyIG1haW5Qb3NpdGlvbiA9IFttYWluR3JvdXAueCwgbWFpbkdyb3VwLnldO1xuICAgIHZhciBsYWJlbHNQb3NpdGlvbiA9IFtsYWJlbEdyb3VwLngsIGxhYmVsR3JvdXAueV07XG4gICAgbGFiZWxzUG9zaXRpb25bMF0gPSBtYWluUG9zaXRpb25bMF0gPSB2aWV3Qm91bmRbMF1bMF07XG4gICAgdmFyIGxhYmVsUG9zT3B0ID0gbGF5b3V0SW5mby5sYWJlbFBvc09wdDtcblxuICAgIGlmIChsYWJlbFBvc09wdCA9PSBudWxsIHx8IGlzU3RyaW5nKGxhYmVsUG9zT3B0KSkge1xuICAgICAgLy8gJysnIG9yICctJ1xuICAgICAgdmFyIG1haW5Cb3VuZElkeCA9IGxhYmVsUG9zT3B0ID09PSAnKycgPyAwIDogMTtcbiAgICAgIHRvQm91bmQobWFpblBvc2l0aW9uLCBtYWluQm91bmQsIHZpZXdCb3VuZCwgMSwgbWFpbkJvdW5kSWR4KTtcbiAgICAgIHRvQm91bmQobGFiZWxzUG9zaXRpb24sIGxhYmVsQm91bmQsIHZpZXdCb3VuZCwgMSwgMSAtIG1haW5Cb3VuZElkeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYWluQm91bmRJZHggPSBsYWJlbFBvc09wdCA+PSAwID8gMCA6IDE7XG4gICAgICB0b0JvdW5kKG1haW5Qb3NpdGlvbiwgbWFpbkJvdW5kLCB2aWV3Qm91bmQsIDEsIG1haW5Cb3VuZElkeCk7XG4gICAgICBsYWJlbHNQb3NpdGlvblsxXSA9IG1haW5Qb3NpdGlvblsxXSArIGxhYmVsUG9zT3B0O1xuICAgIH1cblxuICAgIG1haW5Hcm91cC5zZXRQb3NpdGlvbihtYWluUG9zaXRpb24pO1xuICAgIGxhYmVsR3JvdXAuc2V0UG9zaXRpb24obGFiZWxzUG9zaXRpb24pO1xuICAgIG1haW5Hcm91cC5yb3RhdGlvbiA9IGxhYmVsR3JvdXAucm90YXRpb24gPSBsYXlvdXRJbmZvLnJvdGF0aW9uO1xuICAgIHNldE9yaWdpbihtYWluR3JvdXApO1xuICAgIHNldE9yaWdpbihsYWJlbEdyb3VwKTtcblxuICAgIGZ1bmN0aW9uIHNldE9yaWdpbih0YXJnZXRHcm91cCkge1xuICAgICAgdGFyZ2V0R3JvdXAub3JpZ2luWCA9IHZpZXdCb3VuZFswXVswXSAtIHRhcmdldEdyb3VwLng7XG4gICAgICB0YXJnZXRHcm91cC5vcmlnaW5ZID0gdmlld0JvdW5kWzFdWzBdIC0gdGFyZ2V0R3JvdXAueTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb3VuZChyZWN0KSB7XG4gICAgICAvLyBbW3htaW4sIHhtYXhdLCBbeW1pbiwgeW1heF1dXG4gICAgICByZXR1cm4gW1tyZWN0LngsIHJlY3QueCArIHJlY3Qud2lkdGhdLCBbcmVjdC55LCByZWN0LnkgKyByZWN0LmhlaWdodF1dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQm91bmQoZnJvbVBvcywgZnJvbSwgdG8sIGRpbUlkeCwgYm91bmRJZHgpIHtcbiAgICAgIGZyb21Qb3NbZGltSWR4XSArPSB0b1tkaW1JZHhdW2JvdW5kSWR4XSAtIGZyb21bZGltSWR4XVtib3VuZElkeF07XG4gICAgfVxuICB9O1xuXG4gIFNsaWRlclRpbWVsaW5lVmlldy5wcm90b3R5cGUuX2NyZWF0ZUF4aXMgPSBmdW5jdGlvbiAobGF5b3V0SW5mbywgdGltZWxpbmVNb2RlbCkge1xuICAgIHZhciBkYXRhID0gdGltZWxpbmVNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGF4aXNUeXBlID0gdGltZWxpbmVNb2RlbC5nZXQoJ2F4aXNUeXBlJyk7XG4gICAgdmFyIHNjYWxlID0gY3JlYXRlU2NhbGVCeU1vZGVsKHRpbWVsaW5lTW9kZWwsIGF4aXNUeXBlKTsgLy8gQ3VzdG9taXplIHNjYWxlLiBUaGUgYHRpY2tWYWx1ZWAgaXMgYGRhdGFJbmRleGAuXG5cbiAgICBzY2FsZS5nZXRUaWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkYXRhLm1hcEFycmF5KFsndmFsdWUnXSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGRhdGFFeHRlbnQgPSBkYXRhLmdldERhdGFFeHRlbnQoJ3ZhbHVlJyk7XG4gICAgc2NhbGUuc2V0RXh0ZW50KGRhdGFFeHRlbnRbMF0sIGRhdGFFeHRlbnRbMV0pO1xuICAgIHNjYWxlLm5pY2VUaWNrcygpO1xuICAgIHZhciBheGlzID0gbmV3IFRpbWVsaW5lQXhpcygndmFsdWUnLCBzY2FsZSwgbGF5b3V0SW5mby5heGlzRXh0ZW50LCBheGlzVHlwZSk7XG4gICAgYXhpcy5tb2RlbCA9IHRpbWVsaW5lTW9kZWw7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5fY3JlYXRlR3JvdXAgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIG5ld0dyb3VwID0gdGhpc1trZXldID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICB0aGlzLmdyb3VwLmFkZChuZXdHcm91cCk7XG4gICAgcmV0dXJuIG5ld0dyb3VwO1xuICB9O1xuXG4gIFNsaWRlclRpbWVsaW5lVmlldy5wcm90b3R5cGUuX3JlbmRlckF4aXNMaW5lID0gZnVuY3Rpb24gKGxheW91dEluZm8sIGdyb3VwLCBheGlzLCB0aW1lbGluZU1vZGVsKSB7XG4gICAgdmFyIGF4aXNFeHRlbnQgPSBheGlzLmdldEV4dGVudCgpO1xuXG4gICAgaWYgKCF0aW1lbGluZU1vZGVsLmdldChbJ2xpbmVTdHlsZScsICdzaG93J10pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxpbmUgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHgxOiBheGlzRXh0ZW50WzBdLFxuICAgICAgICB5MTogMCxcbiAgICAgICAgeDI6IGF4aXNFeHRlbnRbMV0sXG4gICAgICAgIHkyOiAwXG4gICAgICB9LFxuICAgICAgc3R5bGU6IGV4dGVuZCh7XG4gICAgICAgIGxpbmVDYXA6ICdyb3VuZCdcbiAgICAgIH0sIHRpbWVsaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpKSxcbiAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgIHoyOiAxXG4gICAgfSk7XG4gICAgZ3JvdXAuYWRkKGxpbmUpO1xuICAgIHZhciBwcm9ncmVzc0xpbmUgPSB0aGlzLl9wcm9ncmVzc0xpbmUgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHgxOiBheGlzRXh0ZW50WzBdLFxuICAgICAgICB4MjogdGhpcy5fY3VycmVudFBvaW50ZXIgPyB0aGlzLl9jdXJyZW50UG9pbnRlci54IDogYXhpc0V4dGVudFswXSxcbiAgICAgICAgeTE6IDAsXG4gICAgICAgIHkyOiAwXG4gICAgICB9LFxuICAgICAgc3R5bGU6IGRlZmF1bHRzKHtcbiAgICAgICAgbGluZUNhcDogJ3JvdW5kJyxcbiAgICAgICAgbGluZVdpZHRoOiBsaW5lLnN0eWxlLmxpbmVXaWR0aFxuICAgICAgfSwgdGltZWxpbmVNb2RlbC5nZXRNb2RlbChbJ3Byb2dyZXNzJywgJ2xpbmVTdHlsZSddKS5nZXRMaW5lU3R5bGUoKSksXG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICB6MjogMVxuICAgIH0pO1xuICAgIGdyb3VwLmFkZChwcm9ncmVzc0xpbmUpO1xuICB9O1xuXG4gIFNsaWRlclRpbWVsaW5lVmlldy5wcm90b3R5cGUuX3JlbmRlckF4aXNUaWNrID0gZnVuY3Rpb24gKGxheW91dEluZm8sIGdyb3VwLCBheGlzLCB0aW1lbGluZU1vZGVsKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBkYXRhID0gdGltZWxpbmVNb2RlbC5nZXREYXRhKCk7IC8vIFNob3cgYWxsIHRpY2tzLCBkZXNwaXRlIGlnbm9yaW5nIHN0cmF0ZWd5LlxuXG4gICAgdmFyIHRpY2tzID0gYXhpcy5zY2FsZS5nZXRUaWNrcygpO1xuICAgIHRoaXMuX3RpY2tTeW1ib2xzID0gW107IC8vIFRoZSB2YWx1ZSBpcyBkYXRhSW5kZXgsIHNlZSB0aGUgY29zdG9taXplZCBzY2FsZS5cblxuICAgIGVhY2godGlja3MsIGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICB2YXIgdGlja0Nvb3JkID0gYXhpcy5kYXRhVG9Db29yZCh0aWNrLnZhbHVlKTtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbCh0aWNrLnZhbHVlKTtcbiAgICAgIHZhciBpdGVtU3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJyk7XG4gICAgICB2YXIgaG92ZXJTdHlsZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKFsnZW1waGFzaXMnLCAnaXRlbVN0eWxlJ10pO1xuICAgICAgdmFyIHByb2dyZXNzU3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChbJ3Byb2dyZXNzJywgJ2l0ZW1TdHlsZSddKTtcbiAgICAgIHZhciBzeW1ib2xPcHQgPSB7XG4gICAgICAgIHg6IHRpY2tDb29yZCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgb25jbGljazogYmluZChfdGhpcy5fY2hhbmdlVGltZWxpbmUsIF90aGlzLCB0aWNrLnZhbHVlKVxuICAgICAgfTtcbiAgICAgIHZhciBlbCA9IGdpdmVTeW1ib2woaXRlbU1vZGVsLCBpdGVtU3R5bGVNb2RlbCwgZ3JvdXAsIHN5bWJvbE9wdCk7XG4gICAgICBlbC5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKS5zdHlsZSA9IGhvdmVyU3R5bGVNb2RlbC5nZXRJdGVtU3R5bGUoKTtcbiAgICAgIGVsLmVuc3VyZVN0YXRlKCdwcm9ncmVzcycpLnN0eWxlID0gcHJvZ3Jlc3NTdHlsZU1vZGVsLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgZW5hYmxlSG92ZXJFbXBoYXNpcyhlbCk7XG4gICAgICB2YXIgZWNEYXRhID0gZ2V0RUNEYXRhKGVsKTtcblxuICAgICAgaWYgKGl0ZW1Nb2RlbC5nZXQoJ3Rvb2x0aXAnKSkge1xuICAgICAgICBlY0RhdGEuZGF0YUluZGV4ID0gdGljay52YWx1ZTtcbiAgICAgICAgZWNEYXRhLmRhdGFNb2RlbCA9IHRpbWVsaW5lTW9kZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlY0RhdGEuZGF0YUluZGV4ID0gZWNEYXRhLmRhdGFNb2RlbCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl90aWNrU3ltYm9scy5wdXNoKGVsKTtcbiAgICB9KTtcbiAgfTtcblxuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLl9yZW5kZXJBeGlzTGFiZWwgPSBmdW5jdGlvbiAobGF5b3V0SW5mbywgZ3JvdXAsIGF4aXMsIHRpbWVsaW5lTW9kZWwpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGxhYmVsTW9kZWwgPSBheGlzLmdldExhYmVsTW9kZWwoKTtcblxuICAgIGlmICghbGFiZWxNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gdGltZWxpbmVNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGxhYmVscyA9IGF4aXMuZ2V0Vmlld0xhYmVscygpO1xuICAgIHRoaXMuX3RpY2tMYWJlbHMgPSBbXTtcbiAgICBlYWNoKGxhYmVscywgZnVuY3Rpb24gKGxhYmVsSXRlbSkge1xuICAgICAgLy8gVGhlIHRpY2tWYWx1ZSBpcyBkYXRhSW5kZXgsIHNlZSB0aGUgY29zdG9taXplZCBzY2FsZS5cbiAgICAgIHZhciBkYXRhSW5kZXggPSBsYWJlbEl0ZW0udGlja1ZhbHVlO1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG4gICAgICB2YXIgbm9ybWFsTGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwnKTtcbiAgICAgIHZhciBob3ZlckxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoWydlbXBoYXNpcycsICdsYWJlbCddKTtcbiAgICAgIHZhciBwcm9ncmVzc0xhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoWydwcm9ncmVzcycsICdsYWJlbCddKTtcbiAgICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLmRhdGFUb0Nvb3JkKGxhYmVsSXRlbS50aWNrVmFsdWUpO1xuICAgICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgICB4OiB0aWNrQ29vcmQsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHJvdGF0aW9uOiBsYXlvdXRJbmZvLmxhYmVsUm90YXRpb24gLSBsYXlvdXRJbmZvLnJvdGF0aW9uLFxuICAgICAgICBvbmNsaWNrOiBiaW5kKF90aGlzLl9jaGFuZ2VUaW1lbGluZSwgX3RoaXMsIGRhdGFJbmRleCksXG4gICAgICAgIHNpbGVudDogZmFsc2UsXG4gICAgICAgIHN0eWxlOiBjcmVhdGVUZXh0U3R5bGUobm9ybWFsTGFiZWxNb2RlbCwge1xuICAgICAgICAgIHRleHQ6IGxhYmVsSXRlbS5mb3JtYXR0ZWRMYWJlbCxcbiAgICAgICAgICBhbGlnbjogbGF5b3V0SW5mby5sYWJlbEFsaWduLFxuICAgICAgICAgIHZlcnRpY2FsQWxpZ246IGxheW91dEluZm8ubGFiZWxCYXNlbGluZVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICB0ZXh0RWwuZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJykuc3R5bGUgPSBjcmVhdGVUZXh0U3R5bGUoaG92ZXJMYWJlbE1vZGVsKTtcbiAgICAgIHRleHRFbC5lbnN1cmVTdGF0ZSgncHJvZ3Jlc3MnKS5zdHlsZSA9IGNyZWF0ZVRleHRTdHlsZShwcm9ncmVzc0xhYmVsTW9kZWwpO1xuICAgICAgZ3JvdXAuYWRkKHRleHRFbCk7XG4gICAgICBlbmFibGVIb3ZlckVtcGhhc2lzKHRleHRFbCk7XG4gICAgICBsYWJlbERhdGFJbmRleFN0b3JlKHRleHRFbCkuZGF0YUluZGV4ID0gZGF0YUluZGV4O1xuXG4gICAgICBfdGhpcy5fdGlja0xhYmVscy5wdXNoKHRleHRFbCk7XG4gICAgfSk7XG4gIH07XG5cbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5fcmVuZGVyQ29udHJvbCA9IGZ1bmN0aW9uIChsYXlvdXRJbmZvLCBncm91cCwgYXhpcywgdGltZWxpbmVNb2RlbCkge1xuICAgIHZhciBjb250cm9sU2l6ZSA9IGxheW91dEluZm8uY29udHJvbFNpemU7XG4gICAgdmFyIHJvdGF0aW9uID0gbGF5b3V0SW5mby5yb3RhdGlvbjtcbiAgICB2YXIgaXRlbVN0eWxlID0gdGltZWxpbmVNb2RlbC5nZXRNb2RlbCgnY29udHJvbFN0eWxlJykuZ2V0SXRlbVN0eWxlKCk7XG4gICAgdmFyIGhvdmVyU3R5bGUgPSB0aW1lbGluZU1vZGVsLmdldE1vZGVsKFsnZW1waGFzaXMnLCAnY29udHJvbFN0eWxlJ10pLmdldEl0ZW1TdHlsZSgpO1xuICAgIHZhciBwbGF5U3RhdGUgPSB0aW1lbGluZU1vZGVsLmdldFBsYXlTdGF0ZSgpO1xuICAgIHZhciBpbnZlcnNlID0gdGltZWxpbmVNb2RlbC5nZXQoJ2ludmVyc2UnLCB0cnVlKTtcbiAgICBtYWtlQnRuKGxheW91dEluZm8ubmV4dEJ0blBvc2l0aW9uLCAnbmV4dCcsIGJpbmQodGhpcy5fY2hhbmdlVGltZWxpbmUsIHRoaXMsIGludmVyc2UgPyAnLScgOiAnKycpKTtcbiAgICBtYWtlQnRuKGxheW91dEluZm8ucHJldkJ0blBvc2l0aW9uLCAncHJldicsIGJpbmQodGhpcy5fY2hhbmdlVGltZWxpbmUsIHRoaXMsIGludmVyc2UgPyAnKycgOiAnLScpKTtcbiAgICBtYWtlQnRuKGxheW91dEluZm8ucGxheVBvc2l0aW9uLCBwbGF5U3RhdGUgPyAnc3RvcCcgOiAncGxheScsIGJpbmQodGhpcy5faGFuZGxlUGxheUNsaWNrLCB0aGlzLCAhcGxheVN0YXRlKSwgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBtYWtlQnRuKHBvc2l0aW9uLCBpY29uTmFtZSwgb25jbGljaywgd2lsbFJvdGF0ZSkge1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpY29uU2l6ZSA9IHBhcnNlUGVyY2VudChyZXRyaWV2ZTIodGltZWxpbmVNb2RlbC5nZXQoWydjb250cm9sU3R5bGUnLCBpY29uTmFtZSArICdCdG5TaXplJ10pLCBjb250cm9sU2l6ZSksIGNvbnRyb2xTaXplKTtcbiAgICAgIHZhciByZWN0ID0gWzAsIC1pY29uU2l6ZSAvIDIsIGljb25TaXplLCBpY29uU2l6ZV07XG4gICAgICB2YXIgb3B0ID0ge1xuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgIG9yaWdpbjogW2NvbnRyb2xTaXplIC8gMiwgMF0sXG4gICAgICAgIHJvdGF0aW9uOiB3aWxsUm90YXRlID8gLXJvdGF0aW9uIDogMCxcbiAgICAgICAgcmVjdEhvdmVyOiB0cnVlLFxuICAgICAgICBzdHlsZTogaXRlbVN0eWxlLFxuICAgICAgICBvbmNsaWNrOiBvbmNsaWNrXG4gICAgICB9O1xuICAgICAgdmFyIGJ0biA9IG1ha2VDb250cm9sSWNvbih0aW1lbGluZU1vZGVsLCBpY29uTmFtZSArICdJY29uJywgcmVjdCwgb3B0KTtcbiAgICAgIGJ0bi5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKS5zdHlsZSA9IGhvdmVyU3R5bGU7XG4gICAgICBncm91cC5hZGQoYnRuKTtcbiAgICAgIGVuYWJsZUhvdmVyRW1waGFzaXMoYnRuKTtcbiAgICB9XG4gIH07XG5cbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5fcmVuZGVyQ3VycmVudFBvaW50ZXIgPSBmdW5jdGlvbiAobGF5b3V0SW5mbywgZ3JvdXAsIGF4aXMsIHRpbWVsaW5lTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHRpbWVsaW5lTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBjdXJyZW50SW5kZXggPSB0aW1lbGluZU1vZGVsLmdldEN1cnJlbnRJbmRleCgpO1xuICAgIHZhciBwb2ludGVyTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChjdXJyZW50SW5kZXgpLmdldE1vZGVsKCdjaGVja3BvaW50U3R5bGUnKTtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBjYWxsYmFjayA9IHtcbiAgICAgIG9uQ3JlYXRlOiBmdW5jdGlvbiAocG9pbnRlcikge1xuICAgICAgICBwb2ludGVyLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIHBvaW50ZXIuZHJpZnQgPSBiaW5kKG1lLl9oYW5kbGVQb2ludGVyRHJhZywgbWUpO1xuICAgICAgICBwb2ludGVyLm9uZHJhZ2VuZCA9IGJpbmQobWUuX2hhbmRsZVBvaW50ZXJEcmFnZW5kLCBtZSk7XG4gICAgICAgIHBvaW50ZXJNb3ZlVG8ocG9pbnRlciwgbWUuX3Byb2dyZXNzTGluZSwgY3VycmVudEluZGV4LCBheGlzLCB0aW1lbGluZU1vZGVsLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBvblVwZGF0ZTogZnVuY3Rpb24gKHBvaW50ZXIpIHtcbiAgICAgICAgcG9pbnRlck1vdmVUbyhwb2ludGVyLCBtZS5fcHJvZ3Jlc3NMaW5lLCBjdXJyZW50SW5kZXgsIGF4aXMsIHRpbWVsaW5lTW9kZWwpO1xuICAgICAgfVxuICAgIH07IC8vIFJldXNlIHdoZW4gZXhpc3RzLCBmb3IgYW5pbWF0aW9uIGFuZCBkcmFnLlxuXG4gICAgdGhpcy5fY3VycmVudFBvaW50ZXIgPSBnaXZlU3ltYm9sKHBvaW50ZXJNb2RlbCwgcG9pbnRlck1vZGVsLCB0aGlzLl9tYWluR3JvdXAsIHt9LCB0aGlzLl9jdXJyZW50UG9pbnRlciwgY2FsbGJhY2spO1xuICB9O1xuXG4gIFNsaWRlclRpbWVsaW5lVmlldy5wcm90b3R5cGUuX2hhbmRsZVBsYXlDbGljayA9IGZ1bmN0aW9uIChuZXh0U3RhdGUpIHtcbiAgICB0aGlzLl9jbGVhclRpbWVyKCk7XG5cbiAgICB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAndGltZWxpbmVQbGF5Q2hhbmdlJyxcbiAgICAgIHBsYXlTdGF0ZTogbmV4dFN0YXRlLFxuICAgICAgZnJvbTogdGhpcy51aWRcbiAgICB9KTtcbiAgfTtcblxuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLl9oYW5kbGVQb2ludGVyRHJhZyA9IGZ1bmN0aW9uIChkeCwgZHksIGUpIHtcbiAgICB0aGlzLl9jbGVhclRpbWVyKCk7XG5cbiAgICB0aGlzLl9wb2ludGVyQ2hhbmdlVGltZWxpbmUoW2Uub2Zmc2V0WCwgZS5vZmZzZXRZXSk7XG4gIH07XG5cbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5faGFuZGxlUG9pbnRlckRyYWdlbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHRoaXMuX3BvaW50ZXJDaGFuZ2VUaW1lbGluZShbZS5vZmZzZXRYLCBlLm9mZnNldFldLCB0cnVlKTtcbiAgfTtcblxuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLl9wb2ludGVyQ2hhbmdlVGltZWxpbmUgPSBmdW5jdGlvbiAobW91c2VQb3MsIHRyaWdnZXIpIHtcbiAgICB2YXIgdG9Db29yZCA9IHRoaXMuX3RvQXhpc0Nvb3JkKG1vdXNlUG9zKVswXTtcblxuICAgIHZhciBheGlzID0gdGhpcy5fYXhpcztcbiAgICB2YXIgYXhpc0V4dGVudCA9IG51bWJlclV0aWwuYXNjKGF4aXMuZ2V0RXh0ZW50KCkuc2xpY2UoKSk7XG4gICAgdG9Db29yZCA+IGF4aXNFeHRlbnRbMV0gJiYgKHRvQ29vcmQgPSBheGlzRXh0ZW50WzFdKTtcbiAgICB0b0Nvb3JkIDwgYXhpc0V4dGVudFswXSAmJiAodG9Db29yZCA9IGF4aXNFeHRlbnRbMF0pO1xuICAgIHRoaXMuX2N1cnJlbnRQb2ludGVyLnggPSB0b0Nvb3JkO1xuXG4gICAgdGhpcy5fY3VycmVudFBvaW50ZXIubWFya1JlZHJhdygpO1xuXG4gICAgdGhpcy5fcHJvZ3Jlc3NMaW5lLnNoYXBlLngyID0gdG9Db29yZDtcblxuICAgIHRoaXMuX3Byb2dyZXNzTGluZS5kaXJ0eSgpO1xuXG4gICAgdmFyIHRhcmdldERhdGFJbmRleCA9IHRoaXMuX2ZpbmROZWFyZXN0VGljayh0b0Nvb3JkKTtcblxuICAgIHZhciB0aW1lbGluZU1vZGVsID0gdGhpcy5tb2RlbDtcblxuICAgIGlmICh0cmlnZ2VyIHx8IHRhcmdldERhdGFJbmRleCAhPT0gdGltZWxpbmVNb2RlbC5nZXRDdXJyZW50SW5kZXgoKSAmJiB0aW1lbGluZU1vZGVsLmdldCgncmVhbHRpbWUnKSkge1xuICAgICAgdGhpcy5fY2hhbmdlVGltZWxpbmUodGFyZ2V0RGF0YUluZGV4KTtcbiAgICB9XG4gIH07XG5cbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5fZG9QbGF5U3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fY2xlYXJUaW1lcigpO1xuXG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0UGxheVN0YXRlKCkpIHtcbiAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIERvIG5vdCBjYWNoZVxuICAgICAgICB2YXIgdGltZWxpbmVNb2RlbCA9IF90aGlzLm1vZGVsO1xuXG4gICAgICAgIF90aGlzLl9jaGFuZ2VUaW1lbGluZSh0aW1lbGluZU1vZGVsLmdldEN1cnJlbnRJbmRleCgpICsgKHRpbWVsaW5lTW9kZWwuZ2V0KCdyZXdpbmQnLCB0cnVlKSA/IC0xIDogMSkpO1xuICAgICAgfSwgdGhpcy5tb2RlbC5nZXQoJ3BsYXlJbnRlcnZhbCcpKTtcbiAgICB9XG4gIH07XG5cbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5fdG9BeGlzQ29vcmQgPSBmdW5jdGlvbiAodmVydGV4KSB7XG4gICAgdmFyIHRyYW5zID0gdGhpcy5fbWFpbkdyb3VwLmdldExvY2FsVHJhbnNmb3JtKCk7XG5cbiAgICByZXR1cm4gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSh2ZXJ0ZXgsIHRyYW5zLCB0cnVlKTtcbiAgfTtcblxuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLl9maW5kTmVhcmVzdFRpY2sgPSBmdW5jdGlvbiAoYXhpc0Nvb3JkKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgZGlzdCA9IEluZmluaXR5O1xuICAgIHZhciB0YXJnZXREYXRhSW5kZXg7XG4gICAgdmFyIGF4aXMgPSB0aGlzLl9heGlzO1xuICAgIGRhdGEuZWFjaChbJ3ZhbHVlJ10sIGZ1bmN0aW9uICh2YWx1ZSwgZGF0YUluZGV4KSB7XG4gICAgICB2YXIgY29vcmQgPSBheGlzLmRhdGFUb0Nvb3JkKHZhbHVlKTtcbiAgICAgIHZhciBkID0gTWF0aC5hYnMoY29vcmQgLSBheGlzQ29vcmQpO1xuXG4gICAgICBpZiAoZCA8IGRpc3QpIHtcbiAgICAgICAgZGlzdCA9IGQ7XG4gICAgICAgIHRhcmdldERhdGFJbmRleCA9IGRhdGFJbmRleDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0RGF0YUluZGV4O1xuICB9O1xuXG4gIFNsaWRlclRpbWVsaW5lVmlldy5wcm90b3R5cGUuX2NsZWFyVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLl9jaGFuZ2VUaW1lbGluZSA9IGZ1bmN0aW9uIChuZXh0SW5kZXgpIHtcbiAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5tb2RlbC5nZXRDdXJyZW50SW5kZXgoKTtcblxuICAgIGlmIChuZXh0SW5kZXggPT09ICcrJykge1xuICAgICAgbmV4dEluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICB9IGVsc2UgaWYgKG5leHRJbmRleCA9PT0gJy0nKSB7XG4gICAgICBuZXh0SW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuICAgIH1cblxuICAgIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICd0aW1lbGluZUNoYW5nZScsXG4gICAgICBjdXJyZW50SW5kZXg6IG5leHRJbmRleCxcbiAgICAgIGZyb206IHRoaXMudWlkXG4gICAgfSk7XG4gIH07XG5cbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5fdXBkYXRlVGlja3NTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IHRoaXMubW9kZWwuZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgdmFyIHRpY2tTeW1ib2xzID0gdGhpcy5fdGlja1N5bWJvbHM7XG4gICAgdmFyIHRpY2tMYWJlbHMgPSB0aGlzLl90aWNrTGFiZWxzO1xuXG4gICAgaWYgKHRpY2tTeW1ib2xzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tTeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRpY2tTeW1ib2xzICYmIHRpY2tTeW1ib2xzW2ldICYmIHRpY2tTeW1ib2xzW2ldLnRvZ2dsZVN0YXRlKCdwcm9ncmVzcycsIGkgPCBjdXJyZW50SW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aWNrTGFiZWxzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tMYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGlja0xhYmVscyAmJiB0aWNrTGFiZWxzW2ldICYmIHRpY2tMYWJlbHNbaV0udG9nZ2xlU3RhdGUoJ3Byb2dyZXNzJywgbGFiZWxEYXRhSW5kZXhTdG9yZSh0aWNrTGFiZWxzW2ldKS5kYXRhSW5kZXggPD0gY3VycmVudEluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU2xpZGVyVGltZWxpbmVWaWV3LnR5cGUgPSAndGltZWxpbmUuc2xpZGVyJztcbiAgcmV0dXJuIFNsaWRlclRpbWVsaW5lVmlldztcbn0oVGltZWxpbmVWaWV3KTtcblxuZnVuY3Rpb24gY3JlYXRlU2NhbGVCeU1vZGVsKG1vZGVsLCBheGlzVHlwZSkge1xuICBheGlzVHlwZSA9IGF4aXNUeXBlIHx8IG1vZGVsLmdldCgndHlwZScpO1xuXG4gIGlmIChheGlzVHlwZSkge1xuICAgIHN3aXRjaCAoYXhpc1R5cGUpIHtcbiAgICAgIC8vIEJ1aWxkaW4gc2NhbGVcbiAgICAgIGNhc2UgJ2NhdGVnb3J5JzpcbiAgICAgICAgcmV0dXJuIG5ldyBPcmRpbmFsU2NhbGUoe1xuICAgICAgICAgIG9yZGluYWxNZXRhOiBtb2RlbC5nZXRDYXRlZ29yaWVzKCksXG4gICAgICAgICAgZXh0ZW50OiBbSW5maW5pdHksIC1JbmZpbml0eV1cbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgICByZXR1cm4gbmV3IFRpbWVTY2FsZSh7XG4gICAgICAgICAgbG9jYWxlOiBtb2RlbC5lY01vZGVsLmdldExvY2FsZU1vZGVsKCksXG4gICAgICAgICAgdXNlVVRDOiBtb2RlbC5lY01vZGVsLmdldCgndXNlVVRDJylcbiAgICAgICAgfSk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGRlZmF1bHQgdG8gYmUgdmFsdWVcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbFNjYWxlKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdSZWN0KG1vZGVsLCBhcGkpIHtcbiAgcmV0dXJuIGxheW91dC5nZXRMYXlvdXRSZWN0KG1vZGVsLmdldEJveExheW91dFBhcmFtcygpLCB7XG4gICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gIH0sIG1vZGVsLmdldCgncGFkZGluZycpKTtcbn1cblxuZnVuY3Rpb24gbWFrZUNvbnRyb2xJY29uKHRpbWVsaW5lTW9kZWwsIG9ialBhdGgsIHJlY3QsIG9wdHMpIHtcbiAgdmFyIHN0eWxlID0gb3B0cy5zdHlsZTtcbiAgdmFyIGljb24gPSBncmFwaGljLmNyZWF0ZUljb24odGltZWxpbmVNb2RlbC5nZXQoWydjb250cm9sU3R5bGUnLCBvYmpQYXRoXSksIG9wdHMgfHwge30sIG5ldyBCb3VuZGluZ1JlY3QocmVjdFswXSwgcmVjdFsxXSwgcmVjdFsyXSwgcmVjdFszXSkpOyAvLyBUT0RPIGNyZWF0ZUljb24gd29uJ3QgdXNlIHN0eWxlIGluIG9wdC5cblxuICBpZiAoc3R5bGUpIHtcbiAgICBpY29uLnNldFN0eWxlKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBpY29uO1xufVxuLyoqXG4gKiBDcmVhdGUgc3ltYm9sIG9yIHVwZGF0ZSBzeW1ib2xcbiAqIG9wdDogYmFzaWMgcG9zaXRpb24gYW5kIGV2ZW50IGhhbmRsZXJzXG4gKi9cblxuXG5mdW5jdGlvbiBnaXZlU3ltYm9sKGhvc3RNb2RlbCwgaXRlbVN0eWxlTW9kZWwsIGdyb3VwLCBvcHQsIHN5bWJvbCwgY2FsbGJhY2spIHtcbiAgdmFyIGNvbG9yID0gaXRlbVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuXG4gIGlmICghc3ltYm9sKSB7XG4gICAgdmFyIHN5bWJvbFR5cGUgPSBob3N0TW9kZWwuZ2V0KCdzeW1ib2wnKTtcbiAgICBzeW1ib2wgPSBjcmVhdGVTeW1ib2woc3ltYm9sVHlwZSwgLTEsIC0xLCAyLCAyLCBjb2xvcik7XG4gICAgc3ltYm9sLnNldFN0eWxlKCdzdHJva2VOb1NjYWxlJywgdHJ1ZSk7XG4gICAgZ3JvdXAuYWRkKHN5bWJvbCk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sub25DcmVhdGUoc3ltYm9sKTtcbiAgfSBlbHNlIHtcbiAgICBzeW1ib2wuc2V0Q29sb3IoY29sb3IpO1xuICAgIGdyb3VwLmFkZChzeW1ib2wpOyAvLyBHcm91cCBtYXkgYmUgbmV3LCBhbHNvIG5lZWQgdG8gYWRkLlxuXG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sub25VcGRhdGUoc3ltYm9sKTtcbiAgfSAvLyBTdHlsZVxuXG5cbiAgdmFyIGl0ZW1TdHlsZSA9IGl0ZW1TdHlsZU1vZGVsLmdldEl0ZW1TdHlsZShbJ2NvbG9yJ10pO1xuICBzeW1ib2wuc2V0U3R5bGUoaXRlbVN0eWxlKTsgLy8gVHJhbnNmb3JtIGFuZCBldmVudHMuXG5cbiAgb3B0ID0gbWVyZ2Uoe1xuICAgIHJlY3RIb3ZlcjogdHJ1ZSxcbiAgICB6MjogMTAwXG4gIH0sIG9wdCwgdHJ1ZSk7XG4gIHZhciBzeW1ib2xTaXplID0gaG9zdE1vZGVsLmdldCgnc3ltYm9sU2l6ZScpO1xuICBzeW1ib2xTaXplID0gc3ltYm9sU2l6ZSBpbnN0YW5jZW9mIEFycmF5ID8gc3ltYm9sU2l6ZS5zbGljZSgpIDogWytzeW1ib2xTaXplLCArc3ltYm9sU2l6ZV07XG4gIG9wdC5zY2FsZVggPSBzeW1ib2xTaXplWzBdIC8gMjtcbiAgb3B0LnNjYWxlWSA9IHN5bWJvbFNpemVbMV0gLyAyO1xuICB2YXIgc3ltYm9sT2Zmc2V0ID0gaG9zdE1vZGVsLmdldCgnc3ltYm9sT2Zmc2V0Jyk7XG5cbiAgaWYgKHN5bWJvbE9mZnNldCkge1xuICAgIG9wdC54ID0gb3B0LnggfHwgMDtcbiAgICBvcHQueSA9IG9wdC55IHx8IDA7XG4gICAgb3B0LnggKz0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoc3ltYm9sT2Zmc2V0WzBdLCBzeW1ib2xTaXplWzBdKTtcbiAgICBvcHQueSArPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChzeW1ib2xPZmZzZXRbMV0sIHN5bWJvbFNpemVbMV0pO1xuICB9XG5cbiAgdmFyIHN5bWJvbFJvdGF0ZSA9IGhvc3RNb2RlbC5nZXQoJ3N5bWJvbFJvdGF0ZScpO1xuICBvcHQucm90YXRpb24gPSAoc3ltYm9sUm90YXRlIHx8IDApICogTWF0aC5QSSAvIDE4MCB8fCAwO1xuICBzeW1ib2wuYXR0cihvcHQpOyAvLyBGSVhNRVxuICAvLyAoMSkgV2hlbiBzeW1ib2wuc3R5bGUuc3Ryb2tlTm9TY2FsZSBpcyB0cnVlIGFuZCB1cGRhdGVUcmFuc2Zvcm0gaXMgbm90IHBlcmZvcm1lZCxcbiAgLy8gZ2V0Qm91bmRpbmdSZWN0IHdpbGwgcmV0dXJuIHdyb25nIHJlc3VsdC5cbiAgLy8gKFRoaXMgaXMgc3VwcG9zZWQgdG8gYmUgcmVzb2x2ZWQgaW4genJlbmRlciwgYnV0IGl0IGlzIGEgbGl0dGxlIGRpZmZpY3VsdCB0b1xuICAvLyBsZXZlcmFnZSBwZXJmb3JtYW5jZSBhbmQgYXV0byB1cGRhdGVUcmFuc2Zvcm0pXG4gIC8vICgyKSBBbGwgb2YgYW5jZXN0ZXJzIG9mIHN5bWJvbCBkbyBub3Qgc2NhbGUsIHNvIHdlIGNhbiBqdXN0IHVwZGF0ZVRyYW5zZm9ybSBzeW1ib2wuXG5cbiAgc3ltYm9sLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICByZXR1cm4gc3ltYm9sO1xufVxuXG5mdW5jdGlvbiBwb2ludGVyTW92ZVRvKHBvaW50ZXIsIHByb2dyZXNzTGluZSwgZGF0YUluZGV4LCBheGlzLCB0aW1lbGluZU1vZGVsLCBub0FuaW1hdGlvbikge1xuICBpZiAocG9pbnRlci5kcmFnZ2luZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwb2ludGVyTW9kZWwgPSB0aW1lbGluZU1vZGVsLmdldE1vZGVsKCdjaGVja3BvaW50U3R5bGUnKTtcbiAgdmFyIHRvQ29vcmQgPSBheGlzLmRhdGFUb0Nvb3JkKHRpbWVsaW5lTW9kZWwuZ2V0RGF0YSgpLmdldCgndmFsdWUnLCBkYXRhSW5kZXgpKTtcblxuICBpZiAobm9BbmltYXRpb24gfHwgIXBvaW50ZXJNb2RlbC5nZXQoJ2FuaW1hdGlvbicsIHRydWUpKSB7XG4gICAgcG9pbnRlci5hdHRyKHtcbiAgICAgIHg6IHRvQ29vcmQsXG4gICAgICB5OiAwXG4gICAgfSk7XG4gICAgcHJvZ3Jlc3NMaW5lICYmIHByb2dyZXNzTGluZS5hdHRyKHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHgyOiB0b0Nvb3JkXG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGFuaW1hdGlvbkNmZyA9IHtcbiAgICAgIGR1cmF0aW9uOiBwb2ludGVyTW9kZWwuZ2V0KCdhbmltYXRpb25EdXJhdGlvbicsIHRydWUpLFxuICAgICAgZWFzaW5nOiBwb2ludGVyTW9kZWwuZ2V0KCdhbmltYXRpb25FYXNpbmcnLCB0cnVlKVxuICAgIH07XG4gICAgcG9pbnRlci5zdG9wQW5pbWF0aW9uKG51bGwsIHRydWUpO1xuICAgIHBvaW50ZXIuYW5pbWF0ZVRvKHtcbiAgICAgIHg6IHRvQ29vcmQsXG4gICAgICB5OiAwXG4gICAgfSwgYW5pbWF0aW9uQ2ZnKTtcbiAgICBwcm9ncmVzc0xpbmUgJiYgcHJvZ3Jlc3NMaW5lLmFuaW1hdGVUbyh7XG4gICAgICBzaGFwZToge1xuICAgICAgICB4MjogdG9Db29yZFxuICAgICAgfVxuICAgIH0sIGFuaW1hdGlvbkNmZyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2xpZGVyVGltZWxpbmVWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBBeGlzIGZyb20gJy4uLy4uL2Nvb3JkL0F4aXMnO1xuLyoqXG4gKiBFeHRlbmQgYXhpcyAyZFxuICovXG5cbnZhciBUaW1lbGluZUF4aXMgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVGltZWxpbmVBeGlzLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFRpbWVsaW5lQXhpcyhkaW0sIHNjYWxlLCBjb29yZEV4dGVudCwgYXhpc1R5cGUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkaW0sIHNjYWxlLCBjb29yZEV4dGVudCkgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBheGlzVHlwZSB8fCAndmFsdWUnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgVGltZWxpbmVBeGlzLnByb3RvdHlwZS5nZXRMYWJlbE1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEZvcmNlIG92ZXJyaWRlXG4gICAgcmV0dXJuIHRoaXMubW9kZWwuZ2V0TW9kZWwoJ2xhYmVsJyk7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBUaW1lbGluZUF4aXMucHJvdG90eXBlLmlzSG9yaXpvbnRhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXQoJ29yaWVudCcpID09PSAnaG9yaXpvbnRhbCc7XG4gIH07XG5cbiAgcmV0dXJuIFRpbWVsaW5lQXhpcztcbn0oQXhpcyk7XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVsaW5lQXhpczsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50JztcbmltcG9ydCBMaXN0IGZyb20gJy4uLy4uL2RhdGEvTGlzdCc7XG5pbXBvcnQgeyBlYWNoLCBpc09iamVjdCwgY2xvbmUgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgY29udmVydE9wdGlvbklkTmFtZSwgZ2V0RGF0YUl0ZW1WYWx1ZSB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwnO1xuXG52YXIgVGltZWxpbmVNb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUaW1lbGluZU1vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFRpbWVsaW5lTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gVGltZWxpbmVNb2RlbC50eXBlO1xuICAgIF90aGlzLmxheW91dE1vZGUgPSAnYm94JztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIFRpbWVsaW5lTW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCkge1xuICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcblxuICAgIHRoaXMuX2luaXREYXRhKCk7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBUaW1lbGluZU1vZGVsLnByb3RvdHlwZS5tZXJnZU9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLm1lcmdlT3B0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLl9pbml0RGF0YSgpO1xuICB9O1xuXG4gIFRpbWVsaW5lTW9kZWwucHJvdG90eXBlLnNldEN1cnJlbnRJbmRleCA9IGZ1bmN0aW9uIChjdXJyZW50SW5kZXgpIHtcbiAgICBpZiAoY3VycmVudEluZGV4ID09IG51bGwpIHtcbiAgICAgIGN1cnJlbnRJbmRleCA9IHRoaXMub3B0aW9uLmN1cnJlbnRJbmRleDtcbiAgICB9XG5cbiAgICB2YXIgY291bnQgPSB0aGlzLl9kYXRhLmNvdW50KCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb24ubG9vcCkge1xuICAgICAgY3VycmVudEluZGV4ID0gKGN1cnJlbnRJbmRleCAlIGNvdW50ICsgY291bnQpICUgY291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRJbmRleCA+PSBjb3VudCAmJiAoY3VycmVudEluZGV4ID0gY291bnQgLSAxKTtcbiAgICAgIGN1cnJlbnRJbmRleCA8IDAgJiYgKGN1cnJlbnRJbmRleCA9IDApO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9uLmN1cnJlbnRJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgfTtcbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gY3VycmVudEluZGV4XG4gICAqL1xuXG5cbiAgVGltZWxpbmVNb2RlbC5wcm90b3R5cGUuZ2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbi5jdXJyZW50SW5kZXg7XG4gIH07XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXG4gIFRpbWVsaW5lTW9kZWwucHJvdG90eXBlLmlzSW5kZXhNYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudEluZGV4KCkgPj0gdGhpcy5fZGF0YS5jb3VudCgpIC0gMTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUgdHJ1ZTogcGxheSwgZmFsc2U6IHN0b3BcbiAgICovXG5cblxuICBUaW1lbGluZU1vZGVsLnByb3RvdHlwZS5zZXRQbGF5U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB0aGlzLm9wdGlvbi5hdXRvUGxheSA9ICEhc3RhdGU7XG4gIH07XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlOiBwbGF5LCBmYWxzZTogc3RvcFxuICAgKi9cblxuXG4gIFRpbWVsaW5lTW9kZWwucHJvdG90eXBlLmdldFBsYXlTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLm9wdGlvbi5hdXRvUGxheTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGltZWxpbmVNb2RlbC5wcm90b3R5cGUuX2luaXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGlzT3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIGRhdGFBcnIgPSB0aGlzT3B0aW9uLmRhdGEgfHwgW107XG4gICAgdmFyIGF4aXNUeXBlID0gdGhpc09wdGlvbi5heGlzVHlwZTtcbiAgICB2YXIgbmFtZXMgPSB0aGlzLl9uYW1lcyA9IFtdO1xuICAgIHZhciBwcm9jZXNzZWREYXRhQXJyO1xuXG4gICAgaWYgKGF4aXNUeXBlID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICBwcm9jZXNzZWREYXRhQXJyID0gW107XG4gICAgICBlYWNoKGRhdGFBcnIsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBjb252ZXJ0T3B0aW9uSWROYW1lKGdldERhdGFJdGVtVmFsdWUoaXRlbSksICcnKTtcbiAgICAgICAgdmFyIG5ld0l0ZW07XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgbmV3SXRlbSA9IGNsb25lKGl0ZW0pO1xuICAgICAgICAgIG5ld0l0ZW0udmFsdWUgPSBpbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdJdGVtID0gaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzZWREYXRhQXJyLnB1c2gobmV3SXRlbSk7XG4gICAgICAgIG5hbWVzLnB1c2godmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3NlZERhdGFBcnIgPSBkYXRhQXJyO1xuICAgIH1cblxuICAgIHZhciBkaW1UeXBlID0ge1xuICAgICAgY2F0ZWdvcnk6ICdvcmRpbmFsJyxcbiAgICAgIHRpbWU6ICd0aW1lJyxcbiAgICAgIHZhbHVlOiAnbnVtYmVyJ1xuICAgIH1bYXhpc1R5cGVdIHx8ICdudW1iZXInO1xuICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YSA9IG5ldyBMaXN0KFt7XG4gICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgdHlwZTogZGltVHlwZVxuICAgIH1dLCB0aGlzKTtcbiAgICBkYXRhLmluaXREYXRhKHByb2Nlc3NlZERhdGFBcnIsIG5hbWVzKTtcbiAgfTtcblxuICBUaW1lbGluZU1vZGVsLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9O1xuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gY2F0ZWdvcmVpc1xuICAgKi9cblxuXG4gIFRpbWVsaW5lTW9kZWwucHJvdG90eXBlLmdldENhdGVnb3JpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZ2V0KCdheGlzVHlwZScpID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmFtZXMuc2xpY2UoKTtcbiAgICB9XG4gIH07XG5cbiAgVGltZWxpbmVNb2RlbC50eXBlID0gJ3RpbWVsaW5lJztcbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cbiAgVGltZWxpbmVNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIHpsZXZlbDogMCxcbiAgICB6OiA0LFxuICAgIHNob3c6IHRydWUsXG4gICAgYXhpc1R5cGU6ICd0aW1lJyxcbiAgICByZWFsdGltZTogdHJ1ZSxcbiAgICBsZWZ0OiAnMjAlJyxcbiAgICB0b3A6IG51bGwsXG4gICAgcmlnaHQ6ICcyMCUnLFxuICAgIGJvdHRvbTogMCxcbiAgICB3aWR0aDogbnVsbCxcbiAgICBoZWlnaHQ6IDQwLFxuICAgIHBhZGRpbmc6IDUsXG4gICAgY29udHJvbFBvc2l0aW9uOiAnbGVmdCcsXG4gICAgYXV0b1BsYXk6IGZhbHNlLFxuICAgIHJld2luZDogZmFsc2UsXG4gICAgbG9vcDogdHJ1ZSxcbiAgICBwbGF5SW50ZXJ2YWw6IDIwMDAsXG4gICAgY3VycmVudEluZGV4OiAwLFxuICAgIGl0ZW1TdHlsZToge30sXG4gICAgbGFiZWw6IHtcbiAgICAgIGNvbG9yOiAnIzAwMCdcbiAgICB9LFxuICAgIGRhdGE6IFtdXG4gIH07XG4gIHJldHVybiBUaW1lbGluZU1vZGVsO1xufShDb21wb25lbnRNb2RlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVsaW5lTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IENvbXBvbmVudFZpZXcgZnJvbSAnLi4vLi4vdmlldy9Db21wb25lbnQnO1xuXG52YXIgVGltZWxpbmVWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRpbWVsaW5lVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBUaW1lbGluZVZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gVGltZWxpbmVWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgVGltZWxpbmVWaWV3LnR5cGUgPSAndGltZWxpbmUnO1xuICByZXR1cm4gVGltZWxpbmVWaWV3O1xufShDb21wb25lbnRWaWV3KTtcblxuZXhwb3J0IGRlZmF1bHQgVGltZWxpbmVWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG5pbXBvcnQgU2xpZGVyVGltZWxpbmVNb2RlbCBmcm9tICcuL1NsaWRlclRpbWVsaW5lTW9kZWwnO1xuaW1wb3J0IFNsaWRlclRpbWVsaW5lVmlldyBmcm9tICcuL1NsaWRlclRpbWVsaW5lVmlldyc7XG5pbXBvcnQgeyBpbnN0YWxsVGltZWxpbmVBY3Rpb24gfSBmcm9tICcuL3RpbWVsaW5lQWN0aW9uJztcbmltcG9ydCBwcmVwcm9jZXNzb3IgZnJvbSAnLi9wcmVwcm9jZXNzb3InO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKFNsaWRlclRpbWVsaW5lTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KFNsaWRlclRpbWVsaW5lVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIoJ3RpbWVsaW5lJywgZnVuY3Rpb24gKCkge1xuICAgIC8vIE9ubHkgc2xpZGVyIG5vdy5cbiAgICByZXR1cm4gJ3NsaWRlcic7XG4gIH0pO1xuICBpbnN0YWxsVGltZWxpbmVBY3Rpb24ocmVnaXN0ZXJzKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKHByZXByb2Nlc3Nvcik7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbi8vIEB0cy1ub2NoZWNrXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRpbWVsaW5lUHJlcHJvY2Vzc29yKG9wdGlvbikge1xuICB2YXIgdGltZWxpbmVPcHQgPSBvcHRpb24gJiYgb3B0aW9uLnRpbWVsaW5lO1xuXG4gIGlmICghenJVdGlsLmlzQXJyYXkodGltZWxpbmVPcHQpKSB7XG4gICAgdGltZWxpbmVPcHQgPSB0aW1lbGluZU9wdCA/IFt0aW1lbGluZU9wdF0gOiBbXTtcbiAgfVxuXG4gIHpyVXRpbC5lYWNoKHRpbWVsaW5lT3B0LCBmdW5jdGlvbiAob3B0KSB7XG4gICAgaWYgKCFvcHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb21wYXRpYmxlRUMyKG9wdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb21wYXRpYmxlRUMyKG9wdCkge1xuICB2YXIgdHlwZSA9IG9wdC50eXBlO1xuICB2YXIgZWMyVHlwZXMgPSB7XG4gICAgJ251bWJlcic6ICd2YWx1ZScsXG4gICAgJ3RpbWUnOiAndGltZSdcbiAgfTsgLy8gQ29tcGF0aWJsZSB3aXRoIGVjMlxuXG4gIGlmIChlYzJUeXBlc1t0eXBlXSkge1xuICAgIG9wdC5heGlzVHlwZSA9IGVjMlR5cGVzW3R5cGVdO1xuICAgIGRlbGV0ZSBvcHQudHlwZTtcbiAgfVxuXG4gIHRyYW5zZmVySXRlbShvcHQpO1xuXG4gIGlmIChoYXMob3B0LCAnY29udHJvbFBvc2l0aW9uJykpIHtcbiAgICB2YXIgY29udHJvbFN0eWxlID0gb3B0LmNvbnRyb2xTdHlsZSB8fCAob3B0LmNvbnRyb2xTdHlsZSA9IHt9KTtcblxuICAgIGlmICghaGFzKGNvbnRyb2xTdHlsZSwgJ3Bvc2l0aW9uJykpIHtcbiAgICAgIGNvbnRyb2xTdHlsZS5wb3NpdGlvbiA9IG9wdC5jb250cm9sUG9zaXRpb247XG4gICAgfVxuXG4gICAgaWYgKGNvbnRyb2xTdHlsZS5wb3NpdGlvbiA9PT0gJ25vbmUnICYmICFoYXMoY29udHJvbFN0eWxlLCAnc2hvdycpKSB7XG4gICAgICBjb250cm9sU3R5bGUuc2hvdyA9IGZhbHNlO1xuICAgICAgZGVsZXRlIGNvbnRyb2xTdHlsZS5wb3NpdGlvbjtcbiAgICB9XG5cbiAgICBkZWxldGUgb3B0LmNvbnRyb2xQb3NpdGlvbjtcbiAgfVxuXG4gIHpyVXRpbC5lYWNoKG9wdC5kYXRhIHx8IFtdLCBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcbiAgICBpZiAoenJVdGlsLmlzT2JqZWN0KGRhdGFJdGVtKSAmJiAhenJVdGlsLmlzQXJyYXkoZGF0YUl0ZW0pKSB7XG4gICAgICBpZiAoIWhhcyhkYXRhSXRlbSwgJ3ZhbHVlJykgJiYgaGFzKGRhdGFJdGVtLCAnbmFtZScpKSB7XG4gICAgICAgIC8vIEluIGVjMiwgdXNpbmcgbmFtZSBhcyB2YWx1ZS5cbiAgICAgICAgZGF0YUl0ZW0udmFsdWUgPSBkYXRhSXRlbS5uYW1lO1xuICAgICAgfVxuXG4gICAgICB0cmFuc2Zlckl0ZW0oZGF0YUl0ZW0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZmVySXRlbShvcHQpIHtcbiAgdmFyIGl0ZW1TdHlsZSA9IG9wdC5pdGVtU3R5bGUgfHwgKG9wdC5pdGVtU3R5bGUgPSB7fSk7XG4gIHZhciBpdGVtU3R5bGVFbXBoYXNpcyA9IGl0ZW1TdHlsZS5lbXBoYXNpcyB8fCAoaXRlbVN0eWxlLmVtcGhhc2lzID0ge30pOyAvLyBUcmFuc2ZlciBsYWJlbCBvdXRcblxuICB2YXIgbGFiZWwgPSBvcHQubGFiZWwgfHwgb3B0LmxhYmVsIHx8IHt9O1xuICB2YXIgbGFiZWxOb3JtYWwgPSBsYWJlbC5ub3JtYWwgfHwgKGxhYmVsLm5vcm1hbCA9IHt9KTtcbiAgdmFyIGV4Y2x1ZGVMYWJlbEF0dHIgPSB7XG4gICAgbm9ybWFsOiAxLFxuICAgIGVtcGhhc2lzOiAxXG4gIH07XG4gIHpyVXRpbC5lYWNoKGxhYmVsLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAoIWV4Y2x1ZGVMYWJlbEF0dHJbbmFtZV0gJiYgIWhhcyhsYWJlbE5vcm1hbCwgbmFtZSkpIHtcbiAgICAgIGxhYmVsTm9ybWFsW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICBpZiAoaXRlbVN0eWxlRW1waGFzaXMubGFiZWwgJiYgIWhhcyhsYWJlbCwgJ2VtcGhhc2lzJykpIHtcbiAgICBsYWJlbC5lbXBoYXNpcyA9IGl0ZW1TdHlsZUVtcGhhc2lzLmxhYmVsO1xuICAgIGRlbGV0ZSBpdGVtU3R5bGVFbXBoYXNpcy5sYWJlbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXMob2JqLCBhdHRyKSB7XG4gIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkoYXR0cik7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IGRlZmF1bHRzIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsVGltZWxpbmVBY3Rpb24ocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbih7XG4gICAgdHlwZTogJ3RpbWVsaW5lQ2hhbmdlJyxcbiAgICBldmVudDogJ3RpbWVsaW5lQ2hhbmdlZCcsXG4gICAgdXBkYXRlOiAncHJlcGFyZUFuZFVwZGF0ZSdcbiAgfSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgICB2YXIgdGltZWxpbmVNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCd0aW1lbGluZScpO1xuXG4gICAgaWYgKHRpbWVsaW5lTW9kZWwgJiYgcGF5bG9hZC5jdXJyZW50SW5kZXggIT0gbnVsbCkge1xuICAgICAgdGltZWxpbmVNb2RlbC5zZXRDdXJyZW50SW5kZXgocGF5bG9hZC5jdXJyZW50SW5kZXgpO1xuXG4gICAgICBpZiAoIXRpbWVsaW5lTW9kZWwuZ2V0KCdsb29wJywgdHJ1ZSkgJiYgdGltZWxpbmVNb2RlbC5pc0luZGV4TWF4KCkpIHtcbiAgICAgICAgdGltZWxpbmVNb2RlbC5zZXRQbGF5U3RhdGUoZmFsc2UpO1xuICAgICAgfVxuICAgIH0gLy8gU2V0IG5vcm1hbGl6ZWQgY3VycmVudEluZGV4IHRvIHBheWxvYWQuXG5cblxuICAgIGVjTW9kZWwucmVzZXRPcHRpb24oJ3RpbWVsaW5lJywge1xuICAgICAgcmVwbGFjZU1lcmdlOiB0aW1lbGluZU1vZGVsLmdldCgncmVwbGFjZU1lcmdlJywgdHJ1ZSlcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmYXVsdHMoe1xuICAgICAgY3VycmVudEluZGV4OiB0aW1lbGluZU1vZGVsLm9wdGlvbi5jdXJyZW50SW5kZXhcbiAgICB9LCBwYXlsb2FkKTtcbiAgfSk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbih7XG4gICAgdHlwZTogJ3RpbWVsaW5lUGxheUNoYW5nZScsXG4gICAgZXZlbnQ6ICd0aW1lbGluZVBsYXlDaGFuZ2VkJyxcbiAgICB1cGRhdGU6ICd1cGRhdGUnXG4gIH0sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgdmFyIHRpbWVsaW5lTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudCgndGltZWxpbmUnKTtcblxuICAgIGlmICh0aW1lbGluZU1vZGVsICYmIHBheWxvYWQucGxheVN0YXRlICE9IG51bGwpIHtcbiAgICAgIHRpbWVsaW5lTW9kZWwuc2V0UGxheVN0YXRlKHBheWxvYWQucGxheVN0YXRlKTtcbiAgICB9XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlJztcbmltcG9ydCB7IGNyZWF0ZVRleHRTdHlsZSB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUnO1xuaW1wb3J0IHsgZ2V0TGF5b3V0UmVjdCB9IGZyb20gJy4uLy4uL3V0aWwvbGF5b3V0JztcbmltcG9ydCBDb21wb25lbnRNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Db21wb25lbnQnO1xuaW1wb3J0IENvbXBvbmVudFZpZXcgZnJvbSAnLi4vLi4vdmlldy9Db21wb25lbnQnO1xuaW1wb3J0IHsgd2luZG93T3BlbiB9IGZyb20gJy4uLy4uL3V0aWwvZm9ybWF0JztcblxudmFyIFRpdGxlTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVGl0bGVNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBUaXRsZU1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IFRpdGxlTW9kZWwudHlwZTtcbiAgICBfdGhpcy5sYXlvdXRNb2RlID0ge1xuICAgICAgdHlwZTogJ2JveCcsXG4gICAgICBpZ25vcmVTaXplOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUaXRsZU1vZGVsLnR5cGUgPSAndGl0bGUnO1xuICBUaXRsZU1vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDYsXG4gICAgc2hvdzogdHJ1ZSxcbiAgICB0ZXh0OiAnJyxcbiAgICB0YXJnZXQ6ICdibGFuaycsXG4gICAgc3VidGV4dDogJycsXG4gICAgc3VidGFyZ2V0OiAnYmxhbmsnLFxuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgcGFkZGluZzogNSxcbiAgICBpdGVtR2FwOiAxMCxcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIGZvbnRTaXplOiAxOCxcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgIGNvbG9yOiAnIzQ2NDY0NidcbiAgICB9LFxuICAgIHN1YnRleHRTdHlsZToge1xuICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgY29sb3I6ICcjNkU3MDc5J1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFRpdGxlTW9kZWw7XG59KENvbXBvbmVudE1vZGVsKTsgLy8gVmlld1xuXG5cbnZhciBUaXRsZVZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVGl0bGVWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFRpdGxlVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBUaXRsZVZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUaXRsZVZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICh0aXRsZU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgaWYgKCF0aXRsZU1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSB0aXRsZU1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICB2YXIgc3VidGV4dFN0eWxlTW9kZWwgPSB0aXRsZU1vZGVsLmdldE1vZGVsKCdzdWJ0ZXh0U3R5bGUnKTtcbiAgICB2YXIgdGV4dEFsaWduID0gdGl0bGVNb2RlbC5nZXQoJ3RleHRBbGlnbicpO1xuICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHpyVXRpbC5yZXRyaWV2ZTIodGl0bGVNb2RlbC5nZXQoJ3RleHRCYXNlbGluZScpLCB0aXRsZU1vZGVsLmdldCgndGV4dFZlcnRpY2FsQWxpZ24nKSk7XG4gICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgc3R5bGU6IGNyZWF0ZVRleHRTdHlsZSh0ZXh0U3R5bGVNb2RlbCwge1xuICAgICAgICB0ZXh0OiB0aXRsZU1vZGVsLmdldCgndGV4dCcpLFxuICAgICAgICBmaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKVxuICAgICAgfSwge1xuICAgICAgICBkaXNhYmxlQm94OiB0cnVlXG4gICAgICB9KSxcbiAgICAgIHoyOiAxMFxuICAgIH0pO1xuICAgIHZhciB0ZXh0UmVjdCA9IHRleHRFbC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgc3ViVGV4dCA9IHRpdGxlTW9kZWwuZ2V0KCdzdWJ0ZXh0Jyk7XG4gICAgdmFyIHN1YlRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgc3R5bGU6IGNyZWF0ZVRleHRTdHlsZShzdWJ0ZXh0U3R5bGVNb2RlbCwge1xuICAgICAgICB0ZXh0OiBzdWJUZXh0LFxuICAgICAgICBmaWxsOiBzdWJ0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSxcbiAgICAgICAgeTogdGV4dFJlY3QuaGVpZ2h0ICsgdGl0bGVNb2RlbC5nZXQoJ2l0ZW1HYXAnKSxcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCdcbiAgICAgIH0sIHtcbiAgICAgICAgZGlzYWJsZUJveDogdHJ1ZVxuICAgICAgfSksXG4gICAgICB6MjogMTBcbiAgICB9KTtcbiAgICB2YXIgbGluayA9IHRpdGxlTW9kZWwuZ2V0KCdsaW5rJyk7XG4gICAgdmFyIHN1YmxpbmsgPSB0aXRsZU1vZGVsLmdldCgnc3VibGluaycpO1xuICAgIHZhciB0cmlnZ2VyRXZlbnQgPSB0aXRsZU1vZGVsLmdldCgndHJpZ2dlckV2ZW50JywgdHJ1ZSk7XG4gICAgdGV4dEVsLnNpbGVudCA9ICFsaW5rICYmICF0cmlnZ2VyRXZlbnQ7XG4gICAgc3ViVGV4dEVsLnNpbGVudCA9ICFzdWJsaW5rICYmICF0cmlnZ2VyRXZlbnQ7XG5cbiAgICBpZiAobGluaykge1xuICAgICAgdGV4dEVsLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93T3BlbihsaW5rLCAnXycgKyB0aXRsZU1vZGVsLmdldCgndGFyZ2V0JykpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHN1YmxpbmspIHtcbiAgICAgIHN1YlRleHRFbC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvd09wZW4oc3VibGluaywgJ18nICsgdGl0bGVNb2RlbC5nZXQoJ3N1YnRhcmdldCcpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldEVDRGF0YSh0ZXh0RWwpLmV2ZW50RGF0YSA9IGdldEVDRGF0YShzdWJUZXh0RWwpLmV2ZW50RGF0YSA9IHRyaWdnZXJFdmVudCA/IHtcbiAgICAgIGNvbXBvbmVudFR5cGU6ICd0aXRsZScsXG4gICAgICBjb21wb25lbnRJbmRleDogdGl0bGVNb2RlbC5jb21wb25lbnRJbmRleFxuICAgIH0gOiBudWxsO1xuICAgIGdyb3VwLmFkZCh0ZXh0RWwpO1xuICAgIHN1YlRleHQgJiYgZ3JvdXAuYWRkKHN1YlRleHRFbCk7IC8vIElmIG5vIHN1YlRleHQsIGJ1dCBhZGQgc3ViVGV4dEVsLCB0aGVyZSB3aWxsIGJlIGFuIGVtcHR5IGxpbmUuXG5cbiAgICB2YXIgZ3JvdXBSZWN0ID0gZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIGxheW91dE9wdGlvbiA9IHRpdGxlTW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCk7XG4gICAgbGF5b3V0T3B0aW9uLndpZHRoID0gZ3JvdXBSZWN0LndpZHRoO1xuICAgIGxheW91dE9wdGlvbi5oZWlnaHQgPSBncm91cFJlY3QuaGVpZ2h0O1xuICAgIHZhciBsYXlvdXRSZWN0ID0gZ2V0TGF5b3V0UmVjdChsYXlvdXRPcHRpb24sIHtcbiAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgfSwgdGl0bGVNb2RlbC5nZXQoJ3BhZGRpbmcnKSk7IC8vIEFkanVzdCB0ZXh0IGFsaWduIGJhc2VkIG9uIHBvc2l0aW9uXG5cbiAgICBpZiAoIXRleHRBbGlnbikge1xuICAgICAgLy8gQWxpZ24gbGVmdCBpZiB0aXRsZSBpcyBvbiB0aGUgbGVmdC4gY2VudGVyIGFuZCByaWdodCBpcyBzYW1lXG4gICAgICB0ZXh0QWxpZ24gPSB0aXRsZU1vZGVsLmdldCgnbGVmdCcpIHx8IHRpdGxlTW9kZWwuZ2V0KCdyaWdodCcpOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdtaWRkbGUnKSB7XG4gICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgfSAvLyBBZGp1c3QgbGF5b3V0IGJ5IHRleHQgYWxpZ25cblxuXG4gICAgICBpZiAodGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIGxheW91dFJlY3QueCArPSBsYXlvdXRSZWN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGxheW91dFJlY3QueCArPSBsYXlvdXRSZWN0LndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IHRpdGxlTW9kZWwuZ2V0KCd0b3AnKSB8fCB0aXRsZU1vZGVsLmdldCgnYm90dG9tJyk7IC8vIEB0cy1pZ25vcmVcblxuICAgICAgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIGxheW91dFJlY3QueSArPSBsYXlvdXRSZWN0LmhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICdtaWRkbGUnKSB7XG4gICAgICAgIGxheW91dFJlY3QueSArPSBsYXlvdXRSZWN0LmhlaWdodCAvIDI7XG4gICAgICB9XG5cbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gdGV4dFZlcnRpY2FsQWxpZ24gfHwgJ3RvcCc7XG4gICAgfVxuXG4gICAgZ3JvdXAueCA9IGxheW91dFJlY3QueDtcbiAgICBncm91cC55ID0gbGF5b3V0UmVjdC55O1xuICAgIGdyb3VwLm1hcmtSZWRyYXcoKTtcbiAgICB2YXIgYWxpZ25TdHlsZSA9IHtcbiAgICAgIGFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICB2ZXJ0aWNhbEFsaWduOiB0ZXh0VmVydGljYWxBbGlnblxuICAgIH07XG4gICAgdGV4dEVsLnNldFN0eWxlKGFsaWduU3R5bGUpO1xuICAgIHN1YlRleHRFbC5zZXRTdHlsZShhbGlnblN0eWxlKTsgLy8gUmVuZGVyIGJhY2tncm91bmRcbiAgICAvLyBHZXQgZ3JvdXBSZWN0IGFnYWluIGJlY2F1c2UgdGV4dEFsaWduIGhhcyBiZWVuIGNoYW5nZWRcblxuICAgIGdyb3VwUmVjdCA9IGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBwYWRkaW5nID0gbGF5b3V0UmVjdC5tYXJnaW47XG4gICAgdmFyIHN0eWxlID0gdGl0bGVNb2RlbC5nZXRJdGVtU3R5bGUoWydjb2xvcicsICdvcGFjaXR5J10pO1xuICAgIHN0eWxlLmZpbGwgPSB0aXRsZU1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XG4gICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHg6IGdyb3VwUmVjdC54IC0gcGFkZGluZ1szXSxcbiAgICAgICAgeTogZ3JvdXBSZWN0LnkgLSBwYWRkaW5nWzBdLFxuICAgICAgICB3aWR0aDogZ3JvdXBSZWN0LndpZHRoICsgcGFkZGluZ1sxXSArIHBhZGRpbmdbM10sXG4gICAgICAgIGhlaWdodDogZ3JvdXBSZWN0LmhlaWdodCArIHBhZGRpbmdbMF0gKyBwYWRkaW5nWzJdLFxuICAgICAgICByOiB0aXRsZU1vZGVsLmdldCgnYm9yZGVyUmFkaXVzJylcbiAgICAgIH0sXG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICBzdWJQaXhlbE9wdGltaXplOiB0cnVlLFxuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSk7XG4gICAgZ3JvdXAuYWRkKHJlY3QpO1xuICB9O1xuXG4gIFRpdGxlVmlldy50eXBlID0gJ3RpdGxlJztcbiAgcmV0dXJuIFRpdGxlVmlldztcbn0oQ29tcG9uZW50Vmlldyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChUaXRsZU1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhUaXRsZVZpZXcpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgZmVhdHVyZU1hbmFnZXIgZnJvbSAnLi9mZWF0dXJlTWFuYWdlcic7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50JztcblxudmFyIFRvb2xib3hNb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUb29sYm94TW9kZWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gVG9vbGJveE1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IFRvb2xib3hNb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFRvb2xib3hNb2RlbC5wcm90b3R5cGUub3B0aW9uVXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgIHpyVXRpbC5lYWNoKHRoaXMub3B0aW9uLmZlYXR1cmUsIGZ1bmN0aW9uIChmZWF0dXJlT3B0LCBmZWF0dXJlTmFtZSkge1xuICAgICAgdmFyIEZlYXR1cmUgPSBmZWF0dXJlTWFuYWdlci5nZXRGZWF0dXJlKGZlYXR1cmVOYW1lKTtcblxuICAgICAgaWYgKEZlYXR1cmUpIHtcbiAgICAgICAgaWYgKEZlYXR1cmUuZ2V0RGVmYXVsdE9wdGlvbikge1xuICAgICAgICAgIEZlYXR1cmUuZGVmYXVsdE9wdGlvbiA9IEZlYXR1cmUuZ2V0RGVmYXVsdE9wdGlvbihlY01vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHpyVXRpbC5tZXJnZShmZWF0dXJlT3B0LCBGZWF0dXJlLmRlZmF1bHRPcHRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFRvb2xib3hNb2RlbC50eXBlID0gJ3Rvb2xib3gnO1xuICBUb29sYm94TW9kZWwubGF5b3V0TW9kZSA9IHtcbiAgICB0eXBlOiAnYm94JyxcbiAgICBpZ25vcmVTaXplOiB0cnVlXG4gIH07XG4gIFRvb2xib3hNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIHNob3c6IHRydWUsXG4gICAgejogNixcbiAgICB6bGV2ZWw6IDAsXG4gICAgb3JpZW50OiAnaG9yaXpvbnRhbCcsXG4gICAgbGVmdDogJ3JpZ2h0JyxcbiAgICB0b3A6ICd0b3AnLFxuICAgIC8vIHJpZ2h0XG4gICAgLy8gYm90dG9tXG4gICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIHBhZGRpbmc6IDUsXG4gICAgaXRlbVNpemU6IDE1LFxuICAgIGl0ZW1HYXA6IDgsXG4gICAgc2hvd1RpdGxlOiB0cnVlLFxuICAgIGljb25TdHlsZToge1xuICAgICAgYm9yZGVyQ29sb3I6ICcjNjY2JyxcbiAgICAgIGNvbG9yOiAnbm9uZSdcbiAgICB9LFxuICAgIGVtcGhhc2lzOiB7XG4gICAgICBpY29uU3R5bGU6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjM0U5OEM1J1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gdGV4dFN0eWxlOiB7fSxcbiAgICAvLyBmZWF0dXJlXG4gICAgdG9vbHRpcDoge1xuICAgICAgc2hvdzogZmFsc2VcbiAgICB9XG4gIH07XG4gIHJldHVybiBUb29sYm94TW9kZWw7XG59KENvbXBvbmVudE1vZGVsKTtcblxuZXhwb3J0IGRlZmF1bHQgVG9vbGJveE1vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgdGV4dENvbnRhaW4gZnJvbSAnenJlbmRlci9saWIvY29udGFpbi90ZXh0JztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCB7IGVudGVyRW1waGFzaXMsIGxlYXZlRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcyc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvTW9kZWwnO1xuaW1wb3J0IERhdGFEaWZmZXIgZnJvbSAnLi4vLi4vZGF0YS9EYXRhRGlmZmVyJztcbmltcG9ydCAqIGFzIGxpc3RDb21wb25lbnRIZWxwZXIgZnJvbSAnLi4vaGVscGVyL2xpc3RDb21wb25lbnQnO1xuaW1wb3J0IENvbXBvbmVudFZpZXcgZnJvbSAnLi4vLi4vdmlldy9Db21wb25lbnQnO1xuaW1wb3J0IHsgVG9vbGJveEZlYXR1cmUsIGdldEZlYXR1cmUgfSBmcm9tICcuL2ZlYXR1cmVNYW5hZ2VyJztcbmltcG9ydCB7IGdldFVJRCB9IGZyb20gJy4uLy4uL3V0aWwvY29tcG9uZW50JztcbmltcG9ydCBaUlRleHQgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0JztcblxudmFyIFRvb2xib3hWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRvb2xib3hWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFRvb2xib3hWaWV3KCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIFRvb2xib3hWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodG9vbGJveE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgaWYgKCF0b29sYm94TW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXRlbVNpemUgPSArdG9vbGJveE1vZGVsLmdldCgnaXRlbVNpemUnKTtcbiAgICB2YXIgZmVhdHVyZU9wdHMgPSB0b29sYm94TW9kZWwuZ2V0KCdmZWF0dXJlJykgfHwge307XG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5fZmVhdHVyZXMgfHwgKHRoaXMuX2ZlYXR1cmVzID0ge30pO1xuICAgIHZhciBmZWF0dXJlTmFtZXMgPSBbXTtcbiAgICB6clV0aWwuZWFjaChmZWF0dXJlT3B0cywgZnVuY3Rpb24gKG9wdCwgbmFtZSkge1xuICAgICAgZmVhdHVyZU5hbWVzLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgbmV3IERhdGFEaWZmZXIodGhpcy5fZmVhdHVyZU5hbWVzIHx8IFtdLCBmZWF0dXJlTmFtZXMpLmFkZChwcm9jZXNzRmVhdHVyZSkudXBkYXRlKHByb2Nlc3NGZWF0dXJlKS5yZW1vdmUoenJVdGlsLmN1cnJ5KHByb2Nlc3NGZWF0dXJlLCBudWxsKSkuZXhlY3V0ZSgpOyAvLyBLZWVwIGZvciBkaWZmLlxuXG4gICAgdGhpcy5fZmVhdHVyZU5hbWVzID0gZmVhdHVyZU5hbWVzO1xuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0ZlYXR1cmUobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gICAgICB2YXIgZmVhdHVyZU5hbWUgPSBmZWF0dXJlTmFtZXNbbmV3SW5kZXhdO1xuICAgICAgdmFyIG9sZE5hbWUgPSBmZWF0dXJlTmFtZXNbb2xkSW5kZXhdO1xuICAgICAgdmFyIGZlYXR1cmVPcHQgPSBmZWF0dXJlT3B0c1tmZWF0dXJlTmFtZV07XG4gICAgICB2YXIgZmVhdHVyZU1vZGVsID0gbmV3IE1vZGVsKGZlYXR1cmVPcHQsIHRvb2xib3hNb2RlbCwgdG9vbGJveE1vZGVsLmVjTW9kZWwpO1xuICAgICAgdmFyIGZlYXR1cmU7IC8vIEZJWCMxMTIzNiwgbWVyZ2UgZmVhdHVyZSB0aXRsZSBmcm9tIE1hZ2ljVHlwZSBuZXdPcHRpb24uIFRPRE86IGNvbnNpZGVyIHNlcmllc0luZGV4ID9cblxuICAgICAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC5uZXdUaXRsZSAhPSBudWxsICYmIHBheWxvYWQuZmVhdHVyZU5hbWUgPT09IGZlYXR1cmVOYW1lKSB7XG4gICAgICAgIGZlYXR1cmVPcHQudGl0bGUgPSBwYXlsb2FkLm5ld1RpdGxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmVhdHVyZU5hbWUgJiYgIW9sZE5hbWUpIHtcbiAgICAgICAgLy8gQ3JlYXRlXG4gICAgICAgIGlmIChpc1VzZXJGZWF0dXJlTmFtZShmZWF0dXJlTmFtZSkpIHtcbiAgICAgICAgICBmZWF0dXJlID0ge1xuICAgICAgICAgICAgb25jbGljazogZmVhdHVyZU1vZGVsLm9wdGlvbi5vbmNsaWNrLFxuICAgICAgICAgICAgZmVhdHVyZU5hbWU6IGZlYXR1cmVOYW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgRmVhdHVyZSA9IGdldEZlYXR1cmUoZmVhdHVyZU5hbWUpO1xuXG4gICAgICAgICAgaWYgKCFGZWF0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmVhdHVyZSA9IG5ldyBGZWF0dXJlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmZWF0dXJlc1tmZWF0dXJlTmFtZV0gPSBmZWF0dXJlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmVhdHVyZSA9IGZlYXR1cmVzW29sZE5hbWVdOyAvLyBJZiBmZWF0dXJlIGRvZXMgbm90IGV4c2l0LlxuXG4gICAgICAgIGlmICghZmVhdHVyZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmZWF0dXJlLnVpZCA9IGdldFVJRCgndG9vbGJveC1mZWF0dXJlJyk7XG4gICAgICBmZWF0dXJlLm1vZGVsID0gZmVhdHVyZU1vZGVsO1xuICAgICAgZmVhdHVyZS5lY01vZGVsID0gZWNNb2RlbDtcbiAgICAgIGZlYXR1cmUuYXBpID0gYXBpO1xuXG4gICAgICBpZiAoZmVhdHVyZSBpbnN0YW5jZW9mIFRvb2xib3hGZWF0dXJlKSB7XG4gICAgICAgIGlmICghZmVhdHVyZU5hbWUgJiYgb2xkTmFtZSkge1xuICAgICAgICAgIGZlYXR1cmUuZGlzcG9zZSAmJiBmZWF0dXJlLmRpc3Bvc2UoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZlYXR1cmVNb2RlbC5nZXQoJ3Nob3cnKSB8fCBmZWF0dXJlLnVudXNhYmxlKSB7XG4gICAgICAgICAgZmVhdHVyZS5yZW1vdmUgJiYgZmVhdHVyZS5yZW1vdmUoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3JlYXRlSWNvblBhdGhzKGZlYXR1cmVNb2RlbCwgZmVhdHVyZSwgZmVhdHVyZU5hbWUpO1xuXG4gICAgICBmZWF0dXJlTW9kZWwuc2V0SWNvblN0YXR1cyA9IGZ1bmN0aW9uIChpY29uTmFtZSwgc3RhdHVzKSB7XG4gICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgdmFyIGljb25QYXRocyA9IHRoaXMuaWNvblBhdGhzO1xuICAgICAgICBvcHRpb24uaWNvblN0YXR1cyA9IG9wdGlvbi5pY29uU3RhdHVzIHx8IHt9O1xuICAgICAgICBvcHRpb24uaWNvblN0YXR1c1tpY29uTmFtZV0gPSBzdGF0dXM7XG5cbiAgICAgICAgaWYgKGljb25QYXRoc1tpY29uTmFtZV0pIHtcbiAgICAgICAgICAoc3RhdHVzID09PSAnZW1waGFzaXMnID8gZW50ZXJFbXBoYXNpcyA6IGxlYXZlRW1waGFzaXMpKGljb25QYXRoc1tpY29uTmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoZmVhdHVyZSBpbnN0YW5jZW9mIFRvb2xib3hGZWF0dXJlKSB7XG4gICAgICAgIGlmIChmZWF0dXJlLnJlbmRlcikge1xuICAgICAgICAgIGZlYXR1cmUucmVuZGVyKGZlYXR1cmVNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUljb25QYXRocyhmZWF0dXJlTW9kZWwsIGZlYXR1cmUsIGZlYXR1cmVOYW1lKSB7XG4gICAgICB2YXIgaWNvblN0eWxlTW9kZWwgPSBmZWF0dXJlTW9kZWwuZ2V0TW9kZWwoJ2ljb25TdHlsZScpO1xuICAgICAgdmFyIGljb25TdHlsZUVtcGhhc2lzTW9kZWwgPSBmZWF0dXJlTW9kZWwuZ2V0TW9kZWwoWydlbXBoYXNpcycsICdpY29uU3R5bGUnXSk7IC8vIElmIG9uZSBmZWF0dXJlIGhhcyBtdXRpcGxlIGljb24uIHRoZXkgYXJlIG9yZ2luYWl6ZWQgYXNcbiAgICAgIC8vIHtcbiAgICAgIC8vICAgICBpY29uOiB7XG4gICAgICAvLyAgICAgICAgIGZvbzogJycsXG4gICAgICAvLyAgICAgICAgIGJhcjogJydcbiAgICAgIC8vICAgICB9LFxuICAgICAgLy8gICAgIHRpdGxlOiB7XG4gICAgICAvLyAgICAgICAgIGZvbzogJycsXG4gICAgICAvLyAgICAgICAgIGJhcjogJydcbiAgICAgIC8vICAgICB9XG4gICAgICAvLyB9XG5cbiAgICAgIHZhciBpY29ucyA9IGZlYXR1cmUgaW5zdGFuY2VvZiBUb29sYm94RmVhdHVyZSAmJiBmZWF0dXJlLmdldEljb25zID8gZmVhdHVyZS5nZXRJY29ucygpIDogZmVhdHVyZU1vZGVsLmdldCgnaWNvbicpO1xuICAgICAgdmFyIHRpdGxlcyA9IGZlYXR1cmVNb2RlbC5nZXQoJ3RpdGxlJykgfHwge307XG4gICAgICB2YXIgaWNvbnNNYXA7XG4gICAgICB2YXIgdGl0bGVzTWFwO1xuXG4gICAgICBpZiAodHlwZW9mIGljb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBpY29uc01hcCA9IHt9O1xuICAgICAgICBpY29uc01hcFtmZWF0dXJlTmFtZV0gPSBpY29ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGljb25zTWFwID0gaWNvbnM7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGl0bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aXRsZXNNYXAgPSB7fTtcbiAgICAgICAgdGl0bGVzTWFwW2ZlYXR1cmVOYW1lXSA9IHRpdGxlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlc01hcCA9IHRpdGxlcztcbiAgICAgIH1cblxuICAgICAgdmFyIGljb25QYXRocyA9IGZlYXR1cmVNb2RlbC5pY29uUGF0aHMgPSB7fTtcbiAgICAgIHpyVXRpbC5lYWNoKGljb25zTWFwLCBmdW5jdGlvbiAoaWNvblN0ciwgaWNvbk5hbWUpIHtcbiAgICAgICAgdmFyIHBhdGggPSBncmFwaGljLmNyZWF0ZUljb24oaWNvblN0ciwge30sIHtcbiAgICAgICAgICB4OiAtaXRlbVNpemUgLyAyLFxuICAgICAgICAgIHk6IC1pdGVtU2l6ZSAvIDIsXG4gICAgICAgICAgd2lkdGg6IGl0ZW1TaXplLFxuICAgICAgICAgIGhlaWdodDogaXRlbVNpemVcbiAgICAgICAgfSk7IC8vIFRPRE8gaGFuZGxpbmcgaW1hZ2VcblxuICAgICAgICBwYXRoLnNldFN0eWxlKGljb25TdHlsZU1vZGVsLmdldEl0ZW1TdHlsZSgpKTtcbiAgICAgICAgdmFyIHBhdGhFbXBoYXNpc1N0YXRlID0gcGF0aC5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKTtcbiAgICAgICAgcGF0aEVtcGhhc2lzU3RhdGUuc3R5bGUgPSBpY29uU3R5bGVFbXBoYXNpc01vZGVsLmdldEl0ZW1TdHlsZSgpOyAvLyBUZXh0IHBvc2l0aW9uIGNhbGN1bGF0aW9uXG5cbiAgICAgICAgdmFyIHRleHRDb250ZW50ID0gbmV3IFpSVGV4dCh7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHRleHQ6IHRpdGxlc01hcFtpY29uTmFtZV0sXG4gICAgICAgICAgICBhbGlnbjogaWNvblN0eWxlRW1waGFzaXNNb2RlbC5nZXQoJ3RleHRBbGlnbicpLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBpY29uU3R5bGVFbXBoYXNpc01vZGVsLmdldCgndGV4dEJvcmRlclJhZGl1cycpLFxuICAgICAgICAgICAgcGFkZGluZzogaWNvblN0eWxlRW1waGFzaXNNb2RlbC5nZXQoJ3RleHRQYWRkaW5nJyksXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZ25vcmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHBhdGguc2V0VGV4dENvbnRlbnQodGV4dENvbnRlbnQpO1xuICAgICAgICB2YXIgdG9vbHRpcE1vZGVsID0gdG9vbGJveE1vZGVsLmdldE1vZGVsKCd0b29sdGlwJyk7XG5cbiAgICAgICAgaWYgKHRvb2x0aXBNb2RlbCAmJiB0b29sdGlwTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICBwYXRoLnRvb2x0aXAgPSB6clV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRpdGxlc01hcFtpY29uTmFtZV0sXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IHRvb2x0aXBNb2RlbC5nZXQoJ2Zvcm1hdHRlcicsIHRydWUpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRpdGxlc01hcFtpY29uTmFtZV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0dGVyUGFyYW1zOiB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6ICd0b29sYm94JyxcbiAgICAgICAgICAgICAgbmFtZTogaWNvbk5hbWUsXG4gICAgICAgICAgICAgIHRpdGxlOiB0aXRsZXNNYXBbaWNvbk5hbWVdLFxuICAgICAgICAgICAgICAkdmFyczogWyduYW1lJywgJ3RpdGxlJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjogdG9vbHRpcE1vZGVsLmdldCgncG9zaXRpb24nLCB0cnVlKSB8fCAnYm90dG9tJ1xuICAgICAgICAgIH0sIHRvb2x0aXBNb2RlbC5vcHRpb24pO1xuICAgICAgICB9IC8vIGdyYXBoaWMuZW5hYmxlSG92ZXJFbXBoYXNpcyhwYXRoKTtcblxuXG4gICAgICAgIHBhdGguX190aXRsZSA9IHRpdGxlc01hcFtpY29uTmFtZV07XG4gICAgICAgIHBhdGgub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBTaG91bGQgbm90IHJldXNlIGFib3ZlIGhvdmVyU3R5bGUsIHdoaWNoIG1pZ2h0IGJlIG1vZGlmaWVkLlxuICAgICAgICAgIHZhciBob3ZlclN0eWxlID0gaWNvblN0eWxlRW1waGFzaXNNb2RlbC5nZXRJdGVtU3R5bGUoKTtcbiAgICAgICAgICB2YXIgZGVmYXVsdFRleHRQb3NpdGlvbiA9IHRvb2xib3hNb2RlbC5nZXQoJ29yaWVudCcpID09PSAndmVydGljYWwnID8gdG9vbGJveE1vZGVsLmdldCgncmlnaHQnKSA9PSBudWxsID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IHRvb2xib3hNb2RlbC5nZXQoJ2JvdHRvbScpID09IG51bGwgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgICAgIHRleHRDb250ZW50LnNldFN0eWxlKHtcbiAgICAgICAgICAgIGZpbGw6IGljb25TdHlsZUVtcGhhc2lzTW9kZWwuZ2V0KCd0ZXh0RmlsbCcpIHx8IGhvdmVyU3R5bGUuZmlsbCB8fCBob3ZlclN0eWxlLnN0cm9rZSB8fCAnIzAwMCcsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGljb25TdHlsZUVtcGhhc2lzTW9kZWwuZ2V0KCd0ZXh0QmFja2dyb3VuZENvbG9yJylcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXRoLnNldFRleHRDb25maWcoe1xuICAgICAgICAgICAgcG9zaXRpb246IGljb25TdHlsZUVtcGhhc2lzTW9kZWwuZ2V0KCd0ZXh0UG9zaXRpb24nKSB8fCBkZWZhdWx0VGV4dFBvc2l0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGV4dENvbnRlbnQuaWdub3JlID0gIXRvb2xib3hNb2RlbC5nZXQoJ3Nob3dUaXRsZScpOyAvLyBVc2UgZW50ZXJFbXBoYXNpcyBhbmQgbGVhdmVFbXBoYXNpcyBwcm92aWRlIGJ5IGVjLlxuICAgICAgICAgIC8vIFRoZXJlIGFyZSBmbGFncyBtYW5hZ2VkIGJ5IHRoZSBlY2hhcnRzLlxuXG4gICAgICAgICAgZW50ZXJFbXBoYXNpcyh0aGlzKTtcbiAgICAgICAgfSkub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmZWF0dXJlTW9kZWwuZ2V0KFsnaWNvblN0YXR1cycsIGljb25OYW1lXSkgIT09ICdlbXBoYXNpcycpIHtcbiAgICAgICAgICAgIGxlYXZlRW1waGFzaXModGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGV4dENvbnRlbnQuaGlkZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgKGZlYXR1cmVNb2RlbC5nZXQoWydpY29uU3RhdHVzJywgaWNvbk5hbWVdKSA9PT0gJ2VtcGhhc2lzJyA/IGVudGVyRW1waGFzaXMgOiBsZWF2ZUVtcGhhc2lzKShwYXRoKTtcbiAgICAgICAgZ3JvdXAuYWRkKHBhdGgpO1xuICAgICAgICBwYXRoLm9uKCdjbGljaycsIHpyVXRpbC5iaW5kKGZlYXR1cmUub25jbGljaywgZmVhdHVyZSwgZWNNb2RlbCwgYXBpLCBpY29uTmFtZSkpO1xuICAgICAgICBpY29uUGF0aHNbaWNvbk5hbWVdID0gcGF0aDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxpc3RDb21wb25lbnRIZWxwZXIubGF5b3V0KGdyb3VwLCB0b29sYm94TW9kZWwsIGFwaSk7IC8vIFJlbmRlciBiYWNrZ3JvdW5kIGFmdGVyIGdyb3VwIGlzIGxheW91dFxuICAgIC8vIEZJWE1FXG5cbiAgICBncm91cC5hZGQobGlzdENvbXBvbmVudEhlbHBlci5tYWtlQmFja2dyb3VuZChncm91cC5nZXRCb3VuZGluZ1JlY3QoKSwgdG9vbGJveE1vZGVsKSk7IC8vIEFkanVzdCBpY29uIHRpdGxlIHBvc2l0aW9ucyB0byBhdm9pZCB0aGVtIG91dCBvZiBzY3JlZW5cblxuICAgIGdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoaWNvbikge1xuICAgICAgdmFyIHRpdGxlVGV4dCA9IGljb24uX190aXRsZTsgLy8gY29uc3QgaG92ZXJTdHlsZSA9IGljb24uaG92ZXJTdHlsZTtcbiAgICAgIC8vIFRPRE8gc2ltcGxpZnkgY29kZT9cblxuICAgICAgdmFyIGVtcGhhc2lzU3RhdGUgPSBpY29uLmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpO1xuICAgICAgdmFyIGVtcGhhc2lzVGV4dENvbmZpZyA9IGVtcGhhc2lzU3RhdGUudGV4dENvbmZpZyB8fCAoZW1waGFzaXNTdGF0ZS50ZXh0Q29uZmlnID0ge30pO1xuICAgICAgdmFyIHRleHRDb250ZW50ID0gaWNvbi5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgdmFyIGVtcGhhc2lzVGV4dFN0YXRlID0gdGV4dENvbnRlbnQgJiYgdGV4dENvbnRlbnQuc3RhdGVzLmVtcGhhc2lzOyAvLyBNYXkgYmUgYmFja2dyb3VuZCBlbGVtZW50XG5cbiAgICAgIGlmIChlbXBoYXNpc1RleHRTdGF0ZSAmJiAhenJVdGlsLmlzRnVuY3Rpb24oZW1waGFzaXNUZXh0U3RhdGUpICYmIHRpdGxlVGV4dCkge1xuICAgICAgICB2YXIgZW1waGFzaXNUZXh0U3R5bGUgPSBlbXBoYXNpc1RleHRTdGF0ZS5zdHlsZSB8fCAoZW1waGFzaXNUZXh0U3RhdGUuc3R5bGUgPSB7fSk7XG4gICAgICAgIHZhciByZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRpdGxlVGV4dCwgWlJUZXh0Lm1ha2VGb250KGVtcGhhc2lzVGV4dFN0eWxlKSk7XG4gICAgICAgIHZhciBvZmZzZXRYID0gaWNvbi54ICsgZ3JvdXAueDtcbiAgICAgICAgdmFyIG9mZnNldFkgPSBpY29uLnkgKyBncm91cC55ICsgaXRlbVNpemU7XG4gICAgICAgIHZhciBuZWVkUHV0T25Ub3AgPSBmYWxzZTtcblxuICAgICAgICBpZiAob2Zmc2V0WSArIHJlY3QuaGVpZ2h0ID4gYXBpLmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgZW1waGFzaXNUZXh0Q29uZmlnLnBvc2l0aW9uID0gJ3RvcCc7XG4gICAgICAgICAgbmVlZFB1dE9uVG9wID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3BPZmZzZXQgPSBuZWVkUHV0T25Ub3AgPyAtNSAtIHJlY3QuaGVpZ2h0IDogaXRlbVNpemUgKyA4O1xuXG4gICAgICAgIGlmIChvZmZzZXRYICsgcmVjdC53aWR0aCAvIDIgPiBhcGkuZ2V0V2lkdGgoKSkge1xuICAgICAgICAgIGVtcGhhc2lzVGV4dENvbmZpZy5wb3NpdGlvbiA9IFsnMTAwJScsIHRvcE9mZnNldF07XG4gICAgICAgICAgZW1waGFzaXNUZXh0U3R5bGUuYWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKG9mZnNldFggLSByZWN0LndpZHRoIC8gMiA8IDApIHtcbiAgICAgICAgICBlbXBoYXNpc1RleHRDb25maWcucG9zaXRpb24gPSBbMCwgdG9wT2Zmc2V0XTtcbiAgICAgICAgICBlbXBoYXNpc1RleHRTdHlsZS5hbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFRvb2xib3hWaWV3LnByb3RvdHlwZS51cGRhdGVWaWV3ID0gZnVuY3Rpb24gKHRvb2xib3hNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgenJVdGlsLmVhY2godGhpcy5fZmVhdHVyZXMsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICBmZWF0dXJlIGluc3RhbmNlb2YgVG9vbGJveEZlYXR1cmUgJiYgZmVhdHVyZS51cGRhdGVWaWV3ICYmIGZlYXR1cmUudXBkYXRlVmlldyhmZWF0dXJlLm1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgIH0pO1xuICB9OyAvLyB1cGRhdGVMYXlvdXQodG9vbGJveE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgLy8gICAgIHpyVXRpbC5lYWNoKHRoaXMuX2ZlYXR1cmVzLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAvLyAgICAgICAgIGZlYXR1cmUudXBkYXRlTGF5b3V0ICYmIGZlYXR1cmUudXBkYXRlTGF5b3V0KGZlYXR1cmUubW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gIC8vICAgICB9KTtcbiAgLy8gfSxcblxuXG4gIFRvb2xib3hWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgenJVdGlsLmVhY2godGhpcy5fZmVhdHVyZXMsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICBmZWF0dXJlIGluc3RhbmNlb2YgVG9vbGJveEZlYXR1cmUgJiYgZmVhdHVyZS5yZW1vdmUgJiYgZmVhdHVyZS5yZW1vdmUoZWNNb2RlbCwgYXBpKTtcbiAgICB9KTtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICB9O1xuXG4gIFRvb2xib3hWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHpyVXRpbC5lYWNoKHRoaXMuX2ZlYXR1cmVzLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgZmVhdHVyZSBpbnN0YW5jZW9mIFRvb2xib3hGZWF0dXJlICYmIGZlYXR1cmUuZGlzcG9zZSAmJiBmZWF0dXJlLmRpc3Bvc2UoZWNNb2RlbCwgYXBpKTtcbiAgICB9KTtcbiAgfTtcblxuICBUb29sYm94Vmlldy50eXBlID0gJ3Rvb2xib3gnO1xuICByZXR1cm4gVG9vbGJveFZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuXG5mdW5jdGlvbiBpc1VzZXJGZWF0dXJlTmFtZShmZWF0dXJlTmFtZSkge1xuICByZXR1cm4gZmVhdHVyZU5hbWUuaW5kZXhPZignbXknKSA9PT0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVG9vbGJveFZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBUb29sYm94RmVhdHVyZSB9IGZyb20gJy4uL2ZlYXR1cmVNYW5hZ2VyJztcbnZhciBJQ09OX1RZUEVTID0gWydyZWN0JywgJ3BvbHlnb24nLCAnbGluZVgnLCAnbGluZVknLCAna2VlcCcsICdjbGVhciddO1xuXG52YXIgQnJ1c2hGZWF0dXJlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEJydXNoRmVhdHVyZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBCcnVzaEZlYXR1cmUoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgQnJ1c2hGZWF0dXJlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZmVhdHVyZU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgYnJ1c2hUeXBlO1xuICAgIHZhciBicnVzaE1vZGU7XG4gICAgdmFyIGlzQnJ1c2hlZDtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6ICdicnVzaCdcbiAgICB9LCBmdW5jdGlvbiAoYnJ1c2hNb2RlbCkge1xuICAgICAgYnJ1c2hUeXBlID0gYnJ1c2hNb2RlbC5icnVzaFR5cGU7XG4gICAgICBicnVzaE1vZGUgPSBicnVzaE1vZGVsLmJydXNoT3B0aW9uLmJydXNoTW9kZSB8fCAnc2luZ2xlJztcbiAgICAgIGlzQnJ1c2hlZCA9IGlzQnJ1c2hlZCB8fCAhIWJydXNoTW9kZWwuYXJlYXMubGVuZ3RoO1xuICAgIH0pO1xuICAgIHRoaXMuX2JydXNoVHlwZSA9IGJydXNoVHlwZTtcbiAgICB0aGlzLl9icnVzaE1vZGUgPSBicnVzaE1vZGU7XG4gICAgenJVdGlsLmVhY2goZmVhdHVyZU1vZGVsLmdldCgndHlwZScsIHRydWUpLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgZmVhdHVyZU1vZGVsLnNldEljb25TdGF0dXModHlwZSwgKHR5cGUgPT09ICdrZWVwJyA/IGJydXNoTW9kZSA9PT0gJ211bHRpcGxlJyA6IHR5cGUgPT09ICdjbGVhcicgPyBpc0JydXNoZWQgOiB0eXBlID09PSBicnVzaFR5cGUpID8gJ2VtcGhhc2lzJyA6ICdub3JtYWwnKTtcbiAgICB9KTtcbiAgfTtcblxuICBCcnVzaEZlYXR1cmUucHJvdG90eXBlLnVwZGF0ZVZpZXcgPSBmdW5jdGlvbiAoZmVhdHVyZU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLnJlbmRlcihmZWF0dXJlTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gIH07XG5cbiAgQnJ1c2hGZWF0dXJlLnByb3RvdHlwZS5nZXRJY29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgIHZhciBhdmFpbGFibGVJY29ucyA9IG1vZGVsLmdldCgnaWNvbicsIHRydWUpO1xuICAgIHZhciBpY29ucyA9IHt9O1xuICAgIHpyVXRpbC5lYWNoKG1vZGVsLmdldCgndHlwZScsIHRydWUpLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgaWYgKGF2YWlsYWJsZUljb25zW3R5cGVdKSB7XG4gICAgICAgIGljb25zW3R5cGVdID0gYXZhaWxhYmxlSWNvbnNbdHlwZV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGljb25zO1xuICB9O1xuXG4gIDtcblxuICBCcnVzaEZlYXR1cmUucHJvdG90eXBlLm9uY2xpY2sgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpLCB0eXBlKSB7XG4gICAgdmFyIGJydXNoVHlwZSA9IHRoaXMuX2JydXNoVHlwZTtcbiAgICB2YXIgYnJ1c2hNb2RlID0gdGhpcy5fYnJ1c2hNb2RlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdjbGVhcicpIHtcbiAgICAgIC8vIFRyaWdnZXIgcGFyYWxsZWwgYWN0aW9uIGZpcnN0bHlcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgIHR5cGU6ICdheGlzQXJlYVNlbGVjdCcsXG4gICAgICAgIGludGVydmFsczogW11cbiAgICAgIH0pO1xuICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ2JydXNoJyxcbiAgICAgICAgY29tbWFuZDogJ2NsZWFyJyxcbiAgICAgICAgLy8gQ2xlYXIgYWxsIGFyZWFzIG9mIGFsbCBicnVzaCBjb21wb25lbnRzLlxuICAgICAgICBhcmVhczogW11cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICB0eXBlOiAndGFrZUdsb2JhbEN1cnNvcicsXG4gICAgICAgIGtleTogJ2JydXNoJyxcbiAgICAgICAgYnJ1c2hPcHRpb246IHtcbiAgICAgICAgICBicnVzaFR5cGU6IHR5cGUgPT09ICdrZWVwJyA/IGJydXNoVHlwZSA6IGJydXNoVHlwZSA9PT0gdHlwZSA/IGZhbHNlIDogdHlwZSxcbiAgICAgICAgICBicnVzaE1vZGU6IHR5cGUgPT09ICdrZWVwJyA/IGJydXNoTW9kZSA9PT0gJ211bHRpcGxlJyA/ICdzaW5nbGUnIDogJ211bHRpcGxlJyA6IGJydXNoTW9kZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgO1xuXG4gIEJydXNoRmVhdHVyZS5nZXREZWZhdWx0T3B0aW9uID0gZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICB2YXIgZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICB0eXBlOiBJQ09OX1RZUEVTLnNsaWNlKCksXG4gICAgICBpY29uOiB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgICAgIHJlY3Q6ICdNNy4zLDM0LjcgTTAuNCwxMFYtMC4yaDkuOCBNODkuNiwxMFYtMC4yaC05LjggTTAuNCw2MHYxMC4yaDkuOCBNODkuNiw2MHYxMC4yaC05LjggTTEyLjMsMjIuNFYxMC41aDEzLjEgTTMzLjYsMTAuNWg3LjggTTQ5LjEsMTAuNWg3LjggTTc3LjUsMjIuNFYxMC41aC0xMyBNMTIuMywzMS4xdjguMiBNNzcuNywzMS4xdjguMiBNMTIuMyw0Ny42djExLjloMTMuMSBNMzMuNiw1OS41aDcuNiBNNDkuMSw1OS41IGg3LjcgTTc3LjUsNDcuNnYxMS45aC0xMycsXG4gICAgICAgIHBvbHlnb246ICdNNTUuMiwzNC45YzEuNywwLDMuMSwxLjQsMy4xLDMuMXMtMS40LDMuMS0zLjEsMy4xIHMtMy4xLTEuNC0zLjEtMy4xUzUzLjUsMzQuOSw1NS4yLDM0Ljl6IE01MC40LDUxYzEuNywwLDMuMSwxLjQsMy4xLDMuMWMwLDEuNy0xLjQsMy4xLTMuMSwzLjFjLTEuNywwLTMuMS0xLjQtMy4xLTMuMSBDNDcuMyw1Mi40LDQ4LjcsNTEsNTAuNCw1MXogTTU1LjYsMzcuMWwxLjUtNy44IE02MC4xLDEzLjVsMS42LTguN2wtNy44LDQgTTU5LDE5bC0xLDUuMyBNMjQsMTYuMWw2LjQsNC45bDYuNC0zLjMgTTQ4LjUsMTEuNiBsLTUuOSwzLjEgTTE5LjEsMTIuOEw5LjcsNS4xbDEuMSw3LjcgTTEzLjQsMjkuOGwxLDcuM2w2LjYsMS42IE0xMS42LDE4LjRsMSw2LjEgTTMyLjgsNDEuOSBNMjYuNiw0MC40IE0yNy4zLDQwLjJsNi4xLDEuNiBNNDkuOSw1Mi4xbC01LjYtNy42bC00LjktMS4yJyxcbiAgICAgICAgbGluZVg6ICdNMTUuMiwzMCBNMTkuNywxNS42VjEuOUgyOSBNMzQuOCwxLjlINDAuNCBNNTUuMywxNS42VjEuOUg0NS45IE0xOS43LDQ0LjRWNTguMUgyOSBNMzQuOCw1OC4xSDQwLjQgTTU1LjMsNDQuNCBWNTguMUg0NS45IE0xMi41LDIwLjNsLTkuNCw5LjZsOS42LDkuOCBNMy4xLDI5LjloMTYuNSBNNjIuNSwyMC4zbDkuNCw5LjZMNjIuMywzOS43IE03MS45LDI5LjlINTUuNCcsXG4gICAgICAgIGxpbmVZOiAnTTM4LjgsNy43IE01Mi43LDEyaDEzLjJ2OSBNNjUuOSwyNi42VjMyIE01Mi43LDQ2LjNoMTMuMnYtOSBNMjQuOSwxMkgxMS44djkgTTExLjgsMjYuNlYzMiBNMjQuOSw0Ni4zSDExLjh2LTkgTTQ4LjIsNS4xbC05LjMtOWwtOS40LDkuMiBNMzguOS0zLjlWMTIgTTQ4LjIsNTMuM2wtOS4zLDlsLTkuNC05LjIgTTM4LjksNjIuM1Y0Ni40JyxcbiAgICAgICAga2VlcDogJ000LDEwLjVWMWgxMC4zIE0yMC43LDFoNi4xIE0zMywxaDYuMSBNNTUuNCwxMC41VjFINDUuMiBNNCwxNy4zdjYuNiBNNTUuNiwxNy4zdjYuNiBNNCwzMC41VjQwaDEwLjMgTTIwLjcsNDAgaDYuMSBNMzMsNDBoNi4xIE01NS40LDMwLjVWNDBINDUuMiBNMjEsMTguOWg2Mi45djQ4LjZIMjFWMTguOXonLFxuICAgICAgICBjbGVhcjogJ00yMiwxNC43bDMwLjksMzEgTTUyLjksMTQuN0wyMiw0NS43IE00LjcsMTYuOFY0LjJoMTMuMSBNMjYsNC4yaDcuOCBNNDEuNiw0LjJoNy44IE03MC4zLDE2LjhWNC4ySDU3LjIgTTQuNywyNS45djguNiBNNzAuMywyNS45djguNiBNNC43LDQzLjJ2MTIuNmgxMy4xIE0yNiw1NS44aDcuOCBNNDEuNiw1NS44aDcuOCBNNzAuMyw0My4ydjEyLjZINTcuMicgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gICAgICB9LFxuICAgICAgLy8gYHJlY3RgLCBgcG9seWdvbmAsIGBsaW5lWGAsIGBsaW5lWWAsIGBrZWVwYCwgYGNsZWFyYFxuICAgICAgdGl0bGU6IGVjTW9kZWwuZ2V0TG9jYWxlKFsndG9vbGJveCcsICdicnVzaCcsICd0aXRsZSddKVxuICAgIH07XG4gICAgcmV0dXJuIGRlZmF1bHRPcHRpb247XG4gIH07XG5cbiAgcmV0dXJuIEJydXNoRmVhdHVyZTtcbn0oVG9vbGJveEZlYXR1cmUpO1xuXG5leHBvcnQgZGVmYXVsdCBCcnVzaEZlYXR1cmU7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgZWNoYXJ0cyBmcm9tICcuLi8uLi8uLi9jb3JlL2VjaGFydHMnO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBUb29sYm94RmVhdHVyZSB9IGZyb20gJy4uL2ZlYXR1cmVNYW5hZ2VyJztcbmltcG9ydCB7IGFkZEV2ZW50TGlzdGVuZXIgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL2V2ZW50JztcbnZhciBCTE9DS19TUExJVEVSID0gbmV3IEFycmF5KDYwKS5qb2luKCctJyk7XG52YXIgSVRFTV9TUExJVEVSID0gJ1xcdCc7XG4vKipcbiAqIEdyb3VwIHNlcmllcyBpbnRvIHR3byB0eXBlc1xuICogIDEuIG9uIGNhdGVnb3J5IGF4aXMsIGxpa2UgbGluZSwgYmFyXG4gKiAgMi4gb3RoZXJzLCBsaWtlIHNjYXR0ZXIsIHBpZVxuICovXG5cbmZ1bmN0aW9uIGdyb3VwU2VyaWVzKGVjTW9kZWwpIHtcbiAgdmFyIHNlcmllc0dyb3VwQnlDYXRlZ29yeUF4aXMgPSB7fTtcbiAgdmFyIG90aGVyU2VyaWVzID0gW107XG4gIHZhciBtZXRhID0gW107XG4gIGVjTW9kZWwuZWFjaFJhd1NlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgaWYgKGNvb3JkU3lzICYmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnIHx8IGNvb3JkU3lzLnR5cGUgPT09ICdwb2xhcicpKSB7XG4gICAgICAvLyBUT0RPOiBUWVBFIENvbnNpZGVyIHBvbGFyPyBJbmNsdWRlIHBvbGFyIG1heSBpbmNyZWFzZSB1bmVjZXNzYXJ5IGJ1bmRsZSBzaXplLlxuICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcblxuICAgICAgaWYgKGJhc2VBeGlzLnR5cGUgPT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgdmFyIGtleSA9IGJhc2VBeGlzLmRpbSArICdfJyArIGJhc2VBeGlzLmluZGV4O1xuXG4gICAgICAgIGlmICghc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpc1trZXldKSB7XG4gICAgICAgICAgc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpc1trZXldID0ge1xuICAgICAgICAgICAgY2F0ZWdvcnlBeGlzOiBiYXNlQXhpcyxcbiAgICAgICAgICAgIHZhbHVlQXhpczogY29vcmRTeXMuZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKSxcbiAgICAgICAgICAgIHNlcmllczogW11cbiAgICAgICAgICB9O1xuICAgICAgICAgIG1ldGEucHVzaCh7XG4gICAgICAgICAgICBheGlzRGltOiBiYXNlQXhpcy5kaW0sXG4gICAgICAgICAgICBheGlzSW5kZXg6IGJhc2VBeGlzLmluZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzW2tleV0uc2VyaWVzLnB1c2goc2VyaWVzTW9kZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3RoZXJTZXJpZXMucHVzaChzZXJpZXNNb2RlbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyU2VyaWVzLnB1c2goc2VyaWVzTW9kZWwpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpczogc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpcyxcbiAgICBvdGhlcjogb3RoZXJTZXJpZXMsXG4gICAgbWV0YTogbWV0YVxuICB9O1xufVxuLyoqXG4gKiBBc3NlbWJsZSBjb250ZW50IG9mIHNlcmllcyBvbiBjYXRlb2dvcnkgYXhpc1xuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlbWJsZVNlcmllc1dpdGhDYXRlZ29yeUF4aXMoZ3JvdXBzKSB7XG4gIHZhciB0YWJsZXMgPSBbXTtcbiAgenJVdGlsLmVhY2goZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXAsIGtleSkge1xuICAgIHZhciBjYXRlZ29yeUF4aXMgPSBncm91cC5jYXRlZ29yeUF4aXM7XG4gICAgdmFyIHZhbHVlQXhpcyA9IGdyb3VwLnZhbHVlQXhpcztcbiAgICB2YXIgdmFsdWVBeGlzRGltID0gdmFsdWVBeGlzLmRpbTtcbiAgICB2YXIgaGVhZGVycyA9IFsnICddLmNvbmNhdCh6clV0aWwubWFwKGdyb3VwLnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgcmV0dXJuIHNlcmllcy5uYW1lO1xuICAgIH0pKTsgLy8gQHRzLWlnbm9yZSBUT0RPIFBvbGFyXG5cbiAgICB2YXIgY29sdW1ucyA9IFtjYXRlZ29yeUF4aXMubW9kZWwuZ2V0Q2F0ZWdvcmllcygpXTtcbiAgICB6clV0aWwuZWFjaChncm91cC5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgIHZhciByYXdEYXRhID0gc2VyaWVzLmdldFJhd0RhdGEoKTtcbiAgICAgIGNvbHVtbnMucHVzaChzZXJpZXMuZ2V0UmF3RGF0YSgpLm1hcEFycmF5KHJhd0RhdGEubWFwRGltZW5zaW9uKHZhbHVlQXhpc0RpbSksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH0pKTtcbiAgICB9KTsgLy8gQXNzZW1ibGUgdGFibGUgY29udGVudFxuXG4gICAgdmFyIGxpbmVzID0gW2hlYWRlcnMuam9pbihJVEVNX1NQTElURVIpXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uc1swXS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1ucy5sZW5ndGg7IGorKykge1xuICAgICAgICBpdGVtcy5wdXNoKGNvbHVtbnNbal1baV0pO1xuICAgICAgfVxuXG4gICAgICBsaW5lcy5wdXNoKGl0ZW1zLmpvaW4oSVRFTV9TUExJVEVSKSk7XG4gICAgfVxuXG4gICAgdGFibGVzLnB1c2gobGluZXMuam9pbignXFxuJykpO1xuICB9KTtcbiAgcmV0dXJuIHRhYmxlcy5qb2luKCdcXG5cXG4nICsgQkxPQ0tfU1BMSVRFUiArICdcXG5cXG4nKTtcbn1cbi8qKlxuICogQXNzZW1ibGUgY29udGVudCBvZiBvdGhlciBzZXJpZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VtYmxlT3RoZXJTZXJpZXMoc2VyaWVzKSB7XG4gIHJldHVybiB6clV0aWwubWFwKHNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuICAgIHZhciBkYXRhID0gc2VyaWVzLmdldFJhd0RhdGEoKTtcbiAgICB2YXIgbGluZXMgPSBbc2VyaWVzLm5hbWVdO1xuICAgIHZhciB2YWxzID0gW107XG4gICAgZGF0YS5lYWNoKGRhdGEuZGltZW5zaW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ0xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgZGF0YUluZGV4ID0gYXJndW1lbnRzW2FyZ0xlbiAtIDFdO1xuICAgICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoZGF0YUluZGV4KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdMZW4gLSAxOyBpKyspIHtcbiAgICAgICAgdmFsc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIH1cblxuICAgICAgbGluZXMucHVzaCgobmFtZSA/IG5hbWUgKyBJVEVNX1NQTElURVIgOiAnJykgKyB2YWxzLmpvaW4oSVRFTV9TUExJVEVSKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICB9KS5qb2luKCdcXG5cXG4nICsgQkxPQ0tfU1BMSVRFUiArICdcXG5cXG4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGVudEZyb21Nb2RlbChlY01vZGVsKSB7XG4gIHZhciByZXN1bHQgPSBncm91cFNlcmllcyhlY01vZGVsKTtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogenJVdGlsLmZpbHRlcihbYXNzZW1ibGVTZXJpZXNXaXRoQ2F0ZWdvcnlBeGlzKHJlc3VsdC5zZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzKSwgYXNzZW1ibGVPdGhlclNlcmllcyhyZXN1bHQub3RoZXIpXSwgZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuICEhc3RyLnJlcGxhY2UoL1tcXG5cXHRcXHNdL2csICcnKTtcbiAgICB9KS5qb2luKCdcXG5cXG4nICsgQkxPQ0tfU1BMSVRFUiArICdcXG5cXG4nKSxcbiAgICBtZXRhOiByZXN1bHQubWV0YVxuICB9O1xufVxuXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xufVxuLyoqXG4gKiBJZiBhIGJsb2NrIGlzIHRzdiBmb3JtYXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVFNWRm9ybWF0KGJsb2NrKSB7XG4gIC8vIFNpbXBsZSBtZXRob2QgdG8gZmluZCBvdXQgaWYgYSBibG9jayBpcyB0c3YgZm9ybWF0XG4gIHZhciBmaXJzdExpbmUgPSBibG9jay5zbGljZSgwLCBibG9jay5pbmRleE9mKCdcXG4nKSk7XG5cbiAgaWYgKGZpcnN0TGluZS5pbmRleE9mKElURU1fU1BMSVRFUikgPj0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnZhciBpdGVtU3BsaXRSZWdleCA9IG5ldyBSZWdFeHAoJ1snICsgSVRFTV9TUExJVEVSICsgJ10rJywgJ2cnKTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRzdlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlVFNWQ29udGVudHModHN2KSB7XG4gIHZhciB0c3ZMaW5lcyA9IHRzdi5zcGxpdCgvXFxuKy9nKTtcbiAgdmFyIGhlYWRlcnMgPSB0cmltKHRzdkxpbmVzLnNoaWZ0KCkpLnNwbGl0KGl0ZW1TcGxpdFJlZ2V4KTtcbiAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgdmFyIHNlcmllcyA9IHpyVXRpbC5tYXAoaGVhZGVycywgZnVuY3Rpb24gKGhlYWRlcikge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBoZWFkZXIsXG4gICAgICBkYXRhOiBbXVxuICAgIH07XG4gIH0pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHN2TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbXMgPSB0cmltKHRzdkxpbmVzW2ldKS5zcGxpdChpdGVtU3BsaXRSZWdleCk7XG4gICAgY2F0ZWdvcmllcy5wdXNoKGl0ZW1zLnNoaWZ0KCkpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtcy5sZW5ndGg7IGorKykge1xuICAgICAgc2VyaWVzW2pdICYmIChzZXJpZXNbal0uZGF0YVtpXSA9IGl0ZW1zW2pdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNlcmllczogc2VyaWVzLFxuICAgIGNhdGVnb3JpZXM6IGNhdGVnb3JpZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VMaXN0Q29udGVudHMoc3RyKSB7XG4gIHZhciBsaW5lcyA9IHN0ci5zcGxpdCgvXFxuKy9nKTtcbiAgdmFyIHNlcmllc05hbWUgPSB0cmltKGxpbmVzLnNoaWZ0KCkpO1xuICB2YXIgZGF0YSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBpZiBsaW5lIGlzIGVtcHR5LCBpZ25vcmUgaXQuXG4gICAgLy8gdGhlcmUgaXMgYSBjYXNlIHRoYXQgYSB1c2VyIGZvcmdvdCB0byBkZWxldGUgYFxcbmAuXG4gICAgdmFyIGxpbmUgPSB0cmltKGxpbmVzW2ldKTtcblxuICAgIGlmICghbGluZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGl0ZW1zID0gbGluZS5zcGxpdChpdGVtU3BsaXRSZWdleCk7XG4gICAgdmFyIG5hbWVfMSA9ICcnO1xuICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICB2YXIgaGFzTmFtZSA9IGZhbHNlO1xuXG4gICAgaWYgKGlzTmFOKGl0ZW1zWzBdKSkge1xuICAgICAgLy8gRmlyc3QgaXRlbSBpcyBuYW1lXG4gICAgICBoYXNOYW1lID0gdHJ1ZTtcbiAgICAgIG5hbWVfMSA9IGl0ZW1zWzBdO1xuICAgICAgaXRlbXMgPSBpdGVtcy5zbGljZSgxKTtcbiAgICAgIGRhdGFbaV0gPSB7XG4gICAgICAgIG5hbWU6IG5hbWVfMSxcbiAgICAgICAgdmFsdWU6IFtdXG4gICAgICB9O1xuICAgICAgdmFsdWUgPSBkYXRhW2ldLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGRhdGFbaV0gPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YWx1ZS5wdXNoKCtpdGVtc1tqXSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaGFzTmFtZSA/IGRhdGFbaV0udmFsdWUgPSB2YWx1ZVswXSA6IGRhdGFbaV0gPSB2YWx1ZVswXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IHNlcmllc05hbWUsXG4gICAgZGF0YTogZGF0YVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUNvbnRlbnRzKHN0ciwgYmxvY2tNZXRhTGlzdCkge1xuICB2YXIgYmxvY2tzID0gc3RyLnNwbGl0KG5ldyBSZWdFeHAoJ1xcbionICsgQkxPQ0tfU1BMSVRFUiArICdcXG4qJywgJ2cnKSk7XG4gIHZhciBuZXdPcHRpb24gPSB7XG4gICAgc2VyaWVzOiBbXVxuICB9O1xuICB6clV0aWwuZWFjaChibG9ja3MsIGZ1bmN0aW9uIChibG9jaywgaWR4KSB7XG4gICAgaWYgKGlzVFNWRm9ybWF0KGJsb2NrKSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlVFNWQ29udGVudHMoYmxvY2spO1xuICAgICAgdmFyIGJsb2NrTWV0YSA9IGJsb2NrTWV0YUxpc3RbaWR4XTtcbiAgICAgIHZhciBheGlzS2V5ID0gYmxvY2tNZXRhLmF4aXNEaW0gKyAnQXhpcyc7XG5cbiAgICAgIGlmIChibG9ja01ldGEpIHtcbiAgICAgICAgbmV3T3B0aW9uW2F4aXNLZXldID0gbmV3T3B0aW9uW2F4aXNLZXldIHx8IFtdO1xuICAgICAgICBuZXdPcHRpb25bYXhpc0tleV1bYmxvY2tNZXRhLmF4aXNJbmRleF0gPSB7XG4gICAgICAgICAgZGF0YTogcmVzdWx0LmNhdGVnb3JpZXNcbiAgICAgICAgfTtcbiAgICAgICAgbmV3T3B0aW9uLnNlcmllcyA9IG5ld09wdGlvbi5zZXJpZXMuY29uY2F0KHJlc3VsdC5zZXJpZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0ID0gcGFyc2VMaXN0Q29udGVudHMoYmxvY2spO1xuICAgICAgbmV3T3B0aW9uLnNlcmllcy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ld09wdGlvbjtcbn1cblxudmFyIERhdGFWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKERhdGFWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIERhdGFWaWV3KCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIERhdGFWaWV3LnByb3RvdHlwZS5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBjb250YWluZXIgPSBhcGkuZ2V0RG9tKCk7XG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcblxuICAgIGlmICh0aGlzLl9kb20pIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9kb20pO1xuICAgIH1cblxuICAgIHZhciByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcm9vdC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6NXB4O3RvcDo1cHg7Ym90dG9tOjVweDtyaWdodDo1cHg7JztcbiAgICByb290LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJykgfHwgJyNmZmYnOyAvLyBDcmVhdGUgZWxlbWVudHNcblxuICAgIHZhciBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoNCcpO1xuICAgIHZhciBsYW5nID0gbW9kZWwuZ2V0KCdsYW5nJykgfHwgW107XG4gICAgaGVhZGVyLmlubmVySFRNTCA9IGxhbmdbMF0gfHwgbW9kZWwuZ2V0KCd0aXRsZScpO1xuICAgIGhlYWRlci5zdHlsZS5jc3NUZXh0ID0gJ21hcmdpbjogMTBweCAyMHB4Oyc7XG4gICAgaGVhZGVyLnN0eWxlLmNvbG9yID0gbW9kZWwuZ2V0KCd0ZXh0Q29sb3InKTtcbiAgICB2YXIgdmlld01haW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgdGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHZpZXdNYWluLnN0eWxlLmNzc1RleHQgPSAnZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO292ZXJmbG93OmF1dG87JztcbiAgICB2YXIgb3B0aW9uVG9Db250ZW50ID0gbW9kZWwuZ2V0KCdvcHRpb25Ub0NvbnRlbnQnKTtcbiAgICB2YXIgY29udGVudFRvT3B0aW9uID0gbW9kZWwuZ2V0KCdjb250ZW50VG9PcHRpb24nKTtcbiAgICB2YXIgcmVzdWx0ID0gZ2V0Q29udGVudEZyb21Nb2RlbChlY01vZGVsKTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVG9Db250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgaHRtbE9yRG9tID0gb3B0aW9uVG9Db250ZW50KGFwaS5nZXRPcHRpb24oKSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaHRtbE9yRG9tID09PSAnc3RyaW5nJykge1xuICAgICAgICB2aWV3TWFpbi5pbm5lckhUTUwgPSBodG1sT3JEb207XG4gICAgICB9IGVsc2UgaWYgKHpyVXRpbC5pc0RvbShodG1sT3JEb20pKSB7XG4gICAgICAgIHZpZXdNYWluLmFwcGVuZENoaWxkKGh0bWxPckRvbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVzZSBkZWZhdWx0IHRleHRhcmVhXG4gICAgICB2aWV3TWFpbi5hcHBlbmRDaGlsZCh0ZXh0YXJlYSk7XG4gICAgICB0ZXh0YXJlYS5yZWFkT25seSA9IG1vZGVsLmdldCgncmVhZE9ubHknKTtcbiAgICAgIHRleHRhcmVhLnN0eWxlLmNzc1RleHQgPSAnd2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtmb250LWZhbWlseTptb25vc3BhY2U7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS42cmVtOyc7XG4gICAgICB0ZXh0YXJlYS5zdHlsZS5jb2xvciA9IG1vZGVsLmdldCgndGV4dENvbG9yJyk7XG4gICAgICB0ZXh0YXJlYS5zdHlsZS5ib3JkZXJDb2xvciA9IG1vZGVsLmdldCgndGV4dGFyZWFCb3JkZXJDb2xvcicpO1xuICAgICAgdGV4dGFyZWEuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gbW9kZWwuZ2V0KCd0ZXh0YXJlYUNvbG9yJyk7XG4gICAgICB0ZXh0YXJlYS52YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgYmxvY2tNZXRhTGlzdCA9IHJlc3VsdC5tZXRhO1xuICAgIHZhciBidXR0b25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBidXR0b25Db250YWluZXIuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDtsZWZ0OjA7cmlnaHQ6MDsnO1xuICAgIHZhciBidXR0b25TdHlsZSA9ICdmbG9hdDpyaWdodDttYXJnaW4tcmlnaHQ6MjBweDtib3JkZXI6bm9uZTsnICsgJ2N1cnNvcjpwb2ludGVyO3BhZGRpbmc6MnB4IDVweDtmb250LXNpemU6MTJweDtib3JkZXItcmFkaXVzOjNweCc7XG4gICAgdmFyIGNsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIHJlZnJlc2hCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBidXR0b25TdHlsZSArPSAnO2JhY2tncm91bmQtY29sb3I6JyArIG1vZGVsLmdldCgnYnV0dG9uQ29sb3InKTtcbiAgICBidXR0b25TdHlsZSArPSAnO2NvbG9yOicgKyBtb2RlbC5nZXQoJ2J1dHRvblRleHRDb2xvcicpO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHJvb3QpO1xuICAgICAgc2VsZi5fZG9tID0gbnVsbDtcbiAgICB9XG5cbiAgICBhZGRFdmVudExpc3RlbmVyKGNsb3NlQnV0dG9uLCAnY2xpY2snLCBjbG9zZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihyZWZyZXNoQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY29udGVudFRvT3B0aW9uID09IG51bGwgJiYgb3B0aW9uVG9Db250ZW50ICE9IG51bGwgfHwgY29udGVudFRvT3B0aW9uICE9IG51bGwgJiYgb3B0aW9uVG9Db250ZW50ID09IG51bGwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0l0IHNlZW1zIHlvdSBoYXZlIGp1c3QgcHJvdmlkZWQgb25lIG9mIGBjb250ZW50VG9PcHRpb25gIGFuZCBgb3B0aW9uVG9Db250ZW50YCBmdW5jdGlvbnMgYnV0IG1pc3NlZCB0aGUgb3RoZXIgb25lLiBEYXRhIGNoYW5nZSBpcyBpZ25vcmVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3T3B0aW9uO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRUb09wdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG5ld09wdGlvbiA9IGNvbnRlbnRUb09wdGlvbih2aWV3TWFpbiwgYXBpLmdldE9wdGlvbigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdPcHRpb24gPSBwYXJzZUNvbnRlbnRzKHRleHRhcmVhLnZhbHVlLCBibG9ja01ldGFMaXN0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgdmlldyBmb3JtYXQgZXJyb3IgJyArIGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3T3B0aW9uKSB7XG4gICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgdHlwZTogJ2NoYW5nZURhdGFWaWV3JyxcbiAgICAgICAgICBuZXdPcHRpb246IG5ld09wdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2xvc2UoKTtcbiAgICB9KTtcbiAgICBjbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSBsYW5nWzFdO1xuICAgIHJlZnJlc2hCdXR0b24uaW5uZXJIVE1MID0gbGFuZ1syXTtcbiAgICByZWZyZXNoQnV0dG9uLnN0eWxlLmNzc1RleHQgPSBidXR0b25TdHlsZTtcbiAgICBjbG9zZUJ1dHRvbi5zdHlsZS5jc3NUZXh0ID0gYnV0dG9uU3R5bGU7XG4gICAgIW1vZGVsLmdldCgncmVhZE9ubHknKSAmJiBidXR0b25Db250YWluZXIuYXBwZW5kQ2hpbGQocmVmcmVzaEJ1dHRvbik7XG4gICAgYnV0dG9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGNsb3NlQnV0dG9uKTtcbiAgICByb290LmFwcGVuZENoaWxkKGhlYWRlcik7XG4gICAgcm9vdC5hcHBlbmRDaGlsZCh2aWV3TWFpbik7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChidXR0b25Db250YWluZXIpO1xuICAgIHZpZXdNYWluLnN0eWxlLmhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgLSA4MCArICdweCc7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHJvb3QpO1xuICAgIHRoaXMuX2RvbSA9IHJvb3Q7XG4gIH07XG5cbiAgRGF0YVZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLl9kb20gJiYgYXBpLmdldERvbSgpLnJlbW92ZUNoaWxkKHRoaXMuX2RvbSk7XG4gIH07XG5cbiAgRGF0YVZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5yZW1vdmUoZWNNb2RlbCwgYXBpKTtcbiAgfTtcblxuICBEYXRhVmlldy5nZXREZWZhdWx0T3B0aW9uID0gZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICB2YXIgZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICByZWFkT25seTogZmFsc2UsXG4gICAgICBvcHRpb25Ub0NvbnRlbnQ6IG51bGwsXG4gICAgICBjb250ZW50VG9PcHRpb246IG51bGwsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGljb246ICdNMTcuNSwxNy4zSDMzIE0xNy41LDE3LjNIMzMgTTQ1LjQsMjkuNWgtMjggTTExLjUsMnY1Nkg1MVYxNC44TDM4LjQsMkgxMS41eiBNMzguNCwyLjJ2MTIuN0g1MSBNNDUuNCw0MS43aC0yOCcsXG4gICAgICB0aXRsZTogZWNNb2RlbC5nZXRMb2NhbGUoWyd0b29sYm94JywgJ2RhdGFWaWV3JywgJ3RpdGxlJ10pLFxuICAgICAgbGFuZzogZWNNb2RlbC5nZXRMb2NhbGUoWyd0b29sYm94JywgJ2RhdGFWaWV3JywgJ2xhbmcnXSksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZmJyxcbiAgICAgIHRleHRDb2xvcjogJyMwMDAnLFxuICAgICAgdGV4dGFyZWFDb2xvcjogJyNmZmYnLFxuICAgICAgdGV4dGFyZWFCb3JkZXJDb2xvcjogJyMzMzMnLFxuICAgICAgYnV0dG9uQ29sb3I6ICcjYzIzNTMxJyxcbiAgICAgIGJ1dHRvblRleHRDb2xvcjogJyNmZmYnXG4gICAgfTtcbiAgICByZXR1cm4gZGVmYXVsdE9wdGlvbjtcbiAgfTtcblxuICByZXR1cm4gRGF0YVZpZXc7XG59KFRvb2xib3hGZWF0dXJlKTtcbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiB0cnlNZXJnZURhdGFPcHRpb24obmV3RGF0YSwgb3JpZ2luYWxEYXRhKSB7XG4gIHJldHVybiB6clV0aWwubWFwKG5ld0RhdGEsIGZ1bmN0aW9uIChuZXdWYWwsIGlkeCkge1xuICAgIHZhciBvcmlnaW5hbCA9IG9yaWdpbmFsRGF0YSAmJiBvcmlnaW5hbERhdGFbaWR4XTtcblxuICAgIGlmICh6clV0aWwuaXNPYmplY3Qob3JpZ2luYWwpICYmICF6clV0aWwuaXNBcnJheShvcmlnaW5hbCkpIHtcbiAgICAgIHZhciBuZXdWYWxJc09iamVjdCA9IHpyVXRpbC5pc09iamVjdChuZXdWYWwpICYmICF6clV0aWwuaXNBcnJheShuZXdWYWwpO1xuXG4gICAgICBpZiAoIW5ld1ZhbElzT2JqZWN0KSB7XG4gICAgICAgIG5ld1ZhbCA9IHtcbiAgICAgICAgICB2YWx1ZTogbmV3VmFsXG4gICAgICAgIH07XG4gICAgICB9IC8vIG9yaWdpbmFsIGRhdGEgaGFzIG5hbWUgYnV0IG5ldyBkYXRhIGhhcyBubyBuYW1lXG5cblxuICAgICAgdmFyIHNob3VsZERlbGV0ZU5hbWUgPSBvcmlnaW5hbC5uYW1lICE9IG51bGwgJiYgbmV3VmFsLm5hbWUgPT0gbnVsbDsgLy8gT3JpZ2luYWwgZGF0YSBoYXMgb3B0aW9uXG5cbiAgICAgIG5ld1ZhbCA9IHpyVXRpbC5kZWZhdWx0cyhuZXdWYWwsIG9yaWdpbmFsKTtcbiAgICAgIHNob3VsZERlbGV0ZU5hbWUgJiYgZGVsZXRlIG5ld1ZhbC5uYW1lO1xuICAgICAgcmV0dXJuIG5ld1ZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ld1ZhbDtcbiAgICB9XG4gIH0pO1xufSAvLyBUT0RPOiBTRUxGIFJFR0lTVEVSRUQuXG5cblxuZWNoYXJ0cy5yZWdpc3RlckFjdGlvbih7XG4gIHR5cGU6ICdjaGFuZ2VEYXRhVmlldycsXG4gIGV2ZW50OiAnZGF0YVZpZXdDaGFuZ2VkJyxcbiAgdXBkYXRlOiAncHJlcGFyZUFuZFVwZGF0ZSdcbn0sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gIHZhciBuZXdTZXJpZXNPcHRMaXN0ID0gW107XG4gIHpyVXRpbC5lYWNoKHBheWxvYWQubmV3T3B0aW9uLnNlcmllcywgZnVuY3Rpb24gKHNlcmllc09wdCkge1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlOYW1lKHNlcmllc09wdC5uYW1lKVswXTtcblxuICAgIGlmICghc2VyaWVzTW9kZWwpIHtcbiAgICAgIC8vIE5ldyBjcmVhdGVkIHNlcmllc1xuICAgICAgLy8gR2V1c3MgdGhlIHNlcmllcyB0eXBlXG4gICAgICBuZXdTZXJpZXNPcHRMaXN0LnB1c2goenJVdGlsLmV4dGVuZCh7XG4gICAgICAgIC8vIERlZmF1bHQgaXMgc2NhdHRlclxuICAgICAgICB0eXBlOiAnc2NhdHRlcidcbiAgICAgIH0sIHNlcmllc09wdCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3JpZ2luYWxEYXRhID0gc2VyaWVzTW9kZWwuZ2V0KCdkYXRhJyk7XG4gICAgICBuZXdTZXJpZXNPcHRMaXN0LnB1c2goe1xuICAgICAgICBuYW1lOiBzZXJpZXNPcHQubmFtZSxcbiAgICAgICAgZGF0YTogdHJ5TWVyZ2VEYXRhT3B0aW9uKHNlcmllc09wdC5kYXRhLCBvcmlnaW5hbERhdGEpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBlY01vZGVsLm1lcmdlT3B0aW9uKHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgc2VyaWVzOiBuZXdTZXJpZXNPcHRMaXN0XG4gIH0sIHBheWxvYWQubmV3T3B0aW9uKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IERhdGFWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjsgLy8gVE9ETyBkZXBlbmRzIG9uIERhdGFab29tIGFuZCBCcnVzaFxuXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBCcnVzaENvbnRyb2xsZXIgZnJvbSAnLi4vLi4vaGVscGVyL0JydXNoQ29udHJvbGxlcic7XG5pbXBvcnQgQnJ1c2hUYXJnZXRNYW5hZ2VyIGZyb20gJy4uLy4uL2hlbHBlci9CcnVzaFRhcmdldE1hbmFnZXInO1xuaW1wb3J0ICogYXMgaGlzdG9yeSBmcm9tICcuLi8uLi9kYXRhWm9vbS9oaXN0b3J5JztcbmltcG9ydCBzbGlkZXJNb3ZlIGZyb20gJy4uLy4uL2hlbHBlci9zbGlkZXJNb3ZlJztcbmltcG9ydCB7IFRvb2xib3hGZWF0dXJlIH0gZnJvbSAnLi4vZmVhdHVyZU1hbmFnZXInO1xuaW1wb3J0IHsgbWFrZUludGVybmFsQ29tcG9uZW50SWQsIHBhcnNlRmluZGVyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbC9tb2RlbCc7XG5pbXBvcnQgeyByZWdpc3RlckludGVybmFsT3B0aW9uQ3JlYXRvciB9IGZyb20gJy4uLy4uLy4uL21vZGVsL2ludGVybmFsQ29tcG9uZW50Q3JlYXRvcic7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIERBVEFfWk9PTV9JRF9CQVNFID0gbWFrZUludGVybmFsQ29tcG9uZW50SWQoJ3Rvb2xib3gtZGF0YVpvb21fJyk7XG52YXIgSUNPTl9UWVBFUyA9IFsnem9vbScsICdiYWNrJ107XG5cbnZhciBEYXRhWm9vbUZlYXR1cmUgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRGF0YVpvb21GZWF0dXJlLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIERhdGFab29tRmVhdHVyZSgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICBEYXRhWm9vbUZlYXR1cmUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChmZWF0dXJlTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIGlmICghdGhpcy5fYnJ1c2hDb250cm9sbGVyKSB7XG4gICAgICB0aGlzLl9icnVzaENvbnRyb2xsZXIgPSBuZXcgQnJ1c2hDb250cm9sbGVyKGFwaS5nZXRacigpKTtcblxuICAgICAgdGhpcy5fYnJ1c2hDb250cm9sbGVyLm9uKCdicnVzaCcsIHpyVXRpbC5iaW5kKHRoaXMuX29uQnJ1c2gsIHRoaXMpKS5tb3VudCgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVpvb21CdG5TdGF0dXMoZmVhdHVyZU1vZGVsLCBlY01vZGVsLCB0aGlzLCBwYXlsb2FkLCBhcGkpO1xuICAgIHVwZGF0ZUJhY2tCdG5TdGF0dXMoZmVhdHVyZU1vZGVsLCBlY01vZGVsKTtcbiAgfTtcblxuICBEYXRhWm9vbUZlYXR1cmUucHJvdG90eXBlLm9uY2xpY2sgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpLCB0eXBlKSB7XG4gICAgaGFuZGxlcnNbdHlwZV0uY2FsbCh0aGlzKTtcbiAgfTtcblxuICBEYXRhWm9vbUZlYXR1cmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLl9icnVzaENvbnRyb2xsZXIgJiYgdGhpcy5fYnJ1c2hDb250cm9sbGVyLnVubW91bnQoKTtcbiAgfTtcblxuICBEYXRhWm9vbUZlYXR1cmUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5fYnJ1c2hDb250cm9sbGVyICYmIHRoaXMuX2JydXNoQ29udHJvbGxlci5kaXNwb3NlKCk7XG4gIH07XG5cbiAgRGF0YVpvb21GZWF0dXJlLnByb3RvdHlwZS5fb25CcnVzaCA9IGZ1bmN0aW9uIChldmVudFBhcmFtKSB7XG4gICAgdmFyIGFyZWFzID0gZXZlbnRQYXJhbS5hcmVhcztcblxuICAgIGlmICghZXZlbnRQYXJhbS5pc0VuZCB8fCAhYXJlYXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNuYXBzaG90ID0ge307XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG5cbiAgICB0aGlzLl9icnVzaENvbnRyb2xsZXIudXBkYXRlQ292ZXJzKFtdKTsgLy8gcmVtb3ZlIGNvdmVyXG5cblxuICAgIHZhciBicnVzaFRhcmdldE1hbmFnZXIgPSBuZXcgQnJ1c2hUYXJnZXRNYW5hZ2VyKG1ha2VBeGlzRmluZGVyKHRoaXMubW9kZWwpLCBlY01vZGVsLCB7XG4gICAgICBpbmNsdWRlOiBbJ2dyaWQnXVxuICAgIH0pO1xuICAgIGJydXNoVGFyZ2V0TWFuYWdlci5tYXRjaE91dHB1dFJhbmdlcyhhcmVhcywgZWNNb2RlbCwgZnVuY3Rpb24gKGFyZWEsIGNvb3JkUmFuZ2UsIGNvb3JkU3lzKSB7XG4gICAgICBpZiAoY29vcmRTeXMudHlwZSAhPT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBicnVzaFR5cGUgPSBhcmVhLmJydXNoVHlwZTtcblxuICAgICAgaWYgKGJydXNoVHlwZSA9PT0gJ3JlY3QnKSB7XG4gICAgICAgIHNldEJhdGNoKCd4JywgY29vcmRTeXMsIGNvb3JkUmFuZ2VbMF0pO1xuICAgICAgICBzZXRCYXRjaCgneScsIGNvb3JkU3lzLCBjb29yZFJhbmdlWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJhdGNoKHtcbiAgICAgICAgICBsaW5lWDogJ3gnLFxuICAgICAgICAgIGxpbmVZOiAneSdcbiAgICAgICAgfVticnVzaFR5cGVdLCBjb29yZFN5cywgY29vcmRSYW5nZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaGlzdG9yeS5wdXNoKGVjTW9kZWwsIHNuYXBzaG90KTtcblxuICAgIHRoaXMuX2Rpc3BhdGNoWm9vbUFjdGlvbihzbmFwc2hvdCk7XG5cbiAgICBmdW5jdGlvbiBzZXRCYXRjaChkaW1OYW1lLCBjb29yZFN5cywgbWluTWF4KSB7XG4gICAgICB2YXIgYXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoZGltTmFtZSk7XG4gICAgICB2YXIgYXhpc01vZGVsID0gYXhpcy5tb2RlbDtcbiAgICAgIHZhciBkYXRhWm9vbU1vZGVsID0gZmluZERhdGFab29tKGRpbU5hbWUsIGF4aXNNb2RlbCwgZWNNb2RlbCk7IC8vIFJlc3RyaWN0IHJhbmdlLlxuXG4gICAgICB2YXIgbWluTWF4U3BhbiA9IGRhdGFab29tTW9kZWwuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KGF4aXNNb2RlbCkuZ2V0TWluTWF4U3BhbigpO1xuXG4gICAgICBpZiAobWluTWF4U3Bhbi5taW5WYWx1ZVNwYW4gIT0gbnVsbCB8fCBtaW5NYXhTcGFuLm1heFZhbHVlU3BhbiAhPSBudWxsKSB7XG4gICAgICAgIG1pbk1heCA9IHNsaWRlck1vdmUoMCwgbWluTWF4LnNsaWNlKCksIGF4aXMuc2NhbGUuZ2V0RXh0ZW50KCksIDAsIG1pbk1heFNwYW4ubWluVmFsdWVTcGFuLCBtaW5NYXhTcGFuLm1heFZhbHVlU3Bhbik7XG4gICAgICB9XG5cbiAgICAgIGRhdGFab29tTW9kZWwgJiYgKHNuYXBzaG90W2RhdGFab29tTW9kZWwuaWRdID0ge1xuICAgICAgICBkYXRhWm9vbUlkOiBkYXRhWm9vbU1vZGVsLmlkLFxuICAgICAgICBzdGFydFZhbHVlOiBtaW5NYXhbMF0sXG4gICAgICAgIGVuZFZhbHVlOiBtaW5NYXhbMV1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmREYXRhWm9vbShkaW1OYW1lLCBheGlzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgIHZhciBmb3VuZDtcbiAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgICAgIG1haW5UeXBlOiAnZGF0YVpvb20nLFxuICAgICAgICBzdWJUeXBlOiAnc2VsZWN0J1xuICAgICAgfSwgZnVuY3Rpb24gKGR6TW9kZWwpIHtcbiAgICAgICAgdmFyIGhhcyA9IGR6TW9kZWwuZ2V0QXhpc01vZGVsKGRpbU5hbWUsIGF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gICAgICAgIGhhcyAmJiAoZm91bmQgPSBkek1vZGVsKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgfTtcblxuICA7XG5cbiAgRGF0YVpvb21GZWF0dXJlLnByb3RvdHlwZS5fZGlzcGF0Y2hab29tQWN0aW9uID0gZnVuY3Rpb24gKHNuYXBzaG90KSB7XG4gICAgdmFyIGJhdGNoID0gW107IC8vIENvbnZlcnQgZnJvbSBoYXNoIG1hcCB0byBhcnJheS5cblxuICAgIGVhY2goc25hcHNob3QsIGZ1bmN0aW9uIChiYXRjaEl0ZW0sIGRhdGFab29tSWQpIHtcbiAgICAgIGJhdGNoLnB1c2goenJVdGlsLmNsb25lKGJhdGNoSXRlbSkpO1xuICAgIH0pO1xuICAgIGJhdGNoLmxlbmd0aCAmJiB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnZGF0YVpvb20nLFxuICAgICAgZnJvbTogdGhpcy51aWQsXG4gICAgICBiYXRjaDogYmF0Y2hcbiAgICB9KTtcbiAgfTtcblxuICBEYXRhWm9vbUZlYXR1cmUuZ2V0RGVmYXVsdE9wdGlvbiA9IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdmFyIGRlZmF1bHRPcHRpb24gPSB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgZmlsdGVyTW9kZTogJ2ZpbHRlcicsXG4gICAgICAvLyBJY29uIGdyb3VwXG4gICAgICBpY29uOiB7XG4gICAgICAgIHpvb206ICdNMCwxMy41aDI2LjkgTTEzLjUsMjYuOVYwIE0zMi4xLDEzLjVINThWNThIMTMuNSBWMzIuMScsXG4gICAgICAgIGJhY2s6ICdNMjIsMS40TDkuOSwxMy41bDEyLjMsMTIuMyBNMTAuMywxMy41SDU0Ljl2NDQuNiBIMTAuM3YtMjYnXG4gICAgICB9LFxuICAgICAgLy8gYHpvb21gLCBgYmFja2BcbiAgICAgIHRpdGxlOiBlY01vZGVsLmdldExvY2FsZShbJ3Rvb2xib3gnLCAnZGF0YVpvb20nLCAndGl0bGUnXSksXG4gICAgICBicnVzaFN0eWxlOiB7XG4gICAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgICBjb2xvcjogJ3JnYmEoMjEwLDIxOSwyMzgsMC4yKSdcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBkZWZhdWx0T3B0aW9uO1xuICB9O1xuXG4gIHJldHVybiBEYXRhWm9vbUZlYXR1cmU7XG59KFRvb2xib3hGZWF0dXJlKTtcblxudmFyIGhhbmRsZXJzID0ge1xuICB6b29tOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5leHRBY3RpdmUgPSAhdGhpcy5faXNab29tQWN0aXZlO1xuICAgIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICd0YWtlR2xvYmFsQ3Vyc29yJyxcbiAgICAgIGtleTogJ2RhdGFab29tU2VsZWN0JyxcbiAgICAgIGRhdGFab29tU2VsZWN0QWN0aXZlOiBuZXh0QWN0aXZlXG4gICAgfSk7XG4gIH0sXG4gIGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oaGlzdG9yeS5wb3AodGhpcy5lY01vZGVsKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG1ha2VBeGlzRmluZGVyKGR6RmVhdHVyZU1vZGVsKSB7XG4gIHZhciBzZXR0aW5nID0ge1xuICAgIHhBeGlzSW5kZXg6IGR6RmVhdHVyZU1vZGVsLmdldCgneEF4aXNJbmRleCcsIHRydWUpLFxuICAgIHlBeGlzSW5kZXg6IGR6RmVhdHVyZU1vZGVsLmdldCgneUF4aXNJbmRleCcsIHRydWUpLFxuICAgIHhBeGlzSWQ6IGR6RmVhdHVyZU1vZGVsLmdldCgneEF4aXNJZCcsIHRydWUpLFxuICAgIHlBeGlzSWQ6IGR6RmVhdHVyZU1vZGVsLmdldCgneUF4aXNJZCcsIHRydWUpXG4gIH07IC8vIElmIGJvdGggYHhBeGlzSW5kZXhgIGB4QXhpc0lkYCBub3Qgc2V0LCBpdCBtZWFucyAnYWxsJy5cbiAgLy8gSWYgYm90aCBgeUF4aXNJbmRleGAgYHlBeGlzSWRgIG5vdCBzZXQsIGl0IG1lYW5zICdhbGwnLlxuICAvLyBTb21lIG9sZCBjYXNlcyBzZXQgbGlrZSB0aGlzIGJlbG93IHRvIGNsb3NlIHlBeGlzIGNvbnRyb2wgYnV0IGxlYXZlIHhBeGlzIGNvbnRyb2w6XG4gIC8vIGB7IGZlYXR1cmU6IHsgZGF0YVpvb206IHsgeUF4aXNJbmRleDogZmFsc2UgfSB9YC5cblxuICBpZiAoc2V0dGluZy54QXhpc0luZGV4ID09IG51bGwgJiYgc2V0dGluZy54QXhpc0lkID09IG51bGwpIHtcbiAgICBzZXR0aW5nLnhBeGlzSW5kZXggPSAnYWxsJztcbiAgfVxuXG4gIGlmIChzZXR0aW5nLnlBeGlzSW5kZXggPT0gbnVsbCAmJiBzZXR0aW5nLnlBeGlzSWQgPT0gbnVsbCkge1xuICAgIHNldHRpbmcueUF4aXNJbmRleCA9ICdhbGwnO1xuICB9XG5cbiAgcmV0dXJuIHNldHRpbmc7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUJhY2tCdG5TdGF0dXMoZmVhdHVyZU1vZGVsLCBlY01vZGVsKSB7XG4gIGZlYXR1cmVNb2RlbC5zZXRJY29uU3RhdHVzKCdiYWNrJywgaGlzdG9yeS5jb3VudChlY01vZGVsKSA+IDEgPyAnZW1waGFzaXMnIDogJ25vcm1hbCcpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVab29tQnRuU3RhdHVzKGZlYXR1cmVNb2RlbCwgZWNNb2RlbCwgdmlldywgcGF5bG9hZCwgYXBpKSB7XG4gIHZhciB6b29tQWN0aXZlID0gdmlldy5faXNab29tQWN0aXZlO1xuXG4gIGlmIChwYXlsb2FkICYmIHBheWxvYWQudHlwZSA9PT0gJ3Rha2VHbG9iYWxDdXJzb3InKSB7XG4gICAgem9vbUFjdGl2ZSA9IHBheWxvYWQua2V5ID09PSAnZGF0YVpvb21TZWxlY3QnID8gcGF5bG9hZC5kYXRhWm9vbVNlbGVjdEFjdGl2ZSA6IGZhbHNlO1xuICB9XG5cbiAgdmlldy5faXNab29tQWN0aXZlID0gem9vbUFjdGl2ZTtcbiAgZmVhdHVyZU1vZGVsLnNldEljb25TdGF0dXMoJ3pvb20nLCB6b29tQWN0aXZlID8gJ2VtcGhhc2lzJyA6ICdub3JtYWwnKTtcbiAgdmFyIGJydXNoVGFyZ2V0TWFuYWdlciA9IG5ldyBCcnVzaFRhcmdldE1hbmFnZXIobWFrZUF4aXNGaW5kZXIoZmVhdHVyZU1vZGVsKSwgZWNNb2RlbCwge1xuICAgIGluY2x1ZGU6IFsnZ3JpZCddXG4gIH0pO1xuICB2YXIgcGFuZWxzID0gYnJ1c2hUYXJnZXRNYW5hZ2VyLm1ha2VQYW5lbE9wdHMoYXBpLCBmdW5jdGlvbiAodGFyZ2V0SW5mbykge1xuICAgIHJldHVybiB0YXJnZXRJbmZvLnhBeGlzRGVjbGFyZWQgJiYgIXRhcmdldEluZm8ueUF4aXNEZWNsYXJlZCA/ICdsaW5lWCcgOiAhdGFyZ2V0SW5mby54QXhpc0RlY2xhcmVkICYmIHRhcmdldEluZm8ueUF4aXNEZWNsYXJlZCA/ICdsaW5lWScgOiAncmVjdCc7XG4gIH0pO1xuXG4gIHZpZXcuX2JydXNoQ29udHJvbGxlci5zZXRQYW5lbHMocGFuZWxzKS5lbmFibGVCcnVzaCh6b29tQWN0aXZlICYmIHBhbmVscy5sZW5ndGggPyB7XG4gICAgYnJ1c2hUeXBlOiAnYXV0bycsXG4gICAgYnJ1c2hTdHlsZTogZmVhdHVyZU1vZGVsLmdldE1vZGVsKCdicnVzaFN0eWxlJykuZ2V0SXRlbVN0eWxlKClcbiAgfSA6IGZhbHNlKTtcbn1cblxucmVnaXN0ZXJJbnRlcm5hbE9wdGlvbkNyZWF0b3IoJ2RhdGFab29tJywgZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgdmFyIHRvb2xib3hNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCd0b29sYm94JywgMCk7XG5cbiAgaWYgKCF0b29sYm94TW9kZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZHpGZWF0dXJlTW9kZWwgPSB0b29sYm94TW9kZWwuZ2V0TW9kZWwoWydmZWF0dXJlJywgJ2RhdGFab29tJ10pO1xuICB2YXIgZHpPcHRpb25zID0gW107XG4gIHZhciBmaW5kZXIgPSBtYWtlQXhpc0ZpbmRlcihkekZlYXR1cmVNb2RlbCk7XG4gIHZhciBmaW5kZXJSZXN1bHQgPSBwYXJzZUZpbmRlcihlY01vZGVsLCBmaW5kZXIpO1xuICBlYWNoKGZpbmRlclJlc3VsdC54QXhpc01vZGVscywgZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgIHJldHVybiBidWlsZEludGVybmFsT3B0aW9ucyhheGlzTW9kZWwsICd4QXhpcycsICd4QXhpc0luZGV4Jyk7XG4gIH0pO1xuICBlYWNoKGZpbmRlclJlc3VsdC55QXhpc01vZGVscywgZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgIHJldHVybiBidWlsZEludGVybmFsT3B0aW9ucyhheGlzTW9kZWwsICd5QXhpcycsICd5QXhpc0luZGV4Jyk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGJ1aWxkSW50ZXJuYWxPcHRpb25zKGF4aXNNb2RlbCwgYXhpc01haW5UeXBlLCBheGlzSW5kZXhQcm9wTmFtZSkge1xuICAgIHZhciBheGlzSW5kZXggPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG4gICAgdmFyIG5ld09wdCA9IHtcbiAgICAgIHR5cGU6ICdzZWxlY3QnLFxuICAgICAgJGZyb21Ub29sYm94OiB0cnVlLFxuICAgICAgLy8gRGVmYXVsdCB0byBiZSBmaWx0ZXJcbiAgICAgIGZpbHRlck1vZGU6IGR6RmVhdHVyZU1vZGVsLmdldCgnZmlsdGVyTW9kZScsIHRydWUpIHx8ICdmaWx0ZXInLFxuICAgICAgLy8gSWQgZm9yIG1lcmdlIG1hcHBpbmcuXG4gICAgICBpZDogREFUQV9aT09NX0lEX0JBU0UgKyBheGlzTWFpblR5cGUgKyBheGlzSW5kZXhcbiAgICB9O1xuICAgIG5ld09wdFtheGlzSW5kZXhQcm9wTmFtZV0gPSBheGlzSW5kZXg7XG4gICAgZHpPcHRpb25zLnB1c2gobmV3T3B0KTtcbiAgfVxuXG4gIHJldHVybiBkek9wdGlvbnM7XG59KTtcbmV4cG9ydCBkZWZhdWx0IERhdGFab29tRmVhdHVyZTsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBlY2hhcnRzIGZyb20gJy4uLy4uLy4uL2NvcmUvZWNoYXJ0cyc7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCB7IFRvb2xib3hGZWF0dXJlIH0gZnJvbSAnLi4vZmVhdHVyZU1hbmFnZXInO1xuaW1wb3J0IHsgU0lOR0xFX1JFRkVSUklORyB9IGZyb20gJy4uLy4uLy4uL3V0aWwvbW9kZWwnO1xudmFyIElOTkVSX1NUQUNLX0tFWVdPUkQgPSAnX19lY19tYWdpY1R5cGVfc3RhY2tfXyc7XG52YXIgSUNPTl9UWVBFUyA9IFsnbGluZScsICdiYXInLCAnc3RhY2snXTsgLy8gc3RhY2sgYW5kIHRpbGVkIGFwcGVhcnMgaW4gcGFpciBmb3IgdGhlIHRpdGxlXG5cbnZhciBUSVRMRV9UWVBFUyA9IFsnbGluZScsICdiYXInLCAnc3RhY2snLCAndGlsZWQnXTtcbnZhciByYWRpb1R5cGVzID0gW1snbGluZScsICdiYXInXSwgWydzdGFjayddXTtcblxudmFyIE1hZ2ljVHlwZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNYWdpY1R5cGUsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gTWFnaWNUeXBlKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIE1hZ2ljVHlwZS5wcm90b3R5cGUuZ2V0SWNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICB2YXIgYXZhaWxhYmxlSWNvbnMgPSBtb2RlbC5nZXQoJ2ljb24nKTtcbiAgICB2YXIgaWNvbnMgPSB7fTtcbiAgICB6clV0aWwuZWFjaChtb2RlbC5nZXQoJ3R5cGUnKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmIChhdmFpbGFibGVJY29uc1t0eXBlXSkge1xuICAgICAgICBpY29uc1t0eXBlXSA9IGF2YWlsYWJsZUljb25zW3R5cGVdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpY29ucztcbiAgfTtcblxuICBNYWdpY1R5cGUuZ2V0RGVmYXVsdE9wdGlvbiA9IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdmFyIGRlZmF1bHRPcHRpb24gPSB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgdHlwZTogW10sXG4gICAgICAvLyBJY29uIGdyb3VwXG4gICAgICBpY29uOiB7XG4gICAgICAgIGxpbmU6ICdNNC4xLDI4LjloNy4xbDkuMy0yMmw3LjQsMzhsOS43LTE5LjdsMywxMi44aDE0LjlNNC4xLDU4aDUxLjQnLFxuICAgICAgICBiYXI6ICdNNi43LDIyLjloMTBWNDhoLTEwVjIyLjl6TTI0LjksMTNoMTB2MzVoLTEwVjEzek00My4yLDJoMTB2NDZoLTEwVjJ6TTMuMSw1OGg1My43JyxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHN0YWNrOiAnTTguMiwzOC40bC04LjQsNC4xbDMwLjYsMTUuM0w2MCw0Mi41bC04LjEtNC4xbC0yMS41LDExTDguMiwzOC40eiBNNTEuOSwzMGwtOC4xLDQuMmwtMTMuNCw2LjlsLTEzLjktNi45TDguMiwzMGwtOC40LDQuMmw4LjQsNC4ybDIyLjIsMTFsMjEuNS0xMWw4LjEtNC4yTDUxLjksMzB6IE01MS45LDIxLjdsLTguMSw0LjJMMzUuNywzMGwtNS4zLDIuOEwyNC45LDMwbC04LjQtNC4xbC04LjMtNC4ybC04LjQsNC4yTDguMiwzMGw4LjMsNC4ybDEzLjksNi45bDEzLjQtNi45bDguMS00LjJsOC4xLTQuMUw1MS45LDIxLjd6TTMwLjQsMi4yTC0wLjIsMTcuNWw4LjQsNC4xbDguMyw0LjJsOC40LDQuMmw1LjUsMi43bDUuMy0yLjdsOC4xLTQuMmw4LjEtNC4ybDguMS00LjFMMzAuNCwyLjJ6JyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgICAgfSxcbiAgICAgIC8vIGBsaW5lYCwgYGJhcmAsIGBzdGFja2AsIGB0aWxlZGBcbiAgICAgIHRpdGxlOiBlY01vZGVsLmdldExvY2FsZShbJ3Rvb2xib3gnLCAnbWFnaWNUeXBlJywgJ3RpdGxlJ10pLFxuICAgICAgb3B0aW9uOiB7fSxcbiAgICAgIHNlcmllc0luZGV4OiB7fVxuICAgIH07XG4gICAgcmV0dXJuIGRlZmF1bHRPcHRpb247XG4gIH07XG5cbiAgTWFnaWNUeXBlLnByb3RvdHlwZS5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSwgdHlwZSkge1xuICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgdmFyIHNlcmllc0luZGV4ID0gbW9kZWwuZ2V0KFsnc2VyaWVzSW5kZXgnLCB0eXBlXSk7IC8vIE5vdCBzdXBwb3J0ZWQgbWFnaWNUeXBlXG5cbiAgICBpZiAoIXNlcmllc09wdEdlbnJlYXRvclt0eXBlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXdPcHRpb24gPSB7XG4gICAgICBzZXJpZXM6IFtdXG4gICAgfTtcblxuICAgIHZhciBnZW5lcmF0ZU5ld1Nlcmllc1R5cGVzID0gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgc2VyaWVzVHlwZSA9IHNlcmllc01vZGVsLnN1YlR5cGU7XG4gICAgICB2YXIgc2VyaWVzSWQgPSBzZXJpZXNNb2RlbC5pZDtcbiAgICAgIHZhciBuZXdTZXJpZXNPcHQgPSBzZXJpZXNPcHRHZW5yZWF0b3JbdHlwZV0oc2VyaWVzVHlwZSwgc2VyaWVzSWQsIHNlcmllc01vZGVsLCBtb2RlbCk7XG5cbiAgICAgIGlmIChuZXdTZXJpZXNPcHQpIHtcbiAgICAgICAgLy8gUEVORElORyBJZiBtZXJnZSBvcmlnaW5hbCBvcHRpb24/XG4gICAgICAgIHpyVXRpbC5kZWZhdWx0cyhuZXdTZXJpZXNPcHQsIHNlcmllc01vZGVsLm9wdGlvbik7XG4gICAgICAgIG5ld09wdGlvbi5zZXJpZXMucHVzaChuZXdTZXJpZXNPcHQpO1xuICAgICAgfSAvLyBNb2RpZnkgYm91bmRhcnlHYXBcblxuXG4gICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgICBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJyAmJiAodHlwZSA9PT0gJ2xpbmUnIHx8IHR5cGUgPT09ICdiYXInKSkge1xuICAgICAgICB2YXIgY2F0ZWdvcnlBeGlzID0gY29vcmRTeXMuZ2V0QXhlc0J5U2NhbGUoJ29yZGluYWwnKVswXTtcblxuICAgICAgICBpZiAoY2F0ZWdvcnlBeGlzKSB7XG4gICAgICAgICAgdmFyIGF4aXNEaW0gPSBjYXRlZ29yeUF4aXMuZGltO1xuICAgICAgICAgIHZhciBheGlzVHlwZSA9IGF4aXNEaW0gKyAnQXhpcyc7XG4gICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoYXhpc1R5cGUsIFNJTkdMRV9SRUZFUlJJTkcpLm1vZGVsc1swXTtcbiAgICAgICAgICB2YXIgYXhpc0luZGV4ID0gYXhpc01vZGVsLmNvbXBvbmVudEluZGV4O1xuICAgICAgICAgIG5ld09wdGlvbltheGlzVHlwZV0gPSBuZXdPcHRpb25bYXhpc1R5cGVdIHx8IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gYXhpc0luZGV4OyBpKyspIHtcbiAgICAgICAgICAgIG5ld09wdGlvbltheGlzVHlwZV1bYXhpc0luZGV4XSA9IG5ld09wdGlvbltheGlzVHlwZV1bYXhpc0luZGV4XSB8fCB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdPcHRpb25bYXhpc1R5cGVdW2F4aXNJbmRleF0uYm91bmRhcnlHYXAgPSB0eXBlID09PSAnYmFyJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwuZWFjaChyYWRpb1R5cGVzLCBmdW5jdGlvbiAocmFkaW8pIHtcbiAgICAgIGlmICh6clV0aWwuaW5kZXhPZihyYWRpbywgdHlwZSkgPj0gMCkge1xuICAgICAgICB6clV0aWwuZWFjaChyYWRpbywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBtb2RlbC5zZXRJY29uU3RhdHVzKGl0ZW0sICdub3JtYWwnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbW9kZWwuc2V0SWNvblN0YXR1cyh0eXBlLCAnZW1waGFzaXMnKTtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6ICdzZXJpZXMnLFxuICAgICAgcXVlcnk6IHNlcmllc0luZGV4ID09IG51bGwgPyBudWxsIDoge1xuICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXhcbiAgICAgIH1cbiAgICB9LCBnZW5lcmF0ZU5ld1Nlcmllc1R5cGVzKTtcbiAgICB2YXIgbmV3VGl0bGU7IC8vIENoYW5nZSB0aXRsZSBvZiBzdGFja1xuXG4gICAgaWYgKHR5cGUgPT09ICdzdGFjaycpIHtcbiAgICAgIC8vIHVzZSB0aXRsZXMgaW4gbW9kZWwgaW5zdGVhZCBvZiBlY01vZGVsXG4gICAgICAvLyBhcyBzdGFjayBhbmQgdGlsZWQgYXBwZWFycyBpbiBwYWlyLCBqdXN0IGZsaXAgdGhlbVxuICAgICAgLy8gbm8gbmVlZCBvZiBjaGVja2luZyBzdGFjayBzdGF0ZVxuICAgICAgbmV3VGl0bGUgPSB6clV0aWwubWVyZ2Uoe1xuICAgICAgICBzdGFjazogbW9kZWwub3B0aW9uLnRpdGxlLnRpbGVkLFxuICAgICAgICB0aWxlZDogbW9kZWwub3B0aW9uLnRpdGxlLnN0YWNrXG4gICAgICB9LCBtb2RlbC5vcHRpb24udGl0bGUpO1xuICAgIH1cblxuICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnY2hhbmdlTWFnaWNUeXBlJyxcbiAgICAgIGN1cnJlbnRUeXBlOiB0eXBlLFxuICAgICAgbmV3T3B0aW9uOiBuZXdPcHRpb24sXG4gICAgICBuZXdUaXRsZTogbmV3VGl0bGUsXG4gICAgICBmZWF0dXJlTmFtZTogJ21hZ2ljVHlwZSdcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTWFnaWNUeXBlO1xufShUb29sYm94RmVhdHVyZSk7XG5cbnZhciBzZXJpZXNPcHRHZW5yZWF0b3IgPSB7XG4gICdsaW5lJzogZnVuY3Rpb24gKHNlcmllc1R5cGUsIHNlcmllc0lkLCBzZXJpZXNNb2RlbCwgbW9kZWwpIHtcbiAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ2JhcicpIHtcbiAgICAgIHJldHVybiB6clV0aWwubWVyZ2Uoe1xuICAgICAgICBpZDogc2VyaWVzSWQsXG4gICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgLy8gUHJlc2VydmUgZGF0YSByZWxhdGVkIG9wdGlvblxuICAgICAgICBkYXRhOiBzZXJpZXNNb2RlbC5nZXQoJ2RhdGEnKSxcbiAgICAgICAgc3RhY2s6IHNlcmllc01vZGVsLmdldCgnc3RhY2snKSxcbiAgICAgICAgbWFya1BvaW50OiBzZXJpZXNNb2RlbC5nZXQoJ21hcmtQb2ludCcpLFxuICAgICAgICBtYXJrTGluZTogc2VyaWVzTW9kZWwuZ2V0KCdtYXJrTGluZScpXG4gICAgICB9LCBtb2RlbC5nZXQoWydvcHRpb24nLCAnbGluZSddKSB8fCB7fSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuICAnYmFyJzogZnVuY3Rpb24gKHNlcmllc1R5cGUsIHNlcmllc0lkLCBzZXJpZXNNb2RlbCwgbW9kZWwpIHtcbiAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICByZXR1cm4genJVdGlsLm1lcmdlKHtcbiAgICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgICB0eXBlOiAnYmFyJyxcbiAgICAgICAgLy8gUHJlc2VydmUgZGF0YSByZWxhdGVkIG9wdGlvblxuICAgICAgICBkYXRhOiBzZXJpZXNNb2RlbC5nZXQoJ2RhdGEnKSxcbiAgICAgICAgc3RhY2s6IHNlcmllc01vZGVsLmdldCgnc3RhY2snKSxcbiAgICAgICAgbWFya1BvaW50OiBzZXJpZXNNb2RlbC5nZXQoJ21hcmtQb2ludCcpLFxuICAgICAgICBtYXJrTGluZTogc2VyaWVzTW9kZWwuZ2V0KCdtYXJrTGluZScpXG4gICAgICB9LCBtb2RlbC5nZXQoWydvcHRpb24nLCAnYmFyJ10pIHx8IHt9LCB0cnVlKTtcbiAgICB9XG4gIH0sXG4gICdzdGFjayc6IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBzZXJpZXNJZCwgc2VyaWVzTW9kZWwsIG1vZGVsKSB7XG4gICAgdmFyIGlzU3RhY2sgPSBzZXJpZXNNb2RlbC5nZXQoJ3N0YWNrJykgPT09IElOTkVSX1NUQUNLX0tFWVdPUkQ7XG5cbiAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ2xpbmUnIHx8IHNlcmllc1R5cGUgPT09ICdiYXInKSB7XG4gICAgICBtb2RlbC5zZXRJY29uU3RhdHVzKCdzdGFjaycsIGlzU3RhY2sgPyAnbm9ybWFsJyA6ICdlbXBoYXNpcycpO1xuICAgICAgcmV0dXJuIHpyVXRpbC5tZXJnZSh7XG4gICAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgICAgc3RhY2s6IGlzU3RhY2sgPyAnJyA6IElOTkVSX1NUQUNLX0tFWVdPUkRcbiAgICAgIH0sIG1vZGVsLmdldChbJ29wdGlvbicsICdzdGFjayddKSB8fCB7fSwgdHJ1ZSk7XG4gICAgfVxuICB9XG59OyAvLyBUT0RPOiBTRUxGIFJFR0lTVEVSRUQuXG5cbmVjaGFydHMucmVnaXN0ZXJBY3Rpb24oe1xuICB0eXBlOiAnY2hhbmdlTWFnaWNUeXBlJyxcbiAgZXZlbnQ6ICdtYWdpY1R5cGVDaGFuZ2VkJyxcbiAgdXBkYXRlOiAncHJlcGFyZUFuZFVwZGF0ZSdcbn0sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gIGVjTW9kZWwubWVyZ2VPcHRpb24ocGF5bG9hZC5uZXdPcHRpb24pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBNYWdpY1R5cGU7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgZWNoYXJ0cyBmcm9tICcuLi8uLi8uLi9jb3JlL2VjaGFydHMnO1xuaW1wb3J0ICogYXMgaGlzdG9yeSBmcm9tICcuLi8uLi9kYXRhWm9vbS9oaXN0b3J5JztcbmltcG9ydCB7IFRvb2xib3hGZWF0dXJlIH0gZnJvbSAnLi4vZmVhdHVyZU1hbmFnZXInO1xuXG52YXIgUmVzdG9yZU9wdGlvbiA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhSZXN0b3JlT3B0aW9uLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFJlc3RvcmVPcHRpb24oKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgUmVzdG9yZU9wdGlvbi5wcm90b3R5cGUub25jbGljayA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBoaXN0b3J5LmNsZWFyKGVjTW9kZWwpO1xuICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAncmVzdG9yZScsXG4gICAgICBmcm9tOiB0aGlzLnVpZFxuICAgIH0pO1xuICB9O1xuXG4gIFJlc3RvcmVPcHRpb24uZ2V0RGVmYXVsdE9wdGlvbiA9IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdmFyIGRlZmF1bHRPcHRpb24gPSB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBpY29uOiAnTTMuOCwzMy40IE00NywxOC45aDkuOFY4LjcgTTU2LjMsMjAuMSBDNTIuMSw5LDQwLjUsMC42LDI2LjgsMi4xQzEyLjYsMy43LDEuNiwxNi4yLDIuMSwzMC42IE0xMyw0MS4xSDMuMXYxMC4yIE0zLjcsMzkuOWM0LjIsMTEuMSwxNS44LDE5LjUsMjkuNSwxOCBjMTQuMi0xLjYsMjUuMi0xNC4xLDI0LjctMjguNScsXG4gICAgICB0aXRsZTogZWNNb2RlbC5nZXRMb2NhbGUoWyd0b29sYm94JywgJ3Jlc3RvcmUnLCAndGl0bGUnXSlcbiAgICB9O1xuICAgIHJldHVybiBkZWZhdWx0T3B0aW9uO1xuICB9O1xuXG4gIHJldHVybiBSZXN0b3JlT3B0aW9uO1xufShUb29sYm94RmVhdHVyZSk7IC8vIFRPRE86IFNFTEYgUkVHSVNURVJFRC5cblxuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ3Jlc3RvcmUnLFxuICBldmVudDogJ3Jlc3RvcmUnLFxuICB1cGRhdGU6ICdwcmVwYXJlQW5kVXBkYXRlJ1xufSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgZWNNb2RlbC5yZXNldE9wdGlvbigncmVjcmVhdGUnKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgUmVzdG9yZU9wdGlvbjsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG4vKiBnbG9iYWwgVWludDhBcnJheSAqL1xuXG5pbXBvcnQgZW52IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvZW52JztcbmltcG9ydCB7IFRvb2xib3hGZWF0dXJlIH0gZnJvbSAnLi4vZmVhdHVyZU1hbmFnZXInO1xuXG52YXIgU2F2ZUFzSW1hZ2UgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2F2ZUFzSW1hZ2UsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU2F2ZUFzSW1hZ2UoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgU2F2ZUFzSW1hZ2UucHJvdG90eXBlLm9uY2xpY2sgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICB2YXIgdGl0bGUgPSBtb2RlbC5nZXQoJ25hbWUnKSB8fCBlY01vZGVsLmdldCgndGl0bGUuMC50ZXh0JykgfHwgJ2VjaGFydHMnO1xuICAgIHZhciBpc1N2ZyA9IGFwaS5nZXRacigpLnBhaW50ZXIuZ2V0VHlwZSgpID09PSAnc3ZnJztcbiAgICB2YXIgdHlwZSA9IGlzU3ZnID8gJ3N2ZycgOiBtb2RlbC5nZXQoJ3R5cGUnLCB0cnVlKSB8fCAncG5nJztcbiAgICB2YXIgdXJsID0gYXBpLmdldENvbm5lY3RlZERhdGFVUkwoe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogbW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InLCB0cnVlKSB8fCBlY01vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJykgfHwgJyNmZmYnLFxuICAgICAgY29ubmVjdGVkQmFja2dyb3VuZENvbG9yOiBtb2RlbC5nZXQoJ2Nvbm5lY3RlZEJhY2tncm91bmRDb2xvcicpLFxuICAgICAgZXhjbHVkZUNvbXBvbmVudHM6IG1vZGVsLmdldCgnZXhjbHVkZUNvbXBvbmVudHMnKSxcbiAgICAgIHBpeGVsUmF0aW86IG1vZGVsLmdldCgncGl4ZWxSYXRpbycpXG4gICAgfSk7IC8vIENocm9tZSwgRmlyZWZveCwgTmV3IEVkZ2VcblxuICAgIGlmICh0eXBlb2YgTW91c2VFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiAoZW52LmJyb3dzZXIubmV3RWRnZSB8fCAhZW52LmJyb3dzZXIuaWUgJiYgIWVudi5icm93c2VyLmVkZ2UpKSB7XG4gICAgICB2YXIgJGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAkYS5kb3dubG9hZCA9IHRpdGxlICsgJy4nICsgdHlwZTtcbiAgICAgICRhLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgJGEuaHJlZiA9IHVybDtcbiAgICAgIHZhciBldnQgPSBuZXcgTW91c2VFdmVudCgnY2xpY2snLCB7XG4gICAgICAgIC8vIHNvbWUgbWljcm8gZnJvbnQtZW5kIGZyYW1ld29ya++8jCB3aW5kb3cgbWF5YmUgaXMgYSBQcm94eVxuICAgICAgICB2aWV3OiBkb2N1bWVudC5kZWZhdWx0VmlldyxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgJGEuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIH0gLy8gSUUgb3Igb2xkIEVkZ2VcbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYiB8fCBpc1N2Zykge1xuICAgICAgICAgIHZhciBwYXJ0cyA9IHVybC5zcGxpdCgnLCcpOyAvLyBkYXRhOls8bWltZSB0eXBlPl1bO2NoYXJzZXQ9PGNoYXJzZXQ+XVs7YmFzZTY0XSw8ZW5jb2RlZCBkYXRhPlxuXG4gICAgICAgICAgdmFyIGJhc2U2NEVuY29kZWQgPSBwYXJ0c1swXS5pbmRleE9mKCdiYXNlNjQnKSA+IC0xO1xuICAgICAgICAgIHZhciBic3RyID0gaXNTdmcgLy8gc2hvdWxkIGRlY29kZSB0aGUgc3ZnIGRhdGEgdXJpIGZpcnN0XG4gICAgICAgICAgPyBkZWNvZGVVUklDb21wb25lbnQocGFydHNbMV0pIDogcGFydHNbMV07IC8vIG9ubHkgYGF0b2JgIHdoZW4gdGhlIGRhdGEgdXJpIGlzIGVuY29kZWQgd2l0aCBiYXNlNjRcbiAgICAgICAgICAvLyBvdGhlcndpc2UsIGxpa2UgYHN2Z2AgZGF0YSB1cmkgZXhwb3J0ZWQgYnkgenJlbmRlcixcbiAgICAgICAgICAvLyB0aGVyZSB3aWxsIGJlIGFuIGVycm9yLCBmb3IgaXQncyBub3QgZW5jb2RlZCB3aXRoIGJhc2U2NC5cbiAgICAgICAgICAvLyAoanVzdCBhIHVybC1lbmNvZGVkIHN0cmluZyB0aHJvdWdoIGBlbmNvZGVVUklDb21wb25lbnRgKVxuXG4gICAgICAgICAgYmFzZTY0RW5jb2RlZCAmJiAoYnN0ciA9IGF0b2IoYnN0cikpO1xuICAgICAgICAgIHZhciBmaWxlbmFtZSA9IHRpdGxlICsgJy4nICsgdHlwZTtcblxuICAgICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IpIHtcbiAgICAgICAgICAgIHZhciBuID0gYnN0ci5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgdThhcnIgPSBuZXcgVWludDhBcnJheShuKTtcblxuICAgICAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgICAgICB1OGFycltuXSA9IGJzdHIuY2hhckNvZGVBdChuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbdThhcnJdKTtcbiAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihibG9iLCBmaWxlbmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmcmFtZSk7XG4gICAgICAgICAgICB2YXIgY3cgPSBmcmFtZS5jb250ZW50V2luZG93O1xuICAgICAgICAgICAgdmFyIGRvYyA9IGN3LmRvY3VtZW50O1xuICAgICAgICAgICAgZG9jLm9wZW4oJ2ltYWdlL3N2Zyt4bWwnLCAncmVwbGFjZScpO1xuICAgICAgICAgICAgZG9jLndyaXRlKGJzdHIpO1xuICAgICAgICAgICAgZG9jLmNsb3NlKCk7XG4gICAgICAgICAgICBjdy5mb2N1cygpO1xuICAgICAgICAgICAgZG9jLmV4ZWNDb21tYW5kKCdTYXZlQXMnLCB0cnVlLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGZyYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGxhbmcgPSBtb2RlbC5nZXQoJ2xhbmcnKTtcbiAgICAgICAgICB2YXIgaHRtbCA9ICcnICsgJzxib2R5IHN0eWxlPVwibWFyZ2luOjA7XCI+JyArICc8aW1nIHNyYz1cIicgKyB1cmwgKyAnXCIgc3R5bGU9XCJtYXgtd2lkdGg6MTAwJTtcIiB0aXRsZT1cIicgKyAobGFuZyAmJiBsYW5nWzBdIHx8ICcnKSArICdcIiAvPicgKyAnPC9ib2R5Pic7XG4gICAgICAgICAgdmFyIHRhYiA9IHdpbmRvdy5vcGVuKCk7XG4gICAgICAgICAgdGFiLmRvY3VtZW50LndyaXRlKGh0bWwpO1xuICAgICAgICAgIHRhYi5kb2N1bWVudC50aXRsZSA9IHRpdGxlO1xuICAgICAgICB9XG4gICAgICB9XG4gIH07XG5cbiAgU2F2ZUFzSW1hZ2UuZ2V0RGVmYXVsdE9wdGlvbiA9IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdmFyIGRlZmF1bHRPcHRpb24gPSB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgaWNvbjogJ000LjcsMjIuOUwyOS4zLDQ1LjVMNTQuNywyMy40TTQuNiw0My42TDQuNiw1OEw1My44LDU4TDUzLjgsNDMuNk0yOS4yLDQ1LjFMMjkuMiwwJyxcbiAgICAgIHRpdGxlOiBlY01vZGVsLmdldExvY2FsZShbJ3Rvb2xib3gnLCAnc2F2ZUFzSW1hZ2UnLCAndGl0bGUnXSksXG4gICAgICB0eXBlOiAncG5nJyxcbiAgICAgIC8vIERlZmF1bHQgdXNlIG9wdGlvbi5iYWNrZ3JvdW5kQ29sb3JcbiAgICAgIC8vIGJhY2tncm91bmRDb2xvcjogJyNmZmYnLFxuICAgICAgY29ubmVjdGVkQmFja2dyb3VuZENvbG9yOiAnI2ZmZicsXG4gICAgICBuYW1lOiAnJyxcbiAgICAgIGV4Y2x1ZGVDb21wb25lbnRzOiBbJ3Rvb2xib3gnXSxcbiAgICAgIC8vIHVzZSBjdXJyZW50IHBpeGVsIHJhdGlvIG9mIGRldmljZSBieSBkZWZhdWx0XG4gICAgICAvLyBwaXhlbFJhdGlvOiAxLFxuICAgICAgbGFuZzogZWNNb2RlbC5nZXRMb2NhbGUoWyd0b29sYm94JywgJ3NhdmVBc0ltYWdlJywgJ2xhbmcnXSlcbiAgICB9O1xuICAgIHJldHVybiBkZWZhdWx0T3B0aW9uO1xuICB9O1xuXG4gIHJldHVybiBTYXZlQXNJbWFnZTtcbn0oVG9vbGJveEZlYXR1cmUpO1xuXG5TYXZlQXNJbWFnZS5wcm90b3R5cGUudW51c2FibGUgPSAhZW52LmNhbnZhc1N1cHBvcnRlZDtcbmV4cG9ydCBkZWZhdWx0IFNhdmVBc0ltYWdlOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG52YXIgVG9vbGJveEZlYXR1cmUgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb29sYm94RmVhdHVyZSgpIHt9XG5cbiAgcmV0dXJuIFRvb2xib3hGZWF0dXJlO1xufSgpO1xuXG5leHBvcnQgeyBUb29sYm94RmVhdHVyZSB9O1xudmFyIGZlYXR1cmVzID0ge307XG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJGZWF0dXJlKG5hbWUsIGN0b3IpIHtcbiAgZmVhdHVyZXNbbmFtZV0gPSBjdG9yO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEZlYXR1cmUobmFtZSkge1xuICByZXR1cm4gZmVhdHVyZXNbbmFtZV07XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IHVzZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbic7XG5pbXBvcnQgeyBpbnN0YWxsIGFzIGluc3RhbGxEYXRhWm9vbVNlbGVjdCB9IGZyb20gJy4uLy4uL2NvbXBvbmVudC9kYXRhWm9vbS9pbnN0YWxsRGF0YVpvb21TZWxlY3QnO1xuaW1wb3J0IFRvb2xib3hNb2RlbCBmcm9tICcuL1Rvb2xib3hNb2RlbCc7XG5pbXBvcnQgVG9vbGJveFZpZXcgZnJvbSAnLi9Ub29sYm94Vmlldyc7IC8vIFRPRE9EOiBSRUdJU1RFUiBJTiBJTlNUQUxMXG5cbmltcG9ydCB7IHJlZ2lzdGVyRmVhdHVyZSB9IGZyb20gJy4vZmVhdHVyZU1hbmFnZXInO1xuaW1wb3J0IFNhdmVBc0ltYWdlIGZyb20gJy4vZmVhdHVyZS9TYXZlQXNJbWFnZSc7XG5pbXBvcnQgTWFnaWNUeXBlIGZyb20gJy4vZmVhdHVyZS9NYWdpY1R5cGUnO1xuaW1wb3J0IERhdGFWaWV3IGZyb20gJy4vZmVhdHVyZS9EYXRhVmlldyc7XG5pbXBvcnQgUmVzdG9yZSBmcm9tICcuL2ZlYXR1cmUvUmVzdG9yZSc7XG5pbXBvcnQgRGF0YVpvb20gZnJvbSAnLi9mZWF0dXJlL0RhdGFab29tJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChUb29sYm94TW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KFRvb2xib3hWaWV3KTtcbiAgcmVnaXN0ZXJGZWF0dXJlKCdzYXZlQXNJbWFnZScsIFNhdmVBc0ltYWdlKTtcbiAgcmVnaXN0ZXJGZWF0dXJlKCdtYWdpY1R5cGUnLCBNYWdpY1R5cGUpO1xuICByZWdpc3RlckZlYXR1cmUoJ2RhdGFWaWV3JywgRGF0YVZpZXcpO1xuICByZWdpc3RlckZlYXR1cmUoJ2RhdGFab29tJywgRGF0YVpvb20pO1xuICByZWdpc3RlckZlYXR1cmUoJ3Jlc3RvcmUnLCBSZXN0b3JlKTtcbiAgdXNlKGluc3RhbGxEYXRhWm9vbVNlbGVjdCk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IGlzU3RyaW5nLCBpbmRleE9mLCBtYXAsIGVhY2gsIGJpbmQsIGlzQXJyYXksIGlzRG9tIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCB7IHRvSGV4IH0gZnJvbSAnenJlbmRlci9saWIvdG9vbC9jb2xvcic7XG5pbXBvcnQgeyBub3JtYWxpemVFdmVudCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQnO1xuaW1wb3J0IHsgdHJhbnNmb3JtTG9jYWxDb29yZCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvZG9tJztcbmltcG9ydCBlbnYgZnJvbSAnenJlbmRlci9saWIvY29yZS9lbnYnO1xuaW1wb3J0IHsgY29udmVydFRvQ29sb3JTdHJpbmcsIHRvQ2FtZWxDYXNlLCBub3JtYWxpemVDc3NBcnJheSB9IGZyb20gJy4uLy4uL3V0aWwvZm9ybWF0JztcbmltcG9ydCB7IHNob3VsZFRvb2x0aXBDb25maW5lIH0gZnJvbSAnLi9oZWxwZXInO1xuaW1wb3J0IHsgZ2V0UGFkZGluZ0Zyb21Ub29sdGlwTW9kZWwgfSBmcm9tICcuL3Rvb2x0aXBNYXJrdXAnO1xudmFyIHZlbmRvcnMgPSBbJy1tcy0nLCAnLW1vei0nLCAnLW8tJywgJy13ZWJraXQtJywgJyddO1xudmFyIGdDc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7Ym9yZGVyLXN0eWxlOnNvbGlkO3doaXRlLXNwYWNlOm5vd3JhcDt6LWluZGV4Ojk5OTk5OTk7JztcblxuZnVuY3Rpb24gbWlycm9yUG9zKHBvcykge1xuICBwb3MgPSBwb3MgPT09ICdsZWZ0JyA/ICdyaWdodCcgOiBwb3MgPT09ICdyaWdodCcgPyAnbGVmdCcgOiBwb3MgPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgcmV0dXJuIHBvcztcbn1cblxuZnVuY3Rpb24gYXNzZW1ibGVBcnJvdyhiYWNrZ3JvdW5kQ29sb3IsIGJvcmRlckNvbG9yLCBhcnJvd1Bvc2l0aW9uKSB7XG4gIGlmICghaXNTdHJpbmcoYXJyb3dQb3NpdGlvbikgfHwgYXJyb3dQb3NpdGlvbiA9PT0gJ2luc2lkZScpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBib3JkZXJDb2xvciA9IGNvbnZlcnRUb0NvbG9yU3RyaW5nKGJvcmRlckNvbG9yKTtcbiAgdmFyIGFycm93UG9zID0gbWlycm9yUG9zKGFycm93UG9zaXRpb24pO1xuICB2YXIgcG9zaXRpb25TdHlsZSA9ICcnO1xuICB2YXIgdHJhbnNmb3JtU3R5bGUgPSAnJztcblxuICBpZiAoaW5kZXhPZihbJ2xlZnQnLCAncmlnaHQnXSwgYXJyb3dQb3MpID4gLTEpIHtcbiAgICBwb3NpdGlvblN0eWxlID0gYXJyb3dQb3MgKyBcIjotNnB4O3RvcDo1MCU7XCI7XG4gICAgdHJhbnNmb3JtU3R5bGUgPSBcInRyYW5zbGF0ZVkoLTUwJSkgcm90YXRlKFwiICsgKGFycm93UG9zID09PSAnbGVmdCcgPyAtMjI1IDogLTQ1KSArIFwiZGVnKVwiO1xuICB9IGVsc2Uge1xuICAgIHBvc2l0aW9uU3R5bGUgPSBhcnJvd1BvcyArIFwiOi02cHg7bGVmdDo1MCU7XCI7XG4gICAgdHJhbnNmb3JtU3R5bGUgPSBcInRyYW5zbGF0ZVgoLTUwJSkgcm90YXRlKFwiICsgKGFycm93UG9zID09PSAndG9wJyA/IDIyNSA6IDQ1KSArIFwiZGVnKVwiO1xuICB9XG5cbiAgdHJhbnNmb3JtU3R5bGUgPSBtYXAodmVuZG9ycywgZnVuY3Rpb24gKHZlbmRvclByZWZpeCkge1xuICAgIHJldHVybiB2ZW5kb3JQcmVmaXggKyAndHJhbnNmb3JtOicgKyB0cmFuc2Zvcm1TdHlsZTtcbiAgfSkuam9pbignOycpO1xuICB2YXIgc3R5bGVDc3MgPSBbJ3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEwcHg7aGVpZ2h0OjEwcHg7JywgXCJcIiArIHBvc2l0aW9uU3R5bGUgKyB0cmFuc2Zvcm1TdHlsZSArIFwiO1wiLCBcImJvcmRlci1ib3R0b206IFwiICsgYm9yZGVyQ29sb3IgKyBcIiBzb2xpZCAxcHg7XCIsIFwiYm9yZGVyLXJpZ2h0OiBcIiArIGJvcmRlckNvbG9yICsgXCIgc29saWQgMXB4O1wiLCBcImJhY2tncm91bmQtY29sb3I6IFwiICsgYmFja2dyb3VuZENvbG9yICsgXCI7XCIsICdib3gtc2hhZG93OiA4cHggOHB4IDE2cHggLTNweCAjMDAwOyddO1xuICByZXR1cm4gXCI8ZGl2IHN0eWxlPVxcXCJcIiArIHN0eWxlQ3NzLmpvaW4oJycpICsgXCJcXFwiPjwvZGl2PlwiO1xufVxuXG5mdW5jdGlvbiBhc3NlbWJsZVRyYW5zaXRpb24oZHVyYXRpb24sIG9ubHlGYWRlKSB7XG4gIHZhciB0cmFuc2l0aW9uQ3VydmUgPSAnY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpJztcbiAgdmFyIHRyYW5zaXRpb25UZXh0ID0gJ29wYWNpdHkgJyArIGR1cmF0aW9uIC8gMiArICdzICcgKyB0cmFuc2l0aW9uQ3VydmUgKyAnLCcgKyAndmlzaWJpbGl0eSAnICsgZHVyYXRpb24gLyAyICsgJ3MgJyArIHRyYW5zaXRpb25DdXJ2ZTtcblxuICBpZiAoIW9ubHlGYWRlKSB7XG4gICAgdHJhbnNpdGlvblRleHQgKz0gJyxsZWZ0ICcgKyBkdXJhdGlvbiArICdzICcgKyB0cmFuc2l0aW9uQ3VydmUgKyAnLHRvcCAnICsgZHVyYXRpb24gKyAncyAnICsgdHJhbnNpdGlvbkN1cnZlO1xuICB9XG5cbiAgcmV0dXJuIG1hcCh2ZW5kb3JzLCBmdW5jdGlvbiAodmVuZG9yUHJlZml4KSB7XG4gICAgcmV0dXJuIHZlbmRvclByZWZpeCArICd0cmFuc2l0aW9uOicgKyB0cmFuc2l0aW9uVGV4dDtcbiAgfSkuam9pbignOycpO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VtYmxlRm9udCh0ZXh0U3R5bGVNb2RlbCkge1xuICB2YXIgY3NzVGV4dCA9IFtdO1xuICB2YXIgZm9udFNpemUgPSB0ZXh0U3R5bGVNb2RlbC5nZXQoJ2ZvbnRTaXplJyk7XG4gIHZhciBjb2xvciA9IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpO1xuICBjb2xvciAmJiBjc3NUZXh0LnB1c2goJ2NvbG9yOicgKyBjb2xvcik7XG4gIGNzc1RleHQucHVzaCgnZm9udDonICsgdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpKTtcbiAgZm9udFNpemUgLy8gQHRzLWlnbm9yZSwgbGVhdmUgaXQgdG8gdGhlIHRvb2x0aXAgcmVmYWN0b3IuXG4gICYmIGNzc1RleHQucHVzaCgnbGluZS1oZWlnaHQ6JyArIE1hdGgucm91bmQoZm9udFNpemUgKiAzIC8gMikgKyAncHgnKTtcbiAgdmFyIHNoYWRvd0NvbG9yID0gdGV4dFN0eWxlTW9kZWwuZ2V0KCd0ZXh0U2hhZG93Q29sb3InKTtcbiAgdmFyIHNoYWRvd0JsdXIgPSB0ZXh0U3R5bGVNb2RlbC5nZXQoJ3RleHRTaGFkb3dCbHVyJykgfHwgMDtcbiAgdmFyIHNoYWRvd09mZnNldFggPSB0ZXh0U3R5bGVNb2RlbC5nZXQoJ3RleHRTaGFkb3dPZmZzZXRYJykgfHwgMDtcbiAgdmFyIHNoYWRvd09mZnNldFkgPSB0ZXh0U3R5bGVNb2RlbC5nZXQoJ3RleHRTaGFkb3dPZmZzZXRZJykgfHwgMDtcbiAgc2hhZG93Q29sb3IgJiYgc2hhZG93Qmx1ciAmJiBjc3NUZXh0LnB1c2goJ3RleHQtc2hhZG93OicgKyBzaGFkb3dPZmZzZXRYICsgJ3B4ICcgKyBzaGFkb3dPZmZzZXRZICsgJ3B4ICcgKyBzaGFkb3dCbHVyICsgJ3B4ICcgKyBzaGFkb3dDb2xvcik7XG4gIGVhY2goWydkZWNvcmF0aW9uJywgJ2FsaWduJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbCA9IHRleHRTdHlsZU1vZGVsLmdldChuYW1lKTtcbiAgICB2YWwgJiYgY3NzVGV4dC5wdXNoKCd0ZXh0LScgKyBuYW1lICsgJzonICsgdmFsKTtcbiAgfSk7XG4gIHJldHVybiBjc3NUZXh0LmpvaW4oJzsnKTtcbn1cblxuZnVuY3Rpb24gYXNzZW1ibGVDc3NUZXh0KHRvb2x0aXBNb2RlbCwgZW5hYmxlVHJhbnNpdGlvbiwgb25seUZhZGUpIHtcbiAgdmFyIGNzc1RleHQgPSBbXTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3RyYW5zaXRpb25EdXJhdGlvbicpO1xuICB2YXIgYmFja2dyb3VuZENvbG9yID0gdG9vbHRpcE1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XG4gIHZhciBzaGFkb3dCbHVyID0gdG9vbHRpcE1vZGVsLmdldCgnc2hhZG93Qmx1cicpO1xuICB2YXIgc2hhZG93Q29sb3IgPSB0b29sdGlwTW9kZWwuZ2V0KCdzaGFkb3dDb2xvcicpO1xuICB2YXIgc2hhZG93T2Zmc2V0WCA9IHRvb2x0aXBNb2RlbC5nZXQoJ3NoYWRvd09mZnNldFgnKTtcbiAgdmFyIHNoYWRvd09mZnNldFkgPSB0b29sdGlwTW9kZWwuZ2V0KCdzaGFkb3dPZmZzZXRZJyk7XG4gIHZhciB0ZXh0U3R5bGVNb2RlbCA9IHRvb2x0aXBNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gIHZhciBwYWRkaW5nID0gZ2V0UGFkZGluZ0Zyb21Ub29sdGlwTW9kZWwodG9vbHRpcE1vZGVsLCAnaHRtbCcpO1xuICB2YXIgYm94U2hhZG93ID0gc2hhZG93T2Zmc2V0WCArIFwicHggXCIgKyBzaGFkb3dPZmZzZXRZICsgXCJweCBcIiArIHNoYWRvd0JsdXIgKyBcInB4IFwiICsgc2hhZG93Q29sb3I7XG4gIGNzc1RleHQucHVzaCgnYm94LXNoYWRvdzonICsgYm94U2hhZG93KTsgLy8gQW5pbWF0aW9uIHRyYW5zaXRpb24uIERvIG5vdCBhbmltYXRlIHdoZW4gdHJhbnNpdGlvbkR1cmF0aW9uIGlzIDAuXG5cbiAgZW5hYmxlVHJhbnNpdGlvbiAmJiB0cmFuc2l0aW9uRHVyYXRpb24gJiYgY3NzVGV4dC5wdXNoKGFzc2VtYmxlVHJhbnNpdGlvbih0cmFuc2l0aW9uRHVyYXRpb24sIG9ubHlGYWRlKSk7XG5cbiAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgIGlmIChlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICBjc3NUZXh0LnB1c2goJ2JhY2tncm91bmQtQ29sb3I6JyArIGJhY2tncm91bmRDb2xvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBpZVxuICAgICAgY3NzVGV4dC5wdXNoKCdiYWNrZ3JvdW5kLUNvbG9yOiMnICsgdG9IZXgoYmFja2dyb3VuZENvbG9yKSk7XG4gICAgICBjc3NUZXh0LnB1c2goJ2ZpbHRlcjphbHBoYShvcGFjaXR5PTcwKScpO1xuICAgIH1cbiAgfSAvLyBCb3JkZXIgc3R5bGVcblxuXG4gIGVhY2goWyd3aWR0aCcsICdjb2xvcicsICdyYWRpdXMnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgYm9yZGVyTmFtZSA9ICdib3JkZXItJyArIG5hbWU7XG4gICAgdmFyIGNhbWVsQ2FzZSA9IHRvQ2FtZWxDYXNlKGJvcmRlck5hbWUpO1xuICAgIHZhciB2YWwgPSB0b29sdGlwTW9kZWwuZ2V0KGNhbWVsQ2FzZSk7XG4gICAgdmFsICE9IG51bGwgJiYgY3NzVGV4dC5wdXNoKGJvcmRlck5hbWUgKyAnOicgKyB2YWwgKyAobmFtZSA9PT0gJ2NvbG9yJyA/ICcnIDogJ3B4JykpO1xuICB9KTsgLy8gVGV4dCBzdHlsZVxuXG4gIGNzc1RleHQucHVzaChhc3NlbWJsZUZvbnQodGV4dFN0eWxlTW9kZWwpKTsgLy8gUGFkZGluZ1xuXG4gIGlmIChwYWRkaW5nICE9IG51bGwpIHtcbiAgICBjc3NUZXh0LnB1c2goJ3BhZGRpbmc6JyArIG5vcm1hbGl6ZUNzc0FycmF5KHBhZGRpbmcpLmpvaW4oJ3B4ICcpICsgJ3B4Jyk7XG4gIH1cblxuICByZXR1cm4gY3NzVGV4dC5qb2luKCc7JykgKyAnOyc7XG59IC8vIElmIG5vdCBhYmxlIHRvIG1ha2UsIGRvIG5vdCBtb2RpZnkgdGhlIGlucHV0IGBvdXRgLlxuXG5cbmZ1bmN0aW9uIG1ha2VTdHlsZUNvb3JkKG91dCwgenIsIGFwcGVuZFRvQm9keSwgenJYLCB6clkpIHtcbiAgdmFyIHpyUGFpbnRlciA9IHpyICYmIHpyLnBhaW50ZXI7XG5cbiAgaWYgKGFwcGVuZFRvQm9keSkge1xuICAgIHZhciB6clZpZXdwb3J0Um9vdCA9IHpyUGFpbnRlciAmJiB6clBhaW50ZXIuZ2V0Vmlld3BvcnRSb290KCk7XG5cbiAgICBpZiAoenJWaWV3cG9ydFJvb3QpIHtcbiAgICAgIC8vIFNvbWUgQVBQcyBtaWdodCB1c2Ugc2NhbGUgb24gYm9keSwgc28gd2Ugc3VwcG9ydCBDU1MgdHJhbnNmb3JtIGhlcmUuXG4gICAgICB0cmFuc2Zvcm1Mb2NhbENvb3JkKG91dCwgenJWaWV3cG9ydFJvb3QsIGRvY3VtZW50LmJvZHksIHpyWCwgenJZKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0genJYO1xuICAgIG91dFsxXSA9IHpyWTsgLy8geHkgc2hvdWxkIGJlIGJhc2VkIG9uIGNhbnZhcyByb290LiBCdXQgdG9vbHRpcENvbnRlbnQgaXNcbiAgICAvLyB0aGUgc2libGluZyBvZiBjYW52YXMgcm9vdC4gU28gcGFkZGluZyBvZiBlYyBjb250YWluZXJcbiAgICAvLyBzaG91bGQgYmUgY29uc2lkZXJlZCBoZXJlLlxuXG4gICAgdmFyIHZpZXdwb3J0Um9vdE9mZnNldCA9IHpyUGFpbnRlciAmJiB6clBhaW50ZXIuZ2V0Vmlld3BvcnRSb290T2Zmc2V0KCk7XG5cbiAgICBpZiAodmlld3BvcnRSb290T2Zmc2V0KSB7XG4gICAgICBvdXRbMF0gKz0gdmlld3BvcnRSb290T2Zmc2V0Lm9mZnNldExlZnQ7XG4gICAgICBvdXRbMV0gKz0gdmlld3BvcnRSb290T2Zmc2V0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cblxuICBvdXRbMl0gPSBvdXRbMF0gLyB6ci5nZXRXaWR0aCgpO1xuICBvdXRbM10gPSBvdXRbMV0gLyB6ci5nZXRIZWlnaHQoKTtcbn1cblxudmFyIFRvb2x0aXBIVE1MQ29udGVudCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRvb2x0aXBIVE1MQ29udGVudChjb250YWluZXIsIGFwaSwgb3B0KSB7XG4gICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuICAgIHRoaXMuX3N0eWxlQ29vcmQgPSBbMCwgMCwgMCwgMF07XG4gICAgdGhpcy5fZW50ZXJhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9maXJzdFNob3cgPSB0cnVlO1xuICAgIHRoaXMuX2xvbmdIaWRlID0gdHJ1ZTtcblxuICAgIGlmIChlbnYud3hhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsgLy8gVE9ETzogVFlQRVxuXG4gICAgZWwuZG9tQmVsb25nVG9aciA9IHRydWU7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHZhciB6ciA9IHRoaXMuX3pyID0gYXBpLmdldFpyKCk7XG4gICAgdmFyIGFwcGVuZFRvQm9keSA9IHRoaXMuX2FwcGVuZFRvQm9keSA9IG9wdCAmJiBvcHQuYXBwZW5kVG9Cb2R5O1xuICAgIG1ha2VTdHlsZUNvb3JkKHRoaXMuX3N0eWxlQ29vcmQsIHpyLCBhcHBlbmRUb0JvZHksIGFwaS5nZXRXaWR0aCgpIC8gMiwgYXBpLmdldEhlaWdodCgpIC8gMik7XG5cbiAgICBpZiAoYXBwZW5kVG9Cb2R5KSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7IC8vIEZJWE1FXG4gICAgLy8gSXMgaXQgbmVlZGVkIHRvIHRyaWdnZXIgenIgZXZlbnQgbWFudWFsbHkgaWZcbiAgICAvLyB0aGUgYnJvd3NlciBkbyBub3Qgc3VwcG9ydCBgcG9pbnRlci1ldmVudHM6IG5vbmVgLlxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZWwub25tb3VzZWVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY2xlYXIgdGhlIHRpbWVvdXQgaW4gaGlkZUxhdGVyIGFuZCBrZWVwIHNob3dpbmcgdG9vbHRpcFxuICAgICAgaWYgKHNlbGYuX2VudGVyYWJsZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5faGlkZVRpbWVvdXQpO1xuICAgICAgICBzZWxmLl9zaG93ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5faW5Db250ZW50ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZWwub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgICBpZiAoIXNlbGYuX2VudGVyYWJsZSkge1xuICAgICAgICAvLyBgcG9pbnRlci1ldmVudHM6IG5vbmVgIGlzIHNldCB0byB0b29sdGlwIGNvbnRlbnQgZGl2XG4gICAgICAgIC8vIGlmIGBlbnRlcmFibGVgIGlzIHNldCBhcyBgZmFsc2VgLCBhbmQgYGVsLm9ubW91c2Vtb3ZlYFxuICAgICAgICAvLyBjYW4gbm90IGJlIHRyaWdnZXJlZC4gQnV0IGluIGJyb3dzZXIgdGhhdCBkbyBub3RcbiAgICAgICAgLy8gc3VwcG9ydCBgcG9pbnRlci1ldmVudHNgLCB3ZSBuZWVkIHRvIGRvIHRoaXM6XG4gICAgICAgIC8vIFRyeSB0cmlnZ2VyIHpyZW5kZXIgZXZlbnQgdG8gYXZvaWQgbW91c2VcbiAgICAgICAgLy8gaW4gYW5kIG91dCBzaGFwZSB0b28gZnJlcXVlbnRseVxuICAgICAgICB2YXIgaGFuZGxlciA9IHpyLmhhbmRsZXI7XG4gICAgICAgIHZhciB6clZpZXdwb3J0Um9vdCA9IHpyLnBhaW50ZXIuZ2V0Vmlld3BvcnRSb290KCk7XG4gICAgICAgIG5vcm1hbGl6ZUV2ZW50KHpyVmlld3BvcnRSb290LCBlLCB0cnVlKTtcbiAgICAgICAgaGFuZGxlci5kaXNwYXRjaCgnbW91c2Vtb3ZlJywgZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGVsLm9ubW91c2VsZWF2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHNldCBgX2luQ29udGVudGAgdG8gYGZhbHNlYCBiZWZvcmUgYGhpZGVMYXRlcmBcbiAgICAgIHNlbGYuX2luQ29udGVudCA9IGZhbHNlO1xuXG4gICAgICBpZiAoc2VsZi5fZW50ZXJhYmxlKSB7XG4gICAgICAgIGlmIChzZWxmLl9zaG93KSB7XG4gICAgICAgICAgc2VsZi5oaWRlTGF0ZXIoc2VsZi5faGlkZURlbGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB3aGVuIHRvb2x0aXAgaXMgcmVuZGVyZWRcbiAgICovXG5cblxuICBUb29sdGlwSFRNTENvbnRlbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwpIHtcbiAgICAvLyBGSVhNRVxuICAgIC8vIE1vdmUgdGhpcyBsb2dpYyB0byBlYyBtYWluP1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG4gICAgdmFyIHN0bCA9IGNvbnRhaW5lci5jdXJyZW50U3R5bGUgfHwgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgIHZhciBkb21TdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcblxuICAgIGlmIChkb21TdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBzdGwucG9zaXRpb24gIT09ICdhYnNvbHV0ZScpIHtcbiAgICAgIGRvbVN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB9IC8vIG1vdmUgdG9vbHRpcCBpZiBjaGFydCByZXNpemVkXG5cblxuICAgIHZhciBhbHdheXNTaG93Q29udGVudCA9IHRvb2x0aXBNb2RlbC5nZXQoJ2Fsd2F5c1Nob3dDb250ZW50Jyk7XG4gICAgYWx3YXlzU2hvd0NvbnRlbnQgJiYgdGhpcy5fbW92ZUlmUmVzaXplZCgpOyAvLyB1cGRhdGUgY2xhc3NOYW1lXG5cbiAgICB0aGlzLmVsLmNsYXNzTmFtZSA9IHRvb2x0aXBNb2RlbC5nZXQoJ2NsYXNzTmFtZScpIHx8ICcnOyAvLyBIaWRlIHRoZSB0b29sdGlwXG4gICAgLy8gUEVORElOR1xuICAgIC8vIHRoaXMuaGlkZSgpO1xuICB9O1xuXG4gIFRvb2x0aXBIVE1MQ29udGVudC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIG5lYXJQb2ludENvbG9yKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hpZGVUaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fbG9uZ0hpZGVUaW1lb3V0KTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBzdHlsZUNvb3JkID0gdGhpcy5fc3R5bGVDb29yZDtcbiAgICB2YXIgb2Zmc2V0ID0gZWwub2Zmc2V0SGVpZ2h0IC8gMjtcbiAgICBuZWFyUG9pbnRDb2xvciA9IGNvbnZlcnRUb0NvbG9yU3RyaW5nKG5lYXJQb2ludENvbG9yKTtcbiAgICBlbC5zdHlsZS5jc3NUZXh0ID0gZ0Nzc1RleHQgKyBhc3NlbWJsZUNzc1RleHQodG9vbHRpcE1vZGVsLCAhdGhpcy5fZmlyc3RTaG93LCB0aGlzLl9sb25nSGlkZSkgLy8gQmVjYXVzZSBvZiB0aGUgcmVhc29uIGRlc2NyaWJlZCBpbjpcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxMTI1NTg3L2NzczMtdHJhbnNpdGlvbi1ub3Qtd29ya2luZy1pbi1jaHJvbWUtYW55bW9yZVxuICAgIC8vIHdlIHNob3VsZCBzZXQgaW5pdGlhbCB2YWx1ZSB0byBgbGVmdGAgYW5kIGB0b3BgLlxuICAgICsgJztsZWZ0OicgKyBzdHlsZUNvb3JkWzBdICsgJ3B4O3RvcDonICsgKHN0eWxlQ29vcmRbMV0gLSBvZmZzZXQpICsgJ3B4OycgKyAoXCJib3JkZXItY29sb3I6IFwiICsgbmVhclBvaW50Q29sb3IgKyBcIjtcIikgKyAodG9vbHRpcE1vZGVsLmdldCgnZXh0cmFDc3NUZXh0JykgfHwgJycpO1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5pbm5lckhUTUwgPyAnYmxvY2snIDogJ25vbmUnOyAvLyBJZiBtb3VzZSBvY2Nhc2lvbmFsbHkgbW92ZSBvdmVyIHRoZSB0b29sdGlwLCBhIG1vdXNlb3V0IGV2ZW50IHdpbGwgYmVcbiAgICAvLyB0cmlnZ2VyZWQgYnkgY2FudmFzLCBhbmQgY2F1c2Ugc29tZSB1bmV4cGVjdGFibGUgcmVzdWx0IGxpa2UgZHJhZ2dpbmdcbiAgICAvLyBzdG9wLCBcInVuZm9jdXNBZGphY2VuY3lcIi4gSGVyZSBgcG9pbnRlci1ldmVudHM6IG5vbmVgIGlzIHVzZWQgdG8gc29sdmVcbiAgICAvLyBpdC4gQWx0aG91Z2ggaXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRTh+SUUxMCwgZm9ydHVuYXRlbHkgaXQgaXMgYSByYXJlXG4gICAgLy8gc2NlbmFyaW8uXG5cbiAgICBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gdGhpcy5fZW50ZXJhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgIHRoaXMuX3Nob3cgPSB0cnVlO1xuICAgIHRoaXMuX2ZpcnN0U2hvdyA9IGZhbHNlO1xuICAgIHRoaXMuX2xvbmdIaWRlID0gZmFsc2U7XG4gIH07XG5cbiAgVG9vbHRpcEhUTUxDb250ZW50LnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQsIG1hcmtlcnMsIHRvb2x0aXBNb2RlbCwgYm9yZGVyQ29sb3IsIGFycm93UG9zaXRpb24pIHtcbiAgICBpZiAoY29udGVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgIGlmIChpc1N0cmluZyhhcnJvd1Bvc2l0aW9uKSAmJiB0b29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyJykgPT09ICdpdGVtJyAmJiAhc2hvdWxkVG9vbHRpcENvbmZpbmUodG9vbHRpcE1vZGVsKSkge1xuICAgICAgY29udGVudCArPSBhc3NlbWJsZUFycm93KHRvb2x0aXBNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpLCBib3JkZXJDb2xvciwgYXJyb3dQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKGNvbnRlbnQpKSB7XG4gICAgICBlbC5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgIH0gZWxzZSBpZiAoY29udGVudCkge1xuICAgICAgLy8gQ2xlYXIgcHJldmlvdXNcbiAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xuXG4gICAgICBpZiAoIWlzQXJyYXkoY29udGVudCkpIHtcbiAgICAgICAgY29udGVudCA9IFtjb250ZW50XTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc0RvbShjb250ZW50W2ldKSAmJiBjb250ZW50W2ldLnBhcmVudE5vZGUgIT09IGVsKSB7XG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoY29udGVudFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgVG9vbHRpcEhUTUxDb250ZW50LnByb3RvdHlwZS5zZXRFbnRlcmFibGUgPSBmdW5jdGlvbiAoZW50ZXJhYmxlKSB7XG4gICAgdGhpcy5fZW50ZXJhYmxlID0gZW50ZXJhYmxlO1xuICB9O1xuXG4gIFRvb2x0aXBIVE1MQ29udGVudC5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHJldHVybiBbZWwuY2xpZW50V2lkdGgsIGVsLmNsaWVudEhlaWdodF07XG4gIH07XG5cbiAgVG9vbHRpcEhUTUxDb250ZW50LnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoenJYLCB6clkpIHtcbiAgICB2YXIgc3R5bGVDb29yZCA9IHRoaXMuX3N0eWxlQ29vcmQ7XG4gICAgbWFrZVN0eWxlQ29vcmQoc3R5bGVDb29yZCwgdGhpcy5fenIsIHRoaXMuX2FwcGVuZFRvQm9keSwgenJYLCB6clkpO1xuXG4gICAgaWYgKHN0eWxlQ29vcmRbMF0gIT0gbnVsbCAmJiBzdHlsZUNvb3JkWzFdICE9IG51bGwpIHtcbiAgICAgIHZhciBzdHlsZSA9IHRoaXMuZWwuc3R5bGU7IC8vIElmIHVzaW5nIGZsb2F0IG9uIHN0eWxlLCB0aGUgZmluYWwgd2lkdGggb2YgdGhlIGRvbSBtaWdodFxuICAgICAgLy8ga2VlcCBjaGFuZ2luZyBzbGlnaHRseSB3aGlsZSBtb3VzZSBtb3ZlLiBTbyBgdG9GaXhlZCgwKWAgdGhlbS5cblxuICAgICAgc3R5bGUubGVmdCA9IHN0eWxlQ29vcmRbMF0udG9GaXhlZCgwKSArICdweCc7XG4gICAgICBzdHlsZS50b3AgPSBzdHlsZUNvb3JkWzFdLnRvRml4ZWQoMCkgKyAncHgnO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIHdoZW4gYGFsd2F5c1Nob3dDb250ZW50YCBpcyB0cnVlLFxuICAgKiBtb3ZlIHRoZSB0b29sdGlwIGFmdGVyIGNoYXJ0IHJlc2l6ZWRcbiAgICovXG5cblxuICBUb29sdGlwSFRNTENvbnRlbnQucHJvdG90eXBlLl9tb3ZlSWZSZXNpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoZSByYXRpbyBvZiBsZWZ0IHRvIHdpZHRoXG4gICAgdmFyIHJhdGlvWCA9IHRoaXMuX3N0eWxlQ29vcmRbMl07IC8vIFRoZSByYXRpbyBvZiB0b3AgdG8gaGVpZ2h0XG5cbiAgICB2YXIgcmF0aW9ZID0gdGhpcy5fc3R5bGVDb29yZFszXTtcbiAgICB0aGlzLm1vdmVUbyhyYXRpb1ggKiB0aGlzLl96ci5nZXRXaWR0aCgpLCByYXRpb1kgKiB0aGlzLl96ci5nZXRIZWlnaHQoKSk7XG4gIH07XG5cbiAgVG9vbHRpcEhUTUxDb250ZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICB0aGlzLmVsLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuICAgIHRoaXMuX2xvbmdIaWRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLl9sb25nSGlkZSA9IHRydWU7XG4gICAgfSwgNTAwKTtcbiAgfTtcblxuICBUb29sdGlwSFRNTENvbnRlbnQucHJvdG90eXBlLmhpZGVMYXRlciA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgaWYgKHRoaXMuX3Nob3cgJiYgISh0aGlzLl9pbkNvbnRlbnQgJiYgdGhpcy5fZW50ZXJhYmxlKSkge1xuICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgdGhpcy5faGlkZURlbGF5ID0gdGltZTsgLy8gU2V0IHNob3cgZmFsc2UgdG8gYXZvaWQgaW52b2tlIGhpZGVMYXRlciBtdWx0aXBsZSB0aW1lc1xuXG4gICAgICAgIHRoaXMuX3Nob3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQodGhpcy5oaWRlLCB0aGlzKSwgdGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgVG9vbHRpcEhUTUxDb250ZW50LnByb3RvdHlwZS5pc1Nob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nob3c7XG4gIH07XG5cbiAgVG9vbHRpcEhUTUxDb250ZW50LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgfTtcblxuICBUb29sdGlwSFRNTENvbnRlbnQucHJvdG90eXBlLmdldE91dGVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgd2lkdGggPSB0aGlzLmVsLmNsaWVudFdpZHRoO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmVsLmNsaWVudEhlaWdodDsgLy8gQ29uc2lkZXIgYnJvd3NlciBjb21wYXRpYmlsaXR5LlxuICAgIC8vIElFOCBkb2VzIG5vdCBzdXBwb3J0IGdldENvbXB1dGVkU3R5bGUuXG5cbiAgICBpZiAoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbCk7XG5cbiAgICAgIGlmIChzdGwpIHtcbiAgICAgICAgd2lkdGggKz0gcGFyc2VJbnQoc3RsLmJvcmRlckxlZnRXaWR0aCwgMTApICsgcGFyc2VJbnQoc3RsLmJvcmRlclJpZ2h0V2lkdGgsIDEwKTtcbiAgICAgICAgaGVpZ2h0ICs9IHBhcnNlSW50KHN0bC5ib3JkZXJUb3BXaWR0aCwgMTApICsgcGFyc2VJbnQoc3RsLmJvcmRlckJvdHRvbVdpZHRoLCAxMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gVG9vbHRpcEhUTUxDb250ZW50O1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBUb29sdGlwSFRNTENvbnRlbnQ7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IENvbXBvbmVudE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL0NvbXBvbmVudCc7XG5cbnZhciBUb29sdGlwTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVG9vbHRpcE1vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFRvb2x0aXBNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBUb29sdGlwTW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUb29sdGlwTW9kZWwudHlwZSA9ICd0b29sdGlwJztcbiAgVG9vbHRpcE1vZGVsLmRlcGVuZGVuY2llcyA9IFsnYXhpc1BvaW50ZXInXTtcbiAgVG9vbHRpcE1vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgemxldmVsOiAwLFxuICAgIHo6IDYwLFxuICAgIHNob3c6IHRydWUsXG4gICAgLy8gdG9vbHRpcCBtYWluIGNvbnRlbnRcbiAgICBzaG93Q29udGVudDogdHJ1ZSxcbiAgICAvLyAndHJpZ2dlcicgb25seSB3b3JrcyBvbiBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAvLyAnaXRlbScgfCAnYXhpcycgfCAnbm9uZSdcbiAgICB0cmlnZ2VyOiAnaXRlbScsXG4gICAgLy8gJ2NsaWNrJyB8ICdtb3VzZW1vdmUnIHwgJ25vbmUnXG4gICAgdHJpZ2dlck9uOiAnbW91c2Vtb3ZlfGNsaWNrJyxcbiAgICBhbHdheXNTaG93Q29udGVudDogZmFsc2UsXG4gICAgZGlzcGxheU1vZGU6ICdzaW5nbGUnLFxuICAgIHJlbmRlck1vZGU6ICdhdXRvJyxcbiAgICAvLyB3aGV0aGVyIHJlc3RyYWludCBjb250ZW50IGluc2lkZSB2aWV3UmVjdC5cbiAgICAvLyBJZiByZW5kZXJNb2RlOiAncmljaFRleHQnLCBkZWZhdWx0IHRydWUuXG4gICAgLy8gSWYgcmVuZGVyTW9kZTogJ2h0bWwnLCBkZWZhdXQgZmFsc2UgKGZvciBiYWNrd2FyZCBjb21wYXQpLlxuICAgIGNvbmZpbmU6IG51bGwsXG4gICAgc2hvd0RlbGF5OiAwLFxuICAgIGhpZGVEZWxheTogMTAwLFxuICAgIC8vIEFuaW1hdGlvbiB0cmFuc2l0aW9uIHRpbWUsIHVuaXQgaXMgc2Vjb25kXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAwLjQsXG4gICAgZW50ZXJhYmxlOiBmYWxzZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZmJyxcbiAgICAvLyBib3ggc2hhZG93XG4gICAgc2hhZG93Qmx1cjogMTAsXG4gICAgc2hhZG93Q29sb3I6ICdyZ2JhKDAsIDAsIDAsIC4yKScsXG4gICAgc2hhZG93T2Zmc2V0WDogMSxcbiAgICBzaGFkb3dPZmZzZXRZOiAyLFxuICAgIC8vIHRvb2x0aXAgYm9yZGVyIHJhZGl1cywgdW5pdCBpcyBweCwgZGVmYXVsdCBpcyA0XG4gICAgYm9yZGVyUmFkaXVzOiA0LFxuICAgIC8vIHRvb2x0aXAgYm9yZGVyIHdpZHRoLCB1bml0IGlzIHB4LCBkZWZhdWx0IGlzIDAgKG5vIGJvcmRlcilcbiAgICBib3JkZXJXaWR0aDogMSxcbiAgICAvLyBUb29sdGlwIGluc2lkZSBwYWRkaW5nLCBkZWZhdWx0IGlzIDUgZm9yIGFsbCBkaXJlY3Rpb25cbiAgICAvLyBBcnJheSBpcyBhbGxvd2VkIHRvIHNldCB1cCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgc2FtZSB3aXRoIGNzc1xuICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlOiBTZWUgYHRvb2x0aXAvdG9vbHRpcE1hcmt1cC50cyNnZXRQYWRkaW5nRnJvbVRvb2x0aXBNb2RlbGAuXG4gICAgcGFkZGluZzogbnVsbCxcbiAgICAvLyBFeHRyYSBjc3MgdGV4dFxuICAgIGV4dHJhQ3NzVGV4dDogJycsXG4gICAgLy8gYXhpcyBpbmRpY2F0b3IsIHRyaWdnZXIgYnkgYXhpc1xuICAgIGF4aXNQb2ludGVyOiB7XG4gICAgICAvLyBkZWZhdWx0IGlzIGxpbmVcbiAgICAgIC8vIGxlZ2FsIHZhbHVlczogJ2xpbmUnIHwgJ3NoYWRvdycgfCAnY3Jvc3MnXG4gICAgICB0eXBlOiAnbGluZScsXG4gICAgICAvLyBWYWxpZCB3aGVuIHR5cGUgaXMgbGluZSwgYXBwb2ludCB0b29sdGlwIGxpbmUgbG9jYXRlIG9uIHdoaWNoIGxpbmUuIE9wdGlvbmFsXG4gICAgICAvLyBsZWdhbCB2YWx1ZXM6ICd4JyB8ICd5JyB8ICdhbmdsZScgfCAncmFkaXVzJyB8ICdhdXRvJ1xuICAgICAgLy8gZGVmYXVsdCBpcyAnYXV0bycsIGNob3NlIHRoZSBheGlzIHdoaWNoIHR5cGUgaXMgY2F0ZWdvcnkuXG4gICAgICAvLyBmb3IgbXVsdGlwbHkgeSBheGlzLCBjYXJ0ZXNpYW4gY29vcmQgY2hvc2UgeCBheGlzLCBwb2xhciBjaG9zZSBhbmdsZSBheGlzXG4gICAgICBheGlzOiAnYXV0bycsXG4gICAgICBhbmltYXRpb246ICdhdXRvJyxcbiAgICAgIGFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlOiAyMDAsXG4gICAgICBhbmltYXRpb25FYXNpbmdVcGRhdGU6ICdleHBvbmVudGlhbE91dCcsXG4gICAgICBjcm9zc1N0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAnIzk5OScsXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICB0eXBlOiAnZGFzaGVkJyxcbiAgICAgICAgLy8gVE9ETyBmb3JtYXR0ZXJcbiAgICAgICAgdGV4dFN0eWxlOiB7fVxuICAgICAgfSAvLyBsaW5lU3R5bGUgYW5kIHNoYWRvd1N0eWxlIHNob3VsZCBub3QgYmUgc3BlY2lmaWVkIGhlcmUsXG4gICAgICAvLyBvdGhlcndpc2UgaXQgd2lsbCBhbHdheXMgb3ZlcnJpZGUgdGhvc2Ugc3R5bGVzIG9uIG9wdGlvbi5heGlzUG9pbnRlci5cblxuICAgIH0sXG4gICAgdGV4dFN0eWxlOiB7XG4gICAgICBjb2xvcjogJyM2NjYnLFxuICAgICAgZm9udFNpemU6IDE0XG4gICAgfVxuICB9O1xuICByZXR1cm4gVG9vbHRpcE1vZGVsO1xufShDb21wb25lbnRNb2RlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IFRvb2x0aXBNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgWlJUZXh0IGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dCc7XG5pbXBvcnQgeyBnZXRQYWRkaW5nRnJvbVRvb2x0aXBNb2RlbCB9IGZyb20gJy4vdG9vbHRpcE1hcmt1cCc7XG5pbXBvcnQgeyB0aHJvd0Vycm9yIH0gZnJvbSAnLi4vLi4vdXRpbC9sb2cnO1xuXG52YXIgVG9vbHRpcFJpY2hDb250ZW50ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVG9vbHRpcFJpY2hDb250ZW50KGFwaSkge1xuICAgIHRoaXMuX3Nob3cgPSBmYWxzZTtcbiAgICB0aGlzLl9zdHlsZUNvb3JkID0gWzAsIDAsIDAsIDBdO1xuICAgIHRoaXMuX2VudGVyYWJsZSA9IHRydWU7XG4gICAgdGhpcy5fenIgPSBhcGkuZ2V0WnIoKTtcbiAgICBtYWtlU3R5bGVDb29yZCh0aGlzLl9zdHlsZUNvb3JkLCB0aGlzLl96ciwgYXBpLmdldFdpZHRoKCkgLyAyLCBhcGkuZ2V0SGVpZ2h0KCkgLyAyKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHdoZW4gdG9vbHRpcCBpcyByZW5kZXJlZFxuICAgKi9cblxuXG4gIFRvb2x0aXBSaWNoQ29udGVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCkge1xuICAgIHZhciBhbHdheXNTaG93Q29udGVudCA9IHRvb2x0aXBNb2RlbC5nZXQoJ2Fsd2F5c1Nob3dDb250ZW50Jyk7XG4gICAgYWx3YXlzU2hvd0NvbnRlbnQgJiYgdGhpcy5fbW92ZUlmUmVzaXplZCgpO1xuICB9O1xuXG4gIFRvb2x0aXBSaWNoQ29udGVudC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5faGlkZVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZW91dCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbC5zaG93KCk7XG4gICAgdGhpcy5fc2hvdyA9IHRydWU7XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgdG9vbHRpcCBjb250ZW50XG4gICAqL1xuXG5cbiAgVG9vbHRpcFJpY2hDb250ZW50LnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQsIG1hcmt1cFN0eWxlQ3JlYXRvciwgdG9vbHRpcE1vZGVsLCBib3JkZXJDb2xvciwgYXJyb3dQb3NpdGlvbikge1xuICAgIGlmICh6clV0aWwuaXNPYmplY3QoY29udGVudCkpIHtcbiAgICAgIHRocm93RXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICdQYXNzaW5nIERPTSBub2RlcyBhcyBjb250ZW50IGlzIG5vdCBzdXBwb3J0ZWQgaW4gcmljaFRleHQgdG9vbHRpcCEnIDogJycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsKSB7XG4gICAgICB0aGlzLl96ci5yZW1vdmUodGhpcy5lbCk7XG4gICAgfVxuXG4gICAgdmFyIHRleHRTdHlsZU1vZGVsID0gdG9vbHRpcE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICB0aGlzLmVsID0gbmV3IFpSVGV4dCh7XG4gICAgICBzdHlsZToge1xuICAgICAgICByaWNoOiBtYXJrdXBTdHlsZUNyZWF0b3IucmljaFRleHRTdHlsZXMsXG4gICAgICAgIHRleHQ6IGNvbnRlbnQsXG4gICAgICAgIGxpbmVIZWlnaHQ6IDIyLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRvb2x0aXBNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpLFxuICAgICAgICBib3JkZXJSYWRpdXM6IHRvb2x0aXBNb2RlbC5nZXQoJ2JvcmRlclJhZGl1cycpLFxuICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgYm9yZGVyQ29sb3I6IGJvcmRlckNvbG9yLFxuICAgICAgICBzaGFkb3dDb2xvcjogdG9vbHRpcE1vZGVsLmdldCgnc2hhZG93Q29sb3InKSxcbiAgICAgICAgc2hhZG93Qmx1cjogdG9vbHRpcE1vZGVsLmdldCgnc2hhZG93Qmx1cicpLFxuICAgICAgICBzaGFkb3dPZmZzZXRYOiB0b29sdGlwTW9kZWwuZ2V0KCdzaGFkb3dPZmZzZXRYJyksXG4gICAgICAgIHNoYWRvd09mZnNldFk6IHRvb2x0aXBNb2RlbC5nZXQoJ3NoYWRvd09mZnNldFknKSxcbiAgICAgICAgdGV4dFNoYWRvd0NvbG9yOiB0ZXh0U3R5bGVNb2RlbC5nZXQoJ3RleHRTaGFkb3dDb2xvcicpLFxuICAgICAgICB0ZXh0U2hhZG93Qmx1cjogdGV4dFN0eWxlTW9kZWwuZ2V0KCd0ZXh0U2hhZG93Qmx1cicpIHx8IDAsXG4gICAgICAgIHRleHRTaGFkb3dPZmZzZXRYOiB0ZXh0U3R5bGVNb2RlbC5nZXQoJ3RleHRTaGFkb3dPZmZzZXRYJykgfHwgMCxcbiAgICAgICAgdGV4dFNoYWRvd09mZnNldFk6IHRleHRTdHlsZU1vZGVsLmdldCgndGV4dFNoYWRvd09mZnNldFknKSB8fCAwLFxuICAgICAgICBmaWxsOiB0b29sdGlwTW9kZWwuZ2V0KFsndGV4dFN0eWxlJywgJ2NvbG9yJ10pLFxuICAgICAgICBwYWRkaW5nOiBnZXRQYWRkaW5nRnJvbVRvb2x0aXBNb2RlbCh0b29sdGlwTW9kZWwsICdyaWNoVGV4dCcpLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcbiAgICAgICAgYWxpZ246ICdsZWZ0J1xuICAgICAgfSxcbiAgICAgIHo6IHRvb2x0aXBNb2RlbC5nZXQoJ3onKVxuICAgIH0pO1xuXG4gICAgdGhpcy5fenIuYWRkKHRoaXMuZWwpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZWwub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGNsZWFyIHRoZSB0aW1lb3V0IGluIGhpZGVMYXRlciBhbmQga2VlcCBzaG93aW5nIHRvb2x0aXBcbiAgICAgIGlmIChzZWxmLl9lbnRlcmFibGUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX2hpZGVUaW1lb3V0KTtcbiAgICAgICAgc2VsZi5fc2hvdyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX2luQ29udGVudCA9IHRydWU7XG4gICAgfSk7XG4gICAgdGhpcy5lbC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5fZW50ZXJhYmxlKSB7XG4gICAgICAgIGlmIChzZWxmLl9zaG93KSB7XG4gICAgICAgICAgc2VsZi5oaWRlTGF0ZXIoc2VsZi5faGlkZURlbGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLl9pbkNvbnRlbnQgPSBmYWxzZTtcbiAgICB9KTtcbiAgfTtcblxuICBUb29sdGlwUmljaENvbnRlbnQucHJvdG90eXBlLnNldEVudGVyYWJsZSA9IGZ1bmN0aW9uIChlbnRlcmFibGUpIHtcbiAgICB0aGlzLl9lbnRlcmFibGUgPSBlbnRlcmFibGU7XG4gIH07XG5cbiAgVG9vbHRpcFJpY2hDb250ZW50LnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIGJvdW5kaW5nID0gdGhpcy5lbC5nZXRCb3VuZGluZ1JlY3QoKTsgLy8gYm91bmRpbmcgcmVjdCBkb2VzIG5vdCBpbmNsdWRlIHNoYWRvdy4gRm9yIHJlbmRlck1vZGUgcmljaFRleHQsXG4gICAgLy8gaWYgb3ZlcmZsb3csIGl0IHdpbGwgYmUgY3V0LiBTbyBjYWxjdWxhdGUgdGhlbSBhY2N1cmF0ZWx5LlxuXG4gICAgdmFyIHNoYWRvd091dGVyU2l6ZSA9IGNhbGNTaGFkb3dPdXRlclNpemUoZWwuc3R5bGUpO1xuICAgIHJldHVybiBbYm91bmRpbmcud2lkdGggKyBzaGFkb3dPdXRlclNpemUubGVmdCArIHNoYWRvd091dGVyU2l6ZS5yaWdodCwgYm91bmRpbmcuaGVpZ2h0ICsgc2hhZG93T3V0ZXJTaXplLnRvcCArIHNoYWRvd091dGVyU2l6ZS5ib3R0b21dO1xuICB9O1xuXG4gIFRvb2x0aXBSaWNoQ29udGVudC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICB2YXIgc3R5bGVDb29yZCA9IHRoaXMuX3N0eWxlQ29vcmQ7XG4gICAgICBtYWtlU3R5bGVDb29yZChzdHlsZUNvb3JkLCB0aGlzLl96ciwgeCwgeSk7XG4gICAgICB4ID0gc3R5bGVDb29yZFswXTtcbiAgICAgIHkgPSBzdHlsZUNvb3JkWzFdO1xuICAgICAgdmFyIHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSBtYXRoTWF4V2l0aDAoc3R5bGUuYm9yZGVyV2lkdGggfHwgMCk7XG4gICAgICB2YXIgc2hhZG93T3V0ZXJTaXplID0gY2FsY1NoYWRvd091dGVyU2l6ZShzdHlsZSk7IC8vIHJpY2ggdGV4dCB4LCB5IGRvIG5vdCBpbmNsdWRlIGJvcmRlci5cblxuICAgICAgZWwueCA9IHggKyBib3JkZXJXaWR0aCArIHNoYWRvd091dGVyU2l6ZS5sZWZ0O1xuICAgICAgZWwueSA9IHkgKyBib3JkZXJXaWR0aCArIHNoYWRvd091dGVyU2l6ZS50b3A7XG4gICAgICBlbC5tYXJrUmVkcmF3KCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogd2hlbiBgYWx3YXlzU2hvd0NvbnRlbnRgIGlzIHRydWUsXG4gICAqIG1vdmUgdGhlIHRvb2x0aXAgYWZ0ZXIgY2hhcnQgcmVzaXplZFxuICAgKi9cblxuXG4gIFRvb2x0aXBSaWNoQ29udGVudC5wcm90b3R5cGUuX21vdmVJZlJlc2l6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhlIHJhdGlvIG9mIGxlZnQgdG8gd2lkdGhcbiAgICB2YXIgcmF0aW9YID0gdGhpcy5fc3R5bGVDb29yZFsyXTsgLy8gVGhlIHJhdGlvIG9mIHRvcCB0byBoZWlnaHRcblxuICAgIHZhciByYXRpb1kgPSB0aGlzLl9zdHlsZUNvb3JkWzNdO1xuICAgIHRoaXMubW92ZVRvKHJhdGlvWCAqIHRoaXMuX3pyLmdldFdpZHRoKCksIHJhdGlvWSAqIHRoaXMuX3pyLmdldEhlaWdodCgpKTtcbiAgfTtcblxuICBUb29sdGlwUmljaENvbnRlbnQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZWwpIHtcbiAgICAgIHRoaXMuZWwuaGlkZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3Nob3cgPSBmYWxzZTtcbiAgfTtcblxuICBUb29sdGlwUmljaENvbnRlbnQucHJvdG90eXBlLmhpZGVMYXRlciA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgaWYgKHRoaXMuX3Nob3cgJiYgISh0aGlzLl9pbkNvbnRlbnQgJiYgdGhpcy5fZW50ZXJhYmxlKSkge1xuICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgdGhpcy5faGlkZURlbGF5ID0gdGltZTsgLy8gU2V0IHNob3cgZmFsc2UgdG8gYXZvaWQgaW52b2tlIGhpZGVMYXRlciBtdWx0aXBsZSB0aW1lc1xuXG4gICAgICAgIHRoaXMuX3Nob3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHpyVXRpbC5iaW5kKHRoaXMuaGlkZSwgdGhpcyksIHRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFRvb2x0aXBSaWNoQ29udGVudC5wcm90b3R5cGUuaXNTaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zaG93O1xuICB9O1xuXG4gIFRvb2x0aXBSaWNoQ29udGVudC5wcm90b3R5cGUuZ2V0T3V0ZXJTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBzaXplWzBdLFxuICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgfTtcbiAgfTtcblxuICBUb29sdGlwUmljaENvbnRlbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fenIucmVtb3ZlKHRoaXMuZWwpO1xuICB9O1xuXG4gIHJldHVybiBUb29sdGlwUmljaENvbnRlbnQ7XG59KCk7XG5cbmZ1bmN0aW9uIG1hdGhNYXhXaXRoMCh2YWwpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIHZhbCk7XG59XG5cbmZ1bmN0aW9uIGNhbGNTaGFkb3dPdXRlclNpemUoc3R5bGUpIHtcbiAgdmFyIHNoYWRvd0JsdXIgPSBtYXRoTWF4V2l0aDAoc3R5bGUuc2hhZG93Qmx1ciB8fCAwKTtcbiAgdmFyIHNoYWRvd09mZnNldFggPSBtYXRoTWF4V2l0aDAoc3R5bGUuc2hhZG93T2Zmc2V0WCB8fCAwKTtcbiAgdmFyIHNoYWRvd09mZnNldFkgPSBtYXRoTWF4V2l0aDAoc3R5bGUuc2hhZG93T2Zmc2V0WSB8fCAwKTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBtYXRoTWF4V2l0aDAoc2hhZG93Qmx1ciAtIHNoYWRvd09mZnNldFgpLFxuICAgIHJpZ2h0OiBtYXRoTWF4V2l0aDAoc2hhZG93Qmx1ciArIHNoYWRvd09mZnNldFgpLFxuICAgIHRvcDogbWF0aE1heFdpdGgwKHNoYWRvd0JsdXIgLSBzaGFkb3dPZmZzZXRZKSxcbiAgICBib3R0b206IG1hdGhNYXhXaXRoMChzaGFkb3dCbHVyICsgc2hhZG93T2Zmc2V0WSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZVN0eWxlQ29vcmQob3V0LCB6ciwgenJYLCB6clkpIHtcbiAgb3V0WzBdID0genJYO1xuICBvdXRbMV0gPSB6clk7XG4gIG91dFsyXSA9IG91dFswXSAvIHpyLmdldFdpZHRoKCk7XG4gIG91dFszXSA9IG91dFsxXSAvIHpyLmdldEhlaWdodCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBUb29sdGlwUmljaENvbnRlbnQ7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBlbnYgZnJvbSAnenJlbmRlci9saWIvY29yZS9lbnYnO1xuaW1wb3J0IFRvb2x0aXBIVE1MQ29udGVudCBmcm9tICcuL1Rvb2x0aXBIVE1MQ29udGVudCc7XG5pbXBvcnQgVG9vbHRpcFJpY2hDb250ZW50IGZyb20gJy4vVG9vbHRpcFJpY2hDb250ZW50JztcbmltcG9ydCAqIGFzIGZvcm1hdFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9mb3JtYXQnO1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgZmluZFBvaW50RnJvbVNlcmllcyBmcm9tICcuLi9heGlzUG9pbnRlci9maW5kUG9pbnRGcm9tU2VyaWVzJztcbmltcG9ydCAqIGFzIGxheW91dFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQnO1xuaW1wb3J0IE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL01vZGVsJztcbmltcG9ydCAqIGFzIGdsb2JhbExpc3RlbmVyIGZyb20gJy4uL2F4aXNQb2ludGVyL2dsb2JhbExpc3RlbmVyJztcbmltcG9ydCAqIGFzIGF4aXNIZWxwZXIgZnJvbSAnLi4vLi4vY29vcmQvYXhpc0hlbHBlcic7XG5pbXBvcnQgKiBhcyBheGlzUG9pbnRlclZpZXdIZWxwZXIgZnJvbSAnLi4vYXhpc1BvaW50ZXIvdmlld0hlbHBlcic7XG5pbXBvcnQgeyBnZXRUb29sdGlwUmVuZGVyTW9kZSB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwnO1xuaW1wb3J0IENvbXBvbmVudFZpZXcgZnJvbSAnLi4vLi4vdmlldy9Db21wb25lbnQnO1xuaW1wb3J0IHsgZm9ybWF0IGFzIHRpbWVGb3JtYXQgfSBmcm9tICcuLi8uLi91dGlsL3RpbWUnOyAvLyBpbXBvcnQgeyBpc0RpbWVuc2lvblN0YWNrZWQgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9kYXRhU3RhY2tIZWxwZXInO1xuXG5pbXBvcnQgeyBnZXRFQ0RhdGEgfSBmcm9tICcuLi8uLi91dGlsL2lubmVyU3RvcmUnO1xuaW1wb3J0IHsgc2hvdWxkVG9vbHRpcENvbmZpbmUgfSBmcm9tICcuL2hlbHBlcic7XG5pbXBvcnQgeyBub3JtYWxpemVUb29sdGlwRm9ybWF0UmVzdWx0IH0gZnJvbSAnLi4vLi4vbW9kZWwvbWl4aW4vZGF0YUZvcm1hdCc7XG5pbXBvcnQgeyBjcmVhdGVUb29sdGlwTWFya3VwLCBidWlsZFRvb2x0aXBNYXJrdXAsIFRvb2x0aXBNYXJrdXBTdHlsZUNyZWF0b3IgfSBmcm9tICcuL3Rvb2x0aXBNYXJrdXAnO1xuaW1wb3J0IHsgZmluZEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4uLy4uL3V0aWwvZXZlbnQnO1xudmFyIGJpbmQgPSB6clV0aWwuYmluZDtcbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgcGFyc2VQZXJjZW50ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQ7XG52YXIgcHJveHlSZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gIHNoYXBlOiB7XG4gICAgeDogLTEsXG4gICAgeTogLTEsXG4gICAgd2lkdGg6IDIsXG4gICAgaGVpZ2h0OiAyXG4gIH1cbn0pO1xuXG52YXIgVG9vbHRpcFZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVG9vbHRpcFZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gVG9vbHRpcFZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gVG9vbHRpcFZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUb29sdGlwVmlldy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdG9vbHRpcE1vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ3Rvb2x0aXAnKTtcbiAgICB2YXIgcmVuZGVyTW9kZSA9IHRvb2x0aXBNb2RlbC5nZXQoJ3JlbmRlck1vZGUnKTtcbiAgICB0aGlzLl9yZW5kZXJNb2RlID0gZ2V0VG9vbHRpcFJlbmRlck1vZGUocmVuZGVyTW9kZSk7XG4gICAgdGhpcy5fdG9vbHRpcENvbnRlbnQgPSB0aGlzLl9yZW5kZXJNb2RlID09PSAncmljaFRleHQnID8gbmV3IFRvb2x0aXBSaWNoQ29udGVudChhcGkpIDogbmV3IFRvb2x0aXBIVE1MQ29udGVudChhcGkuZ2V0RG9tKCksIGFwaSwge1xuICAgICAgYXBwZW5kVG9Cb2R5OiB0b29sdGlwTW9kZWwuZ2V0KCdhcHBlbmRUb0JvZHknLCB0cnVlKVxuICAgIH0pO1xuICB9O1xuXG4gIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFJlc2V0XG5cblxuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy5fdG9vbHRpcE1vZGVsID0gdG9vbHRpcE1vZGVsO1xuICAgIHRoaXMuX2VjTW9kZWwgPSBlY01vZGVsO1xuICAgIHRoaXMuX2FwaSA9IGFwaTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuXG4gICAgdGhpcy5fYWx3YXlzU2hvd0NvbnRlbnQgPSB0b29sdGlwTW9kZWwuZ2V0KCdhbHdheXNTaG93Q29udGVudCcpO1xuICAgIHZhciB0b29sdGlwQ29udGVudCA9IHRoaXMuX3Rvb2x0aXBDb250ZW50O1xuICAgIHRvb2x0aXBDb250ZW50LnVwZGF0ZSh0b29sdGlwTW9kZWwpO1xuICAgIHRvb2x0aXBDb250ZW50LnNldEVudGVyYWJsZSh0b29sdGlwTW9kZWwuZ2V0KCdlbnRlcmFibGUnKSk7XG5cbiAgICB0aGlzLl9pbml0R2xvYmFsTGlzdGVuZXIoKTtcblxuICAgIHRoaXMuX2tlZXBTaG93KCk7XG4gIH07XG5cbiAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl9pbml0R2xvYmFsTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRvb2x0aXBNb2RlbCA9IHRoaXMuX3Rvb2x0aXBNb2RlbDtcbiAgICB2YXIgdHJpZ2dlck9uID0gdG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlck9uJyk7XG4gICAgZ2xvYmFsTGlzdGVuZXIucmVnaXN0ZXIoJ2l0ZW1Ub29sdGlwJywgdGhpcy5fYXBpLCBiaW5kKGZ1bmN0aW9uIChjdXJyVHJpZ2dlciwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgIC8vIElmICdub25lJywgaXQgaXMgbm90IGNvbnRyb2xsZWQgYnkgbW91c2UgdG90YWxseS5cbiAgICAgIGlmICh0cmlnZ2VyT24gIT09ICdub25lJykge1xuICAgICAgICBpZiAodHJpZ2dlck9uLmluZGV4T2YoY3VyclRyaWdnZXIpID49IDApIHtcbiAgICAgICAgICB0aGlzLl90cnlTaG93KGUsIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyVHJpZ2dlciA9PT0gJ2xlYXZlJykge1xuICAgICAgICAgIHRoaXMuX2hpZGUoZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcykpO1xuICB9O1xuXG4gIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5fa2VlcFNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRvb2x0aXBNb2RlbCA9IHRoaXMuX3Rvb2x0aXBNb2RlbDtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX2VjTW9kZWw7XG4gICAgdmFyIGFwaSA9IHRoaXMuX2FwaTsgLy8gVHJ5IHRvIGtlZXAgdGhlIHRvb2x0aXAgc2hvdyB3aGVuIHJlZnJlc2hpbmdcblxuICAgIGlmICh0aGlzLl9sYXN0WCAhPSBudWxsICYmIHRoaXMuX2xhc3RZICE9IG51bGwgLy8gV2hlbiB1c2VyIGlzIHdpbGxpbmcgdG8gY29udHJvbCB0b29sdGlwIHRvdGFsbHkgdXNpbmcgQVBJLFxuICAgIC8vIHNlbGYubWFudWFsbHlTaG93VGlwKHt4LCB5fSkgbWlnaHQgY2F1c2UgdG9vbHRpcCBoaWRlLFxuICAgIC8vIHdoaWNoIGlzIG5vdCBleHBlY3RlZC5cbiAgICAmJiB0b29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyT24nKSAhPT0gJ25vbmUnKSB7XG4gICAgICB2YXIgc2VsZl8xID0gdGhpcztcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoVXBkYXRlVGltZW91dCk7XG4gICAgICB0aGlzLl9yZWZyZXNoVXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBTaG93IHRpcCBuZXh0IHRpY2sgYWZ0ZXIgb3RoZXIgY2hhcnRzIGFyZSByZW5kZXJlZFxuICAgICAgICAvLyBJbiBjYXNlIGhpZ2hsaWdodCBhY3Rpb24gaGFzIHdyb25nIHJlc3VsdFxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAhYXBpLmlzRGlzcG9zZWQoKSAmJiBzZWxmXzEubWFudWFsbHlTaG93VGlwKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCB7XG4gICAgICAgICAgeDogc2VsZl8xLl9sYXN0WCxcbiAgICAgICAgICB5OiBzZWxmXzEuX2xhc3RZLFxuICAgICAgICAgIGRhdGFCeUNvb3JkU3lzOiBzZWxmXzEuX2xhc3REYXRhQnlDb29yZFN5c1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFNob3cgdGlwIG1hbnVhbGx5IGJ5XG4gICAqIGRpc3BhdGNoQWN0aW9uKHtcbiAgICogICAgIHR5cGU6ICdzaG93VGlwJyxcbiAgICogICAgIHg6IDEwLFxuICAgKiAgICAgeTogMTBcbiAgICogfSk7XG4gICAqIE9yXG4gICAqIGRpc3BhdGNoQWN0aW9uKHtcbiAgICogICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAqICAgICAgc2VyaWVzSW5kZXg6IDAsXG4gICAqICAgICAgZGF0YUluZGV4IG9yIGRhdGFJbmRleEluc2lkZSBvciBuYW1lXG4gICAqIH0pO1xuICAgKlxuICAgKiAgVE9ETyBCYXRjaFxuICAgKi9cblxuXG4gIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5tYW51YWxseVNob3dUaXAgPSBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICBpZiAocGF5bG9hZC5mcm9tID09PSB0aGlzLnVpZCB8fCBlbnYubm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkaXNwYXRjaEFjdGlvbiA9IG1ha2VEaXNwYXRjaEFjdGlvbihwYXlsb2FkLCBhcGkpOyAvLyBSZXNldCB0aWNrZXRcblxuICAgIHRoaXMuX3RpY2tldCA9ICcnOyAvLyBXaGVuIHRyaWdnZXJlZCBmcm9tIGF4aXNQb2ludGVyLlxuXG4gICAgdmFyIGRhdGFCeUNvb3JkU3lzID0gcGF5bG9hZC5kYXRhQnlDb29yZFN5cztcblxuICAgIGlmIChwYXlsb2FkLnRvb2x0aXAgJiYgcGF5bG9hZC54ICE9IG51bGwgJiYgcGF5bG9hZC55ICE9IG51bGwpIHtcbiAgICAgIHZhciBlbCA9IHByb3h5UmVjdDtcbiAgICAgIGVsLnggPSBwYXlsb2FkLng7XG4gICAgICBlbC55ID0gcGF5bG9hZC55O1xuICAgICAgZWwudXBkYXRlKCk7XG4gICAgICBlbC50b29sdGlwID0gcGF5bG9hZC50b29sdGlwOyAvLyBNYW51YWxseSBzaG93IHRvb2x0aXAgd2hpbGUgdmlldyBpcyBub3QgdXNpbmcgenJlbmRlciBlbGVtZW50cy5cblxuICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgIG9mZnNldFg6IHBheWxvYWQueCxcbiAgICAgICAgb2Zmc2V0WTogcGF5bG9hZC55LFxuICAgICAgICB0YXJnZXQ6IGVsXG4gICAgICB9LCBkaXNwYXRjaEFjdGlvbik7XG4gICAgfSBlbHNlIGlmIChkYXRhQnlDb29yZFN5cykge1xuICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgIG9mZnNldFg6IHBheWxvYWQueCxcbiAgICAgICAgb2Zmc2V0WTogcGF5bG9hZC55LFxuICAgICAgICBwb3NpdGlvbjogcGF5bG9hZC5wb3NpdGlvbixcbiAgICAgICAgZGF0YUJ5Q29vcmRTeXM6IGRhdGFCeUNvb3JkU3lzLFxuICAgICAgICB0b29sdGlwT3B0aW9uOiBwYXlsb2FkLnRvb2x0aXBPcHRpb25cbiAgICAgIH0sIGRpc3BhdGNoQWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWQuc2VyaWVzSW5kZXggIT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuX21hbnVhbGx5QXhpc1Nob3dUaXAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50SW5mbyA9IGZpbmRQb2ludEZyb21TZXJpZXMocGF5bG9hZCwgZWNNb2RlbCk7XG4gICAgICB2YXIgY3ggPSBwb2ludEluZm8ucG9pbnRbMF07XG4gICAgICB2YXIgY3kgPSBwb2ludEluZm8ucG9pbnRbMV07XG5cbiAgICAgIGlmIChjeCAhPSBudWxsICYmIGN5ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgICAgb2Zmc2V0WDogY3gsXG4gICAgICAgICAgb2Zmc2V0WTogY3ksXG4gICAgICAgICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb24sXG4gICAgICAgICAgdGFyZ2V0OiBwb2ludEluZm8uZWxcbiAgICAgICAgfSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF5bG9hZC54ICE9IG51bGwgJiYgcGF5bG9hZC55ICE9IG51bGwpIHtcbiAgICAgIC8vIEZJWE1FXG4gICAgICAvLyBzaG91bGQgd3JhcCBkaXNwYXRjaEFjdGlvbiBsaWtlIGBheGlzUG9pbnRlci9nbG9iYWxMaXN0ZW5lcmAgP1xuICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgICAgICAgeDogcGF5bG9hZC54LFxuICAgICAgICB5OiBwYXlsb2FkLnlcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl90cnlTaG93KHtcbiAgICAgICAgb2Zmc2V0WDogcGF5bG9hZC54LFxuICAgICAgICBvZmZzZXRZOiBwYXlsb2FkLnksXG4gICAgICAgIHBvc2l0aW9uOiBwYXlsb2FkLnBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQ6IGFwaS5nZXRacigpLmZpbmRIb3ZlcihwYXlsb2FkLngsIHBheWxvYWQueSkudGFyZ2V0XG4gICAgICB9LCBkaXNwYXRjaEFjdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5tYW51YWxseUhpZGVUaXAgPSBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSB0aGlzLl90b29sdGlwQ29udGVudDtcblxuICAgIGlmICghdGhpcy5fYWx3YXlzU2hvd0NvbnRlbnQgJiYgdGhpcy5fdG9vbHRpcE1vZGVsKSB7XG4gICAgICB0b29sdGlwQ29udGVudC5oaWRlTGF0ZXIodGhpcy5fdG9vbHRpcE1vZGVsLmdldCgnaGlkZURlbGF5JykpO1xuICAgIH1cblxuICAgIHRoaXMuX2xhc3RYID0gdGhpcy5fbGFzdFkgPSB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBudWxsO1xuXG4gICAgaWYgKHBheWxvYWQuZnJvbSAhPT0gdGhpcy51aWQpIHtcbiAgICAgIHRoaXMuX2hpZGUobWFrZURpc3BhdGNoQWN0aW9uKHBheWxvYWQsIGFwaSkpO1xuICAgIH1cbiAgfTsgLy8gQmUgY29tcGF0aWJsZSB3aXRoIHByZXZpb3VzIGRlc2lnbiwgdGhhdCBpcywgd2hlbiB0b29sdGlwLnR5cGUgaXMgJ2F4aXMnIGFuZFxuICAvLyBkaXNwYXRjaEFjdGlvbiAnc2hvd1RpcCcgd2l0aCBzZXJpZXNJbmRleCBhbmQgZGF0YUluZGV4IHdpbGwgdHJpZ2dlciBheGlzIHBvaW50ZXJcbiAgLy8gYW5kIHRvb2x0aXAuXG5cblxuICBUb29sdGlwVmlldy5wcm90b3R5cGUuX21hbnVhbGx5QXhpc1Nob3dUaXAgPSBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB2YXIgc2VyaWVzSW5kZXggPSBwYXlsb2FkLnNlcmllc0luZGV4O1xuICAgIHZhciBkYXRhSW5kZXggPSBwYXlsb2FkLmRhdGFJbmRleDsgLy8gQHRzLWlnbm9yZVxuXG4gICAgdmFyIGNvb3JkU3lzQXhlc0luZm8gPSBlY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKS5jb29yZFN5c0F4ZXNJbmZvO1xuXG4gICAgaWYgKHNlcmllc0luZGV4ID09IG51bGwgfHwgZGF0YUluZGV4ID09IG51bGwgfHwgY29vcmRTeXNBeGVzSW5mbyA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KHNlcmllc0luZGV4KTtcblxuICAgIGlmICghc2VyaWVzTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgdG9vbHRpcENhc2NhZGVkTW9kZWwgPSBidWlsZFRvb2x0aXBNb2RlbChbZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KSwgc2VyaWVzTW9kZWwsIChzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtIHx8IHt9KS5tb2RlbCwgdG9vbHRpcE1vZGVsXSk7XG5cbiAgICBpZiAodG9vbHRpcENhc2NhZGVkTW9kZWwuZ2V0KCd0cmlnZ2VyJykgIT09ICdheGlzJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxuICAgICAgZGF0YUluZGV4OiBkYXRhSW5kZXgsXG4gICAgICBwb3NpdGlvbjogcGF5bG9hZC5wb3NpdGlvblxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5fdHJ5U2hvdyA9IGZ1bmN0aW9uIChlLCBkaXNwYXRjaEFjdGlvbikge1xuICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgIHZhciB0b29sdGlwTW9kZWwgPSB0aGlzLl90b29sdGlwTW9kZWw7XG5cbiAgICBpZiAoIXRvb2x0aXBNb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gU2F2ZSBtb3VzZSB4LCBtb3VzZSB5LiBTbyB3ZSBjYW4gdHJ5IHRvIGtlZXAgc2hvd2luZyB0aGUgdGlwIGlmIGNoYXJ0IGlzIHJlZnJlc2hlZFxuXG5cbiAgICB0aGlzLl9sYXN0WCA9IGUub2Zmc2V0WDtcbiAgICB0aGlzLl9sYXN0WSA9IGUub2Zmc2V0WTtcbiAgICB2YXIgZGF0YUJ5Q29vcmRTeXMgPSBlLmRhdGFCeUNvb3JkU3lzO1xuXG4gICAgaWYgKGRhdGFCeUNvb3JkU3lzICYmIGRhdGFCeUNvb3JkU3lzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fc2hvd0F4aXNUb29sdGlwKGRhdGFCeUNvb3JkU3lzLCBlKTtcbiAgICB9IC8vIEFsd2F5cyBzaG93IGl0ZW0gdG9vbHRpcCBpZiBtb3VzZSBpcyBvbiB0aGUgZWxlbWVudCB3aXRoIGRhdGFJbmRleFxuICAgIGVsc2UgaWYgKGVsICYmIGZpbmRFdmVudERpc3BhdGNoZXIoZWwsIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGdldEVDRGF0YSh0YXJnZXQpLmRhdGFJbmRleCAhPSBudWxsO1xuICAgICAgfSwgdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9zaG93U2VyaWVzSXRlbVRvb2x0aXAoZSwgZWwsIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgIH0gLy8gVG9vbHRpcCBwcm92aWRlZCBkaXJlY3RseS4gTGlrZSBsZWdlbmQuXG4gICAgICBlbHNlIGlmIChlbCAmJiBlbC50b29sdGlwKSB7XG4gICAgICAgICAgdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzID0gbnVsbDtcblxuICAgICAgICAgIHRoaXMuX3Nob3dDb21wb25lbnRJdGVtVG9vbHRpcChlLCBlbCwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XG5cbiAgICAgICAgICB0aGlzLl9oaWRlKGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgfVxuICB9O1xuXG4gIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5fc2hvd09yTW92ZSA9IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGNiKSB7XG4gICAgLy8gc2hvd0RlbGF5IGlzIHVzZWQgaW4gdGhpcyBjYXNlOiB0b29sdGlwLmVudGVyYWJsZSBpcyBzZXRcbiAgICAvLyBhcyB0cnVlLiBVc2VyIGludGVudCB0byBtb3ZlIG1vdXNlIGludG8gdG9vbHRpcCBhbmQgY2xpY2tcbiAgICAvLyBzb21ldGhpbmcuIGBzaG93RGVsYXlgIG1ha2VzIGl0IGVhc2llciB0byBlbnRlciB0aGUgY29udGVudFxuICAgIC8vIGJ1dCB0b29sdGlwIGRvIG5vdCBtb3ZlIGltbWVkaWF0ZWx5LlxuICAgIHZhciBkZWxheSA9IHRvb2x0aXBNb2RlbC5nZXQoJ3Nob3dEZWxheScpO1xuICAgIGNiID0genJVdGlsLmJpbmQoY2IsIHRoaXMpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9zaG93VGltb3V0KTtcbiAgICBkZWxheSA+IDAgPyB0aGlzLl9zaG93VGltb3V0ID0gc2V0VGltZW91dChjYiwgZGVsYXkpIDogY2IoKTtcbiAgfTtcblxuICBUb29sdGlwVmlldy5wcm90b3R5cGUuX3Nob3dBeGlzVG9vbHRpcCA9IGZ1bmN0aW9uIChkYXRhQnlDb29yZFN5cywgZSkge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fZWNNb2RlbDtcbiAgICB2YXIgZ2xvYmFsVG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuICAgIHZhciBwb2ludCA9IFtlLm9mZnNldFgsIGUub2Zmc2V0WV07XG4gICAgdmFyIHNpbmdsZVRvb2x0aXBNb2RlbCA9IGJ1aWxkVG9vbHRpcE1vZGVsKFtlLnRvb2x0aXBPcHRpb24sIGdsb2JhbFRvb2x0aXBNb2RlbF0pO1xuICAgIHZhciByZW5kZXJNb2RlID0gdGhpcy5fcmVuZGVyTW9kZTtcbiAgICB2YXIgY2JQYXJhbXNMaXN0ID0gW107XG4gICAgdmFyIGFydGljbGVNYXJrdXAgPSBjcmVhdGVUb29sdGlwTWFya3VwKCdzZWN0aW9uJywge1xuICAgICAgYmxvY2tzOiBbXSxcbiAgICAgIG5vSGVhZGVyOiB0cnVlXG4gICAgfSk7IC8vIE9ubHkgZm9yIGxlZ2FjeTogYFNlcmlzZVsnZm9ybWF0VG9vbHRpcCddYCByZXR1cm5zIGEgc3RyaW5nLlxuXG4gICAgdmFyIG1hcmt1cFRleHRBcnJMZWdhY3kgPSBbXTtcbiAgICB2YXIgbWFya3VwU3R5bGVDcmVhdG9yID0gbmV3IFRvb2x0aXBNYXJrdXBTdHlsZUNyZWF0b3IoKTtcbiAgICBlYWNoKGRhdGFCeUNvb3JkU3lzLCBmdW5jdGlvbiAoaXRlbUNvb3JkU3lzKSB7XG4gICAgICBlYWNoKGl0ZW1Db29yZFN5cy5kYXRhQnlBeGlzLCBmdW5jdGlvbiAoYXhpc0l0ZW0pIHtcbiAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KGF4aXNJdGVtLmF4aXNEaW0gKyAnQXhpcycsIGF4aXNJdGVtLmF4aXNJbmRleCk7XG4gICAgICAgIHZhciBheGlzVmFsdWUgPSBheGlzSXRlbS52YWx1ZTtcblxuICAgICAgICBpZiAoIWF4aXNNb2RlbCB8fCBheGlzVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBheGlzVmFsdWVMYWJlbCA9IGF4aXNQb2ludGVyVmlld0hlbHBlci5nZXRWYWx1ZUxhYmVsKGF4aXNWYWx1ZSwgYXhpc01vZGVsLmF4aXMsIGVjTW9kZWwsIGF4aXNJdGVtLnNlcmllc0RhdGFJbmRpY2VzLCBheGlzSXRlbS52YWx1ZUxhYmVsT3B0KTtcbiAgICAgICAgdmFyIGF4aXNTZWN0aW9uTWFya3VwID0gY3JlYXRlVG9vbHRpcE1hcmt1cCgnc2VjdGlvbicsIHtcbiAgICAgICAgICBoZWFkZXI6IGF4aXNWYWx1ZUxhYmVsLFxuICAgICAgICAgIG5vSGVhZGVyOiAhenJVdGlsLnRyaW0oYXhpc1ZhbHVlTGFiZWwpLFxuICAgICAgICAgIHNvcnRCbG9ja3M6IHRydWUsXG4gICAgICAgICAgYmxvY2tzOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgYXJ0aWNsZU1hcmt1cC5ibG9ja3MucHVzaChheGlzU2VjdGlvbk1hcmt1cCk7XG4gICAgICAgIHpyVXRpbC5lYWNoKGF4aXNJdGVtLnNlcmllc0RhdGFJbmRpY2VzLCBmdW5jdGlvbiAoaWR4SXRlbSkge1xuICAgICAgICAgIHZhciBzZXJpZXMgPSBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoaWR4SXRlbS5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGlkeEl0ZW0uZGF0YUluZGV4SW5zaWRlO1xuICAgICAgICAgIHZhciBjYlBhcmFtcyA9IHNlcmllcy5nZXREYXRhUGFyYW1zKGRhdGFJbmRleCk7XG4gICAgICAgICAgY2JQYXJhbXMuYXhpc0RpbSA9IGF4aXNJdGVtLmF4aXNEaW07XG4gICAgICAgICAgY2JQYXJhbXMuYXhpc0luZGV4ID0gYXhpc0l0ZW0uYXhpc0luZGV4O1xuICAgICAgICAgIGNiUGFyYW1zLmF4aXNUeXBlID0gYXhpc0l0ZW0uYXhpc1R5cGU7XG4gICAgICAgICAgY2JQYXJhbXMuYXhpc0lkID0gYXhpc0l0ZW0uYXhpc0lkO1xuICAgICAgICAgIGNiUGFyYW1zLmF4aXNWYWx1ZSA9IGF4aXNIZWxwZXIuZ2V0QXhpc1Jhd1ZhbHVlKGF4aXNNb2RlbC5heGlzLCB7XG4gICAgICAgICAgICB2YWx1ZTogYXhpc1ZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2JQYXJhbXMuYXhpc1ZhbHVlTGFiZWwgPSBheGlzVmFsdWVMYWJlbDsgLy8gUHJlLWNyZWF0ZSBtYXJrZXIgc3R5bGUgZm9yIG1ha2Vycy4gVXNlcnMgY2FuIGFzc2VtYmxlIHJpY2hUZXh0XG4gICAgICAgICAgLy8gdGV4dCBpbiBgZm9ybWF0dGVyYCBjYWxsYmFjayBhbmQgdXNlIHRob3NlIG1hcmtlcnMgc3R5bGUuXG5cbiAgICAgICAgICBjYlBhcmFtcy5tYXJrZXIgPSBtYXJrdXBTdHlsZUNyZWF0b3IubWFrZVRvb2x0aXBNYXJrZXIoJ2l0ZW0nLCBmb3JtYXRVdGlsLmNvbnZlcnRUb0NvbG9yU3RyaW5nKGNiUGFyYW1zLmNvbG9yKSwgcmVuZGVyTW9kZSk7XG4gICAgICAgICAgdmFyIHNlcmllc1Rvb2x0aXBSZXN1bHQgPSBub3JtYWxpemVUb29sdGlwRm9ybWF0UmVzdWx0KHNlcmllcy5mb3JtYXRUb29sdGlwKGRhdGFJbmRleCwgdHJ1ZSwgbnVsbCkpO1xuXG4gICAgICAgICAgaWYgKHNlcmllc1Rvb2x0aXBSZXN1bHQubWFya3VwRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGF4aXNTZWN0aW9uTWFya3VwLmJsb2Nrcy5wdXNoKHNlcmllc1Rvb2x0aXBSZXN1bHQubWFya3VwRnJhZ21lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZXJpZXNUb29sdGlwUmVzdWx0Lm1hcmt1cFRleHQpIHtcbiAgICAgICAgICAgIG1hcmt1cFRleHRBcnJMZWdhY3kucHVzaChzZXJpZXNUb29sdGlwUmVzdWx0Lm1hcmt1cFRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNiUGFyYW1zTGlzdC5wdXNoKGNiUGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTsgLy8gSW4gbW9zdCBjYXNlcywgdGhlIHNlY29uZCBheGlzIGlzIGRpc3BsYXlzIHVwcGVyIG9uIHRoZSBmaXJzdCBvbmUuXG4gICAgLy8gU28gd2UgcmV2ZXJzZSBpdCB0byBsb29rIGJldHRlci5cblxuICAgIGFydGljbGVNYXJrdXAuYmxvY2tzLnJldmVyc2UoKTtcbiAgICBtYXJrdXBUZXh0QXJyTGVnYWN5LnJldmVyc2UoKTtcbiAgICB2YXIgcG9zaXRpb25FeHByID0gZS5wb3NpdGlvbjtcbiAgICB2YXIgb3JkZXJNb2RlID0gc2luZ2xlVG9vbHRpcE1vZGVsLmdldCgnb3JkZXInKTtcbiAgICB2YXIgYnVpbHRNYXJrdXBUZXh0ID0gYnVpbGRUb29sdGlwTWFya3VwKGFydGljbGVNYXJrdXAsIG1hcmt1cFN0eWxlQ3JlYXRvciwgcmVuZGVyTW9kZSwgb3JkZXJNb2RlLCBlY01vZGVsLmdldCgndXNlVVRDJyksIHNpbmdsZVRvb2x0aXBNb2RlbC5nZXQoJ3RleHRTdHlsZScpKTtcbiAgICBidWlsdE1hcmt1cFRleHQgJiYgbWFya3VwVGV4dEFyckxlZ2FjeS51bnNoaWZ0KGJ1aWx0TWFya3VwVGV4dCk7XG4gICAgdmFyIGJsb2NrQnJlYWsgPSByZW5kZXJNb2RlID09PSAncmljaFRleHQnID8gJ1xcblxcbicgOiAnPGJyLz4nO1xuICAgIHZhciBhbGxNYXJrdXBUZXh0ID0gbWFya3VwVGV4dEFyckxlZ2FjeS5qb2luKGJsb2NrQnJlYWspO1xuXG4gICAgdGhpcy5fc2hvd09yTW92ZShzaW5nbGVUb29sdGlwTW9kZWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl91cGRhdGVDb250ZW50Tm90Q2hhbmdlZE9uQXhpcyhkYXRhQnlDb29yZFN5cykpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oc2luZ2xlVG9vbHRpcE1vZGVsLCBwb3NpdGlvbkV4cHIsIHBvaW50WzBdLCBwb2ludFsxXSwgdGhpcy5fdG9vbHRpcENvbnRlbnQsIGNiUGFyYW1zTGlzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zaG93VG9vbHRpcENvbnRlbnQoc2luZ2xlVG9vbHRpcE1vZGVsLCBhbGxNYXJrdXBUZXh0LCBjYlBhcmFtc0xpc3QsIE1hdGgucmFuZG9tKCkgKyAnJywgcG9pbnRbMF0sIHBvaW50WzFdLCBwb3NpdGlvbkV4cHIsIG51bGwsIG1hcmt1cFN0eWxlQ3JlYXRvcik7XG4gICAgICB9XG4gICAgfSk7IC8vIERvIG5vdCB0cmlnZ2VyIGV2ZW50cyBoZXJlLCBiZWNhdXNlIHRoaXMgYnJhbmNoIG9ubHkgYmUgZW50ZXJlZFxuICAgIC8vIGZyb20gZGlzcGF0Y2hBY3Rpb24uXG5cbiAgfTtcblxuICBUb29sdGlwVmlldy5wcm90b3R5cGUuX3Nob3dTZXJpZXNJdGVtVG9vbHRpcCA9IGZ1bmN0aW9uIChlLCBlbCwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IGZpbmRFdmVudERpc3BhdGNoZXIoZWwsIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBnZXRFQ0RhdGEodGFyZ2V0KS5kYXRhSW5kZXggIT0gbnVsbDtcbiAgICB9LCB0cnVlKTtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX2VjTW9kZWw7XG4gICAgdmFyIGVjRGF0YSA9IGdldEVDRGF0YShkaXNwYXRjaGVyKTsgLy8gVXNlIGRhdGFNb2RlbCBpbiBlbGVtZW50IGlmIHBvc3NpYmxlXG4gICAgLy8gVXNlZCB3aGVuIG1vdXNlb3ZlciBvbiBhIGVsZW1lbnQgbGlrZSBtYXJrUG9pbnQgb3IgZWRnZVxuICAgIC8vIEluIHdoaWNoIGNhc2UsIHRoZSBkYXRhIGlzIG5vdCBtYWluIGRhdGEgaW4gc2VyaWVzLlxuXG4gICAgdmFyIHNlcmllc0luZGV4ID0gZWNEYXRhLnNlcmllc0luZGV4O1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChzZXJpZXNJbmRleCk7IC8vIEZvciBleGFtcGxlLCBncmFwaCBsaW5rLlxuXG4gICAgdmFyIGRhdGFNb2RlbCA9IGVjRGF0YS5kYXRhTW9kZWwgfHwgc2VyaWVzTW9kZWw7XG4gICAgdmFyIGRhdGFJbmRleCA9IGVjRGF0YS5kYXRhSW5kZXg7XG4gICAgdmFyIGRhdGFUeXBlID0gZWNEYXRhLmRhdGFUeXBlO1xuICAgIHZhciBkYXRhID0gZGF0YU1vZGVsLmdldERhdGEoZGF0YVR5cGUpO1xuICAgIHZhciByZW5kZXJNb2RlID0gdGhpcy5fcmVuZGVyTW9kZTtcbiAgICB2YXIgdG9vbHRpcE1vZGVsID0gYnVpbGRUb29sdGlwTW9kZWwoW2RhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCksIGRhdGFNb2RlbCwgc2VyaWVzTW9kZWwgJiYgKHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gfHwge30pLm1vZGVsLCB0aGlzLl90b29sdGlwTW9kZWxdKTtcbiAgICB2YXIgdG9vbHRpcFRyaWdnZXIgPSB0b29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyJyk7XG5cbiAgICBpZiAodG9vbHRpcFRyaWdnZXIgIT0gbnVsbCAmJiB0b29sdGlwVHJpZ2dlciAhPT0gJ2l0ZW0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IGRhdGFNb2RlbC5nZXREYXRhUGFyYW1zKGRhdGFJbmRleCwgZGF0YVR5cGUpO1xuICAgIHZhciBtYXJrdXBTdHlsZUNyZWF0b3IgPSBuZXcgVG9vbHRpcE1hcmt1cFN0eWxlQ3JlYXRvcigpOyAvLyBQcmUtY3JlYXRlIG1hcmtlciBzdHlsZSBmb3IgbWFrZXJzLiBVc2VycyBjYW4gYXNzZW1ibGUgcmljaFRleHRcbiAgICAvLyB0ZXh0IGluIGBmb3JtYXR0ZXJgIGNhbGxiYWNrIGFuZCB1c2UgdGhvc2UgbWFya2VycyBzdHlsZS5cblxuICAgIHBhcmFtcy5tYXJrZXIgPSBtYXJrdXBTdHlsZUNyZWF0b3IubWFrZVRvb2x0aXBNYXJrZXIoJ2l0ZW0nLCBmb3JtYXRVdGlsLmNvbnZlcnRUb0NvbG9yU3RyaW5nKHBhcmFtcy5jb2xvciksIHJlbmRlck1vZGUpO1xuICAgIHZhciBzZXJpZXNUb29sdGlwUmVzdWx0ID0gbm9ybWFsaXplVG9vbHRpcEZvcm1hdFJlc3VsdChkYXRhTW9kZWwuZm9ybWF0VG9vbHRpcChkYXRhSW5kZXgsIGZhbHNlLCBkYXRhVHlwZSkpO1xuICAgIHZhciBvcmRlck1vZGUgPSB0b29sdGlwTW9kZWwuZ2V0KCdvcmRlcicpO1xuICAgIHZhciBtYXJrdXBUZXh0ID0gc2VyaWVzVG9vbHRpcFJlc3VsdC5tYXJrdXBGcmFnbWVudCA/IGJ1aWxkVG9vbHRpcE1hcmt1cChzZXJpZXNUb29sdGlwUmVzdWx0Lm1hcmt1cEZyYWdtZW50LCBtYXJrdXBTdHlsZUNyZWF0b3IsIHJlbmRlck1vZGUsIG9yZGVyTW9kZSwgZWNNb2RlbC5nZXQoJ3VzZVVUQycpLCB0b29sdGlwTW9kZWwuZ2V0KCd0ZXh0U3R5bGUnKSkgOiBzZXJpZXNUb29sdGlwUmVzdWx0Lm1hcmt1cFRleHQ7XG4gICAgdmFyIGFzeW5jVGlja2V0ID0gJ2l0ZW1fJyArIGRhdGFNb2RlbC5uYW1lICsgJ18nICsgZGF0YUluZGV4O1xuXG4gICAgdGhpcy5fc2hvd09yTW92ZSh0b29sdGlwTW9kZWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3Nob3dUb29sdGlwQ29udGVudCh0b29sdGlwTW9kZWwsIG1hcmt1cFRleHQsIHBhcmFtcywgYXN5bmNUaWNrZXQsIGUub2Zmc2V0WCwgZS5vZmZzZXRZLCBlLnBvc2l0aW9uLCBlLnRhcmdldCwgbWFya3VwU3R5bGVDcmVhdG9yKTtcbiAgICB9KTsgLy8gRklYTUVcbiAgICAvLyBkdXBsaWNhdGVkIHNob3d0aXAgaWYgbWFudWFsbHlTaG93VGlwIGlzIGNhbGxlZCBmcm9tIGRpc3BhdGNoQWN0aW9uLlxuXG5cbiAgICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgICBkYXRhSW5kZXhJbnNpZGU6IGRhdGFJbmRleCxcbiAgICAgIGRhdGFJbmRleDogZGF0YS5nZXRSYXdJbmRleChkYXRhSW5kZXgpLFxuICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxuICAgICAgZnJvbTogdGhpcy51aWRcbiAgICB9KTtcbiAgfTtcblxuICBUb29sdGlwVmlldy5wcm90b3R5cGUuX3Nob3dDb21wb25lbnRJdGVtVG9vbHRpcCA9IGZ1bmN0aW9uIChlLCBlbCwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICB2YXIgdG9vbHRpcE9wdCA9IGVsLnRvb2x0aXA7XG5cbiAgICBpZiAoenJVdGlsLmlzU3RyaW5nKHRvb2x0aXBPcHQpKSB7XG4gICAgICB2YXIgY29udGVudCA9IHRvb2x0aXBPcHQ7XG4gICAgICB0b29sdGlwT3B0ID0ge1xuICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAvLyBGaXhlZCBmb3JtYXR0ZXJcbiAgICAgICAgZm9ybWF0dGVyOiBjb250ZW50XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzdWJUb29sdGlwTW9kZWwgPSBuZXcgTW9kZWwodG9vbHRpcE9wdCwgdGhpcy5fdG9vbHRpcE1vZGVsLCB0aGlzLl9lY01vZGVsKTtcbiAgICB2YXIgZGVmYXVsdEh0bWwgPSBzdWJUb29sdGlwTW9kZWwuZ2V0KCdjb250ZW50Jyk7XG4gICAgdmFyIGFzeW5jVGlja2V0ID0gTWF0aC5yYW5kb20oKSArICcnOyAvLyBQRU5ESU5HOiB0aGlzIGNhc2UgZG8gbm90IHN1cHBvcnQgcmljaFRleHQgc3R5bGUgeWV0LlxuXG4gICAgdmFyIG1hcmt1cFN0eWxlQ3JlYXRvciA9IG5ldyBUb29sdGlwTWFya3VwU3R5bGVDcmVhdG9yKCk7IC8vIERvIG5vdCBjaGVjayB3aGV0aGVyIGB0cmlnZ2VyYCBpcyAnbm9uZScgaGVyZSwgYmVjYXVzZSBgdHJpZ2dlcmBcbiAgICAvLyBvbmx5IHdvcmtzIG9uIGNvb3JkaW5hdGUgc3lzdGVtLiBJbiBmYWN0LCB3ZSBoYXZlIG5vdCBmb3VuZCBjYXNlXG4gICAgLy8gdGhhdCByZXF1aXJlcyBzZXR0aW5nIGB0cmlnZ2VyYCBub3RoaW5nIG9uIGNvbXBvbmVudCB5ZXQuXG5cbiAgICB0aGlzLl9zaG93T3JNb3ZlKHN1YlRvb2x0aXBNb2RlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fc2hvd1Rvb2x0aXBDb250ZW50KCAvLyBVc2UgZm9ybWF0dGVyUGFyYW1zIGZyb20gZWxlbWVudCBkZWZpbmVkIGluIGNvbXBvbmVudFxuICAgICAgc3ViVG9vbHRpcE1vZGVsLCBkZWZhdWx0SHRtbCwgc3ViVG9vbHRpcE1vZGVsLmdldCgnZm9ybWF0dGVyUGFyYW1zJykgfHwge30sIGFzeW5jVGlja2V0LCBlLm9mZnNldFgsIGUub2Zmc2V0WSwgZS5wb3NpdGlvbiwgZWwsIG1hcmt1cFN0eWxlQ3JlYXRvcik7XG4gICAgfSk7IC8vIElmIG5vdCBkaXNwYXRjaCBzaG93VGlwLCB0aXAgbWF5IGJlIGhpZGUgdHJpZ2dlcmVkIGJ5IGF4aXMuXG5cblxuICAgIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdzaG93VGlwJyxcbiAgICAgIGZyb206IHRoaXMudWlkXG4gICAgfSk7XG4gIH07XG5cbiAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl9zaG93VG9vbHRpcENvbnRlbnQgPSBmdW5jdGlvbiAoIC8vIFVzZSBNb2RlbDxUb29sdGlwT3B0aW9uPiBpbnN0ZWFkb2YgVG9vbHRpcE1vZGVsIGJlY2F1c2UgdGhpcyBtb2RlbCBtYXkgYmUgZnJvbSBzZXJpZXMgb3Igb3RoZXIgb3B0aW9ucy5cbiAgLy8gSW5zdGVhZCBvZiB0b3AgbGV2ZWwgdG9vbHRpcC5cbiAgdG9vbHRpcE1vZGVsLCBkZWZhdWx0SHRtbCwgcGFyYW1zLCBhc3luY1RpY2tldCwgeCwgeSwgcG9zaXRpb25FeHByLCBlbCwgbWFya3VwU3R5bGVDcmVhdG9yKSB7XG4gICAgLy8gUmVzZXQgdGlja2V0XG4gICAgdGhpcy5fdGlja2V0ID0gJyc7XG5cbiAgICBpZiAoIXRvb2x0aXBNb2RlbC5nZXQoJ3Nob3dDb250ZW50JykgfHwgIXRvb2x0aXBNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0b29sdGlwQ29udGVudCA9IHRoaXMuX3Rvb2x0aXBDb250ZW50O1xuICAgIHZhciBmb3JtYXR0ZXIgPSB0b29sdGlwTW9kZWwuZ2V0KCdmb3JtYXR0ZXInKTtcbiAgICBwb3NpdGlvbkV4cHIgPSBwb3NpdGlvbkV4cHIgfHwgdG9vbHRpcE1vZGVsLmdldCgncG9zaXRpb24nKTtcbiAgICB2YXIgaHRtbCA9IGRlZmF1bHRIdG1sO1xuXG4gICAgdmFyIG5lYXJQb2ludCA9IHRoaXMuX2dldE5lYXJlc3RQb2ludChbeCwgeV0sIHBhcmFtcywgdG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlcicpLCB0b29sdGlwTW9kZWwuZ2V0KCdib3JkZXJDb2xvcicpKTtcblxuICAgIGlmIChmb3JtYXR0ZXIgJiYgenJVdGlsLmlzU3RyaW5nKGZvcm1hdHRlcikpIHtcbiAgICAgIHZhciB1c2VVVEMgPSB0b29sdGlwTW9kZWwuZWNNb2RlbC5nZXQoJ3VzZVVUQycpO1xuICAgICAgdmFyIHBhcmFtczAgPSB6clV0aWwuaXNBcnJheShwYXJhbXMpID8gcGFyYW1zWzBdIDogcGFyYW1zO1xuICAgICAgdmFyIGlzVGltZUF4aXMgPSBwYXJhbXMwICYmIHBhcmFtczAuYXhpc1R5cGUgJiYgcGFyYW1zMC5heGlzVHlwZS5pbmRleE9mKCd0aW1lJykgPj0gMDtcbiAgICAgIGh0bWwgPSBmb3JtYXR0ZXI7XG5cbiAgICAgIGlmIChpc1RpbWVBeGlzKSB7XG4gICAgICAgIGh0bWwgPSB0aW1lRm9ybWF0KHBhcmFtczAuYXhpc1ZhbHVlLCBodG1sLCB1c2VVVEMpO1xuICAgICAgfVxuXG4gICAgICBodG1sID0gZm9ybWF0VXRpbC5mb3JtYXRUcGwoaHRtbCwgcGFyYW1zLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHpyVXRpbC5pc0Z1bmN0aW9uKGZvcm1hdHRlcikpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IGJpbmQoZnVuY3Rpb24gKGNiVGlja2V0LCBodG1sKSB7XG4gICAgICAgIGlmIChjYlRpY2tldCA9PT0gdGhpcy5fdGlja2V0KSB7XG4gICAgICAgICAgdG9vbHRpcENvbnRlbnQuc2V0Q29udGVudChodG1sLCBtYXJrdXBTdHlsZUNyZWF0b3IsIHRvb2x0aXBNb2RlbCwgbmVhclBvaW50LmNvbG9yLCBwb3NpdGlvbkV4cHIpO1xuXG4gICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24odG9vbHRpcE1vZGVsLCBwb3NpdGlvbkV4cHIsIHgsIHksIHRvb2x0aXBDb250ZW50LCBwYXJhbXMsIGVsKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgICB0aGlzLl90aWNrZXQgPSBhc3luY1RpY2tldDtcbiAgICAgIGh0bWwgPSBmb3JtYXR0ZXIocGFyYW1zLCBhc3luY1RpY2tldCwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHRvb2x0aXBDb250ZW50LnNldENvbnRlbnQoaHRtbCwgbWFya3VwU3R5bGVDcmVhdG9yLCB0b29sdGlwTW9kZWwsIG5lYXJQb2ludC5jb2xvciwgcG9zaXRpb25FeHByKTtcbiAgICB0b29sdGlwQ29udGVudC5zaG93KHRvb2x0aXBNb2RlbCwgbmVhclBvaW50LmNvbG9yKTtcblxuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKHRvb2x0aXBNb2RlbCwgcG9zaXRpb25FeHByLCB4LCB5LCB0b29sdGlwQ29udGVudCwgcGFyYW1zLCBlbCk7XG4gIH07XG5cbiAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl9nZXROZWFyZXN0UG9pbnQgPSBmdW5jdGlvbiAocG9pbnQsIHRvb2x0aXBEYXRhUGFyYW1zLCB0cmlnZ2VyLCBib3JkZXJDb2xvcikge1xuICAgIGlmICh0cmlnZ2VyID09PSAnYXhpcycgfHwgenJVdGlsLmlzQXJyYXkodG9vbHRpcERhdGFQYXJhbXMpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xvcjogYm9yZGVyQ29sb3IgfHwgKHRoaXMuX3JlbmRlck1vZGUgPT09ICdodG1sJyA/ICcjZmZmJyA6ICdub25lJylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF6clV0aWwuaXNBcnJheSh0b29sdGlwRGF0YVBhcmFtcykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbG9yOiBib3JkZXJDb2xvciB8fCB0b29sdGlwRGF0YVBhcmFtcy5jb2xvciB8fCB0b29sdGlwRGF0YVBhcmFtcy5ib3JkZXJDb2xvclxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl91cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIHBvc2l0aW9uRXhwciwgeCwgLy8gTW91c2UgeFxuICB5LCAvLyBNb3VzZSB5XG4gIGNvbnRlbnQsIHBhcmFtcywgZWwpIHtcbiAgICB2YXIgdmlld1dpZHRoID0gdGhpcy5fYXBpLmdldFdpZHRoKCk7XG5cbiAgICB2YXIgdmlld0hlaWdodCA9IHRoaXMuX2FwaS5nZXRIZWlnaHQoKTtcblxuICAgIHBvc2l0aW9uRXhwciA9IHBvc2l0aW9uRXhwciB8fCB0b29sdGlwTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgIHZhciBjb250ZW50U2l6ZSA9IGNvbnRlbnQuZ2V0U2l6ZSgpO1xuICAgIHZhciBhbGlnbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ2FsaWduJyk7XG4gICAgdmFyIHZBbGlnbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3ZlcnRpY2FsQWxpZ24nKTtcbiAgICB2YXIgcmVjdCA9IGVsICYmIGVsLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgZWwgJiYgcmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuXG4gICAgaWYgKHpyVXRpbC5pc0Z1bmN0aW9uKHBvc2l0aW9uRXhwcikpIHtcbiAgICAgIC8vIENhbGxiYWNrIG9mIHBvc2l0aW9uIGNhbiBiZSBhbiBhcnJheSBvciBhIHN0cmluZyBzcGVjaWZ5IHRoZSBwb3NpdGlvblxuICAgICAgcG9zaXRpb25FeHByID0gcG9zaXRpb25FeHByKFt4LCB5XSwgcGFyYW1zLCBjb250ZW50LmVsLCByZWN0LCB7XG4gICAgICAgIHZpZXdTaXplOiBbdmlld1dpZHRoLCB2aWV3SGVpZ2h0XSxcbiAgICAgICAgY29udGVudFNpemU6IGNvbnRlbnRTaXplLnNsaWNlKClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh6clV0aWwuaXNBcnJheShwb3NpdGlvbkV4cHIpKSB7XG4gICAgICB4ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uRXhwclswXSwgdmlld1dpZHRoKTtcbiAgICAgIHkgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25FeHByWzFdLCB2aWV3SGVpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKHpyVXRpbC5pc09iamVjdChwb3NpdGlvbkV4cHIpKSB7XG4gICAgICB2YXIgYm94TGF5b3V0UG9zaXRpb24gPSBwb3NpdGlvbkV4cHI7XG4gICAgICBib3hMYXlvdXRQb3NpdGlvbi53aWR0aCA9IGNvbnRlbnRTaXplWzBdO1xuICAgICAgYm94TGF5b3V0UG9zaXRpb24uaGVpZ2h0ID0gY29udGVudFNpemVbMV07XG4gICAgICB2YXIgbGF5b3V0UmVjdCA9IGxheW91dFV0aWwuZ2V0TGF5b3V0UmVjdChib3hMYXlvdXRQb3NpdGlvbiwge1xuICAgICAgICB3aWR0aDogdmlld1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHZpZXdIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgeCA9IGxheW91dFJlY3QueDtcbiAgICAgIHkgPSBsYXlvdXRSZWN0Lnk7XG4gICAgICBhbGlnbiA9IG51bGw7IC8vIFdoZW4gcG9zaXRpb25FeHByIGlzIGxlZnQvdG9wL3JpZ2h0L2JvdHRvbSxcbiAgICAgIC8vIGFsaWduIGFuZCB2ZXJ0aWNhbEFsaWduIHdpbGwgbm90IHdvcmsuXG5cbiAgICAgIHZBbGlnbiA9IG51bGw7XG4gICAgfSAvLyBTcGVjaWZ5IHRvb2x0aXAgcG9zaXRpb24gYnkgc3RyaW5nICd0b3AnICdib3R0b20nICdsZWZ0JyAncmlnaHQnIGFyb3VuZCBncmFwaGljIGVsZW1lbnRcbiAgICBlbHNlIGlmICh6clV0aWwuaXNTdHJpbmcocG9zaXRpb25FeHByKSAmJiBlbCkge1xuICAgICAgICB2YXIgcG9zID0gY2FsY1Rvb2x0aXBQb3NpdGlvbihwb3NpdGlvbkV4cHIsIHJlY3QsIGNvbnRlbnRTaXplKTtcbiAgICAgICAgeCA9IHBvc1swXTtcbiAgICAgICAgeSA9IHBvc1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwb3MgPSByZWZpeFRvb2x0aXBQb3NpdGlvbih4LCB5LCBjb250ZW50LCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQsIGFsaWduID8gbnVsbCA6IDIwLCB2QWxpZ24gPyBudWxsIDogMjApO1xuICAgICAgICB4ID0gcG9zWzBdO1xuICAgICAgICB5ID0gcG9zWzFdO1xuICAgICAgfVxuXG4gICAgYWxpZ24gJiYgKHggLT0gaXNDZW50ZXJBbGlnbihhbGlnbikgPyBjb250ZW50U2l6ZVswXSAvIDIgOiBhbGlnbiA9PT0gJ3JpZ2h0JyA/IGNvbnRlbnRTaXplWzBdIDogMCk7XG4gICAgdkFsaWduICYmICh5IC09IGlzQ2VudGVyQWxpZ24odkFsaWduKSA/IGNvbnRlbnRTaXplWzFdIC8gMiA6IHZBbGlnbiA9PT0gJ2JvdHRvbScgPyBjb250ZW50U2l6ZVsxXSA6IDApO1xuXG4gICAgaWYgKHNob3VsZFRvb2x0aXBDb25maW5lKHRvb2x0aXBNb2RlbCkpIHtcbiAgICAgIHZhciBwb3MgPSBjb25maW5lVG9vbHRpcFBvc2l0aW9uKHgsIHksIGNvbnRlbnQsIHZpZXdXaWR0aCwgdmlld0hlaWdodCk7XG4gICAgICB4ID0gcG9zWzBdO1xuICAgICAgeSA9IHBvc1sxXTtcbiAgICB9XG5cbiAgICBjb250ZW50Lm1vdmVUbyh4LCB5KTtcbiAgfTsgLy8gRklYTUVcbiAgLy8gU2hvdWxkIHdlIHJlbW92ZSB0aGlzIGJ1dCBsZWF2ZSB0aGlzIHRvIHVzZXI/XG5cblxuICBUb29sdGlwVmlldy5wcm90b3R5cGUuX3VwZGF0ZUNvbnRlbnROb3RDaGFuZ2VkT25BeGlzID0gZnVuY3Rpb24gKGRhdGFCeUNvb3JkU3lzKSB7XG4gICAgdmFyIGxhc3RDb29yZFN5cyA9IHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cztcbiAgICB2YXIgY29udGVudE5vdENoYW5nZWQgPSAhIWxhc3RDb29yZFN5cyAmJiBsYXN0Q29vcmRTeXMubGVuZ3RoID09PSBkYXRhQnlDb29yZFN5cy5sZW5ndGg7XG4gICAgY29udGVudE5vdENoYW5nZWQgJiYgZWFjaChsYXN0Q29vcmRTeXMsIGZ1bmN0aW9uIChsYXN0SXRlbUNvb3JkU3lzLCBpbmRleENvb3JkU3lzKSB7XG4gICAgICB2YXIgbGFzdERhdGFCeUF4aXMgPSBsYXN0SXRlbUNvb3JkU3lzLmRhdGFCeUF4aXMgfHwgW107XG4gICAgICB2YXIgdGhpc0l0ZW1Db29yZFN5cyA9IGRhdGFCeUNvb3JkU3lzW2luZGV4Q29vcmRTeXNdIHx8IHt9O1xuICAgICAgdmFyIHRoaXNEYXRhQnlBeGlzID0gdGhpc0l0ZW1Db29yZFN5cy5kYXRhQnlBeGlzIHx8IFtdO1xuICAgICAgY29udGVudE5vdENoYW5nZWQgPSBjb250ZW50Tm90Q2hhbmdlZCAmJiBsYXN0RGF0YUJ5QXhpcy5sZW5ndGggPT09IHRoaXNEYXRhQnlBeGlzLmxlbmd0aDtcbiAgICAgIGNvbnRlbnROb3RDaGFuZ2VkICYmIGVhY2gobGFzdERhdGFCeUF4aXMsIGZ1bmN0aW9uIChsYXN0SXRlbSwgaW5kZXhBeGlzKSB7XG4gICAgICAgIHZhciB0aGlzSXRlbSA9IHRoaXNEYXRhQnlBeGlzW2luZGV4QXhpc10gfHwge307XG4gICAgICAgIHZhciBsYXN0SW5kaWNlcyA9IGxhc3RJdGVtLnNlcmllc0RhdGFJbmRpY2VzIHx8IFtdO1xuICAgICAgICB2YXIgbmV3SW5kaWNlcyA9IHRoaXNJdGVtLnNlcmllc0RhdGFJbmRpY2VzIHx8IFtdO1xuICAgICAgICBjb250ZW50Tm90Q2hhbmdlZCA9IGNvbnRlbnROb3RDaGFuZ2VkICYmIGxhc3RJdGVtLnZhbHVlID09PSB0aGlzSXRlbS52YWx1ZSAmJiBsYXN0SXRlbS5heGlzVHlwZSA9PT0gdGhpc0l0ZW0uYXhpc1R5cGUgJiYgbGFzdEl0ZW0uYXhpc0lkID09PSB0aGlzSXRlbS5heGlzSWQgJiYgbGFzdEluZGljZXMubGVuZ3RoID09PSBuZXdJbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgY29udGVudE5vdENoYW5nZWQgJiYgZWFjaChsYXN0SW5kaWNlcywgZnVuY3Rpb24gKGxhc3RJZHhJdGVtLCBqKSB7XG4gICAgICAgICAgdmFyIG5ld0lkeEl0ZW0gPSBuZXdJbmRpY2VzW2pdO1xuICAgICAgICAgIGNvbnRlbnROb3RDaGFuZ2VkID0gY29udGVudE5vdENoYW5nZWQgJiYgbGFzdElkeEl0ZW0uc2VyaWVzSW5kZXggPT09IG5ld0lkeEl0ZW0uc2VyaWVzSW5kZXggJiYgbGFzdElkeEl0ZW0uZGF0YUluZGV4ID09PSBuZXdJZHhJdGVtLmRhdGFJbmRleDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBkYXRhQnlDb29yZFN5cztcbiAgICByZXR1cm4gISFjb250ZW50Tm90Q2hhbmdlZDtcbiAgfTtcblxuICBUb29sdGlwVmlldy5wcm90b3R5cGUuX2hpZGUgPSBmdW5jdGlvbiAoZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAvLyBEbyBub3QgZGlyZWN0bHkgaGlkZUxhdGVyIGhlcmUsIGJlY2F1c2UgdGhpcyBiZWhhdmlvciBtYXkgYmUgcHJldmVudGVkXG4gICAgLy8gaW4gZGlzcGF0Y2hBY3Rpb24gd2hlbiBzaG93VGlwIGlzIGRpc3BhdGNoZWQuXG4gICAgLy8gRklYTUVcbiAgICAvLyBkdXBsaWNhdGVkIGhpZGVUaXAgaWYgbWFudWFsbHlIaWRlVGlwIGlzIGNhbGxlZCBmcm9tIGRpc3BhdGNoQWN0aW9uLlxuICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XG4gICAgZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2hpZGVUaXAnLFxuICAgICAgZnJvbTogdGhpcy51aWRcbiAgICB9KTtcbiAgfTtcblxuICBUb29sdGlwVmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl90b29sdGlwQ29udGVudC5kaXNwb3NlKCk7XG5cbiAgICBnbG9iYWxMaXN0ZW5lci51bnJlZ2lzdGVyKCdpdGVtVG9vbHRpcCcsIGFwaSk7XG4gIH07XG5cbiAgVG9vbHRpcFZpZXcudHlwZSA9ICd0b29sdGlwJztcbiAgcmV0dXJuIFRvb2x0aXBWaWV3O1xufShDb21wb25lbnRWaWV3KTtcbi8qKlxuICogRnJvbSB0b3AgdG8gYm90dG9tLiAodGhlIGxhc3Qgb25lIHNob3VsZCBiZSBnbG9iYWxUb29sdGlwTW9kZWwpO1xuICovXG5cblxuZnVuY3Rpb24gYnVpbGRUb29sdGlwTW9kZWwobW9kZWxDYXNjYWRlKSB7XG4gIC8vIExhc3QgaXMgYWx3YXlzIHRvb2x0aXAgbW9kZWwuXG4gIHZhciByZXN1bHRNb2RlbCA9IG1vZGVsQ2FzY2FkZS5wb3AoKTtcblxuICB3aGlsZSAobW9kZWxDYXNjYWRlLmxlbmd0aCkge1xuICAgIHZhciB0b29sdGlwT3B0ID0gbW9kZWxDYXNjYWRlLnBvcCgpO1xuXG4gICAgaWYgKHRvb2x0aXBPcHQpIHtcbiAgICAgIGlmICh0b29sdGlwT3B0IGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgdG9vbHRpcE9wdCA9IHRvb2x0aXBPcHQuZ2V0KCd0b29sdGlwJywgdHJ1ZSk7XG4gICAgICB9IC8vIEluIGVhY2ggZGF0YSBpdGVtIHRvb2x0aXAgY2FuIGJlIHNpbXBseSB3cml0ZTpcbiAgICAgIC8vIHtcbiAgICAgIC8vICB2YWx1ZTogMTAsXG4gICAgICAvLyAgdG9vbHRpcDogJ1NvbWV0aGluZyB5b3UgbmVlZCB0byBrbm93J1xuICAgICAgLy8gfVxuXG5cbiAgICAgIGlmICh6clV0aWwuaXNTdHJpbmcodG9vbHRpcE9wdCkpIHtcbiAgICAgICAgdG9vbHRpcE9wdCA9IHtcbiAgICAgICAgICBmb3JtYXR0ZXI6IHRvb2x0aXBPcHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0TW9kZWwgPSBuZXcgTW9kZWwodG9vbHRpcE9wdCwgcmVzdWx0TW9kZWwsIHJlc3VsdE1vZGVsLmVjTW9kZWwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRNb2RlbDtcbn1cblxuZnVuY3Rpb24gbWFrZURpc3BhdGNoQWN0aW9uKHBheWxvYWQsIGFwaSkge1xuICByZXR1cm4gcGF5bG9hZC5kaXNwYXRjaEFjdGlvbiB8fCB6clV0aWwuYmluZChhcGkuZGlzcGF0Y2hBY3Rpb24sIGFwaSk7XG59XG5cbmZ1bmN0aW9uIHJlZml4VG9vbHRpcFBvc2l0aW9uKHgsIHksIGNvbnRlbnQsIHZpZXdXaWR0aCwgdmlld0hlaWdodCwgZ2FwSCwgZ2FwVikge1xuICB2YXIgc2l6ZSA9IGNvbnRlbnQuZ2V0T3V0ZXJTaXplKCk7XG4gIHZhciB3aWR0aCA9IHNpemUud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBzaXplLmhlaWdodDtcblxuICBpZiAoZ2FwSCAhPSBudWxsKSB7XG4gICAgLy8gQWRkIGV4dHJhIDIgcGl4ZWxzIGZvciB0aGlzIGNhc2U6XG4gICAgLy8gQXQgcHJlc2VudCB0aGUgXCJ2YWx1ZXNcIiBpbiBkZWZhdXQgdG9vbHRpcCBhcmUgdXNpbmcgQ1NTIGBmbG9hdDogcmlnaHRgLlxuICAgIC8vIFdoZW4gdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIHRvb2x0aXAgYm94IGlzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZVxuICAgIC8vIHZpZXdwb3J0LCB0aGUgYGZsb2F0YCBsYXlvdXQgbWlnaHQgcHVzaCB0aGUgXCJ2YWx1ZXNcIiB0byB0aGUgc2Vjb25kIGxpbmUuXG4gICAgaWYgKHggKyB3aWR0aCArIGdhcEggKyAyID4gdmlld1dpZHRoKSB7XG4gICAgICB4IC09IHdpZHRoICsgZ2FwSDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCArPSBnYXBIO1xuICAgIH1cbiAgfVxuXG4gIGlmIChnYXBWICE9IG51bGwpIHtcbiAgICBpZiAoeSArIGhlaWdodCArIGdhcFYgPiB2aWV3SGVpZ2h0KSB7XG4gICAgICB5IC09IGhlaWdodCArIGdhcFY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgKz0gZ2FwVjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW3gsIHldO1xufVxuXG5mdW5jdGlvbiBjb25maW5lVG9vbHRpcFBvc2l0aW9uKHgsIHksIGNvbnRlbnQsIHZpZXdXaWR0aCwgdmlld0hlaWdodCkge1xuICB2YXIgc2l6ZSA9IGNvbnRlbnQuZ2V0T3V0ZXJTaXplKCk7XG4gIHZhciB3aWR0aCA9IHNpemUud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgeCA9IE1hdGgubWluKHggKyB3aWR0aCwgdmlld1dpZHRoKSAtIHdpZHRoO1xuICB5ID0gTWF0aC5taW4oeSArIGhlaWdodCwgdmlld0hlaWdodCkgLSBoZWlnaHQ7XG4gIHggPSBNYXRoLm1heCh4LCAwKTtcbiAgeSA9IE1hdGgubWF4KHksIDApO1xuICByZXR1cm4gW3gsIHldO1xufVxuXG5mdW5jdGlvbiBjYWxjVG9vbHRpcFBvc2l0aW9uKHBvc2l0aW9uLCByZWN0LCBjb250ZW50U2l6ZSkge1xuICB2YXIgZG9tV2lkdGggPSBjb250ZW50U2l6ZVswXTtcbiAgdmFyIGRvbUhlaWdodCA9IGNvbnRlbnRTaXplWzFdO1xuICB2YXIgZ2FwID0gMTA7XG4gIHZhciBvZmZzZXQgPSA1O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcbiAgdmFyIHJlY3RXaWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciByZWN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG5cbiAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgIGNhc2UgJ2luc2lkZSc6XG4gICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcbiAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0IC8gMiAtIGRvbUhlaWdodCAvIDI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcbiAgICAgIHkgPSByZWN0LnkgLSBkb21IZWlnaHQgLSBnYXA7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcbiAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0ICsgZ2FwO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHggPSByZWN0LnggLSBkb21XaWR0aCAtIGdhcCAtIG9mZnNldDtcbiAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0IC8gMiAtIGRvbUhlaWdodCAvIDI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHggPSByZWN0LnggKyByZWN0V2lkdGggKyBnYXAgKyBvZmZzZXQ7XG4gICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCAvIDIgLSBkb21IZWlnaHQgLyAyO1xuICB9XG5cbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuZnVuY3Rpb24gaXNDZW50ZXJBbGlnbihhbGlnbikge1xuICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInIHx8IGFsaWduID09PSAnbWlkZGxlJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgVG9vbHRpcFZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRUb29sdGlwQ29uZmluZSh0b29sdGlwTW9kZWwpIHtcbiAgdmFyIGNvbmZpbmVPcHRpb24gPSB0b29sdGlwTW9kZWwuZ2V0KCdjb25maW5lJyk7XG4gIHJldHVybiBjb25maW5lT3B0aW9uICE9IG51bGwgPyAhIWNvbmZpbmVPcHRpb24gLy8gSW4gcmljaFRleHQgbW9kZSwgdGhlIG91dHNpZGUgcGFydCBjYW4gbm90IGJlIHZpc2libGUuXG4gIDogdG9vbHRpcE1vZGVsLmdldCgncmVuZGVyTW9kZScpID09PSAncmljaFRleHQnO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBpbnN0YWxsIGFzIGluc3RhbGxBeGlzUG9pbnRlciB9IGZyb20gJy4uL2F4aXNQb2ludGVyL2luc3RhbGwnO1xuaW1wb3J0IHsgdXNlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9uJztcbmltcG9ydCBUb29sdGlwTW9kZWwgZnJvbSAnLi9Ub29sdGlwTW9kZWwnO1xuaW1wb3J0IFRvb2x0aXBWaWV3IGZyb20gJy4vVG9vbHRpcFZpZXcnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHVzZShpbnN0YWxsQXhpc1BvaW50ZXIpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChUb29sdGlwTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KFRvb2x0aXBWaWV3KTtcbiAgLyoqXG4gICAqIEBhY3Rpb25cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNlcmllc0luZGV4XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt4XVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ldXG4gICAqL1xuXG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbih7XG4gICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgIGV2ZW50OiAnc2hvd1RpcCcsXG4gICAgdXBkYXRlOiAndG9vbHRpcDptYW51YWxseVNob3dUaXAnXG4gIH0sIC8vIG5vb3BcbiAgZnVuY3Rpb24gKCkge30pO1xuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oe1xuICAgIHR5cGU6ICdoaWRlVGlwJyxcbiAgICBldmVudDogJ2hpZGVUaXAnLFxuICAgIHVwZGF0ZTogJ3Rvb2x0aXA6bWFudWFsbHlIaWRlVGlwJ1xuICB9LCAvLyBub29wXG4gIGZ1bmN0aW9uICgpIHt9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24gfSBmcm9tICcuLi8uLi91dGlsL2NvbmRpdGlvbmFsRXhwcmVzc2lvbic7XG5pbXBvcnQgeyBoYXNPd24sIGNyZWF0ZUhhc2hNYXAgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgbWFrZVByaW50YWJsZSwgdGhyb3dFcnJvciB9IGZyb20gJy4uLy4uL3V0aWwvbG9nJztcbmV4cG9ydCB2YXIgZmlsdGVyVHJhbnNmb3JtID0ge1xuICB0eXBlOiAnZWNoYXJ0czpmaWx0ZXInLFxuICAvLyBQRURJTkc6IGVuaGFuY2UgdG8gZmlsdGVyIGJ5IGluZGV4IHJhdGhlciB0aGFuIGNyZWF0ZSBuZXcgZGF0YVxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAvLyBbQ2F2ZWF0XSBGYWlsLUZhc3Q6XG4gICAgLy8gRG8gbm90IHJldHVybiB0aGUgd2hvbGUgZGF0YXNldCB1bmxlc3MgdXNlciBjb25maWcgaW5kaWNhdGUgaXQgZXhwbGljaXRseS5cbiAgICAvLyBGb3IgZXhhbXBsZSwgaWYgbm8gY29uZGl0aW9uIHNwZWNpZmllZCBieSBtaXN0YWtlLCByZXR1cm4gYW4gZW1wdHkgcmVzdWx0XG4gICAgLy8gaXMgYmV0dGVyIHRoYW4gcmV0dXJuIHRoZSBlbnRpcmUgcmF3IHNvcnVjZSBmb3IgdXNlciB0byBmaW5kIHRoZSBtaXN0YWtlLlxuICAgIHZhciB1cHN0cmVhbSA9IHBhcmFtcy51cHN0cmVhbTtcbiAgICB2YXIgcmF3SXRlbTtcbiAgICB2YXIgY29uZGl0aW9uID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24ocGFyYW1zLmNvbmZpZywge1xuICAgICAgdmFsdWVHZXR0ZXJBdHRyTWFwOiBjcmVhdGVIYXNoTWFwKHtcbiAgICAgICAgZGltZW5zaW9uOiB0cnVlXG4gICAgICB9KSxcbiAgICAgIHByZXBhcmVHZXRWYWx1ZTogZnVuY3Rpb24gKGV4cHJPcHRpb24pIHtcbiAgICAgICAgdmFyIGVyck1zZyA9ICcnO1xuICAgICAgICB2YXIgZGltTG9vc2UgPSBleHByT3B0aW9uLmRpbWVuc2lvbjtcblxuICAgICAgICBpZiAoIWhhc093bihleHByT3B0aW9uLCAnZGltZW5zaW9uJykpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZXJyTXNnID0gbWFrZVByaW50YWJsZSgnUmVsYXRpb24gY29uZGl0aW9uIG11c3QgaGFzIHByb3AgXCJkaW1lbnNpb25cIiBzcGVjaWZpZWQuJywgJ0lsbGVnYWwgY29uZGl0aW9uOicsIGV4cHJPcHRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaW1JbmZvID0gdXBzdHJlYW0uZ2V0RGltZW5zaW9uSW5mbyhkaW1Mb29zZSk7XG5cbiAgICAgICAgaWYgKCFkaW1JbmZvKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGVyck1zZyA9IG1ha2VQcmludGFibGUoJ0NhbiBub3QgZmluZCBkaW1lbnNpb24gaW5mbyB2aWE6ICcgKyBkaW1Mb29zZSArICcuXFxuJywgJ0V4aXN0aW5nIGRpbWVuc2lvbnM6ICcsIHVwc3RyZWFtLmNsb25lQWxsRGltZW5zaW9uSW5mbygpLCAnLlxcbicsICdJbGxlZ2FsIGNvbmRpdGlvbjonLCBleHByT3B0aW9uLCAnLlxcbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGltSWR4OiBkaW1JbmZvLmluZGV4XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICByZXR1cm4gdXBzdHJlYW0ucmV0cmlldmVWYWx1ZUZyb21JdGVtKHJhd0l0ZW0sIHBhcmFtLmRpbUlkeCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHJlc3VsdERhdGEgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB1cHN0cmVhbS5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJhd0l0ZW0gPSB1cHN0cmVhbS5nZXRSYXdEYXRhSXRlbShpKTtcblxuICAgICAgaWYgKGNvbmRpdGlvbi5ldmFsdWF0ZSgpKSB7XG4gICAgICAgIHJlc3VsdERhdGEucHVzaChyYXdJdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogcmVzdWx0RGF0YVxuICAgIH07XG4gIH1cbn07IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IGZpbHRlclRyYW5zZm9ybSB9IGZyb20gJy4vZmlsdGVyVHJhbnNmb3JtJztcbmltcG9ydCB7IHNvcnRUcmFuc2Zvcm0gfSBmcm9tICcuL3NvcnRUcmFuc2Zvcm0nO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclRyYW5zZm9ybShmaWx0ZXJUcmFuc2Zvcm0pO1xuICByZWdpc3RlcnMucmVnaXN0ZXJUcmFuc2Zvcm0oc29ydFRyYW5zZm9ybSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IFNPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUywgU09VUkNFX0ZPUk1BVF9PQkpFQ1RfUk9XUyB9IGZyb20gJy4uLy4uL3V0aWwvdHlwZXMnO1xuaW1wb3J0IHsgbWFrZVByaW50YWJsZSwgdGhyb3dFcnJvciB9IGZyb20gJy4uLy4uL3V0aWwvbG9nJztcbmltcG9ydCB7IGVhY2ggfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgbm9ybWFsaXplVG9BcnJheSB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwnO1xuaW1wb3J0IHsgZ2V0UmF3VmFsdWVQYXJzZXIsIFNvcnRPcmRlckNvbXBhcmF0b3IgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9kYXRhVmFsdWVIZWxwZXInO1xudmFyIHNhbXBsZUxvZyA9ICcnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzYW1wbGVMb2cgPSBbJ1ZhbGlkIGNvbmZpZyBpcyBsaWtlOicsICd7IGRpbWVuc2lvbjogXCJhZ2VcIiwgb3JkZXI6IFwiYXNjXCIgfScsICdvciBbeyBkaW1lbnNpb246IFwiYWdlXCIsIG9yZGVyOiBcImFzY1wiXSwgeyBkaW1lbnNpb246IFwiZGF0ZVwiLCBvcmRlcjogXCJkZXNjXCIgfV0nXS5qb2luKCcgJyk7XG59XG5cbmV4cG9ydCB2YXIgc29ydFRyYW5zZm9ybSA9IHtcbiAgdHlwZTogJ2VjaGFydHM6c29ydCcsXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciB1cHN0cmVhbSA9IHBhcmFtcy51cHN0cmVhbTtcbiAgICB2YXIgY29uZmlnID0gcGFyYW1zLmNvbmZpZztcbiAgICB2YXIgZXJyTXNnID0gJyc7IC8vIE5vcm1hbGl6ZVxuICAgIC8vIGNvbnN0IG9yZGVyRXhwckxpc3Q6IE9yZGVyRXhwcmVzc2lvbltdID0gaXNBcnJheShjb25maWdbMF0pXG4gICAgLy8gICAgID8gY29uZmlnIGFzIE9yZGVyRXhwcmVzc2lvbltdXG4gICAgLy8gICAgIDogW2NvbmZpZyBhcyBPcmRlckV4cHJlc3Npb25dO1xuXG4gICAgdmFyIG9yZGVyRXhwckxpc3QgPSBub3JtYWxpemVUb0FycmF5KGNvbmZpZyk7XG5cbiAgICBpZiAoIW9yZGVyRXhwckxpc3QubGVuZ3RoKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBlcnJNc2cgPSAnRW1wdHkgYGNvbmZpZ2AgaW4gc29ydCB0cmFuc2Zvcm0uJztcbiAgICAgIH1cblxuICAgICAgdGhyb3dFcnJvcihlcnJNc2cpO1xuICAgIH1cblxuICAgIHZhciBvcmRlckRlZkxpc3QgPSBbXTtcbiAgICBlYWNoKG9yZGVyRXhwckxpc3QsIGZ1bmN0aW9uIChvcmRlckV4cHIpIHtcbiAgICAgIHZhciBkaW1Mb29zZSA9IG9yZGVyRXhwci5kaW1lbnNpb247XG4gICAgICB2YXIgb3JkZXIgPSBvcmRlckV4cHIub3JkZXI7XG4gICAgICB2YXIgcGFyc2VyTmFtZSA9IG9yZGVyRXhwci5wYXJzZXI7XG4gICAgICB2YXIgaW5jb21wYXJhYmxlID0gb3JkZXJFeHByLmluY29tcGFyYWJsZTtcblxuICAgICAgaWYgKGRpbUxvb3NlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBlcnJNc2cgPSAnU29ydCB0cmFuc2Zvcm0gY29uZmlnIG11c3QgaGFzIFwiZGltZW5zaW9uXCIgc3BlY2lmaWVkLicgKyBzYW1wbGVMb2c7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcmRlciAhPT0gJ2FzYycgJiYgb3JkZXIgIT09ICdkZXNjJykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGVyck1zZyA9ICdTb3J0IHRyYW5zZm9ybSBjb25maWcgbXVzdCBoYXMgXCJvcmRlclwiIHNwZWNpZmllZC4nICsgc2FtcGxlTG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3dFcnJvcihlcnJNc2cpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jb21wYXJhYmxlICYmIGluY29tcGFyYWJsZSAhPT0gJ21pbicgJiYgaW5jb21wYXJhYmxlICE9PSAnbWF4Jykge1xuICAgICAgICB2YXIgZXJyTXNnXzEgPSAnJztcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGVyck1zZ18xID0gJ2luY29tcGFyYWJsZSBtdXN0IGJlIFwibWluXCIgb3IgXCJtYXhcIiByYXRoZXIgdGhhbiBcIicgKyBpbmNvbXBhcmFibGUgKyAnXCIuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93RXJyb3IoZXJyTXNnXzEpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3JkZXIgIT09ICdhc2MnICYmIG9yZGVyICE9PSAnZGVzYycpIHtcbiAgICAgICAgdmFyIGVyck1zZ18yID0gJyc7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBlcnJNc2dfMiA9ICdvcmRlciBtdXN0IGJlIFwiYXNjXCIgb3IgXCJkZXNjXCIgcmF0aGVyIHRoYW4gXCInICsgb3JkZXIgKyAnXCIuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93RXJyb3IoZXJyTXNnXzIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGltSW5mbyA9IHVwc3RyZWFtLmdldERpbWVuc2lvbkluZm8oZGltTG9vc2UpO1xuXG4gICAgICBpZiAoIWRpbUluZm8pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBlcnJNc2cgPSBtYWtlUHJpbnRhYmxlKCdDYW4gbm90IGZpbmQgZGltZW5zaW9uIGluZm8gdmlhOiAnICsgZGltTG9vc2UgKyAnLlxcbicsICdFeGlzdGluZyBkaW1lbnNpb25zOiAnLCB1cHN0cmVhbS5jbG9uZUFsbERpbWVuc2lvbkluZm8oKSwgJy5cXG4nLCAnSWxsZWdhbCBjb25maWc6Jywgb3JkZXJFeHByLCAnLlxcbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3dFcnJvcihlcnJNc2cpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyc2VyID0gcGFyc2VyTmFtZSA/IGdldFJhd1ZhbHVlUGFyc2VyKHBhcnNlck5hbWUpIDogbnVsbDtcblxuICAgICAgaWYgKHBhcnNlck5hbWUgJiYgIXBhcnNlcikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGVyck1zZyA9IG1ha2VQcmludGFibGUoJ0ludmFsaWQgcGFyc2VyIG5hbWUgJyArIHBhcnNlck5hbWUgKyAnLlxcbicsICdJbGxlZ2FsIGNvbmZpZzonLCBvcmRlckV4cHIsICcuXFxuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gICAgICB9XG5cbiAgICAgIG9yZGVyRGVmTGlzdC5wdXNoKHtcbiAgICAgICAgZGltSWR4OiBkaW1JbmZvLmluZGV4LFxuICAgICAgICBwYXJzZXI6IHBhcnNlcixcbiAgICAgICAgY29tcGFyYXRvcjogbmV3IFNvcnRPcmRlckNvbXBhcmF0b3Iob3JkZXIsIGluY29tcGFyYWJsZSlcbiAgICAgIH0pO1xuICAgIH0pOyAvLyBUT0RPOiBzdXBwb3J0IGl0P1xuXG4gICAgdmFyIHNvdXJjZUZvcm1hdCA9IHVwc3RyZWFtLnNvdXJjZUZvcm1hdDtcblxuICAgIGlmIChzb3VyY2VGb3JtYXQgIT09IFNPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUyAmJiBzb3VyY2VGb3JtYXQgIT09IFNPVVJDRV9GT1JNQVRfT0JKRUNUX1JPV1MpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVyck1zZyA9ICdzb3VyY2VGb3JtYXQgXCInICsgc291cmNlRm9ybWF0ICsgJ1wiIGlzIG5vdCBzdXBwb3J0ZWQgeWV0JztcbiAgICAgIH1cblxuICAgICAgdGhyb3dFcnJvcihlcnJNc2cpO1xuICAgIH0gLy8gT3RoZXIgdXBzdHJlYW0gZm9ybWF0IGFyZSBhbGwgYXJyYXkuXG5cblxuICAgIHZhciByZXN1bHREYXRhID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdXBzdHJlYW0uY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHREYXRhLnB1c2godXBzdHJlYW0uZ2V0UmF3RGF0YUl0ZW0oaSkpO1xuICAgIH1cblxuICAgIHJlc3VsdERhdGEuc29ydChmdW5jdGlvbiAoaXRlbTAsIGl0ZW0xKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyRGVmTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb3JkZXJEZWYgPSBvcmRlckRlZkxpc3RbaV07XG4gICAgICAgIHZhciB2YWwwID0gdXBzdHJlYW0ucmV0cmlldmVWYWx1ZUZyb21JdGVtKGl0ZW0wLCBvcmRlckRlZi5kaW1JZHgpO1xuICAgICAgICB2YXIgdmFsMSA9IHVwc3RyZWFtLnJldHJpZXZlVmFsdWVGcm9tSXRlbShpdGVtMSwgb3JkZXJEZWYuZGltSWR4KTtcblxuICAgICAgICBpZiAob3JkZXJEZWYucGFyc2VyKSB7XG4gICAgICAgICAgdmFsMCA9IG9yZGVyRGVmLnBhcnNlcih2YWwwKTtcbiAgICAgICAgICB2YWwxID0gb3JkZXJEZWYucGFyc2VyKHZhbDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9yZGVyRGVmLmNvbXBhcmF0b3IuZXZhbHVhdGUodmFsMCwgdmFsMSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHJlc3VsdERhdGFcbiAgICB9O1xuICB9XG59OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IFZpc3VhbE1hcE1vZGVsIGZyb20gJy4vVmlzdWFsTWFwTW9kZWwnO1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG5pbXBvcnQgeyBpbmhlcml0RGVmYXVsdE9wdGlvbiB9IGZyb20gJy4uLy4uL3V0aWwvY29tcG9uZW50JzsgLy8gQ29uc3RhbnRcblxudmFyIERFRkFVTFRfQkFSX0JPVU5EID0gWzIwLCAxNDBdO1xuXG52YXIgQ29udGludW91c01vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKENvbnRpbnVvdXNNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBDb250aW51b3VzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gQ29udGludW91c01vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBDb250aW51b3VzTW9kZWwucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQgPSBmdW5jdGlvbiAobmV3T3B0aW9uLCBpc0luaXQpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMucmVzZXRFeHRlbnQoKTtcbiAgICB0aGlzLnJlc2V0VmlzdWFsKGZ1bmN0aW9uIChtYXBwaW5nT3B0aW9uKSB7XG4gICAgICBtYXBwaW5nT3B0aW9uLm1hcHBpbmdNZXRob2QgPSAnbGluZWFyJztcbiAgICAgIG1hcHBpbmdPcHRpb24uZGF0YUV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9yZXNldFJhbmdlKCk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIENvbnRpbnVvdXNNb2RlbC5wcm90b3R5cGUucmVzZXRJdGVtU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLnJlc2V0SXRlbVNpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHZhciBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemU7XG4gICAgKGl0ZW1TaXplWzBdID09IG51bGwgfHwgaXNOYU4oaXRlbVNpemVbMF0pKSAmJiAoaXRlbVNpemVbMF0gPSBERUZBVUxUX0JBUl9CT1VORFswXSk7XG4gICAgKGl0ZW1TaXplWzFdID09IG51bGwgfHwgaXNOYU4oaXRlbVNpemVbMV0pKSAmJiAoaXRlbVNpemVbMV0gPSBERUZBVUxUX0JBUl9CT1VORFsxXSk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIENvbnRpbnVvdXNNb2RlbC5wcm90b3R5cGUuX3Jlc2V0UmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGFFeHRlbnQgPSB0aGlzLmdldEV4dGVudCgpO1xuICAgIHZhciByYW5nZSA9IHRoaXMub3B0aW9uLnJhbmdlO1xuXG4gICAgaWYgKCFyYW5nZSB8fCByYW5nZS5hdXRvKSB7XG4gICAgICAvLyBgcmFuZ2VgIHNob3VsZCBhbHdheXMgYmUgYXJyYXkgKHNvIHdlIGRvbnQgdXNlIG90aGVyXG4gICAgICAvLyB2YWx1ZSBsaWtlICdhdXRvJykgZm9yIHVzZXItZnJpZW5kLiAoY29uc2lkZXIgZ2V0T3B0aW9uKS5cbiAgICAgIGRhdGFFeHRlbnQuYXV0byA9IDE7XG4gICAgICB0aGlzLm9wdGlvbi5yYW5nZSA9IGRhdGFFeHRlbnQ7XG4gICAgfSBlbHNlIGlmICh6clV0aWwuaXNBcnJheShyYW5nZSkpIHtcbiAgICAgIGlmIChyYW5nZVswXSA+IHJhbmdlWzFdKSB7XG4gICAgICAgIHJhbmdlLnJldmVyc2UoKTtcbiAgICAgIH1cblxuICAgICAgcmFuZ2VbMF0gPSBNYXRoLm1heChyYW5nZVswXSwgZGF0YUV4dGVudFswXSk7XG4gICAgICByYW5nZVsxXSA9IE1hdGgubWluKHJhbmdlWzFdLCBkYXRhRXh0ZW50WzFdKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIENvbnRpbnVvdXNNb2RlbC5wcm90b3R5cGUuY29tcGxldGVWaXN1YWxPcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5jb21wbGV0ZVZpc3VhbE9wdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgenJVdGlsLmVhY2godGhpcy5zdGF0ZUxpc3QsIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgdmFyIHN5bWJvbFNpemUgPSB0aGlzLm9wdGlvbi5jb250cm9sbGVyW3N0YXRlXS5zeW1ib2xTaXplO1xuXG4gICAgICBpZiAoc3ltYm9sU2l6ZSAmJiBzeW1ib2xTaXplWzBdICE9PSBzeW1ib2xTaXplWzFdKSB7XG4gICAgICAgIHN5bWJvbFNpemVbMF0gPSBzeW1ib2xTaXplWzFdIC8gMzsgLy8gRm9yIGdvb2QgbG9va2luZy5cbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIENvbnRpbnVvdXNNb2RlbC5wcm90b3R5cGUuc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICB0aGlzLm9wdGlvbi5yYW5nZSA9IHNlbGVjdGVkLnNsaWNlKCk7XG5cbiAgICB0aGlzLl9yZXNldFJhbmdlKCk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqL1xuXG5cbiAgQ29udGludW91c01vZGVsLnByb3RvdHlwZS5nZXRTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YUV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIGRhdGFJbnRlcnZhbCA9IG51bWJlclV0aWwuYXNjKCh0aGlzLmdldCgncmFuZ2UnKSB8fCBbXSkuc2xpY2UoKSk7IC8vIENsYW1wXG5cbiAgICBkYXRhSW50ZXJ2YWxbMF0gPiBkYXRhRXh0ZW50WzFdICYmIChkYXRhSW50ZXJ2YWxbMF0gPSBkYXRhRXh0ZW50WzFdKTtcbiAgICBkYXRhSW50ZXJ2YWxbMV0gPiBkYXRhRXh0ZW50WzFdICYmIChkYXRhSW50ZXJ2YWxbMV0gPSBkYXRhRXh0ZW50WzFdKTtcbiAgICBkYXRhSW50ZXJ2YWxbMF0gPCBkYXRhRXh0ZW50WzBdICYmIChkYXRhSW50ZXJ2YWxbMF0gPSBkYXRhRXh0ZW50WzBdKTtcbiAgICBkYXRhSW50ZXJ2YWxbMV0gPCBkYXRhRXh0ZW50WzBdICYmIChkYXRhSW50ZXJ2YWxbMV0gPSBkYXRhRXh0ZW50WzBdKTtcbiAgICByZXR1cm4gZGF0YUludGVydmFsO1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgQ29udGludW91c01vZGVsLnByb3RvdHlwZS5nZXRWYWx1ZVN0YXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5vcHRpb24ucmFuZ2U7XG4gICAgdmFyIGRhdGFFeHRlbnQgPSB0aGlzLmdldEV4dGVudCgpOyAvLyBXaGVuIHJhbmdlWzBdID09PSBkYXRhRXh0ZW50WzBdLCBhbnkgdmFsdWUgbGFyZ2VyIHRoYW4gZGF0YUV4dGVudFswXSBtYXBzIHRvICdpblJhbmdlJy5cbiAgICAvLyByYW5nZVsxXSBpcyBwcm9jZXNzZWQgbGlrZXdpc2UuXG5cbiAgICByZXR1cm4gKHJhbmdlWzBdIDw9IGRhdGFFeHRlbnRbMF0gfHwgcmFuZ2VbMF0gPD0gdmFsdWUpICYmIChyYW5nZVsxXSA+PSBkYXRhRXh0ZW50WzFdIHx8IHZhbHVlIDw9IHJhbmdlWzFdKSA/ICdpblJhbmdlJyA6ICdvdXRPZlJhbmdlJztcbiAgfTtcblxuICBDb250aW51b3VzTW9kZWwucHJvdG90eXBlLmZpbmRUYXJnZXREYXRhSW5kaWNlcyA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB0aGlzLmVhY2hUYXJnZXRTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgZGF0YUluZGljZXMgPSBbXTtcbiAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgZGF0YS5lYWNoKHRoaXMuZ2V0RGF0YURpbWVuc2lvbihkYXRhKSwgZnVuY3Rpb24gKHZhbHVlLCBkYXRhSW5kZXgpIHtcbiAgICAgICAgcmFuZ2VbMF0gPD0gdmFsdWUgJiYgdmFsdWUgPD0gcmFuZ2VbMV0gJiYgZGF0YUluZGljZXMucHVzaChkYXRhSW5kZXgpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIHNlcmllc0lkOiBzZXJpZXNNb2RlbC5pZCxcbiAgICAgICAgZGF0YUluZGV4OiBkYXRhSW5kaWNlc1xuICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgLyoqXG4gICAqIEBpbXBsZW1lbnRcbiAgICovXG5cblxuICBDb250aW51b3VzTW9kZWwucHJvdG90eXBlLmdldFZpc3VhbE1ldGEgPSBmdW5jdGlvbiAoZ2V0Q29sb3JWaXN1YWwpIHtcbiAgICB2YXIgb1ZhbHMgPSBnZXRDb2xvclN0b3BWYWx1ZXModGhpcywgJ291dE9mUmFuZ2UnLCB0aGlzLmdldEV4dGVudCgpKTtcbiAgICB2YXIgaVZhbHMgPSBnZXRDb2xvclN0b3BWYWx1ZXModGhpcywgJ2luUmFuZ2UnLCB0aGlzLm9wdGlvbi5yYW5nZS5zbGljZSgpKTtcbiAgICB2YXIgc3RvcHMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHNldFN0b3AodmFsdWUsIHZhbHVlU3RhdGUpIHtcbiAgICAgIHN0b3BzLnB1c2goe1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGNvbG9yOiBnZXRDb2xvclZpc3VhbCh2YWx1ZSwgdmFsdWVTdGF0ZSlcbiAgICAgIH0pO1xuICAgIH0gLy8gRm9ybWF0IHRvOiBvdXRPZlJhbmdlIC0tIGluUmFuZ2UgLS0gb3V0T2ZSYW5nZS5cblxuXG4gICAgdmFyIGlJZHggPSAwO1xuICAgIHZhciBvSWR4ID0gMDtcbiAgICB2YXIgaUxlbiA9IGlWYWxzLmxlbmd0aDtcbiAgICB2YXIgb0xlbiA9IG9WYWxzLmxlbmd0aDtcblxuICAgIGZvciAoOyBvSWR4IDwgb0xlbiAmJiAoIWlWYWxzLmxlbmd0aCB8fCBvVmFsc1tvSWR4XSA8PSBpVmFsc1swXSk7IG9JZHgrKykge1xuICAgICAgLy8gSWYgb1ZhbFtvSWR4XSA9PT0gaVZhbHNbaUlkeF0sIG9WYWxbb0lkeF0gc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgICBpZiAob1ZhbHNbb0lkeF0gPCBpVmFsc1tpSWR4XSkge1xuICAgICAgICBzZXRTdG9wKG9WYWxzW29JZHhdLCAnb3V0T2ZSYW5nZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGZpcnN0ID0gMTsgaUlkeCA8IGlMZW47IGlJZHgrKywgZmlyc3QgPSAwKSB7XG4gICAgICAvLyBJZiByYW5nZSBpcyBmdWxsLCB2YWx1ZSBiZXlvbmQgbWluLCBtYXggd2lsbCBiZSBjbGFtcGVkLlxuICAgICAgLy8gbWFrZSBhIHNpbmd1bGFyaXR5XG4gICAgICBmaXJzdCAmJiBzdG9wcy5sZW5ndGggJiYgc2V0U3RvcChpVmFsc1tpSWR4XSwgJ291dE9mUmFuZ2UnKTtcbiAgICAgIHNldFN0b3AoaVZhbHNbaUlkeF0sICdpblJhbmdlJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgZmlyc3QgPSAxOyBvSWR4IDwgb0xlbjsgb0lkeCsrKSB7XG4gICAgICBpZiAoIWlWYWxzLmxlbmd0aCB8fCBpVmFsc1tpVmFscy5sZW5ndGggLSAxXSA8IG9WYWxzW29JZHhdKSB7XG4gICAgICAgIC8vIG1ha2UgYSBzaW5ndWxhcml0eVxuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICBzdG9wcy5sZW5ndGggJiYgc2V0U3RvcChzdG9wc1tzdG9wcy5sZW5ndGggLSAxXS52YWx1ZSwgJ291dE9mUmFuZ2UnKTtcbiAgICAgICAgICBmaXJzdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRTdG9wKG9WYWxzW29JZHhdLCAnb3V0T2ZSYW5nZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdG9wc0xlbiA9IHN0b3BzLmxlbmd0aDtcbiAgICByZXR1cm4ge1xuICAgICAgc3RvcHM6IHN0b3BzLFxuICAgICAgb3V0ZXJDb2xvcnM6IFtzdG9wc0xlbiA/IHN0b3BzWzBdLmNvbG9yIDogJ3RyYW5zcGFyZW50Jywgc3RvcHNMZW4gPyBzdG9wc1tzdG9wc0xlbiAtIDFdLmNvbG9yIDogJ3RyYW5zcGFyZW50J11cbiAgICB9O1xuICB9O1xuXG4gIENvbnRpbnVvdXNNb2RlbC50eXBlID0gJ3Zpc3VhbE1hcC5jb250aW51b3VzJztcbiAgQ29udGludW91c01vZGVsLmRlZmF1bHRPcHRpb24gPSBpbmhlcml0RGVmYXVsdE9wdGlvbihWaXN1YWxNYXBNb2RlbC5kZWZhdWx0T3B0aW9uLCB7XG4gICAgYWxpZ246ICdhdXRvJyxcbiAgICBjYWxjdWxhYmxlOiBmYWxzZSxcbiAgICBob3Zlckxpbms6IHRydWUsXG4gICAgcmVhbHRpbWU6IHRydWUsXG4gICAgaGFuZGxlSWNvbjogJ3BhdGg6Ly9NLTExLjM5LDkuNzdoMGEzLjUsMy41LDAsMCwxLTMuNSwzLjVoLTIyYTMuNSwzLjUsMCwwLDEtMy41LTMuNWgwYTMuNSwzLjUsMCwwLDEsMy41LTMuNWgyMkEzLjUsMy41LDAsMCwxLTExLjM5LDkuNzdaJyxcbiAgICBoYW5kbGVTaXplOiAnMTIwJScsXG4gICAgaGFuZGxlU3R5bGU6IHtcbiAgICAgIGJvcmRlckNvbG9yOiAnI2ZmZicsXG4gICAgICBib3JkZXJXaWR0aDogMVxuICAgIH0sXG4gICAgaW5kaWNhdG9ySWNvbjogJ2NpcmNsZScsXG4gICAgaW5kaWNhdG9yU2l6ZTogJzUwJScsXG4gICAgaW5kaWNhdG9yU3R5bGU6IHtcbiAgICAgIGJvcmRlckNvbG9yOiAnI2ZmZicsXG4gICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgIHNoYWRvd0JsdXI6IDIsXG4gICAgICBzaGFkb3dPZmZzZXRYOiAxLFxuICAgICAgc2hhZG93T2Zmc2V0WTogMSxcbiAgICAgIHNoYWRvd0NvbG9yOiAncmdiYSgwLDAsMCwwLjIpJ1xuICAgIH0gLy8gZW1waGFzaXM6IHtcbiAgICAvLyAgICAgaGFuZGxlU3R5bGU6IHtcbiAgICAvLyAgICAgICAgIHNoYWRvd0JsdXI6IDMsXG4gICAgLy8gICAgICAgICBzaGFkb3dPZmZzZXRYOiAxLFxuICAgIC8vICAgICAgICAgc2hhZG93T2Zmc2V0WTogMSxcbiAgICAvLyAgICAgICAgIHNoYWRvd0NvbG9yOiAncmdiYSgwLDAsMCwwLjIpJ1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gIH0pO1xuICByZXR1cm4gQ29udGludW91c01vZGVsO1xufShWaXN1YWxNYXBNb2RlbCk7XG5cbmZ1bmN0aW9uIGdldENvbG9yU3RvcFZhbHVlcyh2aXN1YWxNYXBNb2RlbCwgdmFsdWVTdGF0ZSwgZGF0YUV4dGVudCkge1xuICBpZiAoZGF0YUV4dGVudFswXSA9PT0gZGF0YUV4dGVudFsxXSkge1xuICAgIHJldHVybiBkYXRhRXh0ZW50LnNsaWNlKCk7XG4gIH0gLy8gV2hlbiB1c2luZyBjb2xvckh1ZSBtYXBwaW5nLCBpdCBpcyBub3QgbGluZWFyIGNvbG9yIGFueSBtb3JlLlxuICAvLyBNb3Jlb3ZlciwgY2FudmFzIGdyYWRpZW50IHNlZW1zIG5vdCB0byBiZSBhY2N1cmF0ZSBsaW5lYXIuXG4gIC8vIEZJWE1FXG4gIC8vIFNob3VsZCBiZSBhcmJpdHJhcnkgdmFsdWUgMTAwPyBvciBiYXNlZCBvbiBwaXhlbCBzaXplP1xuXG5cbiAgdmFyIGNvdW50ID0gMjAwO1xuICB2YXIgc3RlcCA9IChkYXRhRXh0ZW50WzFdIC0gZGF0YUV4dGVudFswXSkgLyBjb3VudDtcbiAgdmFyIHZhbHVlID0gZGF0YUV4dGVudFswXTtcbiAgdmFyIHN0b3BWYWx1ZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8PSBjb3VudCAmJiB2YWx1ZSA8IGRhdGFFeHRlbnRbMV07IGkrKykge1xuICAgIHN0b3BWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgdmFsdWUgKz0gc3RlcDtcbiAgfVxuXG4gIHN0b3BWYWx1ZXMucHVzaChkYXRhRXh0ZW50WzFdKTtcbiAgcmV0dXJuIHN0b3BWYWx1ZXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRpbnVvdXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBMaW5lYXJHcmFkaWVudCBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL0xpbmVhckdyYWRpZW50JztcbmltcG9ydCAqIGFzIGV2ZW50VG9vbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL2V2ZW50JztcbmltcG9ydCBWaXN1YWxNYXBWaWV3IGZyb20gJy4vVmlzdWFsTWFwVmlldyc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgKiBhcyBudW1iZXJVdGlsIGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyJztcbmltcG9ydCBzbGlkZXJNb3ZlIGZyb20gJy4uL2hlbHBlci9zbGlkZXJNb3ZlJztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuL2hlbHBlcic7XG5pbXBvcnQgKiBhcyBtb2RlbFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG5pbXBvcnQgeyBwYXJzZVBlcmNlbnQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb250YWluL3RleHQnO1xuaW1wb3J0IHsgc2V0QXNIaWdoRG93bkRpc3BhdGNoZXIgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcyc7XG5pbXBvcnQgeyBjcmVhdGVTeW1ib2wgfSBmcm9tICcuLi8uLi91dGlsL3N5bWJvbCc7XG5pbXBvcnQgWlJJbWFnZSBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlJztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZSc7XG52YXIgbGluZWFyTWFwID0gbnVtYmVyVXRpbC5saW5lYXJNYXA7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7IC8vIEFyYml0cmFyeSB2YWx1ZVxuXG52YXIgSE9WRVJfTElOS19TSVpFID0gMTI7XG52YXIgSE9WRVJfTElOS19PVVQgPSA2OyAvLyBOb3RpY2U6XG4vLyBBbnkgXCJpbnRlcnZhbFwiIHNob3VsZCBiZSBieSB0aGUgb3JkZXIgb2YgW2xvdywgaGlnaF0uXG4vLyBcImhhbmRsZTBcIiAoaGFuZGxlSW5kZXggPT09IDApIG1hcHMgdG9cbi8vIGxvdyBkYXRhIHZhbHVlOiB0aGlzLl9kYXRhSW50ZXJ2YWxbMF0gYW5kIGhhcyBsb3cgY29vcmQuXG4vLyBcImhhbmRsZTFcIiAoaGFuZGxlSW5kZXggPT09IDEpIG1hcHMgdG9cbi8vIGhpZ2ggZGF0YSB2YWx1ZTogdGhpcy5fZGF0YUludGVydmFsWzFdIGFuZCBoYXMgaGlnaCBjb29yZC5cbi8vIFRoZSBsb2dpYyBvZiB0cmFuc2Zvcm0gaXMgaW1wbGVtZW50ZWQgaW4gdGhpcy5fY3JlYXRlQmFyR3JvdXAuXG5cbnZhciBDb250aW51b3VzVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDb250aW51b3VzVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBDb250aW51b3VzVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBDb250aW51b3VzVmlldy50eXBlO1xuICAgIF90aGlzLl9zaGFwZXMgPSB7fTtcbiAgICBfdGhpcy5fZGF0YUludGVydmFsID0gW107XG4gICAgX3RoaXMuX2hhbmRsZUVuZHMgPSBbXTtcbiAgICBfdGhpcy5faG92ZXJMaW5rRGF0YUluZGljZXMgPSBbXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuZG9SZW5kZXIgPSBmdW5jdGlvbiAodmlzdWFsTWFwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRoaXMuX2FwaSA9IGFwaTtcblxuICAgIGlmICghcGF5bG9hZCB8fCBwYXlsb2FkLnR5cGUgIT09ICdzZWxlY3REYXRhUmFuZ2UnIHx8IHBheWxvYWQuZnJvbSAhPT0gdGhpcy51aWQpIHtcbiAgICAgIHRoaXMuX2J1aWxkVmlldygpO1xuICAgIH1cbiAgfTtcblxuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX2J1aWxkVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHZhciB2aXN1YWxNYXBNb2RlbCA9IHRoaXMudmlzdWFsTWFwTW9kZWw7XG4gICAgdmFyIHRoaXNHcm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdGhpcy5fb3JpZW50ID0gdmlzdWFsTWFwTW9kZWwuZ2V0KCdvcmllbnQnKTtcbiAgICB0aGlzLl91c2VIYW5kbGUgPSB2aXN1YWxNYXBNb2RlbC5nZXQoJ2NhbGN1bGFibGUnKTtcblxuICAgIHRoaXMuX3Jlc2V0SW50ZXJ2YWwoKTtcblxuICAgIHRoaXMuX3JlbmRlckJhcih0aGlzR3JvdXApO1xuXG4gICAgdmFyIGRhdGFSYW5nZVRleHQgPSB2aXN1YWxNYXBNb2RlbC5nZXQoJ3RleHQnKTtcblxuICAgIHRoaXMuX3JlbmRlckVuZHNUZXh0KHRoaXNHcm91cCwgZGF0YVJhbmdlVGV4dCwgMCk7XG5cbiAgICB0aGlzLl9yZW5kZXJFbmRzVGV4dCh0aGlzR3JvdXAsIGRhdGFSYW5nZVRleHQsIDEpOyAvLyBEbyB0aGlzIGZvciBiYWNrZ3JvdW5kIHNpemUgY2FsY3VsYXRpb24uXG5cblxuICAgIHRoaXMuX3VwZGF0ZVZpZXcodHJ1ZSk7IC8vIEFmdGVyIHVwZGF0aW5nIHZpZXcsIGlubmVyIHNoYXBlcyBpcyBidWlsdCBjb21wbGV0ZWx5LFxuICAgIC8vIGFuZCB0aGVuIGJhY2tncm91bmQgY2FuIGJlIHJlbmRlcmVkLlxuXG5cbiAgICB0aGlzLnJlbmRlckJhY2tncm91bmQodGhpc0dyb3VwKTsgLy8gUmVhbCB1cGRhdGUgdmlld1xuXG4gICAgdGhpcy5fdXBkYXRlVmlldygpO1xuXG4gICAgdGhpcy5fZW5hYmxlSG92ZXJMaW5rVG9TZXJpZXMoKTtcblxuICAgIHRoaXMuX2VuYWJsZUhvdmVyTGlua0Zyb21TZXJpZXMoKTtcblxuICAgIHRoaXMucG9zaXRpb25Hcm91cCh0aGlzR3JvdXApO1xuICB9O1xuXG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fcmVuZGVyRW5kc1RleHQgPSBmdW5jdGlvbiAoZ3JvdXAsIGRhdGFSYW5nZVRleHQsIGVuZHNJbmRleCkge1xuICAgIGlmICghZGF0YVJhbmdlVGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ29tcGF0aWJsZSB3aXRoIGVjMiwgdGV4dFswXSBtYXAgdG8gaGlnaCB2YWx1ZSwgdGV4dFsxXSBtYXAgbG93IHZhbHVlLlxuXG5cbiAgICB2YXIgdGV4dCA9IGRhdGFSYW5nZVRleHRbMSAtIGVuZHNJbmRleF07XG4gICAgdGV4dCA9IHRleHQgIT0gbnVsbCA/IHRleHQgKyAnJyA6ICcnO1xuICAgIHZhciB2aXN1YWxNYXBNb2RlbCA9IHRoaXMudmlzdWFsTWFwTW9kZWw7XG4gICAgdmFyIHRleHRHYXAgPSB2aXN1YWxNYXBNb2RlbC5nZXQoJ3RleHRHYXAnKTtcbiAgICB2YXIgaXRlbVNpemUgPSB2aXN1YWxNYXBNb2RlbC5pdGVtU2l6ZTtcbiAgICB2YXIgYmFyR3JvdXAgPSB0aGlzLl9zaGFwZXMubWFpbkdyb3VwO1xuXG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fYXBwbHlUcmFuc2Zvcm0oW2l0ZW1TaXplWzBdIC8gMiwgZW5kc0luZGV4ID09PSAwID8gLXRleHRHYXAgOiBpdGVtU2l6ZVsxXSArIHRleHRHYXBdLCBiYXJHcm91cCk7XG5cbiAgICB2YXIgYWxpZ24gPSB0aGlzLl9hcHBseVRyYW5zZm9ybShlbmRzSW5kZXggPT09IDAgPyAnYm90dG9tJyA6ICd0b3AnLCBiYXJHcm91cCk7XG5cbiAgICB2YXIgb3JpZW50ID0gdGhpcy5fb3JpZW50O1xuICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IHRoaXMudmlzdWFsTWFwTW9kZWwudGV4dFN0eWxlTW9kZWw7XG4gICAgdGhpcy5ncm91cC5hZGQobmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICBzdHlsZToge1xuICAgICAgICB4OiBwb3NpdGlvblswXSxcbiAgICAgICAgeTogcG9zaXRpb25bMV0sXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gJ21pZGRsZScgOiBhbGlnbixcbiAgICAgICAgYWxpZ246IG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gYWxpZ24gOiAnY2VudGVyJyxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgZm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxuICAgICAgICBmaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKVxuICAgICAgfVxuICAgIH0pKTtcbiAgfTtcblxuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX3JlbmRlckJhciA9IGZ1bmN0aW9uICh0YXJnZXRHcm91cCkge1xuICAgIHZhciB2aXN1YWxNYXBNb2RlbCA9IHRoaXMudmlzdWFsTWFwTW9kZWw7XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuX3NoYXBlcztcbiAgICB2YXIgaXRlbVNpemUgPSB2aXN1YWxNYXBNb2RlbC5pdGVtU2l6ZTtcbiAgICB2YXIgb3JpZW50ID0gdGhpcy5fb3JpZW50O1xuICAgIHZhciB1c2VIYW5kbGUgPSB0aGlzLl91c2VIYW5kbGU7XG4gICAgdmFyIGl0ZW1BbGlnbiA9IGhlbHBlci5nZXRJdGVtQWxpZ24odmlzdWFsTWFwTW9kZWwsIHRoaXMuYXBpLCBpdGVtU2l6ZSk7XG5cbiAgICB2YXIgbWFpbkdyb3VwID0gc2hhcGVzLm1haW5Hcm91cCA9IHRoaXMuX2NyZWF0ZUJhckdyb3VwKGl0ZW1BbGlnbik7XG5cbiAgICB2YXIgZ3JhZGllbnRCYXJHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgbWFpbkdyb3VwLmFkZChncmFkaWVudEJhckdyb3VwKTsgLy8gQmFyXG5cbiAgICBncmFkaWVudEJhckdyb3VwLmFkZChzaGFwZXMub3V0T2ZSYW5nZSA9IGNyZWF0ZVBvbHlnb24oKSk7XG4gICAgZ3JhZGllbnRCYXJHcm91cC5hZGQoc2hhcGVzLmluUmFuZ2UgPSBjcmVhdGVQb2x5Z29uKG51bGwsIHVzZUhhbmRsZSA/IGdldEN1cnNvcih0aGlzLl9vcmllbnQpIDogbnVsbCwgenJVdGlsLmJpbmQodGhpcy5fZHJhZ0hhbmRsZSwgdGhpcywgJ2FsbCcsIGZhbHNlKSwgenJVdGlsLmJpbmQodGhpcy5fZHJhZ0hhbmRsZSwgdGhpcywgJ2FsbCcsIHRydWUpKSk7IC8vIEEgYm9yZGVyIHJhZGl1cyBjbGlwLlxuXG4gICAgZ3JhZGllbnRCYXJHcm91cC5zZXRDbGlwUGF0aChuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiBpdGVtU2l6ZVswXSxcbiAgICAgICAgaGVpZ2h0OiBpdGVtU2l6ZVsxXSxcbiAgICAgICAgcjogM1xuICAgICAgfVxuICAgIH0pKTtcbiAgICB2YXIgdGV4dFJlY3QgPSB2aXN1YWxNYXBNb2RlbC50ZXh0U3R5bGVNb2RlbC5nZXRUZXh0UmVjdCgn5Zu9Jyk7XG4gICAgdmFyIHRleHRTaXplID0gbWF0aE1heCh0ZXh0UmVjdC53aWR0aCwgdGV4dFJlY3QuaGVpZ2h0KTsgLy8gSGFuZGxlXG5cbiAgICBpZiAodXNlSGFuZGxlKSB7XG4gICAgICBzaGFwZXMuaGFuZGxlVGh1bWJzID0gW107XG4gICAgICBzaGFwZXMuaGFuZGxlTGFiZWxzID0gW107XG4gICAgICBzaGFwZXMuaGFuZGxlTGFiZWxQb2ludHMgPSBbXTtcblxuICAgICAgdGhpcy5fY3JlYXRlSGFuZGxlKHZpc3VhbE1hcE1vZGVsLCBtYWluR3JvdXAsIDAsIGl0ZW1TaXplLCB0ZXh0U2l6ZSwgb3JpZW50KTtcblxuICAgICAgdGhpcy5fY3JlYXRlSGFuZGxlKHZpc3VhbE1hcE1vZGVsLCBtYWluR3JvdXAsIDEsIGl0ZW1TaXplLCB0ZXh0U2l6ZSwgb3JpZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLl9jcmVhdGVJbmRpY2F0b3IodmlzdWFsTWFwTW9kZWwsIG1haW5Hcm91cCwgaXRlbVNpemUsIHRleHRTaXplLCBvcmllbnQpO1xuXG4gICAgdGFyZ2V0R3JvdXAuYWRkKG1haW5Hcm91cCk7XG4gIH07XG5cbiAgQ29udGludW91c1ZpZXcucHJvdG90eXBlLl9jcmVhdGVIYW5kbGUgPSBmdW5jdGlvbiAodmlzdWFsTWFwTW9kZWwsIG1haW5Hcm91cCwgaGFuZGxlSW5kZXgsIGl0ZW1TaXplLCB0ZXh0U2l6ZSwgb3JpZW50KSB7XG4gICAgdmFyIG9uRHJpZnQgPSB6clV0aWwuYmluZCh0aGlzLl9kcmFnSGFuZGxlLCB0aGlzLCBoYW5kbGVJbmRleCwgZmFsc2UpO1xuICAgIHZhciBvbkRyYWdFbmQgPSB6clV0aWwuYmluZCh0aGlzLl9kcmFnSGFuZGxlLCB0aGlzLCBoYW5kbGVJbmRleCwgdHJ1ZSk7XG4gICAgdmFyIGhhbmRsZVNpemUgPSBwYXJzZVBlcmNlbnQodmlzdWFsTWFwTW9kZWwuZ2V0KCdoYW5kbGVTaXplJyksIGl0ZW1TaXplWzBdKTtcbiAgICB2YXIgaGFuZGxlVGh1bWIgPSBjcmVhdGVTeW1ib2wodmlzdWFsTWFwTW9kZWwuZ2V0KCdoYW5kbGVJY29uJyksIC1oYW5kbGVTaXplIC8gMiwgLWhhbmRsZVNpemUgLyAyLCBoYW5kbGVTaXplLCBoYW5kbGVTaXplLCBudWxsLCB0cnVlKTtcbiAgICB2YXIgY3Vyc29yID0gZ2V0Q3Vyc29yKHRoaXMuX29yaWVudCk7XG4gICAgaGFuZGxlVGh1bWIuYXR0cih7XG4gICAgICBjdXJzb3I6IGN1cnNvcixcbiAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgIGRyaWZ0OiBvbkRyaWZ0LFxuICAgICAgb25kcmFnZW5kOiBvbkRyYWdFbmQsXG4gICAgICBvbm1vdXNlbW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZXZlbnRUb29sLnN0b3AoZS5ldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaGFuZGxlVGh1bWIueCA9IGl0ZW1TaXplWzBdIC8gMjtcbiAgICBoYW5kbGVUaHVtYi51c2VTdHlsZSh2aXN1YWxNYXBNb2RlbC5nZXRNb2RlbCgnaGFuZGxlU3R5bGUnKS5nZXRJdGVtU3R5bGUoKSk7XG4gICAgaGFuZGxlVGh1bWIuc2V0U3R5bGUoe1xuICAgICAgc3Ryb2tlTm9TY2FsZTogdHJ1ZSxcbiAgICAgIHN0cm9rZUZpcnN0OiB0cnVlXG4gICAgfSk7XG4gICAgaGFuZGxlVGh1bWIuc3R5bGUubGluZVdpZHRoICo9IDI7XG4gICAgaGFuZGxlVGh1bWIuZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJykuc3R5bGUgPSB2aXN1YWxNYXBNb2RlbC5nZXRNb2RlbChbJ2VtcGhhc2lzJywgJ2hhbmRsZVN0eWxlJ10pLmdldEl0ZW1TdHlsZSgpO1xuICAgIHNldEFzSGlnaERvd25EaXNwYXRjaGVyKGhhbmRsZVRodW1iLCB0cnVlKTtcbiAgICBtYWluR3JvdXAuYWRkKGhhbmRsZVRodW1iKTsgLy8gVGV4dCBpcyBhbHdheXMgaG9yaXpvbnRhbCBsYXlvdXQgYnV0IHNob3VsZCBub3QgYmUgZWZmZWN0ZWQgYnlcbiAgICAvLyB0cmFuc2Zvcm0gKG9yaWVudC9pbnZlcnNlKS4gU28gbGFiZWwgaXMgYnVpbHQgc2VwYXJhdGVseSBidXQgbm90XG4gICAgLy8gdXNlIHpyZW5kZXIvZ3JhcGhpYy9oZWxwZXIvUmVjdFRleHQsIGFuZCBpcyBsb2NhdGVkIGJhc2VkIG9uIHZpZXdcbiAgICAvLyBncm91cCAoYWNjb3JkaW5nIHRvIGhhbmRsZUxhYmVsUG9pbnQpIGJ1dCBub3QgYmFyR3JvdXAuXG5cbiAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSB0aGlzLnZpc3VhbE1hcE1vZGVsLnRleHRTdHlsZU1vZGVsO1xuICAgIHZhciBoYW5kbGVMYWJlbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgY3Vyc29yOiBjdXJzb3IsXG4gICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICBkcmlmdDogb25EcmlmdCxcbiAgICAgIG9ubW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBGb3QgbW9iaWxlIGRldmljZW0sIHByZXZlbnQgc2NyZWVuIHNsaWRlciBvbiB0aGUgYnV0dG9uLlxuICAgICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBvbmRyYWdlbmQ6IG9uRHJhZ0VuZCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHRleHQ6ICcnLFxuICAgICAgICBmb250OiB0ZXh0U3R5bGVNb2RlbC5nZXRGb250KCksXG4gICAgICAgIGZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpXG4gICAgICB9XG4gICAgfSk7XG4gICAgaGFuZGxlTGFiZWwuZW5zdXJlU3RhdGUoJ2JsdXInKS5zdHlsZSA9IHtcbiAgICAgIG9wYWNpdHk6IDAuMVxuICAgIH07XG4gICAgaGFuZGxlTGFiZWwuc3RhdGVUcmFuc2l0aW9uID0ge1xuICAgICAgZHVyYXRpb246IDIwMFxuICAgIH07XG4gICAgdGhpcy5ncm91cC5hZGQoaGFuZGxlTGFiZWwpO1xuICAgIHZhciBoYW5kbGVMYWJlbFBvaW50ID0gW2hhbmRsZVNpemUsIDBdO1xuICAgIHZhciBzaGFwZXMgPSB0aGlzLl9zaGFwZXM7XG4gICAgc2hhcGVzLmhhbmRsZVRodW1ic1toYW5kbGVJbmRleF0gPSBoYW5kbGVUaHVtYjtcbiAgICBzaGFwZXMuaGFuZGxlTGFiZWxQb2ludHNbaGFuZGxlSW5kZXhdID0gaGFuZGxlTGFiZWxQb2ludDtcbiAgICBzaGFwZXMuaGFuZGxlTGFiZWxzW2hhbmRsZUluZGV4XSA9IGhhbmRsZUxhYmVsO1xuICB9O1xuXG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fY3JlYXRlSW5kaWNhdG9yID0gZnVuY3Rpb24gKHZpc3VhbE1hcE1vZGVsLCBtYWluR3JvdXAsIGl0ZW1TaXplLCB0ZXh0U2l6ZSwgb3JpZW50KSB7XG4gICAgdmFyIHNjYWxlID0gcGFyc2VQZXJjZW50KHZpc3VhbE1hcE1vZGVsLmdldCgnaW5kaWNhdG9yU2l6ZScpLCBpdGVtU2l6ZVswXSk7XG4gICAgdmFyIGluZGljYXRvciA9IGNyZWF0ZVN5bWJvbCh2aXN1YWxNYXBNb2RlbC5nZXQoJ2luZGljYXRvckljb24nKSwgLXNjYWxlIC8gMiwgLXNjYWxlIC8gMiwgc2NhbGUsIHNjYWxlLCBudWxsLCB0cnVlKTtcbiAgICBpbmRpY2F0b3IuYXR0cih7XG4gICAgICBjdXJzb3I6ICdtb3ZlJyxcbiAgICAgIGludmlzaWJsZTogdHJ1ZSxcbiAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgIHg6IGl0ZW1TaXplWzBdIC8gMlxuICAgIH0pO1xuICAgIHZhciBpbmRpY2F0b3JTdHlsZSA9IHZpc3VhbE1hcE1vZGVsLmdldE1vZGVsKCdpbmRpY2F0b3JTdHlsZScpLmdldEl0ZW1TdHlsZSgpO1xuXG4gICAgaWYgKGluZGljYXRvciBpbnN0YW5jZW9mIFpSSW1hZ2UpIHtcbiAgICAgIHZhciBwYXRoU3R5bGUgPSBpbmRpY2F0b3Iuc3R5bGU7XG4gICAgICBpbmRpY2F0b3IudXNlU3R5bGUoenJVdGlsLmV4dGVuZCh7XG4gICAgICAgIC8vIFRPRE8gb3RoZXIgcHJvcGVydGllcyBsaWtlIHgsIHkgP1xuICAgICAgICBpbWFnZTogcGF0aFN0eWxlLmltYWdlLFxuICAgICAgICB4OiBwYXRoU3R5bGUueCxcbiAgICAgICAgeTogcGF0aFN0eWxlLnksXG4gICAgICAgIHdpZHRoOiBwYXRoU3R5bGUud2lkdGgsXG4gICAgICAgIGhlaWdodDogcGF0aFN0eWxlLmhlaWdodFxuICAgICAgfSwgaW5kaWNhdG9yU3R5bGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kaWNhdG9yLnVzZVN0eWxlKGluZGljYXRvclN0eWxlKTtcbiAgICB9XG5cbiAgICBtYWluR3JvdXAuYWRkKGluZGljYXRvcik7XG4gICAgdmFyIHRleHRTdHlsZU1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbC50ZXh0U3R5bGVNb2RlbDtcbiAgICB2YXIgaW5kaWNhdG9yTGFiZWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgIGludmlzaWJsZTogdHJ1ZSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHRleHQ6ICcnLFxuICAgICAgICBmb250OiB0ZXh0U3R5bGVNb2RlbC5nZXRGb250KCksXG4gICAgICAgIGZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5ncm91cC5hZGQoaW5kaWNhdG9yTGFiZWwpO1xuICAgIHZhciBpbmRpY2F0b3JMYWJlbFBvaW50ID0gWyhvcmllbnQgPT09ICdob3Jpem9udGFsJyA/IHRleHRTaXplIC8gMiA6IEhPVkVSX0xJTktfT1VUKSArIGl0ZW1TaXplWzBdIC8gMiwgMF07XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuX3NoYXBlcztcbiAgICBzaGFwZXMuaW5kaWNhdG9yID0gaW5kaWNhdG9yO1xuICAgIHNoYXBlcy5pbmRpY2F0b3JMYWJlbCA9IGluZGljYXRvckxhYmVsO1xuICAgIHNoYXBlcy5pbmRpY2F0b3JMYWJlbFBvaW50ID0gaW5kaWNhdG9yTGFiZWxQb2ludDtcbiAgICB0aGlzLl9maXJzdFNob3dJbmRpY2F0b3IgPSB0cnVlO1xuICB9O1xuXG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fZHJhZ0hhbmRsZSA9IGZ1bmN0aW9uIChoYW5kbGVJbmRleCwgaXNFbmQsIC8vIGR4IGlzIGV2ZW50IGZyb20gb25kcmFnZW5kIGlmIGlzRW5kIGlzIHRydWUuIEl0J3Mgbm90IHVzZWRcbiAgZHgsIGR5KSB7XG4gICAgaWYgKCF0aGlzLl91c2VIYW5kbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9kcmFnZ2luZyA9ICFpc0VuZDtcblxuICAgIGlmICghaXNFbmQpIHtcbiAgICAgIC8vIFRyYW5zZm9ybSBkeCwgZHkgdG8gYmFyIGNvb3JkaW5hdGlvbi5cbiAgICAgIHZhciB2ZXJ0ZXggPSB0aGlzLl9hcHBseVRyYW5zZm9ybShbZHgsIGR5XSwgdGhpcy5fc2hhcGVzLm1haW5Hcm91cCwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZUludGVydmFsKGhhbmRsZUluZGV4LCB2ZXJ0ZXhbMV0pO1xuXG4gICAgICB0aGlzLl9oaWRlSW5kaWNhdG9yKCk7IC8vIENvbnNpZGVyaW5nIHJlYWx0aW1lLCB1cGRhdGUgdmlldyBzaG91bGQgYmUgZXhlY3V0ZWRcbiAgICAgIC8vIGJlZm9yZSBkaXNwYXRjaCBhY3Rpb24uXG5cblxuICAgICAgdGhpcy5fdXBkYXRlVmlldygpO1xuICAgIH0gLy8gZHJhZ0VuZCBkbyBub3QgZGlzcGF0Y2ggYWN0aW9uIHdoZW4gcmVhbHRpbWUuXG5cblxuICAgIGlmIChpc0VuZCA9PT0gIXRoaXMudmlzdWFsTWFwTW9kZWwuZ2V0KCdyZWFsdGltZScpKSB7XG4gICAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ3NlbGVjdERhdGFSYW5nZScsXG4gICAgICAgIGZyb206IHRoaXMudWlkLFxuICAgICAgICB2aXN1YWxNYXBJZDogdGhpcy52aXN1YWxNYXBNb2RlbC5pZCxcbiAgICAgICAgc2VsZWN0ZWQ6IHRoaXMuX2RhdGFJbnRlcnZhbC5zbGljZSgpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNFbmQpIHtcbiAgICAgICF0aGlzLl9ob3ZlcmluZyAmJiB0aGlzLl9jbGVhckhvdmVyTGlua1RvU2VyaWVzKCk7XG4gICAgfSBlbHNlIGlmICh1c2VIb3ZlckxpbmtPbkhhbmRsZSh0aGlzLnZpc3VhbE1hcE1vZGVsKSkge1xuICAgICAgdGhpcy5fZG9Ib3ZlckxpbmtUb1Nlcmllcyh0aGlzLl9oYW5kbGVFbmRzW2hhbmRsZUluZGV4XSwgZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX3Jlc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpc3VhbE1hcE1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbDtcbiAgICB2YXIgZGF0YUludGVydmFsID0gdGhpcy5fZGF0YUludGVydmFsID0gdmlzdWFsTWFwTW9kZWwuZ2V0U2VsZWN0ZWQoKTtcbiAgICB2YXIgZGF0YUV4dGVudCA9IHZpc3VhbE1hcE1vZGVsLmdldEV4dGVudCgpO1xuICAgIHZhciBzaXplRXh0ZW50ID0gWzAsIHZpc3VhbE1hcE1vZGVsLml0ZW1TaXplWzFdXTtcbiAgICB0aGlzLl9oYW5kbGVFbmRzID0gW2xpbmVhck1hcChkYXRhSW50ZXJ2YWxbMF0sIGRhdGFFeHRlbnQsIHNpemVFeHRlbnQsIHRydWUpLCBsaW5lYXJNYXAoZGF0YUludGVydmFsWzFdLCBkYXRhRXh0ZW50LCBzaXplRXh0ZW50LCB0cnVlKV07XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gaGFuZGxlSW5kZXggMCBvciAxIG9yICdhbGwnXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICAgKiBAcGFyYW0ge251bWJlcn0gZHlcbiAgICovXG5cblxuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX3VwZGF0ZUludGVydmFsID0gZnVuY3Rpb24gKGhhbmRsZUluZGV4LCBkZWx0YSkge1xuICAgIGRlbHRhID0gZGVsdGEgfHwgMDtcbiAgICB2YXIgdmlzdWFsTWFwTW9kZWwgPSB0aGlzLnZpc3VhbE1hcE1vZGVsO1xuICAgIHZhciBoYW5kbGVFbmRzID0gdGhpcy5faGFuZGxlRW5kcztcbiAgICB2YXIgc2l6ZUV4dGVudCA9IFswLCB2aXN1YWxNYXBNb2RlbC5pdGVtU2l6ZVsxXV07XG4gICAgc2xpZGVyTW92ZShkZWx0YSwgaGFuZGxlRW5kcywgc2l6ZUV4dGVudCwgaGFuZGxlSW5kZXgsIC8vIGNyb3NzIGlzIGZvcmJpZGVuXG4gICAgMCk7XG4gICAgdmFyIGRhdGFFeHRlbnQgPSB2aXN1YWxNYXBNb2RlbC5nZXRFeHRlbnQoKTsgLy8gVXBkYXRlIGRhdGEgaW50ZXJ2YWwuXG5cbiAgICB0aGlzLl9kYXRhSW50ZXJ2YWwgPSBbbGluZWFyTWFwKGhhbmRsZUVuZHNbMF0sIHNpemVFeHRlbnQsIGRhdGFFeHRlbnQsIHRydWUpLCBsaW5lYXJNYXAoaGFuZGxlRW5kc1sxXSwgc2l6ZUV4dGVudCwgZGF0YUV4dGVudCwgdHJ1ZSldO1xuICB9O1xuXG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fdXBkYXRlVmlldyA9IGZ1bmN0aW9uIChmb3JTa2V0Y2gpIHtcbiAgICB2YXIgdmlzdWFsTWFwTW9kZWwgPSB0aGlzLnZpc3VhbE1hcE1vZGVsO1xuICAgIHZhciBkYXRhRXh0ZW50ID0gdmlzdWFsTWFwTW9kZWwuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuX3NoYXBlcztcbiAgICB2YXIgb3V0T2ZSYW5nZUhhbmRsZUVuZHMgPSBbMCwgdmlzdWFsTWFwTW9kZWwuaXRlbVNpemVbMV1dO1xuICAgIHZhciBpblJhbmdlSGFuZGxlRW5kcyA9IGZvclNrZXRjaCA/IG91dE9mUmFuZ2VIYW5kbGVFbmRzIDogdGhpcy5faGFuZGxlRW5kcztcblxuICAgIHZhciB2aXN1YWxJblJhbmdlID0gdGhpcy5fY3JlYXRlQmFyVmlzdWFsKHRoaXMuX2RhdGFJbnRlcnZhbCwgZGF0YUV4dGVudCwgaW5SYW5nZUhhbmRsZUVuZHMsICdpblJhbmdlJyk7XG5cbiAgICB2YXIgdmlzdWFsT3V0T2ZSYW5nZSA9IHRoaXMuX2NyZWF0ZUJhclZpc3VhbChkYXRhRXh0ZW50LCBkYXRhRXh0ZW50LCBvdXRPZlJhbmdlSGFuZGxlRW5kcywgJ291dE9mUmFuZ2UnKTtcblxuICAgIHNoYXBlcy5pblJhbmdlLnNldFN0eWxlKHtcbiAgICAgIGZpbGw6IHZpc3VhbEluUmFuZ2UuYmFyQ29sb3IgLy8gb3BhY2l0eTogdmlzdWFsSW5SYW5nZS5vcGFjaXR5XG5cbiAgICB9KS5zZXRTaGFwZSgncG9pbnRzJywgdmlzdWFsSW5SYW5nZS5iYXJQb2ludHMpO1xuICAgIHNoYXBlcy5vdXRPZlJhbmdlLnNldFN0eWxlKHtcbiAgICAgIGZpbGw6IHZpc3VhbE91dE9mUmFuZ2UuYmFyQ29sb3IgLy8gb3BhY2l0eTogdmlzdWFsT3V0T2ZSYW5nZS5vcGFjaXR5XG5cbiAgICB9KS5zZXRTaGFwZSgncG9pbnRzJywgdmlzdWFsT3V0T2ZSYW5nZS5iYXJQb2ludHMpO1xuXG4gICAgdGhpcy5fdXBkYXRlSGFuZGxlKGluUmFuZ2VIYW5kbGVFbmRzLCB2aXN1YWxJblJhbmdlKTtcbiAgfTtcblxuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX2NyZWF0ZUJhclZpc3VhbCA9IGZ1bmN0aW9uIChkYXRhSW50ZXJ2YWwsIGRhdGFFeHRlbnQsIGhhbmRsZUVuZHMsIGZvcmNlU3RhdGUpIHtcbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgIGZvcmNlU3RhdGU6IGZvcmNlU3RhdGUsXG4gICAgICBjb252ZXJ0T3BhY2l0eVRvQWxwaGE6IHRydWVcbiAgICB9O1xuXG4gICAgdmFyIGNvbG9yU3RvcHMgPSB0aGlzLl9tYWtlQ29sb3JHcmFkaWVudChkYXRhSW50ZXJ2YWwsIG9wdHMpO1xuXG4gICAgdmFyIHN5bWJvbFNpemVzID0gW3RoaXMuZ2V0Q29udHJvbGxlclZpc3VhbChkYXRhSW50ZXJ2YWxbMF0sICdzeW1ib2xTaXplJywgb3B0cyksIHRoaXMuZ2V0Q29udHJvbGxlclZpc3VhbChkYXRhSW50ZXJ2YWxbMV0sICdzeW1ib2xTaXplJywgb3B0cyldO1xuXG4gICAgdmFyIGJhclBvaW50cyA9IHRoaXMuX2NyZWF0ZUJhclBvaW50cyhoYW5kbGVFbmRzLCBzeW1ib2xTaXplcyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYmFyQ29sb3I6IG5ldyBMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCAxLCBjb2xvclN0b3BzKSxcbiAgICAgIGJhclBvaW50czogYmFyUG9pbnRzLFxuICAgICAgaGFuZGxlc0NvbG9yOiBbY29sb3JTdG9wc1swXS5jb2xvciwgY29sb3JTdG9wc1tjb2xvclN0b3BzLmxlbmd0aCAtIDFdLmNvbG9yXVxuICAgIH07XG4gIH07XG5cbiAgQ29udGludW91c1ZpZXcucHJvdG90eXBlLl9tYWtlQ29sb3JHcmFkaWVudCA9IGZ1bmN0aW9uIChkYXRhSW50ZXJ2YWwsIG9wdHMpIHtcbiAgICAvLyBDb25zaWRlcmluZyBjb2xvckh1ZSwgd2hpY2ggaXMgbm90IGxpbmVhciwgc28gd2UgaGF2ZSB0byBzYW1wbGVcbiAgICAvLyB0byBjYWxjdWxhdGUgZ3JhZGllbnQgY29sb3Igc3RvcHMsIGJ1dCBub3Qgb25seSBjYWN1bGF0ZSBoZWFkXG4gICAgLy8gYW5kIHRhaWwuXG4gICAgdmFyIHNhbXBsZU51bWJlciA9IDEwMDsgLy8gQXJiaXRyYXJ5IHZhbHVlLlxuXG4gICAgdmFyIGNvbG9yU3RvcHMgPSBbXTtcbiAgICB2YXIgc3RlcCA9IChkYXRhSW50ZXJ2YWxbMV0gLSBkYXRhSW50ZXJ2YWxbMF0pIC8gc2FtcGxlTnVtYmVyO1xuICAgIGNvbG9yU3RvcHMucHVzaCh7XG4gICAgICBjb2xvcjogdGhpcy5nZXRDb250cm9sbGVyVmlzdWFsKGRhdGFJbnRlcnZhbFswXSwgJ2NvbG9yJywgb3B0cyksXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2FtcGxlTnVtYmVyOyBpKyspIHtcbiAgICAgIHZhciBjdXJyVmFsdWUgPSBkYXRhSW50ZXJ2YWxbMF0gKyBzdGVwICogaTtcblxuICAgICAgaWYgKGN1cnJWYWx1ZSA+IGRhdGFJbnRlcnZhbFsxXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29sb3JTdG9wcy5wdXNoKHtcbiAgICAgICAgY29sb3I6IHRoaXMuZ2V0Q29udHJvbGxlclZpc3VhbChjdXJyVmFsdWUsICdjb2xvcicsIG9wdHMpLFxuICAgICAgICBvZmZzZXQ6IGkgLyBzYW1wbGVOdW1iZXJcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbG9yU3RvcHMucHVzaCh7XG4gICAgICBjb2xvcjogdGhpcy5nZXRDb250cm9sbGVyVmlzdWFsKGRhdGFJbnRlcnZhbFsxXSwgJ2NvbG9yJywgb3B0cyksXG4gICAgICBvZmZzZXQ6IDFcbiAgICB9KTtcbiAgICByZXR1cm4gY29sb3JTdG9wcztcbiAgfTtcblxuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX2NyZWF0ZUJhclBvaW50cyA9IGZ1bmN0aW9uIChoYW5kbGVFbmRzLCBzeW1ib2xTaXplcykge1xuICAgIHZhciBpdGVtU2l6ZSA9IHRoaXMudmlzdWFsTWFwTW9kZWwuaXRlbVNpemU7XG4gICAgcmV0dXJuIFtbaXRlbVNpemVbMF0gLSBzeW1ib2xTaXplc1swXSwgaGFuZGxlRW5kc1swXV0sIFtpdGVtU2l6ZVswXSwgaGFuZGxlRW5kc1swXV0sIFtpdGVtU2l6ZVswXSwgaGFuZGxlRW5kc1sxXV0sIFtpdGVtU2l6ZVswXSAtIHN5bWJvbFNpemVzWzFdLCBoYW5kbGVFbmRzWzFdXV07XG4gIH07XG5cbiAgQ29udGludW91c1ZpZXcucHJvdG90eXBlLl9jcmVhdGVCYXJHcm91cCA9IGZ1bmN0aW9uIChpdGVtQWxpZ24pIHtcbiAgICB2YXIgb3JpZW50ID0gdGhpcy5fb3JpZW50O1xuICAgIHZhciBpbnZlcnNlID0gdGhpcy52aXN1YWxNYXBNb2RlbC5nZXQoJ2ludmVyc2UnKTtcbiAgICByZXR1cm4gbmV3IGdyYXBoaWMuR3JvdXAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcgJiYgIWludmVyc2UgPyB7XG4gICAgICBzY2FsZVg6IGl0ZW1BbGlnbiA9PT0gJ2JvdHRvbScgPyAxIDogLTEsXG4gICAgICByb3RhdGlvbjogTWF0aC5QSSAvIDJcbiAgICB9IDogb3JpZW50ID09PSAnaG9yaXpvbnRhbCcgJiYgaW52ZXJzZSA/IHtcbiAgICAgIHNjYWxlWDogaXRlbUFsaWduID09PSAnYm90dG9tJyA/IC0xIDogMSxcbiAgICAgIHJvdGF0aW9uOiAtTWF0aC5QSSAvIDJcbiAgICB9IDogb3JpZW50ID09PSAndmVydGljYWwnICYmICFpbnZlcnNlID8ge1xuICAgICAgc2NhbGVYOiBpdGVtQWxpZ24gPT09ICdsZWZ0JyA/IDEgOiAtMSxcbiAgICAgIHNjYWxlWTogLTFcbiAgICB9IDoge1xuICAgICAgc2NhbGVYOiBpdGVtQWxpZ24gPT09ICdsZWZ0JyA/IDEgOiAtMVxuICAgIH0pO1xuICB9O1xuXG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fdXBkYXRlSGFuZGxlID0gZnVuY3Rpb24gKGhhbmRsZUVuZHMsIHZpc3VhbEluUmFuZ2UpIHtcbiAgICBpZiAoIXRoaXMuX3VzZUhhbmRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaGFwZXMgPSB0aGlzLl9zaGFwZXM7XG4gICAgdmFyIHZpc3VhbE1hcE1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbDtcbiAgICB2YXIgaGFuZGxlVGh1bWJzID0gc2hhcGVzLmhhbmRsZVRodW1icztcbiAgICB2YXIgaGFuZGxlTGFiZWxzID0gc2hhcGVzLmhhbmRsZUxhYmVscztcbiAgICB2YXIgaXRlbVNpemUgPSB2aXN1YWxNYXBNb2RlbC5pdGVtU2l6ZTtcbiAgICB2YXIgZGF0YUV4dGVudCA9IHZpc3VhbE1hcE1vZGVsLmdldEV4dGVudCgpO1xuICAgIGVhY2goWzAsIDFdLCBmdW5jdGlvbiAoaGFuZGxlSW5kZXgpIHtcbiAgICAgIHZhciBoYW5kbGVUaHVtYiA9IGhhbmRsZVRodW1ic1toYW5kbGVJbmRleF07XG4gICAgICBoYW5kbGVUaHVtYi5zZXRTdHlsZSgnZmlsbCcsIHZpc3VhbEluUmFuZ2UuaGFuZGxlc0NvbG9yW2hhbmRsZUluZGV4XSk7XG4gICAgICBoYW5kbGVUaHVtYi55ID0gaGFuZGxlRW5kc1toYW5kbGVJbmRleF07XG4gICAgICB2YXIgdmFsID0gbGluZWFyTWFwKGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdLCBbMCwgaXRlbVNpemVbMV1dLCBkYXRhRXh0ZW50LCB0cnVlKTtcbiAgICAgIHZhciBzeW1ib2xTaXplID0gdGhpcy5nZXRDb250cm9sbGVyVmlzdWFsKHZhbCwgJ3N5bWJvbFNpemUnKTtcbiAgICAgIGhhbmRsZVRodW1iLnNjYWxlWCA9IGhhbmRsZVRodW1iLnNjYWxlWSA9IHN5bWJvbFNpemUgLyBpdGVtU2l6ZVswXTtcbiAgICAgIGhhbmRsZVRodW1iLnggPSBpdGVtU2l6ZVswXSAtIHN5bWJvbFNpemUgLyAyOyAvLyBVcGRhdGUgaGFuZGxlIGxhYmVsIHBvc2l0aW9uLlxuXG4gICAgICB2YXIgdGV4dFBvaW50ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybShzaGFwZXMuaGFuZGxlTGFiZWxQb2ludHNbaGFuZGxlSW5kZXhdLCBncmFwaGljLmdldFRyYW5zZm9ybShoYW5kbGVUaHVtYiwgdGhpcy5ncm91cCkpO1xuICAgICAgaGFuZGxlTGFiZWxzW2hhbmRsZUluZGV4XS5zZXRTdHlsZSh7XG4gICAgICAgIHg6IHRleHRQb2ludFswXSxcbiAgICAgICAgeTogdGV4dFBvaW50WzFdLFxuICAgICAgICB0ZXh0OiB2aXN1YWxNYXBNb2RlbC5mb3JtYXRWYWx1ZVRleHQodGhpcy5fZGF0YUludGVydmFsW2hhbmRsZUluZGV4XSksXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICBhbGlnbjogdGhpcy5fb3JpZW50ID09PSAndmVydGljYWwnID8gdGhpcy5fYXBwbHlUcmFuc2Zvcm0oJ2xlZnQnLCBzaGFwZXMubWFpbkdyb3VwKSA6ICdjZW50ZXInXG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX3Nob3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoY3Vyc29yVmFsdWUsIHRleHRWYWx1ZSwgcmFuZ2VTeW1ib2wsIGhhbGZIb3ZlckxpbmtTaXplKSB7XG4gICAgdmFyIHZpc3VhbE1hcE1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbDtcbiAgICB2YXIgZGF0YUV4dGVudCA9IHZpc3VhbE1hcE1vZGVsLmdldEV4dGVudCgpO1xuICAgIHZhciBpdGVtU2l6ZSA9IHZpc3VhbE1hcE1vZGVsLml0ZW1TaXplO1xuICAgIHZhciBzaXplRXh0ZW50ID0gWzAsIGl0ZW1TaXplWzFdXTtcbiAgICB2YXIgc2hhcGVzID0gdGhpcy5fc2hhcGVzO1xuICAgIHZhciBpbmRpY2F0b3IgPSBzaGFwZXMuaW5kaWNhdG9yO1xuXG4gICAgaWYgKCFpbmRpY2F0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbmRpY2F0b3IuYXR0cignaW52aXNpYmxlJywgZmFsc2UpO1xuICAgIHZhciBvcHRzID0ge1xuICAgICAgY29udmVydE9wYWNpdHlUb0FscGhhOiB0cnVlXG4gICAgfTtcbiAgICB2YXIgY29sb3IgPSB0aGlzLmdldENvbnRyb2xsZXJWaXN1YWwoY3Vyc29yVmFsdWUsICdjb2xvcicsIG9wdHMpO1xuICAgIHZhciBzeW1ib2xTaXplID0gdGhpcy5nZXRDb250cm9sbGVyVmlzdWFsKGN1cnNvclZhbHVlLCAnc3ltYm9sU2l6ZScpO1xuICAgIHZhciB5ID0gbGluZWFyTWFwKGN1cnNvclZhbHVlLCBkYXRhRXh0ZW50LCBzaXplRXh0ZW50LCB0cnVlKTtcbiAgICB2YXIgeCA9IGl0ZW1TaXplWzBdIC0gc3ltYm9sU2l6ZSAvIDI7XG4gICAgdmFyIG9sZEluZGljYXRvclBvcyA9IHtcbiAgICAgIHg6IGluZGljYXRvci54LFxuICAgICAgeTogaW5kaWNhdG9yLnlcbiAgICB9OyAvLyBVcGRhdGUgaGFuZGxlIGxhYmVsIHBvc2l0aW9uLlxuXG4gICAgaW5kaWNhdG9yLnkgPSB5O1xuICAgIGluZGljYXRvci54ID0geDtcbiAgICB2YXIgdGV4dFBvaW50ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybShzaGFwZXMuaW5kaWNhdG9yTGFiZWxQb2ludCwgZ3JhcGhpYy5nZXRUcmFuc2Zvcm0oaW5kaWNhdG9yLCB0aGlzLmdyb3VwKSk7XG4gICAgdmFyIGluZGljYXRvckxhYmVsID0gc2hhcGVzLmluZGljYXRvckxhYmVsO1xuICAgIGluZGljYXRvckxhYmVsLmF0dHIoJ2ludmlzaWJsZScsIGZhbHNlKTtcblxuICAgIHZhciBhbGlnbiA9IHRoaXMuX2FwcGx5VHJhbnNmb3JtKCdsZWZ0Jywgc2hhcGVzLm1haW5Hcm91cCk7XG5cbiAgICB2YXIgb3JpZW50ID0gdGhpcy5fb3JpZW50O1xuICAgIHZhciBpc0hvcml6b250YWwgPSBvcmllbnQgPT09ICdob3Jpem9udGFsJztcbiAgICBpbmRpY2F0b3JMYWJlbC5zZXRTdHlsZSh7XG4gICAgICB0ZXh0OiAocmFuZ2VTeW1ib2wgPyByYW5nZVN5bWJvbCA6ICcnKSArIHZpc3VhbE1hcE1vZGVsLmZvcm1hdFZhbHVlVGV4dCh0ZXh0VmFsdWUpLFxuICAgICAgdmVydGljYWxBbGlnbjogaXNIb3Jpem9udGFsID8gYWxpZ24gOiAnbWlkZGxlJyxcbiAgICAgIGFsaWduOiBpc0hvcml6b250YWwgPyAnY2VudGVyJyA6IGFsaWduXG4gICAgfSk7XG4gICAgdmFyIGluZGljYXRvck5ld1Byb3BzID0ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICBzdHlsZToge1xuICAgICAgICBmaWxsOiBjb2xvclxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGxhYmVsTmV3UHJvcHMgPSB7XG4gICAgICBzdHlsZToge1xuICAgICAgICB4OiB0ZXh0UG9pbnRbMF0sXG4gICAgICAgIHk6IHRleHRQb2ludFsxXVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodmlzdWFsTWFwTW9kZWwuZWNNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKSAmJiAhdGhpcy5fZmlyc3RTaG93SW5kaWNhdG9yKSB7XG4gICAgICB2YXIgYW5pbWF0aW9uQ2ZnID0ge1xuICAgICAgICBkdXJhdGlvbjogMTAwLFxuICAgICAgICBlYXNpbmc6ICdjdWJpY0luT3V0JyxcbiAgICAgICAgYWRkaXRpdmU6IHRydWVcbiAgICAgIH07XG4gICAgICBpbmRpY2F0b3IueCA9IG9sZEluZGljYXRvclBvcy54O1xuICAgICAgaW5kaWNhdG9yLnkgPSBvbGRJbmRpY2F0b3JQb3MueTtcbiAgICAgIGluZGljYXRvci5hbmltYXRlVG8oaW5kaWNhdG9yTmV3UHJvcHMsIGFuaW1hdGlvbkNmZyk7XG4gICAgICBpbmRpY2F0b3JMYWJlbC5hbmltYXRlVG8obGFiZWxOZXdQcm9wcywgYW5pbWF0aW9uQ2ZnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kaWNhdG9yLmF0dHIoaW5kaWNhdG9yTmV3UHJvcHMpO1xuICAgICAgaW5kaWNhdG9yTGFiZWwuYXR0cihsYWJlbE5ld1Byb3BzKTtcbiAgICB9XG5cbiAgICB0aGlzLl9maXJzdFNob3dJbmRpY2F0b3IgPSBmYWxzZTtcbiAgICB2YXIgaGFuZGxlTGFiZWxzID0gdGhpcy5fc2hhcGVzLmhhbmRsZUxhYmVscztcblxuICAgIGlmIChoYW5kbGVMYWJlbHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlTGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEZhZGUgb3V0IGhhbmRsZSBsYWJlbHMuXG4gICAgICAgIC8vIE5PVEU6IE11c3QgdXNlIGFwaSBlbnRlci9sZWF2ZSBvbiBlbXBoYXNpcy9ibHVyL3NlbGVjdCBzdGF0ZS4gT3IgdGhlIGdsb2JhbCBzdGF0ZXMgbWFuYWdlciB3aWxsIGNoYW5nZSBpdC5cbiAgICAgICAgdGhpcy5fYXBpLmVudGVyQmx1cihoYW5kbGVMYWJlbHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX2VuYWJsZUhvdmVyTGlua1RvU2VyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuX3NoYXBlcy5tYWluR3JvdXAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBzZWxmLl9ob3ZlcmluZyA9IHRydWU7XG5cbiAgICAgIGlmICghc2VsZi5fZHJhZ2dpbmcpIHtcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gc2VsZi52aXN1YWxNYXBNb2RlbC5pdGVtU2l6ZTtcblxuICAgICAgICB2YXIgcG9zID0gc2VsZi5fYXBwbHlUcmFuc2Zvcm0oW2Uub2Zmc2V0WCwgZS5vZmZzZXRZXSwgc2VsZi5fc2hhcGVzLm1haW5Hcm91cCwgdHJ1ZSwgdHJ1ZSk7IC8vIEZvciBob3ZlciBsaW5rIHNob3cgd2hlbiBob3ZlciBoYW5kbGUsIHdoaWNoIG1pZ2h0IGJlXG4gICAgICAgIC8vIGJlbG93IG9yIHVwcGVyIHRoYW4gc2l6ZUV4dGVudC5cblxuXG4gICAgICAgIHBvc1sxXSA9IG1hdGhNaW4obWF0aE1heCgwLCBwb3NbMV0pLCBpdGVtU2l6ZVsxXSk7XG5cbiAgICAgICAgc2VsZi5fZG9Ib3ZlckxpbmtUb1Nlcmllcyhwb3NbMV0sIDAgPD0gcG9zWzBdICYmIHBvc1swXSA8PSBpdGVtU2l6ZVswXSk7XG4gICAgICB9XG4gICAgfSkub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gV2hlbiBtb3VzZSBpcyBvdXQgb2YgaGFuZGxlLCBob3Zlckxpbmsgc3RpbGwgbmVlZFxuICAgICAgLy8gdG8gYmUgZGlzcGxheWVkIHdoZW4gcmVhbHRpbWUgaXMgc2V0IGFzIGZhbHNlLlxuICAgICAgc2VsZi5faG92ZXJpbmcgPSBmYWxzZTtcbiAgICAgICFzZWxmLl9kcmFnZ2luZyAmJiBzZWxmLl9jbGVhckhvdmVyTGlua1RvU2VyaWVzKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgQ29udGludW91c1ZpZXcucHJvdG90eXBlLl9lbmFibGVIb3ZlckxpbmtGcm9tU2VyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB6ciA9IHRoaXMuYXBpLmdldFpyKCk7XG5cbiAgICBpZiAodGhpcy52aXN1YWxNYXBNb2RlbC5vcHRpb24uaG92ZXJMaW5rKSB7XG4gICAgICB6ci5vbignbW91c2VvdmVyJywgdGhpcy5faG92ZXJMaW5rRnJvbVNlcmllc01vdXNlT3ZlciwgdGhpcyk7XG4gICAgICB6ci5vbignbW91c2VvdXQnLCB0aGlzLl9oaWRlSW5kaWNhdG9yLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY2xlYXJIb3ZlckxpbmtGcm9tU2VyaWVzKCk7XG4gICAgfVxuICB9O1xuXG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fZG9Ib3ZlckxpbmtUb1NlcmllcyA9IGZ1bmN0aW9uIChjdXJzb3JQb3MsIGhvdmVyT25CYXIpIHtcbiAgICB2YXIgdmlzdWFsTWFwTW9kZWwgPSB0aGlzLnZpc3VhbE1hcE1vZGVsO1xuICAgIHZhciBpdGVtU2l6ZSA9IHZpc3VhbE1hcE1vZGVsLml0ZW1TaXplO1xuXG4gICAgaWYgKCF2aXN1YWxNYXBNb2RlbC5vcHRpb24uaG92ZXJMaW5rKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNpemVFeHRlbnQgPSBbMCwgaXRlbVNpemVbMV1dO1xuICAgIHZhciBkYXRhRXh0ZW50ID0gdmlzdWFsTWFwTW9kZWwuZ2V0RXh0ZW50KCk7IC8vIEZvciBob3ZlciBsaW5rIHNob3cgd2hlbiBob3ZlciBoYW5kbGUsIHdoaWNoIG1pZ2h0IGJlIGJlbG93IG9yIHVwcGVyIHRoYW4gc2l6ZUV4dGVudC5cblxuICAgIGN1cnNvclBvcyA9IG1hdGhNaW4obWF0aE1heChzaXplRXh0ZW50WzBdLCBjdXJzb3JQb3MpLCBzaXplRXh0ZW50WzFdKTtcbiAgICB2YXIgaGFsZkhvdmVyTGlua1NpemUgPSBnZXRIYWxmSG92ZXJMaW5rU2l6ZSh2aXN1YWxNYXBNb2RlbCwgZGF0YUV4dGVudCwgc2l6ZUV4dGVudCk7XG4gICAgdmFyIGhvdmVyUmFuZ2UgPSBbY3Vyc29yUG9zIC0gaGFsZkhvdmVyTGlua1NpemUsIGN1cnNvclBvcyArIGhhbGZIb3ZlckxpbmtTaXplXTtcbiAgICB2YXIgY3Vyc29yVmFsdWUgPSBsaW5lYXJNYXAoY3Vyc29yUG9zLCBzaXplRXh0ZW50LCBkYXRhRXh0ZW50LCB0cnVlKTtcbiAgICB2YXIgdmFsdWVSYW5nZSA9IFtsaW5lYXJNYXAoaG92ZXJSYW5nZVswXSwgc2l6ZUV4dGVudCwgZGF0YUV4dGVudCwgdHJ1ZSksIGxpbmVhck1hcChob3ZlclJhbmdlWzFdLCBzaXplRXh0ZW50LCBkYXRhRXh0ZW50LCB0cnVlKV07IC8vIENvbnNpZGVyIGRhdGEgcmFuZ2UgaXMgb3V0IG9mIHZpc3VhbE1hcCByYW5nZSwgc2VlIHRlc3QvdmlzdWFsTWFwLWNvbnRpbnVvdXMuaHRtbCxcbiAgICAvLyB3aGVyZSBjaGluYSBhbmQgaW5kaWEgaGFzIHZlcnkgbGFyZ2UgcG9wdWxhdGlvbi5cblxuICAgIGhvdmVyUmFuZ2VbMF0gPCBzaXplRXh0ZW50WzBdICYmICh2YWx1ZVJhbmdlWzBdID0gLUluZmluaXR5KTtcbiAgICBob3ZlclJhbmdlWzFdID4gc2l6ZUV4dGVudFsxXSAmJiAodmFsdWVSYW5nZVsxXSA9IEluZmluaXR5KTsgLy8gRG8gbm90IHNob3cgaW5kaWNhdG9yIHdoZW4gbW91c2UgaXMgb3ZlciBoYW5kbGUsXG4gICAgLy8gb3RoZXJ3aXNlIGxhYmVscyBvdmVybGFwLCBlc3BlY2lhbGx5IHdoZW4gZHJhZ2dpbmcuXG5cbiAgICBpZiAoaG92ZXJPbkJhcikge1xuICAgICAgaWYgKHZhbHVlUmFuZ2VbMF0gPT09IC1JbmZpbml0eSkge1xuICAgICAgICB0aGlzLl9zaG93SW5kaWNhdG9yKGN1cnNvclZhbHVlLCB2YWx1ZVJhbmdlWzFdLCAnPCAnLCBoYWxmSG92ZXJMaW5rU2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlUmFuZ2VbMV0gPT09IEluZmluaXR5KSB7XG4gICAgICAgIHRoaXMuX3Nob3dJbmRpY2F0b3IoY3Vyc29yVmFsdWUsIHZhbHVlUmFuZ2VbMF0sICc+ICcsIGhhbGZIb3ZlckxpbmtTaXplKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Nob3dJbmRpY2F0b3IoY3Vyc29yVmFsdWUsIGN1cnNvclZhbHVlLCAn4omIICcsIGhhbGZIb3ZlckxpbmtTaXplKTtcbiAgICAgIH1cbiAgICB9IC8vIFdoZW4gcmVhbHRpbWUgaXMgc2V0IGFzIGZhbHNlLCBoYW5kbGVzLCB3aGljaCBhcmUgaW4gYmFyR3JvdXAsXG4gICAgLy8gYWxzbyB0cmlnZ2VyIGhvdmVyTGluaywgd2hpY2ggaGVscCB1c2VyIHRvIHJlYWxpemUgd2hlcmUgdGhleVxuICAgIC8vIGZvY3VzIG9uIHdoZW4gZHJhZ2dpbmcuIChzZWUgdGVzdC9oZWF0bWFwLWxhcmdlLmh0bWwpXG4gICAgLy8gV2hlbiByZWFsdGltZSBpcyBzZXQgYXMgdHJ1ZSwgaGlnaGxpZ2h0IHdpbGwgbm90IHNob3cgd2hlbiBob3ZlclxuICAgIC8vIGhhbmRsZSwgYmVjYXVzZSB0aGUgbGFiZWwgb24gaGFuZGxlLCB3aGljaCBkaXNwbGF5cyBhIGV4YWN0IHZhbHVlXG4gICAgLy8gYnV0IG5vdCByYW5nZSwgbWlnaHQgbWlzbGVhZCB1c2Vycy5cblxuXG4gICAgdmFyIG9sZEJhdGNoID0gdGhpcy5faG92ZXJMaW5rRGF0YUluZGljZXM7XG4gICAgdmFyIG5ld0JhdGNoID0gW107XG5cbiAgICBpZiAoaG92ZXJPbkJhciB8fCB1c2VIb3ZlckxpbmtPbkhhbmRsZSh2aXN1YWxNYXBNb2RlbCkpIHtcbiAgICAgIG5ld0JhdGNoID0gdGhpcy5faG92ZXJMaW5rRGF0YUluZGljZXMgPSB2aXN1YWxNYXBNb2RlbC5maW5kVGFyZ2V0RGF0YUluZGljZXModmFsdWVSYW5nZSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdEJhdGNoZXMgPSBtb2RlbFV0aWwuY29tcHJlc3NCYXRjaGVzKG9sZEJhdGNoLCBuZXdCYXRjaCk7XG5cbiAgICB0aGlzLl9kaXNwYXRjaEhpZ2hEb3duKCdkb3ducGxheScsIGhlbHBlci5tYWtlSGlnaERvd25CYXRjaChyZXN1bHRCYXRjaGVzWzBdLCB2aXN1YWxNYXBNb2RlbCkpO1xuXG4gICAgdGhpcy5fZGlzcGF0Y2hIaWdoRG93bignaGlnaGxpZ2h0JywgaGVscGVyLm1ha2VIaWdoRG93bkJhdGNoKHJlc3VsdEJhdGNoZXNbMV0sIHZpc3VhbE1hcE1vZGVsKSk7XG4gIH07XG5cbiAgQ29udGludW91c1ZpZXcucHJvdG90eXBlLl9ob3ZlckxpbmtGcm9tU2VyaWVzTW91c2VPdmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICB2YXIgdmlzdWFsTWFwTW9kZWwgPSB0aGlzLnZpc3VhbE1hcE1vZGVsO1xuXG4gICAgaWYgKCFlbCB8fCBnZXRFQ0RhdGEoZWwpLmRhdGFJbmRleCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVjRGF0YSA9IGdldEVDRGF0YShlbCk7XG4gICAgdmFyIGRhdGFNb2RlbCA9IHRoaXMuZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KGVjRGF0YS5zZXJpZXNJbmRleCk7XG5cbiAgICBpZiAoIXZpc3VhbE1hcE1vZGVsLmlzVGFyZ2V0U2VyaWVzKGRhdGFNb2RlbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IGRhdGFNb2RlbC5nZXREYXRhKGVjRGF0YS5kYXRhVHlwZSk7XG4gICAgdmFyIHZhbHVlID0gZGF0YS5nZXQodmlzdWFsTWFwTW9kZWwuZ2V0RGF0YURpbWVuc2lvbihkYXRhKSwgZWNEYXRhLmRhdGFJbmRleCk7XG5cbiAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgdGhpcy5fc2hvd0luZGljYXRvcih2YWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX2hpZGVJbmRpY2F0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuX3NoYXBlcztcbiAgICBzaGFwZXMuaW5kaWNhdG9yICYmIHNoYXBlcy5pbmRpY2F0b3IuYXR0cignaW52aXNpYmxlJywgdHJ1ZSk7XG4gICAgc2hhcGVzLmluZGljYXRvckxhYmVsICYmIHNoYXBlcy5pbmRpY2F0b3JMYWJlbC5hdHRyKCdpbnZpc2libGUnLCB0cnVlKTtcbiAgICB2YXIgaGFuZGxlTGFiZWxzID0gdGhpcy5fc2hhcGVzLmhhbmRsZUxhYmVscztcblxuICAgIGlmIChoYW5kbGVMYWJlbHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlTGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEZhZGUgb3V0IGhhbmRsZSBsYWJlbHMuXG4gICAgICAgIC8vIE5PVEU6IE11c3QgdXNlIGFwaSBlbnRlci9sZWF2ZSBvbiBlbXBoYXNpcy9ibHVyL3NlbGVjdCBzdGF0ZS4gT3IgdGhlIGdsb2JhbCBzdGF0ZXMgbWFuYWdlciB3aWxsIGNoYW5nZSBpdC5cbiAgICAgICAgdGhpcy5fYXBpLmxlYXZlQmx1cihoYW5kbGVMYWJlbHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX2NsZWFySG92ZXJMaW5rVG9TZXJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faGlkZUluZGljYXRvcigpO1xuXG4gICAgdmFyIGluZGljZXMgPSB0aGlzLl9ob3ZlckxpbmtEYXRhSW5kaWNlcztcblxuICAgIHRoaXMuX2Rpc3BhdGNoSGlnaERvd24oJ2Rvd25wbGF5JywgaGVscGVyLm1ha2VIaWdoRG93bkJhdGNoKGluZGljZXMsIHRoaXMudmlzdWFsTWFwTW9kZWwpKTtcblxuICAgIGluZGljZXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX2NsZWFySG92ZXJMaW5rRnJvbVNlcmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9oaWRlSW5kaWNhdG9yKCk7XG5cbiAgICB2YXIgenIgPSB0aGlzLmFwaS5nZXRacigpO1xuICAgIHpyLm9mZignbW91c2VvdmVyJywgdGhpcy5faG92ZXJMaW5rRnJvbVNlcmllc01vdXNlT3Zlcik7XG4gICAgenIub2ZmKCdtb3VzZW91dCcsIHRoaXMuX2hpZGVJbmRpY2F0b3IpO1xuICB9O1xuXG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodmVydGV4LCBlbGVtZW50LCBpbnZlcnNlLCBnbG9iYWwpIHtcbiAgICB2YXIgdHJhbnNmb3JtID0gZ3JhcGhpYy5nZXRUcmFuc2Zvcm0oZWxlbWVudCwgZ2xvYmFsID8gbnVsbCA6IHRoaXMuZ3JvdXApO1xuICAgIHJldHVybiB6clV0aWwuaXNBcnJheSh2ZXJ0ZXgpID8gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSh2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJzZSkgOiBncmFwaGljLnRyYW5zZm9ybURpcmVjdGlvbih2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJzZSk7XG4gIH07IC8vIFRPRE86IFRZUEUgbW9yZSBzcGVjaWZpZWQgcGF5bG9hZCB0eXBlcy5cblxuXG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fZGlzcGF0Y2hIaWdoRG93biA9IGZ1bmN0aW9uICh0eXBlLCBiYXRjaCkge1xuICAgIGJhdGNoICYmIGJhdGNoLmxlbmd0aCAmJiB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgYmF0Y2g6IGJhdGNoXG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jbGVhckhvdmVyTGlua0Zyb21TZXJpZXMoKTtcblxuICAgIHRoaXMuX2NsZWFySG92ZXJMaW5rVG9TZXJpZXMoKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xlYXJIb3ZlckxpbmtGcm9tU2VyaWVzKCk7XG5cbiAgICB0aGlzLl9jbGVhckhvdmVyTGlua1RvU2VyaWVzKCk7XG4gIH07XG5cbiAgQ29udGludW91c1ZpZXcudHlwZSA9ICd2aXN1YWxNYXAuY29udGludW91cyc7XG4gIHJldHVybiBDb250aW51b3VzVmlldztcbn0oVmlzdWFsTWFwVmlldyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvbHlnb24ocG9pbnRzLCBjdXJzb3IsIG9uRHJpZnQsIG9uRHJhZ0VuZCkge1xuICByZXR1cm4gbmV3IGdyYXBoaWMuUG9seWdvbih7XG4gICAgc2hhcGU6IHtcbiAgICAgIHBvaW50czogcG9pbnRzXG4gICAgfSxcbiAgICBkcmFnZ2FibGU6ICEhb25EcmlmdCxcbiAgICBjdXJzb3I6IGN1cnNvcixcbiAgICBkcmlmdDogb25EcmlmdCxcbiAgICBvbm1vdXNlbW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIEZvdCBtb2JpbGUgZGV2aWNlbSwgcHJldmVudCBzY3JlZW4gc2xpZGVyIG9uIHRoZSBidXR0b24uXG4gICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcbiAgICB9LFxuICAgIG9uZHJhZ2VuZDogb25EcmFnRW5kXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRIYWxmSG92ZXJMaW5rU2l6ZSh2aXN1YWxNYXBNb2RlbCwgZGF0YUV4dGVudCwgc2l6ZUV4dGVudCkge1xuICB2YXIgaGFsZkhvdmVyTGlua1NpemUgPSBIT1ZFUl9MSU5LX1NJWkUgLyAyO1xuICB2YXIgaG92ZXJMaW5rRGF0YVNpemUgPSB2aXN1YWxNYXBNb2RlbC5nZXQoJ2hvdmVyTGlua0RhdGFTaXplJyk7XG5cbiAgaWYgKGhvdmVyTGlua0RhdGFTaXplKSB7XG4gICAgaGFsZkhvdmVyTGlua1NpemUgPSBsaW5lYXJNYXAoaG92ZXJMaW5rRGF0YVNpemUsIGRhdGFFeHRlbnQsIHNpemVFeHRlbnQsIHRydWUpIC8gMjtcbiAgfVxuXG4gIHJldHVybiBoYWxmSG92ZXJMaW5rU2l6ZTtcbn1cblxuZnVuY3Rpb24gdXNlSG92ZXJMaW5rT25IYW5kbGUodmlzdWFsTWFwTW9kZWwpIHtcbiAgdmFyIGhvdmVyTGlua09uSGFuZGxlID0gdmlzdWFsTWFwTW9kZWwuZ2V0KCdob3ZlckxpbmtPbkhhbmRsZScpO1xuICByZXR1cm4gISEoaG92ZXJMaW5rT25IYW5kbGUgPT0gbnVsbCA/IHZpc3VhbE1hcE1vZGVsLmdldCgncmVhbHRpbWUnKSA6IGhvdmVyTGlua09uSGFuZGxlKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q3Vyc29yKG9yaWVudCkge1xuICByZXR1cm4gb3JpZW50ID09PSAndmVydGljYWwnID8gJ25zLXJlc2l6ZScgOiAnZXctcmVzaXplJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udGludW91c1ZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgVmlzdWFsTWFwTW9kZWwgZnJvbSAnLi9WaXN1YWxNYXBNb2RlbCc7XG5pbXBvcnQgVmlzdWFsTWFwcGluZyBmcm9tICcuLi8uLi92aXN1YWwvVmlzdWFsTWFwcGluZyc7XG5pbXBvcnQgdmlzdWFsRGVmYXVsdCBmcm9tICcuLi8uLi92aXN1YWwvdmlzdWFsRGVmYXVsdCc7XG5pbXBvcnQgeyByZWZvcm1JbnRlcnZhbHMgfSBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG5pbXBvcnQgeyBpbmhlcml0RGVmYXVsdE9wdGlvbiB9IGZyb20gJy4uLy4uL3V0aWwvY29tcG9uZW50JztcblxudmFyIFBpZWNld2lzZU1vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBpZWNld2lzZU1vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFBpZWNld2lzZU1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IFBpZWNld2lzZU1vZGVsLnR5cGU7XG4gICAgLyoqXG4gICAgICogVGhlIG9yZGVyIGlzIGFsd2F5cyBbbG93LCAuLi4sIGhpZ2hdLlxuICAgICAqIFt7dGV4dDogc3RyaW5nLCBpbnRlcnZhbDogQXJyYXkuPG51bWJlcj59LCAuLi5dXG4gICAgICovXG5cbiAgICBfdGhpcy5fcGllY2VMaXN0ID0gW107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUGllY2V3aXNlTW9kZWwucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQgPSBmdW5jdGlvbiAobmV3T3B0aW9uLCBpc0luaXQpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMucmVzZXRFeHRlbnQoKTtcblxuICAgIHZhciBtb2RlID0gdGhpcy5fbW9kZSA9IHRoaXMuX2RldGVybWluZU1vZGUoKTtcblxuICAgIHRoaXMuX3BpZWNlTGlzdCA9IFtdO1xuXG4gICAgcmVzZXRNZXRob2RzW3RoaXMuX21vZGVdLmNhbGwodGhpcywgdGhpcy5fcGllY2VMaXN0KTtcblxuICAgIHRoaXMuX3Jlc2V0U2VsZWN0ZWQobmV3T3B0aW9uLCBpc0luaXQpO1xuXG4gICAgdmFyIGNhdGVnb3JpZXMgPSB0aGlzLm9wdGlvbi5jYXRlZ29yaWVzO1xuICAgIHRoaXMucmVzZXRWaXN1YWwoZnVuY3Rpb24gKG1hcHBpbmdPcHRpb24sIHN0YXRlKSB7XG4gICAgICBpZiAobW9kZSA9PT0gJ2NhdGVnb3JpZXMnKSB7XG4gICAgICAgIG1hcHBpbmdPcHRpb24ubWFwcGluZ01ldGhvZCA9ICdjYXRlZ29yeSc7XG4gICAgICAgIG1hcHBpbmdPcHRpb24uY2F0ZWdvcmllcyA9IHpyVXRpbC5jbG9uZShjYXRlZ29yaWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcHBpbmdPcHRpb24uZGF0YUV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgICAgIG1hcHBpbmdPcHRpb24ubWFwcGluZ01ldGhvZCA9ICdwaWVjZXdpc2UnO1xuICAgICAgICBtYXBwaW5nT3B0aW9uLnBpZWNlTGlzdCA9IHpyVXRpbC5tYXAodGhpcy5fcGllY2VMaXN0LCBmdW5jdGlvbiAocGllY2UpIHtcbiAgICAgICAgICBwaWVjZSA9IHpyVXRpbC5jbG9uZShwaWVjZSk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUgIT09ICdpblJhbmdlJykge1xuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIC8vIG91dE9mUmFuZ2UgZG8gbm90IHN1cHBvcnQgc3BlY2lhbCB2aXN1YWwgaW4gcGllY2VzLlxuICAgICAgICAgICAgcGllY2UudmlzdWFsID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcGllY2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBQaWVjZXdpc2VNb2RlbC5wcm90b3R5cGUuY29tcGxldGVWaXN1YWxPcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOlxuICAgIC8vIHZpc3VhbE1hcDoge1xuICAgIC8vICAgICAgcGllY2VzOiBbe3N5bWJvbDogJ2NpcmNsZScsIGx0OiAwfSwge3N5bWJvbDogJ3JlY3QnLCBndGU6IDB9XVxuICAgIC8vIH1cbiAgICAvLyB3aGVyZSBubyBpblJhbmdlL291dE9mUmFuZ2Ugc2V0IGJ1dCBvbmx5IHBpZWNlcy4gU28gd2Ugc2hvdWxkIG1ha2VcbiAgICAvLyBkZWZhdWx0IGluUmFuZ2Uvb3V0T2ZSYW5nZSBmb3IgdGhpcyBjYXNlLCBvdGhlcndpc2UgdmlzdWFscyB0aGF0IG9ubHlcbiAgICAvLyBhcHBlYXIgaW4gYHBpZWNlc2Agd2lsbCBub3QgYmUgdGFrZW4gaW50byBhY2NvdW50IGluIHZpc3VhbCBlbmNvZGluZy5cbiAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIHZpc3VhbFR5cGVzSW5QaWVjZXMgPSB7fTtcbiAgICB2YXIgdmlzdWFsVHlwZXMgPSBWaXN1YWxNYXBwaW5nLmxpc3RWaXN1YWxUeXBlcygpO1xuICAgIHZhciBpc0NhdGVnb3J5ID0gdGhpcy5pc0NhdGVnb3J5KCk7XG4gICAgenJVdGlsLmVhY2gob3B0aW9uLnBpZWNlcywgZnVuY3Rpb24gKHBpZWNlKSB7XG4gICAgICB6clV0aWwuZWFjaCh2aXN1YWxUeXBlcywgZnVuY3Rpb24gKHZpc3VhbFR5cGUpIHtcbiAgICAgICAgaWYgKHBpZWNlLmhhc093blByb3BlcnR5KHZpc3VhbFR5cGUpKSB7XG4gICAgICAgICAgdmlzdWFsVHlwZXNJblBpZWNlc1t2aXN1YWxUeXBlXSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHpyVXRpbC5lYWNoKHZpc3VhbFR5cGVzSW5QaWVjZXMsIGZ1bmN0aW9uICh2LCB2aXN1YWxUeXBlKSB7XG4gICAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG4gICAgICB6clV0aWwuZWFjaCh0aGlzLnN0YXRlTGlzdCwgZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGV4aXN0cyA9IGV4aXN0cyB8fCBoYXMob3B0aW9uLCBzdGF0ZSwgdmlzdWFsVHlwZSkgfHwgaGFzKG9wdGlvbi50YXJnZXQsIHN0YXRlLCB2aXN1YWxUeXBlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgIWV4aXN0cyAmJiB6clV0aWwuZWFjaCh0aGlzLnN0YXRlTGlzdCwgZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIChvcHRpb25bc3RhdGVdIHx8IChvcHRpb25bc3RhdGVdID0ge30pKVt2aXN1YWxUeXBlXSA9IHZpc3VhbERlZmF1bHQuZ2V0KHZpc3VhbFR5cGUsIHN0YXRlID09PSAnaW5SYW5nZScgPyAnYWN0aXZlJyA6ICdpbmFjdGl2ZScsIGlzQ2F0ZWdvcnkpO1xuICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICBmdW5jdGlvbiBoYXMob2JqLCBzdGF0ZSwgdmlzdWFsVHlwZSkge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmpbc3RhdGVdICYmIG9ialtzdGF0ZV0uaGFzT3duUHJvcGVydHkodmlzdWFsVHlwZSk7XG4gICAgfVxuXG4gICAgX3N1cGVyLnByb3RvdHlwZS5jb21wbGV0ZVZpc3VhbE9wdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIFBpZWNld2lzZU1vZGVsLnByb3RvdHlwZS5fcmVzZXRTZWxlY3RlZCA9IGZ1bmN0aW9uIChuZXdPcHRpb24sIGlzSW5pdCkge1xuICAgIHZhciB0aGlzT3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIHBpZWNlTGlzdCA9IHRoaXMuX3BpZWNlTGlzdDsgLy8gU2VsZWN0ZWQgZG8gbm90IG1lcmdlIGJ1dCBhbGwgb3ZlcnJpZGUuXG5cbiAgICB2YXIgc2VsZWN0ZWQgPSAoaXNJbml0ID8gdGhpc09wdGlvbiA6IG5ld09wdGlvbikuc2VsZWN0ZWQgfHwge307XG4gICAgdGhpc09wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkOyAvLyBDb25zaWRlciAnbm90IHNwZWNpZmllZCcgbWVhbnMgdHJ1ZS5cblxuICAgIHpyVXRpbC5lYWNoKHBpZWNlTGlzdCwgZnVuY3Rpb24gKHBpZWNlLCBpbmRleCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0U2VsZWN0ZWRNYXBLZXkocGllY2UpO1xuXG4gICAgICBpZiAoIXNlbGVjdGVkLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgc2VsZWN0ZWRba2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAodGhpc09wdGlvbi5zZWxlY3RlZE1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0ZWQuXG4gICAgICB2YXIgaGFzU2VsXzEgPSBmYWxzZTtcbiAgICAgIHpyVXRpbC5lYWNoKHBpZWNlTGlzdCwgZnVuY3Rpb24gKHBpZWNlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5nZXRTZWxlY3RlZE1hcEtleShwaWVjZSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkW2tleV0pIHtcbiAgICAgICAgICBoYXNTZWxfMSA/IHNlbGVjdGVkW2tleV0gPSBmYWxzZSA6IGhhc1NlbF8xID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfSAvLyB0aGlzT3B0aW9uLnNlbGVjdGVkTW9kZSA9PT0gJ211bHRpcGxlJywgZGVmYXVsdDogYWxsIHNlbGVjdGVkLlxuXG4gIH07XG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqL1xuXG5cbiAgUGllY2V3aXNlTW9kZWwucHJvdG90eXBlLmdldFNlbGVjdGVkTWFwS2V5ID0gZnVuY3Rpb24gKHBpZWNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGUgPT09ICdjYXRlZ29yaWVzJyA/IHBpZWNlLnZhbHVlICsgJycgOiBwaWVjZS5pbmRleCArICcnO1xuICB9O1xuICAvKipcbiAgICogQHB1YmxpY1xuICAgKi9cblxuXG4gIFBpZWNld2lzZU1vZGVsLnByb3RvdHlwZS5nZXRQaWVjZUxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BpZWNlTGlzdDtcbiAgfTtcbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cblxuICBQaWVjZXdpc2VNb2RlbC5wcm90b3R5cGUuX2RldGVybWluZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIHJldHVybiBvcHRpb24ucGllY2VzICYmIG9wdGlvbi5waWVjZXMubGVuZ3RoID4gMCA/ICdwaWVjZXMnIDogdGhpcy5vcHRpb24uY2F0ZWdvcmllcyA/ICdjYXRlZ29yaWVzJyA6ICdzcGxpdE51bWJlcic7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBQaWVjZXdpc2VNb2RlbC5wcm90b3R5cGUuc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICB0aGlzLm9wdGlvbi5zZWxlY3RlZCA9IHpyVXRpbC5jbG9uZShzZWxlY3RlZCk7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBQaWVjZXdpc2VNb2RlbC5wcm90b3R5cGUuZ2V0VmFsdWVTdGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBpbmRleCA9IFZpc3VhbE1hcHBpbmcuZmluZFBpZWNlSW5kZXgodmFsdWUsIHRoaXMuX3BpZWNlTGlzdCk7XG4gICAgcmV0dXJuIGluZGV4ICE9IG51bGwgPyB0aGlzLm9wdGlvbi5zZWxlY3RlZFt0aGlzLmdldFNlbGVjdGVkTWFwS2V5KHRoaXMuX3BpZWNlTGlzdFtpbmRleF0pXSA/ICdpblJhbmdlJyA6ICdvdXRPZlJhbmdlJyA6ICdvdXRPZlJhbmdlJztcbiAgfTtcbiAgLyoqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHBpZWNlSW5kZXggcGllY2UgaW5kZXggaW4gdmlzdWFsTWFwTW9kZWwuZ2V0UGllY2VMaXN0KClcbiAgICovXG5cblxuICBQaWVjZXdpc2VNb2RlbC5wcm90b3R5cGUuZmluZFRhcmdldERhdGFJbmRpY2VzID0gZnVuY3Rpb24gKHBpZWNlSW5kZXgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHBpZWNlTGlzdCA9IHRoaXMuX3BpZWNlTGlzdDtcbiAgICB0aGlzLmVhY2hUYXJnZXRTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgZGF0YUluZGljZXMgPSBbXTtcbiAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgZGF0YS5lYWNoKHRoaXMuZ2V0RGF0YURpbWVuc2lvbihkYXRhKSwgZnVuY3Rpb24gKHZhbHVlLCBkYXRhSW5kZXgpIHtcbiAgICAgICAgLy8gU2hvdWxkIGFsd2F5cyBiYXNlIG9uIG1vZGVsIHBpZWNlTGlzdCwgYmVjYXVzZSBpdCBpcyBvcmRlciBzZW5zaXRpdmUuXG4gICAgICAgIHZhciBwSWR4ID0gVmlzdWFsTWFwcGluZy5maW5kUGllY2VJbmRleCh2YWx1ZSwgcGllY2VMaXN0KTtcbiAgICAgICAgcElkeCA9PT0gcGllY2VJbmRleCAmJiBkYXRhSW5kaWNlcy5wdXNoKGRhdGFJbmRleCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgc2VyaWVzSWQ6IHNlcmllc01vZGVsLmlkLFxuICAgICAgICBkYXRhSW5kZXg6IGRhdGFJbmRpY2VzXG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHBpZWNlIHBpZWNlLnZhbHVlIG9yIHBpZWNlLmludGVydmFsIGlzIHJlcXVpcmVkLlxuICAgKiBAcmV0dXJuICBDYW4gYmUgSW5maW5pdHkgb3IgLUluZmluaXR5XG4gICAqL1xuXG5cbiAgUGllY2V3aXNlTW9kZWwucHJvdG90eXBlLmdldFJlcHJlc2VudFZhbHVlID0gZnVuY3Rpb24gKHBpZWNlKSB7XG4gICAgdmFyIHJlcHJlc2VudFZhbHVlO1xuXG4gICAgaWYgKHRoaXMuaXNDYXRlZ29yeSgpKSB7XG4gICAgICByZXByZXNlbnRWYWx1ZSA9IHBpZWNlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGllY2UudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICByZXByZXNlbnRWYWx1ZSA9IHBpZWNlLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBpZWNlSW50ZXJ2YWwgPSBwaWVjZS5pbnRlcnZhbCB8fCBbXTtcbiAgICAgICAgcmVwcmVzZW50VmFsdWUgPSBwaWVjZUludGVydmFsWzBdID09PSAtSW5maW5pdHkgJiYgcGllY2VJbnRlcnZhbFsxXSA9PT0gSW5maW5pdHkgPyAwIDogKHBpZWNlSW50ZXJ2YWxbMF0gKyBwaWVjZUludGVydmFsWzFdKSAvIDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcHJlc2VudFZhbHVlO1xuICB9O1xuXG4gIFBpZWNld2lzZU1vZGVsLnByb3RvdHlwZS5nZXRWaXN1YWxNZXRhID0gZnVuY3Rpb24gKGdldENvbG9yVmlzdWFsKSB7XG4gICAgLy8gRG8gbm90IHN1cHBvcnQgY2F0ZWdvcnkuIChjYXRlZ29yeSBheGlzIGlzIG9yZGluYWwsIG51bWVyaWNhbClcbiAgICBpZiAodGhpcy5pc0NhdGVnb3J5KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RvcHMgPSBbXTtcbiAgICB2YXIgb3V0ZXJDb2xvcnMgPSBbJycsICcnXTtcbiAgICB2YXIgdmlzdWFsTWFwTW9kZWwgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gc2V0U3RvcChpbnRlcnZhbCwgdmFsdWVTdGF0ZSkge1xuICAgICAgdmFyIHJlcHJlc2VudFZhbHVlID0gdmlzdWFsTWFwTW9kZWwuZ2V0UmVwcmVzZW50VmFsdWUoe1xuICAgICAgICBpbnRlcnZhbDogaW50ZXJ2YWxcbiAgICAgIH0pOyAvLyBOb3QgY2F0ZWdvcnlcblxuICAgICAgaWYgKCF2YWx1ZVN0YXRlKSB7XG4gICAgICAgIHZhbHVlU3RhdGUgPSB2aXN1YWxNYXBNb2RlbC5nZXRWYWx1ZVN0YXRlKHJlcHJlc2VudFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9yID0gZ2V0Q29sb3JWaXN1YWwocmVwcmVzZW50VmFsdWUsIHZhbHVlU3RhdGUpO1xuXG4gICAgICBpZiAoaW50ZXJ2YWxbMF0gPT09IC1JbmZpbml0eSkge1xuICAgICAgICBvdXRlckNvbG9yc1swXSA9IGNvbG9yO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnZhbFsxXSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgb3V0ZXJDb2xvcnNbMV0gPSBjb2xvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3BzLnB1c2goe1xuICAgICAgICAgIHZhbHVlOiBpbnRlcnZhbFswXSxcbiAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgfSwge1xuICAgICAgICAgIHZhbHVlOiBpbnRlcnZhbFsxXSxcbiAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyBTdXBsZW1lbnRcblxuXG4gICAgdmFyIHBpZWNlTGlzdCA9IHRoaXMuX3BpZWNlTGlzdC5zbGljZSgpO1xuXG4gICAgaWYgKCFwaWVjZUxpc3QubGVuZ3RoKSB7XG4gICAgICBwaWVjZUxpc3QucHVzaCh7XG4gICAgICAgIGludGVydmFsOiBbLUluZmluaXR5LCBJbmZpbml0eV1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWRnZSA9IHBpZWNlTGlzdFswXS5pbnRlcnZhbFswXTtcbiAgICAgIGVkZ2UgIT09IC1JbmZpbml0eSAmJiBwaWVjZUxpc3QudW5zaGlmdCh7XG4gICAgICAgIGludGVydmFsOiBbLUluZmluaXR5LCBlZGdlXVxuICAgICAgfSk7XG4gICAgICBlZGdlID0gcGllY2VMaXN0W3BpZWNlTGlzdC5sZW5ndGggLSAxXS5pbnRlcnZhbFsxXTtcbiAgICAgIGVkZ2UgIT09IEluZmluaXR5ICYmIHBpZWNlTGlzdC5wdXNoKHtcbiAgICAgICAgaW50ZXJ2YWw6IFtlZGdlLCBJbmZpbml0eV1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBjdXJyID0gLUluZmluaXR5O1xuICAgIHpyVXRpbC5lYWNoKHBpZWNlTGlzdCwgZnVuY3Rpb24gKHBpZWNlKSB7XG4gICAgICB2YXIgaW50ZXJ2YWwgPSBwaWVjZS5pbnRlcnZhbDtcblxuICAgICAgaWYgKGludGVydmFsKSB7XG4gICAgICAgIC8vIEZ1bGZpbGwgZ2FwLlxuICAgICAgICBpbnRlcnZhbFswXSA+IGN1cnIgJiYgc2V0U3RvcChbY3VyciwgaW50ZXJ2YWxbMF1dLCAnb3V0T2ZSYW5nZScpO1xuICAgICAgICBzZXRTdG9wKGludGVydmFsLnNsaWNlKCkpO1xuICAgICAgICBjdXJyID0gaW50ZXJ2YWxbMV07XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0b3BzOiBzdG9wcyxcbiAgICAgIG91dGVyQ29sb3JzOiBvdXRlckNvbG9yc1xuICAgIH07XG4gIH07XG5cbiAgUGllY2V3aXNlTW9kZWwudHlwZSA9ICd2aXN1YWxNYXAucGllY2V3aXNlJztcbiAgUGllY2V3aXNlTW9kZWwuZGVmYXVsdE9wdGlvbiA9IGluaGVyaXREZWZhdWx0T3B0aW9uKFZpc3VhbE1hcE1vZGVsLmRlZmF1bHRPcHRpb24sIHtcbiAgICBzZWxlY3RlZDogbnVsbCxcbiAgICBtaW5PcGVuOiBmYWxzZSxcbiAgICBtYXhPcGVuOiBmYWxzZSxcbiAgICBhbGlnbjogJ2F1dG8nLFxuICAgIGl0ZW1XaWR0aDogMjAsXG4gICAgaXRlbUhlaWdodDogMTQsXG4gICAgaXRlbVN5bWJvbDogJ3JvdW5kUmVjdCcsXG4gICAgcGllY2VzOiBudWxsLFxuICAgIGNhdGVnb3JpZXM6IG51bGwsXG4gICAgc3BsaXROdW1iZXI6IDUsXG4gICAgc2VsZWN0ZWRNb2RlOiAnbXVsdGlwbGUnLFxuICAgIGl0ZW1HYXA6IDEwLFxuICAgIGhvdmVyTGluazogdHJ1ZSAvLyBFbmFibGUgaG92ZXIgaGlnaGxpZ2h0LlxuXG4gIH0pO1xuICByZXR1cm4gUGllY2V3aXNlTW9kZWw7XG59KFZpc3VhbE1hcE1vZGVsKTtcblxuO1xuLyoqXG4gKiBLZXkgaXMgdGhpcy5fbW9kZVxuICogQHR5cGUge09iamVjdH1cbiAqIEB0aGlzIHttb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvdml1c2FsTWFwL1BpZWNld2lzZU1vZGV9XG4gKi9cblxudmFyIHJlc2V0TWV0aG9kcyA9IHtcbiAgc3BsaXROdW1iZXI6IGZ1bmN0aW9uIChvdXRQaWVjZUxpc3QpIHtcbiAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIHZhciBwcmVjaXNpb24gPSBNYXRoLm1pbih0aGlzT3B0aW9uLnByZWNpc2lvbiwgMjApO1xuICAgIHZhciBkYXRhRXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgc3BsaXROdW1iZXIgPSB0aGlzT3B0aW9uLnNwbGl0TnVtYmVyO1xuICAgIHNwbGl0TnVtYmVyID0gTWF0aC5tYXgocGFyc2VJbnQoc3BsaXROdW1iZXIsIDEwKSwgMSk7XG4gICAgdGhpc09wdGlvbi5zcGxpdE51bWJlciA9IHNwbGl0TnVtYmVyO1xuICAgIHZhciBzcGxpdFN0ZXAgPSAoZGF0YUV4dGVudFsxXSAtIGRhdGFFeHRlbnRbMF0pIC8gc3BsaXROdW1iZXI7IC8vIFByZWNpc2lvbiBhdXRvLWFkYXB0aW9uXG5cbiAgICB3aGlsZSAoK3NwbGl0U3RlcC50b0ZpeGVkKHByZWNpc2lvbikgIT09IHNwbGl0U3RlcCAmJiBwcmVjaXNpb24gPCA1KSB7XG4gICAgICBwcmVjaXNpb24rKztcbiAgICB9XG5cbiAgICB0aGlzT3B0aW9uLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICBzcGxpdFN0ZXAgPSArc3BsaXRTdGVwLnRvRml4ZWQocHJlY2lzaW9uKTtcblxuICAgIGlmICh0aGlzT3B0aW9uLm1pbk9wZW4pIHtcbiAgICAgIG91dFBpZWNlTGlzdC5wdXNoKHtcbiAgICAgICAgaW50ZXJ2YWw6IFstSW5maW5pdHksIGRhdGFFeHRlbnRbMF1dLFxuICAgICAgICBjbG9zZTogWzAsIDBdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGN1cnIgPSBkYXRhRXh0ZW50WzBdOyBpbmRleCA8IHNwbGl0TnVtYmVyOyBjdXJyICs9IHNwbGl0U3RlcCwgaW5kZXgrKykge1xuICAgICAgdmFyIG1heCA9IGluZGV4ID09PSBzcGxpdE51bWJlciAtIDEgPyBkYXRhRXh0ZW50WzFdIDogY3VyciArIHNwbGl0U3RlcDtcbiAgICAgIG91dFBpZWNlTGlzdC5wdXNoKHtcbiAgICAgICAgaW50ZXJ2YWw6IFtjdXJyLCBtYXhdLFxuICAgICAgICBjbG9zZTogWzEsIDFdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpc09wdGlvbi5tYXhPcGVuKSB7XG4gICAgICBvdXRQaWVjZUxpc3QucHVzaCh7XG4gICAgICAgIGludGVydmFsOiBbZGF0YUV4dGVudFsxXSwgSW5maW5pdHldLFxuICAgICAgICBjbG9zZTogWzAsIDBdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZWZvcm1JbnRlcnZhbHMob3V0UGllY2VMaXN0KTtcbiAgICB6clV0aWwuZWFjaChvdXRQaWVjZUxpc3QsIGZ1bmN0aW9uIChwaWVjZSwgaW5kZXgpIHtcbiAgICAgIHBpZWNlLmluZGV4ID0gaW5kZXg7XG4gICAgICBwaWVjZS50ZXh0ID0gdGhpcy5mb3JtYXRWYWx1ZVRleHQocGllY2UuaW50ZXJ2YWwpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuICBjYXRlZ29yaWVzOiBmdW5jdGlvbiAob3V0UGllY2VMaXN0KSB7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB6clV0aWwuZWFjaCh0aGlzT3B0aW9uLmNhdGVnb3JpZXMsIGZ1bmN0aW9uIChjYXRlKSB7XG4gICAgICAvLyBGSVhNRSBjYXRlZ29yeeaooeW8j+S5n+S9v+eUqHBpZWNlTGlzdO+8jOS9huWcqHZpc3VhbE1hcHBpbmfkuK3kuI3mmK/kvb/nlKhwaWVjZUxpc3TjgIJcbiAgICAgIC8vIOaYr+WQpuaUueS4gOiHtOOAglxuICAgICAgb3V0UGllY2VMaXN0LnB1c2goe1xuICAgICAgICB0ZXh0OiB0aGlzLmZvcm1hdFZhbHVlVGV4dChjYXRlLCB0cnVlKSxcbiAgICAgICAgdmFsdWU6IGNhdGVcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMpOyAvLyBTZWUgXCJPcmRlciBSdWxlXCIuXG5cbiAgICBub3JtYWxpemVSZXZlcnNlKHRoaXNPcHRpb24sIG91dFBpZWNlTGlzdCk7XG4gIH0sXG4gIHBpZWNlczogZnVuY3Rpb24gKG91dFBpZWNlTGlzdCkge1xuICAgIHZhciB0aGlzT3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgenJVdGlsLmVhY2godGhpc09wdGlvbi5waWVjZXMsIGZ1bmN0aW9uIChwaWVjZUxpc3RJdGVtLCBpbmRleCkge1xuICAgICAgaWYgKCF6clV0aWwuaXNPYmplY3QocGllY2VMaXN0SXRlbSkpIHtcbiAgICAgICAgcGllY2VMaXN0SXRlbSA9IHtcbiAgICAgICAgICB2YWx1ZTogcGllY2VMaXN0SXRlbVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgdGV4dDogJycsXG4gICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgfTtcblxuICAgICAgaWYgKHBpZWNlTGlzdEl0ZW0ubGFiZWwgIT0gbnVsbCkge1xuICAgICAgICBpdGVtLnRleHQgPSBwaWVjZUxpc3RJdGVtLmxhYmVsO1xuICAgICAgfVxuXG4gICAgICBpZiAocGllY2VMaXN0SXRlbS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpdGVtLnZhbHVlID0gcGllY2VMaXN0SXRlbS52YWx1ZTtcbiAgICAgICAgaXRlbS5pbnRlcnZhbCA9IFt2YWx1ZSwgdmFsdWVdO1xuICAgICAgICBpdGVtLmNsb3NlID0gWzEsIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYG1pbmAgYG1heGAgaXMgbGVnYWN5IG9wdGlvbi5cbiAgICAgICAgLy8gYGx0YCBgZ3RgIGBsdGVgIGBndGVgIGlzIHJlY29tbWFuZGVkLlxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBpdGVtLmludGVydmFsID0gW107XG4gICAgICAgIHZhciBjbG9zZV8xID0gaXRlbS5jbG9zZSA9IFswLCAwXTtcbiAgICAgICAgdmFyIGNsb3NlTGlzdCA9IFsxLCAwLCAxXTtcbiAgICAgICAgdmFyIGluZmluaXR5TGlzdCA9IFstSW5maW5pdHksIEluZmluaXR5XTtcbiAgICAgICAgdmFyIHVzZU1pbk1heCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGxnID0gMDsgbGcgPCAyOyBsZysrKSB7XG4gICAgICAgICAgdmFyIG5hbWVzID0gW1snZ3RlJywgJ2d0JywgJ21pbiddLCBbJ2x0ZScsICdsdCcsICdtYXgnXV1bbGddO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzICYmIGludGVydmFsW2xnXSA9PSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgIGludGVydmFsW2xnXSA9IHBpZWNlTGlzdEl0ZW1bbmFtZXNbaV1dO1xuICAgICAgICAgICAgY2xvc2VfMVtsZ10gPSBjbG9zZUxpc3RbaV07XG4gICAgICAgICAgICB1c2VNaW5NYXhbbGddID0gaSA9PT0gMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbnRlcnZhbFtsZ10gPT0gbnVsbCAmJiAoaW50ZXJ2YWxbbGddID0gaW5maW5pdHlMaXN0W2xnXSk7XG4gICAgICAgIH1cblxuICAgICAgICB1c2VNaW5NYXhbMF0gJiYgaW50ZXJ2YWxbMV0gPT09IEluZmluaXR5ICYmIChjbG9zZV8xWzBdID0gMCk7XG4gICAgICAgIHVzZU1pbk1heFsxXSAmJiBpbnRlcnZhbFswXSA9PT0gLUluZmluaXR5ICYmIChjbG9zZV8xWzFdID0gMCk7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoaW50ZXJ2YWxbMF0gPiBpbnRlcnZhbFsxXSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdQaWVjZSAnICsgaW5kZXggKyAnaXMgaWxsZWdhbDogJyArIGludGVydmFsICsgJyBsb3dlciBib3VuZCBzaG91bGQgbm90IGdyZWF0ZXIgdGhlbiB1cHBwZXIgYm91bmQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludGVydmFsWzBdID09PSBpbnRlcnZhbFsxXSAmJiBjbG9zZV8xWzBdICYmIGNsb3NlXzFbMV0pIHtcbiAgICAgICAgICAvLyBDb25zaWRlcjogW3ttaW46IDUsIG1heDogNSwgdmlzdWFsOiB7Li4ufX0sIHttaW46IDAsIG1heDogNX1dLFxuICAgICAgICAgIC8vIHdlIHVzZSB2YWx1ZSB0byBsaWZ0IHRoZSBwcmlvcml0eSB3aGVuIG1pbiA9PT0gbWF4XG4gICAgICAgICAgaXRlbS52YWx1ZSA9IGludGVydmFsWzBdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGl0ZW0udmlzdWFsID0gVmlzdWFsTWFwcGluZy5yZXRyaWV2ZVZpc3VhbHMocGllY2VMaXN0SXRlbSk7XG4gICAgICBvdXRQaWVjZUxpc3QucHVzaChpdGVtKTtcbiAgICB9LCB0aGlzKTsgLy8gU2VlIFwiT3JkZXIgUnVsZVwiLlxuXG4gICAgbm9ybWFsaXplUmV2ZXJzZSh0aGlzT3B0aW9uLCBvdXRQaWVjZUxpc3QpOyAvLyBPbmx5IHBpZWNlc1xuXG4gICAgcmVmb3JtSW50ZXJ2YWxzKG91dFBpZWNlTGlzdCk7XG4gICAgenJVdGlsLmVhY2gob3V0UGllY2VMaXN0LCBmdW5jdGlvbiAocGllY2UpIHtcbiAgICAgIHZhciBjbG9zZSA9IHBpZWNlLmNsb3NlO1xuICAgICAgdmFyIGVkZ2VTeW1ib2xzID0gW1snPCcsICfiiaQnXVtjbG9zZVsxXV0sIFsnPicsICfiiaUnXVtjbG9zZVswXV1dO1xuICAgICAgcGllY2UudGV4dCA9IHBpZWNlLnRleHQgfHwgdGhpcy5mb3JtYXRWYWx1ZVRleHQocGllY2UudmFsdWUgIT0gbnVsbCA/IHBpZWNlLnZhbHVlIDogcGllY2UuaW50ZXJ2YWwsIGZhbHNlLCBlZGdlU3ltYm9scyk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJldmVyc2UodGhpc09wdGlvbiwgcGllY2VMaXN0KSB7XG4gIHZhciBpbnZlcnNlID0gdGhpc09wdGlvbi5pbnZlcnNlO1xuXG4gIGlmICh0aGlzT3B0aW9uLm9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/ICFpbnZlcnNlIDogaW52ZXJzZSkge1xuICAgIHBpZWNlTGlzdC5yZXZlcnNlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGllY2V3aXNlTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgVmlzdWFsTWFwVmlldyBmcm9tICcuL1Zpc3VhbE1hcFZpZXcnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IHsgY3JlYXRlU3ltYm9sIH0gZnJvbSAnLi4vLi4vdXRpbC9zeW1ib2wnO1xuaW1wb3J0ICogYXMgbGF5b3V0IGZyb20gJy4uLy4uL3V0aWwvbGF5b3V0JztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuL2hlbHBlcic7XG5cbnZhciBQaWVjZXdpc2VWaXN1YWxNYXBWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBpZWNld2lzZVZpc3VhbE1hcFZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gUGllY2V3aXNlVmlzdWFsTWFwVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBQaWVjZXdpc2VWaXN1YWxNYXBWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUGllY2V3aXNlVmlzdWFsTWFwVmlldy5wcm90b3R5cGUuZG9SZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoaXNHcm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdGhpc0dyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHZhciB2aXN1YWxNYXBNb2RlbCA9IHRoaXMudmlzdWFsTWFwTW9kZWw7XG4gICAgdmFyIHRleHRHYXAgPSB2aXN1YWxNYXBNb2RlbC5nZXQoJ3RleHRHYXAnKTtcbiAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSB2aXN1YWxNYXBNb2RlbC50ZXh0U3R5bGVNb2RlbDtcbiAgICB2YXIgdGV4dEZvbnQgPSB0ZXh0U3R5bGVNb2RlbC5nZXRGb250KCk7XG4gICAgdmFyIHRleHRGaWxsID0gdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCk7XG5cbiAgICB2YXIgaXRlbUFsaWduID0gdGhpcy5fZ2V0SXRlbUFsaWduKCk7XG5cbiAgICB2YXIgaXRlbVNpemUgPSB2aXN1YWxNYXBNb2RlbC5pdGVtU2l6ZTtcblxuICAgIHZhciB2aWV3RGF0YSA9IHRoaXMuX2dldFZpZXdEYXRhKCk7XG5cbiAgICB2YXIgZW5kc1RleHQgPSB2aWV3RGF0YS5lbmRzVGV4dDtcbiAgICB2YXIgc2hvd0xhYmVsID0genJVdGlsLnJldHJpZXZlKHZpc3VhbE1hcE1vZGVsLmdldCgnc2hvd0xhYmVsJywgdHJ1ZSksICFlbmRzVGV4dCk7XG4gICAgZW5kc1RleHQgJiYgdGhpcy5fcmVuZGVyRW5kc1RleHQodGhpc0dyb3VwLCBlbmRzVGV4dFswXSwgaXRlbVNpemUsIHNob3dMYWJlbCwgaXRlbUFsaWduKTtcbiAgICB6clV0aWwuZWFjaCh2aWV3RGF0YS52aWV3UGllY2VMaXN0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHBpZWNlID0gaXRlbS5waWVjZTtcbiAgICAgIHZhciBpdGVtR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgICAgaXRlbUdyb3VwLm9uY2xpY2sgPSB6clV0aWwuYmluZCh0aGlzLl9vbkl0ZW1DbGljaywgdGhpcywgcGllY2UpO1xuXG4gICAgICB0aGlzLl9lbmFibGVIb3ZlckxpbmsoaXRlbUdyb3VwLCBpdGVtLmluZGV4SW5Nb2RlbFBpZWNlTGlzdCk7IC8vIFRPRE8gQ2F0ZWdvcnlcblxuXG4gICAgICB2YXIgcmVwcmVzZW50VmFsdWUgPSB2aXN1YWxNYXBNb2RlbC5nZXRSZXByZXNlbnRWYWx1ZShwaWVjZSk7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZUl0ZW1TeW1ib2woaXRlbUdyb3VwLCByZXByZXNlbnRWYWx1ZSwgWzAsIDAsIGl0ZW1TaXplWzBdLCBpdGVtU2l6ZVsxXV0pO1xuXG4gICAgICBpZiAoc2hvd0xhYmVsKSB7XG4gICAgICAgIHZhciB2aXN1YWxTdGF0ZSA9IHRoaXMudmlzdWFsTWFwTW9kZWwuZ2V0VmFsdWVTdGF0ZShyZXByZXNlbnRWYWx1ZSk7XG4gICAgICAgIGl0ZW1Hcm91cC5hZGQobmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHg6IGl0ZW1BbGlnbiA9PT0gJ3JpZ2h0JyA/IC10ZXh0R2FwIDogaXRlbVNpemVbMF0gKyB0ZXh0R2FwLFxuICAgICAgICAgICAgeTogaXRlbVNpemVbMV0gLyAyLFxuICAgICAgICAgICAgdGV4dDogcGllY2UudGV4dCxcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICAgICAgYWxpZ246IGl0ZW1BbGlnbixcbiAgICAgICAgICAgIGZvbnQ6IHRleHRGb250LFxuICAgICAgICAgICAgZmlsbDogdGV4dEZpbGwsXG4gICAgICAgICAgICBvcGFjaXR5OiB2aXN1YWxTdGF0ZSA9PT0gJ291dE9mUmFuZ2UnID8gMC41IDogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzR3JvdXAuYWRkKGl0ZW1Hcm91cCk7XG4gICAgfSwgdGhpcyk7XG4gICAgZW5kc1RleHQgJiYgdGhpcy5fcmVuZGVyRW5kc1RleHQodGhpc0dyb3VwLCBlbmRzVGV4dFsxXSwgaXRlbVNpemUsIHNob3dMYWJlbCwgaXRlbUFsaWduKTtcbiAgICBsYXlvdXQuYm94KHZpc3VhbE1hcE1vZGVsLmdldCgnb3JpZW50JyksIHRoaXNHcm91cCwgdmlzdWFsTWFwTW9kZWwuZ2V0KCdpdGVtR2FwJykpO1xuICAgIHRoaXMucmVuZGVyQmFja2dyb3VuZCh0aGlzR3JvdXApO1xuICAgIHRoaXMucG9zaXRpb25Hcm91cCh0aGlzR3JvdXApO1xuICB9O1xuXG4gIFBpZWNld2lzZVZpc3VhbE1hcFZpZXcucHJvdG90eXBlLl9lbmFibGVIb3ZlckxpbmsgPSBmdW5jdGlvbiAoaXRlbUdyb3VwLCBwaWVjZUluZGV4KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGl0ZW1Hcm91cC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uSG92ZXJMaW5rKCdoaWdobGlnaHQnKTtcbiAgICB9KS5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb25Ib3ZlckxpbmsoJ2Rvd25wbGF5Jyk7XG4gICAgfSk7XG5cbiAgICB2YXIgb25Ib3ZlckxpbmsgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICB2YXIgdmlzdWFsTWFwTW9kZWwgPSBfdGhpcy52aXN1YWxNYXBNb2RlbDsgLy8gVE9ETzogVFlQRSBNb3JlIGRldGFpbGVkIGFjdGlvbiB0eXBlc1xuXG4gICAgICB2aXN1YWxNYXBNb2RlbC5vcHRpb24uaG92ZXJMaW5rICYmIF90aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgIHR5cGU6IG1ldGhvZCxcbiAgICAgICAgYmF0Y2g6IGhlbHBlci5tYWtlSGlnaERvd25CYXRjaCh2aXN1YWxNYXBNb2RlbC5maW5kVGFyZ2V0RGF0YUluZGljZXMocGllY2VJbmRleCksIHZpc3VhbE1hcE1vZGVsKVxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICBQaWVjZXdpc2VWaXN1YWxNYXBWaWV3LnByb3RvdHlwZS5fZ2V0SXRlbUFsaWduID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aXN1YWxNYXBNb2RlbCA9IHRoaXMudmlzdWFsTWFwTW9kZWw7XG4gICAgdmFyIG1vZGVsT3B0aW9uID0gdmlzdWFsTWFwTW9kZWwub3B0aW9uO1xuXG4gICAgaWYgKG1vZGVsT3B0aW9uLm9yaWVudCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgcmV0dXJuIGhlbHBlci5nZXRJdGVtQWxpZ24odmlzdWFsTWFwTW9kZWwsIHRoaXMuYXBpLCB2aXN1YWxNYXBNb2RlbC5pdGVtU2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvcml6b250YWwsIG1vc3QgY2FzZSBsZWZ0IHVubGVzcyBzcGVjaWZ5aW5nIHJpZ2h0LlxuICAgICAgdmFyIGFsaWduID0gbW9kZWxPcHRpb24uYWxpZ247XG5cbiAgICAgIGlmICghYWxpZ24gfHwgYWxpZ24gPT09ICdhdXRvJykge1xuICAgICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsaWduO1xuICAgIH1cbiAgfTtcblxuICBQaWVjZXdpc2VWaXN1YWxNYXBWaWV3LnByb3RvdHlwZS5fcmVuZGVyRW5kc1RleHQgPSBmdW5jdGlvbiAoZ3JvdXAsIHRleHQsIGl0ZW1TaXplLCBzaG93TGFiZWwsIGl0ZW1BbGlnbikge1xuICAgIGlmICghdGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpdGVtR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IHRoaXMudmlzdWFsTWFwTW9kZWwudGV4dFN0eWxlTW9kZWw7XG4gICAgaXRlbUdyb3VwLmFkZChuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHg6IHNob3dMYWJlbCA/IGl0ZW1BbGlnbiA9PT0gJ3JpZ2h0JyA/IGl0ZW1TaXplWzBdIDogMCA6IGl0ZW1TaXplWzBdIC8gMixcbiAgICAgICAgeTogaXRlbVNpemVbMV0gLyAyLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgYWxpZ246IHNob3dMYWJlbCA/IGl0ZW1BbGlnbiA6ICdjZW50ZXInLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBmb250OiB0ZXh0U3R5bGVNb2RlbC5nZXRGb250KCksXG4gICAgICAgIGZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGdyb3VwLmFkZChpdGVtR3JvdXApO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fSB7cGVpY2VMaXN0LCBlbmRzVGV4dH0gVGhlIG9yZGVyIGlzIHRoZSBzYW1lIGFzIHNjcmVlbiBwaXhlbCBvcmRlci5cbiAgICovXG5cblxuICBQaWVjZXdpc2VWaXN1YWxNYXBWaWV3LnByb3RvdHlwZS5fZ2V0Vmlld0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpc3VhbE1hcE1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbDtcbiAgICB2YXIgdmlld1BpZWNlTGlzdCA9IHpyVXRpbC5tYXAodmlzdWFsTWFwTW9kZWwuZ2V0UGllY2VMaXN0KCksIGZ1bmN0aW9uIChwaWVjZSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBpZWNlOiBwaWVjZSxcbiAgICAgICAgaW5kZXhJbk1vZGVsUGllY2VMaXN0OiBpbmRleFxuICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgZW5kc1RleHQgPSB2aXN1YWxNYXBNb2RlbC5nZXQoJ3RleHQnKTsgLy8gQ29uc2lkZXIgb3JpZW50IGFuZCBpbnZlcnNlLlxuXG4gICAgdmFyIG9yaWVudCA9IHZpc3VhbE1hcE1vZGVsLmdldCgnb3JpZW50Jyk7XG4gICAgdmFyIGludmVyc2UgPSB2aXN1YWxNYXBNb2RlbC5nZXQoJ2ludmVyc2UnKTsgLy8gT3JkZXIgb2YgbW9kZWwgcGllY2VMaXN0IGlzIGFsd2F5cyBbbG93LCAuLi4sIGhpZ2hdXG5cbiAgICBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyBpbnZlcnNlIDogIWludmVyc2UpIHtcbiAgICAgIHZpZXdQaWVjZUxpc3QucmV2ZXJzZSgpO1xuICAgIH0gLy8gT3JpZ2luIG9yZGVyIG9mIGVuZHNUZXh0IGlzIFtoaWdoLCBsb3ddXG4gICAgZWxzZSBpZiAoZW5kc1RleHQpIHtcbiAgICAgICAgZW5kc1RleHQgPSBlbmRzVGV4dC5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2aWV3UGllY2VMaXN0OiB2aWV3UGllY2VMaXN0LFxuICAgICAgZW5kc1RleHQ6IGVuZHNUZXh0XG4gICAgfTtcbiAgfTtcblxuICBQaWVjZXdpc2VWaXN1YWxNYXBWaWV3LnByb3RvdHlwZS5fY3JlYXRlSXRlbVN5bWJvbCA9IGZ1bmN0aW9uIChncm91cCwgcmVwcmVzZW50VmFsdWUsIHNoYXBlUGFyYW0pIHtcbiAgICBncm91cC5hZGQoY3JlYXRlU3ltYm9sKCAvLyBzeW1ib2wgd2lsbCBiZSBzdHJpbmdcbiAgICB0aGlzLmdldENvbnRyb2xsZXJWaXN1YWwocmVwcmVzZW50VmFsdWUsICdzeW1ib2wnKSwgc2hhcGVQYXJhbVswXSwgc2hhcGVQYXJhbVsxXSwgc2hhcGVQYXJhbVsyXSwgc2hhcGVQYXJhbVszXSwgLy8gY29sb3Igd2lsbCBiZSBzdHJpbmdcbiAgICB0aGlzLmdldENvbnRyb2xsZXJWaXN1YWwocmVwcmVzZW50VmFsdWUsICdjb2xvcicpKSk7XG4gIH07XG5cbiAgUGllY2V3aXNlVmlzdWFsTWFwVmlldy5wcm90b3R5cGUuX29uSXRlbUNsaWNrID0gZnVuY3Rpb24gKHBpZWNlKSB7XG4gICAgdmFyIHZpc3VhbE1hcE1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbDtcbiAgICB2YXIgb3B0aW9uID0gdmlzdWFsTWFwTW9kZWwub3B0aW9uO1xuICAgIHZhciBzZWxlY3RlZCA9IHpyVXRpbC5jbG9uZShvcHRpb24uc2VsZWN0ZWQpO1xuICAgIHZhciBuZXdLZXkgPSB2aXN1YWxNYXBNb2RlbC5nZXRTZWxlY3RlZE1hcEtleShwaWVjZSk7XG5cbiAgICBpZiAob3B0aW9uLnNlbGVjdGVkTW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIHNlbGVjdGVkW25ld0tleV0gPSB0cnVlO1xuICAgICAgenJVdGlsLmVhY2goc2VsZWN0ZWQsIGZ1bmN0aW9uIChvLCBrZXkpIHtcbiAgICAgICAgc2VsZWN0ZWRba2V5XSA9IGtleSA9PT0gbmV3S2V5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGVkW25ld0tleV0gPSAhc2VsZWN0ZWRbbmV3S2V5XTtcbiAgICB9XG5cbiAgICB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnc2VsZWN0RGF0YVJhbmdlJyxcbiAgICAgIGZyb206IHRoaXMudWlkLFxuICAgICAgdmlzdWFsTWFwSWQ6IHRoaXMudmlzdWFsTWFwTW9kZWwuaWQsXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWRcbiAgICB9KTtcbiAgfTtcblxuICBQaWVjZXdpc2VWaXN1YWxNYXBWaWV3LnR5cGUgPSAndmlzdWFsTWFwLnBpZWNld2lzZSc7XG4gIHJldHVybiBQaWVjZXdpc2VWaXN1YWxNYXBWaWV3O1xufShWaXN1YWxNYXBWaWV3KTtcblxuZXhwb3J0IGRlZmF1bHQgUGllY2V3aXNlVmlzdWFsTWFwVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBlbnYgZnJvbSAnenJlbmRlci9saWIvY29yZS9lbnYnO1xuaW1wb3J0IHZpc3VhbERlZmF1bHQgZnJvbSAnLi4vLi4vdmlzdWFsL3Zpc3VhbERlZmF1bHQnO1xuaW1wb3J0IFZpc3VhbE1hcHBpbmcgZnJvbSAnLi4vLi4vdmlzdWFsL1Zpc3VhbE1hcHBpbmcnO1xuaW1wb3J0ICogYXMgdmlzdWFsU29sdXRpb24gZnJvbSAnLi4vLi4vdmlzdWFsL3Zpc3VhbFNvbHV0aW9uJztcbmltcG9ydCAqIGFzIG1vZGVsVXRpbCBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbmltcG9ydCAqIGFzIG51bWJlclV0aWwgZnJvbSAnLi4vLi4vdXRpbC9udW1iZXInO1xuaW1wb3J0IENvbXBvbmVudE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL0NvbXBvbmVudCc7XG52YXIgbWFwVmlzdWFsID0gVmlzdWFsTWFwcGluZy5tYXBWaXN1YWw7XG52YXIgZWFjaFZpc3VhbCA9IFZpc3VhbE1hcHBpbmcuZWFjaFZpc3VhbDtcbnZhciBpc0FycmF5ID0genJVdGlsLmlzQXJyYXk7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIGFzYyA9IG51bWJlclV0aWwuYXNjO1xudmFyIGxpbmVhck1hcCA9IG51bWJlclV0aWwubGluZWFyTWFwO1xuXG52YXIgVmlzdWFsTWFwTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVmlzdWFsTWFwTW9kZWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gVmlzdWFsTWFwTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gVmlzdWFsTWFwTW9kZWwudHlwZTtcbiAgICBfdGhpcy5zdGF0ZUxpc3QgPSBbJ2luUmFuZ2UnLCAnb3V0T2ZSYW5nZSddO1xuICAgIF90aGlzLnJlcGxhY2FibGVPcHRpb25LZXlzID0gWydpblJhbmdlJywgJ291dE9mUmFuZ2UnLCAndGFyZ2V0JywgJ2NvbnRyb2xsZXInLCAnY29sb3InXTtcbiAgICBfdGhpcy5sYXlvdXRNb2RlID0ge1xuICAgICAgdHlwZTogJ2JveCcsXG4gICAgICBpZ25vcmVTaXplOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbbG93ZXJCb3VuZCwgdXBwZXJCb3VuZF1cbiAgICAgKi9cblxuICAgIF90aGlzLmRhdGFCb3VuZCA9IFstSW5maW5pdHksIEluZmluaXR5XTtcbiAgICBfdGhpcy50YXJnZXRWaXN1YWxzID0ge307XG4gICAgX3RoaXMuY29udHJvbGxlclZpc3VhbHMgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBWaXN1YWxNYXBNb2RlbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICB9O1xuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5vcHRpb25VcGRhdGVkID0gZnVuY3Rpb24gKG5ld09wdGlvbiwgaXNJbml0KSB7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjsgLy8gRklYTUVcbiAgICAvLyBuZWNlc3Nhcnk/XG4gICAgLy8gRGlzYWJsZSByZWFsdGltZSB2aWV3IHVwZGF0ZSBpZiBjYW52YXMgaXMgbm90IHN1cHBvcnRlZC5cblxuICAgIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgdGhpc09wdGlvbi5yZWFsdGltZSA9IGZhbHNlO1xuICAgIH1cblxuICAgICFpc0luaXQgJiYgdmlzdWFsU29sdXRpb24ucmVwbGFjZVZpc3VhbE9wdGlvbih0aGlzT3B0aW9uLCBuZXdPcHRpb24sIHRoaXMucmVwbGFjYWJsZU9wdGlvbktleXMpO1xuICAgIHRoaXMudGV4dFN0eWxlTW9kZWwgPSB0aGlzLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICB0aGlzLnJlc2V0SXRlbVNpemUoKTtcbiAgICB0aGlzLmNvbXBsZXRlVmlzdWFsT3B0aW9uKCk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cbiAgVmlzdWFsTWFwTW9kZWwucHJvdG90eXBlLnJlc2V0VmlzdWFsID0gZnVuY3Rpb24gKHN1cHBsZW1lbnRWaXN1YWxPcHRpb24pIHtcbiAgICB2YXIgc3RhdGVMaXN0ID0gdGhpcy5zdGF0ZUxpc3Q7XG4gICAgc3VwcGxlbWVudFZpc3VhbE9wdGlvbiA9IHpyVXRpbC5iaW5kKHN1cHBsZW1lbnRWaXN1YWxPcHRpb24sIHRoaXMpO1xuICAgIHRoaXMuY29udHJvbGxlclZpc3VhbHMgPSB2aXN1YWxTb2x1dGlvbi5jcmVhdGVWaXN1YWxNYXBwaW5ncyh0aGlzLm9wdGlvbi5jb250cm9sbGVyLCBzdGF0ZUxpc3QsIHN1cHBsZW1lbnRWaXN1YWxPcHRpb24pO1xuICAgIHRoaXMudGFyZ2V0VmlzdWFscyA9IHZpc3VhbFNvbHV0aW9uLmNyZWF0ZVZpc3VhbE1hcHBpbmdzKHRoaXMub3B0aW9uLnRhcmdldCwgc3RhdGVMaXN0LCBzdXBwbGVtZW50VmlzdWFsT3B0aW9uKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IEFuIGFycmF5IG9mIHNlcmllcyBpbmRpY2VzLlxuICAgKi9cblxuXG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5nZXRUYXJnZXRTZXJpZXNJbmRpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25TZXJpZXNJbmRleCA9IHRoaXMub3B0aW9uLnNlcmllc0luZGV4O1xuICAgIHZhciBzZXJpZXNJbmRpY2VzID0gW107XG5cbiAgICBpZiAob3B0aW9uU2VyaWVzSW5kZXggPT0gbnVsbCB8fCBvcHRpb25TZXJpZXNJbmRleCA9PT0gJ2FsbCcpIHtcbiAgICAgIHRoaXMuZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgaW5kZXgpIHtcbiAgICAgICAgc2VyaWVzSW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpZXNJbmRpY2VzID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkob3B0aW9uU2VyaWVzSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBzZXJpZXNJbmRpY2VzO1xuICB9O1xuICAvKipcbiAgICogQHB1YmxpY1xuICAgKi9cblxuXG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5lYWNoVGFyZ2V0U2VyaWVzID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgenJVdGlsLmVhY2godGhpcy5nZXRUYXJnZXRTZXJpZXNJbmRpY2VzKCksIGZ1bmN0aW9uIChzZXJpZXNJbmRleCkge1xuICAgICAgdmFyIHNlcmllc01vZGVsID0gdGhpcy5lY01vZGVsLmdldFNlcmllc0J5SW5kZXgoc2VyaWVzSW5kZXgpO1xuXG4gICAgICBpZiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBzZXJpZXNNb2RlbCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHViaWxjXG4gICAqL1xuXG5cbiAgVmlzdWFsTWFwTW9kZWwucHJvdG90eXBlLmlzVGFyZ2V0U2VyaWVzID0gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGlzID0gZmFsc2U7XG4gICAgdGhpcy5lYWNoVGFyZ2V0U2VyaWVzKGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgbW9kZWwgPT09IHNlcmllc01vZGVsICYmIChpcyA9IHRydWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMuZm9ybWF0VmFsdWVUZXh0KHNvbWVWYWwpOyAvLyBmb3JtYXQgc2luZ2xlIG51bWVyaWMgdmFsdWUgdG8gdGV4dC5cbiAgICogdGhpcy5mb3JtYXRWYWx1ZVRleHQoc29tZVZhbCwgdHJ1ZSk7IC8vIGZvcm1hdCBzaW5nbGUgY2F0ZWdvcnkgdmFsdWUgdG8gdGV4dC5cbiAgICogdGhpcy5mb3JtYXRWYWx1ZVRleHQoW21pbiwgbWF4XSk7IC8vIGZvcm1hdCBudW1lcmljIG1pbi1tYXggdG8gdGV4dC5cbiAgICogdGhpcy5mb3JtYXRWYWx1ZVRleHQoW3RoaXMuZGF0YUJvdW5kWzBdLCBtYXhdKTsgLy8gdXNpbmcgZGF0YSBsb3dlciBib3VuZC5cbiAgICogdGhpcy5mb3JtYXRWYWx1ZVRleHQoW21pbiwgdGhpcy5kYXRhQm91bmRbMV1dKTsgLy8gdXNpbmcgZGF0YSB1cHBlciBib3VuZC5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIFJlYWwgdmFsdWUsIG9yIHRoaXMuZGF0YUJvdW5kWzAgb3IgMV0uXG4gICAqIEBwYXJhbSBpc0NhdGVnb3J5IE9ubHkgYXZhaWxhYmxlIHdoZW4gdmFsdWUgaXMgbnVtYmVyLlxuICAgKiBAcGFyYW0gZWRnZVN5bWJvbHMgT3Blbi1jbG9zZSBzeW1ib2wgd2hlbiB2YWx1ZSBpcyBpbnRlcnZhbC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5mb3JtYXRWYWx1ZVRleHQgPSBmdW5jdGlvbiAodmFsdWUsIGlzQ2F0ZWdvcnksIGVkZ2VTeW1ib2xzKSB7XG4gICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIHZhciBwcmVjaXNpb24gPSBvcHRpb24ucHJlY2lzaW9uO1xuICAgIHZhciBkYXRhQm91bmQgPSB0aGlzLmRhdGFCb3VuZDtcbiAgICB2YXIgZm9ybWF0dGVyID0gb3B0aW9uLmZvcm1hdHRlcjtcbiAgICB2YXIgaXNNaW5NYXg7XG4gICAgZWRnZVN5bWJvbHMgPSBlZGdlU3ltYm9scyB8fCBbJzwnLCAnPiddO1xuXG4gICAgaWYgKHpyVXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgaXNNaW5NYXggPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciB0ZXh0VmFsdWUgPSBpc0NhdGVnb3J5ID8gdmFsdWUgLy8gVmFsdWUgaXMgc3RyaW5nIHdoZW4gaXNDYXRlZ29yeVxuICAgIDogaXNNaW5NYXggPyBbdG9GaXhlZCh2YWx1ZVswXSksIHRvRml4ZWQodmFsdWVbMV0pXSA6IHRvRml4ZWQodmFsdWUpO1xuXG4gICAgaWYgKHpyVXRpbC5pc1N0cmluZyhmb3JtYXR0ZXIpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyLnJlcGxhY2UoJ3t2YWx1ZX0nLCBpc01pbk1heCA/IHRleHRWYWx1ZVswXSA6IHRleHRWYWx1ZSkucmVwbGFjZSgne3ZhbHVlMn0nLCBpc01pbk1heCA/IHRleHRWYWx1ZVsxXSA6IHRleHRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh6clV0aWwuaXNGdW5jdGlvbihmb3JtYXR0ZXIpKSB7XG4gICAgICByZXR1cm4gaXNNaW5NYXggPyBmb3JtYXR0ZXIodmFsdWVbMF0sIHZhbHVlWzFdKSA6IGZvcm1hdHRlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTWluTWF4KSB7XG4gICAgICBpZiAodmFsdWVbMF0gPT09IGRhdGFCb3VuZFswXSkge1xuICAgICAgICByZXR1cm4gZWRnZVN5bWJvbHNbMF0gKyAnICcgKyB0ZXh0VmFsdWVbMV07XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlWzFdID09PSBkYXRhQm91bmRbMV0pIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VTeW1ib2xzWzFdICsgJyAnICsgdGV4dFZhbHVlWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRleHRWYWx1ZVswXSArICcgLSAnICsgdGV4dFZhbHVlWzFdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3JtYXQgc2luZ2xlIHZhbHVlIChpbmNsdWRlcyBjYXRlZ29yeSBjYXNlKS5cbiAgICAgIHJldHVybiB0ZXh0VmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9GaXhlZCh2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgPT09IGRhdGFCb3VuZFswXSA/ICdtaW4nIDogdmFsID09PSBkYXRhQm91bmRbMV0gPyAnbWF4JyA6ICgrdmFsKS50b0ZpeGVkKE1hdGgubWluKHByZWNpc2lvbiwgMjApKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cbiAgVmlzdWFsTWFwTW9kZWwucHJvdG90eXBlLnJlc2V0RXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGlzT3B0aW9uID0gdGhpcy5vcHRpb247IC8vIENhbiBub3QgY2FsY3VsYXRlIGRhdGEgZXh0ZW50IGJ5IGRhdGEgaGVyZS5cbiAgICAvLyBCZWNhdXNlIHNlcmllcyBhbmQgZGF0YSBtYXkgYmUgbW9kaWZpZWQgaW4gcHJvY2Vzc2luZyBzdGFnZS5cbiAgICAvLyBTbyB3ZSBkbyBub3Qgc3VwcG9ydCB0aGUgZmVhdHVyZSBcImF1dG8gbWluL21heFwiLlxuXG4gICAgdmFyIGV4dGVudCA9IGFzYyhbdGhpc09wdGlvbi5taW4sIHRoaXNPcHRpb24ubWF4XSk7XG4gICAgdGhpcy5fZGF0YUV4dGVudCA9IGV4dGVudDtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybiAgQ29uY3JldGUgZGltZW50aW9uLiBJZiByZXR1cm4gbnVsbC91bmRlZmluZWQsIG5vIGRpbWVuc2lvbiB1c2VkLlxuICAgKi9cblxuXG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5nZXREYXRhRGltZW5zaW9uID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICB2YXIgb3B0RGltID0gdGhpcy5vcHRpb24uZGltZW5zaW9uO1xuICAgIHZhciBsaXN0RGltZW5zaW9ucyA9IGxpc3QuZGltZW5zaW9ucztcblxuICAgIGlmIChvcHREaW0gPT0gbnVsbCAmJiAhbGlzdERpbWVuc2lvbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdERpbSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gbGlzdC5nZXREaW1lbnNpb24ob3B0RGltKTtcbiAgICB9XG5cbiAgICB2YXIgZGltTmFtZXMgPSBsaXN0LmRpbWVuc2lvbnM7XG5cbiAgICBmb3IgKHZhciBpID0gZGltTmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBkaW1OYW1lID0gZGltTmFtZXNbaV07XG4gICAgICB2YXIgZGltSW5mbyA9IGxpc3QuZ2V0RGltZW5zaW9uSW5mbyhkaW1OYW1lKTtcblxuICAgICAgaWYgKCFkaW1JbmZvLmlzQ2FsY3VsYXRpb25Db29yZCkge1xuICAgICAgICByZXR1cm4gZGltTmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgVmlzdWFsTWFwTW9kZWwucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YUV4dGVudC5zbGljZSgpO1xuICB9O1xuXG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5jb21wbGV0ZVZpc3VhbE9wdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIHZhciBiYXNlID0ge1xuICAgICAgaW5SYW5nZTogdGhpc09wdGlvbi5pblJhbmdlLFxuICAgICAgb3V0T2ZSYW5nZTogdGhpc09wdGlvbi5vdXRPZlJhbmdlXG4gICAgfTtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpc09wdGlvbi50YXJnZXQgfHwgKHRoaXNPcHRpb24udGFyZ2V0ID0ge30pO1xuICAgIHZhciBjb250cm9sbGVyID0gdGhpc09wdGlvbi5jb250cm9sbGVyIHx8ICh0aGlzT3B0aW9uLmNvbnRyb2xsZXIgPSB7fSk7XG4gICAgenJVdGlsLm1lcmdlKHRhcmdldCwgYmFzZSk7IC8vIERvIG5vdCBvdmVycmlkZVxuXG4gICAgenJVdGlsLm1lcmdlKGNvbnRyb2xsZXIsIGJhc2UpOyAvLyBEbyBub3Qgb3ZlcnJpZGVcblxuICAgIHZhciBpc0NhdGVnb3J5ID0gdGhpcy5pc0NhdGVnb3J5KCk7XG4gICAgY29tcGxldGVTaW5nbGUuY2FsbCh0aGlzLCB0YXJnZXQpO1xuICAgIGNvbXBsZXRlU2luZ2xlLmNhbGwodGhpcywgY29udHJvbGxlcik7XG4gICAgY29tcGxldGVJbmFjdGl2ZS5jYWxsKHRoaXMsIHRhcmdldCwgJ2luUmFuZ2UnLCAnb3V0T2ZSYW5nZScpOyAvLyBjb21wbGV0ZUluYWN0aXZlLmNhbGwodGhpcywgdGFyZ2V0LCAnb3V0T2ZSYW5nZScsICdpblJhbmdlJyk7XG5cbiAgICBjb21wbGV0ZUNvbnRyb2xsZXIuY2FsbCh0aGlzLCBjb250cm9sbGVyKTtcblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlU2luZ2xlKGJhc2UpIHtcbiAgICAgIC8vIENvbXBhdGlibGUgd2l0aCBlYzIgZGF0YVJhbmdlLmNvbG9yLlxuICAgICAgLy8gVGhlIG1hcHBpbmcgb3JkZXIgb2YgZGF0YVJhbmdlLmNvbG9yIGlzOiBbaGlnaCB2YWx1ZSwgLi4uLCBsb3cgdmFsdWVdXG4gICAgICAvLyB3aGVyZWFzIGluUmFuZ2UuY29sb3IgYW5kIG91dE9mUmFuZ2UuY29sb3IgaXMgW2xvdyB2YWx1ZSwgLi4uLCBoaWdoIHZhbHVlXVxuICAgICAgLy8gTm90aWNlOiBlYzIgaGFzIG5vIGludmVyc2UuXG4gICAgICBpZiAoaXNBcnJheSh0aGlzT3B0aW9uLmNvbG9yKSAvLyBJZiB0aGVyZSBoYXMgYmVlbiBpblJhbmdlOiB7c3ltYm9sOiAuLi59LCBhZGRpbmcgY29sb3IgaXMgYSBtaXN0YWtlLlxuICAgICAgLy8gU28gYWRkaW5nIGNvbG9yIG9ubHkgd2hlbiBubyBpblJhbmdlIGRlZmluZWQuXG4gICAgICAmJiAhYmFzZS5pblJhbmdlKSB7XG4gICAgICAgIGJhc2UuaW5SYW5nZSA9IHtcbiAgICAgICAgICBjb2xvcjogdGhpc09wdGlvbi5jb2xvci5zbGljZSgpLnJldmVyc2UoKVxuICAgICAgICB9O1xuICAgICAgfSAvLyBDb21wYXRpYmxlIHdpdGggcHJldmlvdXMgbG9naWMsIGFsd2F5cyBnaXZlIGEgZGVmYXV0bCBjb2xvciwgb3RoZXJ3aXNlXG4gICAgICAvLyBzaW1wbGUgY29uZmlnIHdpdGggbm8gaW5SYW5nZSBhbmQgb3V0T2ZSYW5nZSB3aWxsIG5vdCB3b3JrLlxuICAgICAgLy8gT3JpZ2luYWxseSB3ZSB1c2UgdmlzdWFsTWFwLmNvbG9yIGFzIHRoZSBkZWZhdWx0IGNvbG9yLCBidXQgc2V0T3B0aW9uIGF0XG4gICAgICAvLyB0aGUgc2Vjb25kIHRpbWUgdGhlIGRlZmF1bHQgY29sb3Igd2lsbCBiZSBlcmFzZWQuIFNvIHdlIGNoYW5nZSB0byB1c2VcbiAgICAgIC8vIGNvbnN0YW50IERFRkFVTFRfQ09MT1IuXG4gICAgICAvLyBJZiB1c2VyIGRvIG5vdCB3YW50IHRoZSBkZWZhdWx0IGNvbG9yLCBzZXQgaW5SYW5nZToge2NvbG9yOiBudWxsfS5cblxuXG4gICAgICBiYXNlLmluUmFuZ2UgPSBiYXNlLmluUmFuZ2UgfHwge1xuICAgICAgICBjb2xvcjogZWNNb2RlbC5nZXQoJ2dyYWRpZW50Q29sb3InKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZUluYWN0aXZlKGJhc2UsIHN0YXRlRXhpc3QsIHN0YXRlQWJzZW50KSB7XG4gICAgICB2YXIgb3B0RXhpc3QgPSBiYXNlW3N0YXRlRXhpc3RdO1xuICAgICAgdmFyIG9wdEFic2VudCA9IGJhc2Vbc3RhdGVBYnNlbnRdO1xuXG4gICAgICBpZiAob3B0RXhpc3QgJiYgIW9wdEFic2VudCkge1xuICAgICAgICBvcHRBYnNlbnQgPSBiYXNlW3N0YXRlQWJzZW50XSA9IHt9O1xuICAgICAgICBlYWNoKG9wdEV4aXN0LCBmdW5jdGlvbiAodmlzdWFsRGF0YSwgdmlzdWFsVHlwZSkge1xuICAgICAgICAgIGlmICghVmlzdWFsTWFwcGluZy5pc1ZhbGlkVHlwZSh2aXN1YWxUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkZWZhID0gdmlzdWFsRGVmYXVsdC5nZXQodmlzdWFsVHlwZSwgJ2luYWN0aXZlJywgaXNDYXRlZ29yeSk7XG5cbiAgICAgICAgICBpZiAoZGVmYSAhPSBudWxsKSB7XG4gICAgICAgICAgICBvcHRBYnNlbnRbdmlzdWFsVHlwZV0gPSBkZWZhOyAvLyBDb21wYXRpYmFibGUgd2l0aCBlYzI6XG4gICAgICAgICAgICAvLyBPbmx5IGluYWN0aXZlIGNvbG9yIHRvIHJnYmEoMCwwLDAsMCkgY2FuIG5vdFxuICAgICAgICAgICAgLy8gbWFrZSBsYWJlbCB0cmFuc3BhcmVudCwgc28gdXNlIG9wYWNpdHkgYWxzby5cblxuICAgICAgICAgICAgaWYgKHZpc3VhbFR5cGUgPT09ICdjb2xvcicgJiYgIW9wdEFic2VudC5oYXNPd25Qcm9wZXJ0eSgnb3BhY2l0eScpICYmICFvcHRBYnNlbnQuaGFzT3duUHJvcGVydHkoJ2NvbG9yQWxwaGEnKSkge1xuICAgICAgICAgICAgICBvcHRBYnNlbnQub3BhY2l0eSA9IFswLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlQ29udHJvbGxlcihjb250cm9sbGVyKSB7XG4gICAgICB2YXIgc3ltYm9sRXhpc3RzID0gKGNvbnRyb2xsZXIuaW5SYW5nZSB8fCB7fSkuc3ltYm9sIHx8IChjb250cm9sbGVyLm91dE9mUmFuZ2UgfHwge30pLnN5bWJvbDtcbiAgICAgIHZhciBzeW1ib2xTaXplRXhpc3RzID0gKGNvbnRyb2xsZXIuaW5SYW5nZSB8fCB7fSkuc3ltYm9sU2l6ZSB8fCAoY29udHJvbGxlci5vdXRPZlJhbmdlIHx8IHt9KS5zeW1ib2xTaXplO1xuICAgICAgdmFyIGluYWN0aXZlQ29sb3IgPSB0aGlzLmdldCgnaW5hY3RpdmVDb2xvcicpO1xuICAgICAgZWFjaCh0aGlzLnN0YXRlTGlzdCwgZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemU7XG4gICAgICAgIHZhciB2aXN1YWxzID0gY29udHJvbGxlcltzdGF0ZV07IC8vIFNldCBpbmFjdGl2ZSBjb2xvciBmb3IgY29udHJvbGxlciBpZiBubyBvdGhlciBjb2xvclxuICAgICAgICAvLyBhdHRyIChsaWtlIGNvbG9yQWxwaGEpIHNwZWNpZmllZC5cblxuICAgICAgICBpZiAoIXZpc3VhbHMpIHtcbiAgICAgICAgICB2aXN1YWxzID0gY29udHJvbGxlcltzdGF0ZV0gPSB7XG4gICAgICAgICAgICBjb2xvcjogaXNDYXRlZ29yeSA/IGluYWN0aXZlQ29sb3IgOiBbaW5hY3RpdmVDb2xvcl1cbiAgICAgICAgICB9O1xuICAgICAgICB9IC8vIENvbnNpc3RlbnQgc3ltYm9sIGFuZCBzeW1ib2xTaXplIGlmIG5vdCBzcGVjaWZpZWQuXG5cblxuICAgICAgICBpZiAodmlzdWFscy5zeW1ib2wgPT0gbnVsbCkge1xuICAgICAgICAgIHZpc3VhbHMuc3ltYm9sID0gc3ltYm9sRXhpc3RzICYmIHpyVXRpbC5jbG9uZShzeW1ib2xFeGlzdHMpIHx8IChpc0NhdGVnb3J5ID8gJ3JvdW5kUmVjdCcgOiBbJ3JvdW5kUmVjdCddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2aXN1YWxzLnN5bWJvbFNpemUgPT0gbnVsbCkge1xuICAgICAgICAgIHZpc3VhbHMuc3ltYm9sU2l6ZSA9IHN5bWJvbFNpemVFeGlzdHMgJiYgenJVdGlsLmNsb25lKHN5bWJvbFNpemVFeGlzdHMpIHx8IChpc0NhdGVnb3J5ID8gaXRlbVNpemVbMF0gOiBbaXRlbVNpemVbMF0sIGl0ZW1TaXplWzBdXSk7XG4gICAgICAgIH0gLy8gRmlsdGVyIHNxdWFyZSBhbmQgbm9uZS5cblxuXG4gICAgICAgIHZpc3VhbHMuc3ltYm9sID0gbWFwVmlzdWFsKHZpc3VhbHMuc3ltYm9sLCBmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgICAgICAgcmV0dXJuIHN5bWJvbCA9PT0gJ25vbmUnIHx8IHN5bWJvbCA9PT0gJ3NxdWFyZScgPyAncm91bmRSZWN0JyA6IHN5bWJvbDtcbiAgICAgICAgfSk7IC8vIE5vcm1hbGl6ZSBzeW1ib2xTaXplXG5cbiAgICAgICAgdmFyIHN5bWJvbFNpemUgPSB2aXN1YWxzLnN5bWJvbFNpemU7XG5cbiAgICAgICAgaWYgKHN5bWJvbFNpemUgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBtYXhfMSA9IC1JbmZpbml0eTsgLy8gc3ltYm9sU2l6ZSBjYW4gYmUgb2JqZWN0IHdoZW4gY2F0ZWdvcmllcyBkZWZpbmVkLlxuXG4gICAgICAgICAgZWFjaFZpc3VhbChzeW1ib2xTaXplLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID4gbWF4XzEgJiYgKG1heF8xID0gdmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZpc3VhbHMuc3ltYm9sU2l6ZSA9IG1hcFZpc3VhbChzeW1ib2xTaXplLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lYXJNYXAodmFsdWUsIFswLCBtYXhfMV0sIFswLCBpdGVtU2l6ZVswXV0sIHRydWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgVmlzdWFsTWFwTW9kZWwucHJvdG90eXBlLnJlc2V0SXRlbVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pdGVtU2l6ZSA9IFtwYXJzZUZsb2F0KHRoaXMuZ2V0KCdpdGVtV2lkdGgnKSksIHBhcnNlRmxvYXQodGhpcy5nZXQoJ2l0ZW1IZWlnaHQnKSldO1xuICB9O1xuXG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5pc0NhdGVnb3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMub3B0aW9uLmNhdGVnb3JpZXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5zZXRTZWxlY3RlZCA9IGZ1bmN0aW9uIChzZWxlY3RlZCkge307XG5cbiAgVmlzdWFsTWFwTW9kZWwucHJvdG90eXBlLmdldFNlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBWaXN1YWxNYXBNb2RlbC5wcm90b3R5cGUuZ2V0VmFsdWVTdGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuICAvKipcbiAgICogRklYTUVcbiAgICogRG8gbm90IHB1Ymxpc2ggdG8gdGhpcnQtcGFydC1kZXYgdGVtcG9yYXJpbHlcbiAgICogdXRpbCB0aGUgaW50ZXJmYWNlIGlzIHN0YWJsZS4gKFNob3VsZCBpdCByZXR1cm5cbiAgICogYSBmdW5jdGlvbiBidXQgbm90IHZpc3VhbCBtZXRhPylcbiAgICpcbiAgICogQHB1YmlsY1xuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIGdldENvbG9yVmlzdWFsXG4gICAqICAgICAgICBwYXJhbXM6IHZhbHVlLCB2YWx1ZVN0YXRlXG4gICAqICAgICAgICByZXR1cm46IGNvbG9yXG4gICAqIEByZXR1cm4ge09iamVjdH0gdmlzdWFsTWV0YVxuICAgKiAgICAgICAgc2hvdWxkIGluY2x1ZGVzIHtzdG9wcywgb3V0ZXJDb2xvcnN9XG4gICAqICAgICAgICBvdXRlckNvbG9yIG1lYW5zIFtjb2xvckJleW9uZE1pblZhbHVlLCBjb2xvckJleW9uZE1heFZhbHVlXVxuICAgKi9cblxuXG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5nZXRWaXN1YWxNZXRhID0gZnVuY3Rpb24gKGdldENvbG9yVmlzdWFsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgVmlzdWFsTWFwTW9kZWwudHlwZSA9ICd2aXN1YWxNYXAnO1xuICBWaXN1YWxNYXBNb2RlbC5kZXBlbmRlbmNpZXMgPSBbJ3NlcmllcyddO1xuICBWaXN1YWxNYXBNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIHNob3c6IHRydWUsXG4gICAgemxldmVsOiAwLFxuICAgIHo6IDQsXG4gICAgc2VyaWVzSW5kZXg6ICdhbGwnLFxuICAgIG1pbjogMCxcbiAgICBtYXg6IDIwMCxcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiBudWxsLFxuICAgIHRvcDogbnVsbCxcbiAgICBib3R0b206IDAsXG4gICAgaXRlbVdpZHRoOiBudWxsLFxuICAgIGl0ZW1IZWlnaHQ6IG51bGwsXG4gICAgaW52ZXJzZTogZmFsc2UsXG4gICAgb3JpZW50OiAndmVydGljYWwnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgY29udGVudENvbG9yOiAnIzU3OTNmMycsXG4gICAgaW5hY3RpdmVDb2xvcjogJyNhYWEnLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIHBhZGRpbmc6IDUsXG4gICAgLy8g5o6l5Y+X5pWw57uE5YiG5Yir6K6+5a6a5LiK5Y+z5LiL5bem6L656Led77yM5ZCMY3NzXG4gICAgdGV4dEdhcDogMTAsXG4gICAgcHJlY2lzaW9uOiAwLFxuICAgIHRleHRTdHlsZToge1xuICAgICAgY29sb3I6ICcjMzMzJyAvLyDlgLzln5/mloflrZfpopzoibJcblxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFZpc3VhbE1hcE1vZGVsO1xufShDb21wb25lbnRNb2RlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IFZpc3VhbE1hcE1vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgUmVjdCB9IGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgKiBhcyBmb3JtYXRVdGlsIGZyb20gJy4uLy4uL3V0aWwvZm9ybWF0JztcbmltcG9ydCAqIGFzIGxheW91dCBmcm9tICcuLi8uLi91dGlsL2xheW91dCc7XG5pbXBvcnQgVmlzdWFsTWFwcGluZyBmcm9tICcuLi8uLi92aXN1YWwvVmlzdWFsTWFwcGluZyc7XG5pbXBvcnQgQ29tcG9uZW50VmlldyBmcm9tICcuLi8uLi92aWV3L0NvbXBvbmVudCc7XG5cbnZhciBWaXN1YWxNYXBWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFZpc3VhbE1hcFZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gVmlzdWFsTWFwVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBWaXN1YWxNYXBWaWV3LnR5cGU7XG4gICAgX3RoaXMuYXV0b1Bvc2l0aW9uVmFsdWVzID0ge1xuICAgICAgbGVmdDogMSxcbiAgICAgIHJpZ2h0OiAxLFxuICAgICAgdG9wOiAxLFxuICAgICAgYm90dG9tOiAxXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBWaXN1YWxNYXBWaWV3LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuZWNNb2RlbCA9IGVjTW9kZWw7XG4gICAgdGhpcy5hcGkgPSBhcGk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cbiAgVmlzdWFsTWFwVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHZpc3VhbE1hcE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQgLy8gVE9ETzogVFlQRVxuICApIHtcbiAgICB0aGlzLnZpc3VhbE1hcE1vZGVsID0gdmlzdWFsTWFwTW9kZWw7XG5cbiAgICBpZiAodmlzdWFsTWFwTW9kZWwuZ2V0KCdzaG93JykgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZG9SZW5kZXIodmlzdWFsTWFwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cbiAgVmlzdWFsTWFwVmlldy5wcm90b3R5cGUucmVuZGVyQmFja2dyb3VuZCA9IGZ1bmN0aW9uIChncm91cCkge1xuICAgIHZhciB2aXN1YWxNYXBNb2RlbCA9IHRoaXMudmlzdWFsTWFwTW9kZWw7XG4gICAgdmFyIHBhZGRpbmcgPSBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KHZpc3VhbE1hcE1vZGVsLmdldCgncGFkZGluZycpIHx8IDApO1xuICAgIHZhciByZWN0ID0gZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgZ3JvdXAuYWRkKG5ldyBSZWN0KHtcbiAgICAgIHoyOiAtMSxcbiAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHg6IHJlY3QueCAtIHBhZGRpbmdbM10sXG4gICAgICAgIHk6IHJlY3QueSAtIHBhZGRpbmdbMF0sXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoICsgcGFkZGluZ1szXSArIHBhZGRpbmdbMV0sXG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKyBwYWRkaW5nWzBdICsgcGFkZGluZ1syXVxuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGZpbGw6IHZpc3VhbE1hcE1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyksXG4gICAgICAgIHN0cm9rZTogdmlzdWFsTWFwTW9kZWwuZ2V0KCdib3JkZXJDb2xvcicpLFxuICAgICAgICBsaW5lV2lkdGg6IHZpc3VhbE1hcE1vZGVsLmdldCgnYm9yZGVyV2lkdGgnKVxuICAgICAgfVxuICAgIH0pKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHRhcmdldFZhbHVlIGNhbiBiZSBJbmZpbml0eSBvciAtSW5maW5pdHlcbiAgICogQHBhcmFtIHZpc3VhbENsdXN0ZXIgT25seSBjYW4gYmUgJ2NvbG9yJyAnb3BhY2l0eScgJ3N5bWJvbCcgJ3N5bWJvbFNpemUnXG4gICAqIEBwYXJhbSBvcHRzXG4gICAqIEBwYXJhbSBvcHRzLmZvcmNlU3RhdGUgU3BlY2lmeSBzdGF0ZSwgaW5zdGVhZCBvZiB1c2luZyBnZXRWYWx1ZVN0YXRlIG1ldGhvZC5cbiAgICogQHBhcmFtIG9wdHMuY29udmVydE9wYWNpdHlUb0FscGhhIEZvciBjb2xvciBncmFkaWVudCBpbiBjb250cm9sbGVyIHdpZGdldC5cbiAgICogQHJldHVybiB7Kn0gVmlzdWFsIHZhbHVlLlxuICAgKi9cblxuXG4gIFZpc3VhbE1hcFZpZXcucHJvdG90eXBlLmdldENvbnRyb2xsZXJWaXN1YWwgPSBmdW5jdGlvbiAodGFyZ2V0VmFsdWUsIHZpc3VhbENsdXN0ZXIsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgZm9yY2VTdGF0ZSA9IG9wdHMuZm9yY2VTdGF0ZTtcbiAgICB2YXIgdmlzdWFsTWFwTW9kZWwgPSB0aGlzLnZpc3VhbE1hcE1vZGVsO1xuICAgIHZhciB2aXN1YWxPYmogPSB7fTsgLy8gRGVmYXVsdCB2YWx1ZXMuXG5cbiAgICBpZiAodmlzdWFsQ2x1c3RlciA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHZpc3VhbE9iai5zeW1ib2wgPSB2aXN1YWxNYXBNb2RlbC5nZXQoJ2l0ZW1TeW1ib2wnKTtcbiAgICB9XG5cbiAgICBpZiAodmlzdWFsQ2x1c3RlciA9PT0gJ2NvbG9yJykge1xuICAgICAgdmFyIGRlZmF1bHRDb2xvciA9IHZpc3VhbE1hcE1vZGVsLmdldCgnY29udGVudENvbG9yJyk7XG4gICAgICB2aXN1YWxPYmouY29sb3IgPSBkZWZhdWx0Q29sb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0dGVyKGtleSkge1xuICAgICAgcmV0dXJuIHZpc3VhbE9ialtrZXldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHRlcihrZXksIHZhbHVlKSB7XG4gICAgICB2aXN1YWxPYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBtYXBwaW5ncyA9IHZpc3VhbE1hcE1vZGVsLmNvbnRyb2xsZXJWaXN1YWxzW2ZvcmNlU3RhdGUgfHwgdmlzdWFsTWFwTW9kZWwuZ2V0VmFsdWVTdGF0ZSh0YXJnZXRWYWx1ZSldO1xuICAgIHZhciB2aXN1YWxUeXBlcyA9IFZpc3VhbE1hcHBpbmcucHJlcGFyZVZpc3VhbFR5cGVzKG1hcHBpbmdzKTtcbiAgICB6clV0aWwuZWFjaCh2aXN1YWxUeXBlcywgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciB2aXN1YWxNYXBwaW5nID0gbWFwcGluZ3NbdHlwZV07XG5cbiAgICAgIGlmIChvcHRzLmNvbnZlcnRPcGFjaXR5VG9BbHBoYSAmJiB0eXBlID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgdHlwZSA9ICdjb2xvckFscGhhJztcbiAgICAgICAgdmlzdWFsTWFwcGluZyA9IG1hcHBpbmdzLl9fYWxwaGFGb3JPcGFjaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAoVmlzdWFsTWFwcGluZy5kZXBlbmRzT24odHlwZSwgdmlzdWFsQ2x1c3RlcikpIHtcbiAgICAgICAgdmlzdWFsTWFwcGluZyAmJiB2aXN1YWxNYXBwaW5nLmFwcGx5VmlzdWFsKHRhcmdldFZhbHVlLCBnZXR0ZXIsIHNldHRlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZpc3VhbE9ialt2aXN1YWxDbHVzdGVyXTtcbiAgfTtcblxuICBWaXN1YWxNYXBWaWV3LnByb3RvdHlwZS5wb3NpdGlvbkdyb3VwID0gZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgdmFyIG1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbDtcbiAgICB2YXIgYXBpID0gdGhpcy5hcGk7XG4gICAgbGF5b3V0LnBvc2l0aW9uRWxlbWVudChncm91cCwgbW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCksIHtcbiAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgfSk7XG4gIH07XG5cbiAgVmlzdWFsTWFwVmlldy5wcm90b3R5cGUuZG9SZW5kZXIgPSBmdW5jdGlvbiAodmlzdWFsTWFwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge307XG5cbiAgVmlzdWFsTWFwVmlldy50eXBlID0gJ3Zpc3VhbE1hcCc7XG4gIHJldHVybiBWaXN1YWxNYXBWaWV3O1xufShDb21wb25lbnRWaWV3KTtcblxuZXhwb3J0IGRlZmF1bHQgVmlzdWFsTWFwVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBnZXRMYXlvdXRSZWN0IH0gZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQnO1xudmFyIHBhcmFtc1NldCA9IFtbJ2xlZnQnLCAncmlnaHQnLCAnd2lkdGgnXSwgWyd0b3AnLCAnYm90dG9tJywgJ2hlaWdodCddXTtcbi8qKlxuICogQHBhcmFtIHZpc3VhbE1hcE1vZGVsXG4gKiBAcGFyYW0gYXBpXG4gKiBAcGFyYW0gaXRlbVNpemUgYWx3YXlzIFtzaG9ydCwgbG9uZ11cbiAqIEByZXR1cm4ge3N0cmluZ30gJ2xlZnQnIG9yICdyaWdodCcgb3IgJ3RvcCcgb3IgJ2JvdHRvbSdcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXRlbUFsaWduKHZpc3VhbE1hcE1vZGVsLCBhcGksIGl0ZW1TaXplKSB7XG4gIHZhciBtb2RlbE9wdGlvbiA9IHZpc3VhbE1hcE1vZGVsLm9wdGlvbjtcbiAgdmFyIGl0ZW1BbGlnbiA9IG1vZGVsT3B0aW9uLmFsaWduO1xuXG4gIGlmIChpdGVtQWxpZ24gIT0gbnVsbCAmJiBpdGVtQWxpZ24gIT09ICdhdXRvJykge1xuICAgIHJldHVybiBpdGVtQWxpZ247XG4gIH0gLy8gQXV0byBkZWNpc2lvbiBhbGlnbi5cblxuXG4gIHZhciBlY1NpemUgPSB7XG4gICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gIH07XG4gIHZhciByZWFsSW5kZXggPSBtb2RlbE9wdGlvbi5vcmllbnQgPT09ICdob3Jpem9udGFsJyA/IDEgOiAwO1xuICB2YXIgcmVhbHMgPSBwYXJhbXNTZXRbcmVhbEluZGV4XTtcbiAgdmFyIGZha2VWYWx1ZSA9IFswLCBudWxsLCAxMF07XG4gIHZhciBsYXlvdXRJbnB1dCA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgbGF5b3V0SW5wdXRbcGFyYW1zU2V0WzEgLSByZWFsSW5kZXhdW2ldXSA9IGZha2VWYWx1ZVtpXTtcbiAgICBsYXlvdXRJbnB1dFtyZWFsc1tpXV0gPSBpID09PSAyID8gaXRlbVNpemVbMF0gOiBtb2RlbE9wdGlvbltyZWFsc1tpXV07XG4gIH1cblxuICB2YXIgclBhcmFtID0gW1sneCcsICd3aWR0aCcsIDNdLCBbJ3knLCAnaGVpZ2h0JywgMF1dW3JlYWxJbmRleF07XG4gIHZhciByZWN0ID0gZ2V0TGF5b3V0UmVjdChsYXlvdXRJbnB1dCwgZWNTaXplLCBtb2RlbE9wdGlvbi5wYWRkaW5nKTtcbiAgcmV0dXJuIHJlYWxzWyhyZWN0Lm1hcmdpbltyUGFyYW1bMl1dIHx8IDApICsgcmVjdFtyUGFyYW1bMF1dICsgcmVjdFtyUGFyYW1bMV1dICogMC41IDwgZWNTaXplW3JQYXJhbVsxXV0gKiAwLjUgPyAwIDogMV07XG59XG4vKipcbiAqIFByZXBhcmUgZGF0YUluZGV4IGZvciBvdXRzaWRlIHVzYWdlLCB3aGVyZSBkYXRhSW5kZXggbWVhbnMgcmF3SW5kZXgsIGFuZFxuICogZGF0YUluZGV4SW5zaWRlIG1lYW5zIGZpbHRlcmVkIGluZGV4LlxuICovXG4vLyBUT0RPOiBUWVBFIG1vcmUgc3BlY2lmaWVkIHBheWxvYWQgdHlwZXMuXG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSGlnaERvd25CYXRjaChiYXRjaCwgdmlzdWFsTWFwTW9kZWwpIHtcbiAgenJVdGlsLmVhY2goYmF0Y2ggfHwgW10sIGZ1bmN0aW9uIChiYXRjaEl0ZW0pIHtcbiAgICBpZiAoYmF0Y2hJdGVtLmRhdGFJbmRleCAhPSBudWxsKSB7XG4gICAgICBiYXRjaEl0ZW0uZGF0YUluZGV4SW5zaWRlID0gYmF0Y2hJdGVtLmRhdGFJbmRleDtcbiAgICAgIGJhdGNoSXRlbS5kYXRhSW5kZXggPSBudWxsO1xuICAgIH1cblxuICAgIGJhdGNoSXRlbS5oaWdobGlnaHRLZXkgPSAndmlzdWFsTWFwJyArICh2aXN1YWxNYXBNb2RlbCA/IHZpc3VhbE1hcE1vZGVsLmNvbXBvbmVudEluZGV4IDogJycpO1xuICB9KTtcbiAgcmV0dXJuIGJhdGNoO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyB1c2UgfSBmcm9tICcuLi8uLi9leHRlbnNpb24nO1xuaW1wb3J0IHsgaW5zdGFsbCBhcyBpbnN0YWxsVmlzdWFsTWFwQ29udGludW91cyB9IGZyb20gJy4vaW5zdGFsbFZpc3VhbE1hcENvbnRpbnVvdXMnO1xuaW1wb3J0IHsgaW5zdGFsbCBhcyBpbnN0YWxsVmlzdWFsTWFwUGllY2V3aXNlIH0gZnJvbSAnLi9pbnN0YWxsVmlzdWFsTWFwUGllY2V3aXNlJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICB1c2UoaW5zdGFsbFZpc3VhbE1hcENvbnRpbnVvdXMpO1xuICB1c2UoaW5zdGFsbFZpc3VhbE1hcFBpZWNld2lzZSk7IC8vIERvIG5vdCBpbnN0YWxsICcuL2RhdGFab29tU2VsZWN0JyxcbiAgLy8gc2luY2UgaXQgb25seSB3b3JrIGZvciB0b29sYm94IGRhdGFab29tLlxufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyB2aXN1YWxNYXBBY3Rpb25JbmZvLCB2aXN1YWxNYXBBY3Rpb25IYW5kZXIgfSBmcm9tICcuL3Zpc3VhbE1hcEFjdGlvbic7XG5pbXBvcnQgeyB2aXN1YWxNYXBFbmNvZGluZ0hhbmRsZXJzIH0gZnJvbSAnLi92aXN1YWxFbmNvZGluZyc7XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBwcmVwcm9jZXNzb3IgZnJvbSAnLi9wcmVwcm9jZXNzb3InO1xudmFyIGluc3RhbGxlZCA9IGZhbHNlO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5zdGFsbENvbW1vbihyZWdpc3RlcnMpIHtcbiAgaWYgKGluc3RhbGxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGluc3RhbGxlZCA9IHRydWU7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIoJ3Zpc3VhbE1hcCcsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAvLyBDb21wYXRpYmxlIHdpdGggZWMyLCB3aGVuIHNwbGl0TnVtYmVyID09PSAwLCBjb250aW51b3VzIHZpc3VhbE1hcCB3aWxsIGJlIHVzZWQuXG4gICAgcmV0dXJuICFvcHRpb24uY2F0ZWdvcmllcyAmJiAoIShvcHRpb24ucGllY2VzID8gb3B0aW9uLnBpZWNlcy5sZW5ndGggPiAwIDogb3B0aW9uLnNwbGl0TnVtYmVyID4gMCkgfHwgb3B0aW9uLmNhbGN1bGFibGUpID8gJ2NvbnRpbnVvdXMnIDogJ3BpZWNld2lzZSc7XG4gIH0pO1xuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24odmlzdWFsTWFwQWN0aW9uSW5mbywgdmlzdWFsTWFwQWN0aW9uSGFuZGVyKTtcbiAgZWFjaCh2aXN1YWxNYXBFbmNvZGluZ0hhbmRsZXJzLCBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHJlZ2lzdGVycy5yZWdpc3RlclZpc3VhbChyZWdpc3RlcnMuUFJJT1JJVFkuVklTVUFMLkNPTVBPTkVOVCwgaGFuZGxlcik7XG4gIH0pO1xuICByZWdpc3RlcnMucmVnaXN0ZXJQcmVwcm9jZXNzb3IocHJlcHJvY2Vzc29yKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IENvbnRpbnVvdXNNb2RlbCBmcm9tICcuL0NvbnRpbnVvdXNNb2RlbCc7XG5pbXBvcnQgQ29udGludW91c1ZpZXcgZnJvbSAnLi9Db250aW51b3VzVmlldyc7XG5pbXBvcnQgaW5zdGFsbENvbW1vbiBmcm9tICcuL2luc3RhbGxDb21tb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKENvbnRpbnVvdXNNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoQ29udGludW91c1ZpZXcpO1xuICBpbnN0YWxsQ29tbW9uKHJlZ2lzdGVycyk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCBQaWVjZXdpc2VNb2RlbCBmcm9tICcuL1BpZWNld2lzZU1vZGVsJztcbmltcG9ydCBQaWVjZXdpc2VWaWV3IGZyb20gJy4vUGllY2V3aXNlVmlldyc7XG5pbXBvcnQgaW5zdGFsbENvbW1vbiBmcm9tICcuL2luc3RhbGxDb21tb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKFBpZWNld2lzZU1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhQaWVjZXdpc2VWaWV3KTtcbiAgaW5zdGFsbENvbW1vbihyZWdpc3RlcnMpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBAdHMtbm9jaGVja1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmlzdWFsTWFwUHJlcHJvY2Vzc29yKG9wdGlvbikge1xuICB2YXIgdmlzdWFsTWFwID0gb3B0aW9uICYmIG9wdGlvbi52aXN1YWxNYXA7XG5cbiAgaWYgKCF6clV0aWwuaXNBcnJheSh2aXN1YWxNYXApKSB7XG4gICAgdmlzdWFsTWFwID0gdmlzdWFsTWFwID8gW3Zpc3VhbE1hcF0gOiBbXTtcbiAgfVxuXG4gIGVhY2godmlzdWFsTWFwLCBmdW5jdGlvbiAob3B0KSB7XG4gICAgaWYgKCFvcHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHJlbmFtZSBzcGxpdExpc3QgdG8gcGllY2VzXG5cblxuICAgIGlmIChoYXMob3B0LCAnc3BsaXRMaXN0JykgJiYgIWhhcyhvcHQsICdwaWVjZXMnKSkge1xuICAgICAgb3B0LnBpZWNlcyA9IG9wdC5zcGxpdExpc3Q7XG4gICAgICBkZWxldGUgb3B0LnNwbGl0TGlzdDtcbiAgICB9XG5cbiAgICB2YXIgcGllY2VzID0gb3B0LnBpZWNlcztcblxuICAgIGlmIChwaWVjZXMgJiYgenJVdGlsLmlzQXJyYXkocGllY2VzKSkge1xuICAgICAgZWFjaChwaWVjZXMsIGZ1bmN0aW9uIChwaWVjZSkge1xuICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KHBpZWNlKSkge1xuICAgICAgICAgIGlmIChoYXMocGllY2UsICdzdGFydCcpICYmICFoYXMocGllY2UsICdtaW4nKSkge1xuICAgICAgICAgICAgcGllY2UubWluID0gcGllY2Uuc3RhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhcyhwaWVjZSwgJ2VuZCcpICYmICFoYXMocGllY2UsICdtYXgnKSkge1xuICAgICAgICAgICAgcGllY2UubWF4ID0gcGllY2UuZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFzKG9iaiwgbmFtZSkge1xuICByZXR1cm4gb2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eSAmJiBvYmouaGFzT3duUHJvcGVydHkobmFtZSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgdmlzdWFsU29sdXRpb24gZnJvbSAnLi4vLi4vdmlzdWFsL3Zpc3VhbFNvbHV0aW9uJztcbmltcG9ydCBWaXN1YWxNYXBwaW5nIGZyb20gJy4uLy4uL3Zpc3VhbC9WaXN1YWxNYXBwaW5nJztcbmltcG9ydCB7IGdldFZpc3VhbEZyb21EYXRhIH0gZnJvbSAnLi4vLi4vdmlzdWFsL2hlbHBlcic7XG5leHBvcnQgdmFyIHZpc3VhbE1hcEVuY29kaW5nSGFuZGxlcnMgPSBbe1xuICBjcmVhdGVPbkFsbFNlcmllczogdHJ1ZSxcbiAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgIHZhciByZXNldERlZmluZXMgPSBbXTtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ3Zpc3VhbE1hcCcsIGZ1bmN0aW9uICh2aXN1YWxNYXBNb2RlbCkge1xuICAgICAgdmFyIHBpcGVsaW5lQ29udGV4dCA9IHNlcmllc01vZGVsLnBpcGVsaW5lQ29udGV4dDtcblxuICAgICAgaWYgKCF2aXN1YWxNYXBNb2RlbC5pc1RhcmdldFNlcmllcyhzZXJpZXNNb2RlbCkgfHwgcGlwZWxpbmVDb250ZXh0ICYmIHBpcGVsaW5lQ29udGV4dC5sYXJnZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc2V0RGVmaW5lcy5wdXNoKHZpc3VhbFNvbHV0aW9uLmluY3JlbWVudGFsQXBwbHlWaXN1YWwodmlzdWFsTWFwTW9kZWwuc3RhdGVMaXN0LCB2aXN1YWxNYXBNb2RlbC50YXJnZXRWaXN1YWxzLCB6clV0aWwuYmluZCh2aXN1YWxNYXBNb2RlbC5nZXRWYWx1ZVN0YXRlLCB2aXN1YWxNYXBNb2RlbCksIHZpc3VhbE1hcE1vZGVsLmdldERhdGFEaW1lbnNpb24oc2VyaWVzTW9kZWwuZ2V0RGF0YSgpKSkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXNldERlZmluZXM7XG4gIH1cbn0sIC8vIE9ubHkgc3VwcG9ydCBjb2xvci5cbntcbiAgY3JlYXRlT25BbGxTZXJpZXM6IHRydWUsXG4gIHJlc2V0OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgdmlzdWFsTWV0YUxpc3QgPSBbXTtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ3Zpc3VhbE1hcCcsIGZ1bmN0aW9uICh2aXN1YWxNYXBNb2RlbCkge1xuICAgICAgaWYgKHZpc3VhbE1hcE1vZGVsLmlzVGFyZ2V0U2VyaWVzKHNlcmllc01vZGVsKSkge1xuICAgICAgICB2YXIgdmlzdWFsTWV0YSA9IHZpc3VhbE1hcE1vZGVsLmdldFZpc3VhbE1ldGEoenJVdGlsLmJpbmQoZ2V0Q29sb3JWaXN1YWwsIG51bGwsIHNlcmllc01vZGVsLCB2aXN1YWxNYXBNb2RlbCkpIHx8IHtcbiAgICAgICAgICBzdG9wczogW10sXG4gICAgICAgICAgb3V0ZXJDb2xvcnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb25jcmV0ZURpbSA9IHZpc3VhbE1hcE1vZGVsLmdldERhdGFEaW1lbnNpb24oZGF0YSk7XG4gICAgICAgIHZhciBkaW1JbmZvID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGNvbmNyZXRlRGltKTtcblxuICAgICAgICBpZiAoZGltSW5mbyAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gdmlzdWFsTWV0YS5kaW1lbnNpb24gc2hvdWxkIGJlIGRpbWVuc2lvbiBpbmRleCwgYnV0IG5vdCBjb25jcmV0ZSBkaW1lbnNpb24uXG4gICAgICAgICAgdmlzdWFsTWV0YS5kaW1lbnNpb24gPSBkaW1JbmZvLmluZGV4O1xuICAgICAgICAgIHZpc3VhbE1ldGFMaXN0LnB1c2godmlzdWFsTWV0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkodmlzdWFsTWV0YUxpc3QubWFwKGEgPT4gYS5zdG9wcykpKTtcblxuICAgIHNlcmllc01vZGVsLmdldERhdGEoKS5zZXRWaXN1YWwoJ3Zpc3VhbE1ldGEnLCB2aXN1YWxNZXRhTGlzdCk7XG4gIH1cbn1dOyAvLyBGSVhNRVxuLy8gcGVyZm9ybWFuY2UgYW5kIGV4cG9ydCBmb3IgaGVhdG1hcD9cbi8vIHZhbHVlIGNhbiBiZSBJbmZpbml0eSBvciAtSW5maW5pdHlcblxuZnVuY3Rpb24gZ2V0Q29sb3JWaXN1YWwoc2VyaWVzTW9kZWwsIHZpc3VhbE1hcE1vZGVsLCB2YWx1ZSwgdmFsdWVTdGF0ZSkge1xuICB2YXIgbWFwcGluZ3MgPSB2aXN1YWxNYXBNb2RlbC50YXJnZXRWaXN1YWxzW3ZhbHVlU3RhdGVdO1xuICB2YXIgdmlzdWFsVHlwZXMgPSBWaXN1YWxNYXBwaW5nLnByZXBhcmVWaXN1YWxUeXBlcyhtYXBwaW5ncyk7XG4gIHZhciByZXN1bHRWaXN1YWwgPSB7XG4gICAgY29sb3I6IGdldFZpc3VhbEZyb21EYXRhKHNlcmllc01vZGVsLmdldERhdGEoKSwgJ2NvbG9yJykgLy8gZGVmYXVsdCBjb2xvci5cblxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2aXN1YWxUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB0eXBlID0gdmlzdWFsVHlwZXNbaV07XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBwaW5nc1t0eXBlID09PSAnb3BhY2l0eScgPyAnX19hbHBoYUZvck9wYWNpdHknIDogdHlwZV07XG4gICAgbWFwcGluZyAmJiBtYXBwaW5nLmFwcGx5VmlzdWFsKHZhbHVlLCBnZXRWaXN1YWwsIHNldFZpc3VhbCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0VmlzdWFsLmNvbG9yO1xuXG4gIGZ1bmN0aW9uIGdldFZpc3VhbChrZXkpIHtcbiAgICByZXR1cm4gcmVzdWx0VmlzdWFsW2tleV07XG4gIH1cblxuICBmdW5jdGlvbiBzZXRWaXN1YWwoa2V5LCB2YWx1ZSkge1xuICAgIHJlc3VsdFZpc3VhbFtrZXldID0gdmFsdWU7XG4gIH1cbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuZXhwb3J0IHZhciB2aXN1YWxNYXBBY3Rpb25JbmZvID0ge1xuICB0eXBlOiAnc2VsZWN0RGF0YVJhbmdlJyxcbiAgZXZlbnQ6ICdkYXRhUmFuZ2VTZWxlY3RlZCcsXG4gIC8vIEZJWE1FIHVzZSB1cGRhdGVWaWV3IGFwcGVhcnMgd3JvbmdcbiAgdXBkYXRlOiAndXBkYXRlJ1xufTtcbmV4cG9ydCB2YXIgdmlzdWFsTWFwQWN0aW9uSGFuZGVyID0gZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICBtYWluVHlwZTogJ3Zpc3VhbE1hcCcsXG4gICAgcXVlcnk6IHBheWxvYWRcbiAgfSwgZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgbW9kZWwuc2V0U2VsZWN0ZWQocGF5bG9hZC5zZWxlY3RlZCk7XG4gIH0pO1xufTsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgKiBhcyBsYXlvdXQgZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQnO1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi8uLi91dGlsL251bWJlcic7IC8vICgyNCo2MCo2MCoxMDAwKVxuXG52YXIgUFJPWElNQVRFX09ORV9EQVkgPSA4NjQwMDAwMDtcblxudmFyIENhbGVuZGFyID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2FsZW5kYXIoY2FsZW5kYXJNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy50eXBlID0gJ2NhbGVuZGFyJztcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBDYWxlbmRhci5kaW1lbnNpb25zOyAvLyBSZXF1aXJlZCBpbiBjcmVhdGVMaXN0RnJvbURhdGFcblxuICAgIHRoaXMuZ2V0RGltZW5zaW9uc0luZm8gPSBDYWxlbmRhci5nZXREaW1lbnNpb25zSW5mbztcbiAgICB0aGlzLl9tb2RlbCA9IGNhbGVuZGFyTW9kZWw7XG4gIH1cblxuICBDYWxlbmRhci5nZXREaW1lbnNpb25zSW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIG5hbWU6ICd0aW1lJyxcbiAgICAgIHR5cGU6ICd0aW1lJ1xuICAgIH0sICd2YWx1ZSddO1xuICB9O1xuXG4gIENhbGVuZGFyLnByb3RvdHlwZS5nZXRSYW5nZUluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JhbmdlSW5mbztcbiAgfTtcblxuICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0TW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsO1xuICB9O1xuXG4gIENhbGVuZGFyLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICB9O1xuXG4gIENhbGVuZGFyLnByb3RvdHlwZS5nZXRDZWxsV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N3O1xuICB9O1xuXG4gIENhbGVuZGFyLnByb3RvdHlwZS5nZXRDZWxsSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zaDtcbiAgfTtcblxuICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0T3JpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmllbnQ7XG4gIH07XG4gIC8qKlxuICAgKiBnZXRGaXJzdERheU9mV2Vla1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgICAgMCA6IHN0YXJ0IGF0IFN1bmRheVxuICAgKiAgICAgMSA6IHN0YXJ0IGF0IE1vbmRheVxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXIucHJvdG90eXBlLmdldEZpcnN0RGF5T2ZXZWVrID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdERheU9mV2VlaztcbiAgfTtcbiAgLyoqXG4gICAqIGdldCBkYXRlIGluZm9cbiAgICogfVxuICAgKi9cblxuXG4gIENhbGVuZGFyLnByb3RvdHlwZS5nZXREYXRlSW5mbyA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgZGF0ZSA9IG51bWJlclV0aWwucGFyc2VEYXRlKGRhdGUpO1xuICAgIHZhciB5ID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIHZhciBtID0gZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgICB2YXIgbVN0ciA9IG0gPCAxMCA/ICcwJyArIG0gOiAnJyArIG07XG4gICAgdmFyIGQgPSBkYXRlLmdldERhdGUoKTtcbiAgICB2YXIgZFN0ciA9IGQgPCAxMCA/ICcwJyArIGQgOiAnJyArIGQ7XG4gICAgdmFyIGRheSA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgZGF5ID0gTWF0aC5hYnMoKGRheSArIDcgLSB0aGlzLmdldEZpcnN0RGF5T2ZXZWVrKCkpICUgNyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHk6IHkgKyAnJyxcbiAgICAgIG06IG1TdHIsXG4gICAgICBkOiBkU3RyLFxuICAgICAgZGF5OiBkYXksXG4gICAgICB0aW1lOiBkYXRlLmdldFRpbWUoKSxcbiAgICAgIGZvcm1hdGVkRGF0ZTogeSArICctJyArIG1TdHIgKyAnLScgKyBkU3RyLFxuICAgICAgZGF0ZTogZGF0ZVxuICAgIH07XG4gIH07XG5cbiAgQ2FsZW5kYXIucHJvdG90eXBlLmdldE5leHRORGF5ID0gZnVuY3Rpb24gKGRhdGUsIG4pIHtcbiAgICBuID0gbiB8fCAwO1xuXG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldERhdGVJbmZvKGRhdGUpO1xuICAgIH1cblxuICAgIGRhdGUgPSBuZXcgRGF0ZSh0aGlzLmdldERhdGVJbmZvKGRhdGUpLnRpbWUpO1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIG4pO1xuICAgIHJldHVybiB0aGlzLmdldERhdGVJbmZvKGRhdGUpO1xuICB9O1xuXG4gIENhbGVuZGFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5fZmlyc3REYXlPZldlZWsgPSArdGhpcy5fbW9kZWwuZ2V0TW9kZWwoJ2RheUxhYmVsJykuZ2V0KCdmaXJzdERheScpO1xuICAgIHRoaXMuX29yaWVudCA9IHRoaXMuX21vZGVsLmdldCgnb3JpZW50Jyk7XG4gICAgdGhpcy5fbGluZVdpZHRoID0gdGhpcy5fbW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZSgpLmxpbmVXaWR0aCB8fCAwO1xuICAgIHRoaXMuX3JhbmdlSW5mbyA9IHRoaXMuX2dldFJhbmdlSW5mbyh0aGlzLl9pbml0UmFuZ2VPcHRpb24oKSk7XG4gICAgdmFyIHdlZWtzID0gdGhpcy5fcmFuZ2VJbmZvLndlZWtzIHx8IDE7XG4gICAgdmFyIHdoTmFtZXMgPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xuXG4gICAgdmFyIGNlbGxTaXplID0gdGhpcy5fbW9kZWwuZ2V0Q2VsbFNpemUoKS5zbGljZSgpO1xuXG4gICAgdmFyIGxheW91dFBhcmFtcyA9IHRoaXMuX21vZGVsLmdldEJveExheW91dFBhcmFtcygpO1xuXG4gICAgdmFyIGNlbGxOdW1iZXJzID0gdGhpcy5fb3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyBbd2Vla3MsIDddIDogWzcsIHdlZWtzXTtcbiAgICB6clV0aWwuZWFjaChbMCwgMV0sIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIGlmIChjZWxsU2l6ZVNwZWNpZmllZChjZWxsU2l6ZSwgaWR4KSkge1xuICAgICAgICBsYXlvdXRQYXJhbXNbd2hOYW1lc1tpZHhdXSA9IGNlbGxTaXplW2lkeF0gKiBjZWxsTnVtYmVyc1tpZHhdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciB3aEdsb2JhbCA9IHtcbiAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgfTtcbiAgICB2YXIgY2FsZW5kYXJSZWN0ID0gdGhpcy5fcmVjdCA9IGxheW91dC5nZXRMYXlvdXRSZWN0KGxheW91dFBhcmFtcywgd2hHbG9iYWwpO1xuICAgIHpyVXRpbC5lYWNoKFswLCAxXSwgZnVuY3Rpb24gKGlkeCkge1xuICAgICAgaWYgKCFjZWxsU2l6ZVNwZWNpZmllZChjZWxsU2l6ZSwgaWR4KSkge1xuICAgICAgICBjZWxsU2l6ZVtpZHhdID0gY2FsZW5kYXJSZWN0W3doTmFtZXNbaWR4XV0gLyBjZWxsTnVtYmVyc1tpZHhdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY2VsbFNpemVTcGVjaWZpZWQoY2VsbFNpemUsIGlkeCkge1xuICAgICAgcmV0dXJuIGNlbGxTaXplW2lkeF0gIT0gbnVsbCAmJiBjZWxsU2l6ZVtpZHhdICE9PSAnYXV0byc7XG4gICAgfSAvLyBIYXMgYmVlbiBjYWxjdWxhdGVkIG91dCBudW1iZXIuXG5cblxuICAgIHRoaXMuX3N3ID0gY2VsbFNpemVbMF07XG4gICAgdGhpcy5fc2ggPSBjZWxsU2l6ZVsxXTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnQgYSB0aW1lIGRhdGEodGltZSwgdmFsdWUpIGl0ZW0gdG8gKHgsIHkpIHBvaW50LlxuICAgKi9cbiAgLy8gVE9ETyBDbGFtcCBvZiBjYWxlbmRhciBpcyBub3Qgc2FtZSB3aXRoIGNhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbXMuXG4gIC8vIEl0IHdpbGwgcmV0dXJuIE5hTiBpZiBkYXRhIGV4Y2VlZHMuXG5cblxuICBDYWxlbmRhci5wcm90b3R5cGUuZGF0YVRvUG9pbnQgPSBmdW5jdGlvbiAoZGF0YSwgY2xhbXApIHtcbiAgICB6clV0aWwuaXNBcnJheShkYXRhKSAmJiAoZGF0YSA9IGRhdGFbMF0pO1xuICAgIGNsYW1wID09IG51bGwgJiYgKGNsYW1wID0gdHJ1ZSk7XG4gICAgdmFyIGRheUluZm8gPSB0aGlzLmdldERhdGVJbmZvKGRhdGEpO1xuICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlSW5mbztcbiAgICB2YXIgZGF0ZSA9IGRheUluZm8uZm9ybWF0ZWREYXRlOyAvLyBpZiBub3QgaW4gcmFuZ2UgcmV0dXJuIFtOYU4sIE5hTl1cblxuICAgIGlmIChjbGFtcCAmJiAhKGRheUluZm8udGltZSA+PSByYW5nZS5zdGFydC50aW1lICYmIGRheUluZm8udGltZSA8IHJhbmdlLmVuZC50aW1lICsgUFJPWElNQVRFX09ORV9EQVkpKSB7XG4gICAgICByZXR1cm4gW05hTiwgTmFOXTtcbiAgICB9XG5cbiAgICB2YXIgd2VlayA9IGRheUluZm8uZGF5O1xuXG4gICAgdmFyIG50aFdlZWsgPSB0aGlzLl9nZXRSYW5nZUluZm8oW3JhbmdlLnN0YXJ0LnRpbWUsIGRhdGVdKS5udGhXZWVrO1xuXG4gICAgaWYgKHRoaXMuX29yaWVudCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgcmV0dXJuIFt0aGlzLl9yZWN0LnggKyB3ZWVrICogdGhpcy5fc3cgKyB0aGlzLl9zdyAvIDIsIHRoaXMuX3JlY3QueSArIG50aFdlZWsgKiB0aGlzLl9zaCArIHRoaXMuX3NoIC8gMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt0aGlzLl9yZWN0LnggKyBudGhXZWVrICogdGhpcy5fc3cgKyB0aGlzLl9zdyAvIDIsIHRoaXMuX3JlY3QueSArIHdlZWsgKiB0aGlzLl9zaCArIHRoaXMuX3NoIC8gMl07XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgKHgsIHkpIHBvaW50IHRvIHRpbWUgZGF0YVxuICAgKi9cblxuXG4gIENhbGVuZGFyLnByb3RvdHlwZS5wb2ludFRvRGF0YSA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciBkYXRlID0gdGhpcy5wb2ludFRvRGF0ZShwb2ludCk7XG4gICAgcmV0dXJuIGRhdGUgJiYgZGF0ZS50aW1lO1xuICB9O1xuICAvKipcbiAgICogQ29udmVydCBhIHRpbWUgZGF0ZSBpdGVtIHRvICh4LCB5KSBmb3VyIHBvaW50LlxuICAgKi9cblxuXG4gIENhbGVuZGFyLnByb3RvdHlwZS5kYXRhVG9SZWN0ID0gZnVuY3Rpb24gKGRhdGEsIGNsYW1wKSB7XG4gICAgdmFyIHBvaW50ID0gdGhpcy5kYXRhVG9Qb2ludChkYXRhLCBjbGFtcCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnRTaGFwZToge1xuICAgICAgICB4OiBwb2ludFswXSAtICh0aGlzLl9zdyAtIHRoaXMuX2xpbmVXaWR0aCkgLyAyLFxuICAgICAgICB5OiBwb2ludFsxXSAtICh0aGlzLl9zaCAtIHRoaXMuX2xpbmVXaWR0aCkgLyAyLFxuICAgICAgICB3aWR0aDogdGhpcy5fc3cgLSB0aGlzLl9saW5lV2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5fc2ggLSB0aGlzLl9saW5lV2lkdGhcbiAgICAgIH0sXG4gICAgICBjZW50ZXI6IHBvaW50LFxuICAgICAgdGw6IFtwb2ludFswXSAtIHRoaXMuX3N3IC8gMiwgcG9pbnRbMV0gLSB0aGlzLl9zaCAvIDJdLFxuICAgICAgdHI6IFtwb2ludFswXSArIHRoaXMuX3N3IC8gMiwgcG9pbnRbMV0gLSB0aGlzLl9zaCAvIDJdLFxuICAgICAgYnI6IFtwb2ludFswXSArIHRoaXMuX3N3IC8gMiwgcG9pbnRbMV0gKyB0aGlzLl9zaCAvIDJdLFxuICAgICAgYmw6IFtwb2ludFswXSAtIHRoaXMuX3N3IC8gMiwgcG9pbnRbMV0gKyB0aGlzLl9zaCAvIDJdXG4gICAgfTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnQgYSAoeCwgeSkgcG9pbnQgdG8gdGltZSBkYXRlXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5fSBwb2ludCBwb2ludFxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIGRhdGVcbiAgICovXG5cblxuICBDYWxlbmRhci5wcm90b3R5cGUucG9pbnRUb0RhdGUgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgbnRoWCA9IE1hdGguZmxvb3IoKHBvaW50WzBdIC0gdGhpcy5fcmVjdC54KSAvIHRoaXMuX3N3KSArIDE7XG4gICAgdmFyIG50aFkgPSBNYXRoLmZsb29yKChwb2ludFsxXSAtIHRoaXMuX3JlY3QueSkgLyB0aGlzLl9zaCkgKyAxO1xuICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlSW5mby5yYW5nZTtcblxuICAgIGlmICh0aGlzLl9vcmllbnQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXREYXRlQnlXZWVrc0FuZERheShudGhZLCBudGhYIC0gMSwgcmFuZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9nZXREYXRlQnlXZWVrc0FuZERheShudGhYLCBudGhZIC0gMSwgcmFuZ2UpO1xuICB9O1xuXG4gIENhbGVuZGFyLnByb3RvdHlwZS5jb252ZXJ0VG9QaXhlbCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIsIHZhbHVlKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gZ2V0Q29vcmRTeXMoZmluZGVyKTtcbiAgICByZXR1cm4gY29vcmRTeXMgPT09IHRoaXMgPyBjb29yZFN5cy5kYXRhVG9Qb2ludCh2YWx1ZSkgOiBudWxsO1xuICB9O1xuXG4gIENhbGVuZGFyLnByb3RvdHlwZS5jb252ZXJ0RnJvbVBpeGVsID0gZnVuY3Rpb24gKGVjTW9kZWwsIGZpbmRlciwgcGl4ZWwpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBnZXRDb29yZFN5cyhmaW5kZXIpO1xuICAgIHJldHVybiBjb29yZFN5cyA9PT0gdGhpcyA/IGNvb3JkU3lzLnBvaW50VG9EYXRhKHBpeGVsKSA6IG51bGw7XG4gIH07XG5cbiAgQ2FsZW5kYXIucHJvdG90eXBlLmNvbnRhaW5Qb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIGNvbnNvbGUud2FybignTm90IGltcGxlbWVudGVkLicpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgLyoqXG4gICAqIGluaXRSYW5nZVxuICAgKiBOb3JtYWxpemUgdG8gYW4gW3N0YXJ0LCBlbmRdIGFycmF5XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXIucHJvdG90eXBlLl9pbml0UmFuZ2VPcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5fbW9kZWwuZ2V0KCdyYW5nZScpO1xuXG4gICAgdmFyIG5vcm1hbGl6ZWRSYW5nZTsgLy8gQ29udmVydCBbMTk5MF0gdG8gMTk5MFxuXG4gICAgaWYgKHpyVXRpbC5pc0FycmF5KHJhbmdlKSAmJiByYW5nZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJhbmdlID0gcmFuZ2VbMF07XG4gICAgfVxuXG4gICAgaWYgKCF6clV0aWwuaXNBcnJheShyYW5nZSkpIHtcbiAgICAgIHZhciByYW5nZVN0ciA9IHJhbmdlLnRvU3RyaW5nKCk7IC8vIE9uZSB5ZWFyLlxuXG4gICAgICBpZiAoL15cXGR7NH0kLy50ZXN0KHJhbmdlU3RyKSkge1xuICAgICAgICBub3JtYWxpemVkUmFuZ2UgPSBbcmFuZ2VTdHIgKyAnLTAxLTAxJywgcmFuZ2VTdHIgKyAnLTEyLTMxJ107XG4gICAgICB9IC8vIE9uZSBtb250aFxuXG5cbiAgICAgIGlmICgvXlxcZHs0fVtcXC98LV1cXGR7MSwyfSQvLnRlc3QocmFuZ2VTdHIpKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0RGF0ZUluZm8ocmFuZ2VTdHIpO1xuICAgICAgICB2YXIgZmlyc3REYXkgPSBzdGFydC5kYXRlO1xuICAgICAgICBmaXJzdERheS5zZXRNb250aChmaXJzdERheS5nZXRNb250aCgpICsgMSk7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmdldE5leHRORGF5KGZpcnN0RGF5LCAtMSk7XG4gICAgICAgIG5vcm1hbGl6ZWRSYW5nZSA9IFtzdGFydC5mb3JtYXRlZERhdGUsIGVuZC5mb3JtYXRlZERhdGVdO1xuICAgICAgfSAvLyBPbmUgZGF5XG5cblxuICAgICAgaWYgKC9eXFxkezR9W1xcL3wtXVxcZHsxLDJ9W1xcL3wtXVxcZHsxLDJ9JC8udGVzdChyYW5nZVN0cikpIHtcbiAgICAgICAgbm9ybWFsaXplZFJhbmdlID0gW3JhbmdlU3RyLCByYW5nZVN0cl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZWRSYW5nZSA9IHJhbmdlO1xuICAgIH1cblxuICAgIGlmICghbm9ybWFsaXplZFJhbmdlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB6clV0aWwubG9nRXJyb3IoJ0ludmFsaWQgZGF0ZSByYW5nZS4nKTtcbiAgICAgIH0gLy8gTm90IGhhbmRsaW5nIGl0LlxuXG5cbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG5cbiAgICB2YXIgdG1wID0gdGhpcy5fZ2V0UmFuZ2VJbmZvKG5vcm1hbGl6ZWRSYW5nZSk7XG5cbiAgICBpZiAodG1wLnN0YXJ0LnRpbWUgPiB0bXAuZW5kLnRpbWUpIHtcbiAgICAgIG5vcm1hbGl6ZWRSYW5nZS5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRSYW5nZTtcbiAgfTtcbiAgLyoqXG4gICAqIHJhbmdlIGluZm9cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7QXJyYXl9IHJhbmdlIHJhbmdlIFsnMjAxNy0wMS0wMScsICcyMDE3LTA3LTA4J11cbiAgICogIElmIHJhbmdlWzBdID4gcmFuZ2VbMV0sIHRoZXkgd2lsbCBub3QgYmUgcmV2ZXJzZWQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgb2JqXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXIucHJvdG90eXBlLl9nZXRSYW5nZUluZm8gPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICB2YXIgcGFyc2VkUmFuZ2UgPSBbdGhpcy5nZXREYXRlSW5mbyhyYW5nZVswXSksIHRoaXMuZ2V0RGF0ZUluZm8ocmFuZ2VbMV0pXTtcbiAgICB2YXIgcmV2ZXJzZWQ7XG5cbiAgICBpZiAocGFyc2VkUmFuZ2VbMF0udGltZSA+IHBhcnNlZFJhbmdlWzFdLnRpbWUpIHtcbiAgICAgIHJldmVyc2VkID0gdHJ1ZTtcbiAgICAgIHBhcnNlZFJhbmdlLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB2YXIgYWxsRGF5ID0gTWF0aC5mbG9vcihwYXJzZWRSYW5nZVsxXS50aW1lIC8gUFJPWElNQVRFX09ORV9EQVkpIC0gTWF0aC5mbG9vcihwYXJzZWRSYW5nZVswXS50aW1lIC8gUFJPWElNQVRFX09ORV9EQVkpICsgMTsgLy8gQ29uc2lkZXIgY2FzZTEgKCMxMTY3NyAjMTA0MzApOlxuICAgIC8vIFNldCB0aGUgc3lzdGVtIHRpbWV6b25lIGFzIFwiVUtcIiwgc2V0IHRoZSByYW5nZSB0byBgWycyMDE2LTA3LTAxJywgJzIwMTYtMTItMzEnXWBcbiAgICAvLyBDb25zaWRlciBjYXNlMjpcbiAgICAvLyBGaXJzdGx5IHNldCBzeXN0ZW0gdGltZXpvbmUgYXMgXCJUaW1lIFpvbmU6IEFtZXJpY2EvVG9yb250b1wiLFxuICAgIC8vIGBgYFxuICAgIC8vIGxldCBmaXJzdCA9IG5ldyBEYXRlKDE0Nzg0MTIwMDAwMDAgLSAzNjAwICogMTAwMCAqIDIuNSk7XG4gICAgLy8gbGV0IHNlY29uZCA9IG5ldyBEYXRlKDE0Nzg0MTIwMDAwMDApO1xuICAgIC8vIGxldCBhbGxEYXlzID0gTWF0aC5mbG9vcihzZWNvbmQgLyBPTkVfREFZKSAtIE1hdGguZmxvb3IoZmlyc3QgLyBPTkVfREFZKSArIDE7XG4gICAgLy8gYGBgXG4gICAgLy8gd2lsbCBnZXQgd3JvbmcgcmVzdWx0IGJlY2F1c2Ugb2YgRFNULiBTbyB3ZSBzaG91bGQgZml4IGl0LlxuXG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShwYXJzZWRSYW5nZVswXS50aW1lKTtcbiAgICB2YXIgc3RhcnREYXRlTnVtID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgdmFyIGVuZERhdGVOdW0gPSBwYXJzZWRSYW5nZVsxXS5kYXRlLmdldERhdGUoKTtcbiAgICBkYXRlLnNldERhdGUoc3RhcnREYXRlTnVtICsgYWxsRGF5IC0gMSk7IC8vIFRoZSBiaWFzIGNhbiBub3Qgb3ZlciBhIG1vbnRoLCBzbyBqdXN0IGNvbXBhcmUgZGF0ZS5cblxuICAgIHZhciBkYXRlTnVtID0gZGF0ZS5nZXREYXRlKCk7XG5cbiAgICBpZiAoZGF0ZU51bSAhPT0gZW5kRGF0ZU51bSkge1xuICAgICAgdmFyIHNpZ24gPSBkYXRlLmdldFRpbWUoKSAtIHBhcnNlZFJhbmdlWzFdLnRpbWUgPiAwID8gMSA6IC0xO1xuXG4gICAgICB3aGlsZSAoKGRhdGVOdW0gPSBkYXRlLmdldERhdGUoKSkgIT09IGVuZERhdGVOdW0gJiYgKGRhdGUuZ2V0VGltZSgpIC0gcGFyc2VkUmFuZ2VbMV0udGltZSkgKiBzaWduID4gMCkge1xuICAgICAgICBhbGxEYXkgLT0gc2lnbjtcbiAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGVOdW0gLSBzaWduKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgd2Vla3MgPSBNYXRoLmZsb29yKChhbGxEYXkgKyBwYXJzZWRSYW5nZVswXS5kYXkgKyA2KSAvIDcpO1xuICAgIHZhciBudGhXZWVrID0gcmV2ZXJzZWQgPyAtd2Vla3MgKyAxIDogd2Vla3MgLSAxO1xuICAgIHJldmVyc2VkICYmIHBhcnNlZFJhbmdlLnJldmVyc2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmFuZ2U6IFtwYXJzZWRSYW5nZVswXS5mb3JtYXRlZERhdGUsIHBhcnNlZFJhbmdlWzFdLmZvcm1hdGVkRGF0ZV0sXG4gICAgICBzdGFydDogcGFyc2VkUmFuZ2VbMF0sXG4gICAgICBlbmQ6IHBhcnNlZFJhbmdlWzFdLFxuICAgICAgYWxsRGF5OiBhbGxEYXksXG4gICAgICB3ZWVrczogd2Vla3MsXG4gICAgICAvLyBGcm9tIDAuXG4gICAgICBudGhXZWVrOiBudGhXZWVrLFxuICAgICAgZndlZWs6IHBhcnNlZFJhbmdlWzBdLmRheSxcbiAgICAgIGx3ZWVrOiBwYXJzZWRSYW5nZVsxXS5kYXlcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogZ2V0IGRhdGUgYnkgbnRoV2Vla3MgYW5kIHdlZWsgZGF5IGluIHJhbmdlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge251bWJlcn0gbnRoV2VlayB0aGUgd2Vla1xuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGRheSAgIHRoZSB3ZWVrIGRheVxuICAgKiBAcGFyYW0gIHtBcnJheX0gcmFuZ2UgW2QxLCBkMl1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuXG4gIENhbGVuZGFyLnByb3RvdHlwZS5fZ2V0RGF0ZUJ5V2Vla3NBbmREYXkgPSBmdW5jdGlvbiAobnRoV2VlaywgZGF5LCByYW5nZSkge1xuICAgIHZhciByYW5nZUluZm8gPSB0aGlzLl9nZXRSYW5nZUluZm8ocmFuZ2UpO1xuXG4gICAgaWYgKG50aFdlZWsgPiByYW5nZUluZm8ud2Vla3MgfHwgbnRoV2VlayA9PT0gMCAmJiBkYXkgPCByYW5nZUluZm8uZndlZWsgfHwgbnRoV2VlayA9PT0gcmFuZ2VJbmZvLndlZWtzICYmIGRheSA+IHJhbmdlSW5mby5sd2Vlaykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG50aERheSA9IChudGhXZWVrIC0gMSkgKiA3IC0gcmFuZ2VJbmZvLmZ3ZWVrICsgZGF5O1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUocmFuZ2VJbmZvLnN0YXJ0LnRpbWUpO1xuICAgIGRhdGUuc2V0RGF0ZSgrcmFuZ2VJbmZvLnN0YXJ0LmQgKyBudGhEYXkpO1xuICAgIHJldHVybiB0aGlzLmdldERhdGVJbmZvKGRhdGUpO1xuICB9O1xuXG4gIENhbGVuZGFyLmNyZWF0ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgY2FsZW5kYXJMaXN0ID0gW107XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdjYWxlbmRhcicsIGZ1bmN0aW9uIChjYWxlbmRhck1vZGVsKSB7XG4gICAgICB2YXIgY2FsZW5kYXIgPSBuZXcgQ2FsZW5kYXIoY2FsZW5kYXJNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICAgIGNhbGVuZGFyTGlzdC5wdXNoKGNhbGVuZGFyKTtcbiAgICAgIGNhbGVuZGFyTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9IGNhbGVuZGFyO1xuICAgIH0pO1xuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoY2FsZW5kYXJTZXJpZXMpIHtcbiAgICAgIGlmIChjYWxlbmRhclNlcmllcy5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKSA9PT0gJ2NhbGVuZGFyJykge1xuICAgICAgICAvLyBJbmplY3QgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgICAgY2FsZW5kYXJTZXJpZXMuY29vcmRpbmF0ZVN5c3RlbSA9IGNhbGVuZGFyTGlzdFtjYWxlbmRhclNlcmllcy5nZXQoJ2NhbGVuZGFySW5kZXgnKSB8fCAwXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2FsZW5kYXJMaXN0O1xuICB9O1xuXG4gIENhbGVuZGFyLmRpbWVuc2lvbnMgPSBbJ3RpbWUnLCAndmFsdWUnXTtcbiAgcmV0dXJuIENhbGVuZGFyO1xufSgpO1xuXG5mdW5jdGlvbiBnZXRDb29yZFN5cyhmaW5kZXIpIHtcbiAgdmFyIGNhbGVuZGFyTW9kZWwgPSBmaW5kZXIuY2FsZW5kYXJNb2RlbDtcbiAgdmFyIHNlcmllc01vZGVsID0gZmluZGVyLnNlcmllc01vZGVsO1xuICB2YXIgY29vcmRTeXMgPSBjYWxlbmRhck1vZGVsID8gY2FsZW5kYXJNb2RlbC5jb29yZGluYXRlU3lzdGVtIDogc2VyaWVzTW9kZWwgPyBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtIDogbnVsbDtcbiAgcmV0dXJuIGNvb3JkU3lzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBDYWxlbmRhcjsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBDb21wb25lbnRNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Db21wb25lbnQnO1xuaW1wb3J0IHsgZ2V0TGF5b3V0UGFyYW1zLCBzaXplQ2FsY3VsYWJsZSwgbWVyZ2VMYXlvdXRQYXJhbSB9IGZyb20gJy4uLy4uL3V0aWwvbGF5b3V0JztcblxudmFyIENhbGVuZGFyTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ2FsZW5kYXJNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBDYWxlbmRhck1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IENhbGVuZGFyTW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIENhbGVuZGFyTW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCkge1xuICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gZ2V0TGF5b3V0UGFyYW1zKG9wdGlvbik7XG5cbiAgICBfc3VwZXIucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIG1lcmdlQW5kTm9ybWFsaXplTGF5b3V0UGFyYW1zKG9wdGlvbiwgaW5wdXRQb3NpdGlvblBhcmFtcyk7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBDYWxlbmRhck1vZGVsLnByb3RvdHlwZS5tZXJnZU9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLm1lcmdlT3B0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBtZXJnZUFuZE5vcm1hbGl6ZUxheW91dFBhcmFtcyh0aGlzLm9wdGlvbiwgb3B0aW9uKTtcbiAgfTtcblxuICBDYWxlbmRhck1vZGVsLnByb3RvdHlwZS5nZXRDZWxsU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBIYXMgYmVlbiBub3JtYWxpemVkXG4gICAgcmV0dXJuIHRoaXMub3B0aW9uLmNlbGxTaXplO1xuICB9O1xuXG4gIENhbGVuZGFyTW9kZWwudHlwZSA9ICdjYWxlbmRhcic7XG4gIENhbGVuZGFyTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogMixcbiAgICBsZWZ0OiA4MCxcbiAgICB0b3A6IDYwLFxuICAgIGNlbGxTaXplOiAyMCxcbiAgICAvLyBob3Jpem9udGFsIHZlcnRpY2FsXG4gICAgb3JpZW50OiAnaG9yaXpvbnRhbCcsXG4gICAgLy8gbW9udGggc2VwYXJhdGUgbGluZSBzdHlsZVxuICAgIHNwbGl0TGluZToge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBjb2xvcjogJyMwMDAnLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gcmVjdCBzdHlsZSAgdGVtcG9yYXJpbHkgdW51c2VkIGVtcGhhc2lzXG4gICAgaXRlbVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICBib3JkZXJDb2xvcjogJyNjY2MnXG4gICAgfSxcbiAgICAvLyB3ZWVrIHRleHQgc3R5bGVcbiAgICBkYXlMYWJlbDoge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIGZpcnN0RGF5OiAwLFxuICAgICAgLy8gc3RhcnQgZW5kXG4gICAgICBwb3NpdGlvbjogJ3N0YXJ0JyxcbiAgICAgIG1hcmdpbjogJzUwJScsXG4gICAgICBuYW1lTWFwOiAnZW4nLFxuICAgICAgY29sb3I6ICcjMDAwJ1xuICAgIH0sXG4gICAgLy8gbW9udGggdGV4dCBzdHlsZVxuICAgIG1vbnRoTGFiZWw6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICAvLyBzdGFydCBlbmRcbiAgICAgIHBvc2l0aW9uOiAnc3RhcnQnLFxuICAgICAgbWFyZ2luOiA1LFxuICAgICAgLy8gY2VudGVyIG9yIGxlZnRcbiAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgIC8vIGNuIGVuIFtdXG4gICAgICBuYW1lTWFwOiAnZW4nLFxuICAgICAgZm9ybWF0dGVyOiBudWxsLFxuICAgICAgY29sb3I6ICcjMDAwJ1xuICAgIH0sXG4gICAgLy8geWVhciB0ZXh0IHN0eWxlXG4gICAgeWVhckxhYmVsOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgLy8gdG9wIGJvdHRvbSBsZWZ0IHJpZ2h0XG4gICAgICBwb3NpdGlvbjogbnVsbCxcbiAgICAgIG1hcmdpbjogMzAsXG4gICAgICBmb3JtYXR0ZXI6IG51bGwsXG4gICAgICBjb2xvcjogJyNjY2MnLFxuICAgICAgZm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuICAgICAgZm9udFdlaWdodDogJ2JvbGRlcicsXG4gICAgICBmb250U2l6ZTogMjBcbiAgICB9XG4gIH07XG4gIHJldHVybiBDYWxlbmRhck1vZGVsO1xufShDb21wb25lbnRNb2RlbCk7XG5cbmZ1bmN0aW9uIG1lcmdlQW5kTm9ybWFsaXplTGF5b3V0UGFyYW1zKHRhcmdldCwgcmF3KSB7XG4gIC8vIE5vcm1hbGl6ZSBjZWxsU2l6ZVxuICB2YXIgY2VsbFNpemUgPSB0YXJnZXQuY2VsbFNpemU7XG4gIHZhciBjZWxsU2l6ZUFycjtcblxuICBpZiAoIXpyVXRpbC5pc0FycmF5KGNlbGxTaXplKSkge1xuICAgIGNlbGxTaXplQXJyID0gdGFyZ2V0LmNlbGxTaXplID0gW2NlbGxTaXplLCBjZWxsU2l6ZV07XG4gIH0gZWxzZSB7XG4gICAgY2VsbFNpemVBcnIgPSBjZWxsU2l6ZTtcbiAgfVxuXG4gIGlmIChjZWxsU2l6ZUFyci5sZW5ndGggPT09IDEpIHtcbiAgICBjZWxsU2l6ZUFyclsxXSA9IGNlbGxTaXplQXJyWzBdO1xuICB9XG5cbiAgdmFyIGlnbm9yZVNpemUgPSB6clV0aWwubWFwKFswLCAxXSwgZnVuY3Rpb24gKGh2SWR4KSB7XG4gICAgLy8gSWYgdXNlciBoYXZlIHNldCBgd2lkdGhgIG9yIGJvdGggYGxlZnRgIGFuZCBgcmlnaHRgLCBjZWxsU2l6ZUFyclxuICAgIC8vIHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgdG8gJ2F1dG8nLCBvdGhlcndpc2UgdGhlIGRlZmF1bHRcbiAgICAvLyBzZXR0aW5nIG9mIGNlbGxTaXplQXJyIHdpbGwgbWFrZSBgd2lkdGhgIHNldHRpbmcgbm90IHdvcmsuXG4gICAgaWYgKHNpemVDYWxjdWxhYmxlKHJhdywgaHZJZHgpKSB7XG4gICAgICBjZWxsU2l6ZUFycltodklkeF0gPSAnYXV0byc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbGxTaXplQXJyW2h2SWR4XSAhPSBudWxsICYmIGNlbGxTaXplQXJyW2h2SWR4XSAhPT0gJ2F1dG8nO1xuICB9KTtcbiAgbWVyZ2VMYXlvdXRQYXJhbSh0YXJnZXQsIHJhdywge1xuICAgIHR5cGU6ICdib3gnLFxuICAgIGlnbm9yZVNpemU6IGlnbm9yZVNpemVcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbGVuZGFyTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgdGV4dENvbnRhaW4gZnJvbSAnenJlbmRlci9saWIvY29udGFpbi90ZXh0JztcbmltcG9ydCBBeGlzIGZyb20gJy4uL0F4aXMnO1xuaW1wb3J0IHsgbWFrZUlubmVyIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcblxudmFyIEFuZ2xlQXhpcyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhBbmdsZUF4aXMsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gQW5nbGVBeGlzKHNjYWxlLCBhbmdsZUV4dGVudCkge1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAnYW5nbGUnLCBzY2FsZSwgYW5nbGVFeHRlbnQgfHwgWzAsIDM2MF0pIHx8IHRoaXM7XG4gIH1cblxuICBBbmdsZUF4aXMucHJvdG90eXBlLnBvaW50VG9EYXRhID0gZnVuY3Rpb24gKHBvaW50LCBjbGFtcCkge1xuICAgIHJldHVybiB0aGlzLnBvbGFyLnBvaW50VG9EYXRhKHBvaW50LCBjbGFtcClbdGhpcy5kaW0gPT09ICdyYWRpdXMnID8gMCA6IDFdO1xuICB9O1xuICAvKipcbiAgICogT25seSBiZSBjYWxsZWQgaW4gY2F0ZWdvcnkgYXhpcy5cbiAgICogQW5nbGUgYXhpcyB1c2VzIHRleHQgaGVpZ2h0IHRvIGRlY2lkZSBpbnRlcnZhbFxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHJldHVybiB7bnVtYmVyfSBBdXRvIGludGVydmFsIGZvciBjYXRlb2dyeSBheGlzIHRpY2sgYW5kIGxhYmVsXG4gICAqL1xuXG5cbiAgQW5nbGVBeGlzLnByb3RvdHlwZS5jYWxjdWxhdGVDYXRlZ29yeUludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBheGlzID0gdGhpcztcbiAgICB2YXIgbGFiZWxNb2RlbCA9IGF4aXMuZ2V0TGFiZWxNb2RlbCgpO1xuICAgIHZhciBvcmRpbmFsU2NhbGUgPSBheGlzLnNjYWxlO1xuICAgIHZhciBvcmRpbmFsRXh0ZW50ID0gb3JkaW5hbFNjYWxlLmdldEV4dGVudCgpOyAvLyBQcm92aWRpbmcgdGhpcyBtZXRob2QgaXMgZm9yIG9wdGltaXphdGlvbjpcbiAgICAvLyBhdm9pZCBnZW5lcmF0aW5nIGEgbG9uZyBhcnJheSBieSBgZ2V0VGlja3NgXG4gICAgLy8gaW4gbGFyZ2UgY2F0ZWdvcnkgZGF0YSBjYXNlLlxuXG4gICAgdmFyIHRpY2tDb3VudCA9IG9yZGluYWxTY2FsZS5jb3VudCgpO1xuXG4gICAgaWYgKG9yZGluYWxFeHRlbnRbMV0gLSBvcmRpbmFsRXh0ZW50WzBdIDwgMSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIHRpY2tWYWx1ZSA9IG9yZGluYWxFeHRlbnRbMF07XG4gICAgdmFyIHVuaXRTcGFuID0gYXhpcy5kYXRhVG9Db29yZCh0aWNrVmFsdWUgKyAxKSAtIGF4aXMuZGF0YVRvQ29vcmQodGlja1ZhbHVlKTtcbiAgICB2YXIgdW5pdEggPSBNYXRoLmFicyh1bml0U3Bhbik7IC8vIE5vdCBwcmVjaXNlLCBqdXN0IHVzZSBoZWlnaHQgYXMgdGV4dCB3aWR0aFxuICAgIC8vIGFuZCBlYWNoIGRpc3RhbmNlIGZyb20gYXhpcyBsaW5lIHlldC5cblxuICAgIHZhciByZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRpY2tWYWx1ZSA9PSBudWxsID8gJycgOiB0aWNrVmFsdWUgKyAnJywgbGFiZWxNb2RlbC5nZXRGb250KCksICdjZW50ZXInLCAndG9wJyk7XG4gICAgdmFyIG1heEggPSBNYXRoLm1heChyZWN0LmhlaWdodCwgNyk7XG4gICAgdmFyIGRoID0gbWF4SCAvIHVuaXRIOyAvLyAwLzAgaXMgTmFOLCAxLzAgaXMgSW5maW5pdHkuXG5cbiAgICBpc05hTihkaCkgJiYgKGRoID0gSW5maW5pdHkpO1xuICAgIHZhciBpbnRlcnZhbCA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IoZGgpKTtcbiAgICB2YXIgY2FjaGUgPSBpbm5lcihheGlzLm1vZGVsKTtcbiAgICB2YXIgbGFzdEF1dG9JbnRlcnZhbCA9IGNhY2hlLmxhc3RBdXRvSW50ZXJ2YWw7XG4gICAgdmFyIGxhc3RUaWNrQ291bnQgPSBjYWNoZS5sYXN0VGlja0NvdW50OyAvLyBVc2UgY2FjaGUgdG8ga2VlcCBpbnRlcnZhbCBzdGFibGUgd2hpbGUgbW92aW5nIHpvb20gd2luZG93LFxuICAgIC8vIG90aGVyd2lzZSB0aGUgY2FsY3VsYXRlZCBpbnRlcnZhbCBtaWdodCBqaXR0ZXIgd2hlbiB0aGUgem9vbVxuICAgIC8vIHdpbmRvdyBzaXplIGlzIGNsb3NlIHRvIHRoZSBpbnRlcnZhbC1jaGFuZ2luZyBzaXplLlxuXG4gICAgaWYgKGxhc3RBdXRvSW50ZXJ2YWwgIT0gbnVsbCAmJiBsYXN0VGlja0NvdW50ICE9IG51bGwgJiYgTWF0aC5hYnMobGFzdEF1dG9JbnRlcnZhbCAtIGludGVydmFsKSA8PSAxICYmIE1hdGguYWJzKGxhc3RUaWNrQ291bnQgLSB0aWNrQ291bnQpIDw9IDEgLy8gQWx3YXlzIGNob29zZSB0aGUgYmlnZ2VyIG9uZSwgb3RoZXJ3aXNlIHRoZSBjcml0aWNhbFxuICAgIC8vIHBvaW50IGlzIG5vdCB0aGUgc2FtZSB3aGVuIHpvb21pbmcgaW4gb3Igem9vbWluZyBvdXQuXG4gICAgJiYgbGFzdEF1dG9JbnRlcnZhbCA+IGludGVydmFsKSB7XG4gICAgICBpbnRlcnZhbCA9IGxhc3RBdXRvSW50ZXJ2YWw7XG4gICAgfSAvLyBPbmx5IHVwZGF0ZSBjYWNoZSBpZiBjYWNoZSBub3QgdXNlZCwgb3RoZXJ3aXNlIHRoZVxuICAgIC8vIGNoYW5naW5nIG9mIGludGVydmFsIGlzIHRvbyBpbnNlbnNpdGl2ZS5cbiAgICBlbHNlIHtcbiAgICAgICAgY2FjaGUubGFzdFRpY2tDb3VudCA9IHRpY2tDb3VudDtcbiAgICAgICAgY2FjaGUubGFzdEF1dG9JbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgfVxuXG4gICAgcmV0dXJuIGludGVydmFsO1xuICB9O1xuXG4gIHJldHVybiBBbmdsZUF4aXM7XG59KEF4aXMpO1xuXG5BbmdsZUF4aXMucHJvdG90eXBlLmRhdGFUb0FuZ2xlID0gQXhpcy5wcm90b3R5cGUuZGF0YVRvQ29vcmQ7XG5BbmdsZUF4aXMucHJvdG90eXBlLmFuZ2xlVG9EYXRhID0gQXhpcy5wcm90b3R5cGUuY29vcmRUb0RhdGE7XG5leHBvcnQgZGVmYXVsdCBBbmdsZUF4aXM7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50JztcbmltcG9ydCB7IEF4aXNNb2RlbENvbW1vbk1peGluIH0gZnJvbSAnLi4vYXhpc01vZGVsQ29tbW9uTWl4aW4nO1xuaW1wb3J0IHsgU0lOR0xFX1JFRkVSUklORyB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwnO1xuXG52YXIgUG9sYXJBeGlzTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUG9sYXJBeGlzTW9kZWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gUG9sYXJBeGlzTW9kZWwoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgUG9sYXJBeGlzTW9kZWwucHJvdG90eXBlLmdldENvb3JkU3lzTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVmZXJyaW5nQ29tcG9uZW50cygncG9sYXInLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG4gIH07XG5cbiAgUG9sYXJBeGlzTW9kZWwudHlwZSA9ICdwb2xhckF4aXMnO1xuICByZXR1cm4gUG9sYXJBeGlzTW9kZWw7XG59KENvbXBvbmVudE1vZGVsKTtcblxuenJVdGlsLm1peGluKFBvbGFyQXhpc01vZGVsLCBBeGlzTW9kZWxDb21tb25NaXhpbik7XG5leHBvcnQgeyBQb2xhckF4aXNNb2RlbCB9O1xuXG52YXIgQW5nbGVBeGlzTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQW5nbGVBeGlzTW9kZWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gQW5nbGVBeGlzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gQW5nbGVBeGlzTW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBBbmdsZUF4aXNNb2RlbC50eXBlID0gJ2FuZ2xlQXhpcyc7XG4gIHJldHVybiBBbmdsZUF4aXNNb2RlbDtcbn0oUG9sYXJBeGlzTW9kZWwpO1xuXG5leHBvcnQgeyBBbmdsZUF4aXNNb2RlbCB9O1xuXG52YXIgUmFkaXVzQXhpc01vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFJhZGl1c0F4aXNNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBSYWRpdXNBeGlzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gUmFkaXVzQXhpc01vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUmFkaXVzQXhpc01vZGVsLnR5cGUgPSAncmFkaXVzQXhpcyc7XG4gIHJldHVybiBSYWRpdXNBeGlzTW9kZWw7XG59KFBvbGFyQXhpc01vZGVsKTtcblxuZXhwb3J0IHsgUmFkaXVzQXhpc01vZGVsIH07IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCBSYWRpdXNBeGlzIGZyb20gJy4vUmFkaXVzQXhpcyc7XG5pbXBvcnQgQW5nbGVBeGlzIGZyb20gJy4vQW5nbGVBeGlzJztcblxudmFyIFBvbGFyID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9sYXIobmFtZSkge1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IFsncmFkaXVzJywgJ2FuZ2xlJ107XG4gICAgdGhpcy50eXBlID0gJ3BvbGFyJztcbiAgICAvKipcbiAgICAgKiB4IG9mIHBvbGFyIGNlbnRlclxuICAgICAqL1xuXG4gICAgdGhpcy5jeCA9IDA7XG4gICAgLyoqXG4gICAgICogeSBvZiBwb2xhciBjZW50ZXJcbiAgICAgKi9cblxuICAgIHRoaXMuY3kgPSAwO1xuICAgIHRoaXMuX3JhZGl1c0F4aXMgPSBuZXcgUmFkaXVzQXhpcygpO1xuICAgIHRoaXMuX2FuZ2xlQXhpcyA9IG5ldyBBbmdsZUF4aXMoKTtcbiAgICB0aGlzLmF4aXNQb2ludGVyRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5uYW1lID0gbmFtZSB8fCAnJztcbiAgICB0aGlzLl9yYWRpdXNBeGlzLnBvbGFyID0gdGhpcy5fYW5nbGVBeGlzLnBvbGFyID0gdGhpcztcbiAgfVxuICAvKipcbiAgICogSWYgY29udGFpbiBjb29yZFxuICAgKi9cblxuXG4gIFBvbGFyLnByb3RvdHlwZS5jb250YWluUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgY29vcmQgPSB0aGlzLnBvaW50VG9Db29yZChwb2ludCk7XG4gICAgcmV0dXJuIHRoaXMuX3JhZGl1c0F4aXMuY29udGFpbihjb29yZFswXSkgJiYgdGhpcy5fYW5nbGVBeGlzLmNvbnRhaW4oY29vcmRbMV0pO1xuICB9O1xuICAvKipcbiAgICogSWYgY29udGFpbiBkYXRhXG4gICAqL1xuXG5cbiAgUG9sYXIucHJvdG90eXBlLmNvbnRhaW5EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fcmFkaXVzQXhpcy5jb250YWluRGF0YShkYXRhWzBdKSAmJiB0aGlzLl9hbmdsZUF4aXMuY29udGFpbkRhdGEoZGF0YVsxXSk7XG4gIH07XG5cbiAgUG9sYXIucHJvdG90eXBlLmdldEF4aXMgPSBmdW5jdGlvbiAoZGltKSB7XG4gICAgdmFyIGtleSA9ICdfJyArIGRpbSArICdBeGlzJztcbiAgICByZXR1cm4gdGhpc1trZXldO1xuICB9O1xuXG4gIFBvbGFyLnByb3RvdHlwZS5nZXRBeGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbdGhpcy5fcmFkaXVzQXhpcywgdGhpcy5fYW5nbGVBeGlzXTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldCBheGVzIGJ5IHR5cGUgb2Ygc2NhbGVcbiAgICovXG5cblxuICBQb2xhci5wcm90b3R5cGUuZ2V0QXhlc0J5U2NhbGUgPSBmdW5jdGlvbiAoc2NhbGVUeXBlKSB7XG4gICAgdmFyIGF4ZXMgPSBbXTtcbiAgICB2YXIgYW5nbGVBeGlzID0gdGhpcy5fYW5nbGVBeGlzO1xuICAgIHZhciByYWRpdXNBeGlzID0gdGhpcy5fcmFkaXVzQXhpcztcbiAgICBhbmdsZUF4aXMuc2NhbGUudHlwZSA9PT0gc2NhbGVUeXBlICYmIGF4ZXMucHVzaChhbmdsZUF4aXMpO1xuICAgIHJhZGl1c0F4aXMuc2NhbGUudHlwZSA9PT0gc2NhbGVUeXBlICYmIGF4ZXMucHVzaChyYWRpdXNBeGlzKTtcbiAgICByZXR1cm4gYXhlcztcbiAgfTtcblxuICBQb2xhci5wcm90b3R5cGUuZ2V0QW5nbGVBeGlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9hbmdsZUF4aXM7XG4gIH07XG5cbiAgUG9sYXIucHJvdG90eXBlLmdldFJhZGl1c0F4aXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JhZGl1c0F4aXM7XG4gIH07XG5cbiAgUG9sYXIucHJvdG90eXBlLmdldE90aGVyQXhpcyA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgdmFyIGFuZ2xlQXhpcyA9IHRoaXMuX2FuZ2xlQXhpcztcbiAgICByZXR1cm4gYXhpcyA9PT0gYW5nbGVBeGlzID8gdGhpcy5fcmFkaXVzQXhpcyA6IGFuZ2xlQXhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEJhc2UgYXhpcyB3aWxsIGJlIHVzZWQgb24gc3RhY2tpbmcuXG4gICAqXG4gICAqL1xuXG5cbiAgUG9sYXIucHJvdG90eXBlLmdldEJhc2VBeGlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF4ZXNCeVNjYWxlKCdvcmRpbmFsJylbMF0gfHwgdGhpcy5nZXRBeGVzQnlTY2FsZSgndGltZScpWzBdIHx8IHRoaXMuZ2V0QW5nbGVBeGlzKCk7XG4gIH07XG5cbiAgUG9sYXIucHJvdG90eXBlLmdldFRvb2x0aXBBeGVzID0gZnVuY3Rpb24gKGRpbSkge1xuICAgIHZhciBiYXNlQXhpcyA9IGRpbSAhPSBudWxsICYmIGRpbSAhPT0gJ2F1dG8nID8gdGhpcy5nZXRBeGlzKGRpbSkgOiB0aGlzLmdldEJhc2VBeGlzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2VBeGVzOiBbYmFzZUF4aXNdLFxuICAgICAgb3RoZXJBeGVzOiBbdGhpcy5nZXRPdGhlckF4aXMoYmFzZUF4aXMpXVxuICAgIH07XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgc2luZ2xlIGRhdGEgaXRlbSB0byAoeCwgeSkgcG9pbnQuXG4gICAqIFBhcmFtZXRlciBkYXRhIGlzIGFuIGFycmF5IHdoaWNoIHRoZSBmaXJzdCBlbGVtZW50IGlzIHJhZGl1cyBhbmQgdGhlIHNlY29uZCBpcyBhbmdsZVxuICAgKi9cblxuXG4gIFBvbGFyLnByb3RvdHlwZS5kYXRhVG9Qb2ludCA9IGZ1bmN0aW9uIChkYXRhLCBjbGFtcCkge1xuICAgIHJldHVybiB0aGlzLmNvb3JkVG9Qb2ludChbdGhpcy5fcmFkaXVzQXhpcy5kYXRhVG9SYWRpdXMoZGF0YVswXSwgY2xhbXApLCB0aGlzLl9hbmdsZUF4aXMuZGF0YVRvQW5nbGUoZGF0YVsxXSwgY2xhbXApXSk7XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgKHgsIHkpIHBvaW50IHRvIGRhdGFcbiAgICovXG5cblxuICBQb2xhci5wcm90b3R5cGUucG9pbnRUb0RhdGEgPSBmdW5jdGlvbiAocG9pbnQsIGNsYW1wKSB7XG4gICAgdmFyIGNvb3JkID0gdGhpcy5wb2ludFRvQ29vcmQocG9pbnQpO1xuICAgIHJldHVybiBbdGhpcy5fcmFkaXVzQXhpcy5yYWRpdXNUb0RhdGEoY29vcmRbMF0sIGNsYW1wKSwgdGhpcy5fYW5nbGVBeGlzLmFuZ2xlVG9EYXRhKGNvb3JkWzFdLCBjbGFtcCldO1xuICB9O1xuICAvKipcbiAgICogQ29udmVydCBhICh4LCB5KSBwb2ludCB0byAocmFkaXVzLCBhbmdsZSkgY29vcmRcbiAgICovXG5cblxuICBQb2xhci5wcm90b3R5cGUucG9pbnRUb0Nvb3JkID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgdmFyIGR4ID0gcG9pbnRbMF0gLSB0aGlzLmN4O1xuICAgIHZhciBkeSA9IHBvaW50WzFdIC0gdGhpcy5jeTtcbiAgICB2YXIgYW5nbGVBeGlzID0gdGhpcy5nZXRBbmdsZUF4aXMoKTtcbiAgICB2YXIgZXh0ZW50ID0gYW5nbGVBeGlzLmdldEV4dGVudCgpO1xuICAgIHZhciBtaW5BbmdsZSA9IE1hdGgubWluKGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICB2YXIgbWF4QW5nbGUgPSBNYXRoLm1heChleHRlbnRbMF0sIGV4dGVudFsxXSk7IC8vIEZpeCBmaXhlZCBleHRlbnQgaW4gcG9sYXJDcmVhdG9yXG4gICAgLy8gRklYTUVcblxuICAgIGFuZ2xlQXhpcy5pbnZlcnNlID8gbWluQW5nbGUgPSBtYXhBbmdsZSAtIDM2MCA6IG1heEFuZ2xlID0gbWluQW5nbGUgKyAzNjA7XG4gICAgdmFyIHJhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgZHggLz0gcmFkaXVzO1xuICAgIGR5IC89IHJhZGl1cztcbiAgICB2YXIgcmFkaWFuID0gTWF0aC5hdGFuMigtZHksIGR4KSAvIE1hdGguUEkgKiAxODA7IC8vIG1vdmUgdG8gYW5nbGVFeHRlbnRcblxuICAgIHZhciBkaXIgPSByYWRpYW4gPCBtaW5BbmdsZSA/IDEgOiAtMTtcblxuICAgIHdoaWxlIChyYWRpYW4gPCBtaW5BbmdsZSB8fCByYWRpYW4gPiBtYXhBbmdsZSkge1xuICAgICAgcmFkaWFuICs9IGRpciAqIDM2MDtcbiAgICB9XG5cbiAgICByZXR1cm4gW3JhZGl1cywgcmFkaWFuXTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnQgYSAocmFkaXVzLCBhbmdsZSkgY29vcmQgdG8gKHgsIHkpIHBvaW50XG4gICAqL1xuXG5cbiAgUG9sYXIucHJvdG90eXBlLmNvb3JkVG9Qb2ludCA9IGZ1bmN0aW9uIChjb29yZCkge1xuICAgIHZhciByYWRpdXMgPSBjb29yZFswXTtcbiAgICB2YXIgcmFkaWFuID0gY29vcmRbMV0gLyAxODAgKiBNYXRoLlBJO1xuICAgIHZhciB4ID0gTWF0aC5jb3MocmFkaWFuKSAqIHJhZGl1cyArIHRoaXMuY3g7IC8vIEludmVyc2UgdGhlIHlcblxuICAgIHZhciB5ID0gLU1hdGguc2luKHJhZGlhbikgKiByYWRpdXMgKyB0aGlzLmN5O1xuICAgIHJldHVybiBbeCwgeV07XG4gIH07XG4gIC8qKlxuICAgKiBHZXQgcmluZyBhcmVhIG9mIGNhcnRlc2lhbi5cbiAgICogQXJlYSB3aWxsIGhhdmUgYSBjb250YWluIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhIHBvaW50IGlzIGluIHRoZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICovXG5cblxuICBQb2xhci5wcm90b3R5cGUuZ2V0QXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYW5nbGVBeGlzID0gdGhpcy5nZXRBbmdsZUF4aXMoKTtcbiAgICB2YXIgcmFkaXVzQXhpcyA9IHRoaXMuZ2V0UmFkaXVzQXhpcygpO1xuICAgIHZhciByYWRpdXNFeHRlbnQgPSByYWRpdXNBeGlzLmdldEV4dGVudCgpLnNsaWNlKCk7XG4gICAgcmFkaXVzRXh0ZW50WzBdID4gcmFkaXVzRXh0ZW50WzFdICYmIHJhZGl1c0V4dGVudC5yZXZlcnNlKCk7XG4gICAgdmFyIGFuZ2xlRXh0ZW50ID0gYW5nbGVBeGlzLmdldEV4dGVudCgpO1xuICAgIHZhciBSQURJQU4gPSBNYXRoLlBJIC8gMTgwO1xuICAgIHJldHVybiB7XG4gICAgICBjeDogdGhpcy5jeCxcbiAgICAgIGN5OiB0aGlzLmN5LFxuICAgICAgcjA6IHJhZGl1c0V4dGVudFswXSxcbiAgICAgIHI6IHJhZGl1c0V4dGVudFsxXSxcbiAgICAgIHN0YXJ0QW5nbGU6IC1hbmdsZUV4dGVudFswXSAqIFJBRElBTixcbiAgICAgIGVuZEFuZ2xlOiAtYW5nbGVFeHRlbnRbMV0gKiBSQURJQU4sXG4gICAgICBjbG9ja3dpc2U6IGFuZ2xlQXhpcy5pbnZlcnNlLFxuICAgICAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgLy8gSXQncyBhIHJpbmcgc2hhcGUuXG4gICAgICAgIC8vIFN0YXJ0IGFuZ2xlIGFuZCBlbmQgYW5nbGUgZG9uJ3QgbWF0dGVyXG4gICAgICAgIHZhciBkeCA9IHggLSB0aGlzLmN4O1xuICAgICAgICB2YXIgZHkgPSB5IC0gdGhpcy5jeTtcbiAgICAgICAgdmFyIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIHZhciByID0gdGhpcy5yO1xuICAgICAgICB2YXIgcjAgPSB0aGlzLnIwO1xuICAgICAgICByZXR1cm4gZDIgPD0gciAqIHIgJiYgZDIgPj0gcjAgKiByMDtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIFBvbGFyLnByb3RvdHlwZS5jb252ZXJ0VG9QaXhlbCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIsIHZhbHVlKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gZ2V0Q29vcmRTeXMoZmluZGVyKTtcbiAgICByZXR1cm4gY29vcmRTeXMgPT09IHRoaXMgPyB0aGlzLmRhdGFUb1BvaW50KHZhbHVlKSA6IG51bGw7XG4gIH07XG5cbiAgUG9sYXIucHJvdG90eXBlLmNvbnZlcnRGcm9tUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCBwaXhlbCkge1xuICAgIHZhciBjb29yZFN5cyA9IGdldENvb3JkU3lzKGZpbmRlcik7XG4gICAgcmV0dXJuIGNvb3JkU3lzID09PSB0aGlzID8gdGhpcy5wb2ludFRvRGF0YShwaXhlbCkgOiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBQb2xhcjtcbn0oKTtcblxuZnVuY3Rpb24gZ2V0Q29vcmRTeXMoZmluZGVyKSB7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGZpbmRlci5zZXJpZXNNb2RlbDtcbiAgdmFyIHBvbGFyTW9kZWwgPSBmaW5kZXIucG9sYXJNb2RlbDtcbiAgcmV0dXJuIHBvbGFyTW9kZWwgJiYgcG9sYXJNb2RlbC5jb29yZGluYXRlU3lzdGVtIHx8IHNlcmllc01vZGVsICYmIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvbGFyOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBDb21wb25lbnRNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Db21wb25lbnQnO1xuXG52YXIgUG9sYXJNb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQb2xhck1vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFBvbGFyTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gUG9sYXJNb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFBvbGFyTW9kZWwucHJvdG90eXBlLmZpbmRBeGlzTW9kZWwgPSBmdW5jdGlvbiAoYXhpc1R5cGUpIHtcbiAgICB2YXIgZm91bmRBeGlzTW9kZWw7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KGF4aXNUeXBlLCBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgICBpZiAoYXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKSA9PT0gdGhpcykge1xuICAgICAgICBmb3VuZEF4aXNNb2RlbCA9IGF4aXNNb2RlbDtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gZm91bmRBeGlzTW9kZWw7XG4gIH07XG5cbiAgUG9sYXJNb2RlbC50eXBlID0gJ3BvbGFyJztcbiAgUG9sYXJNb2RlbC5kZXBlbmRlbmNpZXMgPSBbJ3JhZGl1c0F4aXMnLCAnYW5nbGVBeGlzJ107XG4gIFBvbGFyTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogMCxcbiAgICBjZW50ZXI6IFsnNTAlJywgJzUwJSddLFxuICAgIHJhZGl1czogJzgwJSdcbiAgfTtcbiAgcmV0dXJuIFBvbGFyTW9kZWw7XG59KENvbXBvbmVudE1vZGVsKTtcblxuZXhwb3J0IGRlZmF1bHQgUG9sYXJNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQXhpcyBmcm9tICcuLi9BeGlzJztcblxudmFyIFJhZGl1c0F4aXMgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUmFkaXVzQXhpcywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBSYWRpdXNBeGlzKHNjYWxlLCByYWRpdXNFeHRlbnQpIHtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ3JhZGl1cycsIHNjYWxlLCByYWRpdXNFeHRlbnQpIHx8IHRoaXM7XG4gIH1cblxuICBSYWRpdXNBeGlzLnByb3RvdHlwZS5wb2ludFRvRGF0YSA9IGZ1bmN0aW9uIChwb2ludCwgY2xhbXApIHtcbiAgICByZXR1cm4gdGhpcy5wb2xhci5wb2ludFRvRGF0YShwb2ludCwgY2xhbXApW3RoaXMuZGltID09PSAncmFkaXVzJyA/IDAgOiAxXTtcbiAgfTtcblxuICByZXR1cm4gUmFkaXVzQXhpcztcbn0oQXhpcyk7XG5cblJhZGl1c0F4aXMucHJvdG90eXBlLmRhdGFUb1JhZGl1cyA9IEF4aXMucHJvdG90eXBlLmRhdGFUb0Nvb3JkO1xuUmFkaXVzQXhpcy5wcm90b3R5cGUucmFkaXVzVG9EYXRhID0gQXhpcy5wcm90b3R5cGUuY29vcmRUb0RhdGE7XG5leHBvcnQgZGVmYXVsdCBSYWRpdXNBeGlzOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBUT0RPIEF4aXMgc2NhbGVcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IFBvbGFyIGZyb20gJy4vUG9sYXInO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50IH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXInO1xuaW1wb3J0IHsgY3JlYXRlU2NhbGVCeU1vZGVsLCBuaWNlU2NhbGVFeHRlbnQsIGdldERhdGFEaW1lbnNpb25zT25BeGlzIH0gZnJvbSAnLi4vLi4vY29vcmQvYXhpc0hlbHBlcic7XG5pbXBvcnQgeyBTSU5HTEVfUkVGRVJSSU5HIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG4vKipcbiAqIFJlc2l6ZSBtZXRob2QgYm91bmQgdG8gdGhlIHBvbGFyXG4gKi9cblxuZnVuY3Rpb24gcmVzaXplUG9sYXIocG9sYXIsIHBvbGFyTW9kZWwsIGFwaSkge1xuICB2YXIgY2VudGVyID0gcG9sYXJNb2RlbC5nZXQoJ2NlbnRlcicpO1xuICB2YXIgd2lkdGggPSBhcGkuZ2V0V2lkdGgoKTtcbiAgdmFyIGhlaWdodCA9IGFwaS5nZXRIZWlnaHQoKTtcbiAgcG9sYXIuY3ggPSBwYXJzZVBlcmNlbnQoY2VudGVyWzBdLCB3aWR0aCk7XG4gIHBvbGFyLmN5ID0gcGFyc2VQZXJjZW50KGNlbnRlclsxXSwgaGVpZ2h0KTtcbiAgdmFyIHJhZGl1c0F4aXMgPSBwb2xhci5nZXRSYWRpdXNBeGlzKCk7XG4gIHZhciBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyO1xuICB2YXIgcmFkaXVzID0gcG9sYXJNb2RlbC5nZXQoJ3JhZGl1cycpO1xuXG4gIGlmIChyYWRpdXMgPT0gbnVsbCkge1xuICAgIHJhZGl1cyA9IFswLCAnMTAwJSddO1xuICB9IGVsc2UgaWYgKCF6clV0aWwuaXNBcnJheShyYWRpdXMpKSB7XG4gICAgLy8gcjAgPSAwXG4gICAgcmFkaXVzID0gWzAsIHJhZGl1c107XG4gIH1cblxuICB2YXIgcGFyc2VkUmFkaXVzID0gW3BhcnNlUGVyY2VudChyYWRpdXNbMF0sIHNpemUpLCBwYXJzZVBlcmNlbnQocmFkaXVzWzFdLCBzaXplKV07XG4gIHJhZGl1c0F4aXMuaW52ZXJzZSA/IHJhZGl1c0F4aXMuc2V0RXh0ZW50KHBhcnNlZFJhZGl1c1sxXSwgcGFyc2VkUmFkaXVzWzBdKSA6IHJhZGl1c0F4aXMuc2V0RXh0ZW50KHBhcnNlZFJhZGl1c1swXSwgcGFyc2VkUmFkaXVzWzFdKTtcbn1cbi8qKlxuICogVXBkYXRlIHBvbGFyXG4gKi9cblxuXG5mdW5jdGlvbiB1cGRhdGVQb2xhclNjYWxlKGVjTW9kZWwsIGFwaSkge1xuICB2YXIgcG9sYXIgPSB0aGlzO1xuICB2YXIgYW5nbGVBeGlzID0gcG9sYXIuZ2V0QW5nbGVBeGlzKCk7XG4gIHZhciByYWRpdXNBeGlzID0gcG9sYXIuZ2V0UmFkaXVzQXhpcygpOyAvLyBSZXNldCBzY2FsZVxuXG4gIGFuZ2xlQXhpcy5zY2FsZS5zZXRFeHRlbnQoSW5maW5pdHksIC1JbmZpbml0eSk7XG4gIHJhZGl1c0F4aXMuc2NhbGUuc2V0RXh0ZW50KEluZmluaXR5LCAtSW5maW5pdHkpO1xuICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgaWYgKHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPT09IHBvbGFyKSB7XG4gICAgICB2YXIgZGF0YV8xID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgenJVdGlsLmVhY2goZ2V0RGF0YURpbWVuc2lvbnNPbkF4aXMoZGF0YV8xLCAncmFkaXVzJyksIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgcmFkaXVzQXhpcy5zY2FsZS51bmlvbkV4dGVudEZyb21EYXRhKGRhdGFfMSwgZGltKTtcbiAgICAgIH0pO1xuICAgICAgenJVdGlsLmVhY2goZ2V0RGF0YURpbWVuc2lvbnNPbkF4aXMoZGF0YV8xLCAnYW5nbGUnKSwgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICBhbmdsZUF4aXMuc2NhbGUudW5pb25FeHRlbnRGcm9tRGF0YShkYXRhXzEsIGRpbSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBuaWNlU2NhbGVFeHRlbnQoYW5nbGVBeGlzLnNjYWxlLCBhbmdsZUF4aXMubW9kZWwpO1xuICBuaWNlU2NhbGVFeHRlbnQocmFkaXVzQXhpcy5zY2FsZSwgcmFkaXVzQXhpcy5tb2RlbCk7IC8vIEZpeCBleHRlbnQgb2YgY2F0ZWdvcnkgYW5nbGUgYXhpc1xuXG4gIGlmIChhbmdsZUF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyAmJiAhYW5nbGVBeGlzLm9uQmFuZCkge1xuICAgIHZhciBleHRlbnQgPSBhbmdsZUF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIGRpZmYgPSAzNjAgLyBhbmdsZUF4aXMuc2NhbGUuY291bnQoKTtcbiAgICBhbmdsZUF4aXMuaW52ZXJzZSA/IGV4dGVudFsxXSArPSBkaWZmIDogZXh0ZW50WzFdIC09IGRpZmY7XG4gICAgYW5nbGVBeGlzLnNldEV4dGVudChleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBbmdsZUF4aXNNb2RlbChheGlzTW9kZWwpIHtcbiAgcmV0dXJuIGF4aXNNb2RlbC5tYWluVHlwZSA9PT0gJ2FuZ2xlQXhpcyc7XG59XG4vKipcbiAqIFNldCBjb21tb24gYXhpcyBwcm9wZXJ0aWVzXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRBeGlzKGF4aXMsIGF4aXNNb2RlbCkge1xuICBheGlzLnR5cGUgPSBheGlzTW9kZWwuZ2V0KCd0eXBlJyk7XG4gIGF4aXMuc2NhbGUgPSBjcmVhdGVTY2FsZUJ5TW9kZWwoYXhpc01vZGVsKTtcbiAgYXhpcy5vbkJhbmQgPSBheGlzTW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpICYmIGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgYXhpcy5pbnZlcnNlID0gYXhpc01vZGVsLmdldCgnaW52ZXJzZScpO1xuXG4gIGlmIChpc0FuZ2xlQXhpc01vZGVsKGF4aXNNb2RlbCkpIHtcbiAgICBheGlzLmludmVyc2UgPSBheGlzLmludmVyc2UgIT09IGF4aXNNb2RlbC5nZXQoJ2Nsb2Nrd2lzZScpO1xuICAgIHZhciBzdGFydEFuZ2xlID0gYXhpc01vZGVsLmdldCgnc3RhcnRBbmdsZScpO1xuICAgIGF4aXMuc2V0RXh0ZW50KHN0YXJ0QW5nbGUsIHN0YXJ0QW5nbGUgKyAoYXhpcy5pbnZlcnNlID8gLTM2MCA6IDM2MCkpO1xuICB9IC8vIEluamVjdCBheGlzIGluc3RhbmNlXG5cblxuICBheGlzTW9kZWwuYXhpcyA9IGF4aXM7XG4gIGF4aXMubW9kZWwgPSBheGlzTW9kZWw7XG59XG5cbnZhciBwb2xhckNyZWF0b3IgPSB7XG4gIGRpbWVuc2lvbnM6IFBvbGFyLnByb3RvdHlwZS5kaW1lbnNpb25zLFxuICBjcmVhdGU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgcG9sYXJMaXN0ID0gW107XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdwb2xhcicsIGZ1bmN0aW9uIChwb2xhck1vZGVsLCBpZHgpIHtcbiAgICAgIHZhciBwb2xhciA9IG5ldyBQb2xhcihpZHggKyAnJyk7IC8vIEluamVjdCByZXNpemUgYW5kIHVwZGF0ZSBtZXRob2RcblxuICAgICAgcG9sYXIudXBkYXRlID0gdXBkYXRlUG9sYXJTY2FsZTtcbiAgICAgIHZhciByYWRpdXNBeGlzID0gcG9sYXIuZ2V0UmFkaXVzQXhpcygpO1xuICAgICAgdmFyIGFuZ2xlQXhpcyA9IHBvbGFyLmdldEFuZ2xlQXhpcygpO1xuICAgICAgdmFyIHJhZGl1c0F4aXNNb2RlbCA9IHBvbGFyTW9kZWwuZmluZEF4aXNNb2RlbCgncmFkaXVzQXhpcycpO1xuICAgICAgdmFyIGFuZ2xlQXhpc01vZGVsID0gcG9sYXJNb2RlbC5maW5kQXhpc01vZGVsKCdhbmdsZUF4aXMnKTtcbiAgICAgIHNldEF4aXMocmFkaXVzQXhpcywgcmFkaXVzQXhpc01vZGVsKTtcbiAgICAgIHNldEF4aXMoYW5nbGVBeGlzLCBhbmdsZUF4aXNNb2RlbCk7XG4gICAgICByZXNpemVQb2xhcihwb2xhciwgcG9sYXJNb2RlbCwgYXBpKTtcbiAgICAgIHBvbGFyTGlzdC5wdXNoKHBvbGFyKTtcbiAgICAgIHBvbGFyTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9IHBvbGFyO1xuICAgICAgcG9sYXIubW9kZWwgPSBwb2xhck1vZGVsO1xuICAgIH0pOyAvLyBJbmplY3QgY29vcmRpbmF0ZVN5c3RlbSB0byBzZXJpZXNcblxuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIGlmIChzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKSA9PT0gJ3BvbGFyJykge1xuICAgICAgICB2YXIgcG9sYXJNb2RlbCA9IHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3BvbGFyJywgU0lOR0xFX1JFRkVSUklORykubW9kZWxzWzBdO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFwb2xhck1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvbGFyIFwiJyArIHpyVXRpbC5yZXRyaWV2ZShzZXJpZXNNb2RlbC5nZXQoJ3BvbGFySW5kZXgnKSwgc2VyaWVzTW9kZWwuZ2V0KCdwb2xhcklkJyksIDApICsgJ1wiIG5vdCBmb3VuZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSBwb2xhck1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBvbGFyTGlzdDtcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IHBvbGFyQ3JlYXRvcjsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50JztcbmltcG9ydCB7IEF4aXNNb2RlbENvbW1vbk1peGluIH0gZnJvbSAnLi4vYXhpc01vZGVsQ29tbW9uTWl4aW4nO1xuaW1wb3J0IHsgbWl4aW4gfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuXG52YXIgU2luZ2xlQXhpc01vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNpbmdsZUF4aXNNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTaW5nbGVBeGlzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gU2luZ2xlQXhpc01vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU2luZ2xlQXhpc01vZGVsLnByb3RvdHlwZS5nZXRDb29yZFN5c01vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFNpbmdsZUF4aXNNb2RlbC50eXBlID0gJ3NpbmdsZUF4aXMnO1xuICBTaW5nbGVBeGlzTW9kZWwubGF5b3V0TW9kZSA9ICdib3gnO1xuICBTaW5nbGVBeGlzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICBsZWZ0OiAnNSUnLFxuICAgIHRvcDogJzUlJyxcbiAgICByaWdodDogJzUlJyxcbiAgICBib3R0b206ICc1JScsXG4gICAgdHlwZTogJ3ZhbHVlJyxcbiAgICBwb3NpdGlvbjogJ2JvdHRvbScsXG4gICAgb3JpZW50OiAnaG9yaXpvbnRhbCcsXG4gICAgYXhpc0xpbmU6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFNpbmdsZSBjb29yZGluYXRlIHN5c3RlbSBhbmQgc2luZ2xlIGF4aXMgaXMgdGhlLFxuICAgIC8vIHdoaWNoIGlzIHVzZWQgYXMgdGhlIHBhcmVudCB0b29sdGlwIG1vZGVsLlxuICAgIC8vIHNhbWUgbW9kZWwsIHNvIHdlIHNldCBkZWZhdWx0IHRvb2x0aXAgc2hvdyBhcyB0cnVlLlxuICAgIHRvb2x0aXA6IHtcbiAgICAgIHNob3c6IHRydWVcbiAgICB9LFxuICAgIGF4aXNUaWNrOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgbGVuZ3RoOiA2LFxuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiAxXG4gICAgICB9XG4gICAgfSxcbiAgICBheGlzTGFiZWw6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBpbnRlcnZhbDogJ2F1dG8nXG4gICAgfSxcbiAgICBzcGxpdExpbmU6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgdHlwZTogJ2Rhc2hlZCcsXG4gICAgICAgIG9wYWNpdHk6IDAuMlxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFNpbmdsZUF4aXNNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuXG5taXhpbihTaW5nbGVBeGlzTW9kZWwsIEF4aXNNb2RlbENvbW1vbk1peGluLnByb3RvdHlwZSk7XG5leHBvcnQgZGVmYXVsdCBTaW5nbGVBeGlzTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBTaW5nbGUgY29vcmRpbmF0ZXMgc3lzdGVtLlxuICovXG5pbXBvcnQgU2luZ2xlQXhpcyBmcm9tICcuL1NpbmdsZUF4aXMnO1xuaW1wb3J0ICogYXMgYXhpc0hlbHBlciBmcm9tICcuLi9heGlzSGVscGVyJztcbmltcG9ydCB7IGdldExheW91dFJlY3QgfSBmcm9tICcuLi8uLi91dGlsL2xheW91dCc7XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbi8qKlxuICogQ3JlYXRlIGEgc2luZ2xlIGNvb3JkaW5hdGVzIHN5c3RlbS5cbiAqL1xuXG52YXIgU2luZ2xlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2luZ2xlKGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy50eXBlID0gJ3NpbmdsZSc7XG4gICAgdGhpcy5kaW1lbnNpb24gPSAnc2luZ2xlJztcbiAgICAvKipcbiAgICAgKiBBZGQgaXQganVzdCBmb3IgZHJhdyB0b29sdGlwLlxuICAgICAqL1xuXG4gICAgdGhpcy5kaW1lbnNpb25zID0gWydzaW5nbGUnXTtcbiAgICB0aGlzLmF4aXNQb2ludGVyRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5tb2RlbCA9IGF4aXNNb2RlbDtcblxuICAgIHRoaXMuX2luaXQoYXhpc01vZGVsLCBlY01vZGVsLCBhcGkpO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHNpbmdsZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICovXG5cblxuICBTaW5nbGUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGRpbSA9IHRoaXMuZGltZW5zaW9uO1xuICAgIHZhciBheGlzID0gbmV3IFNpbmdsZUF4aXMoZGltLCBheGlzSGVscGVyLmNyZWF0ZVNjYWxlQnlNb2RlbChheGlzTW9kZWwpLCBbMCwgMF0sIGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSwgYXhpc01vZGVsLmdldCgncG9zaXRpb24nKSk7XG4gICAgdmFyIGlzQ2F0ZWdvcnkgPSBheGlzLnR5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgYXhpcy5vbkJhbmQgPSBpc0NhdGVnb3J5ICYmIGF4aXNNb2RlbC5nZXQoJ2JvdW5kYXJ5R2FwJyk7XG4gICAgYXhpcy5pbnZlcnNlID0gYXhpc01vZGVsLmdldCgnaW52ZXJzZScpO1xuICAgIGF4aXMub3JpZW50ID0gYXhpc01vZGVsLmdldCgnb3JpZW50Jyk7XG4gICAgYXhpc01vZGVsLmF4aXMgPSBheGlzO1xuICAgIGF4aXMubW9kZWwgPSBheGlzTW9kZWw7XG4gICAgYXhpcy5jb29yZGluYXRlU3lzdGVtID0gdGhpcztcbiAgICB0aGlzLl9heGlzID0gYXhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFVwZGF0ZSBheGlzIHNjYWxlIGFmdGVyIGRhdGEgcHJvY2Vzc2VkXG4gICAqL1xuXG5cbiAgU2luZ2xlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgaWYgKHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPT09IHRoaXMpIHtcbiAgICAgICAgdmFyIGRhdGFfMSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgZWFjaChkYXRhXzEubWFwRGltZW5zaW9uc0FsbCh0aGlzLmRpbWVuc2lvbiksIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgICB0aGlzLl9heGlzLnNjYWxlLnVuaW9uRXh0ZW50RnJvbURhdGEoZGF0YV8xLCBkaW0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgYXhpc0hlbHBlci5uaWNlU2NhbGVFeHRlbnQodGhpcy5fYXhpcy5zY2FsZSwgdGhpcy5fYXhpcy5tb2RlbCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIHNpbmdsZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICovXG5cblxuICBTaW5nbGUucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChheGlzTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuX3JlY3QgPSBnZXRMYXlvdXRSZWN0KHtcbiAgICAgIGxlZnQ6IGF4aXNNb2RlbC5nZXQoJ2xlZnQnKSxcbiAgICAgIHRvcDogYXhpc01vZGVsLmdldCgndG9wJyksXG4gICAgICByaWdodDogYXhpc01vZGVsLmdldCgncmlnaHQnKSxcbiAgICAgIGJvdHRvbTogYXhpc01vZGVsLmdldCgnYm90dG9tJyksXG4gICAgICB3aWR0aDogYXhpc01vZGVsLmdldCgnd2lkdGgnKSxcbiAgICAgIGhlaWdodDogYXhpc01vZGVsLmdldCgnaGVpZ2h0JylcbiAgICB9LCB7XG4gICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgIH0pO1xuXG4gICAgdGhpcy5fYWRqdXN0QXhpcygpO1xuICB9O1xuXG4gIFNpbmdsZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgfTtcblxuICBTaW5nbGUucHJvdG90eXBlLl9hZGp1c3RBeGlzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWN0ID0gdGhpcy5fcmVjdDtcbiAgICB2YXIgYXhpcyA9IHRoaXMuX2F4aXM7XG4gICAgdmFyIGlzSG9yaXpvbnRhbCA9IGF4aXMuaXNIb3Jpem9udGFsKCk7XG4gICAgdmFyIGV4dGVudCA9IGlzSG9yaXpvbnRhbCA/IFswLCByZWN0LndpZHRoXSA6IFswLCByZWN0LmhlaWdodF07XG4gICAgdmFyIGlkeCA9IGF4aXMucmV2ZXJzZSA/IDEgOiAwO1xuICAgIGF4aXMuc2V0RXh0ZW50KGV4dGVudFtpZHhdLCBleHRlbnRbMSAtIGlkeF0pO1xuXG4gICAgdGhpcy5fdXBkYXRlQXhpc1RyYW5zZm9ybShheGlzLCBpc0hvcml6b250YWwgPyByZWN0LnggOiByZWN0LnkpO1xuICB9O1xuXG4gIFNpbmdsZS5wcm90b3R5cGUuX3VwZGF0ZUF4aXNUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoYXhpcywgY29vcmRCYXNlKSB7XG4gICAgdmFyIGF4aXNFeHRlbnQgPSBheGlzLmdldEV4dGVudCgpO1xuICAgIHZhciBleHRlbnRTdW0gPSBheGlzRXh0ZW50WzBdICsgYXhpc0V4dGVudFsxXTtcbiAgICB2YXIgaXNIb3Jpem9udGFsID0gYXhpcy5pc0hvcml6b250YWwoKTtcbiAgICBheGlzLnRvR2xvYmFsQ29vcmQgPSBpc0hvcml6b250YWwgPyBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgIHJldHVybiBjb29yZCArIGNvb3JkQmFzZTtcbiAgICB9IDogZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICByZXR1cm4gZXh0ZW50U3VtIC0gY29vcmQgKyBjb29yZEJhc2U7XG4gICAgfTtcbiAgICBheGlzLnRvTG9jYWxDb29yZCA9IGlzSG9yaXpvbnRhbCA/IGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgcmV0dXJuIGNvb3JkIC0gY29vcmRCYXNlO1xuICAgIH0gOiBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgIHJldHVybiBleHRlbnRTdW0gLSBjb29yZCArIGNvb3JkQmFzZTtcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogR2V0IGF4aXMuXG4gICAqL1xuXG5cbiAgU2luZ2xlLnByb3RvdHlwZS5nZXRBeGlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9heGlzO1xuICB9O1xuICAvKipcbiAgICogR2V0IGF4aXMsIGFkZCBpdCBqdXN0IGZvciBkcmF3IHRvb2x0aXAuXG4gICAqL1xuXG5cbiAgU2luZ2xlLnByb3RvdHlwZS5nZXRCYXNlQXhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXhpcztcbiAgfTtcblxuICBTaW5nbGUucHJvdG90eXBlLmdldEF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLl9heGlzXTtcbiAgfTtcblxuICBTaW5nbGUucHJvdG90eXBlLmdldFRvb2x0aXBBeGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlQXhlczogW3RoaXMuZ2V0QXhpcygpXSxcbiAgICAgIC8vIEVtcHR5IG90aGVyQXhlc1xuICAgICAgb3RoZXJBeGVzOiBbXVxuICAgIH07XG4gIH07XG4gIC8qKlxuICAgKiBJZiBjb250YWluIHBvaW50LlxuICAgKi9cblxuXG4gIFNpbmdsZS5wcm90b3R5cGUuY29udGFpblBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldFJlY3QoKTtcbiAgICB2YXIgYXhpcyA9IHRoaXMuZ2V0QXhpcygpO1xuICAgIHZhciBvcmllbnQgPSBheGlzLm9yaWVudDtcblxuICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgcmV0dXJuIGF4aXMuY29udGFpbihheGlzLnRvTG9jYWxDb29yZChwb2ludFswXSkpICYmIHBvaW50WzFdID49IHJlY3QueSAmJiBwb2ludFsxXSA8PSByZWN0LnkgKyByZWN0LmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF4aXMuY29udGFpbihheGlzLnRvTG9jYWxDb29yZChwb2ludFsxXSkpICYmIHBvaW50WzBdID49IHJlY3QueSAmJiBwb2ludFswXSA8PSByZWN0LnkgKyByZWN0LmhlaWdodDtcbiAgICB9XG4gIH07XG5cbiAgU2luZ2xlLnByb3RvdHlwZS5wb2ludFRvRGF0YSA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciBheGlzID0gdGhpcy5nZXRBeGlzKCk7XG4gICAgcmV0dXJuIFtheGlzLmNvb3JkVG9EYXRhKGF4aXMudG9Mb2NhbENvb3JkKHBvaW50W2F4aXMub3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyAwIDogMV0pKV07XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBzZXJpZXMgZGF0YSB0byBjb25jcmV0ZSBwb2ludC5cbiAgICogQ2FuIGJlIFt2YWxdIHwgdmFsXG4gICAqL1xuXG5cbiAgU2luZ2xlLnByb3RvdHlwZS5kYXRhVG9Qb2ludCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMuZ2V0QXhpcygpO1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRSZWN0KCk7XG4gICAgdmFyIHB0ID0gW107XG4gICAgdmFyIGlkeCA9IGF4aXMub3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyAwIDogMTtcblxuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFsID0gdmFsWzBdO1xuICAgIH1cblxuICAgIHB0W2lkeF0gPSBheGlzLnRvR2xvYmFsQ29vcmQoYXhpcy5kYXRhVG9Db29yZCgrdmFsKSk7XG4gICAgcHRbMSAtIGlkeF0gPSBpZHggPT09IDAgPyByZWN0LnkgKyByZWN0LmhlaWdodCAvIDIgOiByZWN0LnggKyByZWN0LndpZHRoIC8gMjtcbiAgICByZXR1cm4gcHQ7XG4gIH07XG5cbiAgU2luZ2xlLnByb3RvdHlwZS5jb252ZXJ0VG9QaXhlbCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIsIHZhbHVlKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gZ2V0Q29vcmRTeXMoZmluZGVyKTtcbiAgICByZXR1cm4gY29vcmRTeXMgPT09IHRoaXMgPyB0aGlzLmRhdGFUb1BvaW50KHZhbHVlKSA6IG51bGw7XG4gIH07XG5cbiAgU2luZ2xlLnByb3RvdHlwZS5jb252ZXJ0RnJvbVBpeGVsID0gZnVuY3Rpb24gKGVjTW9kZWwsIGZpbmRlciwgcGl4ZWwpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBnZXRDb29yZFN5cyhmaW5kZXIpO1xuICAgIHJldHVybiBjb29yZFN5cyA9PT0gdGhpcyA/IHRoaXMucG9pbnRUb0RhdGEocGl4ZWwpIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gU2luZ2xlO1xufSgpO1xuXG5mdW5jdGlvbiBnZXRDb29yZFN5cyhmaW5kZXIpIHtcbiAgdmFyIHNlcmllc01vZGVsID0gZmluZGVyLnNlcmllc01vZGVsO1xuICB2YXIgc2luZ2xlTW9kZWwgPSBmaW5kZXIuc2luZ2xlQXhpc01vZGVsO1xuICByZXR1cm4gc2luZ2xlTW9kZWwgJiYgc2luZ2xlTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSB8fCBzZXJpZXNNb2RlbCAmJiBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTaW5nbGU7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IEF4aXMgZnJvbSAnLi4vQXhpcyc7XG5cbnZhciBTaW5nbGVBeGlzID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNpbmdsZUF4aXMsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU2luZ2xlQXhpcyhkaW0sIHNjYWxlLCBjb29yZEV4dGVudCwgYXhpc1R5cGUsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGltLCBzY2FsZSwgY29vcmRFeHRlbnQpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gYXhpc1R5cGUgfHwgJ3ZhbHVlJztcbiAgICBfdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uIHx8ICdib3R0b20nO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogSnVkZ2UgdGhlIG9yaWVudCBvZiB0aGUgYXhpcy5cbiAgICovXG5cblxuICBTaW5nbGVBeGlzLnByb3RvdHlwZS5pc0hvcml6b250YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfTtcblxuICBTaW5nbGVBeGlzLnByb3RvdHlwZS5wb2ludFRvRGF0YSA9IGZ1bmN0aW9uIChwb2ludCwgY2xhbXApIHtcbiAgICByZXR1cm4gdGhpcy5jb29yZGluYXRlU3lzdGVtLnBvaW50VG9EYXRhKHBvaW50KVswXTtcbiAgfTtcblxuICByZXR1cm4gU2luZ2xlQXhpcztcbn0oQXhpcyk7XG5cbmV4cG9ydCBkZWZhdWx0IFNpbmdsZUF4aXM7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuZXhwb3J0IGZ1bmN0aW9uIGxheW91dChheGlzTW9kZWwsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG4gIHZhciBzaW5nbGUgPSBheGlzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgdmFyIGxheW91dCA9IHt9O1xuICB2YXIgYXhpc1Bvc2l0aW9uID0gYXhpcy5wb3NpdGlvbjtcbiAgdmFyIG9yaWVudCA9IGF4aXMub3JpZW50O1xuICB2YXIgcmVjdCA9IHNpbmdsZS5nZXRSZWN0KCk7XG4gIHZhciByZWN0Qm91bmQgPSBbcmVjdC54LCByZWN0LnggKyByZWN0LndpZHRoLCByZWN0LnksIHJlY3QueSArIHJlY3QuaGVpZ2h0XTtcbiAgdmFyIHBvc2l0aW9uTWFwID0ge1xuICAgIGhvcml6b250YWw6IHtcbiAgICAgIHRvcDogcmVjdEJvdW5kWzJdLFxuICAgICAgYm90dG9tOiByZWN0Qm91bmRbM11cbiAgICB9LFxuICAgIHZlcnRpY2FsOiB7XG4gICAgICBsZWZ0OiByZWN0Qm91bmRbMF0sXG4gICAgICByaWdodDogcmVjdEJvdW5kWzFdXG4gICAgfVxuICB9O1xuICBsYXlvdXQucG9zaXRpb24gPSBbb3JpZW50ID09PSAndmVydGljYWwnID8gcG9zaXRpb25NYXAudmVydGljYWxbYXhpc1Bvc2l0aW9uXSA6IHJlY3RCb3VuZFswXSwgb3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyBwb3NpdGlvbk1hcC5ob3Jpem9udGFsW2F4aXNQb3NpdGlvbl0gOiByZWN0Qm91bmRbM11dO1xuICB2YXIgciA9IHtcbiAgICBob3Jpem9udGFsOiAwLFxuICAgIHZlcnRpY2FsOiAxXG4gIH07XG4gIGxheW91dC5yb3RhdGlvbiA9IE1hdGguUEkgLyAyICogcltvcmllbnRdO1xuICB2YXIgZGlyZWN0aW9uTWFwID0ge1xuICAgIHRvcDogLTEsXG4gICAgYm90dG9tOiAxLFxuICAgIHJpZ2h0OiAxLFxuICAgIGxlZnQ6IC0xXG4gIH07XG4gIGxheW91dC5sYWJlbERpcmVjdGlvbiA9IGxheW91dC50aWNrRGlyZWN0aW9uID0gbGF5b3V0Lm5hbWVEaXJlY3Rpb24gPSBkaXJlY3Rpb25NYXBbYXhpc1Bvc2l0aW9uXTtcblxuICBpZiAoYXhpc01vZGVsLmdldChbJ2F4aXNUaWNrJywgJ2luc2lkZSddKSkge1xuICAgIGxheW91dC50aWNrRGlyZWN0aW9uID0gLWxheW91dC50aWNrRGlyZWN0aW9uO1xuICB9XG5cbiAgaWYgKHpyVXRpbC5yZXRyaWV2ZShvcHQubGFiZWxJbnNpZGUsIGF4aXNNb2RlbC5nZXQoWydheGlzTGFiZWwnLCAnaW5zaWRlJ10pKSkge1xuICAgIGxheW91dC5sYWJlbERpcmVjdGlvbiA9IC1sYXlvdXQubGFiZWxEaXJlY3Rpb247XG4gIH1cblxuICB2YXIgbGFiZWxSb3RhdGlvbiA9IG9wdC5yb3RhdGU7XG4gIGxhYmVsUm90YXRpb24gPT0gbnVsbCAmJiAobGFiZWxSb3RhdGlvbiA9IGF4aXNNb2RlbC5nZXQoWydheGlzTGFiZWwnLCAncm90YXRlJ10pKTtcbiAgbGF5b3V0LmxhYmVsUm90YXRpb24gPSBheGlzUG9zaXRpb24gPT09ICd0b3AnID8gLWxhYmVsUm90YXRpb24gOiBsYWJlbFJvdGF0aW9uO1xuICBsYXlvdXQuejIgPSAxO1xuICByZXR1cm4gbGF5b3V0O1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogU2luZ2xlIGNvb3JkaW5hdGUgc3lzdGVtIGNyZWF0b3IuXG4gKi9cbmltcG9ydCBTaW5nbGUgZnJvbSAnLi9TaW5nbGUnO1xuaW1wb3J0IHsgU0lOR0xFX1JFRkVSUklORyB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwnO1xuLyoqXG4gKiBDcmVhdGUgc2luZ2xlIGNvb3JkaW5hdGUgc3lzdGVtIGFuZCBpbmplY3QgaXQgaW50byBzZXJpZXNNb2RlbC5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGUoZWNNb2RlbCwgYXBpKSB7XG4gIHZhciBzaW5nbGVzID0gW107XG4gIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnc2luZ2xlQXhpcycsIGZ1bmN0aW9uIChheGlzTW9kZWwsIGlkeCkge1xuICAgIHZhciBzaW5nbGUgPSBuZXcgU2luZ2xlKGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICBzaW5nbGUubmFtZSA9ICdzaW5nbGVfJyArIGlkeDtcbiAgICBzaW5nbGUucmVzaXplKGF4aXNNb2RlbCwgYXBpKTtcbiAgICBheGlzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9IHNpbmdsZTtcbiAgICBzaW5nbGVzLnB1c2goc2luZ2xlKTtcbiAgfSk7XG4gIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICBpZiAoc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJykgPT09ICdzaW5nbGVBeGlzJykge1xuICAgICAgdmFyIHNpbmdsZUF4aXNNb2RlbCA9IHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3NpbmdsZUF4aXMnLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG4gICAgICBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gc2luZ2xlQXhpc01vZGVsICYmIHNpbmdsZUF4aXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzaW5nbGVzO1xufVxuXG52YXIgc2luZ2xlQ3JlYXRvciA9IHtcbiAgY3JlYXRlOiBjcmVhdGUsXG4gIGRpbWVuc2lvbnM6IFNpbmdsZS5wcm90b3R5cGUuZGltZW5zaW9uc1xufTtcbmV4cG9ydCBkZWZhdWx0IHNpbmdsZUNyZWF0b3I7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmV4cG9ydCB7IGluc3RhbGwgYXMgR3JpZFNpbXBsZUNvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudC9ncmlkL2luc3RhbGxTaW1wbGUnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBHcmlkQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50L2dyaWQvaW5zdGFsbCc7XG5leHBvcnQgeyBpbnN0YWxsIGFzIFBvbGFyQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50L3BvbGFyL2luc3RhbGwnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBSYWRhckNvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudC9yYWRhci9pbnN0YWxsJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgR2VvQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50L2dlby9pbnN0YWxsJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgU2luZ2xlQXhpc0NvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudC9zaW5nbGVBeGlzL2luc3RhbGwnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBQYXJhbGxlbENvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudC9wYXJhbGxlbC9pbnN0YWxsJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgQ2FsZW5kYXJDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnQvY2FsZW5kYXIvaW5zdGFsbCc7XG5leHBvcnQgeyBpbnN0YWxsIGFzIEdyYXBoaWNDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnQvZ3JhcGhpYy9pbnN0YWxsJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgVG9vbGJveENvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudC90b29sYm94L2luc3RhbGwnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBUb29sdGlwQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50L3Rvb2x0aXAvaW5zdGFsbCc7XG5leHBvcnQgeyBpbnN0YWxsIGFzIEF4aXNQb2ludGVyQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50L2F4aXNQb2ludGVyL2luc3RhbGwnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBCcnVzaENvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudC9icnVzaC9pbnN0YWxsJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgVGl0bGVDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnQvdGl0bGUvaW5zdGFsbCc7XG5leHBvcnQgeyBpbnN0YWxsIGFzIFRpbWVsaW5lQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50L3RpbWVsaW5lL2luc3RhbGwnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBNYXJrUG9pbnRDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnQvbWFya2VyL2luc3RhbGxNYXJrUG9pbnQnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBNYXJrTGluZUNvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudC9tYXJrZXIvaW5zdGFsbE1hcmtMaW5lJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgTWFya0FyZWFDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnQvbWFya2VyL2luc3RhbGxNYXJrQXJlYSc7XG5leHBvcnQgeyBpbnN0YWxsIGFzIExlZ2VuZENvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudC9sZWdlbmQvaW5zdGFsbCc7XG5leHBvcnQgeyBpbnN0YWxsIGFzIExlZ2VuZFNjcm9sbENvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudC9sZWdlbmQvaW5zdGFsbExlZ2VuZFNjcm9sbCc7XG5leHBvcnQgeyBpbnN0YWxsIGFzIExlZ2VuZFBsYWluQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50L2xlZ2VuZC9pbnN0YWxsTGVnZW5kUGxhaW4nO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBEYXRhWm9vbUNvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudC9kYXRhWm9vbS9pbnN0YWxsJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgRGF0YVpvb21JbnNpZGVDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnQvZGF0YVpvb20vaW5zdGFsbERhdGFab29tSW5zaWRlJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgRGF0YVpvb21TbGlkZXJDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnQvZGF0YVpvb20vaW5zdGFsbERhdGFab29tU2xpZGVyJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgVmlzdWFsTWFwQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50L3Zpc3VhbE1hcC9pbnN0YWxsJztcbmV4cG9ydCB7IGluc3RhbGwgYXMgVmlzdWFsTWFwQ29udGludW91c0NvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudC92aXN1YWxNYXAvaW5zdGFsbFZpc3VhbE1hcENvbnRpbnVvdXMnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBWaXN1YWxNYXBQaWVjZXdpc2VDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnQvdmlzdWFsTWFwL2luc3RhbGxWaXN1YWxNYXBQaWVjZXdpc2UnO1xuZXhwb3J0IHsgaW5zdGFsbCBhcyBBcmlhQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50L2FyaWEvaW5zdGFsbCc7XG5leHBvcnQgeyBpbnN0YWxsIGFzIFRyYW5zZm9ybUNvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudC90cmFuc2Zvcm0vaW5zdGFsbCc7XG5leHBvcnQgeyBpbnN0YWxsIGFzIERhdGFzZXRDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnQvZGF0YXNldC9pbnN0YWxsJzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBwYXJzZVBlcmNlbnQgfSBmcm9tICcuLi91dGlsL251bWJlcic7XG5pbXBvcnQgeyBpc0RpbWVuc2lvblN0YWNrZWQgfSBmcm9tICcuLi9kYXRhL2hlbHBlci9kYXRhU3RhY2tIZWxwZXInO1xuXG5mdW5jdGlvbiBnZXRTZXJpZXNTdGFja0lkKHNlcmllc01vZGVsKSB7XG4gIHJldHVybiBzZXJpZXNNb2RlbC5nZXQoJ3N0YWNrJykgfHwgJ19fZWNfc3RhY2tfJyArIHNlcmllc01vZGVsLnNlcmllc0luZGV4O1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzS2V5KHBvbGFyLCBheGlzKSB7XG4gIHJldHVybiBheGlzLmRpbSArIHBvbGFyLm1vZGVsLmNvbXBvbmVudEluZGV4O1xufVxuXG5mdW5jdGlvbiBiYXJMYXlvdXRQb2xhcihzZXJpZXNUeXBlLCBlY01vZGVsLCBhcGkpIHtcbiAgdmFyIGxhc3RTdGFja0Nvb3JkcyA9IHt9O1xuICB2YXIgYmFyV2lkdGhBbmRPZmZzZXQgPSBjYWxSYWRpYWxCYXIoenJVdGlsLmZpbHRlcihlY01vZGVsLmdldFNlcmllc0J5VHlwZShzZXJpZXNUeXBlKSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgcmV0dXJuICFlY01vZGVsLmlzU2VyaWVzRmlsdGVyZWQoc2VyaWVzTW9kZWwpICYmIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gJiYgc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS50eXBlID09PSAncG9sYXInO1xuICB9KSk7XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAvLyBDaGVjayBzZXJpZXMgY29vcmRpbmF0ZSwgZG8gbGF5b3V0IGZvciBwb2xhciBvbmx5XG4gICAgaWYgKHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0udHlwZSAhPT0gJ3BvbGFyJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBwb2xhciA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGJhc2VBeGlzID0gcG9sYXIuZ2V0QmFzZUF4aXMoKTtcbiAgICB2YXIgYXhpc0tleSA9IGdldEF4aXNLZXkocG9sYXIsIGJhc2VBeGlzKTtcbiAgICB2YXIgc3RhY2tJZCA9IGdldFNlcmllc1N0YWNrSWQoc2VyaWVzTW9kZWwpO1xuICAgIHZhciBjb2x1bW5MYXlvdXRJbmZvID0gYmFyV2lkdGhBbmRPZmZzZXRbYXhpc0tleV1bc3RhY2tJZF07XG4gICAgdmFyIGNvbHVtbk9mZnNldCA9IGNvbHVtbkxheW91dEluZm8ub2Zmc2V0O1xuICAgIHZhciBjb2x1bW5XaWR0aCA9IGNvbHVtbkxheW91dEluZm8ud2lkdGg7XG4gICAgdmFyIHZhbHVlQXhpcyA9IHBvbGFyLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gICAgdmFyIGN4ID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5jeDtcbiAgICB2YXIgY3kgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtLmN5O1xuICAgIHZhciBiYXJNaW5IZWlnaHQgPSBzZXJpZXNNb2RlbC5nZXQoJ2Jhck1pbkhlaWdodCcpIHx8IDA7XG4gICAgdmFyIGJhck1pbkFuZ2xlID0gc2VyaWVzTW9kZWwuZ2V0KCdiYXJNaW5BbmdsZScpIHx8IDA7XG4gICAgbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdID0gbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdIHx8IFtdO1xuICAgIHZhciB2YWx1ZURpbSA9IGRhdGEubWFwRGltZW5zaW9uKHZhbHVlQXhpcy5kaW0pO1xuICAgIHZhciBiYXNlRGltID0gZGF0YS5tYXBEaW1lbnNpb24oYmFzZUF4aXMuZGltKTtcbiAgICB2YXIgc3RhY2tlZCA9IGlzRGltZW5zaW9uU3RhY2tlZChkYXRhLCB2YWx1ZURpbVxuICAgIC8qLCBiYXNlRGltKi9cbiAgICApO1xuICAgIHZhciBjbGFtcExheW91dCA9IGJhc2VBeGlzLmRpbSAhPT0gJ3JhZGl1cycgfHwgIXNlcmllc01vZGVsLmdldCgncm91bmRDYXAnLCB0cnVlKTtcbiAgICB2YXIgdmFsdWVBeGlzU3RhcnQgPSB2YWx1ZUF4aXMuZGF0YVRvQ29vcmQoMCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwLCBsZW4gPSBkYXRhLmNvdW50KCk7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGRhdGEuZ2V0KHZhbHVlRGltLCBpZHgpO1xuICAgICAgdmFyIGJhc2VWYWx1ZSA9IGRhdGEuZ2V0KGJhc2VEaW0sIGlkeCk7XG4gICAgICB2YXIgc2lnbiA9IHZhbHVlID49IDAgPyAncCcgOiAnbic7XG4gICAgICB2YXIgYmFzZUNvb3JkID0gdmFsdWVBeGlzU3RhcnQ7IC8vIEJlY2F1c2Ugb2YgdGhlIGJhck1pbkhlaWdodCwgd2UgY2FuIG5vdCB1c2UgdGhlIHZhbHVlIGluXG4gICAgICAvLyBzdGFja1Jlc3VsdERpbWVuc2lvbiBkaXJlY3RseS5cbiAgICAgIC8vIE9ubHkgb3JkaW5hbCBheGlzIGNhbiBiZSBzdGFja2VkLlxuXG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICBpZiAoIWxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtiYXNlVmFsdWVdKSB7XG4gICAgICAgICAgbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2Jhc2VWYWx1ZV0gPSB7XG4gICAgICAgICAgICBwOiB2YWx1ZUF4aXNTdGFydCxcbiAgICAgICAgICAgIG46IHZhbHVlQXhpc1N0YXJ0IC8vIE5lZ2F0aXZlIHN0YWNrXG5cbiAgICAgICAgICB9O1xuICAgICAgICB9IC8vIFNob3VsZCBhbHNvIGNvbnNpZGVyICM0MjQzXG5cblxuICAgICAgICBiYXNlQ29vcmQgPSBsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF1bYmFzZVZhbHVlXVtzaWduXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIwID0gdm9pZCAwO1xuICAgICAgdmFyIHIgPSB2b2lkIDA7XG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IHZvaWQgMDtcbiAgICAgIHZhciBlbmRBbmdsZSA9IHZvaWQgMDsgLy8gcmFkaWFsIHNlY3RvclxuXG4gICAgICBpZiAodmFsdWVBeGlzLmRpbSA9PT0gJ3JhZGl1cycpIHtcbiAgICAgICAgdmFyIHJhZGl1c1NwYW4gPSB2YWx1ZUF4aXMuZGF0YVRvQ29vcmQodmFsdWUpIC0gdmFsdWVBeGlzU3RhcnQ7XG4gICAgICAgIHZhciBhbmdsZSA9IGJhc2VBeGlzLmRhdGFUb0Nvb3JkKGJhc2VWYWx1ZSk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHJhZGl1c1NwYW4pIDwgYmFyTWluSGVpZ2h0KSB7XG4gICAgICAgICAgcmFkaXVzU3BhbiA9IChyYWRpdXNTcGFuIDwgMCA/IC0xIDogMSkgKiBiYXJNaW5IZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICByMCA9IGJhc2VDb29yZDtcbiAgICAgICAgciA9IGJhc2VDb29yZCArIHJhZGl1c1NwYW47XG4gICAgICAgIHN0YXJ0QW5nbGUgPSBhbmdsZSAtIGNvbHVtbk9mZnNldDtcbiAgICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlIC0gY29sdW1uV2lkdGg7XG4gICAgICAgIHN0YWNrZWQgJiYgKGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtiYXNlVmFsdWVdW3NpZ25dID0gcik7XG4gICAgICB9IC8vIHRhbmdlbnRpYWwgc2VjdG9yXG4gICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYW5nbGVTcGFuID0gdmFsdWVBeGlzLmRhdGFUb0Nvb3JkKHZhbHVlLCBjbGFtcExheW91dCkgLSB2YWx1ZUF4aXNTdGFydDtcbiAgICAgICAgICB2YXIgcmFkaXVzID0gYmFzZUF4aXMuZGF0YVRvQ29vcmQoYmFzZVZhbHVlKTtcblxuICAgICAgICAgIGlmIChNYXRoLmFicyhhbmdsZVNwYW4pIDwgYmFyTWluQW5nbGUpIHtcbiAgICAgICAgICAgIGFuZ2xlU3BhbiA9IChhbmdsZVNwYW4gPCAwID8gLTEgOiAxKSAqIGJhck1pbkFuZ2xlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIwID0gcmFkaXVzICsgY29sdW1uT2Zmc2V0O1xuICAgICAgICAgIHIgPSByMCArIGNvbHVtbldpZHRoO1xuICAgICAgICAgIHN0YXJ0QW5nbGUgPSBiYXNlQ29vcmQ7XG4gICAgICAgICAgZW5kQW5nbGUgPSBiYXNlQ29vcmQgKyBhbmdsZVNwYW47IC8vIGlmIHRoZSBwcmV2aW91cyBzdGFjayBpcyBhdCB0aGUgZW5kIG9mIHRoZSByaW5nLFxuICAgICAgICAgIC8vIGFkZCBhIHJvdW5kIHRvIGRpZmZlcmVudGlhdGUgaXQgZnJvbSBvcmlnaW5cbiAgICAgICAgICAvLyBsZXQgZXh0ZW50ID0gYW5nbGVBeGlzLmdldEV4dGVudCgpO1xuICAgICAgICAgIC8vIGxldCBzdGFja0Nvb3JkID0gYW5nbGU7XG4gICAgICAgICAgLy8gaWYgKHN0YWNrQ29vcmQgPT09IGV4dGVudFswXSAmJiB2YWx1ZSA+IDApIHtcbiAgICAgICAgICAvLyAgICAgc3RhY2tDb29yZCA9IGV4dGVudFsxXTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgICAgLy8gZWxzZSBpZiAoc3RhY2tDb29yZCA9PT0gZXh0ZW50WzFdICYmIHZhbHVlIDwgMCkge1xuICAgICAgICAgIC8vICAgICBzdGFja0Nvb3JkID0gZXh0ZW50WzBdO1xuICAgICAgICAgIC8vIH1cblxuICAgICAgICAgIHN0YWNrZWQgJiYgKGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtiYXNlVmFsdWVdW3NpZ25dID0gZW5kQW5nbGUpO1xuICAgICAgICB9XG5cbiAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHtcbiAgICAgICAgY3g6IGN4LFxuICAgICAgICBjeTogY3ksXG4gICAgICAgIHIwOiByMCxcbiAgICAgICAgcjogcixcbiAgICAgICAgLy8gQ29uc2lkZXIgdGhhdCBwb3NpdGl2ZSBhbmdsZSBpcyBhbnRpLWNsb2Nrd2lzZSxcbiAgICAgICAgLy8gd2hpbGUgcG9zaXRpdmUgcmFkaWFuIG9mIHNlY3RvciBpcyBjbG9ja3dpc2VcbiAgICAgICAgc3RhcnRBbmdsZTogLXN0YXJ0QW5nbGUgKiBNYXRoLlBJIC8gMTgwLFxuICAgICAgICBlbmRBbmdsZTogLWVuZEFuZ2xlICogTWF0aC5QSSAvIDE4MFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGJhciB3aWR0aCBhbmQgb2Zmc2V0IGZvciByYWRpYWwgYmFyIGNoYXJ0c1xuICovXG5cblxuZnVuY3Rpb24gY2FsUmFkaWFsQmFyKGJhclNlcmllcykge1xuICAvLyBDb2x1bW5zIGluZm8gb24gZWFjaCBjYXRlZ29yeSBheGlzLiBLZXkgaXMgcG9sYXIgbmFtZVxuICB2YXIgY29sdW1uc01hcCA9IHt9O1xuICB6clV0aWwuZWFjaChiYXJTZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgaWR4KSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHBvbGFyID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgYmFzZUF4aXMgPSBwb2xhci5nZXRCYXNlQXhpcygpO1xuICAgIHZhciBheGlzS2V5ID0gZ2V0QXhpc0tleShwb2xhciwgYmFzZUF4aXMpO1xuICAgIHZhciBheGlzRXh0ZW50ID0gYmFzZUF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIGJhbmRXaWR0aCA9IGJhc2VBeGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyBiYXNlQXhpcy5nZXRCYW5kV2lkdGgoKSA6IE1hdGguYWJzKGF4aXNFeHRlbnRbMV0gLSBheGlzRXh0ZW50WzBdKSAvIGRhdGEuY291bnQoKTtcbiAgICB2YXIgY29sdW1uc09uQXhpcyA9IGNvbHVtbnNNYXBbYXhpc0tleV0gfHwge1xuICAgICAgYmFuZFdpZHRoOiBiYW5kV2lkdGgsXG4gICAgICByZW1haW5lZFdpZHRoOiBiYW5kV2lkdGgsXG4gICAgICBhdXRvV2lkdGhDb3VudDogMCxcbiAgICAgIGNhdGVnb3J5R2FwOiAnMjAlJyxcbiAgICAgIGdhcDogJzMwJScsXG4gICAgICBzdGFja3M6IHt9XG4gICAgfTtcbiAgICB2YXIgc3RhY2tzID0gY29sdW1uc09uQXhpcy5zdGFja3M7XG4gICAgY29sdW1uc01hcFtheGlzS2V5XSA9IGNvbHVtbnNPbkF4aXM7XG4gICAgdmFyIHN0YWNrSWQgPSBnZXRTZXJpZXNTdGFja0lkKHNlcmllc01vZGVsKTtcblxuICAgIGlmICghc3RhY2tzW3N0YWNrSWRdKSB7XG4gICAgICBjb2x1bW5zT25BeGlzLmF1dG9XaWR0aENvdW50Kys7XG4gICAgfVxuXG4gICAgc3RhY2tzW3N0YWNrSWRdID0gc3RhY2tzW3N0YWNrSWRdIHx8IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgbWF4V2lkdGg6IDBcbiAgICB9O1xuICAgIHZhciBiYXJXaWR0aCA9IHBhcnNlUGVyY2VudChzZXJpZXNNb2RlbC5nZXQoJ2JhcldpZHRoJyksIGJhbmRXaWR0aCk7XG4gICAgdmFyIGJhck1heFdpZHRoID0gcGFyc2VQZXJjZW50KHNlcmllc01vZGVsLmdldCgnYmFyTWF4V2lkdGgnKSwgYmFuZFdpZHRoKTtcbiAgICB2YXIgYmFyR2FwID0gc2VyaWVzTW9kZWwuZ2V0KCdiYXJHYXAnKTtcbiAgICB2YXIgYmFyQ2F0ZWdvcnlHYXAgPSBzZXJpZXNNb2RlbC5nZXQoJ2JhckNhdGVnb3J5R2FwJyk7XG5cbiAgICBpZiAoYmFyV2lkdGggJiYgIXN0YWNrc1tzdGFja0lkXS53aWR0aCkge1xuICAgICAgYmFyV2lkdGggPSBNYXRoLm1pbihjb2x1bW5zT25BeGlzLnJlbWFpbmVkV2lkdGgsIGJhcldpZHRoKTtcbiAgICAgIHN0YWNrc1tzdGFja0lkXS53aWR0aCA9IGJhcldpZHRoO1xuICAgICAgY29sdW1uc09uQXhpcy5yZW1haW5lZFdpZHRoIC09IGJhcldpZHRoO1xuICAgIH1cblxuICAgIGJhck1heFdpZHRoICYmIChzdGFja3Nbc3RhY2tJZF0ubWF4V2lkdGggPSBiYXJNYXhXaWR0aCk7XG4gICAgYmFyR2FwICE9IG51bGwgJiYgKGNvbHVtbnNPbkF4aXMuZ2FwID0gYmFyR2FwKTtcbiAgICBiYXJDYXRlZ29yeUdhcCAhPSBudWxsICYmIChjb2x1bW5zT25BeGlzLmNhdGVnb3J5R2FwID0gYmFyQ2F0ZWdvcnlHYXApO1xuICB9KTtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB6clV0aWwuZWFjaChjb2x1bW5zTWFwLCBmdW5jdGlvbiAoY29sdW1uc09uQXhpcywgY29vcmRTeXNOYW1lKSB7XG4gICAgcmVzdWx0W2Nvb3JkU3lzTmFtZV0gPSB7fTtcbiAgICB2YXIgc3RhY2tzID0gY29sdW1uc09uQXhpcy5zdGFja3M7XG4gICAgdmFyIGJhbmRXaWR0aCA9IGNvbHVtbnNPbkF4aXMuYmFuZFdpZHRoO1xuICAgIHZhciBjYXRlZ29yeUdhcCA9IHBhcnNlUGVyY2VudChjb2x1bW5zT25BeGlzLmNhdGVnb3J5R2FwLCBiYW5kV2lkdGgpO1xuICAgIHZhciBiYXJHYXBQZXJjZW50ID0gcGFyc2VQZXJjZW50KGNvbHVtbnNPbkF4aXMuZ2FwLCAxKTtcbiAgICB2YXIgcmVtYWluZWRXaWR0aCA9IGNvbHVtbnNPbkF4aXMucmVtYWluZWRXaWR0aDtcbiAgICB2YXIgYXV0b1dpZHRoQ291bnQgPSBjb2x1bW5zT25BeGlzLmF1dG9XaWR0aENvdW50O1xuICAgIHZhciBhdXRvV2lkdGggPSAocmVtYWluZWRXaWR0aCAtIGNhdGVnb3J5R2FwKSAvIChhdXRvV2lkdGhDb3VudCArIChhdXRvV2lkdGhDb3VudCAtIDEpICogYmFyR2FwUGVyY2VudCk7XG4gICAgYXV0b1dpZHRoID0gTWF0aC5tYXgoYXV0b1dpZHRoLCAwKTsgLy8gRmluZCBpZiBhbnkgYXV0byBjYWxjdWxhdGVkIGJhciBleGNlZWRlZCBtYXhCYXJXaWR0aFxuXG4gICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBzdGFjaykge1xuICAgICAgdmFyIG1heFdpZHRoID0gY29sdW1uLm1heFdpZHRoO1xuXG4gICAgICBpZiAobWF4V2lkdGggJiYgbWF4V2lkdGggPCBhdXRvV2lkdGgpIHtcbiAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbihtYXhXaWR0aCwgcmVtYWluZWRXaWR0aCk7XG5cbiAgICAgICAgaWYgKGNvbHVtbi53aWR0aCkge1xuICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5taW4obWF4V2lkdGgsIGNvbHVtbi53aWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZW1haW5lZFdpZHRoIC09IG1heFdpZHRoO1xuICAgICAgICBjb2x1bW4ud2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgYXV0b1dpZHRoQ291bnQtLTtcbiAgICAgIH1cbiAgICB9KTsgLy8gUmVjYWxjdWxhdGUgd2lkdGggYWdhaW5cblxuICAgIGF1dG9XaWR0aCA9IChyZW1haW5lZFdpZHRoIC0gY2F0ZWdvcnlHYXApIC8gKGF1dG9XaWR0aENvdW50ICsgKGF1dG9XaWR0aENvdW50IC0gMSkgKiBiYXJHYXBQZXJjZW50KTtcbiAgICBhdXRvV2lkdGggPSBNYXRoLm1heChhdXRvV2lkdGgsIDApO1xuICAgIHZhciB3aWR0aFN1bSA9IDA7XG4gICAgdmFyIGxhc3RDb2x1bW47XG4gICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBpZHgpIHtcbiAgICAgIGlmICghY29sdW1uLndpZHRoKSB7XG4gICAgICAgIGNvbHVtbi53aWR0aCA9IGF1dG9XaWR0aDtcbiAgICAgIH1cblxuICAgICAgbGFzdENvbHVtbiA9IGNvbHVtbjtcbiAgICAgIHdpZHRoU3VtICs9IGNvbHVtbi53aWR0aCAqICgxICsgYmFyR2FwUGVyY2VudCk7XG4gICAgfSk7XG5cbiAgICBpZiAobGFzdENvbHVtbikge1xuICAgICAgd2lkdGhTdW0gLT0gbGFzdENvbHVtbi53aWR0aCAqIGJhckdhcFBlcmNlbnQ7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldCA9IC13aWR0aFN1bSAvIDI7XG4gICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBzdGFja0lkKSB7XG4gICAgICByZXN1bHRbY29vcmRTeXNOYW1lXVtzdGFja0lkXSA9IHJlc3VsdFtjb29yZFN5c05hbWVdW3N0YWNrSWRdIHx8IHtcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHdpZHRoOiBjb2x1bW4ud2lkdGhcbiAgICAgIH07XG4gICAgICBvZmZzZXQgKz0gY29sdW1uLndpZHRoICogKDEgKyBiYXJHYXBQZXJjZW50KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhckxheW91dFBvbGFyOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBrZXlzLCBpc0FycmF5LCBtYXAsIGlzT2JqZWN0LCBpc1N0cmluZywgaXNSZWdFeHAsIGlzQXJyYXlMaWtlLCBoYXNPd24gfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgdGhyb3dFcnJvciwgbWFrZVByaW50YWJsZSB9IGZyb20gJy4vbG9nJztcbmltcG9ydCB7IGdldFJhd1ZhbHVlUGFyc2VyLCBjcmVhdGVGaWx0ZXJDb21wYXJhdG9yIH0gZnJvbSAnLi4vZGF0YS9oZWxwZXIvZGF0YVZhbHVlSGVscGVyJztcbjtcbnZhciBSRUxBVElPTkFMX0VYUFJFU1NJT05fT1BfQUxJQVNfTUFQID0ge1xuICB2YWx1ZTogJ2VxJyxcbiAgLy8gUEVORElORzogbm90IGdvb2QgZm9yIGxpdGVyYWwgc2VtYW50aWM/XG4gICc8JzogJ2x0JyxcbiAgJzw9JzogJ2x0ZScsXG4gICc+JzogJ2d0JyxcbiAgJz49JzogJ2d0ZScsXG4gICc9JzogJ2VxJyxcbiAgJyE9JzogJ25lJyxcbiAgJzw+JzogJ25lJyAvLyBNaWdodCBtaWxlYWRpbmcgZm9yIHNha2Ugb2YgdGhlIGRpZmZlcmVudCBiZXR3ZWVuICc9PScgYW5kICc9PT0nLFxuICAvLyBTbyBkb250IHN1cHBvcnQgdGhlbS5cbiAgLy8gJz09JzogJ2VxJyxcbiAgLy8gJz09PSc6ICdzZXEnLFxuICAvLyAnIT09JzogJ3NuZSdcbiAgLy8gUEVORElORzogV2hldGhlciBzdXBwb3J0IHNvbWUgY29tbW9uIGFsaWFzIFwiZ2VcIiwgXCJsZVwiLCBcIm5lcVwiP1xuICAvLyBnZTogJ2d0ZScsXG4gIC8vIGxlOiAnbHRlJyxcbiAgLy8gbmVxOiAnbmUnLFxuXG59O1xuXG52YXIgUmVnRXhwRXZhbHVhdG9yID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVnRXhwRXZhbHVhdG9yKHJWYWwpIHtcbiAgICAvLyBTdXBwb3J0IGNvbmRWYWw6IFJlZ0V4cCB8IHN0cmluZ1xuICAgIHZhciBjb25kVmFsdWUgPSB0aGlzLl9jb25kVmFsID0gaXNTdHJpbmcoclZhbCkgPyBuZXcgUmVnRXhwKHJWYWwpIDogaXNSZWdFeHAoclZhbCkgPyByVmFsIDogbnVsbDtcblxuICAgIGlmIChjb25kVmFsdWUgPT0gbnVsbCkge1xuICAgICAgdmFyIGVyck1zZyA9ICcnO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBlcnJNc2cgPSBtYWtlUHJpbnRhYmxlKCdJbGxlZ2FsIHJlZ2V4cCcsIHJWYWwsICdpbicpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gICAgfVxuICB9XG5cbiAgUmVnRXhwRXZhbHVhdG9yLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIChsVmFsKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgbFZhbDtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3N0cmluZycgPyB0aGlzLl9jb25kVmFsLnRlc3QobFZhbCkgOiB0eXBlID09PSAnbnVtYmVyJyA/IHRoaXMuX2NvbmRWYWwudGVzdChsVmFsICsgJycpIDogZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIFJlZ0V4cEV2YWx1YXRvcjtcbn0oKTtcblxudmFyIENvbnN0Q29uZGl0aW9uSW50ZXJuYWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb25zdENvbmRpdGlvbkludGVybmFsKCkge31cblxuICBDb25zdENvbmRpdGlvbkludGVybmFsLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfTtcblxuICByZXR1cm4gQ29uc3RDb25kaXRpb25JbnRlcm5hbDtcbn0oKTtcblxudmFyIEFuZENvbmRpdGlvbkludGVybmFsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5kQ29uZGl0aW9uSW50ZXJuYWwoKSB7fVxuXG4gIEFuZENvbmRpdGlvbkludGVybmFsLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFjaGlsZHJlbltpXS5ldmFsdWF0ZSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICByZXR1cm4gQW5kQ29uZGl0aW9uSW50ZXJuYWw7XG59KCk7XG5cbnZhciBPckNvbmRpdGlvbkludGVybmFsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT3JDb25kaXRpb25JbnRlcm5hbCgpIHt9XG5cbiAgT3JDb25kaXRpb25JbnRlcm5hbC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjaGlsZHJlbltpXS5ldmFsdWF0ZSgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICByZXR1cm4gT3JDb25kaXRpb25JbnRlcm5hbDtcbn0oKTtcblxudmFyIE5vdENvbmRpdGlvbkludGVybmFsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm90Q29uZGl0aW9uSW50ZXJuYWwoKSB7fVxuXG4gIE5vdENvbmRpdGlvbkludGVybmFsLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXRoaXMuY2hpbGQuZXZhbHVhdGUoKTtcbiAgfTtcblxuICByZXR1cm4gTm90Q29uZGl0aW9uSW50ZXJuYWw7XG59KCk7XG5cbnZhciBSZWxhdGlvbmFsQ29uZGl0aW9uSW50ZXJuYWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWxhdGlvbmFsQ29uZGl0aW9uSW50ZXJuYWwoKSB7fVxuXG4gIFJlbGF0aW9uYWxDb25kaXRpb25JbnRlcm5hbC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5lZWRQYXJzZSA9ICEhdGhpcy52YWx1ZVBhcnNlcjsgLy8gQ2FsbCBnZXRWYWx1ZSB3aXRoIG5vIGB0aGlzYC5cblxuICAgIHZhciBnZXRWYWx1ZSA9IHRoaXMuZ2V0VmFsdWU7XG4gICAgdmFyIHRhclZhbFJhdyA9IGdldFZhbHVlKHRoaXMudmFsdWVHZXR0ZXJQYXJhbSk7XG4gICAgdmFyIHRhclZhbFBhcnNlZCA9IG5lZWRQYXJzZSA/IHRoaXMudmFsdWVQYXJzZXIodGFyVmFsUmF3KSA6IG51bGw7IC8vIFJlbGF0aW9uYWwgY29uZCBmb2xsb3cgXCJhbmRcIiBsb2dpYyBpbnRlcm5hbGx5LlxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YkNvbmRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuc3ViQ29uZExpc3RbaV0uZXZhbHVhdGUobmVlZFBhcnNlID8gdGFyVmFsUGFyc2VkIDogdGFyVmFsUmF3KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcmV0dXJuIFJlbGF0aW9uYWxDb25kaXRpb25JbnRlcm5hbDtcbn0oKTtcblxuZnVuY3Rpb24gcGFyc2VPcHRpb24oZXhwck9wdGlvbiwgZ2V0dGVycykge1xuICBpZiAoZXhwck9wdGlvbiA9PT0gdHJ1ZSB8fCBleHByT3B0aW9uID09PSBmYWxzZSkge1xuICAgIHZhciBjb25kID0gbmV3IENvbnN0Q29uZGl0aW9uSW50ZXJuYWwoKTtcbiAgICBjb25kLnZhbHVlID0gZXhwck9wdGlvbjtcbiAgICByZXR1cm4gY29uZDtcbiAgfVxuXG4gIHZhciBlcnJNc2cgPSAnJztcblxuICBpZiAoIWlzT2JqZWN0Tm90QXJyYXkoZXhwck9wdGlvbikpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZXJyTXNnID0gbWFrZVByaW50YWJsZSgnSWxsZWdhbCBjb25maWcuIEV4cGVjdCBhIHBsYWluIG9iamVjdCBidXQgYWN0dWFsbHknLCBleHByT3B0aW9uKTtcbiAgICB9XG5cbiAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gIH1cblxuICBpZiAoZXhwck9wdGlvbi5hbmQpIHtcbiAgICByZXR1cm4gcGFyc2VBbmRPck9wdGlvbignYW5kJywgZXhwck9wdGlvbiwgZ2V0dGVycyk7XG4gIH0gZWxzZSBpZiAoZXhwck9wdGlvbi5vcikge1xuICAgIHJldHVybiBwYXJzZUFuZE9yT3B0aW9uKCdvcicsIGV4cHJPcHRpb24sIGdldHRlcnMpO1xuICB9IGVsc2UgaWYgKGV4cHJPcHRpb24ubm90KSB7XG4gICAgcmV0dXJuIHBhcnNlTm90T3B0aW9uKGV4cHJPcHRpb24sIGdldHRlcnMpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlUmVsYXRpb25hbE9wdGlvbihleHByT3B0aW9uLCBnZXR0ZXJzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VBbmRPck9wdGlvbihvcCwgZXhwck9wdGlvbiwgZ2V0dGVycykge1xuICB2YXIgc3ViT3B0aW9uQXJyID0gZXhwck9wdGlvbltvcF07XG4gIHZhciBlcnJNc2cgPSAnJztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGVyck1zZyA9IG1ha2VQcmludGFibGUoJ1wiYW5kXCIvXCJvclwiIGNvbmRpdGlvbiBzaG91bGQgb25seSBiZSBgJyArIG9wICsgJzogWy4uLl1gIGFuZCBtdXN0IG5vdCBiZSBlbXB0eSBhcnJheS4nLCAnSWxsZWdhbCBjb25kaXRpb246JywgZXhwck9wdGlvbik7XG4gIH1cblxuICBpZiAoIWlzQXJyYXkoc3ViT3B0aW9uQXJyKSkge1xuICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgfVxuXG4gIGlmICghc3ViT3B0aW9uQXJyLmxlbmd0aCkge1xuICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgfVxuXG4gIHZhciBjb25kID0gb3AgPT09ICdhbmQnID8gbmV3IEFuZENvbmRpdGlvbkludGVybmFsKCkgOiBuZXcgT3JDb25kaXRpb25JbnRlcm5hbCgpO1xuICBjb25kLmNoaWxkcmVuID0gbWFwKHN1Yk9wdGlvbkFyciwgZnVuY3Rpb24gKHN1Yk9wdGlvbikge1xuICAgIHJldHVybiBwYXJzZU9wdGlvbihzdWJPcHRpb24sIGdldHRlcnMpO1xuICB9KTtcblxuICBpZiAoIWNvbmQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdGhyb3dFcnJvcihlcnJNc2cpO1xuICB9XG5cbiAgcmV0dXJuIGNvbmQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTm90T3B0aW9uKGV4cHJPcHRpb24sIGdldHRlcnMpIHtcbiAgdmFyIHN1Yk9wdGlvbiA9IGV4cHJPcHRpb24ubm90O1xuICB2YXIgZXJyTXNnID0gJyc7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBlcnJNc2cgPSBtYWtlUHJpbnRhYmxlKCdcIm5vdFwiIGNvbmRpdGlvbiBzaG91bGQgb25seSBiZSBgbm90OiB7fWAuJywgJ0lsbGVnYWwgY29uZGl0aW9uOicsIGV4cHJPcHRpb24pO1xuICB9XG5cbiAgaWYgKCFpc09iamVjdE5vdEFycmF5KHN1Yk9wdGlvbikpIHtcbiAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gIH1cblxuICB2YXIgY29uZCA9IG5ldyBOb3RDb25kaXRpb25JbnRlcm5hbCgpO1xuICBjb25kLmNoaWxkID0gcGFyc2VPcHRpb24oc3ViT3B0aW9uLCBnZXR0ZXJzKTtcblxuICBpZiAoIWNvbmQuY2hpbGQpIHtcbiAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gIH1cblxuICByZXR1cm4gY29uZDtcbn1cblxuZnVuY3Rpb24gcGFyc2VSZWxhdGlvbmFsT3B0aW9uKGV4cHJPcHRpb24sIGdldHRlcnMpIHtcbiAgdmFyIGVyck1zZyA9ICcnO1xuICB2YXIgdmFsdWVHZXR0ZXJQYXJhbSA9IGdldHRlcnMucHJlcGFyZUdldFZhbHVlKGV4cHJPcHRpb24pO1xuICB2YXIgc3ViQ29uZExpc3QgPSBbXTtcbiAgdmFyIGV4cHJLZXlzID0ga2V5cyhleHByT3B0aW9uKTtcbiAgdmFyIHBhcnNlck5hbWUgPSBleHByT3B0aW9uLnBhcnNlcjtcbiAgdmFyIHZhbHVlUGFyc2VyID0gcGFyc2VyTmFtZSA/IGdldFJhd1ZhbHVlUGFyc2VyKHBhcnNlck5hbWUpIDogbnVsbDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleVJhdyA9IGV4cHJLZXlzW2ldO1xuXG4gICAgaWYgKGtleVJhdyA9PT0gJ3BhcnNlcicgfHwgZ2V0dGVycy52YWx1ZUdldHRlckF0dHJNYXAuZ2V0KGtleVJhdykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBvcCA9IGhhc093bihSRUxBVElPTkFMX0VYUFJFU1NJT05fT1BfQUxJQVNfTUFQLCBrZXlSYXcpID8gUkVMQVRJT05BTF9FWFBSRVNTSU9OX09QX0FMSUFTX01BUFtrZXlSYXddIDoga2V5UmF3O1xuICAgIHZhciBjb25kVmFsdWVSYXcgPSBleHByT3B0aW9uW2tleVJhd107XG4gICAgdmFyIGNvbmRWYWx1ZVBhcnNlZCA9IHZhbHVlUGFyc2VyID8gdmFsdWVQYXJzZXIoY29uZFZhbHVlUmF3KSA6IGNvbmRWYWx1ZVJhdztcbiAgICB2YXIgZXZhbHVhdG9yID0gY3JlYXRlRmlsdGVyQ29tcGFyYXRvcihvcCwgY29uZFZhbHVlUGFyc2VkKSB8fCBvcCA9PT0gJ3JlZycgJiYgbmV3IFJlZ0V4cEV2YWx1YXRvcihjb25kVmFsdWVQYXJzZWQpO1xuXG4gICAgaWYgKCFldmFsdWF0b3IpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVyck1zZyA9IG1ha2VQcmludGFibGUoJ0lsbGVnYWwgcmVsYXRpb25hbCBvcGVyYXRpb246IFwiJyArIGtleVJhdyArICdcIiBpbiBjb25kaXRpb246JywgZXhwck9wdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgICB9XG5cbiAgICBzdWJDb25kTGlzdC5wdXNoKGV2YWx1YXRvcik7XG4gIH1cblxuICBpZiAoIXN1YkNvbmRMaXN0Lmxlbmd0aCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBlcnJNc2cgPSBtYWtlUHJpbnRhYmxlKCdSZWxhdGlvbmFsIGNvbmRpdGlvbiBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIG9wZXJhdG9yLicsICdJbGxlZ2FsIGNvbmRpdGlvbjonLCBleHByT3B0aW9uKTtcbiAgICB9IC8vIE5vIHJlbGF0aW9uYWwgb3BlcmF0b3IgYWx3YXlzIGRpc2FibGVkIGluIGNhc2Ugb2YgZGFuZ2VycyByZXN1bHQuXG5cblxuICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgfVxuXG4gIHZhciBjb25kID0gbmV3IFJlbGF0aW9uYWxDb25kaXRpb25JbnRlcm5hbCgpO1xuICBjb25kLnZhbHVlR2V0dGVyUGFyYW0gPSB2YWx1ZUdldHRlclBhcmFtO1xuICBjb25kLnZhbHVlUGFyc2VyID0gdmFsdWVQYXJzZXI7XG4gIGNvbmQuZ2V0VmFsdWUgPSBnZXR0ZXJzLmdldFZhbHVlO1xuICBjb25kLnN1YkNvbmRMaXN0ID0gc3ViQ29uZExpc3Q7XG4gIHJldHVybiBjb25kO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdE5vdEFycmF5KHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheUxpa2UodmFsKTtcbn1cblxudmFyIENvbmRpdGlvbmFsRXhwcmVzc2lvblBhcnNlZCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbmRpdGlvbmFsRXhwcmVzc2lvblBhcnNlZChleHByT3B0aW9uLCBnZXR0ZXJzKSB7XG4gICAgdGhpcy5fY29uZCA9IHBhcnNlT3B0aW9uKGV4cHJPcHRpb24sIGdldHRlcnMpO1xuICB9XG5cbiAgQ29uZGl0aW9uYWxFeHByZXNzaW9uUGFyc2VkLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZC5ldmFsdWF0ZSgpO1xuICB9O1xuXG4gIHJldHVybiBDb25kaXRpb25hbEV4cHJlc3Npb25QYXJzZWQ7XG59KCk7XG5cbjtcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbihleHByT3B0aW9uLCBnZXR0ZXJzKSB7XG4gIHJldHVybiBuZXcgQ29uZGl0aW9uYWxFeHByZXNzaW9uUGFyc2VkKGV4cHJPcHRpb24sIGdldHRlcnMpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCB7IHJldHJpZXZlUmF3VmFsdWUgfSBmcm9tICcuLi9kYXRhL2hlbHBlci9kYXRhUHJvdmlkZXInO1xuaW1wb3J0IHsgbWFrZUlubmVyIH0gZnJvbSAnLi4vdXRpbC9tb2RlbCc7XG5pbXBvcnQgeyBnZXREZWNhbEZyb21QYWxldHRlIH0gZnJvbSAnLi4vbW9kZWwvbWl4aW4vcGFsZXR0ZSc7XG52YXIgREVGQVVMVF9PUFRJT04gPSB7XG4gIGxhYmVsOiB7XG4gICAgZW5hYmxlZDogdHJ1ZVxuICB9LFxuICBkZWNhbDoge1xuICAgIHNob3c6IGZhbHNlXG4gIH1cbn07XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcbnZhciBkZWNhbFBhbGV0dGVTY29wZSA9IHt9O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXJpYVZpc3VhbChlY01vZGVsLCBhcGkpIHtcbiAgdmFyIGFyaWFNb2RlbCA9IGVjTW9kZWwuZ2V0TW9kZWwoJ2FyaWEnKTsgLy8gU2VlIFwiYXJlYSBlbmFibGVkXCIgZGV0ZWN0aW9uIGNvZGUgaW4gYEdsb2JhbE1vZGVsLnRzYC5cblxuICBpZiAoIWFyaWFNb2RlbC5nZXQoJ2VuYWJsZWQnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkZWZhdWx0T3B0aW9uID0genJVdGlsLmNsb25lKERFRkFVTFRfT1BUSU9OKTtcbiAgenJVdGlsLm1lcmdlKGRlZmF1bHRPcHRpb24ubGFiZWwsIGVjTW9kZWwuZ2V0TG9jYWxlTW9kZWwoKS5nZXQoJ2FyaWEnKSwgZmFsc2UpO1xuICB6clV0aWwubWVyZ2UoYXJpYU1vZGVsLm9wdGlvbiwgZGVmYXVsdE9wdGlvbiwgZmFsc2UpO1xuICBzZXREZWNhbCgpO1xuICBzZXRMYWJlbCgpO1xuXG4gIGZ1bmN0aW9uIHNldERlY2FsKCkge1xuICAgIHZhciBkZWNhbE1vZGVsID0gYXJpYU1vZGVsLmdldE1vZGVsKCdkZWNhbCcpO1xuICAgIHZhciB1c2VEZWNhbCA9IGRlY2FsTW9kZWwuZ2V0KCdzaG93Jyk7XG5cbiAgICBpZiAodXNlRGVjYWwpIHtcbiAgICAgIC8vIEVhY2ggdHlwZSBvZiBzZXJpZXMgdXNlIG9uZSBzY29wZS5cbiAgICAgIC8vIFBpZSBhbmQgZnVubmVsIGFyZSB1c2luZyBkaWZlcnJlbnQgc2NvcGVzXG4gICAgICB2YXIgcGFsZXR0ZVNjb3BlR3JvdXBCeVR5cGVfMSA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgIGlmICghc2VyaWVzTW9kZWwudXNlQ29sb3JQYWxldHRlT25EYXRhKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlY2FsU2NvcGUgPSBwYWxldHRlU2NvcGVHcm91cEJ5VHlwZV8xLmdldChzZXJpZXNNb2RlbC50eXBlKTtcblxuICAgICAgICBpZiAoIWRlY2FsU2NvcGUpIHtcbiAgICAgICAgICBkZWNhbFNjb3BlID0ge307XG4gICAgICAgICAgcGFsZXR0ZVNjb3BlR3JvdXBCeVR5cGVfMS5zZXQoc2VyaWVzTW9kZWwudHlwZSwgZGVjYWxTY29wZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbm5lcihzZXJpZXNNb2RlbCkuc2NvcGUgPSBkZWNhbFNjb3BlO1xuICAgICAgfSk7XG4gICAgICBlY01vZGVsLmVhY2hSYXdTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgIGlmIChlY01vZGVsLmlzU2VyaWVzRmlsdGVyZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZXJpZXNNb2RlbC5lbmFibGVBcmlhRGVjYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBMZXQgc2VyaWVzIGRlZmluZSBob3cgdG8gdXNlIGRlY2FsIHBhbGV0dGUgb24gZGF0YVxuICAgICAgICAgIHNlcmllc01vZGVsLmVuYWJsZUFyaWFEZWNhbCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgICAgIGlmIChzZXJpZXNNb2RlbC51c2VDb2xvclBhbGV0dGVPbkRhdGEpIHtcbiAgICAgICAgICB2YXIgZGF0YUFsbF8xID0gc2VyaWVzTW9kZWwuZ2V0UmF3RGF0YSgpO1xuICAgICAgICAgIHZhciBpZHhNYXBfMSA9IHt9O1xuICAgICAgICAgIHZhciBkZWNhbFNjb3BlXzEgPSBpbm5lcihzZXJpZXNNb2RlbCkuc2NvcGU7XG4gICAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgIHZhciByYXdJZHggPSBkYXRhLmdldFJhd0luZGV4KGlkeCk7XG4gICAgICAgICAgICBpZHhNYXBfMVtyYXdJZHhdID0gaWR4O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBkYXRhQ291bnRfMSA9IGRhdGFBbGxfMS5jb3VudCgpO1xuICAgICAgICAgIGRhdGFBbGxfMS5lYWNoKGZ1bmN0aW9uIChyYXdJZHgpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSBpZHhNYXBfMVtyYXdJZHhdO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBkYXRhQWxsXzEuZ2V0TmFtZShyYXdJZHgpIHx8IHJhd0lkeCArICcnO1xuICAgICAgICAgICAgdmFyIHBhbGV0dGVEZWNhbCA9IGdldERlY2FsRnJvbVBhbGV0dGUoc2VyaWVzTW9kZWwuZWNNb2RlbCwgbmFtZSwgZGVjYWxTY29wZV8xLCBkYXRhQ291bnRfMSk7XG4gICAgICAgICAgICB2YXIgc3BlY2lmaWVkRGVjYWwgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnZGVjYWwnKTtcbiAgICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdkZWNhbCcsIG1lcmdlRGVjYWwoc3BlY2lmaWVkRGVjYWwsIHBhbGV0dGVEZWNhbCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwYWxldHRlRGVjYWwgPSBnZXREZWNhbEZyb21QYWxldHRlKHNlcmllc01vZGVsLmVjTW9kZWwsIHNlcmllc01vZGVsLm5hbWUsIGRlY2FsUGFsZXR0ZVNjb3BlLCBlY01vZGVsLmdldFNlcmllc0NvdW50KCkpO1xuICAgICAgICAgIHZhciBzcGVjaWZpZWREZWNhbCA9IGRhdGEuZ2V0VmlzdWFsKCdkZWNhbCcpO1xuICAgICAgICAgIGRhdGEuc2V0VmlzdWFsKCdkZWNhbCcsIG1lcmdlRGVjYWwoc3BlY2lmaWVkRGVjYWwsIHBhbGV0dGVEZWNhbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VEZWNhbChzcGVjaWZpZWREZWNhbCwgcGFsZXR0ZURlY2FsKSB7XG4gICAgICAgICAgLy8gTWVyZ2UgZGVjYWwgZnJvbSBwYWxldHRlIHRvIGRlY2FsIGZyb20gaXRlbVN0eWxlLlxuICAgICAgICAgIC8vIFVzZXIgZG8gbm90IG5lZWQgdG8gc3BlY2lmeSBhbGwgb2YgdGhlIGRlY2FsIHByb3BzLlxuICAgICAgICAgIHZhciByZXN1bHREZWNhbCA9IHNwZWNpZmllZERlY2FsID8genJVdGlsLmV4dGVuZCh6clV0aWwuZXh0ZW5kKHt9LCBwYWxldHRlRGVjYWwpLCBzcGVjaWZpZWREZWNhbCkgOiBwYWxldHRlRGVjYWw7XG4gICAgICAgICAgcmVzdWx0RGVjYWwuZGlydHkgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiByZXN1bHREZWNhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGFiZWwoKSB7XG4gICAgdmFyIGxhYmVsTG9jYWxlID0gZWNNb2RlbC5nZXRMb2NhbGVNb2RlbCgpLmdldCgnYXJpYScpO1xuICAgIHZhciBsYWJlbE1vZGVsID0gYXJpYU1vZGVsLmdldE1vZGVsKCdsYWJlbCcpO1xuICAgIGxhYmVsTW9kZWwub3B0aW9uID0genJVdGlsLmRlZmF1bHRzKGxhYmVsTW9kZWwub3B0aW9uLCBsYWJlbExvY2FsZSk7XG5cbiAgICBpZiAoIWxhYmVsTW9kZWwuZ2V0KCdlbmFibGVkJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZG9tID0gYXBpLmdldFpyKCkuZG9tO1xuXG4gICAgaWYgKGxhYmVsTW9kZWwuZ2V0KCdkZXNjcmlwdGlvbicpKSB7XG4gICAgICBkb20uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgbGFiZWxNb2RlbC5nZXQoJ2Rlc2NyaXB0aW9uJykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZXJpZXNDbnQgPSBlY01vZGVsLmdldFNlcmllc0NvdW50KCk7XG4gICAgdmFyIG1heERhdGFDbnQgPSBsYWJlbE1vZGVsLmdldChbJ2RhdGEnLCAnbWF4Q291bnQnXSkgfHwgMTA7XG4gICAgdmFyIG1heFNlcmllc0NudCA9IGxhYmVsTW9kZWwuZ2V0KFsnc2VyaWVzJywgJ21heENvdW50J10pIHx8IDEwO1xuICAgIHZhciBkaXNwbGF5U2VyaWVzQ250ID0gTWF0aC5taW4oc2VyaWVzQ250LCBtYXhTZXJpZXNDbnQpO1xuICAgIHZhciBhcmlhTGFiZWw7XG5cbiAgICBpZiAoc2VyaWVzQ250IDwgMSkge1xuICAgICAgLy8gTm8gc2VyaWVzLCBubyBhcmlhIGxhYmVsXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKCk7XG5cbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICB2YXIgd2l0aFRpdGxlID0gbGFiZWxNb2RlbC5nZXQoWydnZW5lcmFsJywgJ3dpdGhUaXRsZSddKTtcbiAgICAgICAgYXJpYUxhYmVsID0gcmVwbGFjZSh3aXRoVGl0bGUsIHtcbiAgICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmlhTGFiZWwgPSBsYWJlbE1vZGVsLmdldChbJ2dlbmVyYWwnLCAnd2l0aG91dFRpdGxlJ10pO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VyaWVzTGFiZWxzXzEgPSBbXTtcbiAgICAgIHZhciBwcmVmaXggPSBzZXJpZXNDbnQgPiAxID8gbGFiZWxNb2RlbC5nZXQoWydzZXJpZXMnLCAnbXVsdGlwbGUnLCAncHJlZml4J10pIDogbGFiZWxNb2RlbC5nZXQoWydzZXJpZXMnLCAnc2luZ2xlJywgJ3ByZWZpeCddKTtcbiAgICAgIGFyaWFMYWJlbCArPSByZXBsYWNlKHByZWZpeCwge1xuICAgICAgICBzZXJpZXNDb3VudDogc2VyaWVzQ250XG4gICAgICB9KTtcbiAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGlkeCkge1xuICAgICAgICBpZiAoaWR4IDwgZGlzcGxheVNlcmllc0NudCkge1xuICAgICAgICAgIHZhciBzZXJpZXNMYWJlbCA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgc2VyaWVzTmFtZSA9IHNlcmllc01vZGVsLmdldCgnbmFtZScpO1xuICAgICAgICAgIHZhciB3aXRoTmFtZSA9IHNlcmllc05hbWUgPyAnd2l0aE5hbWUnIDogJ3dpdGhvdXROYW1lJztcbiAgICAgICAgICBzZXJpZXNMYWJlbCA9IHNlcmllc0NudCA+IDEgPyBsYWJlbE1vZGVsLmdldChbJ3NlcmllcycsICdtdWx0aXBsZScsIHdpdGhOYW1lXSkgOiBsYWJlbE1vZGVsLmdldChbJ3NlcmllcycsICdzaW5nbGUnLCB3aXRoTmFtZV0pO1xuICAgICAgICAgIHNlcmllc0xhYmVsID0gcmVwbGFjZShzZXJpZXNMYWJlbCwge1xuICAgICAgICAgICAgc2VyaWVzSWQ6IHNlcmllc01vZGVsLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgc2VyaWVzTmFtZTogc2VyaWVzTW9kZWwuZ2V0KCduYW1lJyksXG4gICAgICAgICAgICBzZXJpZXNUeXBlOiBnZXRTZXJpZXNUeXBlTmFtZShzZXJpZXNNb2RlbC5zdWJUeXBlKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgICAgICAgaWYgKGRhdGEuY291bnQoKSA+IG1heERhdGFDbnQpIHtcbiAgICAgICAgICAgIC8vIFNob3cgcGFydCBvZiBkYXRhXG4gICAgICAgICAgICB2YXIgcGFydGlhbExhYmVsID0gbGFiZWxNb2RlbC5nZXQoWydkYXRhJywgJ3BhcnRpYWxEYXRhJ10pO1xuICAgICAgICAgICAgc2VyaWVzTGFiZWwgKz0gcmVwbGFjZShwYXJ0aWFsTGFiZWwsIHtcbiAgICAgICAgICAgICAgZGlzcGxheUNudDogbWF4RGF0YUNudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcmllc0xhYmVsICs9IGxhYmVsTW9kZWwuZ2V0KFsnZGF0YScsICdhbGxEYXRhJ10pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkYXRhTGFiZWxzID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuY291bnQoKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IG1heERhdGFDbnQpIHtcbiAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IGRhdGEuZ2V0TmFtZShpKTtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmV0cmlldmVSYXdWYWx1ZShkYXRhLCBpKTtcbiAgICAgICAgICAgICAgdmFyIGRhdGFMYWJlbCA9IGxhYmVsTW9kZWwuZ2V0KFsnZGF0YScsIG5hbWVfMSA/ICd3aXRoTmFtZScgOiAnd2l0aG91dE5hbWUnXSk7XG4gICAgICAgICAgICAgIGRhdGFMYWJlbHMucHVzaChyZXBsYWNlKGRhdGFMYWJlbCwge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVfMSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtaWRkbGVTZXBhcmF0b3JfMSA9IGxhYmVsTW9kZWwuZ2V0KFsnZGF0YScsICdzZXBhcmF0b3InLCAnbWlkZGxlJ10pO1xuICAgICAgICAgIHZhciBlbmRTZXBhcmF0b3JfMSA9IGxhYmVsTW9kZWwuZ2V0KFsnZGF0YScsICdzZXBhcmF0b3InLCAnZW5kJ10pO1xuICAgICAgICAgIHNlcmllc0xhYmVsICs9IGRhdGFMYWJlbHMuam9pbihtaWRkbGVTZXBhcmF0b3JfMSkgKyBlbmRTZXBhcmF0b3JfMTtcbiAgICAgICAgICBzZXJpZXNMYWJlbHNfMS5wdXNoKHNlcmllc0xhYmVsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgc2VwYXJhdG9yTW9kZWwgPSBsYWJlbE1vZGVsLmdldE1vZGVsKFsnc2VyaWVzJywgJ211bHRpcGxlJywgJ3NlcGFyYXRvciddKTtcbiAgICAgIHZhciBtaWRkbGVTZXBhcmF0b3IgPSBzZXBhcmF0b3JNb2RlbC5nZXQoJ21pZGRsZScpO1xuICAgICAgdmFyIGVuZFNlcGFyYXRvciA9IHNlcGFyYXRvck1vZGVsLmdldCgnZW5kJyk7XG4gICAgICBhcmlhTGFiZWwgKz0gc2VyaWVzTGFiZWxzXzEuam9pbihtaWRkbGVTZXBhcmF0b3IpICsgZW5kU2VwYXJhdG9yO1xuICAgICAgZG9tLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGFyaWFMYWJlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShzdHIsIGtleVZhbHVlcykge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gc3RyO1xuICAgIHpyVXRpbC5lYWNoKGtleVZhbHVlcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFx7XFxcXHMqJyArIGtleSArICdcXFxccypcXFxcfScsICdnJyksIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgdmFyIHRpdGxlID0gZWNNb2RlbC5nZXQoJ3RpdGxlJyk7XG5cbiAgICBpZiAodGl0bGUgJiYgdGl0bGUubGVuZ3RoKSB7XG4gICAgICB0aXRsZSA9IHRpdGxlWzBdO1xuICAgIH1cblxuICAgIHJldHVybiB0aXRsZSAmJiB0aXRsZS50ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2VyaWVzVHlwZU5hbWUodHlwZSkge1xuICAgIHJldHVybiBlY01vZGVsLmdldExvY2FsZU1vZGVsKCkuZ2V0KFsnc2VyaWVzJywgJ3R5cGVOYW1lcyddKVt0eXBlXSB8fCAn6Ieq5a6a5LmJ5Zu+JztcbiAgfVxufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogQGZpbGUgVmlzdWFsIG1hcHBpbmcuXG4gKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xudmFyIHZpc3VhbERlZmF1bHQgPSB7XG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uICh2aXN1YWxUeXBlLCBrZXksIGlzQ2F0ZWdvcnkpIHtcbiAgICB2YXIgdmFsdWUgPSB6clV0aWwuY2xvbmUoKGRlZmF1bHRPcHRpb25bdmlzdWFsVHlwZV0gfHwge30pW2tleV0pO1xuICAgIHJldHVybiBpc0NhdGVnb3J5ID8genJVdGlsLmlzQXJyYXkodmFsdWUpID8gdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gOiB2YWx1ZSA6IHZhbHVlO1xuICB9XG59O1xudmFyIGRlZmF1bHRPcHRpb24gPSB7XG4gIGNvbG9yOiB7XG4gICAgYWN0aXZlOiBbJyMwMDZlZGQnLCAnI2UwZmZmZiddLFxuICAgIGluYWN0aXZlOiBbJ3JnYmEoMCwwLDAsMCknXVxuICB9LFxuICBjb2xvckh1ZToge1xuICAgIGFjdGl2ZTogWzAsIDM2MF0sXG4gICAgaW5hY3RpdmU6IFswLCAwXVxuICB9LFxuICBjb2xvclNhdHVyYXRpb246IHtcbiAgICBhY3RpdmU6IFswLjMsIDFdLFxuICAgIGluYWN0aXZlOiBbMCwgMF1cbiAgfSxcbiAgY29sb3JMaWdodG5lc3M6IHtcbiAgICBhY3RpdmU6IFswLjksIDAuNV0sXG4gICAgaW5hY3RpdmU6IFswLCAwXVxuICB9LFxuICBjb2xvckFscGhhOiB7XG4gICAgYWN0aXZlOiBbMC4zLCAxXSxcbiAgICBpbmFjdGl2ZTogWzAsIDBdXG4gIH0sXG4gIG9wYWNpdHk6IHtcbiAgICBhY3RpdmU6IFswLjMsIDFdLFxuICAgIGluYWN0aXZlOiBbMCwgMF1cbiAgfSxcbiAgc3ltYm9sOiB7XG4gICAgYWN0aXZlOiBbJ2NpcmNsZScsICdyb3VuZFJlY3QnLCAnZGlhbW9uZCddLFxuICAgIGluYWN0aXZlOiBbJ25vbmUnXVxuICB9LFxuICBzeW1ib2xTaXplOiB7XG4gICAgYWN0aXZlOiBbMTAsIDUwXSxcbiAgICBpbmFjdGl2ZTogWzAsIDBdXG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCB2aXN1YWxEZWZhdWx0OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogQGZpbGUgVmlzdWFsIHNvbHV0aW9uLCBmb3IgY29uc2lzdGVudCBvcHRpb24gc3BlY2lmaWNhdGlvbi5cbiAqL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgVmlzdWFsTWFwcGluZyBmcm9tICcuL1Zpc3VhbE1hcHBpbmcnO1xuaW1wb3J0IHsgZ2V0SXRlbVZpc3VhbEZyb21EYXRhLCBzZXRJdGVtVmlzdWFsRnJvbURhdGEgfSBmcm9tICcuL2hlbHBlcic7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuXG5mdW5jdGlvbiBoYXNLZXlzKG9iaikge1xuICBpZiAob2JqKSB7XG4gICAgZm9yICh2YXIgbmFtZV8xIGluIG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lXzEpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVmlzdWFsTWFwcGluZ3Mob3B0aW9uLCBzdGF0ZUxpc3QsIHN1cHBsZW1lbnRWaXN1YWxPcHRpb24pIHtcbiAgdmFyIHZpc3VhbE1hcHBpbmdzID0ge307XG4gIGVhY2goc3RhdGVMaXN0LCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgbWFwcGluZ3MgPSB2aXN1YWxNYXBwaW5nc1tzdGF0ZV0gPSBjcmVhdGVNYXBwaW5ncygpO1xuICAgIGVhY2gob3B0aW9uW3N0YXRlXSwgZnVuY3Rpb24gKHZpc3VhbERhdGEsIHZpc3VhbFR5cGUpIHtcbiAgICAgIGlmICghVmlzdWFsTWFwcGluZy5pc1ZhbGlkVHlwZSh2aXN1YWxUeXBlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXBwaW5nT3B0aW9uID0ge1xuICAgICAgICB0eXBlOiB2aXN1YWxUeXBlLFxuICAgICAgICB2aXN1YWw6IHZpc3VhbERhdGFcbiAgICAgIH07XG4gICAgICBzdXBwbGVtZW50VmlzdWFsT3B0aW9uICYmIHN1cHBsZW1lbnRWaXN1YWxPcHRpb24obWFwcGluZ09wdGlvbiwgc3RhdGUpO1xuICAgICAgbWFwcGluZ3NbdmlzdWFsVHlwZV0gPSBuZXcgVmlzdWFsTWFwcGluZyhtYXBwaW5nT3B0aW9uKTsgLy8gUHJlcGFyZSBhIGFscGhhIGZvciBvcGFjaXR5LCBmb3Igc29tZSBjYXNlIHRoYXQgb3BhY2l0eVxuICAgICAgLy8gaXMgbm90IHN1cHBvcnRlZCwgc3VjaCBhcyByZW5kZXJpbmcgdXNpbmcgZ3JhZGllbnQgY29sb3IuXG5cbiAgICAgIGlmICh2aXN1YWxUeXBlID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgbWFwcGluZ09wdGlvbiA9IHpyVXRpbC5jbG9uZShtYXBwaW5nT3B0aW9uKTtcbiAgICAgICAgbWFwcGluZ09wdGlvbi50eXBlID0gJ2NvbG9yQWxwaGEnO1xuICAgICAgICBtYXBwaW5ncy5fX2hpZGRlbi5fX2FscGhhRm9yT3BhY2l0eSA9IG5ldyBWaXN1YWxNYXBwaW5nKG1hcHBpbmdPcHRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHZpc3VhbE1hcHBpbmdzO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1hcHBpbmdzKCkge1xuICAgIHZhciBDcmVhdGVyID0gZnVuY3Rpb24gKCkge307IC8vIE1ha2Ugc3VyZSBoaWRkZW4gZmllbGRzIHdpbGwgbm90IGJlIHZpc2l0ZWQgYnlcbiAgICAvLyBvYmplY3QgaXRlcmF0aW9uICh3aXRoIGhhc093blByb3BlcnR5IGNoZWNraW5nKS5cblxuXG4gICAgQ3JlYXRlci5wcm90b3R5cGUuX19oaWRkZW4gPSBDcmVhdGVyLnByb3RvdHlwZTtcbiAgICB2YXIgb2JqID0gbmV3IENyZWF0ZXIoKTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZVZpc3VhbE9wdGlvbih0aGlzT3B0aW9uLCBuZXdPcHRpb24sIGtleXMpIHtcbiAgLy8gVmlzdWFsIGF0dHJpYnV0ZXMgbWVyZ2UgaXMgbm90IHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGl0XG4gIC8vIGJyaW5ncyBvdmVyY29tcGxpY2F0ZWQgbWVyZ2UgbG9naWMuIFNlZSAjMjg1My4gU28gaWZcbiAgLy8gbmV3T3B0aW9uIGhhcyBhbnlvbmUgb2YgdGhlc2Uga2V5cywgYWxsIG9mIHRoZXNlIGtleXNcbiAgLy8gd2lsbCBiZSByZXNldC4gT3RoZXJ3aXNlLCBhbGwga2V5cyByZW1haW4uXG4gIHZhciBoYXM7XG4gIHpyVXRpbC5lYWNoKGtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAobmV3T3B0aW9uLmhhc093blByb3BlcnR5KGtleSkgJiYgaGFzS2V5cyhuZXdPcHRpb25ba2V5XSkpIHtcbiAgICAgIGhhcyA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgaGFzICYmIHpyVXRpbC5lYWNoKGtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAobmV3T3B0aW9uLmhhc093blByb3BlcnR5KGtleSkgJiYgaGFzS2V5cyhuZXdPcHRpb25ba2V5XSkpIHtcbiAgICAgIHRoaXNPcHRpb25ba2V5XSA9IHpyVXRpbC5jbG9uZShuZXdPcHRpb25ba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzT3B0aW9uW2tleV07XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHN0YXRlTGlzdFxuICogQHBhcmFtIHZpc3VhbE1hcHBpbmdzXG4gKiBAcGFyYW0gbGlzdFxuICogQHBhcmFtIGdldFZhbHVlU3RhdGUgcGFyYW06IHZhbHVlT3JJbmRleCwgcmV0dXJuOiBzdGF0ZS5cbiAqIEBwYXJhbSBzY29wZSBTY29wZSBmb3IgZ2V0VmFsdWVTdGF0ZVxuICogQHBhcmFtIGRpbWVuc2lvbiBDb25jcmV0ZSBkaW1lbnNpb24sIGlmIHVzZWQuXG4gKi9cbi8vID8/PyEgaGFuZGxlIGJydXNoP1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlWaXN1YWwoc3RhdGVMaXN0LCB2aXN1YWxNYXBwaW5ncywgZGF0YSwgZ2V0VmFsdWVTdGF0ZSwgc2NvcGUsIGRpbWVuc2lvbikge1xuICB2YXIgdmlzdWFsVHlwZXNNYXAgPSB7fTtcbiAgenJVdGlsLmVhY2goc3RhdGVMaXN0LCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgdmlzdWFsVHlwZXMgPSBWaXN1YWxNYXBwaW5nLnByZXBhcmVWaXN1YWxUeXBlcyh2aXN1YWxNYXBwaW5nc1tzdGF0ZV0pO1xuICAgIHZpc3VhbFR5cGVzTWFwW3N0YXRlXSA9IHZpc3VhbFR5cGVzO1xuICB9KTtcbiAgdmFyIGRhdGFJbmRleDtcblxuICBmdW5jdGlvbiBnZXRWaXN1YWwoa2V5KSB7XG4gICAgcmV0dXJuIGdldEl0ZW1WaXN1YWxGcm9tRGF0YShkYXRhLCBkYXRhSW5kZXgsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRWaXN1YWwoa2V5LCB2YWx1ZSkge1xuICAgIHNldEl0ZW1WaXN1YWxGcm9tRGF0YShkYXRhLCBkYXRhSW5kZXgsIGtleSwgdmFsdWUpO1xuICB9XG5cbiAgaWYgKGRpbWVuc2lvbiA9PSBudWxsKSB7XG4gICAgZGF0YS5lYWNoKGVhY2hJdGVtKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLmVhY2goW2RpbWVuc2lvbl0sIGVhY2hJdGVtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVhY2hJdGVtKHZhbHVlT3JJbmRleCwgaW5kZXgpIHtcbiAgICBkYXRhSW5kZXggPSBkaW1lbnNpb24gPT0gbnVsbCA/IHZhbHVlT3JJbmRleCAvLyBGaXJzdCBhcmd1bWVudCBpcyBpbmRleFxuICAgIDogaW5kZXg7XG4gICAgdmFyIHJhd0RhdGFJdGVtID0gZGF0YS5nZXRSYXdEYXRhSXRlbShkYXRhSW5kZXgpOyAvLyBDb25zaWRlciBwZXJmb3JtYW5jZVxuICAgIC8vIEB0cy1pZ25vcmVcblxuICAgIGlmIChyYXdEYXRhSXRlbSAmJiByYXdEYXRhSXRlbS52aXN1YWxNYXAgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlU3RhdGUgPSBnZXRWYWx1ZVN0YXRlLmNhbGwoc2NvcGUsIHZhbHVlT3JJbmRleCk7XG4gICAgdmFyIG1hcHBpbmdzID0gdmlzdWFsTWFwcGluZ3NbdmFsdWVTdGF0ZV07XG4gICAgdmFyIHZpc3VhbFR5cGVzID0gdmlzdWFsVHlwZXNNYXBbdmFsdWVTdGF0ZV07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmlzdWFsVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB0eXBlID0gdmlzdWFsVHlwZXNbaV07XG4gICAgICBtYXBwaW5nc1t0eXBlXSAmJiBtYXBwaW5nc1t0eXBlXS5hcHBseVZpc3VhbCh2YWx1ZU9ySW5kZXgsIGdldFZpc3VhbCwgc2V0VmlzdWFsKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBzdGF0ZUxpc3RcbiAqIEBwYXJhbSB2aXN1YWxNYXBwaW5ncyA8c3RhdGUsIE9iamVjdC48dmlzdWFsVHlwZSwgbW9kdWxlOmVjaGFydHMvdmlzdWFsL1Zpc3VhbE1hcHBpbmc+PlxuICogQHBhcmFtIGdldFZhbHVlU3RhdGUgcGFyYW06IHZhbHVlT3JJbmRleCwgcmV0dXJuOiBzdGF0ZS5cbiAqIEBwYXJhbSBkaW0gZGltZW5zaW9uIG9yIGRpbWVuc2lvbiBpbmRleC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW5jcmVtZW50YWxBcHBseVZpc3VhbChzdGF0ZUxpc3QsIHZpc3VhbE1hcHBpbmdzLCBnZXRWYWx1ZVN0YXRlLCBkaW0pIHtcbiAgdmFyIHZpc3VhbFR5cGVzTWFwID0ge307XG4gIHpyVXRpbC5lYWNoKHN0YXRlTGlzdCwgZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgdmFyIHZpc3VhbFR5cGVzID0gVmlzdWFsTWFwcGluZy5wcmVwYXJlVmlzdWFsVHlwZXModmlzdWFsTWFwcGluZ3Nbc3RhdGVdKTtcbiAgICB2aXN1YWxUeXBlc01hcFtzdGF0ZV0gPSB2aXN1YWxUeXBlcztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKHBhcmFtcywgZGF0YSkge1xuICAgICAgdmFyIGRpbU5hbWU7XG5cbiAgICAgIGlmIChkaW0gIT0gbnVsbCkge1xuICAgICAgICBkaW1OYW1lID0gZGF0YS5nZXREaW1lbnNpb24oZGltKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0VmlzdWFsKGtleSkge1xuICAgICAgICByZXR1cm4gZ2V0SXRlbVZpc3VhbEZyb21EYXRhKGRhdGEsIGRhdGFJbmRleCwga2V5KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0VmlzdWFsKGtleSwgdmFsdWUpIHtcbiAgICAgICAgc2V0SXRlbVZpc3VhbEZyb21EYXRhKGRhdGEsIGRhdGFJbmRleCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhSW5kZXg7XG5cbiAgICAgIHdoaWxlICgoZGF0YUluZGV4ID0gcGFyYW1zLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgcmF3RGF0YUl0ZW0gPSBkYXRhLmdldFJhd0RhdGFJdGVtKGRhdGFJbmRleCk7IC8vIENvbnNpZGVyIHBlcmZvcm1hbmNlXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcblxuICAgICAgICBpZiAocmF3RGF0YUl0ZW0gJiYgcmF3RGF0YUl0ZW0udmlzdWFsTWFwID09PSBmYWxzZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gZGltICE9IG51bGwgPyBkYXRhLmdldChkaW1OYW1lLCBkYXRhSW5kZXgpIDogZGF0YUluZGV4O1xuICAgICAgICB2YXIgdmFsdWVTdGF0ZSA9IGdldFZhbHVlU3RhdGUodmFsdWUpO1xuICAgICAgICB2YXIgbWFwcGluZ3MgPSB2aXN1YWxNYXBwaW5nc1t2YWx1ZVN0YXRlXTtcbiAgICAgICAgdmFyIHZpc3VhbFR5cGVzID0gdmlzdWFsVHlwZXNNYXBbdmFsdWVTdGF0ZV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZpc3VhbFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSB2aXN1YWxUeXBlc1tpXTtcbiAgICAgICAgICBtYXBwaW5nc1t0eXBlXSAmJiBtYXBwaW5nc1t0eXBlXS5hcHBseVZpc3VhbCh2YWx1ZSwgZ2V0VmlzdWFsLCBzZXRWaXN1YWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufSJdLCJzb3VyY2VSb290IjoiIn0=