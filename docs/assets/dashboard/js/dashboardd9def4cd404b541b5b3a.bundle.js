(self["webpackChunkdi_website"] = self["webpackChunkdi_website"] || []).push([["vendors-node_modules_echarts_lib_chart_helper_LineDraw_js-node_modules_echarts_lib_chart_help-e3a1dd"],{

/***/ "./node_modules/echarts/lib/action/roamHelper.js":
/*!*******************************************************!*\
  !*** ./node_modules/echarts/lib/action/roamHelper.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "updateCenterAndZoom": () => (/* binding */ updateCenterAndZoom)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function updateCenterAndZoom(view, payload, zoomLimit) {
  var previousZoom = view.getZoom();
  var center = view.getCenter();
  var zoom = payload.zoom;
  var point = view.dataToPoint(center);

  if (payload.dx != null && payload.dy != null) {
    point[0] -= payload.dx;
    point[1] -= payload.dy;
    view.setCenter(view.pointToData(point));
  }

  if (zoom != null) {
    if (zoomLimit) {
      var zoomMin = zoomLimit.min || 0;
      var zoomMax = zoomLimit.max || Infinity;
      zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom;
    } // Zoom on given point(originX, originY)


    view.scaleX *= zoom;
    view.scaleY *= zoom;
    var fixX = (payload.originX - view.x) * (zoom - 1);
    var fixY = (payload.originY - view.y) * (zoom - 1);
    view.x -= fixX;
    view.y -= fixY;
    view.updateTransform(); // Get the new center

    view.setCenter(view.pointToData(point));
    view.setZoom(zoom * previousZoom);
  }

  return {
    center: view.getCenter(),
    zoom: view.getZoom()
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/Line.js":
/*!*******************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/Line.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! zrender/lib/core/vector */ "./node_modules/zrender/lib/core/vector.js");
/* harmony import */ var _util_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/symbol */ "./node_modules/echarts/lib/util/symbol.js");
/* harmony import */ var _LinePath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LinePath */ "./node_modules/echarts/lib/chart/helper/LinePath.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/









var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];

function makeSymbolTypeKey(symbolCategory) {
  return '_' + symbolCategory + 'Type';
}
/**
 * @inner
 */


function createSymbol(name, lineData, idx) {
  var symbolType = lineData.getItemVisual(idx, name);

  if (!symbolType || symbolType === 'none') {
    return;
  }

  var symbolSize = lineData.getItemVisual(idx, name + 'Size');
  var symbolRotate = lineData.getItemVisual(idx, name + 'Rotate');
  var symbolSizeArr = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(symbolSize) ? symbolSize : [symbolSize, symbolSize];
  var symbolPath = _util_symbol__WEBPACK_IMPORTED_MODULE_1__.createSymbol(symbolType, -symbolSizeArr[0] / 2, -symbolSizeArr[1] / 2, symbolSizeArr[0], symbolSizeArr[1]);
  symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0;
  symbolPath.name = name;
  return symbolPath;
}

function createLine(points) {
  var line = new _LinePath__WEBPACK_IMPORTED_MODULE_2__.default({
    name: 'line',
    subPixelOptimize: true
  });
  setLinePoints(line.shape, points);
  return line;
}

function setLinePoints(targetShape, points) {
  targetShape.x1 = points[0][0];
  targetShape.y1 = points[0][1];
  targetShape.x2 = points[1][0];
  targetShape.y2 = points[1][1];
  targetShape.percent = 1;
  var cp1 = points[2];

  if (cp1) {
    targetShape.cpx1 = cp1[0];
    targetShape.cpy1 = cp1[1];
  } else {
    targetShape.cpx1 = NaN;
    targetShape.cpy1 = NaN;
  }
}

var Line =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(Line, _super);

  function Line(lineData, idx, seriesScope) {
    var _this = _super.call(this) || this;

    _this._createLine(lineData, idx, seriesScope);

    return _this;
  }

  Line.prototype._createLine = function (lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var linePoints = lineData.getItemLayout(idx);
    var line = createLine(linePoints);
    line.shape.percent = 0;
    _util_graphic__WEBPACK_IMPORTED_MODULE_4__.initProps(line, {
      shape: {
        percent: 1
      }
    }, seriesModel, idx);
    this.add(line);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(SYMBOL_CATEGORIES, function (symbolCategory) {
      var symbol = createSymbol(symbolCategory, lineData, idx); // symbols must added after line to make sure
      // it will be updated after line#update.
      // Or symbol position and rotation update in line#beforeUpdate will be one frame slow

      this.add(symbol);
      this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
    }, this);

    this._updateCommonStl(lineData, idx, seriesScope);
  }; // TODO More strict on the List type in parameters?


  Line.prototype.updateData = function (lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line = this.childOfName('line');
    var linePoints = lineData.getItemLayout(idx);
    var target = {
      shape: {}
    };
    setLinePoints(target.shape, linePoints);
    _util_graphic__WEBPACK_IMPORTED_MODULE_4__.updateProps(line, target, seriesModel, idx);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(SYMBOL_CATEGORIES, function (symbolCategory) {
      var symbolType = lineData.getItemVisual(idx, symbolCategory);
      var key = makeSymbolTypeKey(symbolCategory); // Symbol changed

      if (this[key] !== symbolType) {
        this.remove(this.childOfName(symbolCategory));
        var symbol = createSymbol(symbolCategory, lineData, idx);
        this.add(symbol);
      }

      this[key] = symbolType;
    }, this);

    this._updateCommonStl(lineData, idx, seriesScope);
  };

  ;

  Line.prototype.getLinePath = function () {
    return this.childAt(0);
  };

  Line.prototype._updateCommonStl = function (lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line = this.childOfName('line');
    var emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;
    var blurLineStyle = seriesScope && seriesScope.blurLineStyle;
    var selectLineStyle = seriesScope && seriesScope.selectLineStyle;
    var labelStatesModels = seriesScope && seriesScope.labelStatesModels; // Optimization for large dataset

    if (!seriesScope || lineData.hasItemOption) {
      var itemModel = lineData.getItemModel(idx);
      emphasisLineStyle = itemModel.getModel(['emphasis', 'lineStyle']).getLineStyle();
      blurLineStyle = itemModel.getModel(['blur', 'lineStyle']).getLineStyle();
      selectLineStyle = itemModel.getModel(['select', 'lineStyle']).getLineStyle();
      labelStatesModels = (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_5__.getLabelStatesModels)(itemModel);
    }

    var lineStyle = lineData.getItemVisual(idx, 'style');
    var visualColor = lineStyle.stroke;
    line.useStyle(lineStyle);
    line.style.fill = null;
    line.style.strokeNoScale = true;
    line.ensureState('emphasis').style = emphasisLineStyle;
    line.ensureState('blur').style = blurLineStyle;
    line.ensureState('select').style = selectLineStyle; // Update symbol

    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(SYMBOL_CATEGORIES, function (symbolCategory) {
      var symbol = this.childOfName(symbolCategory);

      if (symbol) {
        // Share opacity and color with line.
        symbol.setColor(visualColor);
        symbol.style.opacity = lineStyle.opacity;

        for (var i = 0; i < _util_states__WEBPACK_IMPORTED_MODULE_6__.SPECIAL_STATES.length; i++) {
          var stateName = _util_states__WEBPACK_IMPORTED_MODULE_6__.SPECIAL_STATES[i];
          var lineState = line.getState(stateName);

          if (lineState) {
            var lineStateStyle = lineState.style || {};
            var state = symbol.ensureState(stateName);
            var stateStyle = state.style || (state.style = {});

            if (lineStateStyle.stroke != null) {
              stateStyle[symbol.__isEmptyBrush ? 'stroke' : 'fill'] = lineStateStyle.stroke;
            }

            if (lineStateStyle.opacity != null) {
              stateStyle.opacity = lineStateStyle.opacity;
            }
          }
        }

        symbol.markRedraw();
      }
    }, this);
    var rawVal = seriesModel.getRawValue(idx);
    (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_5__.setLabelStyle)(this, labelStatesModels, {
      labelDataIndex: idx,
      labelFetcher: {
        getFormattedLabel: function (dataIndex, stateName) {
          return seriesModel.getFormattedLabel(dataIndex, stateName, lineData.dataType);
        }
      },
      inheritColor: visualColor || '#000',
      defaultOpacity: lineStyle.opacity,
      defaultText: (rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? (0,_util_number__WEBPACK_IMPORTED_MODULE_7__.round)(rawVal) : rawVal) + ''
    });
    var label = this.getTextContent(); // Always set `textStyle` even if `normalStyle.text` is null, because default
    // values have to be set on `normalStyle`.

    if (label) {
      var labelNormalModel = labelStatesModels.normal;
      label.__align = label.style.align;
      label.__verticalAlign = label.style.verticalAlign; // 'start', 'middle', 'end'

      label.__position = labelNormalModel.get('position') || 'middle';
      var distance = labelNormalModel.get('distance');

      if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(distance)) {
        distance = [distance, distance];
      }

      label.__labelDistance = distance;
    }

    this.setTextConfig({
      position: null,
      local: true,
      inside: false // Can't be inside for stroke element.

    });
    (0,_util_states__WEBPACK_IMPORTED_MODULE_6__.enableHoverEmphasis)(this);
  };

  Line.prototype.highlight = function () {
    (0,_util_states__WEBPACK_IMPORTED_MODULE_6__.enterEmphasis)(this);
  };

  Line.prototype.downplay = function () {
    (0,_util_states__WEBPACK_IMPORTED_MODULE_6__.leaveEmphasis)(this);
  };

  Line.prototype.updateLayout = function (lineData, idx) {
    this.setLinePoints(lineData.getItemLayout(idx));
  };

  Line.prototype.setLinePoints = function (points) {
    var linePath = this.childOfName('line');
    setLinePoints(linePath.shape, points);
    linePath.dirty();
  };

  Line.prototype.beforeUpdate = function () {
    var lineGroup = this;
    var symbolFrom = lineGroup.childOfName('fromSymbol');
    var symbolTo = lineGroup.childOfName('toSymbol');
    var label = lineGroup.getTextContent(); // Quick reject

    if (!symbolFrom && !symbolTo && (!label || label.ignore)) {
      return;
    }

    var invScale = 1;
    var parentNode = this.parent;

    while (parentNode) {
      if (parentNode.scaleX) {
        invScale /= parentNode.scaleX;
      }

      parentNode = parentNode.parent;
    }

    var line = lineGroup.childOfName('line'); // If line not changed
    // FIXME Parent scale changed

    if (!this.__dirty && !line.__dirty) {
      return;
    }

    var percent = line.shape.percent;
    var fromPos = line.pointAt(0);
    var toPos = line.pointAt(percent);
    var d = zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_8__.sub([], toPos, fromPos);
    zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_8__.normalize(d, d);

    function setSymbolRotation(symbol, percent) {
      // Fix #12388
      // when symbol is set to be 'arrow' in markLine,
      // symbolRotate value will be ignored, and compulsively use tangent angle.
      // rotate by default if symbol rotation is not specified
      var specifiedRotation = symbol.__specifiedRotation;

      if (specifiedRotation == null) {
        var tangent = line.tangentAt(percent);
        symbol.attr('rotation', (percent === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
      } else {
        symbol.attr('rotation', specifiedRotation);
      }
    }

    if (symbolFrom) {
      symbolFrom.setPosition(fromPos);
      setSymbolRotation(symbolFrom, 0);
      symbolFrom.scaleX = symbolFrom.scaleY = invScale * percent;
      symbolFrom.markRedraw();
    }

    if (symbolTo) {
      symbolTo.setPosition(toPos);
      setSymbolRotation(symbolTo, 1);
      symbolTo.scaleX = symbolTo.scaleY = invScale * percent;
      symbolTo.markRedraw();
    }

    if (label && !label.ignore) {
      label.x = label.y = 0;
      label.originX = label.originY = 0;
      var textAlign = void 0;
      var textVerticalAlign = void 0;
      var distance = label.__labelDistance;
      var distanceX = distance[0] * invScale;
      var distanceY = distance[1] * invScale;
      var halfPercent = percent / 2;
      var tangent = line.tangentAt(halfPercent);
      var n = [tangent[1], -tangent[0]];
      var cp = line.pointAt(halfPercent);

      if (n[1] > 0) {
        n[0] = -n[0];
        n[1] = -n[1];
      }

      var dir = tangent[0] < 0 ? -1 : 1;

      if (label.__position !== 'start' && label.__position !== 'end') {
        var rotation = -Math.atan2(tangent[1], tangent[0]);

        if (toPos[0] < fromPos[0]) {
          rotation = Math.PI + rotation;
        }

        label.rotation = rotation;
      }

      var dy = void 0;

      switch (label.__position) {
        case 'insideStartTop':
        case 'insideMiddleTop':
        case 'insideEndTop':
        case 'middle':
          dy = -distanceY;
          textVerticalAlign = 'bottom';
          break;

        case 'insideStartBottom':
        case 'insideMiddleBottom':
        case 'insideEndBottom':
          dy = distanceY;
          textVerticalAlign = 'top';
          break;

        default:
          dy = 0;
          textVerticalAlign = 'middle';
      }

      switch (label.__position) {
        case 'end':
          label.x = d[0] * distanceX + toPos[0];
          label.y = d[1] * distanceY + toPos[1];
          textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center';
          textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle';
          break;

        case 'start':
          label.x = -d[0] * distanceX + fromPos[0];
          label.y = -d[1] * distanceY + fromPos[1];
          textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center';
          textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle';
          break;

        case 'insideStartTop':
        case 'insideStart':
        case 'insideStartBottom':
          label.x = distanceX * dir + fromPos[0];
          label.y = fromPos[1] + dy;
          textAlign = tangent[0] < 0 ? 'right' : 'left';
          label.originX = -distanceX * dir;
          label.originY = -dy;
          break;

        case 'insideMiddleTop':
        case 'insideMiddle':
        case 'insideMiddleBottom':
        case 'middle':
          label.x = cp[0];
          label.y = cp[1] + dy;
          textAlign = 'center';
          label.originY = -dy;
          break;

        case 'insideEndTop':
        case 'insideEnd':
        case 'insideEndBottom':
          label.x = -distanceX * dir + toPos[0];
          label.y = toPos[1] + dy;
          textAlign = tangent[0] >= 0 ? 'right' : 'left';
          label.originX = distanceX * dir;
          label.originY = -dy;
          break;
      }

      label.scaleX = label.scaleY = invScale;
      label.setStyle({
        // Use the user specified text align and baseline first
        verticalAlign: label.__verticalAlign || textVerticalAlign,
        align: label.__align || textAlign
      });
    }
  };

  return Line;
}(_util_graphic__WEBPACK_IMPORTED_MODULE_9__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Line);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/LineDraw.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/LineDraw.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _Line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Line */ "./node_modules/echarts/lib/chart/helper/Line.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var LineDraw =
/** @class */
function () {
  function LineDraw(LineCtor) {
    this.group = new _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default();
    this._LineCtor = LineCtor || _Line__WEBPACK_IMPORTED_MODULE_1__.default;
  }

  LineDraw.prototype.isPersistent = function () {
    return true;
  };

  ;

  LineDraw.prototype.updateData = function (lineData) {
    var _this = this;

    var lineDraw = this;
    var group = lineDraw.group;
    var oldLineData = lineDraw._lineData;
    lineDraw._lineData = lineData; // There is no oldLineData only when first rendering or switching from
    // stream mode to normal mode, where previous elements should be removed.

    if (!oldLineData) {
      group.removeAll();
    }

    var seriesScope = makeSeriesScope(lineData);
    lineData.diff(oldLineData).add(function (idx) {
      _this._doAdd(lineData, idx, seriesScope);
    }).update(function (newIdx, oldIdx) {
      _this._doUpdate(oldLineData, lineData, oldIdx, newIdx, seriesScope);
    }).remove(function (idx) {
      group.remove(oldLineData.getItemGraphicEl(idx));
    }).execute();
  };

  ;

  LineDraw.prototype.updateLayout = function () {
    var lineData = this._lineData; // Do not support update layout in incremental mode.

    if (!lineData) {
      return;
    }

    lineData.eachItemGraphicEl(function (el, idx) {
      el.updateLayout(lineData, idx);
    }, this);
  };

  ;

  LineDraw.prototype.incrementalPrepareUpdate = function (lineData) {
    this._seriesScope = makeSeriesScope(lineData);
    this._lineData = null;
    this.group.removeAll();
  };

  ;

  LineDraw.prototype.incrementalUpdate = function (taskParams, lineData) {
    function updateIncrementalAndHover(el) {
      if (!el.isGroup && !isEffectObject(el)) {
        el.incremental = true;
        el.ensureState('emphasis').hoverLayer = true;
      }
    }

    for (var idx = taskParams.start; idx < taskParams.end; idx++) {
      var itemLayout = lineData.getItemLayout(idx);

      if (lineNeedsDraw(itemLayout)) {
        var el = new this._LineCtor(lineData, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        this.group.add(el);
        lineData.setItemGraphicEl(idx, el);
      }
    }
  };

  ;

  LineDraw.prototype.remove = function () {
    this.group.removeAll();
  };

  ;

  LineDraw.prototype._doAdd = function (lineData, idx, seriesScope) {
    var itemLayout = lineData.getItemLayout(idx);

    if (!lineNeedsDraw(itemLayout)) {
      return;
    }

    var el = new this._LineCtor(lineData, idx, seriesScope);
    lineData.setItemGraphicEl(idx, el);
    this.group.add(el);
  };

  LineDraw.prototype._doUpdate = function (oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
    var itemEl = oldLineData.getItemGraphicEl(oldIdx);

    if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
      this.group.remove(itemEl);
      return;
    }

    if (!itemEl) {
      itemEl = new this._LineCtor(newLineData, newIdx, seriesScope);
    } else {
      itemEl.updateData(newLineData, newIdx, seriesScope);
    }

    newLineData.setItemGraphicEl(newIdx, itemEl);
    this.group.add(itemEl);
  };

  return LineDraw;
}();

function isEffectObject(el) {
  return el.animators && el.animators.length > 0;
}

function makeSeriesScope(lineData) {
  var hostModel = lineData.hostModel;
  return {
    lineStyle: hostModel.getModel('lineStyle').getLineStyle(),
    emphasisLineStyle: hostModel.getModel(['emphasis', 'lineStyle']).getLineStyle(),
    blurLineStyle: hostModel.getModel(['blur', 'lineStyle']).getLineStyle(),
    selectLineStyle: hostModel.getModel(['select', 'lineStyle']).getLineStyle(),
    labelStatesModels: (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_2__.getLabelStatesModels)(hostModel)
  };
}

function isPointNaN(pt) {
  return isNaN(pt[0]) || isNaN(pt[1]);
}

function lineNeedsDraw(pts) {
  return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LineDraw);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/LinePath.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/LinePath.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Line.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/BezierCurve.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Path.js");
/* harmony import */ var zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/vector */ "./node_modules/zrender/lib/core/vector.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Line path for bezier and straight line draw
 */



var straightLineProto = _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default.prototype;
var bezierCurveProto = _util_graphic__WEBPACK_IMPORTED_MODULE_1__.default.prototype;

var StraightLineShape =
/** @class */
function () {
  function StraightLineShape() {
    // Start point
    this.x1 = 0;
    this.y1 = 0; // End point

    this.x2 = 0;
    this.y2 = 0;
    this.percent = 1;
  }

  return StraightLineShape;
}();

var CurveShape =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(CurveShape, _super);

  function CurveShape() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return CurveShape;
}(StraightLineShape);

function isStraightLine(shape) {
  return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
}

var ECLinePath =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ECLinePath, _super);

  function ECLinePath(opts) {
    var _this = _super.call(this, opts) || this;

    _this.type = 'ec-line';
    return _this;
  }

  ECLinePath.prototype.getDefaultStyle = function () {
    return {
      stroke: '#000',
      fill: null
    };
  };

  ECLinePath.prototype.getDefaultShape = function () {
    return new StraightLineShape();
  };

  ECLinePath.prototype.buildPath = function (ctx, shape) {
    if (isStraightLine(shape)) {
      straightLineProto.buildPath.call(this, ctx, shape);
    } else {
      bezierCurveProto.buildPath.call(this, ctx, shape);
    }
  };

  ECLinePath.prototype.pointAt = function (t) {
    if (isStraightLine(this.shape)) {
      return straightLineProto.pointAt.call(this, t);
    } else {
      return bezierCurveProto.pointAt.call(this, t);
    }
  };

  ECLinePath.prototype.tangentAt = function (t) {
    var shape = this.shape;
    var p = isStraightLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);
    return zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_3__.normalize(p, p);
  };

  return ECLinePath;
}(_util_graphic__WEBPACK_IMPORTED_MODULE_4__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ECLinePath);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/Symbol.js":
/*!*********************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/Symbol.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _util_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/symbol */ "./node_modules/echarts/lib/util/symbol.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _labelHelper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./labelHelper */ "./node_modules/echarts/lib/chart/helper/labelHelper.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var zrender_lib_graphic_Image__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zrender/lib/graphic/Image */ "./node_modules/zrender/lib/graphic/Image.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/











var Symbol =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Symbol, _super);

  function Symbol(data, idx, seriesScope, opts) {
    var _this = _super.call(this) || this;

    _this.updateData(data, idx, seriesScope, opts);

    return _this;
  }

  Symbol.prototype._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {
    // Remove paths created before
    this.removeAll(); // let symbolPath = createSymbol(
    //     symbolType, -0.5, -0.5, 1, 1, color
    // );
    // If width/height are set too small (e.g., set to 1) on ios10
    // and macOS Sierra, a circle stroke become a rect, no matter what
    // the scale is set. So we set width/height as 2. See #4150.

    var symbolPath = (0,_util_symbol__WEBPACK_IMPORTED_MODULE_1__.createSymbol)(symbolType, -1, -1, 2, 2, null, keepAspect);
    symbolPath.attr({
      z2: 100,
      culling: true,
      scaleX: symbolSize[0] / 2,
      scaleY: symbolSize[1] / 2
    }); // Rewrite drift method

    symbolPath.drift = driftSymbol;
    this._symbolType = symbolType;
    this.add(symbolPath);
  };
  /**
   * Stop animation
   * @param {boolean} toLastFrame
   */


  Symbol.prototype.stopSymbolAnimation = function (toLastFrame) {
    this.childAt(0).stopAnimation(null, toLastFrame);
  };
  /**
   * FIXME:
   * Caution: This method breaks the encapsulation of this module,
   * but it indeed brings convenience. So do not use the method
   * unless you detailedly know all the implements of `Symbol`,
   * especially animation.
   *
   * Get symbol path element.
   */


  Symbol.prototype.getSymbolPath = function () {
    return this.childAt(0);
  };
  /**
   * Highlight symbol
   */


  Symbol.prototype.highlight = function () {
    (0,_util_states__WEBPACK_IMPORTED_MODULE_2__.enterEmphasis)(this.childAt(0));
  };
  /**
   * Downplay symbol
   */


  Symbol.prototype.downplay = function () {
    (0,_util_states__WEBPACK_IMPORTED_MODULE_2__.leaveEmphasis)(this.childAt(0));
  };
  /**
   * @param {number} zlevel
   * @param {number} z
   */


  Symbol.prototype.setZ = function (zlevel, z) {
    var symbolPath = this.childAt(0);
    symbolPath.zlevel = zlevel;
    symbolPath.z = z;
  };

  Symbol.prototype.setDraggable = function (draggable) {
    var symbolPath = this.childAt(0);
    symbolPath.draggable = draggable;
    symbolPath.cursor = draggable ? 'move' : symbolPath.cursor;
  };
  /**
   * Update symbol properties
   */


  Symbol.prototype.updateData = function (data, idx, seriesScope, opts) {
    this.silent = false;
    var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
    var seriesModel = data.hostModel;
    var symbolSize = Symbol.getSymbolSize(data, idx);
    var isInit = symbolType !== this._symbolType;
    var disableAnimation = opts && opts.disableAnimation;

    if (isInit) {
      var keepAspect = data.getItemVisual(idx, 'symbolKeepAspect');

      this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
    } else {
      var symbolPath = this.childAt(0);
      symbolPath.silent = false;
      var target = {
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2
      };
      disableAnimation ? symbolPath.attr(target) : _util_graphic__WEBPACK_IMPORTED_MODULE_3__.updateProps(symbolPath, target, seriesModel, idx);
    }

    this._updateCommon(data, idx, symbolSize, seriesScope, opts);

    if (isInit) {
      var symbolPath = this.childAt(0);

      if (!disableAnimation) {
        var target = {
          scaleX: this._sizeX,
          scaleY: this._sizeY,
          style: {
            // Always fadeIn. Because it has fadeOut animation when symbol is removed..
            opacity: symbolPath.style.opacity
          }
        };
        symbolPath.scaleX = symbolPath.scaleY = 0;
        symbolPath.style.opacity = 0;
        _util_graphic__WEBPACK_IMPORTED_MODULE_3__.initProps(symbolPath, target, seriesModel, idx);
      }
    }

    if (disableAnimation) {
      // Must stop remove animation manually if don't call initProps or updateProps.
      this.childAt(0).stopAnimation('remove');
    }

    this._seriesModel = seriesModel;
  };

  Symbol.prototype._updateCommon = function (data, idx, symbolSize, seriesScope, opts) {
    var symbolPath = this.childAt(0);
    var seriesModel = data.hostModel;
    var emphasisItemStyle;
    var blurItemStyle;
    var selectItemStyle;
    var focus;
    var blurScope;
    var symbolOffset;
    var labelStatesModels;
    var hoverScale;
    var cursorStyle;

    if (seriesScope) {
      emphasisItemStyle = seriesScope.emphasisItemStyle;
      blurItemStyle = seriesScope.blurItemStyle;
      selectItemStyle = seriesScope.selectItemStyle;
      focus = seriesScope.focus;
      blurScope = seriesScope.blurScope;
      symbolOffset = seriesScope.symbolOffset;
      labelStatesModels = seriesScope.labelStatesModels;
      hoverScale = seriesScope.hoverScale;
      cursorStyle = seriesScope.cursorStyle;
    }

    if (!seriesScope || data.hasItemOption) {
      var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
      var emphasisModel = itemModel.getModel('emphasis');
      emphasisItemStyle = emphasisModel.getModel('itemStyle').getItemStyle();
      selectItemStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle();
      blurItemStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle();
      focus = emphasisModel.get('focus');
      blurScope = emphasisModel.get('blurScope');
      symbolOffset = itemModel.getShallow('symbolOffset');
      labelStatesModels = (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_4__.getLabelStatesModels)(itemModel);
      hoverScale = emphasisModel.getShallow('scale');
      cursorStyle = itemModel.getShallow('cursor');
    }

    var symbolRotate = data.getItemVisual(idx, 'symbolRotate');
    symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);

    if (symbolOffset) {
      symbolPath.x = (0,_util_number__WEBPACK_IMPORTED_MODULE_5__.parsePercent)(symbolOffset[0], symbolSize[0]);
      symbolPath.y = (0,_util_number__WEBPACK_IMPORTED_MODULE_5__.parsePercent)(symbolOffset[1], symbolSize[1]);
    }

    cursorStyle && symbolPath.attr('cursor', cursorStyle);
    var symbolStyle = data.getItemVisual(idx, 'style');
    var visualColor = symbolStyle.fill;

    if (symbolPath instanceof zrender_lib_graphic_Image__WEBPACK_IMPORTED_MODULE_6__.default) {
      var pathStyle = symbolPath.style;
      symbolPath.useStyle((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_7__.extend)({
        // TODO other properties like x, y ?
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, symbolStyle));
    } else {
      if (symbolPath.__isEmptyBrush) {
        // fill and stroke will be swapped if it's empty.
        // So we cloned a new style to avoid it affecting the original style in visual storage.
        // TODO Better implementation. No empty logic!
        symbolPath.useStyle((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_7__.extend)({}, symbolStyle));
      } else {
        symbolPath.useStyle(symbolStyle);
      } // Disable decal because symbol scale will been applied on the decal.


      symbolPath.style.decal = null;
      symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);
      symbolPath.style.strokeNoScale = true;
    }

    var liftZ = data.getItemVisual(idx, 'liftZ');
    var z2Origin = this._z2;

    if (liftZ != null) {
      if (z2Origin == null) {
        this._z2 = symbolPath.z2;
        symbolPath.z2 += liftZ;
      }
    } else if (z2Origin != null) {
      symbolPath.z2 = z2Origin;
      this._z2 = null;
    }

    var useNameLabel = opts && opts.useNameLabel;
    (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_4__.setLabelStyle)(symbolPath, labelStatesModels, {
      labelFetcher: seriesModel,
      labelDataIndex: idx,
      defaultText: getLabelDefaultText,
      inheritColor: visualColor,
      defaultOpacity: symbolStyle.opacity
    }); // Do not execute util needed.

    function getLabelDefaultText(idx) {
      return useNameLabel ? data.getName(idx) : (0,_labelHelper__WEBPACK_IMPORTED_MODULE_8__.getDefaultLabel)(data, idx);
    }

    this._sizeX = symbolSize[0] / 2;
    this._sizeY = symbolSize[1] / 2;
    var emphasisState = symbolPath.ensureState('emphasis');
    emphasisState.style = emphasisItemStyle;
    symbolPath.ensureState('select').style = selectItemStyle;
    symbolPath.ensureState('blur').style = blurItemStyle;

    if (hoverScale) {
      var scaleRatio = Math.max(1.1, 3 / this._sizeY);
      emphasisState.scaleX = this._sizeX * scaleRatio;
      emphasisState.scaleY = this._sizeY * scaleRatio;
    }

    this.setSymbolScale(1);
    (0,_util_states__WEBPACK_IMPORTED_MODULE_2__.enableHoverEmphasis)(this, focus, blurScope);
  };

  Symbol.prototype.setSymbolScale = function (scale) {
    this.scaleX = this.scaleY = scale;
  };

  Symbol.prototype.fadeOut = function (cb, opt) {
    var symbolPath = this.childAt(0);
    var seriesModel = this._seriesModel;
    var dataIndex = (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_9__.getECData)(this).dataIndex;
    var animationOpt = opt && opt.animation; // Avoid mistaken hover when fading out

    this.silent = symbolPath.silent = true; // Not show text when animating

    if (opt && opt.fadeLabel) {
      var textContent = symbolPath.getTextContent();

      if (textContent) {
        _util_graphic__WEBPACK_IMPORTED_MODULE_3__.removeElement(textContent, {
          style: {
            opacity: 0
          }
        }, seriesModel, {
          dataIndex: dataIndex,
          removeOpt: animationOpt,
          cb: function () {
            symbolPath.removeTextContent();
          }
        });
      }
    } else {
      symbolPath.removeTextContent();
    }

    _util_graphic__WEBPACK_IMPORTED_MODULE_3__.removeElement(symbolPath, {
      style: {
        opacity: 0
      },
      scaleX: 0,
      scaleY: 0
    }, seriesModel, {
      dataIndex: dataIndex,
      cb: cb,
      removeOpt: animationOpt
    });
  };

  Symbol.getSymbolSize = function (data, idx) {
    var symbolSize = data.getItemVisual(idx, 'symbolSize');
    return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
  };

  return Symbol;
}(_util_graphic__WEBPACK_IMPORTED_MODULE_10__.default);

function driftSymbol(dx, dy) {
  this.parent.drift(dx, dy);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Symbol);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/SymbolDraw.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/SymbolDraw.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _Symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Symbol */ "./node_modules/echarts/lib/chart/helper/Symbol.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





function symbolNeedsDraw(data, point, idx, opt) {
  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of
  // the symbol element shape. We use the same clip shape here as
  // the line clip.
  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';
}

function normalizeUpdateOpt(opt) {
  if (opt != null && !(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(opt)) {
    opt = {
      isIgnore: opt
    };
  }

  return opt || {};
}

function makeSeriesScope(data) {
  var seriesModel = data.hostModel;
  var emphasisModel = seriesModel.getModel('emphasis');
  return {
    emphasisItemStyle: emphasisModel.getModel('itemStyle').getItemStyle(),
    blurItemStyle: seriesModel.getModel(['blur', 'itemStyle']).getItemStyle(),
    selectItemStyle: seriesModel.getModel(['select', 'itemStyle']).getItemStyle(),
    focus: emphasisModel.get('focus'),
    blurScope: emphasisModel.get('blurScope'),
    symbolRotate: seriesModel.get('symbolRotate'),
    symbolOffset: seriesModel.get('symbolOffset'),
    hoverScale: emphasisModel.get('scale'),
    labelStatesModels: (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_1__.getLabelStatesModels)(seriesModel),
    cursorStyle: seriesModel.get('cursor')
  };
}

var SymbolDraw =
/** @class */
function () {
  function SymbolDraw(SymbolCtor) {
    this.group = new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default();
    this._SymbolCtor = SymbolCtor || _Symbol__WEBPACK_IMPORTED_MODULE_3__.default;
  }
  /**
   * Update symbols draw by new data
   */


  SymbolDraw.prototype.updateData = function (data, opt) {
    opt = normalizeUpdateOpt(opt);
    var group = this.group;
    var seriesModel = data.hostModel;
    var oldData = this._data;
    var SymbolCtor = this._SymbolCtor;
    var disableAnimation = opt.disableAnimation;
    var seriesScope = makeSeriesScope(data);
    var symbolUpdateOpt = {
      disableAnimation: disableAnimation
    };

    var getSymbolPoint = opt.getSymbolPoint || function (idx) {
      return data.getItemLayout(idx);
    }; // There is no oldLineData only when first rendering or switching from
    // stream mode to normal mode, where previous elements should be removed.


    if (!oldData) {
      group.removeAll();
    }

    data.diff(oldData).add(function (newIdx) {
      var point = getSymbolPoint(newIdx);

      if (symbolNeedsDraw(data, point, newIdx, opt)) {
        var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function (newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      var point = getSymbolPoint(newIdx);

      if (!symbolNeedsDraw(data, point, newIdx, opt)) {
        group.remove(symbolEl);
        return;
      }

      if (!symbolEl) {
        symbolEl = new SymbolCtor(data, newIdx);
        symbolEl.setPosition(point);
      } else {
        symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);
        var target = {
          x: point[0],
          y: point[1]
        };
        disableAnimation ? symbolEl.attr(target) : _util_graphic__WEBPACK_IMPORTED_MODULE_4__.updateProps(symbolEl, target, seriesModel);
      } // Add back


      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function (oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && el.fadeOut(function () {
        group.remove(el);
      });
    }).execute();
    this._getSymbolPoint = getSymbolPoint;
    this._data = data;
  };

  ;

  SymbolDraw.prototype.isPersistent = function () {
    return true;
  };

  ;

  SymbolDraw.prototype.updateLayout = function () {
    var _this = this;

    var data = this._data;

    if (data) {
      // Not use animation
      data.eachItemGraphicEl(function (el, idx) {
        var point = _this._getSymbolPoint(idx);

        el.setPosition(point);
        el.markRedraw();
      });
    }
  };

  ;

  SymbolDraw.prototype.incrementalPrepareUpdate = function (data) {
    this._seriesScope = makeSeriesScope(data);
    this._data = null;
    this.group.removeAll();
  };

  ;
  /**
   * Update symbols draw by new data
   */

  SymbolDraw.prototype.incrementalUpdate = function (taskParams, data, opt) {
    opt = normalizeUpdateOpt(opt);

    function updateIncrementalAndHover(el) {
      if (!el.isGroup) {
        el.incremental = true;
        el.ensureState('emphasis').hoverLayer = true;
      }
    }

    for (var idx = taskParams.start; idx < taskParams.end; idx++) {
      var point = data.getItemLayout(idx);

      if (symbolNeedsDraw(data, point, idx, opt)) {
        var el = new this._SymbolCtor(data, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        el.setPosition(point);
        this.group.add(el);
        data.setItemGraphicEl(idx, el);
      }
    }
  };

  ;

  SymbolDraw.prototype.remove = function (enableAnimation) {
    var group = this.group;
    var data = this._data; // Incremental model do not have this._data.

    if (data && enableAnimation) {
      data.eachItemGraphicEl(function (el) {
        el.fadeOut(function () {
          group.remove(el);
        });
      });
    } else {
      group.removeAll();
    }
  };

  ;
  return SymbolDraw;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SymbolDraw);

/***/ }),

/***/ "./node_modules/echarts/lib/chart/helper/labelHelper.js":
/*!**************************************************************!*\
  !*** ./node_modules/echarts/lib/chart/helper/labelHelper.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDefaultLabel": () => (/* binding */ getDefaultLabel),
/* harmony export */   "getDefaultInterpolatedLabel": () => (/* binding */ getDefaultInterpolatedLabel)
/* harmony export */ });
/* harmony import */ var _data_helper_dataProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/helper/dataProvider */ "./node_modules/echarts/lib/data/helper/dataProvider.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * @return label string. Not null/undefined
 */

function getDefaultLabel(data, dataIndex) {
  var labelDims = data.mapDimensionsAll('defaultedLabel');
  var len = labelDims.length; // Simple optimization (in lots of cases, label dims length is 1)

  if (len === 1) {
    var rawVal = (0,_data_helper_dataProvider__WEBPACK_IMPORTED_MODULE_0__.retrieveRawValue)(data, dataIndex, labelDims[0]);
    return rawVal != null ? rawVal + '' : null;
  } else if (len) {
    var vals = [];

    for (var i = 0; i < labelDims.length; i++) {
      vals.push((0,_data_helper_dataProvider__WEBPACK_IMPORTED_MODULE_0__.retrieveRawValue)(data, dataIndex, labelDims[i]));
    }

    return vals.join(' ');
  }
}
function getDefaultInterpolatedLabel(data, interpolatedValue) {
  var labelDims = data.mapDimensionsAll('defaultedLabel');

  if (!(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(interpolatedValue)) {
    return interpolatedValue + '';
  }

  var vals = [];

  for (var i = 0; i < labelDims.length; i++) {
    var dimInfo = data.getDimensionInfo(labelDims[i]);

    if (dimInfo) {
      vals.push(interpolatedValue[dimInfo.index]);
    }
  }

  return vals.join(' ');
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/AxisBuilder.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axis/AxisBuilder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Line.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../model/Model */ "./node_modules/echarts/lib/model/Model.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _util_symbol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/symbol */ "./node_modules/echarts/lib/util/symbol.js");
/* harmony import */ var zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! zrender/lib/core/matrix */ "./node_modules/zrender/lib/core/matrix.js");
/* harmony import */ var zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/vector */ "./node_modules/zrender/lib/core/vector.js");
/* harmony import */ var _coord_axisHelper__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../coord/axisHelper */ "./node_modules/echarts/lib/coord/axisHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/










var PI = Math.PI;
/**
 * A final axis is translated and rotated from a "standard axis".
 * So opt.position and opt.rotation is required.
 *
 * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],
 * for example: (0, 0) ------------> (0, 50)
 *
 * nameDirection or tickDirection or labelDirection is 1 means tick
 * or label is below the standard axis, whereas is -1 means above
 * the standard axis. labelOffset means offset between label and axis,
 * which is useful when 'onZero', where axisLabel is in the grid and
 * label in outside grid.
 *
 * Tips: like always,
 * positive rotation represents anticlockwise, and negative rotation
 * represents clockwise.
 * The direction of position coordinate is the same as the direction
 * of screen coordinate.
 *
 * Do not need to consider axis 'inverse', which is auto processed by
 * axis extent.
 */

var AxisBuilder =
/** @class */
function () {
  function AxisBuilder(axisModel, opt) {
    this.group = new _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default();
    this.opt = opt;
    this.axisModel = axisModel; // Default value

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults)(opt, {
      labelOffset: 0,
      nameDirection: 1,
      tickDirection: 1,
      labelDirection: 1,
      silent: true,
      handleAutoShown: function () {
        return true;
      }
    }); // FIXME Not use a seperate text group?

    var transformGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default({
      x: opt.position[0],
      y: opt.position[1],
      rotation: opt.rotation
    }); // this.group.add(transformGroup);
    // this._transformGroup = transformGroup;

    transformGroup.updateTransform();
    this._transformGroup = transformGroup;
  }

  AxisBuilder.prototype.hasBuilder = function (name) {
    return !!builders[name];
  };

  AxisBuilder.prototype.add = function (name) {
    builders[name](this.opt, this.axisModel, this.group, this._transformGroup);
  };

  AxisBuilder.prototype.getGroup = function () {
    return this.group;
  };

  AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {
    var rotationDiff = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.remRadian)(textRotation - axisRotation);
    var textAlign;
    var textVerticalAlign;

    if ((0,_util_number__WEBPACK_IMPORTED_MODULE_2__.isRadianAroundZero)(rotationDiff)) {
      // Label is parallel with axis line.
      textVerticalAlign = direction > 0 ? 'top' : 'bottom';
      textAlign = 'center';
    } else if ((0,_util_number__WEBPACK_IMPORTED_MODULE_2__.isRadianAroundZero)(rotationDiff - PI)) {
      // Label is inverse parallel with axis line.
      textVerticalAlign = direction > 0 ? 'bottom' : 'top';
      textAlign = 'center';
    } else {
      textVerticalAlign = 'middle';

      if (rotationDiff > 0 && rotationDiff < PI) {
        textAlign = direction > 0 ? 'right' : 'left';
      } else {
        textAlign = direction > 0 ? 'left' : 'right';
      }
    }

    return {
      rotation: rotationDiff,
      textAlign: textAlign,
      textVerticalAlign: textVerticalAlign
    };
  };

  AxisBuilder.makeAxisEventDataBase = function (axisModel) {
    var eventData = {
      componentType: axisModel.mainType,
      componentIndex: axisModel.componentIndex
    };
    eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;
    return eventData;
  };

  AxisBuilder.isLabelSilent = function (axisModel) {
    var tooltipOpt = axisModel.get('tooltip');
    return axisModel.get('silent') // Consider mouse cursor, add these restrictions.
    || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);
  };

  return AxisBuilder;
}();

;
var builders = {
  axisLine: function (opt, axisModel, group, transformGroup) {
    var shown = axisModel.get(['axisLine', 'show']);

    if (shown === 'auto' && opt.handleAutoShown) {
      shown = opt.handleAutoShown('axisLine');
    }

    if (!shown) {
      return;
    }

    var extent = axisModel.axis.getExtent();
    var matrix = transformGroup.transform;
    var pt1 = [extent[0], 0];
    var pt2 = [extent[1], 0];

    if (matrix) {
      (0,zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_3__.applyTransform)(pt1, pt1, matrix);
      (0,zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_3__.applyTransform)(pt2, pt2, matrix);
    }

    var lineStyle = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend)({
      lineCap: 'round'
    }, axisModel.getModel(['axisLine', 'lineStyle']).getLineStyle());
    var line = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default({
      // Id for animation
      subPixelOptimize: true,
      shape: {
        x1: pt1[0],
        y1: pt1[1],
        x2: pt2[0],
        y2: pt2[1]
      },
      style: lineStyle,
      strokeContainThreshold: opt.strokeContainThreshold || 5,
      silent: true,
      z2: 1
    });
    line.anid = 'line';
    group.add(line);
    var arrows = axisModel.get(['axisLine', 'symbol']);
    var arrowSize = axisModel.get(['axisLine', 'symbolSize']);
    var arrowOffset = axisModel.get(['axisLine', 'symbolOffset']) || 0;

    if (typeof arrowOffset === 'number') {
      arrowOffset = [arrowOffset, arrowOffset];
    }

    if (arrows != null) {
      if (typeof arrows === 'string') {
        // Use the same arrow for start and end point
        arrows = [arrows, arrows];
      }

      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {
        // Use the same size for width and height
        arrowSize = [arrowSize, arrowSize];
      }

      var symbolWidth_1 = arrowSize[0];
      var symbolHeight_1 = arrowSize[1];
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)([{
        rotate: opt.rotation + Math.PI / 2,
        offset: arrowOffset[0],
        r: 0
      }, {
        rotate: opt.rotation - Math.PI / 2,
        offset: arrowOffset[1],
        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))
      }], function (point, index) {
        if (arrows[index] !== 'none' && arrows[index] != null) {
          var symbol = (0,_util_symbol__WEBPACK_IMPORTED_MODULE_5__.createSymbol)(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true); // Calculate arrow position with offset

          var r = point.r + point.offset;
          symbol.attr({
            rotation: point.rotate,
            x: pt1[0] + r * Math.cos(opt.rotation),
            y: pt1[1] - r * Math.sin(opt.rotation),
            silent: true,
            z2: 11
          });
          group.add(symbol);
        }
      });
    }
  },
  axisTickLabel: function (opt, axisModel, group, transformGroup) {
    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);
    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);
    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection);
  },
  axisName: function (opt, axisModel, group, transformGroup) {
    var name = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.retrieve)(opt.axisName, axisModel.get('name'));

    if (!name) {
      return;
    }

    var nameLocation = axisModel.get('nameLocation');
    var nameDirection = opt.nameDirection;
    var textStyleModel = axisModel.getModel('nameTextStyle');
    var gap = axisModel.get('nameGap') || 0;
    var extent = axisModel.axis.getExtent();
    var gapSignal = extent[0] > extent[1] ? -1 : 1;
    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // Reuse labelOffset.
    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];
    var labelLayout;
    var nameRotation = axisModel.get('nameRotate');

    if (nameRotation != null) {
      nameRotation = nameRotation * PI / 180; // To radian.
    }

    var axisNameAvailableWidth;

    if (isNameLocationCenter(nameLocation)) {
      labelLayout = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.
      nameDirection);
    } else {
      labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent);
      axisNameAvailableWidth = opt.axisNameAvailableWidth;

      if (axisNameAvailableWidth != null) {
        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
      }
    }

    var textFont = textStyleModel.getFont();
    var truncateOpt = axisModel.get('nameTruncate', true) || {};
    var ellipsis = truncateOpt.ellipsis;
    var maxWidth = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.retrieve)(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
    var tooltipOpt = axisModel.get('tooltip', true);
    var mainType = axisModel.mainType;
    var formatterParams = {
      componentType: mainType,
      name: name,
      $vars: ['name']
    };
    formatterParams[mainType + 'Index'] = axisModel.componentIndex;
    var textEl = new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default({
      x: pos[0],
      y: pos[1],
      rotation: labelLayout.rotation,
      silent: AxisBuilder.isLabelSilent(axisModel),
      style: (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_7__.createTextStyle)(textStyleModel, {
        text: name,
        font: textFont,
        overflow: 'truncate',
        width: maxWidth,
        ellipsis: ellipsis,
        fill: textStyleModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']),
        align: textStyleModel.get('align') || labelLayout.textAlign,
        verticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign
      }),
      z2: 1
    });
    textEl.tooltip = tooltipOpt && tooltipOpt.show ? (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend)({
      content: name,
      formatter: function () {
        return name;
      },
      formatterParams: formatterParams
    }, tooltipOpt) : null;
    textEl.__fullText = name; // Id for animation

    textEl.anid = 'name';

    if (axisModel.get('triggerEvent')) {
      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = 'axisName';
      eventData.name = name;
      (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_8__.getECData)(textEl).eventData = eventData;
    } // FIXME


    transformGroup.add(textEl);
    textEl.updateTransform();
    group.add(textEl);
    textEl.decomposeTransform();
  }
};

function endTextLayout(rotation, textPosition, textRotate, extent) {
  var rotationDiff = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.remRadian)(textRotate - rotation);
  var textAlign;
  var textVerticalAlign;
  var inverse = extent[0] > extent[1];
  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;

  if ((0,_util_number__WEBPACK_IMPORTED_MODULE_2__.isRadianAroundZero)(rotationDiff - PI / 2)) {
    textVerticalAlign = onLeft ? 'bottom' : 'top';
    textAlign = 'center';
  } else if ((0,_util_number__WEBPACK_IMPORTED_MODULE_2__.isRadianAroundZero)(rotationDiff - PI * 1.5)) {
    textVerticalAlign = onLeft ? 'top' : 'bottom';
    textAlign = 'center';
  } else {
    textVerticalAlign = 'middle';

    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
      textAlign = onLeft ? 'left' : 'right';
    } else {
      textAlign = onLeft ? 'right' : 'left';
    }
  }

  return {
    rotation: rotationDiff,
    textAlign: textAlign,
    textVerticalAlign: textVerticalAlign
  };
}

function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
  if ((0,_coord_axisHelper__WEBPACK_IMPORTED_MODULE_9__.shouldShowAllLabels)(axisModel.axis)) {
    return;
  } // If min or max are user set, we need to check
  // If the tick on min(max) are overlap on their neighbour tick
  // If they are overlapped, we need to hide the min(max) tick label


  var showMinLabel = axisModel.get(['axisLabel', 'showMinLabel']);
  var showMaxLabel = axisModel.get(['axisLabel', 'showMaxLabel']); // FIXME
  // Have not consider onBand yet, where tick els is more than label els.

  labelEls = labelEls || [];
  tickEls = tickEls || [];
  var firstLabel = labelEls[0];
  var nextLabel = labelEls[1];
  var lastLabel = labelEls[labelEls.length - 1];
  var prevLabel = labelEls[labelEls.length - 2];
  var firstTick = tickEls[0];
  var nextTick = tickEls[1];
  var lastTick = tickEls[tickEls.length - 1];
  var prevTick = tickEls[tickEls.length - 2];

  if (showMinLabel === false) {
    ignoreEl(firstLabel);
    ignoreEl(firstTick);
  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
    if (showMinLabel) {
      ignoreEl(nextLabel);
      ignoreEl(nextTick);
    } else {
      ignoreEl(firstLabel);
      ignoreEl(firstTick);
    }
  }

  if (showMaxLabel === false) {
    ignoreEl(lastLabel);
    ignoreEl(lastTick);
  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
    if (showMaxLabel) {
      ignoreEl(prevLabel);
      ignoreEl(prevTick);
    } else {
      ignoreEl(lastLabel);
      ignoreEl(lastTick);
    }
  }
}

function ignoreEl(el) {
  el && (el.ignore = true);
}

function isTwoLabelOverlapped(current, next) {
  // current and next has the same rotation.
  var firstRect = current && current.getBoundingRect().clone();
  var nextRect = next && next.getBoundingRect().clone();

  if (!firstRect || !nextRect) {
    return;
  } // When checking intersect of two rotated labels, we use mRotationBack
  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.


  var mRotationBack = zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_10__.identity([]);
  zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_10__.rotate(mRotationBack, mRotationBack, -current.rotation);
  firstRect.applyTransform(zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_10__.mul([], mRotationBack, current.getLocalTransform()));
  nextRect.applyTransform(zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_10__.mul([], mRotationBack, next.getLocalTransform()));
  return firstRect.intersect(nextRect);
}

function isNameLocationCenter(nameLocation) {
  return nameLocation === 'middle' || nameLocation === 'center';
}

function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {
  var tickEls = [];
  var pt1 = [];
  var pt2 = [];

  for (var i = 0; i < ticksCoords.length; i++) {
    var tickCoord = ticksCoords[i].coord;
    pt1[0] = tickCoord;
    pt1[1] = 0;
    pt2[0] = tickCoord;
    pt2[1] = tickEndCoord;

    if (tickTransform) {
      (0,zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_3__.applyTransform)(pt1, pt1, tickTransform);
      (0,zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_3__.applyTransform)(pt2, pt2, tickTransform);
    } // Tick line, Not use group transform to have better line draw


    var tickEl = new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default({
      subPixelOptimize: true,
      shape: {
        x1: pt1[0],
        y1: pt1[1],
        x2: pt2[0],
        y2: pt2[1]
      },
      style: tickLineStyle,
      z2: 2,
      autoBatch: true,
      silent: true
    });
    tickEl.anid = anidPrefix + '_' + ticksCoords[i].tickValue;
    tickEls.push(tickEl);
  }

  return tickEls;
}

function buildAxisMajorTicks(group, transformGroup, axisModel, opt) {
  var axis = axisModel.axis;
  var tickModel = axisModel.getModel('axisTick');
  var shown = tickModel.get('show');

  if (shown === 'auto' && opt.handleAutoShown) {
    shown = opt.handleAutoShown('axisTick');
  }

  if (!shown || axis.scale.isBlank()) {
    return;
  }

  var lineStyleModel = tickModel.getModel('lineStyle');
  var tickEndCoord = opt.tickDirection * tickModel.get('length');
  var ticksCoords = axis.getTicksCoords();
  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults)(lineStyleModel.getLineStyle(), {
    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])
  }), 'ticks');

  for (var i = 0; i < ticksEls.length; i++) {
    group.add(ticksEls[i]);
  }

  return ticksEls;
}

function buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {
  var axis = axisModel.axis;
  var minorTickModel = axisModel.getModel('minorTick');

  if (!minorTickModel.get('show') || axis.scale.isBlank()) {
    return;
  }

  var minorTicksCoords = axis.getMinorTicksCoords();

  if (!minorTicksCoords.length) {
    return;
  }

  var lineStyleModel = minorTickModel.getModel('lineStyle');
  var tickEndCoord = tickDirection * minorTickModel.get('length');
  var minorTickLineStyle = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults)(lineStyleModel.getLineStyle(), (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults)(axisModel.getModel('axisTick').getLineStyle(), {
    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])
  }));

  for (var i = 0; i < minorTicksCoords.length; i++) {
    var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i);

    for (var k = 0; k < minorTicksEls.length; k++) {
      group.add(minorTicksEls[k]);
    }
  }
}

function buildAxisLabel(group, transformGroup, axisModel, opt) {
  var axis = axisModel.axis;
  var show = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.retrieve)(opt.axisLabelShow, axisModel.get(['axisLabel', 'show']));

  if (!show || axis.scale.isBlank()) {
    return;
  }

  var labelModel = axisModel.getModel('axisLabel');
  var labelMargin = labelModel.get('margin');
  var labels = axis.getViewLabels(); // Special label rotate.

  var labelRotation = ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.retrieve)(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;
  var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
  var labelEls = [];
  var silent = AxisBuilder.isLabelSilent(axisModel);
  var triggerEvent = axisModel.get('triggerEvent');
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(labels, function (labelItem, index) {
    var tickValue = axis.scale.type === 'ordinal' ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
    var formattedLabel = labelItem.formattedLabel;
    var rawLabel = labelItem.rawLabel;
    var itemLabelModel = labelModel;

    if (rawCategoryData && rawCategoryData[tickValue]) {
      var rawCategoryItem = rawCategoryData[tickValue];

      if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(rawCategoryItem) && rawCategoryItem.textStyle) {
        itemLabelModel = new _model_Model__WEBPACK_IMPORTED_MODULE_11__.default(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);
      }
    }

    var textColor = itemLabelModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']);
    var tickCoord = axis.dataToCoord(tickValue);
    var textEl = new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default({
      x: tickCoord,
      y: opt.labelOffset + opt.labelDirection * labelMargin,
      rotation: labelLayout.rotation,
      silent: silent,
      z2: 10,
      style: (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_7__.createTextStyle)(itemLabelModel, {
        text: formattedLabel,
        align: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,
        verticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,
        fill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original
        // index of axis.data. So tick should not be exposed to user
        // in category axis.
        // (2) Compatible with previous version, which always use formatted label as
        // input. But in interval scale the formatted label is like '223,445', which
        // maked user repalce ','. So we modify it to return original val but remain
        // it as 'string' to avoid error in replacing.
        axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor
      })
    });
    textEl.anid = 'label_' + tickValue; // Pack data for mouse event

    if (triggerEvent) {
      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = 'axisLabel';
      eventData.value = rawLabel;
      (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_8__.getECData)(textEl).eventData = eventData;
    } // FIXME


    transformGroup.add(textEl);
    textEl.updateTransform();
    labelEls.push(textEl);
    group.add(textEl);
    textEl.decomposeTransform();
  });
  return labelEls;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxisBuilder);

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/AxisView.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axis/AxisView.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _axisPointer_modelHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../axisPointer/modelHelper */ "./node_modules/echarts/lib/component/axisPointer/modelHelper.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var axisPointerClazz = {};
/**
 * Base class of AxisView.
 */

var AxisView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(AxisView, _super);

  function AxisView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = AxisView.type;
    return _this;
  }
  /**
   * @override
   */


  AxisView.prototype.render = function (axisModel, ecModel, api, payload) {
    // FIXME
    // This process should proformed after coordinate systems updated
    // (axis scale updated), and should be performed each time update.
    // So put it here temporarily, although it is not appropriate to
    // put a model-writing procedure in `view`.
    this.axisPointerClass && _axisPointer_modelHelper__WEBPACK_IMPORTED_MODULE_1__.fixValue(axisModel);

    _super.prototype.render.apply(this, arguments);

    this._doUpdateAxisPointerClass(axisModel, api, true);
  };
  /**
   * Action handler.
   */


  AxisView.prototype.updateAxisPointer = function (axisModel, ecModel, api, payload) {
    this._doUpdateAxisPointerClass(axisModel, api, false);
  };
  /**
   * @override
   */


  AxisView.prototype.remove = function (ecModel, api) {
    var axisPointer = this._axisPointer;
    axisPointer && axisPointer.remove(api);
  };
  /**
   * @override
   */


  AxisView.prototype.dispose = function (ecModel, api) {
    this._disposeAxisPointer(api);

    _super.prototype.dispose.apply(this, arguments);
  };

  AxisView.prototype._doUpdateAxisPointerClass = function (axisModel, api, forceRender) {
    var Clazz = AxisView.getAxisPointerClass(this.axisPointerClass);

    if (!Clazz) {
      return;
    }

    var axisPointerModel = _axisPointer_modelHelper__WEBPACK_IMPORTED_MODULE_1__.getAxisPointerModel(axisModel);
    axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : this._disposeAxisPointer(api);
  };

  AxisView.prototype._disposeAxisPointer = function (api) {
    this._axisPointer && this._axisPointer.dispose(api);
    this._axisPointer = null;
  };

  AxisView.registerAxisPointerClass = function (type, clazz) {
    if (true) {
      if (axisPointerClazz[type]) {
        throw new Error('axisPointer ' + type + ' exists');
      }
    }

    axisPointerClazz[type] = clazz;
  };

  ;

  AxisView.getAxisPointerClass = function (type) {
    return type && axisPointerClazz[type];
  };

  ;
  AxisView.type = 'axis';
  return AxisView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_2__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxisView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/CartesianAxisView.js":
/*!**********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axis/CartesianAxisView.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CartesianXAxisView": () => (/* binding */ CartesianXAxisView),
/* harmony export */   "CartesianYAxisView": () => (/* binding */ CartesianYAxisView),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Line.js");
/* harmony import */ var _AxisBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AxisBuilder */ "./node_modules/echarts/lib/component/axis/AxisBuilder.js");
/* harmony import */ var _AxisView__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./AxisView */ "./node_modules/echarts/lib/component/axis/AxisView.js");
/* harmony import */ var _coord_cartesian_cartesianAxisHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../coord/cartesian/cartesianAxisHelper */ "./node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js");
/* harmony import */ var _axisSplitHelper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./axisSplitHelper */ "./node_modules/echarts/lib/component/axis/axisSplitHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];
var selfBuilderAttrs = ['splitArea', 'splitLine', 'minorSplitLine'];

var CartesianAxisView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(CartesianAxisView, _super);

  function CartesianAxisView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CartesianAxisView.type;
    _this.axisPointerClass = 'CartesianAxisPointer';
    return _this;
  }
  /**
   * @override
   */


  CartesianAxisView.prototype.render = function (axisModel, ecModel, api, payload) {
    this.group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_1__.default();
    this.group.add(this._axisGroup);

    if (!axisModel.get('show')) {
      return;
    }

    var gridModel = axisModel.getCoordSysModel();
    var layout = _coord_cartesian_cartesianAxisHelper__WEBPACK_IMPORTED_MODULE_2__.layout(gridModel, axisModel);
    var axisBuilder = new _AxisBuilder__WEBPACK_IMPORTED_MODULE_3__.default(axisModel, zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.extend({
      handleAutoShown: function (elementType) {
        var cartesians = gridModel.coordinateSystem.getCartesians();

        for (var i = 0; i < cartesians.length; i++) {
          var otherAxisType = cartesians[i].getOtherAxis(axisModel.axis).type;

          if (otherAxisType === 'value' || otherAxisType === 'log') {
            // Still show axis tick or axisLine if other axis is value / log
            return true;
          }
        } // Not show axisTick or axisLine if other axis is category / time


        return false;
      }
    }, layout));
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);

    this._axisGroup.add(axisBuilder.getGroup());

    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.each(selfBuilderAttrs, function (name) {
      if (axisModel.get([name, 'show'])) {
        axisElementBuilders[name](this, this._axisGroup, axisModel, gridModel);
      }
    }, this);
    _util_graphic__WEBPACK_IMPORTED_MODULE_5__.groupTransition(oldAxisGroup, this._axisGroup, axisModel);

    _super.prototype.render.call(this, axisModel, ecModel, api, payload);
  };

  CartesianAxisView.prototype.remove = function () {
    (0,_axisSplitHelper__WEBPACK_IMPORTED_MODULE_6__.rectCoordAxisHandleRemove)(this);
  };

  CartesianAxisView.type = 'cartesianAxis';
  return CartesianAxisView;
}(_AxisView__WEBPACK_IMPORTED_MODULE_7__.default);

var axisElementBuilders = {
  splitLine: function (axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;

    if (axis.scale.isBlank()) {
      return;
    }

    var splitLineModel = axisModel.getModel('splitLine');
    var lineStyleModel = splitLineModel.getModel('lineStyle');
    var lineColors = lineStyleModel.get('color');
    lineColors = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.isArray(lineColors) ? lineColors : [lineColors];
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var lineCount = 0;
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitLineModel
    });
    var p1 = [];
    var p2 = [];
    var lineStyle = lineStyleModel.getLineStyle();

    for (var i = 0; i < ticksCoords.length; i++) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);

      if (isHorizontal) {
        p1[0] = tickCoord;
        p1[1] = gridRect.y;
        p2[0] = tickCoord;
        p2[1] = gridRect.y + gridRect.height;
      } else {
        p1[0] = gridRect.x;
        p1[1] = tickCoord;
        p2[0] = gridRect.x + gridRect.width;
        p2[1] = tickCoord;
      }

      var colorIndex = lineCount++ % lineColors.length;
      var tickValue = ticksCoords[i].tickValue;
      axisGroup.add(new _util_graphic__WEBPACK_IMPORTED_MODULE_8__.default({
        anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,
        subPixelOptimize: true,
        autoBatch: true,
        shape: {
          x1: p1[0],
          y1: p1[1],
          x2: p2[0],
          y2: p2[1]
        },
        style: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.defaults({
          stroke: lineColors[colorIndex]
        }, lineStyle),
        silent: true
      }));
    }
  },
  minorSplitLine: function (axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;
    var minorSplitLineModel = axisModel.getModel('minorSplitLine');
    var lineStyleModel = minorSplitLineModel.getModel('lineStyle');
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var minorTicksCoords = axis.getMinorTicksCoords();

    if (!minorTicksCoords.length) {
      return;
    }

    var p1 = [];
    var p2 = [];
    var lineStyle = lineStyleModel.getLineStyle();

    for (var i = 0; i < minorTicksCoords.length; i++) {
      for (var k = 0; k < minorTicksCoords[i].length; k++) {
        var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);

        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }

        axisGroup.add(new _util_graphic__WEBPACK_IMPORTED_MODULE_8__.default({
          anid: 'minor_line_' + minorTicksCoords[i][k].tickValue,
          subPixelOptimize: true,
          autoBatch: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: lineStyle,
          silent: true
        }));
      }
    }
  },
  splitArea: function (axisView, axisGroup, axisModel, gridModel) {
    (0,_axisSplitHelper__WEBPACK_IMPORTED_MODULE_6__.rectCoordAxisBuildSplitArea)(axisView, axisGroup, axisModel, gridModel);
  }
};

var CartesianXAxisView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(CartesianXAxisView, _super);

  function CartesianXAxisView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CartesianXAxisView.type;
    return _this;
  }

  CartesianXAxisView.type = 'xAxis';
  return CartesianXAxisView;
}(CartesianAxisView);



var CartesianYAxisView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(CartesianYAxisView, _super);

  function CartesianYAxisView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CartesianXAxisView.type;
    return _this;
  }

  CartesianYAxisView.type = 'yAxis';
  return CartesianYAxisView;
}(CartesianAxisView);


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CartesianAxisView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/ParallelAxisView.js":
/*!*********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axis/ParallelAxisView.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _AxisBuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AxisBuilder */ "./node_modules/echarts/lib/component/axis/AxisBuilder.js");
/* harmony import */ var _helper_BrushController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/BrushController */ "./node_modules/echarts/lib/component/helper/BrushController.js");
/* harmony import */ var _helper_brushHelper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helper/brushHelper */ "./node_modules/echarts/lib/component/helper/brushHelper.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/core/BoundingRect.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







var elementList = ['axisLine', 'axisTickLabel', 'axisName'];

var ParallelAxisView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ParallelAxisView, _super);

  function ParallelAxisView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ParallelAxisView.type;
    return _this;
  }

  ParallelAxisView.prototype.init = function (ecModel, api) {
    _super.prototype.init.apply(this, arguments);

    (this._brushController = new _helper_BrushController__WEBPACK_IMPORTED_MODULE_1__.default(api.getZr())).on('brush', zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.bind(this._onBrush, this));
  };

  ParallelAxisView.prototype.render = function (axisModel, ecModel, api, payload) {
    if (fromAxisAreaSelect(axisModel, ecModel, payload)) {
      return;
    }

    this.axisModel = axisModel;
    this.api = api;
    this.group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default();
    this.group.add(this._axisGroup);

    if (!axisModel.get('show')) {
      return;
    }

    var coordSysModel = getCoordSysModel(axisModel, ecModel);
    var coordSys = coordSysModel.coordinateSystem;
    var areaSelectStyle = axisModel.getAreaSelectStyle();
    var areaWidth = areaSelectStyle.width;
    var dim = axisModel.axis.dim;
    var axisLayout = coordSys.getAxisLayout(dim);
    var builderOpt = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.extend({
      strokeContainThreshold: areaWidth
    }, axisLayout);
    var axisBuilder = new _AxisBuilder__WEBPACK_IMPORTED_MODULE_4__.default(axisModel, builderOpt);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each(elementList, axisBuilder.add, axisBuilder);

    this._axisGroup.add(axisBuilder.getGroup());

    this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api);

    _util_graphic__WEBPACK_IMPORTED_MODULE_5__.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
  }; // /**
  //  * @override
  //  */
  // updateVisual(axisModel, ecModel, api, payload) {
  //     this._brushController && this._brushController
  //         .updateCovers(getCoverInfoList(axisModel));
  // }


  ParallelAxisView.prototype._refreshBrushController = function (builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api) {
    // After filtering, axis may change, select area needs to be update.
    var extent = axisModel.axis.getExtent();
    var extentLen = extent[1] - extent[0];
    var extra = Math.min(30, Math.abs(extentLen) * 0.1); // Arbitrary value.
    // width/height might be negative, which will be
    // normalized in BoundingRect.

    var rect = _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default.create({
      x: extent[0],
      y: -areaWidth / 2,
      width: extentLen,
      height: areaWidth
    });
    rect.x -= extra;
    rect.width += 2 * extra;

    this._brushController.mount({
      enableGlobalPan: true,
      rotation: builderOpt.rotation,
      x: builderOpt.position[0],
      y: builderOpt.position[1]
    }).setPanels([{
      panelId: 'pl',
      clipPath: _helper_brushHelper__WEBPACK_IMPORTED_MODULE_7__.makeRectPanelClipPath(rect),
      isTargetByCursor: _helper_brushHelper__WEBPACK_IMPORTED_MODULE_7__.makeRectIsTargetByCursor(rect, api, coordSysModel),
      getLinearBrushOtherExtent: _helper_brushHelper__WEBPACK_IMPORTED_MODULE_7__.makeLinearBrushOtherExtent(rect, 0)
    }]).enableBrush({
      brushType: 'lineX',
      brushStyle: areaSelectStyle,
      removeOnClick: true
    }).updateCovers(getCoverInfoList(axisModel));
  };

  ParallelAxisView.prototype._onBrush = function (eventParam) {
    var coverInfoList = eventParam.areas; // Do not cache these object, because the mey be changed.

    var axisModel = this.axisModel;
    var axis = axisModel.axis;
    var intervals = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.map(coverInfoList, function (coverInfo) {
      return [axis.coordToData(coverInfo.range[0], true), axis.coordToData(coverInfo.range[1], true)];
    }); // If realtime is true, action is not dispatched on drag end, because
    // the drag end emits the same params with the last drag move event,
    // and may have some delay when using touch pad.

    if (!axisModel.option.realtime === eventParam.isEnd || eventParam.removeOnClick) {
      // jshint ignore:line
      this.api.dispatchAction({
        type: 'axisAreaSelect',
        parallelAxisId: axisModel.id,
        intervals: intervals
      });
    }
  };

  ParallelAxisView.prototype.dispose = function () {
    this._brushController.dispose();
  };

  ParallelAxisView.type = 'parallelAxis';
  return ParallelAxisView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_8__.default);

function fromAxisAreaSelect(axisModel, ecModel, payload) {
  return payload && payload.type === 'axisAreaSelect' && ecModel.findComponents({
    mainType: 'parallelAxis',
    query: payload
  })[0] === axisModel;
}

function getCoverInfoList(axisModel) {
  var axis = axisModel.axis;
  return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.map(axisModel.activeIntervals, function (interval) {
    return {
      brushType: 'lineX',
      panelId: 'pl',
      range: [axis.dataToCoord(interval[0], true), axis.dataToCoord(interval[1], true)]
    };
  });
}

function getCoordSysModel(axisModel, ecModel) {
  return ecModel.getComponent('parallel', axisModel.get('parallelIndex'));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ParallelAxisView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/axisSplitHelper.js":
/*!********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axis/axisSplitHelper.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rectCoordAxisBuildSplitArea": () => (/* binding */ rectCoordAxisBuildSplitArea),
/* harmony export */   "rectCoordAxisHandleRemove": () => (/* binding */ rectCoordAxisHandleRemove)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();
function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
  var axis = axisModel.axis;

  if (axis.scale.isBlank()) {
    return;
  } // TODO: TYPE


  var splitAreaModel = axisModel.getModel('splitArea');
  var areaStyleModel = splitAreaModel.getModel('areaStyle');
  var areaColors = areaStyleModel.get('color');
  var gridRect = gridModel.coordinateSystem.getRect();
  var ticksCoords = axis.getTicksCoords({
    tickModel: splitAreaModel,
    clamp: true
  });

  if (!ticksCoords.length) {
    return;
  } // For Making appropriate splitArea animation, the color and anid
  // should be corresponding to previous one if possible.


  var areaColorsLen = areaColors.length;
  var lastSplitAreaColors = inner(axisView).splitAreaColors;
  var newSplitAreaColors = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.createHashMap();
  var colorIndex = 0;

  if (lastSplitAreaColors) {
    for (var i = 0; i < ticksCoords.length; i++) {
      var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);

      if (cIndex != null) {
        colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
        break;
      }
    }
  }

  var prev = axis.toGlobalCoord(ticksCoords[0].coord);
  var areaStyle = areaStyleModel.getAreaStyle();
  areaColors = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(areaColors) ? areaColors : [areaColors];

  for (var i = 1; i < ticksCoords.length; i++) {
    var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
    var x = void 0;
    var y = void 0;
    var width = void 0;
    var height = void 0;

    if (axis.isHorizontal()) {
      x = prev;
      y = gridRect.y;
      width = tickCoord - x;
      height = gridRect.height;
      prev = x + width;
    } else {
      x = gridRect.x;
      y = prev;
      width = gridRect.width;
      height = tickCoord - y;
      prev = y + height;
    }

    var tickValue = ticksCoords[i - 1].tickValue;
    tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
    axisGroup.add(new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default({
      anid: tickValue != null ? 'area_' + tickValue : null,
      shape: {
        x: x,
        y: y,
        width: width,
        height: height
      },
      style: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults({
        fill: areaColors[colorIndex]
      }, areaStyle),
      autoBatch: true,
      silent: true
    }));
    colorIndex = (colorIndex + 1) % areaColorsLen;
  }

  inner(axisView).splitAreaColors = newSplitAreaColors;
}
function rectCoordAxisHandleRemove(axisView) {
  inner(axisView).splitAreaColors = null;
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/axis/parallelAxisAction.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axis/parallelAxisAction.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "installParallelActions": () => (/* binding */ installParallelActions)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var actionInfo = {
  type: 'axisAreaSelect',
  event: 'axisAreaSelected' // update: 'updateVisual'

};
function installParallelActions(registers) {
  registers.registerAction(actionInfo, function (payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'parallelAxis',
      query: payload
    }, function (parallelAxisModel) {
      parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);
    });
  });
  /**
   * @payload
   */

  registers.registerAction('parallelAxisExpand', function (payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'parallel',
      query: payload
    }, function (parallelModel) {
      parallelModel.setAxisExpand(payload);
    });
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/axisPointer/modelHelper.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/axisPointer/modelHelper.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "collect": () => (/* binding */ collect),
/* harmony export */   "fixValue": () => (/* binding */ fixValue),
/* harmony export */   "getAxisInfo": () => (/* binding */ getAxisInfo),
/* harmony export */   "getAxisPointerModel": () => (/* binding */ getAxisPointerModel),
/* harmony export */   "makeKey": () => (/* binding */ makeKey)
/* harmony export */ });
/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/Model */ "./node_modules/echarts/lib/model/Model.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

 // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
// allAxesInfo should be updated when setOption performed.

function collect(ecModel, api) {
  var result = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: false,

    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart.

  result.seriesInvolved && collectSeriesInfo(result, ecModel);
  return result;
}

function collectAxesInfo(result, ecModel, api) {
  var globalTooltipModel = ecModel.getComponent('tooltip');
  var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global.

  var linksOption = globalAxisPointerModel.get('link', true) || [];
  var linkGroups = []; // Collect axes info.

  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(api.getCoordinateSystems(), function (coordSys) {
    // Some coordinate system do not support axes, like geo.
    if (!coordSys.axisPointerEnabled) {
      return;
    }

    var coordSysKey = makeKey(coordSys.model);
    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
    result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer
    // for user. So we enable seting tooltip on coordSys model.

    var coordSysModel = coordSys.model;
    var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(coordSys.getAxes(), (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.curry)(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys.
    // Notice this case: coordSys is `grid` but not `cartesian2D` here.

    if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not
    // show but axisPointer will show as normal.
    && baseTooltipModel.get('show')) {
      // Compatible with previous logic. But series.tooltip.trigger: 'axis'
      // or series.data[n].tooltip.trigger: 'axis' are not support any more.
      var triggerAxis = baseTooltipModel.get('trigger') === 'axis';
      var cross = baseTooltipModel.get(['axisPointer', 'type']) === 'cross';
      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(['axisPointer', 'axis']));

      if (triggerAxis || cross) {
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(tooltipAxes.baseAxes, (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.curry)(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));
      }

      if (cross) {
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(tooltipAxes.otherAxes, (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.curry)(saveTooltipAxisInfo, 'cross', false));
      }
    } // fromTooltip: true | false | 'cross'
    // triggerTooltip: true | false | null


    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
      var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);
      var axisPointerShow = axisPointerModel.get('show');

      if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
        return;
      }

      if (triggerTooltip == null) {
        triggerTooltip = axisPointerModel.get('triggerTooltip');
      }

      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
      var snap = axisPointerModel.get('snap');
      var axisKey = makeKey(axis.model);
      var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority).

      var axisInfo = result.axesInfo[axisKey] = {
        key: axisKey,
        axis: axis,
        coordSys: coordSys,
        axisPointerModel: axisPointerModel,
        triggerTooltip: triggerTooltip,
        involveSeries: involveSeries,
        snap: snap,
        useHandle: isHandleTrigger(axisPointerModel),
        seriesModels: [],
        linkGroup: null
      };
      axesInfoInCoordSys[axisKey] = axisInfo;
      result.seriesInvolved = result.seriesInvolved || involveSeries;
      var groupIndex = getLinkGroupIndex(linksOption, axis);

      if (groupIndex != null) {
        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
          axesInfo: {}
        });
        linkGroup.axesInfo[axisKey] = axisInfo;
        linkGroup.mapper = linksOption[groupIndex].mapper;
        axisInfo.linkGroup = linkGroup;
      }
    }
  });
}

function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
  var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');
  var fields = ['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'];
  var volatileOption = {};
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(fields, function (field) {
    volatileOption[field] = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.clone)(tooltipAxisPointerModel.get(field));
  }); // category axis do not auto snap, otherwise some tick that do not
  // has value can not be hovered. value/time/log axis default snap if
  // triggered from tooltip and trigger tooltip.

  volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default.
  // Only these properties can be overrided from tooltip to axisPointer.

  if (tooltipAxisPointerModel.get('type') === 'cross') {
    volatileOption.type = 'line';
  }

  var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default.

  labelOption.show == null && (labelOption.show = false);

  if (fromTooltip === 'cross') {
    // When 'cross', both axes show labels.
    var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(['label', 'show']);
    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true; // If triggerTooltip, this is a base axis, which should better not use cross style
    // (cross style is dashed by default)

    if (!triggerTooltip) {
      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');
      crossStyle && (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.defaults)(labelOption, crossStyle.textStyle);
    }
  }

  return axis.model.getModel('axisPointer', new _model_Model__WEBPACK_IMPORTED_MODULE_1__.default(volatileOption, globalAxisPointerModel, ecModel));
}

function collectSeriesInfo(result, ecModel) {
  // Prepare data for axis trigger
  ecModel.eachSeries(function (seriesModel) {
    // Notice this case: this coordSys is `cartesian2D` but not `grid`.
    var coordSys = seriesModel.coordinateSystem;
    var seriesTooltipTrigger = seriesModel.get(['tooltip', 'trigger'], true);
    var seriesTooltipShow = seriesModel.get(['tooltip', 'show'], true);

    if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get(['axisPointer', 'show'], true) === false) {
      return;
    }

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {
      var axis = axisInfo.axis;

      if (coordSys.getAxis(axis.dim) === axis) {
        axisInfo.seriesModels.push(seriesModel);
        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
        axisInfo.seriesDataCount += seriesModel.getData().count();
      }
    });
  });
}
/**
 * For example:
 * {
 *     axisPointer: {
 *         links: [{
 *             xAxisIndex: [2, 4],
 *             yAxisIndex: 'all'
 *         }, {
 *             xAxisId: ['a5', 'a7'],
 *             xAxisName: 'xxx'
 *         }]
 *     }
 * }
 */


function getLinkGroupIndex(linksOption, axis) {
  var axisModel = axis.model;
  var dim = axis.dim;

  for (var i = 0; i < linksOption.length; i++) {
    var linkOption = linksOption[i] || {};

    if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {
      return i;
    }
  }
}

function checkPropInLink(linkPropValue, axisPropValue) {
  return linkPropValue === 'all' || (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(linkPropValue) && (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.indexOf)(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
}

function fixValue(axisModel) {
  var axisInfo = getAxisInfo(axisModel);

  if (!axisInfo) {
    return;
  }

  var axisPointerModel = axisInfo.axisPointerModel;
  var scale = axisInfo.axis.scale;
  var option = axisPointerModel.option;
  var status = axisPointerModel.get('status');
  var value = axisPointerModel.get('value'); // Parse init value for category and time axis.

  if (value != null) {
    value = scale.parse(value);
  }

  var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value
  // and status should be initialized.

  if (status == null) {
    option.status = useHandle ? 'show' : 'hide';
  }

  var extent = scale.getExtent().slice();
  extent[0] > extent[1] && extent.reverse();

  if ( // Pick a value on axis when initializing.
  value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent,
  // where we should re-pick a value to keep `handle` displaying normally.
  || value > extent[1]) {
    // Make handle displayed on the end of the axis when init, which looks better.
    value = extent[1];
  }

  if (value < extent[0]) {
    value = extent[0];
  }

  option.value = value;

  if (useHandle) {
    option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';
  }
}
function getAxisInfo(axisModel) {
  var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;
  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
}
function getAxisPointerModel(axisModel) {
  var axisInfo = getAxisInfo(axisModel);
  return axisInfo && axisInfo.axisPointerModel;
}

function isHandleTrigger(axisPointerModel) {
  return !!axisPointerModel.get(['handle', 'show']);
}
/**
 * @param {module:echarts/model/Model} model
 * @return {string} unique key
 */


function makeKey(model) {
  return model.type + '||' + model.id;
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/geo/GeoView.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/component/geo/GeoView.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _helper_MapDraw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/MapDraw */ "./node_modules/echarts/lib/component/helper/MapDraw.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var GeoView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(GeoView, _super);

  function GeoView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = GeoView.type;
    return _this;
  }

  GeoView.prototype.init = function (ecModel, api) {
    var mapDraw = new _helper_MapDraw__WEBPACK_IMPORTED_MODULE_1__.default(api);
    this._mapDraw = mapDraw;
    this.group.add(mapDraw.group);
    this._api = api;
  };

  GeoView.prototype.render = function (geoModel, ecModel, api, payload) {
    var mapDraw = this._mapDraw;

    if (geoModel.get('show')) {
      mapDraw.draw(geoModel, ecModel, api, this, payload);
    } else {
      this._mapDraw.group.removeAll();
    }

    mapDraw.group.on('click', this._handleRegionClick, this);
    mapDraw.group.silent = geoModel.get('silent');
    this._model = geoModel;
    this.updateSelectStatus(geoModel, ecModel, api);
  };

  GeoView.prototype._handleRegionClick = function (e) {
    var current = e.target;
    var eventData; // TODO extract a util function

    while (current && (eventData = (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_2__.getECData)(current).eventData) == null) {
      current = current.__hostTarget || current.parent;
    }

    if (eventData) {
      this._api.dispatchAction({
        type: 'geoToggleSelect',
        geoId: this._model.id,
        name: eventData.name
      });
    }
  };

  GeoView.prototype.updateSelectStatus = function (model, ecModel, api) {
    var _this = this;

    this._mapDraw.group.traverse(function (node) {
      var eventData = (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_2__.getECData)(node).eventData;

      if (eventData) {
        _this._model.isSelected(eventData.name) ? api.enterSelect(node) : api.leaveSelect(node); // No need to traverse children.

        return true;
      }
    });
  };

  GeoView.prototype.dispose = function () {
    this._mapDraw && this._mapDraw.remove();
  };

  GeoView.type = 'geo';
  return GeoView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_3__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/geo/install.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/component/geo/install.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _coord_geo_GeoModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../coord/geo/GeoModel */ "./node_modules/echarts/lib/coord/geo/GeoModel.js");
/* harmony import */ var _coord_geo_geoCreator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../coord/geo/geoCreator */ "./node_modules/echarts/lib/coord/geo/geoCreator.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _action_roamHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../action/roamHelper */ "./node_modules/echarts/lib/action/roamHelper.js");
/* harmony import */ var _GeoView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeoView */ "./node_modules/echarts/lib/component/geo/GeoView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





function install(registers) {
  registers.registerCoordinateSystem('geo', _coord_geo_geoCreator__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerComponentModel(_coord_geo_GeoModel__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerComponentView(_GeoView__WEBPACK_IMPORTED_MODULE_2__.default);

  function makeAction(method, actionInfo) {
    actionInfo.update = 'geo:updateSelectStatus';
    registers.registerAction(actionInfo, function (payload, ecModel) {
      var selected = {};
      ecModel.eachComponent({
        mainType: 'geo',
        query: payload
      }, function (geoModel) {
        geoModel[method](payload.name);
        var geo = geoModel.coordinateSystem;
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.each)(geo.regions, function (region) {
          selected[region.name] = geoModel.isSelected(region.name) || false;
        });
      });
      return {
        selected: selected,
        name: payload.name
      };
    });
  }

  makeAction('toggleSelected', {
    type: 'geoToggleSelect',
    event: 'geoselectchanged'
  });
  makeAction('select', {
    type: 'geoSelect',
    event: 'geoselected'
  });
  makeAction('unSelect', {
    type: 'geoUnSelect',
    event: 'geounselected'
  });
  /**
   * @payload
   * @property {string} [componentType=series]
   * @property {number} [dx]
   * @property {number} [dy]
   * @property {number} [zoom]
   * @property {number} [originX]
   * @property {number} [originY]
   */

  registers.registerAction({
    type: 'geoRoam',
    event: 'geoRoam',
    update: 'updateTransform'
  }, function (payload, ecModel) {
    var componentType = payload.componentType || 'series';
    ecModel.eachComponent({
      mainType: componentType,
      query: payload
    }, function (componentModel) {
      var geo = componentModel.coordinateSystem;

      if (geo.type !== 'geo') {
        return;
      }

      var res = (0,_action_roamHelper__WEBPACK_IMPORTED_MODULE_4__.updateCenterAndZoom)(geo, payload, componentModel.get('scaleLimit'));
      componentModel.setCenter && componentModel.setCenter(res.center);
      componentModel.setZoom && componentModel.setZoom(res.zoom); // All map series with same `map` use the same geo coordinate system
      // So the center and zoom must be in sync. Include the series not selected by legend

      if (componentType === 'series') {
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.each)(componentModel.seriesGroup, function (seriesModel) {
          seriesModel.setCenter(res.center);
          seriesModel.setZoom(res.zoom);
        });
      }
    });
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/grid/installSimple.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/grid/installSimple.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");
/* harmony import */ var _coord_cartesian_GridModel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../coord/cartesian/GridModel */ "./node_modules/echarts/lib/coord/cartesian/GridModel.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _coord_cartesian_AxisModel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../coord/cartesian/AxisModel */ "./node_modules/echarts/lib/coord/cartesian/AxisModel.js");
/* harmony import */ var _coord_axisModelCreator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../coord/axisModelCreator */ "./node_modules/echarts/lib/coord/axisModelCreator.js");
/* harmony import */ var _coord_cartesian_Grid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../coord/cartesian/Grid */ "./node_modules/echarts/lib/coord/cartesian/Grid.js");
/* harmony import */ var _axis_CartesianAxisView__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../axis/CartesianAxisView */ "./node_modules/echarts/lib/component/axis/CartesianAxisView.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








 // Grid view

var GridView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(GridView, _super);

  function GridView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'grid';
    return _this;
  }

  GridView.prototype.render = function (gridModel, ecModel) {
    this.group.removeAll();

    if (gridModel.get('show')) {
      this.group.add(new _util_graphic__WEBPACK_IMPORTED_MODULE_1__.default({
        shape: gridModel.coordinateSystem.getRect(),
        style: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.defaults)({
          fill: gridModel.get('backgroundColor')
        }, gridModel.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }
  };

  GridView.type = 'grid';
  return GridView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_3__.default);

var extraOption = {
  // gridIndex: 0,
  // gridId: '',
  offset: 0
};
function install(registers) {
  registers.registerComponentView(GridView);
  registers.registerComponentModel(_coord_cartesian_GridModel__WEBPACK_IMPORTED_MODULE_4__.default);
  registers.registerCoordinateSystem('cartesian2d', _coord_cartesian_Grid__WEBPACK_IMPORTED_MODULE_5__.default);
  (0,_coord_axisModelCreator__WEBPACK_IMPORTED_MODULE_6__.default)(registers, 'x', _coord_cartesian_AxisModel__WEBPACK_IMPORTED_MODULE_7__.CartesianAxisModel, extraOption);
  (0,_coord_axisModelCreator__WEBPACK_IMPORTED_MODULE_6__.default)(registers, 'y', _coord_cartesian_AxisModel__WEBPACK_IMPORTED_MODULE_7__.CartesianAxisModel, extraOption);
  registers.registerComponentView(_axis_CartesianAxisView__WEBPACK_IMPORTED_MODULE_8__.CartesianXAxisView);
  registers.registerComponentView(_axis_CartesianAxisView__WEBPACK_IMPORTED_MODULE_8__.CartesianYAxisView);
  registers.registerPreprocessor(function (option) {
    // Only create grid when need
    if (option.xAxis && option.yAxis && !option.grid) {
      option.grid = {};
    }
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/BrushController.js":
/*!**********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/helper/BrushController.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_core_Eventful__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/core/Eventful */ "./node_modules/zrender/lib/core/Eventful.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polyline.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polygon.js");
/* harmony import */ var _interactionMutex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interactionMutex */ "./node_modules/echarts/lib/component/helper/interactionMutex.js");
/* harmony import */ var _data_DataDiffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../data/DataDiffer */ "./node_modules/echarts/lib/data/DataDiffer.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var BRUSH_PANEL_GLOBAL = true;
var mathMin = Math.min;
var mathMax = Math.max;
var mathPow = Math.pow;
var COVER_Z = 10000;
var UNSELECT_THRESHOLD = 6;
var MIN_RESIZE_LINE_WIDTH = 6;
var MUTEX_RESOURCE_KEY = 'globalPan';
var DIRECTION_MAP = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
};
var CURSOR_MAP = {
  w: 'ew',
  e: 'ew',
  n: 'ns',
  s: 'ns',
  ne: 'nesw',
  sw: 'nesw',
  nw: 'nwse',
  se: 'nwse'
};
var DEFAULT_BRUSH_OPT = {
  brushStyle: {
    lineWidth: 2,
    stroke: 'rgba(210,219,238,0.3)',
    fill: '#D2DBEE'
  },
  transformable: true,
  brushMode: 'single',
  removeOnClick: false
};
var baseUID = 0;
/**
 * params:
 *     areas: Array.<Array>, coord relates to container group,
 *                             If no container specified, to global.
 *     opt {
 *         isEnd: boolean,
 *         removeOnClick: boolean
 *     }
 */

var BrushController =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(BrushController, _super);

  function BrushController(zr) {
    var _this = _super.call(this) || this;
    /**
     * @internal
     */


    _this._track = [];
    /**
     * @internal
     */

    _this._covers = [];
    _this._handlers = {};

    if (true) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)(zr);
    }

    _this._zr = zr;
    _this.group = new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default();
    _this._uid = 'brushController_' + baseUID++;
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(pointerHandlers, function (handler, eventName) {
      this._handlers[eventName] = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind)(handler, this);
    }, _this);
    return _this;
  }
  /**
   * If set to `false`, select disabled.
   */


  BrushController.prototype.enableBrush = function (brushOption) {
    if (true) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this._mounted);
    }

    this._brushType && this._doDisableBrush();
    brushOption.brushType && this._doEnableBrush(brushOption);
    return this;
  };

  BrushController.prototype._doEnableBrush = function (brushOption) {
    var zr = this._zr; // Consider roam, which takes globalPan too.

    if (!this._enableGlobalPan) {
      _interactionMutex__WEBPACK_IMPORTED_MODULE_3__.take(zr, MUTEX_RESOURCE_KEY, this._uid);
    }

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(this._handlers, function (handler, eventName) {
      zr.on(eventName, handler);
    });
    this._brushType = brushOption.brushType;
    this._brushOption = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge)((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone)(DEFAULT_BRUSH_OPT), brushOption, true);
  };

  BrushController.prototype._doDisableBrush = function () {
    var zr = this._zr;
    _interactionMutex__WEBPACK_IMPORTED_MODULE_3__.release(zr, MUTEX_RESOURCE_KEY, this._uid);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(this._handlers, function (handler, eventName) {
      zr.off(eventName, handler);
    });
    this._brushType = this._brushOption = null;
  };
  /**
   * @param panelOpts If not pass, it is global brush.
   */


  BrushController.prototype.setPanels = function (panelOpts) {
    if (panelOpts && panelOpts.length) {
      var panels_1 = this._panels = {};
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(panelOpts, function (panelOpts) {
        panels_1[panelOpts.panelId] = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone)(panelOpts);
      });
    } else {
      this._panels = null;
    }

    return this;
  };

  BrushController.prototype.mount = function (opt) {
    opt = opt || {};

    if (true) {
      this._mounted = true; // should be at first.
    }

    this._enableGlobalPan = opt.enableGlobalPan;
    var thisGroup = this.group;

    this._zr.add(thisGroup);

    thisGroup.attr({
      x: opt.x || 0,
      y: opt.y || 0,
      rotation: opt.rotation || 0,
      scaleX: opt.scaleX || 1,
      scaleY: opt.scaleY || 1
    });
    this._transform = thisGroup.getLocalTransform();
    return this;
  }; // eachCover(cb, context): void {
  //     each(this._covers, cb, context);
  // }

  /**
   * Update covers.
   * @param coverConfigList
   *        If coverConfigList is null/undefined, all covers removed.
   */


  BrushController.prototype.updateCovers = function (coverConfigList) {
    if (true) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this._mounted);
    }

    coverConfigList = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map)(coverConfigList, function (coverConfig) {
      return (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge)((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone)(DEFAULT_BRUSH_OPT), coverConfig, true);
    });
    var tmpIdPrefix = '\0-brush-index-';
    var oldCovers = this._covers;
    var newCovers = this._covers = [];
    var controller = this;
    var creatingCover = this._creatingCover;
    new _data_DataDiffer__WEBPACK_IMPORTED_MODULE_4__.default(oldCovers, coverConfigList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();
    return this;

    function getKey(brushOption, index) {
      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;
    }

    function oldGetKey(cover, index) {
      return getKey(cover.__brushOption, index);
    }

    function addOrUpdate(newIndex, oldIndex) {
      var newBrushInternal = coverConfigList[newIndex]; // Consider setOption in event listener of brushSelect,
      // where updating cover when creating should be forbiden.

      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
        newCovers[newIndex] = oldCovers[oldIndex];
      } else {
        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushInternal, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushInternal));
        updateCoverAfterCreation(controller, cover);
      }
    }

    function remove(oldIndex) {
      if (oldCovers[oldIndex] !== creatingCover) {
        controller.group.remove(oldCovers[oldIndex]);
      }
    }
  };

  BrushController.prototype.unmount = function () {
    if (true) {
      if (!this._mounted) {
        return;
      }
    }

    this.enableBrush(false); // container may 'removeAll' outside.

    clearCovers(this);

    this._zr.remove(this.group);

    if (true) {
      this._mounted = false; // should be at last.
    }

    return this;
  };

  BrushController.prototype.dispose = function () {
    this.unmount();
    this.off();
  };

  return BrushController;
}(zrender_lib_core_Eventful__WEBPACK_IMPORTED_MODULE_5__.default);

function createCover(controller, brushOption) {
  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
  cover.__brushOption = brushOption;
  updateZ(cover, brushOption);
  controller.group.add(cover);
  return cover;
}

function endCreating(controller, creatingCover) {
  var coverRenderer = getCoverRenderer(creatingCover);

  if (coverRenderer.endCreating) {
    coverRenderer.endCreating(controller, creatingCover);
    updateZ(creatingCover, creatingCover.__brushOption);
  }

  return creatingCover;
}

function updateCoverShape(controller, cover) {
  var brushOption = cover.__brushOption;
  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
}

function updateZ(cover, brushOption) {
  var z = brushOption.z;
  z == null && (z = COVER_Z);
  cover.traverse(function (el) {
    el.z = z;
    el.z2 = z; // Consider in given container.
  });
}

function updateCoverAfterCreation(controller, cover) {
  getCoverRenderer(cover).updateCommon(controller, cover);
  updateCoverShape(controller, cover);
}

function getCoverRenderer(cover) {
  return coverRenderers[cover.__brushOption.brushType];
} // return target panel or `true` (means global panel)


function getPanelByPoint(controller, e, localCursorPoint) {
  var panels = controller._panels;

  if (!panels) {
    return BRUSH_PANEL_GLOBAL; // Global panel
  }

  var panel;
  var transform = controller._transform;
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(panels, function (pn) {
    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);
  });
  return panel;
} // Return a panel or true


function getPanelByCover(controller, cover) {
  var panels = controller._panels;

  if (!panels) {
    return BRUSH_PANEL_GLOBAL; // Global panel
  }

  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,
  // which is then treated as global panel.

  return panelId != null ? panels[panelId] : BRUSH_PANEL_GLOBAL;
}

function clearCovers(controller) {
  var covers = controller._covers;
  var originalLength = covers.length;
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(covers, function (cover) {
    controller.group.remove(cover);
  }, controller);
  covers.length = 0;
  return !!originalLength;
}

function trigger(controller, opt) {
  var areas = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map)(controller._covers, function (cover) {
    var brushOption = cover.__brushOption;
    var range = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone)(brushOption.range);
    return {
      brushType: brushOption.brushType,
      panelId: brushOption.panelId,
      range: range
    };
  });
  controller.trigger('brush', {
    areas: areas,
    isEnd: !!opt.isEnd,
    removeOnClick: !!opt.removeOnClick
  });
}

function shouldShowCover(controller) {
  var track = controller._track;

  if (!track.length) {
    return false;
  }

  var p2 = track[track.length - 1];
  var p1 = track[0];
  var dx = p2[0] - p1[0];
  var dy = p2[1] - p1[1];
  var dist = mathPow(dx * dx + dy * dy, 0.5);
  return dist > UNSELECT_THRESHOLD;
}

function getTrackEnds(track) {
  var tail = track.length - 1;
  tail < 0 && (tail = 0);
  return [track[0], track[tail]];
}

;

function createBaseRectCover(rectRangeConverter, controller, brushOption, edgeNameSequences) {
  var cover = new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default();
  cover.add(new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default({
    name: 'main',
    style: makeStyle(brushOption),
    silent: true,
    draggable: true,
    cursor: 'move',
    drift: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry)(driftRect, rectRangeConverter, controller, cover, ['n', 's', 'w', 'e']),
    ondragend: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry)(trigger, controller, {
      isEnd: true
    })
  }));
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(edgeNameSequences, function (nameSequence) {
    cover.add(new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default({
      name: nameSequence.join(''),
      style: {
        opacity: 0
      },
      draggable: true,
      silent: true,
      invisible: true,
      drift: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry)(driftRect, rectRangeConverter, controller, cover, nameSequence),
      ondragend: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry)(trigger, controller, {
        isEnd: true
      })
    }));
  });
  return cover;
}

function updateBaseRect(controller, cover, localRange, brushOption) {
  var lineWidth = brushOption.brushStyle.lineWidth || 0;
  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);
  var x = localRange[0][0];
  var y = localRange[1][0];
  var xa = x - lineWidth / 2;
  var ya = y - lineWidth / 2;
  var x2 = localRange[0][1];
  var y2 = localRange[1][1];
  var x2a = x2 - handleSize + lineWidth / 2;
  var y2a = y2 - handleSize + lineWidth / 2;
  var width = x2 - x;
  var height = y2 - y;
  var widtha = width + lineWidth;
  var heighta = height + lineWidth;
  updateRectShape(controller, cover, 'main', x, y, width, height);

  if (brushOption.transformable) {
    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);
    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);
    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);
    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);
    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);
    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);
    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);
    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);
  }
}

function updateCommon(controller, cover) {
  var brushOption = cover.__brushOption;
  var transformable = brushOption.transformable;
  var mainEl = cover.childAt(0);
  mainEl.useStyle(makeStyle(brushOption));
  mainEl.attr({
    silent: !transformable,
    cursor: transformable ? 'move' : 'default'
  });
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)([['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']], function (nameSequence) {
    var el = cover.childOfName(nameSequence.join(''));
    var globalDir = nameSequence.length === 1 ? getGlobalDirection1(controller, nameSequence[0]) : getGlobalDirection2(controller, nameSequence);
    el && el.attr({
      silent: !transformable,
      invisible: !transformable,
      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null
    });
  });
}

function updateRectShape(controller, cover, name, x, y, w, h) {
  var el = cover.childOfName(name);
  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));
}

function makeStyle(brushOption) {
  return (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults)({
    strokeNoScale: true
  }, brushOption.brushStyle);
}

function formatRectRange(x, y, x2, y2) {
  var min = [mathMin(x, x2), mathMin(y, y2)];
  var max = [mathMax(x, x2), mathMax(y, y2)];
  return [[min[0], max[0]], [min[1], max[1]] // y range
  ];
}

function getTransform(controller) {
  return _util_graphic__WEBPACK_IMPORTED_MODULE_7__.getTransform(controller.group);
}

function getGlobalDirection1(controller, localDirName) {
  var map = {
    w: 'left',
    e: 'right',
    n: 'top',
    s: 'bottom'
  };
  var inverseMap = {
    left: 'w',
    right: 'e',
    top: 'n',
    bottom: 's'
  };
  var dir = _util_graphic__WEBPACK_IMPORTED_MODULE_7__.transformDirection(map[localDirName], getTransform(controller));
  return inverseMap[dir];
}

function getGlobalDirection2(controller, localDirNameSeq) {
  var globalDir = [getGlobalDirection1(controller, localDirNameSeq[0]), getGlobalDirection1(controller, localDirNameSeq[1])];
  (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();
  return globalDir.join('');
}

function driftRect(rectRangeConverter, controller, cover, dirNameSequence, dx, dy) {
  var brushOption = cover.__brushOption;
  var rectRange = rectRangeConverter.toRectRange(brushOption.range);
  var localDelta = toLocalDelta(controller, dx, dy);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(dirNameSequence, function (dirName) {
    var ind = DIRECTION_MAP[dirName];
    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
  });
  brushOption.range = rectRangeConverter.fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
  updateCoverAfterCreation(controller, cover);
  trigger(controller, {
    isEnd: false
  });
}

function driftPolygon(controller, cover, dx, dy) {
  var range = cover.__brushOption.range;
  var localDelta = toLocalDelta(controller, dx, dy);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(range, function (point) {
    point[0] += localDelta[0];
    point[1] += localDelta[1];
  });
  updateCoverAfterCreation(controller, cover);
  trigger(controller, {
    isEnd: false
  });
}

function toLocalDelta(controller, dx, dy) {
  var thisGroup = controller.group;
  var localD = thisGroup.transformCoordToLocal(dx, dy);
  var localZero = thisGroup.transformCoordToLocal(0, 0);
  return [localD[0] - localZero[0], localD[1] - localZero[1]];
}

function clipByPanel(controller, cover, data) {
  var panel = getPanelByCover(controller, cover);
  return panel && panel !== BRUSH_PANEL_GLOBAL ? panel.clipPath(data, controller._transform) : (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone)(data);
}

function pointsToRect(points) {
  var xmin = mathMin(points[0][0], points[1][0]);
  var ymin = mathMin(points[0][1], points[1][1]);
  var xmax = mathMax(points[0][0], points[1][0]);
  var ymax = mathMax(points[0][1], points[1][1]);
  return {
    x: xmin,
    y: ymin,
    width: xmax - xmin,
    height: ymax - ymin
  };
}

function resetCursor(controller, e, localCursorPoint) {
  if ( // Check active
  !controller._brushType // resetCursor should be always called when mouse is in zr area,
  // but not called when mouse is out of zr area to avoid bad influence
  // if `mousemove`, `mouseup` are triggered from `document` event.
  || isOutsideZrArea(controller, e.offsetX, e.offsetY)) {
    return;
  }

  var zr = controller._zr;
  var covers = controller._covers;
  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.

  if (!controller._dragging) {
    for (var i = 0; i < covers.length; i++) {
      var brushOption = covers[i].__brushOption;

      if (currPanel && (currPanel === BRUSH_PANEL_GLOBAL || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {
        // Use cursor style set on cover.
        return;
      }
    }
  }

  currPanel && zr.setCursorStyle('crosshair');
}

function preventDefault(e) {
  var rawE = e.event;
  rawE.preventDefault && rawE.preventDefault();
}

function mainShapeContain(cover, x, y) {
  return cover.childOfName('main').contain(x, y);
}

function updateCoverByMouse(controller, e, localCursorPoint, isEnd) {
  var creatingCover = controller._creatingCover;
  var panel = controller._creatingPanel;
  var thisBrushOption = controller._brushOption;
  var eventParams;

  controller._track.push(localCursorPoint.slice());

  if (shouldShowCover(controller) || creatingCover) {
    if (panel && !creatingCover) {
      thisBrushOption.brushMode === 'single' && clearCovers(controller);
      var brushOption = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone)(thisBrushOption);
      brushOption.brushType = determineBrushType(brushOption.brushType, panel);
      brushOption.panelId = panel === BRUSH_PANEL_GLOBAL ? null : panel.panelId;
      creatingCover = controller._creatingCover = createCover(controller, brushOption);

      controller._covers.push(creatingCover);
    }

    if (creatingCover) {
      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
      var coverBrushOption = creatingCover.__brushOption;
      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));

      if (isEnd) {
        endCreating(controller, creatingCover);
        coverRenderer.updateCommon(controller, creatingCover);
      }

      updateCoverShape(controller, creatingCover);
      eventParams = {
        isEnd: isEnd
      };
    }
  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {
    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.
    // But a single click do not clear covers, because user may have casual
    // clicks (for example, click on other component and do not expect covers
    // disappear).
    // Only some cover removed, trigger action, but not every click trigger action.
    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {
      eventParams = {
        isEnd: isEnd,
        removeOnClick: true
      };
    }
  }

  return eventParams;
}

function determineBrushType(brushType, panel) {
  if (brushType === 'auto') {
    if (true) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)(panel && panel.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"');
    }

    return panel.defaultBrushType;
  }

  return brushType;
}

var pointerHandlers = {
  mousedown: function (e) {
    if (this._dragging) {
      // In case some browser do not support globalOut,
      // and release mouse out side the browser.
      handleDragEnd(this, e);
    } else if (!e.target || !e.target.draggable) {
      preventDefault(e);
      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
      this._creatingCover = null;
      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);

      if (panel) {
        this._dragging = true;
        this._track = [localCursorPoint.slice()];
      }
    }
  },
  mousemove: function (e) {
    var x = e.offsetX;
    var y = e.offsetY;
    var localCursorPoint = this.group.transformCoordToLocal(x, y);
    resetCursor(this, e, localCursorPoint);

    if (this._dragging) {
      preventDefault(e);
      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);
      eventParams && trigger(this, eventParams);
    }
  },
  mouseup: function (e) {
    handleDragEnd(this, e);
  }
};

function handleDragEnd(controller, e) {
  if (controller._dragging) {
    preventDefault(e);
    var x = e.offsetX;
    var y = e.offsetY;
    var localCursorPoint = controller.group.transformCoordToLocal(x, y);
    var eventParams = updateCoverByMouse(controller, e, localCursorPoint, true);
    controller._dragging = false;
    controller._track = [];
    controller._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.

    eventParams && trigger(controller, eventParams);
  }
}

function isOutsideZrArea(controller, x, y) {
  var zr = controller._zr;
  return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();
}
/**
 * key: brushType
 */


var coverRenderers = {
  lineX: getLineRenderer(0),
  lineY: getLineRenderer(1),
  rect: {
    createCover: function (controller, brushOption) {
      function returnInput(range) {
        return range;
      }

      return createBaseRectCover({
        toRectRange: returnInput,
        fromRectRange: returnInput
      }, controller, brushOption, [['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']]);
    },
    getCreatingRange: function (localTrack) {
      var ends = getTrackEnds(localTrack);
      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
    },
    updateCoverShape: function (controller, cover, localRange, brushOption) {
      updateBaseRect(controller, cover, localRange, brushOption);
    },
    updateCommon: updateCommon,
    contain: mainShapeContain
  },
  polygon: {
    createCover: function (controller, brushOption) {
      var cover = new _util_graphic__WEBPACK_IMPORTED_MODULE_2__.default(); // Do not use graphic.Polygon because graphic.Polyline do not close the
      // border of the shape when drawing, which is a better experience for user.

      cover.add(new _util_graphic__WEBPACK_IMPORTED_MODULE_8__.default({
        name: 'main',
        style: makeStyle(brushOption),
        silent: true
      }));
      return cover;
    },
    getCreatingRange: function (localTrack) {
      return localTrack;
    },
    endCreating: function (controller, cover) {
      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.

      cover.add(new _util_graphic__WEBPACK_IMPORTED_MODULE_9__.default({
        name: 'main',
        draggable: true,
        drift: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry)(driftPolygon, controller, cover),
        ondragend: (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.curry)(trigger, controller, {
          isEnd: true
        })
      }));
    },
    updateCoverShape: function (controller, cover, localRange, brushOption) {
      cover.childAt(0).setShape({
        points: clipByPanel(controller, cover, localRange)
      });
    },
    updateCommon: updateCommon,
    contain: mainShapeContain
  }
};

function getLineRenderer(xyIndex) {
  return {
    createCover: function (controller, brushOption) {
      return createBaseRectCover({
        toRectRange: function (range) {
          var rectRange = [range, [0, 100]];
          xyIndex && rectRange.reverse();
          return rectRange;
        },
        fromRectRange: function (rectRange) {
          return rectRange[xyIndex];
        }
      }, controller, brushOption, [[['w'], ['e']], [['n'], ['s']]][xyIndex]);
    },
    getCreatingRange: function (localTrack) {
      var ends = getTrackEnds(localTrack);
      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);
      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);
      return [min, max];
    },
    updateCoverShape: function (controller, cover, localRange, brushOption) {
      var otherExtent; // If brushWidth not specified, fit the panel.

      var panel = getPanelByCover(controller, cover);

      if (panel !== BRUSH_PANEL_GLOBAL && panel.getLinearBrushOtherExtent) {
        otherExtent = panel.getLinearBrushOtherExtent(xyIndex);
      } else {
        var zr = controller._zr;
        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
      }

      var rectRange = [localRange, otherExtent];
      xyIndex && rectRange.reverse();
      updateBaseRect(controller, cover, rectRange, brushOption);
    },
    updateCommon: updateCommon,
    contain: mainShapeContain
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BrushController);

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/MapDraw.js":
/*!**************************************************************!*\
  !*** ./node_modules/echarts/lib/component/helper/MapDraw.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _RoamController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RoamController */ "./node_modules/echarts/lib/component/helper/RoamController.js");
/* harmony import */ var _component_helper_roamHelper__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../component/helper/roamHelper */ "./node_modules/echarts/lib/component/helper/roamHelper.js");
/* harmony import */ var _component_helper_cursorHelper__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../component/helper/cursorHelper */ "./node_modules/echarts/lib/component/helper/cursorHelper.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/CompoundPath.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polygon.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/Text.js");
/* harmony import */ var _util_states__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/states */ "./node_modules/echarts/lib/util/states.js");
/* harmony import */ var _coord_geo_geoSourceManager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../coord/geo/geoSourceManager */ "./node_modules/echarts/lib/coord/geo/geoSourceManager.js");
/* harmony import */ var _util_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/component */ "./node_modules/echarts/lib/util/component.js");
/* harmony import */ var zrender_lib_core_Transformable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/Transformable */ "./node_modules/zrender/lib/core/Transformable.js");
/* harmony import */ var _label_labelStyle__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../label/labelStyle */ "./node_modules/echarts/lib/label/labelStyle.js");
/* harmony import */ var _util_innerStore__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../util/innerStore */ "./node_modules/echarts/lib/util/innerStore.js");
/* harmony import */ var _util_decal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/decal */ "./node_modules/echarts/lib/util/decal.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/













function getFixedItemStyle(model) {
  var itemStyle = model.getItemStyle();
  var areaColor = model.get('areaColor'); // If user want the color not to be changed when hover,
  // they should both set areaColor and color to be null.

  if (areaColor != null) {
    itemStyle.fill = areaColor;
  }

  return itemStyle;
}

var MapDraw =
/** @class */
function () {
  function MapDraw(api) {
    var group = new _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default();
    this.uid = (0,_util_component__WEBPACK_IMPORTED_MODULE_1__.getUID)('ec_map_draw'); // @ts-ignore FIXME:TS

    this._controller = new _RoamController__WEBPACK_IMPORTED_MODULE_2__.default(api.getZr());
    this._controllerHost = {
      target: group
    };
    this.group = group;
    group.add(this._regionsGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default());
    group.add(this._backgroundGroup = new _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default());
  }

  MapDraw.prototype.draw = function (mapOrGeoModel, ecModel, api, fromView, payload) {
    var isGeo = mapOrGeoModel.mainType === 'geo'; // Map series has data. GEO model that controlled by map series
    // will be assigned with map data. Other GEO model has no data.

    var data = mapOrGeoModel.getData && mapOrGeoModel.getData();
    isGeo && ecModel.eachComponent({
      mainType: 'series',
      subType: 'map'
    }, function (mapSeries) {
      if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {
        data = mapSeries.getData();
      }
    });
    var geo = mapOrGeoModel.coordinateSystem;

    this._updateBackground(geo);

    var regionsGroup = this._regionsGroup;
    var group = this.group;
    var transformInfo = geo.getTransformInfo(); // No animation when first draw or in action

    var isFirstDraw = !regionsGroup.childAt(0) || payload;
    var targetScaleX;
    var targetScaleY;

    if (isFirstDraw) {
      group.transform = transformInfo.roamTransform;
      group.decomposeTransform();
      group.dirty();
    } else {
      var target = new zrender_lib_core_Transformable__WEBPACK_IMPORTED_MODULE_3__.default();
      target.transform = transformInfo.roamTransform;
      target.decomposeTransform();
      var props = {
        scaleX: target.scaleX,
        scaleY: target.scaleY,
        x: target.x,
        y: target.y
      };
      targetScaleX = target.scaleX;
      targetScaleY = target.scaleY;
      _util_graphic__WEBPACK_IMPORTED_MODULE_4__.updateProps(group, props, mapOrGeoModel);
    }

    regionsGroup.removeAll();
    var nameMap = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.createHashMap();
    var isVisualEncodedByVisualMap = data && data.getVisual('visualMeta') && data.getVisual('visualMeta').length > 0;
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.each(geo.regions, function (region) {
      // Consider in GeoJson properties.name may be duplicated, for example,
      // there is multiple region named "United Kindom" or "France" (so many
      // colonies). And it is not appropriate to merge them in geo, which
      // will make them share the same label and bring trouble in label
      // location calculation.
      var regionGroup = nameMap.get(region.name) || nameMap.set(region.name, new _util_graphic__WEBPACK_IMPORTED_MODULE_0__.default());
      var compoundPath = new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default({
        segmentIgnoreThreshold: 1,
        shape: {
          paths: []
        }
      });
      regionGroup.add(compoundPath);
      var regionModel = mapOrGeoModel.getRegionModel(region.name) || mapOrGeoModel; // @ts-ignore FIXME:TS fix the "compatible with each other"?

      var itemStyleModel = regionModel.getModel('itemStyle'); // @ts-ignore FIXME:TS fix the "compatible with each other"?

      var emphasisModel = regionModel.getModel('emphasis');
      var emphasisItemStyleModel = emphasisModel.getModel('itemStyle'); // @ts-ignore FIXME:TS fix the "compatible with each other"?

      var blurItemStyleModel = regionModel.getModel(['blur', 'itemStyle']); // @ts-ignore FIXME:TS fix the "compatible with each other"?

      var selectItemStyleModel = regionModel.getModel(['select', 'itemStyle']); // NOTE: DONT use 'style' in visual when drawing map.
      // This component is used for drawing underlying map for both geo component and map series.

      var itemStyle = getFixedItemStyle(itemStyleModel);
      var emphasisItemStyle = getFixedItemStyle(emphasisItemStyleModel);
      var blurItemStyle = getFixedItemStyle(blurItemStyleModel);
      var selectItemStyle = getFixedItemStyle(selectItemStyleModel);
      var dataIdx; // Use the itemStyle in data if has data

      if (data) {
        dataIdx = data.indexOfName(region.name); // Only visual color of each item will be used. It can be encoded by visualMap
        // But visual color of series is used in symbol drawing
        //
        // Visual color for each series is for the symbol draw

        var style = data.getItemVisual(dataIdx, 'style');
        var decal = data.getItemVisual(dataIdx, 'decal');

        if (isVisualEncodedByVisualMap && style.fill) {
          itemStyle.fill = style.fill;
        }

        if (decal) {
          itemStyle.decal = (0,_util_decal__WEBPACK_IMPORTED_MODULE_7__.createOrUpdatePatternFromDecal)(decal, api);
        }
      }

      var sx = transformInfo.rawScaleX;
      var sy = transformInfo.rawScaleY;
      var offsetX = transformInfo.rawX;
      var offsetY = transformInfo.rawY;

      var transformPoint = function (point) {
        return [point[0] * sx + offsetX, point[1] * sy + offsetY];
      };

      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.each(region.geometries, function (geometry) {
        if (geometry.type !== 'polygon') {
          return;
        }

        var points = [];

        for (var i = 0; i < geometry.exterior.length; ++i) {
          points.push(transformPoint(geometry.exterior[i]));
        }

        compoundPath.shape.paths.push(new _util_graphic__WEBPACK_IMPORTED_MODULE_8__.default({
          segmentIgnoreThreshold: 1,
          shape: {
            points: points
          }
        }));

        for (var i = 0; i < (geometry.interiors ? geometry.interiors.length : 0); ++i) {
          var interior = geometry.interiors[i];
          var points_1 = [];

          for (var j = 0; j < interior.length; ++j) {
            points_1.push(transformPoint(interior[j]));
          }

          compoundPath.shape.paths.push(new _util_graphic__WEBPACK_IMPORTED_MODULE_8__.default({
            segmentIgnoreThreshold: 1,
            shape: {
              points: points_1
            }
          }));
        }
      });
      compoundPath.setStyle(itemStyle);
      compoundPath.style.strokeNoScale = true;
      compoundPath.culling = true;
      compoundPath.ensureState('emphasis').style = emphasisItemStyle;
      compoundPath.ensureState('blur').style = blurItemStyle;
      compoundPath.ensureState('select').style = selectItemStyle;
      var showLabel = false;

      for (var i = 0; i < _util_states__WEBPACK_IMPORTED_MODULE_9__.DISPLAY_STATES.length; i++) {
        var stateName = _util_states__WEBPACK_IMPORTED_MODULE_9__.DISPLAY_STATES[i]; // @ts-ignore FIXME:TS fix the "compatible with each other"?

        if (regionModel.get(stateName === 'normal' ? ['label', 'show'] : [stateName, 'label', 'show'])) {
          showLabel = true;
          break;
        }
      }

      var isDataNaN = data && isNaN(data.get(data.mapDimension('value'), dataIdx));
      var itemLayout = data && data.getItemLayout(dataIdx); // In the following cases label will be drawn
      // 1. In map series and data value is NaN
      // 2. In geo component
      // 4. Region has no series legendSymbol, which will be add a showLabel flag in mapSymbolLayout

      if (isGeo || isDataNaN && showLabel || itemLayout && itemLayout.showLabel) {
        var query = !isGeo ? dataIdx : region.name;
        var labelFetcher = void 0; // Consider dataIdx not found.

        if (!data || dataIdx >= 0) {
          labelFetcher = mapOrGeoModel;
        }

        var centerPt = transformPoint(region.center);
        var textEl = new _util_graphic__WEBPACK_IMPORTED_MODULE_10__.default({
          x: centerPt[0],
          y: centerPt[1],
          // FIXME
          // label rotation is not support yet in geo or regions of series-map
          // that has no data. The rotation will be effected by this `scale`.
          // So needed to change to RectText?
          scaleX: 1 / group.scaleX,
          scaleY: 1 / group.scaleY,
          z2: 10,
          silent: true
        });
        (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_11__.setLabelStyle)(textEl, (0,_label_labelStyle__WEBPACK_IMPORTED_MODULE_11__.getLabelStatesModels)(regionModel), {
          labelFetcher: labelFetcher,
          labelDataIndex: query,
          defaultText: region.name
        }, {
          normal: {
            align: 'center',
            verticalAlign: 'middle'
          }
        });
        compoundPath.setTextContent(textEl);
        compoundPath.setTextConfig({
          local: true
        });
        compoundPath.disableLabelAnimation = true;

        if (!isFirstDraw) {
          // Text animation
          _util_graphic__WEBPACK_IMPORTED_MODULE_4__.updateProps(textEl, {
            scaleX: 1 / targetScaleX,
            scaleY: 1 / targetScaleY
          }, mapOrGeoModel);
        }
      } // setItemGraphicEl, setHoverStyle after all polygons and labels
      // are added to the rigionGroup


      if (data) {
        data.setItemGraphicEl(dataIdx, regionGroup);
      } else {
        var regionModel_1 = mapOrGeoModel.getRegionModel(region.name); // Package custom mouse event for geo component

        (0,_util_innerStore__WEBPACK_IMPORTED_MODULE_12__.getECData)(compoundPath).eventData = {
          componentType: 'geo',
          componentIndex: mapOrGeoModel.componentIndex,
          geoIndex: mapOrGeoModel.componentIndex,
          name: region.name,
          region: regionModel_1 && regionModel_1.option || {}
        };
      }

      var groupRegions = regionGroup.__regions || (regionGroup.__regions = []);
      groupRegions.push(region); // @ts-ignore FIXME:TS fix the "compatible with each other"?

      regionGroup.highDownSilentOnTouch = !!mapOrGeoModel.get('selectedMode');
      (0,_util_states__WEBPACK_IMPORTED_MODULE_9__.enableHoverEmphasis)(regionGroup, emphasisModel.get('focus'), emphasisModel.get('blurScope'));
      regionsGroup.add(regionGroup);
    });

    this._updateController(mapOrGeoModel, ecModel, api);

    this._updateMapSelectHandler(mapOrGeoModel, regionsGroup, api, fromView);
  };

  MapDraw.prototype.remove = function () {
    this._regionsGroup.removeAll();

    this._backgroundGroup.removeAll();

    this._controller.dispose();

    this._mapName && _coord_geo_geoSourceManager__WEBPACK_IMPORTED_MODULE_13__.default.removeGraphic(this._mapName, this.uid);
    this._mapName = null;
    this._controllerHost = null;
  };

  MapDraw.prototype._updateBackground = function (geo) {
    var mapName = geo.map;

    if (this._mapName !== mapName) {
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.each(_coord_geo_geoSourceManager__WEBPACK_IMPORTED_MODULE_13__.default.makeGraphic(mapName, this.uid), function (root) {
        this._backgroundGroup.add(root);
      }, this);
    }

    this._mapName = mapName;
  };

  MapDraw.prototype._updateController = function (mapOrGeoModel, ecModel, api) {
    var geo = mapOrGeoModel.coordinateSystem;
    var controller = this._controller;
    var controllerHost = this._controllerHost; // @ts-ignore FIXME:TS

    controllerHost.zoomLimit = mapOrGeoModel.get('scaleLimit');
    controllerHost.zoom = geo.getZoom(); // roamType is will be set default true if it is null
    // @ts-ignore FIXME:TS

    controller.enable(mapOrGeoModel.get('roam') || false);
    var mainType = mapOrGeoModel.mainType;

    function makeActionBase() {
      var action = {
        type: 'geoRoam',
        componentType: mainType
      };
      action[mainType + 'Id'] = mapOrGeoModel.id;
      return action;
    }

    controller.off('pan').on('pan', function (e) {
      this._mouseDownFlag = false;
      _component_helper_roamHelper__WEBPACK_IMPORTED_MODULE_14__.updateViewOnPan(controllerHost, e.dx, e.dy);
      api.dispatchAction(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.extend(makeActionBase(), {
        dx: e.dx,
        dy: e.dy
      }));
    }, this);
    controller.off('zoom').on('zoom', function (e) {
      this._mouseDownFlag = false;
      _component_helper_roamHelper__WEBPACK_IMPORTED_MODULE_14__.updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);
      api.dispatchAction(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.extend(makeActionBase(), {
        zoom: e.scale,
        originX: e.originX,
        originY: e.originY
      }));
      var group = this.group;

      this._regionsGroup.traverse(function (el) {
        var textContent = el.getTextContent();

        if (textContent) {
          textContent.scaleX = 1 / group.scaleX;
          textContent.scaleY = 1 / group.scaleY;
          textContent.markRedraw();
        }
      });
    }, this);
    controller.setPointerChecker(function (e, x, y) {
      return geo.getViewRectAfterRoam().contain(x, y) && !(0,_component_helper_cursorHelper__WEBPACK_IMPORTED_MODULE_15__.onIrrelevantElement)(e, api, mapOrGeoModel);
    });
  };

  MapDraw.prototype._updateMapSelectHandler = function (mapOrGeoModel, regionsGroup, api, fromView) {
    var mapDraw = this;
    regionsGroup.off('mousedown'); // @ts-ignore FIXME:TS resolve type conflict

    if (mapOrGeoModel.get('selectedMode')) {
      regionsGroup.on('mousedown', function () {
        mapDraw._mouseDownFlag = true;
      });
      regionsGroup.on('click', function (e) {
        if (!mapDraw._mouseDownFlag) {
          return;
        }

        mapDraw._mouseDownFlag = false;
      });
    }
  };

  return MapDraw;
}();

;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapDraw);

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/RoamController.js":
/*!*********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/helper/RoamController.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_Eventful__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/Eventful */ "./node_modules/zrender/lib/core/Eventful.js");
/* harmony import */ var zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/event */ "./node_modules/zrender/lib/core/event.js");
/* harmony import */ var _interactionMutex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interactionMutex */ "./node_modules/echarts/lib/component/helper/interactionMutex.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var RoamController =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(RoamController, _super);

  function RoamController(zr) {
    var _this = _super.call(this) || this;

    _this._zr = zr; // Avoid two roamController bind the same handler

    var mousedownHandler = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind)(_this._mousedownHandler, _this);
    var mousemoveHandler = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind)(_this._mousemoveHandler, _this);
    var mouseupHandler = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind)(_this._mouseupHandler, _this);
    var mousewheelHandler = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind)(_this._mousewheelHandler, _this);
    var pinchHandler = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind)(_this._pinchHandler, _this);
    /**
     * Notice: only enable needed types. For example, if 'zoom'
     * is not needed, 'zoom' should not be enabled, otherwise
     * default mousewheel behaviour (scroll page) will be disabled.
     */

    _this.enable = function (controlType, opt) {
      // Disable previous first
      this.disable();
      this._opt = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults)((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone)(opt) || {}, {
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        // By default, wheel do not trigger move.
        moveOnMouseWheel: false,
        preventDefaultMouseMove: true
      });

      if (controlType == null) {
        controlType = true;
      }

      if (controlType === true || controlType === 'move' || controlType === 'pan') {
        zr.on('mousedown', mousedownHandler);
        zr.on('mousemove', mousemoveHandler);
        zr.on('mouseup', mouseupHandler);
      }

      if (controlType === true || controlType === 'scale' || controlType === 'zoom') {
        zr.on('mousewheel', mousewheelHandler);
        zr.on('pinch', pinchHandler);
      }
    };

    _this.disable = function () {
      zr.off('mousedown', mousedownHandler);
      zr.off('mousemove', mousemoveHandler);
      zr.off('mouseup', mouseupHandler);
      zr.off('mousewheel', mousewheelHandler);
      zr.off('pinch', pinchHandler);
    };

    return _this;
  }

  RoamController.prototype.isDragging = function () {
    return this._dragging;
  };

  RoamController.prototype.isPinching = function () {
    return this._pinching;
  };

  RoamController.prototype.setPointerChecker = function (pointerChecker) {
    this.pointerChecker = pointerChecker;
  };

  RoamController.prototype.dispose = function () {
    this.disable();
  };

  RoamController.prototype._mousedownHandler = function (e) {
    if (zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_2__.isMiddleOrRightButtonOnMouseUpDown(e) || e.target && e.target.draggable) {
      return;
    }

    var x = e.offsetX;
    var y = e.offsetY; // Only check on mosedown, but not mousemove.
    // Mouse can be out of target when mouse moving.

    if (this.pointerChecker && this.pointerChecker(e, x, y)) {
      this._x = x;
      this._y = y;
      this._dragging = true;
    }
  };

  RoamController.prototype._mousemoveHandler = function (e) {
    if (!this._dragging || !isAvailableBehavior('moveOnMouseMove', e, this._opt) || e.gestureEvent === 'pinch' || _interactionMutex__WEBPACK_IMPORTED_MODULE_3__.isTaken(this._zr, 'globalPan')) {
      return;
    }

    var x = e.offsetX;
    var y = e.offsetY;
    var oldX = this._x;
    var oldY = this._y;
    var dx = x - oldX;
    var dy = y - oldY;
    this._x = x;
    this._y = y;
    this._opt.preventDefaultMouseMove && zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_2__.stop(e.event);
    trigger(this, 'pan', 'moveOnMouseMove', e, {
      dx: dx,
      dy: dy,
      oldX: oldX,
      oldY: oldY,
      newX: x,
      newY: y,
      isAvailableBehavior: null
    });
  };

  RoamController.prototype._mouseupHandler = function (e) {
    if (!zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_2__.isMiddleOrRightButtonOnMouseUpDown(e)) {
      this._dragging = false;
    }
  };

  RoamController.prototype._mousewheelHandler = function (e) {
    var shouldZoom = isAvailableBehavior('zoomOnMouseWheel', e, this._opt);
    var shouldMove = isAvailableBehavior('moveOnMouseWheel', e, this._opt);
    var wheelDelta = e.wheelDelta;
    var absWheelDeltaDelta = Math.abs(wheelDelta);
    var originX = e.offsetX;
    var originY = e.offsetY; // wheelDelta maybe -0 in chrome mac.

    if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
      return;
    } // If both `shouldZoom` and `shouldMove` is true, trigger
    // their event both, and the final behavior is determined
    // by event listener themselves.


    if (shouldZoom) {
      // Convenience:
      // Mac and VM Windows on Mac: scroll up: zoom out.
      // Windows: scroll up: zoom in.
      // FIXME: Should do more test in different environment.
      // wheelDelta is too complicated in difference nvironment
      // (https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel),
      // although it has been normallized by zrender.
      // wheelDelta of mouse wheel is bigger than touch pad.
      var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
      var scale = wheelDelta > 0 ? factor : 1 / factor;
      checkPointerAndTrigger(this, 'zoom', 'zoomOnMouseWheel', e, {
        scale: scale,
        originX: originX,
        originY: originY,
        isAvailableBehavior: null
      });
    }

    if (shouldMove) {
      // FIXME: Should do more test in different environment.
      var absDelta = Math.abs(wheelDelta); // wheelDelta of mouse wheel is bigger than touch pad.

      var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
      checkPointerAndTrigger(this, 'scrollMove', 'moveOnMouseWheel', e, {
        scrollDelta: scrollDelta,
        originX: originX,
        originY: originY,
        isAvailableBehavior: null
      });
    }
  };

  RoamController.prototype._pinchHandler = function (e) {
    if (_interactionMutex__WEBPACK_IMPORTED_MODULE_3__.isTaken(this._zr, 'globalPan')) {
      return;
    }

    var scale = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
    checkPointerAndTrigger(this, 'zoom', null, e, {
      scale: scale,
      originX: e.pinchX,
      originY: e.pinchY,
      isAvailableBehavior: null
    });
  };

  return RoamController;
}(zrender_lib_core_Eventful__WEBPACK_IMPORTED_MODULE_4__.default);

function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
  if (controller.pointerChecker && controller.pointerChecker(e, contollerEvent.originX, contollerEvent.originY)) {
    // When mouse is out of roamController rect,
    // default befavoius should not be be disabled, otherwise
    // page sliding is disabled, contrary to expectation.
    zrender_lib_core_event__WEBPACK_IMPORTED_MODULE_2__.stop(e.event);
    trigger(controller, eventName, behaviorToCheck, e, contollerEvent);
  }
}

function trigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
  // Also provide behavior checker for event listener, for some case that
  // multiple components share one listener.
  contollerEvent.isAvailableBehavior = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind)(isAvailableBehavior, null, behaviorToCheck, e);
  controller.trigger(eventName, contollerEvent);
} // settings: {
//     zoomOnMouseWheel
//     moveOnMouseMove
//     moveOnMouseWheel
// }
// The value can be: true / false / 'shift' / 'ctrl' / 'alt'.


function isAvailableBehavior(behaviorToCheck, e, settings) {
  var setting = settings[behaviorToCheck];
  return !behaviorToCheck || setting && (!(0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isString)(setting) || e.event[setting + 'Key']);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoamController);

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/brushHelper.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/helper/brushHelper.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeRectPanelClipPath": () => (/* binding */ makeRectPanelClipPath),
/* harmony export */   "makeLinearBrushOtherExtent": () => (/* binding */ makeLinearBrushOtherExtent),
/* harmony export */   "makeRectIsTargetByCursor": () => (/* binding */ makeRectIsTargetByCursor)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/BoundingRect */ "./node_modules/zrender/lib/core/BoundingRect.js");
/* harmony import */ var _cursorHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cursorHelper */ "./node_modules/echarts/lib/component/helper/cursorHelper.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function makeRectPanelClipPath(rect) {
  rect = normalizeRect(rect);
  return function (localPoints) {
    return _util_graphic__WEBPACK_IMPORTED_MODULE_0__.clipPointsByRect(localPoints, rect);
  };
}
function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
  rect = normalizeRect(rect);
  return function (xyIndex) {
    var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
    var brushWidth = idx ? rect.width : rect.height;
    var base = idx ? rect.x : rect.y;
    return [base, base + (brushWidth || 0)];
  };
}
function makeRectIsTargetByCursor(rect, api, targetModel) {
  var boundingRect = normalizeRect(rect);
  return function (e, localCursorPoint) {
    return boundingRect.contain(localCursorPoint[0], localCursorPoint[1]) && !(0,_cursorHelper__WEBPACK_IMPORTED_MODULE_1__.onIrrelevantElement)(e, api, targetModel);
  };
} // Consider width/height is negative.

function normalizeRect(rect) {
  return zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_2__.default.create(rect);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/cursorHelper.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/component/helper/cursorHelper.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "onIrrelevantElement": () => (/* binding */ onIrrelevantElement)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var IRRELEVANT_EXCLUDES = {
  'axisPointer': 1,
  'tooltip': 1,
  'brush': 1
};
/**
 * Avoid that: mouse click on a elements that is over geo or graph,
 * but roam is triggered.
 */

function onIrrelevantElement(e, api, targetCoordSysModel) {
  var model = api.getComponentByElement(e.topTarget); // If model is axisModel, it works only if it is injected with coordinateSystem.

  var coordSys = model && model.coordinateSystem;
  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES.hasOwnProperty(model.mainType) && coordSys && coordSys.model !== targetCoordSysModel;
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/interactionMutex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/helper/interactionMutex.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "take": () => (/* binding */ take),
/* harmony export */   "release": () => (/* binding */ release),
/* harmony export */   "isTaken": () => (/* binding */ isTaken)
/* harmony export */ });
/* harmony import */ var _core_echarts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/echarts */ "./node_modules/echarts/lib/core/echarts.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// @ts-nocheck

var ATTR = '\0_ec_interaction_mutex';
function take(zr, resourceKey, userKey) {
  var store = getStore(zr);
  store[resourceKey] = userKey;
}
function release(zr, resourceKey, userKey) {
  var store = getStore(zr);
  var uKey = store[resourceKey];

  if (uKey === userKey) {
    store[resourceKey] = null;
  }
}
function isTaken(zr, resourceKey) {
  return !!getStore(zr)[resourceKey];
}

function getStore(zr) {
  return zr[ATTR] || (zr[ATTR] = {});
}
/**
 * payload: {
 *     type: 'takeGlobalCursor',
 *     key: 'dataZoomSelect', or 'brush', or ...,
 *         If no userKey, release global cursor.
 * }
 */
// TODO: SELF REGISTERED.


_core_echarts__WEBPACK_IMPORTED_MODULE_0__.registerAction({
  type: 'takeGlobalCursor',
  event: 'globalCursorTaken',
  update: 'update'
}, function () {});

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/roamHelper.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/helper/roamHelper.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "updateViewOnPan": () => (/* binding */ updateViewOnPan),
/* harmony export */   "updateViewOnZoom": () => (/* binding */ updateViewOnZoom)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * For geo and graph.
 */
function updateViewOnPan(controllerHost, dx, dy) {
  var target = controllerHost.target;
  target.x += dx;
  target.y += dy;
  target.dirty();
}
/**
 * For geo and graph.
 */

function updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {
  var target = controllerHost.target;
  var zoomLimit = controllerHost.zoomLimit;
  var newZoom = controllerHost.zoom = controllerHost.zoom || 1;
  newZoom *= zoomDelta;

  if (zoomLimit) {
    var zoomMin = zoomLimit.min || 0;
    var zoomMax = zoomLimit.max || Infinity;
    newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);
  }

  var zoomScale = newZoom / controllerHost.zoom;
  controllerHost.zoom = newZoom; // Keep the mouse center when scaling

  target.x -= (zoomX - target.x) * (zoomScale - 1);
  target.y -= (zoomY - target.y) * (zoomScale - 1);
  target.scaleX *= zoomScale;
  target.scaleY *= zoomScale;
  target.dirty();
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/helper/sliderMove.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/helper/sliderMove.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sliderMove)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Calculate slider move result.
 * Usage:
 * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as
 * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.
 * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.
 *
 * @param delta Move length.
 * @param handleEnds handleEnds[0] can be bigger then handleEnds[1].
 *              handleEnds will be modified in this method.
 * @param extent handleEnds is restricted by extent.
 *              extent[0] should less or equals than extent[1].
 * @param handleIndex Can be 'all', means that both move the two handleEnds.
 * @param minSpan The range of dataZoom can not be smaller than that.
 *              If not set, handle0 and cross handle1. If set as a non-negative
 *              number (including `0`), handles will push each other when reaching
 *              the minSpan.
 * @param maxSpan The range of dataZoom can not be larger than that.
 * @return The input handleEnds.
 */
function sliderMove(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
  delta = delta || 0;
  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.

  if (minSpan != null) {
    minSpan = restrict(minSpan, [0, extentSpan]);
  }

  if (maxSpan != null) {
    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
  }

  if (handleIndex === 'all') {
    var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
    handleSpan = restrict(handleSpan, [0, extentSpan]);
    minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);
    handleIndex = 0;
  }

  handleEnds[0] = restrict(handleEnds[0], extent);
  handleEnds[1] = restrict(handleEnds[1], extent);
  var originalDistSign = getSpanSign(handleEnds, handleIndex);
  handleEnds[handleIndex] += delta; // Restrict in extent.

  var extentMinSpan = minSpan || 0;
  var realExtent = extent.slice();
  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.

  var currDistSign;
  currDistSign = getSpanSign(handleEnds, handleIndex);

  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
    // If minSpan exists, 'cross' is forbidden.
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
  } // Shrink span.


  currDistSign = getSpanSign(handleEnds, handleIndex);

  if (maxSpan != null && currDistSign.span > maxSpan) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
  }

  return handleEnds;
}

function getSpanSign(handleEnds, handleIndex) {
  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]
  // is at left of handleEnds[1] for non-cross case.

  return {
    span: Math.abs(dist),
    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1
  };
}

function restrict(value, extend) {
  return Math.min(extend[1] != null ? extend[1] : Infinity, Math.max(extend[0] != null ? extend[0] : -Infinity, value));
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/parallel/ParallelView.js":
/*!*********************************************************************!*\
  !*** ./node_modules/echarts/lib/component/parallel/ParallelView.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/throttle */ "./node_modules/echarts/lib/util/throttle.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var CLICK_THRESHOLD = 5; // > 4

var ParallelView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ParallelView, _super);

  function ParallelView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ParallelView.type;
    return _this;
  }

  ParallelView.prototype.render = function (parallelModel, ecModel, api) {
    this._model = parallelModel;
    this._api = api;

    if (!this._handlers) {
      this._handlers = {};
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(handlers, function (handler, eventName) {
        api.getZr().on(eventName, this._handlers[eventName] = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.bind)(handler, this));
      }, this);
    }

    (0,_util_throttle__WEBPACK_IMPORTED_MODULE_2__.createOrUpdate)(this, '_throttledDispatchExpand', parallelModel.get('axisExpandRate'), 'fixRate');
  };

  ParallelView.prototype.dispose = function (ecModel, api) {
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(this._handlers, function (handler, eventName) {
      api.getZr().off(eventName, handler);
    });
    this._handlers = null;
  };
  /**
   * @internal
   * @param {Object} [opt] If null, cancle the last action triggering for debounce.
   */


  ParallelView.prototype._throttledDispatchExpand = function (opt) {
    this._dispatchExpand(opt);
  };
  /**
   * @internal
   */


  ParallelView.prototype._dispatchExpand = function (opt) {
    opt && this._api.dispatchAction((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.extend)({
      type: 'parallelAxisExpand'
    }, opt));
  };

  ParallelView.type = 'parallel';
  return ParallelView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_3__.default);

var handlers = {
  mousedown: function (e) {
    if (checkTrigger(this, 'click')) {
      this._mouseDownPoint = [e.offsetX, e.offsetY];
    }
  },
  mouseup: function (e) {
    var mouseDownPoint = this._mouseDownPoint;

    if (checkTrigger(this, 'click') && mouseDownPoint) {
      var point = [e.offsetX, e.offsetY];
      var dist = Math.pow(mouseDownPoint[0] - point[0], 2) + Math.pow(mouseDownPoint[1] - point[1], 2);

      if (dist > CLICK_THRESHOLD) {
        return;
      }

      var result = this._model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]);

      result.behavior !== 'none' && this._dispatchExpand({
        axisExpandWindow: result.axisExpandWindow
      });
    }

    this._mouseDownPoint = null;
  },
  mousemove: function (e) {
    // Should do nothing when brushing.
    if (this._mouseDownPoint || !checkTrigger(this, 'mousemove')) {
      return;
    }

    var model = this._model;
    var result = model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]);
    var behavior = result.behavior;
    behavior === 'jump' && this._throttledDispatchExpand.debounceNextCall(model.get('axisExpandDebounce'));

    this._throttledDispatchExpand(behavior === 'none' ? null // Cancle the last trigger, in case that mouse slide out of the area quickly.
    : {
      axisExpandWindow: result.axisExpandWindow,
      // Jumping uses animation, and sliding suppresses animation.
      animation: behavior === 'jump' ? null : {
        duration: 0 // Disable animation.

      }
    });
  }
};

function checkTrigger(view, triggerOn) {
  var model = view._model;
  return model.get('axisExpandable') && model.get('axisExpandTriggerOn') === triggerOn;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ParallelView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/parallel/install.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/component/parallel/install.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _coord_parallel_parallelPreprocessor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../coord/parallel/parallelPreprocessor */ "./node_modules/echarts/lib/coord/parallel/parallelPreprocessor.js");
/* harmony import */ var _ParallelView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ParallelView */ "./node_modules/echarts/lib/component/parallel/ParallelView.js");
/* harmony import */ var _coord_parallel_ParallelModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../coord/parallel/ParallelModel */ "./node_modules/echarts/lib/coord/parallel/ParallelModel.js");
/* harmony import */ var _coord_parallel_parallelCreator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../coord/parallel/parallelCreator */ "./node_modules/echarts/lib/coord/parallel/parallelCreator.js");
/* harmony import */ var _coord_axisModelCreator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../coord/axisModelCreator */ "./node_modules/echarts/lib/coord/axisModelCreator.js");
/* harmony import */ var _coord_parallel_AxisModel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../coord/parallel/AxisModel */ "./node_modules/echarts/lib/coord/parallel/AxisModel.js");
/* harmony import */ var _axis_ParallelAxisView__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../axis/ParallelAxisView */ "./node_modules/echarts/lib/component/axis/ParallelAxisView.js");
/* harmony import */ var _axis_parallelAxisAction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../axis/parallelAxisAction */ "./node_modules/echarts/lib/component/axis/parallelAxisAction.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








var defaultAxisOption = {
  type: 'value',
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: 'rgba(160,197,232)',
    color: 'rgba(160,197,232)',
    opacity: 0.3
  },
  realtime: true,
  z: 10
};
function install(registers) {
  registers.registerComponentView(_ParallelView__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerComponentModel(_coord_parallel_ParallelModel__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerCoordinateSystem('parallel', _coord_parallel_parallelCreator__WEBPACK_IMPORTED_MODULE_2__.default);
  registers.registerPreprocessor(_coord_parallel_parallelPreprocessor__WEBPACK_IMPORTED_MODULE_3__.default);
  registers.registerComponentModel(_coord_parallel_AxisModel__WEBPACK_IMPORTED_MODULE_4__.default);
  registers.registerComponentView(_axis_ParallelAxisView__WEBPACK_IMPORTED_MODULE_5__.default);
  (0,_coord_axisModelCreator__WEBPACK_IMPORTED_MODULE_6__.default)(registers, 'parallel', _coord_parallel_AxisModel__WEBPACK_IMPORTED_MODULE_4__.default, defaultAxisOption);
  (0,_axis_parallelAxisAction__WEBPACK_IMPORTED_MODULE_7__.installParallelActions)(registers);
}

/***/ }),

/***/ "./node_modules/echarts/lib/component/radar/RadarView.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/component/radar/RadarView.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _axis_AxisBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../axis/AxisBuilder */ "./node_modules/echarts/lib/component/axis/AxisBuilder.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Circle.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Ring.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polyline.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/zrender/lib/graphic/shape/Polygon.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _view_Component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../view/Component */ "./node_modules/echarts/lib/view/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];

var RadarView =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(RadarView, _super);

  function RadarView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = RadarView.type;
    return _this;
  }

  RadarView.prototype.render = function (radarModel, ecModel, api) {
    var group = this.group;
    group.removeAll();

    this._buildAxes(radarModel);

    this._buildSplitLineAndArea(radarModel);
  };

  RadarView.prototype._buildAxes = function (radarModel) {
    var radar = radarModel.coordinateSystem;
    var indicatorAxes = radar.getIndicatorAxes();
    var axisBuilders = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map(indicatorAxes, function (indicatorAxis) {
      var axisBuilder = new _axis_AxisBuilder__WEBPACK_IMPORTED_MODULE_2__.default(indicatorAxis.model, {
        position: [radar.cx, radar.cy],
        rotation: indicatorAxis.angle,
        labelDirection: -1,
        tickDirection: -1,
        nameDirection: 1
      });
      return axisBuilder;
    });
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(axisBuilders, function (axisBuilder) {
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
      this.group.add(axisBuilder.getGroup());
    }, this);
  };

  RadarView.prototype._buildSplitLineAndArea = function (radarModel) {
    var radar = radarModel.coordinateSystem;
    var indicatorAxes = radar.getIndicatorAxes();

    if (!indicatorAxes.length) {
      return;
    }

    var shape = radarModel.get('shape');
    var splitLineModel = radarModel.getModel('splitLine');
    var splitAreaModel = radarModel.getModel('splitArea');
    var lineStyleModel = splitLineModel.getModel('lineStyle');
    var areaStyleModel = splitAreaModel.getModel('areaStyle');
    var showSplitLine = splitLineModel.get('show');
    var showSplitArea = splitAreaModel.get('show');
    var splitLineColors = lineStyleModel.get('color');
    var splitAreaColors = areaStyleModel.get('color');
    var splitLineColorsArr = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(splitLineColors) ? splitLineColors : [splitLineColors];
    var splitAreaColorsArr = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];
    var splitLines = [];
    var splitAreas = [];

    function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
      var colorIndex = idx % areaOrLineColorList.length;
      areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];
      return colorIndex;
    }

    if (shape === 'circle') {
      var ticksRadius = indicatorAxes[0].getTicksCoords();
      var cx = radar.cx;
      var cy = radar.cy;

      for (var i = 0; i < ticksRadius.length; i++) {
        if (showSplitLine) {
          var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);
          splitLines[colorIndex].push(new _util_graphic__WEBPACK_IMPORTED_MODULE_3__.default({
            shape: {
              cx: cx,
              cy: cy,
              r: ticksRadius[i].coord
            }
          }));
        }

        if (showSplitArea && i < ticksRadius.length - 1) {
          var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i);
          splitAreas[colorIndex].push(new _util_graphic__WEBPACK_IMPORTED_MODULE_4__.default({
            shape: {
              cx: cx,
              cy: cy,
              r0: ticksRadius[i].coord,
              r: ticksRadius[i + 1].coord
            }
          }));
        }
      }
    } // Polyyon
    else {
        var realSplitNumber_1;
        var axesTicksPoints = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map(indicatorAxes, function (indicatorAxis, idx) {
          var ticksCoords = indicatorAxis.getTicksCoords();
          realSplitNumber_1 = realSplitNumber_1 == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber_1);
          return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map(ticksCoords, function (tickCoord) {
            return radar.coordToPoint(tickCoord.coord, idx);
          });
        });
        var prevPoints = [];

        for (var i = 0; i <= realSplitNumber_1; i++) {
          var points = [];

          for (var j = 0; j < indicatorAxes.length; j++) {
            points.push(axesTicksPoints[j][i]);
          } // Close


          if (points[0]) {
            points.push(points[0].slice());
          } else {
            if (true) {
              console.error('Can\'t draw value axis ' + i);
            }
          }

          if (showSplitLine) {
            var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);
            splitLines[colorIndex].push(new _util_graphic__WEBPACK_IMPORTED_MODULE_5__.default({
              shape: {
                points: points
              }
            }));
          }

          if (showSplitArea && prevPoints) {
            var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i - 1);
            splitAreas[colorIndex].push(new _util_graphic__WEBPACK_IMPORTED_MODULE_6__.default({
              shape: {
                points: points.concat(prevPoints)
              }
            }));
          }

          prevPoints = points.slice().reverse();
        }
      }

    var lineStyle = lineStyleModel.getLineStyle();
    var areaStyle = areaStyleModel.getAreaStyle(); // Add splitArea before splitLine

    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(splitAreas, function (splitAreas, idx) {
      this.group.add(_util_graphic__WEBPACK_IMPORTED_MODULE_7__.mergePath(splitAreas, {
        style: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults({
          stroke: 'none',
          fill: splitAreaColorsArr[idx % splitAreaColorsArr.length]
        }, areaStyle),
        silent: true
      }));
    }, this);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(splitLines, function (splitLines, idx) {
      this.group.add(_util_graphic__WEBPACK_IMPORTED_MODULE_7__.mergePath(splitLines, {
        style: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults({
          fill: 'none',
          stroke: splitLineColorsArr[idx % splitLineColorsArr.length]
        }, lineStyle),
        silent: true
      }));
    }, this);
  };

  RadarView.type = 'radar';
  return RadarView;
}(_view_Component__WEBPACK_IMPORTED_MODULE_8__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadarView);

/***/ }),

/***/ "./node_modules/echarts/lib/component/radar/install.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/component/radar/install.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var _coord_radar_RadarModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../coord/radar/RadarModel */ "./node_modules/echarts/lib/coord/radar/RadarModel.js");
/* harmony import */ var _RadarView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RadarView */ "./node_modules/echarts/lib/component/radar/RadarView.js");
/* harmony import */ var _coord_radar_Radar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../coord/radar/Radar */ "./node_modules/echarts/lib/coord/radar/Radar.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



function install(registers) {
  registers.registerCoordinateSystem('radar', _coord_radar_Radar__WEBPACK_IMPORTED_MODULE_0__.default);
  registers.registerComponentModel(_coord_radar_RadarModel__WEBPACK_IMPORTED_MODULE_1__.default);
  registers.registerComponentView(_RadarView__WEBPACK_IMPORTED_MODULE_2__.default);
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/CoordinateSystem.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/CoordinateSystem.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isCoordinateSystemType": () => (/* binding */ isCoordinateSystemType)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function isCoordinateSystemType(coordSys, type) {
  return coordSys.type === type;
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/View.js":
/*!************************************************!*\
  !*** ./node_modules/echarts/lib/coord/View.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/vector */ "./node_modules/zrender/lib/core/vector.js");
/* harmony import */ var zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/matrix */ "./node_modules/zrender/lib/core/matrix.js");
/* harmony import */ var zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/BoundingRect */ "./node_modules/zrender/lib/core/BoundingRect.js");
/* harmony import */ var zrender_lib_core_Transformable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/Transformable */ "./node_modules/zrender/lib/core/Transformable.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Simple view coordinate system
 * Mapping given x, y to transformd view x, y
 */






var v2ApplyTransform = zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.applyTransform;

var View =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(View, _super);

  function View(name) {
    var _this = _super.call(this) || this;

    _this.type = 'view';
    _this.dimensions = ['x', 'y'];
    _this._roamTransformable = new zrender_lib_core_Transformable__WEBPACK_IMPORTED_MODULE_2__.default();
    _this._rawTransformable = new zrender_lib_core_Transformable__WEBPACK_IMPORTED_MODULE_2__.default();
    _this.name = name;
    return _this;
  } // PENDING to getRect


  View.prototype.setBoundingRect = function (x, y, width, height) {
    this._rect = new zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_3__.default(x, y, width, height);
    return this._rect;
  };
  /**
   * @return {module:zrender/core/BoundingRect}
   */
  // PENDING to getRect


  View.prototype.getBoundingRect = function () {
    return this._rect;
  };

  View.prototype.setViewRect = function (x, y, width, height) {
    this.transformTo(x, y, width, height);
    this._viewRect = new zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_3__.default(x, y, width, height);
  };
  /**
   * Transformed to particular position and size
   */


  View.prototype.transformTo = function (x, y, width, height) {
    var rect = this.getBoundingRect();
    var rawTransform = this._rawTransformable;
    rawTransform.transform = rect.calculateTransform(new zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_3__.default(x, y, width, height));
    rawTransform.decomposeTransform();

    this._updateTransform();
  };
  /**
   * Set center of view
   */


  View.prototype.setCenter = function (centerCoord) {
    if (!centerCoord) {
      return;
    }

    this._center = centerCoord;

    this._updateCenterAndZoom();
  };

  View.prototype.setZoom = function (zoom) {
    zoom = zoom || 1;
    var zoomLimit = this.zoomLimit;

    if (zoomLimit) {
      if (zoomLimit.max != null) {
        zoom = Math.min(zoomLimit.max, zoom);
      }

      if (zoomLimit.min != null) {
        zoom = Math.max(zoomLimit.min, zoom);
      }
    }

    this._zoom = zoom;

    this._updateCenterAndZoom();
  };
  /**
   * Get default center without roam
   */


  View.prototype.getDefaultCenter = function () {
    // Rect before any transform
    var rawRect = this.getBoundingRect();
    var cx = rawRect.x + rawRect.width / 2;
    var cy = rawRect.y + rawRect.height / 2;
    return [cx, cy];
  };

  View.prototype.getCenter = function () {
    return this._center || this.getDefaultCenter();
  };

  View.prototype.getZoom = function () {
    return this._zoom || 1;
  };

  View.prototype.getRoamTransform = function () {
    return this._roamTransformable.getLocalTransform();
  };
  /**
   * Remove roam
   */


  View.prototype._updateCenterAndZoom = function () {
    // Must update after view transform updated
    var rawTransformMatrix = this._rawTransformable.getLocalTransform();

    var roamTransform = this._roamTransformable;
    var defaultCenter = this.getDefaultCenter();
    var center = this.getCenter();
    var zoom = this.getZoom();
    center = zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.applyTransform([], center, rawTransformMatrix);
    defaultCenter = zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.applyTransform([], defaultCenter, rawTransformMatrix);
    roamTransform.originX = center[0];
    roamTransform.originY = center[1];
    roamTransform.x = defaultCenter[0] - center[0];
    roamTransform.y = defaultCenter[1] - center[1];
    roamTransform.scaleX = roamTransform.scaleY = zoom;

    this._updateTransform();
  };
  /**
   * Update transform from roam and mapLocation
   */


  View.prototype._updateTransform = function () {
    var roamTransformable = this._roamTransformable;
    var rawTransformable = this._rawTransformable;
    rawTransformable.parent = roamTransformable;
    roamTransformable.updateTransform();
    rawTransformable.updateTransform();
    zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_4__.copy(this.transform || (this.transform = []), rawTransformable.transform || zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_4__.create());
    this._rawTransform = rawTransformable.getLocalTransform();
    this.invTransform = this.invTransform || [];
    zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_4__.invert(this.invTransform, this.transform);
    this.decomposeTransform();
  };

  View.prototype.getTransformInfo = function () {
    var roamTransform = this._roamTransformable.transform;
    var rawTransformable = this._rawTransformable;
    return {
      roamTransform: roamTransform ? zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_5__.slice(roamTransform) : zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_4__.create(),
      rawScaleX: rawTransformable.scaleX,
      rawScaleY: rawTransformable.scaleY,
      rawX: rawTransformable.x,
      rawY: rawTransformable.y
    };
  };

  View.prototype.getViewRect = function () {
    return this._viewRect;
  };
  /**
   * Get view rect after roam transform
   */


  View.prototype.getViewRectAfterRoam = function () {
    var rect = this.getBoundingRect().clone();
    rect.applyTransform(this.transform);
    return rect;
  };
  /**
   * Convert a single (lon, lat) data item to (x, y) point.
   */


  View.prototype.dataToPoint = function (data, noRoam, out) {
    var transform = noRoam ? this._rawTransform : this.transform;
    out = out || [];
    return transform ? v2ApplyTransform(out, data, transform) : zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_0__.copy(out, data);
  };
  /**
   * Convert a (x, y) point to (lon, lat) data
   */


  View.prototype.pointToData = function (point) {
    var invTransform = this.invTransform;
    return invTransform ? v2ApplyTransform([], point, invTransform) : [point[0], point[1]];
  };

  View.prototype.convertToPixel = function (ecModel, finder, value) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  };

  View.prototype.convertFromPixel = function (ecModel, finder, pixel) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  };
  /**
   * @implements
   */


  View.prototype.containPoint = function (point) {
    return this.getViewRectAfterRoam().contain(point[0], point[1]);
  };

  View.dimensions = ['x', 'y'];
  return View;
}(zrender_lib_core_Transformable__WEBPACK_IMPORTED_MODULE_2__.default);

function getCoordSys(finder) {
  var seriesModel = finder.seriesModel;
  return seriesModel ? seriesModel.coordinateSystem : null; // e.g., graph.
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (View);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/axisCommonTypes.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts/lib/coord/axisCommonTypes.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AXIS_TYPES": () => (/* binding */ AXIS_TYPES)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var AXIS_TYPES = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};

/***/ }),

/***/ "./node_modules/echarts/lib/coord/axisDefault.js":
/*!*******************************************************!*\
  !*** ./node_modules/echarts/lib/coord/axisDefault.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

var defaultOption = {
  show: true,
  zlevel: 0,
  z: 0,
  // Inverse the axis.
  inverse: false,
  // Axis name displayed.
  name: '',
  // 'start' | 'middle' | 'end'
  nameLocation: 'end',
  // By degree. By default auto rotate by nameLocation.
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: '...',
    placeholder: '.'
  },
  // Use global text style by default.
  nameTextStyle: {},
  // The gap between axisName and axisLine.
  nameGap: 15,
  // Default `false` to support tooltip.
  silent: false,
  // Default `false` to avoid legacy user event listener fail.
  triggerEvent: false,
  tooltip: {
    show: false
  },
  axisPointer: {},
  axisLine: {
    show: true,
    onZero: true,
    onZeroAxisIndex: null,
    lineStyle: {
      color: '#6E7079',
      width: 1,
      type: 'solid'
    },
    // The arrow at both ends the the axis.
    symbol: ['none', 'none'],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: true,
    // Whether axisTick is inside the grid or outside the grid.
    inside: false,
    // The length of axisTick.
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: true,
    // Whether axisLabel is inside the grid or outside the grid.
    inside: false,
    rotate: 0,
    // true | false | null/undefined (auto)
    showMinLabel: null,
    // true | false | null/undefined (auto)
    showMaxLabel: null,
    margin: 8,
    // formatter: null,
    fontSize: 12
  },
  splitLine: {
    show: true,
    lineStyle: {
      color: ['#E0E6F1'],
      width: 1,
      type: 'solid'
    }
  },
  splitArea: {
    show: false,
    areaStyle: {
      color: ['rgba(250,250,250,0.2)', 'rgba(210,219,238,0.2)']
    }
  }
};
var categoryAxis = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.merge({
  // The gap at both ends of the axis. For categoryAxis, boolean.
  boundaryGap: true,
  // Set false to faster category collection.
  deduplication: null,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: false
  },
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: false,
    interval: 'auto'
  },
  axisLabel: {
    interval: 'auto'
  }
}, defaultOption);
var valueAxis = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.merge({
  boundaryGap: [0, 0],
  axisLine: {
    // Not shown when other axis is categoryAxis in cartesian
    show: 'auto'
  },
  axisTick: {
    // Not shown when other axis is categoryAxis in cartesian
    show: 'auto'
  },
  // TODO
  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
  splitNumber: 5,
  minorTick: {
    // Minor tick, not available for cateogry axis.
    show: false,
    // Split number of minor ticks. The value should be in range of (0, 100)
    splitNumber: 5,
    // Lenght of minor tick
    length: 3,
    // Line style
    lineStyle: {// Default to be same with axisTick
    }
  },
  minorSplitLine: {
    show: false,
    lineStyle: {
      color: '#F4F7FD',
      width: 1
    }
  }
}, defaultOption);
var timeAxis = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.merge({
  scale: true,
  splitNumber: 6,
  axisLabel: {
    // To eliminate labels that are not nice
    showMinLabel: false,
    showMaxLabel: false,
    rich: {
      primary: {
        fontWeight: 'bold'
      }
    }
  },
  splitLine: {
    show: false
  }
}, valueAxis);
var logAxis = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.defaults({
  scale: true,
  logBase: 10
}, valueAxis);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  category: categoryAxis,
  value: valueAxis,
  time: timeAxis,
  log: logAxis
});

/***/ }),

/***/ "./node_modules/echarts/lib/coord/axisModelCreator.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/axisModelCreator.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ axisModelCreator)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _axisDefault__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./axisDefault */ "./node_modules/echarts/lib/coord/axisDefault.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _data_OrdinalMeta__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../data/OrdinalMeta */ "./node_modules/echarts/lib/data/OrdinalMeta.js");
/* harmony import */ var _axisCommonTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./axisCommonTypes */ "./node_modules/echarts/lib/coord/axisCommonTypes.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






/**
 * Generate sub axis model class
 * @param axisName 'x' 'y' 'radius' 'angle' 'parallel' ...
 */

function axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(_axisCommonTypes__WEBPACK_IMPORTED_MODULE_1__.AXIS_TYPES, function (v, axisType) {
    var defaultOption = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.merge)((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.merge)({}, _axisDefault__WEBPACK_IMPORTED_MODULE_2__.default[axisType], true), extraDefaultOption, true);

    var AxisModel =
    /** @class */
    function (_super) {
      (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(AxisModel, _super);

      function AxisModel() {
        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        var _this = _super.apply(this, args) || this;

        _this.type = axisName + 'Axis.' + axisType;
        return _this;
      }

      AxisModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {
        var layoutMode = (0,_util_layout__WEBPACK_IMPORTED_MODULE_4__.fetchLayoutMode)(this);
        var inputPositionParams = layoutMode ? (0,_util_layout__WEBPACK_IMPORTED_MODULE_4__.getLayoutParams)(option) : {};
        var themeModel = ecModel.getTheme();
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.merge)(option, themeModel.get(axisType + 'Axis'));
        (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.merge)(option, this.getDefaultOption());
        option.type = getAxisType(option);

        if (layoutMode) {
          (0,_util_layout__WEBPACK_IMPORTED_MODULE_4__.mergeLayoutParam)(option, inputPositionParams, layoutMode);
        }
      };

      AxisModel.prototype.optionUpdated = function () {
        var thisOption = this.option;

        if (thisOption.type === 'category') {
          this.__ordinalMeta = _data_OrdinalMeta__WEBPACK_IMPORTED_MODULE_5__.default.createByAxisModel(this);
        }
      };
      /**
       * Should not be called before all of 'getInitailData' finished.
       * Because categories are collected during initializing data.
       */


      AxisModel.prototype.getCategories = function (rawData) {
        var option = this.option; // FIXME
        // warning if called before all of 'getInitailData' finished.

        if (option.type === 'category') {
          if (rawData) {
            return option.data;
          }

          return this.__ordinalMeta.categories;
        }
      };

      AxisModel.prototype.getOrdinalMeta = function () {
        return this.__ordinalMeta;
      };

      AxisModel.type = axisName + 'Axis.' + axisType;
      AxisModel.defaultOption = defaultOption;
      return AxisModel;
    }(BaseAxisModelClass);

    registers.registerComponentModel(AxisModel);
  });
  registers.registerSubTypeDefaulter(axisName + 'Axis', getAxisType);
}

function getAxisType(option) {
  // Default axis with data is category axis
  return option.type || (option.data ? 'category' : 'value');
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/Axis2D.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/cartesian/Axis2D.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Axis */ "./node_modules/echarts/lib/coord/Axis.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var Axis2D =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Axis2D, _super);

  function Axis2D(dim, scale, coordExtent, axisType, position) {
    var _this = _super.call(this, dim, scale, coordExtent) || this;
    /**
     * Index of axis, can be used as key
     * Injected outside.
     */


    _this.index = 0;
    _this.type = axisType || 'value';
    _this.position = position || 'bottom';
    return _this;
  }

  Axis2D.prototype.isHorizontal = function () {
    var position = this.position;
    return position === 'top' || position === 'bottom';
  };
  /**
   * Each item cooresponds to this.getExtent(), which
   * means globalExtent[0] may greater than globalExtent[1],
   * unless `asc` is input.
   *
   * @param {boolean} [asc]
   * @return {Array.<number>}
   */


  Axis2D.prototype.getGlobalExtent = function (asc) {
    var ret = this.getExtent();
    ret[0] = this.toGlobalCoord(ret[0]);
    ret[1] = this.toGlobalCoord(ret[1]);
    asc && ret[0] > ret[1] && ret.reverse();
    return ret;
  };

  Axis2D.prototype.pointToData = function (point, clamp) {
    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);
  };
  /**
   * Set ordinalSortInfo
   * @param info new OrdinalSortInfo
   */


  Axis2D.prototype.setCategorySortInfo = function (info) {
    if (this.type !== 'category') {
      return false;
    }

    this.model.option.categorySortInfo = info;
    this.scale.setSortInfo(info);
  };

  return Axis2D;
}(_Axis__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Axis2D);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/AxisModel.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/cartesian/AxisModel.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CartesianAxisModel": () => (/* binding */ CartesianAxisModel),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");
/* harmony import */ var _axisModelCommonMixin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../axisModelCommonMixin */ "./node_modules/echarts/lib/coord/axisModelCommonMixin.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var CartesianAxisModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(CartesianAxisModel, _super);

  function CartesianAxisModel() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  CartesianAxisModel.prototype.getCoordSysModel = function () {
    return this.getReferringComponents('grid', _util_model__WEBPACK_IMPORTED_MODULE_1__.SINGLE_REFERRING).models[0];
  };

  CartesianAxisModel.type = 'cartesian2dAxis';
  return CartesianAxisModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_2__.default);


zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.mixin(CartesianAxisModel, _axisModelCommonMixin__WEBPACK_IMPORTED_MODULE_4__.AxisModelCommonMixin);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CartesianAxisModel);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/Cartesian.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/cartesian/Cartesian.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


var Cartesian =
/** @class */
function () {
  function Cartesian(name) {
    this.type = 'cartesian';
    this._dimList = [];
    this._axes = {};
    this.name = name || '';
  }

  Cartesian.prototype.getAxis = function (dim) {
    return this._axes[dim];
  };

  Cartesian.prototype.getAxes = function () {
    return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map(this._dimList, function (dim) {
      return this._axes[dim];
    }, this);
  };

  Cartesian.prototype.getAxesByScale = function (scaleType) {
    scaleType = scaleType.toLowerCase();
    return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.filter(this.getAxes(), function (axis) {
      return axis.scale.type === scaleType;
    });
  };

  Cartesian.prototype.addAxis = function (axis) {
    var dim = axis.dim;
    this._axes[dim] = axis;

    this._dimList.push(dim);
  };

  return Cartesian;
}();

;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Cartesian);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/Cartesian2D.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/cartesian/Cartesian2D.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cartesian2DDimensions": () => (/* binding */ cartesian2DDimensions),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/BoundingRect */ "./node_modules/zrender/lib/core/BoundingRect.js");
/* harmony import */ var _Cartesian__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Cartesian */ "./node_modules/echarts/lib/coord/cartesian/Cartesian.js");
/* harmony import */ var zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/matrix */ "./node_modules/zrender/lib/core/matrix.js");
/* harmony import */ var zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/vector */ "./node_modules/zrender/lib/core/vector.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var cartesian2DDimensions = ['x', 'y'];

function canCalculateAffineTransform(scale) {
  return scale.type === 'interval' || scale.type === 'time';
}

var Cartesian2D =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Cartesian2D, _super);

  function Cartesian2D() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'cartesian2d';
    _this.dimensions = cartesian2DDimensions;
    return _this;
  }
  /**
   * Calculate an affine transform matrix if two axes are time or value.
   * It's mainly for accelartion on the large time series data.
   */


  Cartesian2D.prototype.calcAffineTransform = function () {
    this._transform = this._invTransform = null;
    var xAxisScale = this.getAxis('x').scale;
    var yAxisScale = this.getAxis('y').scale;

    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {
      return;
    }

    var xScaleExtent = xAxisScale.getExtent();
    var yScaleExtent = yAxisScale.getExtent();
    var start = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);
    var end = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);
    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];
    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];

    if (!xScaleSpan || !yScaleSpan) {
      return;
    } // Accelerate data to point calculation on the special large time series data.


    var scaleX = (end[0] - start[0]) / xScaleSpan;
    var scaleY = (end[1] - start[1]) / yScaleSpan;
    var translateX = start[0] - xScaleExtent[0] * scaleX;
    var translateY = start[1] - yScaleExtent[0] * scaleY;
    var m = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];
    this._invTransform = (0,zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_1__.invert)([], m);
  };
  /**
   * Base axis will be used on stacking.
   */


  Cartesian2D.prototype.getBaseAxis = function () {
    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');
  };

  Cartesian2D.prototype.containPoint = function (point) {
    var axisX = this.getAxis('x');
    var axisY = this.getAxis('y');
    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
  };

  Cartesian2D.prototype.containData = function (data) {
    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);
  };

  Cartesian2D.prototype.dataToPoint = function (data, reserved, out) {
    out = out || [];
    var xVal = data[0];
    var yVal = data[1]; // Fast path

    if (this._transform // It's supported that if data is like `[Inifity, 123]`, where only Y pixel calculated.
    && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {
      return (0,zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_2__.applyTransform)(out, data, this._transform);
    }

    var xAxis = this.getAxis('x');
    var yAxis = this.getAxis('y');
    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal));
    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal));
    return out;
  };

  Cartesian2D.prototype.clampData = function (data, out) {
    var xScale = this.getAxis('x').scale;
    var yScale = this.getAxis('y').scale;
    var xAxisExtent = xScale.getExtent();
    var yAxisExtent = yScale.getExtent();
    var x = xScale.parse(data[0]);
    var y = yScale.parse(data[1]);
    out = out || [];
    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
    return out;
  };

  Cartesian2D.prototype.pointToData = function (point, out) {
    out = out || [];

    if (this._invTransform) {
      return (0,zrender_lib_core_vector__WEBPACK_IMPORTED_MODULE_2__.applyTransform)(out, point, this._invTransform);
    }

    var xAxis = this.getAxis('x');
    var yAxis = this.getAxis('y');
    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));
    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));
    return out;
  };

  Cartesian2D.prototype.getOtherAxis = function (axis) {
    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');
  };
  /**
   * Get rect area of cartesian.
   * Area will have a contain function to determine if a point is in the coordinate system.
   */


  Cartesian2D.prototype.getArea = function () {
    var xExtent = this.getAxis('x').getGlobalExtent();
    var yExtent = this.getAxis('y').getGlobalExtent();
    var x = Math.min(xExtent[0], xExtent[1]);
    var y = Math.min(yExtent[0], yExtent[1]);
    var width = Math.max(xExtent[0], xExtent[1]) - x;
    var height = Math.max(yExtent[0], yExtent[1]) - y;
    return new zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_3__.default(x, y, width, height);
  };

  return Cartesian2D;
}(_Cartesian__WEBPACK_IMPORTED_MODULE_4__.default);

;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Cartesian2D);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/Grid.js":
/*!**********************************************************!*\
  !*** ./node_modules/echarts/lib/coord/cartesian/Grid.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _coord_axisHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../coord/axisHelper */ "./node_modules/echarts/lib/coord/axisHelper.js");
/* harmony import */ var _Cartesian2D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cartesian2D */ "./node_modules/echarts/lib/coord/cartesian/Cartesian2D.js");
/* harmony import */ var _Axis2D__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Axis2D */ "./node_modules/echarts/lib/coord/cartesian/Axis2D.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _cartesianAxisHelper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cartesianAxisHelper */ "./node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Grid is a region which contains at most 4 cartesian systems
 *
 * TODO Default cartesian
 */








var Grid =
/** @class */
function () {
  function Grid(gridModel, ecModel, api) {
    // FIXME:TS where used (different from registered type 'cartesian2d')?
    this.type = 'grid';
    this._coordsMap = {};
    this._coordsList = [];
    this._axesMap = {};
    this._axesList = [];
    this.axisPointerEnabled = true;
    this.dimensions = _Cartesian2D__WEBPACK_IMPORTED_MODULE_0__.cartesian2DDimensions;

    this._initCartesian(gridModel, ecModel, api);

    this.model = gridModel;
  }

  Grid.prototype.getRect = function () {
    return this._rect;
  };

  Grid.prototype.update = function (ecModel, api) {
    var axesMap = this._axesMap;

    this._updateScale(ecModel, this.model);

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(axesMap.x, function (xAxis) {
      (0,_coord_axisHelper__WEBPACK_IMPORTED_MODULE_2__.niceScaleExtent)(xAxis.scale, xAxis.model);
    });
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(axesMap.y, function (yAxis) {
      (0,_coord_axisHelper__WEBPACK_IMPORTED_MODULE_2__.niceScaleExtent)(yAxis.scale, yAxis.model);
    }); // Key: axisDim_axisIndex, value: boolean, whether onZero target.

    var onZeroRecords = {};
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(axesMap.x, function (xAxis) {
      fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);
    });
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(axesMap.y, function (yAxis) {
      fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);
    }); // Resize again if containLabel is enabled
    // FIXME It may cause getting wrong grid size in data processing stage

    this.resize(this.model, api);
  };
  /**
   * Resize the grid
   */


  Grid.prototype.resize = function (gridModel, api, ignoreContainLabel) {
    var boxLayoutParams = gridModel.getBoxLayoutParams();
    var isContainLabel = !ignoreContainLabel && gridModel.get('containLabel');
    var gridRect = (0,_util_layout__WEBPACK_IMPORTED_MODULE_3__.getLayoutRect)(boxLayoutParams, {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._rect = gridRect;
    var axesList = this._axesList;
    adjustAxes(); // Minus label size

    if (isContainLabel) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(axesList, function (axis) {
        if (!axis.model.get(['axisLabel', 'inside'])) {
          var labelUnionRect = (0,_coord_axisHelper__WEBPACK_IMPORTED_MODULE_2__.estimateLabelUnionRect)(axis);

          if (labelUnionRect) {
            var dim = axis.isHorizontal() ? 'height' : 'width';
            var margin = axis.model.get(['axisLabel', 'margin']);
            gridRect[dim] -= labelUnionRect[dim] + margin;

            if (axis.position === 'top') {
              gridRect.y += labelUnionRect.height + margin;
            } else if (axis.position === 'left') {
              gridRect.x += labelUnionRect.width + margin;
            }
          }
        }
      });
      adjustAxes();
    }

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(this._coordsList, function (coord) {
      // Calculate affine matrix to accelerate the data to point transform.
      // If all the axes scales are time or value.
      coord.calcAffineTransform();
    });

    function adjustAxes() {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(axesList, function (axis) {
        var isHorizontal = axis.isHorizontal();
        var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
        var idx = axis.inverse ? 1 : 0;
        axis.setExtent(extent[idx], extent[1 - idx]);
        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
      });
    }
  };

  Grid.prototype.getAxis = function (dim, axisIndex) {
    var axesMapOnDim = this._axesMap[dim];

    if (axesMapOnDim != null) {
      return axesMapOnDim[axisIndex || 0]; // if (axisIndex == null) {
      //     Find first axis
      //     for (let name in axesMapOnDim) {
      //         if (axesMapOnDim.hasOwnProperty(name)) {
      //             return axesMapOnDim[name];
      //         }
      //     }
      // }
      // return axesMapOnDim[axisIndex];
    }
  };

  Grid.prototype.getAxes = function () {
    return this._axesList.slice();
  };

  Grid.prototype.getCartesian = function (xAxisIndex, yAxisIndex) {
    if (xAxisIndex != null && yAxisIndex != null) {
      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
      return this._coordsMap[key];
    }

    if ((0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(xAxisIndex)) {
      yAxisIndex = xAxisIndex.yAxisIndex;
      xAxisIndex = xAxisIndex.xAxisIndex;
    }

    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
      if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {
        return coordList[i];
      }
    }
  };

  Grid.prototype.getCartesians = function () {
    return this._coordsList.slice();
  };
  /**
   * @implements
   */


  Grid.prototype.convertToPixel = function (ecModel, finder, value) {
    var target = this._findConvertTarget(finder);

    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
  };
  /**
   * @implements
   */


  Grid.prototype.convertFromPixel = function (ecModel, finder, value) {
    var target = this._findConvertTarget(finder);

    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
  };

  Grid.prototype._findConvertTarget = function (finder) {
    var seriesModel = finder.seriesModel;
    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis', _util_model__WEBPACK_IMPORTED_MODULE_4__.SINGLE_REFERRING).models[0];
    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis', _util_model__WEBPACK_IMPORTED_MODULE_4__.SINGLE_REFERRING).models[0];
    var gridModel = finder.gridModel;
    var coordsList = this._coordsList;
    var cartesian;
    var axis;

    if (seriesModel) {
      cartesian = seriesModel.coordinateSystem;
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.indexOf)(coordsList, cartesian) < 0 && (cartesian = null);
    } else if (xAxisModel && yAxisModel) {
      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    } else if (xAxisModel) {
      axis = this.getAxis('x', xAxisModel.componentIndex);
    } else if (yAxisModel) {
      axis = this.getAxis('y', yAxisModel.componentIndex);
    } // Lowest priority.
    else if (gridModel) {
        var grid = gridModel.coordinateSystem;

        if (grid === this) {
          cartesian = this._coordsList[0];
        }
      }

    return {
      cartesian: cartesian,
      axis: axis
    };
  };
  /**
   * @implements
   */


  Grid.prototype.containPoint = function (point) {
    var coord = this._coordsList[0];

    if (coord) {
      return coord.containPoint(point);
    }
  };
  /**
   * Initialize cartesian coordinate systems
   */


  Grid.prototype._initCartesian = function (gridModel, ecModel, api) {
    var _this = this;

    var grid = this;
    var axisPositionUsed = {
      left: false,
      right: false,
      top: false,
      bottom: false
    };
    var axesMap = {
      x: {},
      y: {}
    };
    var axesCount = {
      x: 0,
      y: 0
    }; /// Create axis

    ecModel.eachComponent('xAxis', createAxisCreator('x'), this);
    ecModel.eachComponent('yAxis', createAxisCreator('y'), this);

    if (!axesCount.x || !axesCount.y) {
      // Roll back when there no either x or y axis
      this._axesMap = {};
      this._axesList = [];
      return;
    }

    this._axesMap = axesMap; /// Create cartesian2d

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(axesMap.x, function (xAxis, xAxisIndex) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(axesMap.y, function (yAxis, yAxisIndex) {
        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
        var cartesian = new _Cartesian2D__WEBPACK_IMPORTED_MODULE_0__.default(key);
        cartesian.master = _this;
        cartesian.model = gridModel;
        _this._coordsMap[key] = cartesian;

        _this._coordsList.push(cartesian);

        cartesian.addAxis(xAxis);
        cartesian.addAxis(yAxis);
      });
    });

    function createAxisCreator(dimName) {
      return function (axisModel, idx) {
        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
          return;
        }

        var axisPosition = axisModel.get('position');

        if (dimName === 'x') {
          // Fix position
          if (axisPosition !== 'top' && axisPosition !== 'bottom') {
            // Default bottom of X
            axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';
          }
        } else {
          // Fix position
          if (axisPosition !== 'left' && axisPosition !== 'right') {
            // Default left of Y
            axisPosition = axisPositionUsed.left ? 'right' : 'left';
          }
        }

        axisPositionUsed[axisPosition] = true;
        var axis = new _Axis2D__WEBPACK_IMPORTED_MODULE_5__.default(dimName, (0,_coord_axisHelper__WEBPACK_IMPORTED_MODULE_2__.createScaleByModel)(axisModel), [0, 0], axisModel.get('type'), axisPosition);
        var isCategory = axis.type === 'category';
        axis.onBand = isCategory && axisModel.get('boundaryGap');
        axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel

        axisModel.axis = axis; // Inject axisModel into axis

        axis.model = axisModel; // Inject grid info axis

        axis.grid = grid; // Index of axis, can be used as key

        axis.index = idx;

        grid._axesList.push(axis);

        axesMap[dimName][idx] = axis;
        axesCount[dimName]++;
      };
    }
  };
  /**
   * Update cartesian properties from series.
   */


  Grid.prototype._updateScale = function (ecModel, gridModel) {
    // Reset scale
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(this._axesList, function (axis) {
      axis.scale.setExtent(Infinity, -Infinity);

      if (axis.type === 'category') {
        var categorySortInfo = axis.model.get('categorySortInfo');
        axis.scale.setSortInfo(categorySortInfo);
      }
    });
    ecModel.eachSeries(function (seriesModel) {
      if ((0,_cartesianAxisHelper__WEBPACK_IMPORTED_MODULE_6__.isCartesian2DSeries)(seriesModel)) {
        var axesModelMap = (0,_cartesianAxisHelper__WEBPACK_IMPORTED_MODULE_6__.findAxisModels)(seriesModel);
        var xAxisModel = axesModelMap.xAxisModel;
        var yAxisModel = axesModelMap.yAxisModel;

        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
          return;
        }

        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        var data = seriesModel.getData();
        var xAxis = cartesian.getAxis('x');
        var yAxis = cartesian.getAxis('y');

        if (data.type === 'list') {
          unionExtent(data, xAxis);
          unionExtent(data, yAxis);
        }
      }
    }, this);

    function unionExtent(data, axis) {
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)((0,_coord_axisHelper__WEBPACK_IMPORTED_MODULE_2__.getDataDimensionsOnAxis)(data, axis.dim), function (dim) {
        axis.scale.unionExtentFromData(data, dim);
      });
    }
  };
  /**
   * @param dim 'x' or 'y' or 'auto' or null/undefined
   */


  Grid.prototype.getTooltipAxes = function (dim) {
    var baseAxes = [];
    var otherAxes = [];
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each)(this.getCartesians(), function (cartesian) {
      var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
      var otherAxis = cartesian.getOtherAxis(baseAxis);
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.indexOf)(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.indexOf)(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
    });
    return {
      baseAxes: baseAxes,
      otherAxes: otherAxes
    };
  };

  Grid.create = function (ecModel, api) {
    var grids = [];
    ecModel.eachComponent('grid', function (gridModel, idx) {
      var grid = new Grid(gridModel, ecModel, api);
      grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize
      // should be performed in create stage.

      grid.resize(gridModel, api, true);
      gridModel.coordinateSystem = grid;
      grids.push(grid);
    }); // Inject the coordinateSystems into seriesModel

    ecModel.eachSeries(function (seriesModel) {
      if (!(0,_cartesianAxisHelper__WEBPACK_IMPORTED_MODULE_6__.isCartesian2DSeries)(seriesModel)) {
        return;
      }

      var axesModelMap = (0,_cartesianAxisHelper__WEBPACK_IMPORTED_MODULE_6__.findAxisModels)(seriesModel);
      var xAxisModel = axesModelMap.xAxisModel;
      var yAxisModel = axesModelMap.yAxisModel;
      var gridModel = xAxisModel.getCoordSysModel();

      if (true) {
        if (!gridModel) {
          throw new Error('Grid "' + (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.retrieve3)(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '" not found');
        }

        if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {
          throw new Error('xAxis and yAxis must use the same grid');
        }
      }

      var grid = gridModel.coordinateSystem;
      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    });
    return grids;
  }; // For deciding which dimensions to use when creating list data


  Grid.dimensions = _Cartesian2D__WEBPACK_IMPORTED_MODULE_0__.cartesian2DDimensions;
  return Grid;
}();
/**
 * Check if the axis is used in the specified grid.
 */


function isAxisUsedInTheGrid(axisModel, gridModel) {
  return axisModel.getCoordSysModel() === gridModel;
}

function fixAxisOnZero(axesMap, otherAxisDim, axis, // Key: see `getOnZeroRecordKey`
onZeroRecords) {
  axis.getAxesOnZeroOf = function () {
    // TODO: onZero of multiple axes.
    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
  }; // onZero can not be enabled in these two situations:
  // 1. When any other axis is a category axis.
  // 2. When no axis is cross 0 point.


  var otherAxes = axesMap[otherAxisDim];
  var otherAxisOnZeroOf;
  var axisModel = axis.model;
  var onZero = axisModel.get(['axisLine', 'onZero']);
  var onZeroAxisIndex = axisModel.get(['axisLine', 'onZeroAxisIndex']);

  if (!onZero) {
    return;
  } // If target axis is specified.


  if (onZeroAxisIndex != null) {
    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
    }
  } else {
    // Find the first available other axis.
    for (var idx in otherAxes) {
      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) // Consider that two Y axes on one value axis,
      // if both onZero, the two Y axes overlap.
      && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
        otherAxisOnZeroOf = otherAxes[idx];
        break;
      }
    }
  }

  if (otherAxisOnZeroOf) {
    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
  }

  function getOnZeroRecordKey(axis) {
    return axis.dim + '_' + axis.index;
  }
}

function canOnZeroToAxis(axis) {
  return axis && axis.type !== 'category' && axis.type !== 'time' && (0,_coord_axisHelper__WEBPACK_IMPORTED_MODULE_2__.ifAxisCrossZero)(axis);
}

function updateAxisTransform(axis, coordBase) {
  var axisExtent = axis.getExtent();
  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform

  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {
    return coord + coordBase;
  } : function (coord) {
    return axisExtentSum - coord + coordBase;
  };
  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {
    return coord - coordBase;
  } : function (coord) {
    return axisExtentSum - coord + coordBase;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Grid);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/GridModel.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/cartesian/GridModel.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var GridModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(GridModel, _super);

  function GridModel() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  GridModel.type = 'grid';
  GridModel.dependencies = ['xAxis', 'yAxis'];
  GridModel.layoutMode = 'box';
  GridModel.defaultOption = {
    show: false,
    zlevel: 0,
    z: 0,
    left: '10%',
    top: 60,
    right: '10%',
    bottom: 70,
    // If grid size contain label
    containLabel: false,
    // width: {totalWidth} - left - right,
    // height: {totalHeight} - top - bottom,
    backgroundColor: 'rgba(0,0,0,0)',
    borderWidth: 1,
    borderColor: '#ccc'
  };
  return GridModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GridModel);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js":
/*!*************************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "layout": () => (/* binding */ layout),
/* harmony export */   "isCartesian2DSeries": () => (/* binding */ isCartesian2DSeries),
/* harmony export */   "findAxisModels": () => (/* binding */ findAxisModels)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * Can only be called after coordinate system creation stage.
 * (Can be called before coordinate system update stage).
 */

function layout(gridModel, axisModel, opt) {
  opt = opt || {};
  var grid = gridModel.coordinateSystem;
  var axis = axisModel.axis;
  var layout = {};
  var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
  var rawAxisPosition = axis.position;
  var axisPosition = otherAxisOnZeroOf ? 'onZero' : rawAxisPosition;
  var axisDim = axis.dim;
  var rect = grid.getRect();
  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  var idx = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  };
  var axisOffset = axisModel.get('offset') || 0;
  var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];

  if (otherAxisOnZeroOf) {
    var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
    posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
  } // Axis position


  layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]]; // Axis rotation

  layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim

  var dirMap = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];
  layout.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;

  if (axisModel.get(['axisTick', 'inside'])) {
    layout.tickDirection = -layout.tickDirection;
  }

  if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.retrieve(opt.labelInside, axisModel.get(['axisLabel', 'inside']))) {
    layout.labelDirection = -layout.labelDirection;
  } // Special label rotation


  var labelRotate = axisModel.get(['axisLabel', 'rotate']);
  layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // Over splitLine and splitArea

  layout.z2 = 1;
  return layout;
}
function isCartesian2DSeries(seriesModel) {
  return seriesModel.get('coordinateSystem') === 'cartesian2d';
}
function findAxisModels(seriesModel) {
  var axisModelMap = {
    xAxisModel: null,
    yAxisModel: null
  };
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(axisModelMap, function (v, key) {
    var axisType = key.replace(/Model$/, '');
    var axisModel = seriesModel.getReferringComponents(axisType, _util_model__WEBPACK_IMPORTED_MODULE_1__.SINGLE_REFERRING).models[0];

    if (true) {
      if (!axisModel) {
        throw new Error(axisType + ' "' + zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.retrieve3(seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0) + '" not found');
      }
    }

    axisModelMap[key] = axisModel;
  });
  return axisModelMap;
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/geo/Geo.js":
/*!***************************************************!*\
  !*** ./node_modules/echarts/lib/coord/geo/Geo.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/BoundingRect */ "./node_modules/zrender/lib/core/BoundingRect.js");
/* harmony import */ var _View__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../View */ "./node_modules/echarts/lib/coord/View.js");
/* harmony import */ var _geoSourceManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geoSourceManager */ "./node_modules/echarts/lib/coord/geo/geoSourceManager.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







var Geo =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Geo, _super);
  /**
   * For backward compatibility, the orginal interface:
   * `name, map, geoJson, specialAreas, nameMap` is kept.
   *
   * @param map Map type Specify the positioned areas by left, top, width, height.
   * @param [nameMap] Specify name alias
   */


  function Geo(name, map, nameMap, invertLongitute) {
    var _this = _super.call(this, name) || this;

    _this.dimensions = ['lng', 'lat'];
    _this.type = 'geo';
    _this.map = map;
    var source = _geoSourceManager__WEBPACK_IMPORTED_MODULE_1__.default.load(map, nameMap);
    _this._nameCoordMap = source.nameCoordMap;
    _this._regionsMap = source.regionsMap;
    _this._invertLongitute = invertLongitute == null ? true : invertLongitute;
    _this.regions = source.regions;
    _this._rect = source.boundingRect;
    return _this;
  }
  /**
   * Whether contain the given [lng, lat] coord.
   */


  Geo.prototype.containCoord = function (coord) {
    var regions = this.regions;

    for (var i = 0; i < regions.length; i++) {
      if (regions[i].contain(coord)) {
        return true;
      }
    }

    return false;
  };

  Geo.prototype.transformTo = function (x, y, width, height) {
    var rect = this.getBoundingRect();
    var invertLongitute = this._invertLongitute;
    rect = rect.clone();

    if (invertLongitute) {
      // Longitute is inverted
      rect.y = -rect.y - rect.height;
    }

    var rawTransformable = this._rawTransformable;
    rawTransformable.transform = rect.calculateTransform(new zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_2__.default(x, y, width, height));
    rawTransformable.decomposeTransform();

    if (invertLongitute) {
      rawTransformable.scaleY = -rawTransformable.scaleY;
    }

    rawTransformable.updateTransform();

    this._updateTransform();
  };

  Geo.prototype.getRegion = function (name) {
    return this._regionsMap.get(name);
  };

  Geo.prototype.getRegionByCoord = function (coord) {
    var regions = this.regions;

    for (var i = 0; i < regions.length; i++) {
      if (regions[i].contain(coord)) {
        return regions[i];
      }
    }
  };
  /**
   * Add geoCoord for indexing by name
   */


  Geo.prototype.addGeoCoord = function (name, geoCoord) {
    this._nameCoordMap.set(name, geoCoord);
  };
  /**
   * Get geoCoord by name
   */


  Geo.prototype.getGeoCoord = function (name) {
    return this._nameCoordMap.get(name);
  };

  Geo.prototype.getBoundingRect = function () {
    return this._rect;
  };

  Geo.prototype.dataToPoint = function (data, noRoam, out) {
    if (typeof data === 'string') {
      // Map area name to geoCoord
      data = this.getGeoCoord(data);
    }

    if (data) {
      return _View__WEBPACK_IMPORTED_MODULE_3__.default.prototype.dataToPoint.call(this, data, noRoam, out);
    }
  };

  Geo.prototype.convertToPixel = function (ecModel, finder, value) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  };

  Geo.prototype.convertFromPixel = function (ecModel, finder, pixel) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  };

  return Geo;
}(_View__WEBPACK_IMPORTED_MODULE_3__.default);

;
zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_4__.mixin(Geo, _View__WEBPACK_IMPORTED_MODULE_3__.default);

function getCoordSys(finder) {
  var geoModel = finder.geoModel;
  var seriesModel = finder.seriesModel;
  return geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem // For map series.
  || (seriesModel.getReferringComponents('geo', _util_model__WEBPACK_IMPORTED_MODULE_5__.SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Geo);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/geo/GeoModel.js":
/*!********************************************************!*\
  !*** ./node_modules/echarts/lib/coord/geo/GeoModel.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");
/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../model/Model */ "./node_modules/echarts/lib/model/Model.js");
/* harmony import */ var _geoCreator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geoCreator */ "./node_modules/echarts/lib/coord/geo/geoCreator.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






;
;

var GeoModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(GeoModel, _super);

  function GeoModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = GeoModel.type;
    return _this;
  }

  GeoModel.prototype.init = function (option, parentModel, ecModel) {
    _super.prototype.init.call(this, option, parentModel, ecModel); // Default label emphasis `show`


    _util_model__WEBPACK_IMPORTED_MODULE_1__.defaultEmphasis(option, 'label', ['show']);
  };

  GeoModel.prototype.optionUpdated = function () {
    var option = this.option;
    var self = this;
    option.regions = _geoCreator__WEBPACK_IMPORTED_MODULE_2__.default.getFilledRegions(option.regions, option.map, option.nameMap);
    var selectedMap = {};
    this._optionModelMap = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.reduce(option.regions || [], function (optionModelMap, regionOpt) {
      var regionName = regionOpt.name;

      if (regionName) {
        optionModelMap.set(regionName, new _model_Model__WEBPACK_IMPORTED_MODULE_4__.default(regionOpt, self));

        if (regionOpt.selected) {
          selectedMap[regionName] = true;
        }
      }

      return optionModelMap;
    }, zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.createHashMap());

    if (!option.selectedMap) {
      option.selectedMap = selectedMap;
    }
  };
  /**
   * Get model of region.
   */


  GeoModel.prototype.getRegionModel = function (name) {
    return this._optionModelMap.get(name) || new _model_Model__WEBPACK_IMPORTED_MODULE_4__.default(null, this, this.ecModel);
  };
  /**
   * Format label
   * @param name Region name
   */


  GeoModel.prototype.getFormattedLabel = function (name, status) {
    var regionModel = this.getRegionModel(name);
    var formatter = status === 'normal' ? regionModel.get(['label', 'formatter']) : regionModel.get(['emphasis', 'label', 'formatter']);
    var params = {
      name: name
    };

    if (typeof formatter === 'function') {
      params.status = status;
      return formatter(params);
    } else if (typeof formatter === 'string') {
      return formatter.replace('{a}', name != null ? name : '');
    }
  };

  GeoModel.prototype.setZoom = function (zoom) {
    this.option.zoom = zoom;
  };

  GeoModel.prototype.setCenter = function (center) {
    this.option.center = center;
  }; // PENGING If selectedMode is null ?


  GeoModel.prototype.select = function (name) {
    var option = this.option;
    var selectedMode = option.selectedMode;

    if (!selectedMode) {
      return;
    }

    if (selectedMode !== 'multiple') {
      option.selectedMap = null;
    }

    var selectedMap = option.selectedMap || (option.selectedMap = {});
    selectedMap[name] = true;
  };

  GeoModel.prototype.unSelect = function (name) {
    var selectedMap = this.option.selectedMap;

    if (selectedMap) {
      selectedMap[name] = false;
    }
  };

  GeoModel.prototype.toggleSelected = function (name) {
    this[this.isSelected(name) ? 'unSelect' : 'select'](name);
  };

  GeoModel.prototype.isSelected = function (name) {
    var selectedMap = this.option.selectedMap;
    return !!(selectedMap && selectedMap[name]);
  };

  GeoModel.prototype._initSelectedMapFromData = function () {};

  GeoModel.type = 'geo';
  GeoModel.layoutMode = 'box';
  GeoModel.defaultOption = {
    zlevel: 0,
    z: 0,
    show: true,
    left: 'center',
    top: 'center',
    // If svg used, aspectScale is 1 by default.
    // aspectScale: 0.75,
    aspectScale: null,
    ///// Layout with center and size
    // If you wan't to put map in a fixed size box with right aspect ratio
    // This two properties may more conveninet
    // layoutCenter: [50%, 50%]
    // layoutSize: 100
    silent: false,
    // Map type
    map: '',
    // Define left-top, right-bottom coords to control view
    // For example, [ [180, 90], [-180, -90] ]
    boundingCoords: null,
    // Default on center of map
    center: null,
    zoom: 1,
    scaleLimit: null,
    // selectedMode: false
    label: {
      show: false,
      color: '#000'
    },
    itemStyle: {
      // color: ,
      borderWidth: 0.5,
      borderColor: '#444',
      color: '#eee'
    },
    emphasis: {
      label: {
        show: true,
        color: 'rgb(100,0,0)'
      },
      itemStyle: {
        color: 'rgba(255,215,0,0.8)'
      }
    },
    select: {
      label: {
        show: true,
        color: 'rgb(100,0,0)'
      },
      itemStyle: {
        color: 'rgba(255,215,0,0.8)'
      }
    },
    regions: []
  };
  return GeoModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_5__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoModel);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/geo/fix/diaoyuIsland.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/geo/fix/diaoyuIsland.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fixDiaoyuIsland)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Fix for 
// let Region = require('../Region');
// let zrUtil = require('zrender/lib/core/util');
// let geoCoord = [126, 25];
var points = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function fixDiaoyuIsland(mapType, region) {
  if (mapType === 'china' && region.name === '') {
    region.geometries.push({
      type: 'polygon',
      exterior: points[0]
    });
  }
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/geo/fix/geoCoord.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/geo/fix/geoCoord.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fixGeoCoords)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var geoCoordMap = {
  'Russia': [100, 60],
  'United States': [-99, 38],
  'United States of America': [-99, 38]
};
function fixGeoCoords(mapType, region) {
  if (mapType === 'world') {
    var geoCoord = geoCoordMap[region.name];

    if (geoCoord) {
      var cp = region.center;
      cp[0] = geoCoord[0];
      cp[1] = geoCoord[1];
    }
  }
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/geo/fix/nanhai.js":
/*!**********************************************************!*\
  !*** ./node_modules/echarts/lib/coord/geo/fix/nanhai.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fixNanhai)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _Region__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Region */ "./node_modules/echarts/lib/coord/geo/Region.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Fix for 


var geoCoord = [126, 25];
var points = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];

for (var i = 0; i < points.length; i++) {
  for (var k = 0; k < points[i].length; k++) {
    points[i][k][0] /= 10.5;
    points[i][k][1] /= -10.5 / 0.75;
    points[i][k][0] += geoCoord[0];
    points[i][k][1] += geoCoord[1];
  }
}

function fixNanhai(mapType, regions) {
  if (mapType === 'china') {
    regions.push(new _Region__WEBPACK_IMPORTED_MODULE_0__.default('', zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map(points, function (exterior) {
      return {
        type: 'polygon',
        exterior: exterior
      };
    }), geoCoord));
  }
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/geo/fix/textCoord.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/geo/fix/textCoord.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fixTextCoords)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var coordsOffsetMap = {
  '': [32, 80],
  // 
  '': [0, -10],
  '': [10, 5],
  '': [-10, 10],
  //'': [-10, 0],
  '': [5, 5]
};
function fixTextCoords(mapType, region) {
  if (mapType === 'china') {
    var coordFix = coordsOffsetMap[region.name];

    if (coordFix) {
      var cp = region.center;
      cp[0] += coordFix[0] / 10.5;
      cp[1] += -coordFix[1] / (10.5 / 0.75);
    }
  }
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/geo/geoCreator.js":
/*!**********************************************************!*\
  !*** ./node_modules/echarts/lib/coord/geo/geoCreator.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _Geo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Geo */ "./node_modules/echarts/lib/coord/geo/Geo.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _geoSourceManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./geoSourceManager */ "./node_modules/echarts/lib/coord/geo/geoSourceManager.js");
/* harmony import */ var _mapDataStorage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mapDataStorage */ "./node_modules/echarts/lib/coord/geo/mapDataStorage.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






/**
 * Resize method bound to the geo
 */

function resizeGeo(geoModel, api) {
  var boundingCoords = geoModel.get('boundingCoords');

  if (boundingCoords != null) {
    var leftTop = boundingCoords[0];
    var rightBottom = boundingCoords[1];

    if (isNaN(leftTop[0]) || isNaN(leftTop[1]) || isNaN(rightBottom[0]) || isNaN(rightBottom[1])) {
      if (true) {
        console.error('Invalid boundingCoords');
      }
    } else {
      this.setBoundingRect(leftTop[0], leftTop[1], rightBottom[0] - leftTop[0], rightBottom[1] - leftTop[1]);
    }
  }

  var rect = this.getBoundingRect();
  var centerOption = geoModel.get('layoutCenter');
  var sizeOption = geoModel.get('layoutSize');
  var viewWidth = api.getWidth();
  var viewHeight = api.getHeight();
  var aspect = rect.width / rect.height * this.aspectScale;
  var useCenterAndSize = false;
  var center;
  var size;

  if (centerOption && sizeOption) {
    center = [_util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent(centerOption[0], viewWidth), _util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent(centerOption[1], viewHeight)];
    size = _util_number__WEBPACK_IMPORTED_MODULE_0__.parsePercent(sizeOption, Math.min(viewWidth, viewHeight));

    if (!isNaN(center[0]) && !isNaN(center[1]) && !isNaN(size)) {
      useCenterAndSize = true;
    } else {
      if (true) {
        console.warn('Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.');
      }
    }
  }

  var viewRect;

  if (useCenterAndSize) {
    viewRect = {};

    if (aspect > 1) {
      // Width is same with size
      viewRect.width = size;
      viewRect.height = size / aspect;
    } else {
      viewRect.height = size;
      viewRect.width = size * aspect;
    }

    viewRect.y = center[1] - viewRect.height / 2;
    viewRect.x = center[0] - viewRect.width / 2;
  } else {
    // Use left/top/width/height
    var boxLayoutOption = geoModel.getBoxLayoutParams(); // 0.75 rate

    boxLayoutOption.aspect = aspect;
    viewRect = _util_layout__WEBPACK_IMPORTED_MODULE_1__.getLayoutRect(boxLayoutOption, {
      width: viewWidth,
      height: viewHeight
    });
  }

  this.setViewRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
  this.setCenter(geoModel.get('center'));
  this.setZoom(geoModel.get('zoom'));
} // Back compat for ECharts2, where the coord map is set on map series:
// {type: 'map', geoCoord: {'cityA': [116.46,39.92], 'cityA': [119.12,24.61]}},


function setGeoCoords(geo, model) {
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each(model.get('geoCoord'), function (geoCoord, name) {
    geo.addGeoCoord(name, geoCoord);
  });
}

var GeoCreator =
/** @class */
function () {
  function GeoCreator() {
    // For deciding which dimensions to use when creating list data
    this.dimensions = _Geo__WEBPACK_IMPORTED_MODULE_3__.default.prototype.dimensions;
  }

  GeoCreator.prototype.create = function (ecModel, api) {
    var geoList = []; // FIXME Create each time may be slow

    ecModel.eachComponent('geo', function (geoModel, idx) {
      var name = geoModel.get('map');
      var aspectScale = geoModel.get('aspectScale');
      var invertLongitute = true;
      var mapRecords = _mapDataStorage__WEBPACK_IMPORTED_MODULE_4__.default.retrieveMap(name);

      if (mapRecords && mapRecords[0] && mapRecords[0].type === 'svg') {
        aspectScale == null && (aspectScale = 1);
        invertLongitute = false;
      } else {
        aspectScale == null && (aspectScale = 0.75);
      }

      var geo = new _Geo__WEBPACK_IMPORTED_MODULE_3__.default(name + idx, name, geoModel.get('nameMap'), invertLongitute);
      geo.aspectScale = aspectScale;
      geo.zoomLimit = geoModel.get('scaleLimit');
      geoList.push(geo); // setGeoCoords(geo, geoModel);

      geoModel.coordinateSystem = geo;
      geo.model = geoModel; // Inject resize method

      geo.resize = resizeGeo;
      geo.resize(geoModel, api);
    });
    ecModel.eachSeries(function (seriesModel) {
      var coordSys = seriesModel.get('coordinateSystem');

      if (coordSys === 'geo') {
        var geoIndex = seriesModel.get('geoIndex') || 0;
        seriesModel.coordinateSystem = geoList[geoIndex];
      }
    }); // If has map series

    var mapModelGroupBySeries = {};
    ecModel.eachSeriesByType('map', function (seriesModel) {
      if (!seriesModel.getHostGeoModel()) {
        var mapType = seriesModel.getMapType();
        mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];
        mapModelGroupBySeries[mapType].push(seriesModel);
      }
    });
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each(mapModelGroupBySeries, function (mapSeries, mapType) {
      var nameMapList = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.map(mapSeries, function (singleMapSeries) {
        return singleMapSeries.get('nameMap');
      });
      var geo = new _Geo__WEBPACK_IMPORTED_MODULE_3__.default(mapType, mapType, zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.mergeAll(nameMapList));
      geo.zoomLimit = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.retrieve.apply(null, zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.map(mapSeries, function (singleMapSeries) {
        return singleMapSeries.get('scaleLimit');
      }));
      geoList.push(geo); // Inject resize method

      geo.resize = resizeGeo;
      geo.aspectScale = mapSeries[0].get('aspectScale');
      geo.resize(mapSeries[0], api);
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each(mapSeries, function (singleMapSeries) {
        singleMapSeries.coordinateSystem = geo;
        setGeoCoords(geo, singleMapSeries);
      });
    });
    return geoList;
  };
  /**
   * Fill given regions array
   */


  GeoCreator.prototype.getFilledRegions = function (originRegionArr, mapName, nameMap) {
    // Not use the original
    var regionsArr = (originRegionArr || []).slice();
    var dataNameMap = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.createHashMap();

    for (var i = 0; i < regionsArr.length; i++) {
      dataNameMap.set(regionsArr[i].name, regionsArr[i]);
    }

    var source = _geoSourceManager__WEBPACK_IMPORTED_MODULE_5__.default.load(mapName, nameMap);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each(source.regions, function (region) {
      var name = region.name;
      !dataNameMap.get(name) && regionsArr.push({
        name: name
      });
    });
    return regionsArr;
  };

  return GeoCreator;
}();

var geoCreator = new GeoCreator();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (geoCreator);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/geo/geoJSONLoader.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/geo/geoJSONLoader.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _parseGeoJson__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parseGeoJson */ "./node_modules/echarts/lib/coord/geo/parseGeoJson.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _fix_nanhai__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fix/nanhai */ "./node_modules/echarts/lib/coord/geo/fix/nanhai.js");
/* harmony import */ var _fix_textCoord__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fix/textCoord */ "./node_modules/echarts/lib/coord/geo/fix/textCoord.js");
/* harmony import */ var _fix_geoCoord__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fix/geoCoord */ "./node_modules/echarts/lib/coord/geo/fix/geoCoord.js");
/* harmony import */ var _fix_diaoyuIsland__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fix/diaoyuIsland */ "./node_modules/echarts/lib/coord/geo/fix/diaoyuIsland.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


 // Built-in GEO fixer.





var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  load: function (mapName, mapRecord, nameProperty) {
    var parsed = inner(mapRecord).parsed;

    if (parsed) {
      return parsed;
    }

    var specialAreas = mapRecord.specialAreas || {};
    var geoJSON = mapRecord.geoJSON;
    var regions; // https://jsperf.com/try-catch-performance-overhead

    try {
      regions = geoJSON ? (0,_parseGeoJson__WEBPACK_IMPORTED_MODULE_1__.default)(geoJSON, nameProperty) : [];
    } catch (e) {
      throw new Error('Invalid geoJson format\n' + e.message);
    }

    (0,_fix_nanhai__WEBPACK_IMPORTED_MODULE_2__.default)(mapName, regions);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_3__.each)(regions, function (region) {
      var regionName = region.name;
      (0,_fix_textCoord__WEBPACK_IMPORTED_MODULE_4__.default)(mapName, region);
      (0,_fix_geoCoord__WEBPACK_IMPORTED_MODULE_5__.default)(mapName, region);
      (0,_fix_diaoyuIsland__WEBPACK_IMPORTED_MODULE_6__.default)(mapName, region); // Some area like Alaska in USA map needs to be tansformed
      // to look better

      var specialArea = specialAreas[regionName];

      if (specialArea) {
        region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
      }
    });
    return inner(mapRecord).parsed = {
      regions: regions,
      boundingRect: getBoundingRect(regions)
    };
  }
});

function getBoundingRect(regions) {
  var rect;

  for (var i = 0; i < regions.length; i++) {
    var regionRect = regions[i].getBoundingRect();
    rect = rect || regionRect.clone();
    rect.union(regionRect);
  }

  return rect;
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/geo/geoSVGLoader.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/geo/geoSVGLoader.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_tool_parseSVG__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/tool/parseSVG */ "./node_modules/zrender/lib/tool/parseSVG.js");
/* harmony import */ var zrender_lib_graphic_Group__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/graphic/Group */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var zrender_lib_graphic_shape_Rect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/graphic/shape/Rect */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/BoundingRect */ "./node_modules/zrender/lib/core/BoundingRect.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var inner = (0,_util_model__WEBPACK_IMPORTED_MODULE_0__.makeInner)();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  load: function (mapName, mapRecord) {
    var originRoot = inner(mapRecord).originRoot;

    if (originRoot) {
      return {
        root: originRoot,
        boundingRect: inner(mapRecord).boundingRect
      };
    }

    var graphic = buildGraphic(mapRecord);
    inner(mapRecord).originRoot = graphic.root;
    inner(mapRecord).boundingRect = graphic.boundingRect;
    return graphic;
  },
  makeGraphic: function (mapName, mapRecord, hostKey) {
    // For performance consideration (in large SVG), graphic only maked
    // when necessary and reuse them according to hostKey.
    var field = inner(mapRecord);
    var rootMap = field.rootMap || (field.rootMap = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.createHashMap)());
    var root = rootMap.get(hostKey);

    if (root) {
      return root;
    }

    var originRoot = field.originRoot;
    var boundingRect = field.boundingRect; // For performance, if originRoot is not used by a view,
    // assign it to a view, but not reproduce graphic elements.

    if (!field.originRootHostKey) {
      field.originRootHostKey = hostKey;
      root = originRoot;
    } else {
      root = buildGraphic(mapRecord, boundingRect).root;
    }

    return rootMap.set(hostKey, root);
  },
  removeGraphic: function (mapName, mapRecord, hostKey) {
    var field = inner(mapRecord);
    var rootMap = field.rootMap;
    rootMap && rootMap.removeKey(hostKey);

    if (hostKey === field.originRootHostKey) {
      field.originRootHostKey = null;
    }
  }
});

function buildGraphic(mapRecord, boundingRect) {
  var svgXML = mapRecord.svgXML;
  var result;
  var root;

  try {
    result = svgXML && (0,zrender_lib_tool_parseSVG__WEBPACK_IMPORTED_MODULE_2__.parseSVG)(svgXML, {
      ignoreViewBox: true,
      ignoreRootClip: true
    }) || {};
    root = result.root;
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.assert)(root != null);
  } catch (e) {
    throw new Error('Invalid svg format\n' + e.message);
  }

  var svgWidth = result.width;
  var svgHeight = result.height;
  var viewBoxRect = result.viewBoxRect;

  if (!boundingRect) {
    boundingRect = svgWidth == null || svgHeight == null ? // If svg width / height not specified, calculate
    // bounding rect as the width / height
    root.getBoundingRect() : new zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 0, 0);

    if (svgWidth != null) {
      boundingRect.width = svgWidth;
    }

    if (svgHeight != null) {
      boundingRect.height = svgHeight;
    }
  }

  if (viewBoxRect) {
    var viewBoxTransform = (0,zrender_lib_tool_parseSVG__WEBPACK_IMPORTED_MODULE_2__.makeViewBoxTransform)(viewBoxRect, boundingRect.width, boundingRect.height);
    var elRoot = root;
    root = new zrender_lib_graphic_Group__WEBPACK_IMPORTED_MODULE_4__.default();
    root.add(elRoot);
    elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;
    elRoot.x = viewBoxTransform.x;
    elRoot.y = viewBoxTransform.y;
  }

  root.setClipPath(new zrender_lib_graphic_shape_Rect__WEBPACK_IMPORTED_MODULE_5__.default({
    shape: boundingRect.plain()
  }));
  return {
    root: root,
    boundingRect: boundingRect
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/geo/geoSourceManager.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/geo/geoSourceManager.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _mapDataStorage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mapDataStorage */ "./node_modules/echarts/lib/coord/geo/mapDataStorage.js");
/* harmony import */ var _geoJSONLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geoJSONLoader */ "./node_modules/echarts/lib/coord/geo/geoJSONLoader.js");
/* harmony import */ var _geoSVGLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geoSVGLoader */ "./node_modules/echarts/lib/coord/geo/geoSVGLoader.js");
/* harmony import */ var zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/core/BoundingRect */ "./node_modules/zrender/lib/core/BoundingRect.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var loaders = {
  geoJSON: _geoJSONLoader__WEBPACK_IMPORTED_MODULE_0__.default,
  svg: _geoSVGLoader__WEBPACK_IMPORTED_MODULE_1__.default
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  load: function (mapName, nameMap, nameProperty) {
    var regions = [];
    var regionsMap = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.createHashMap)();
    var nameCoordMap = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.createHashMap)();
    var boundingRect;
    var mapRecords = retrieveMap(mapName);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(mapRecords, function (record) {
      var singleSource = loaders[record.type].load(mapName, record, nameProperty);
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(singleSource.regions, function (region) {
        var regionName = region.name; // Try use the alias in geoNameMap

        if (nameMap && nameMap.hasOwnProperty(regionName)) {
          region = region.cloneShallow(regionName = nameMap[regionName]);
        }

        regions.push(region);
        regionsMap.set(regionName, region);
        nameCoordMap.set(regionName, region.center);
      });
      var rect = singleSource.boundingRect;

      if (rect) {
        boundingRect ? boundingRect.union(rect) : boundingRect = rect.clone();
      }
    });
    return {
      regions: regions,
      regionsMap: regionsMap,
      nameCoordMap: nameCoordMap,
      // FIXME Always return new ?
      boundingRect: boundingRect || new zrender_lib_core_BoundingRect__WEBPACK_IMPORTED_MODULE_3__.default(0, 0, 0, 0)
    };
  },

  /**
   * @param hostKey For cache.
   * @return Roots.
   */
  makeGraphic: function (mapName, hostKey) {
    var mapRecords = retrieveMap(mapName);
    var results = [];
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(mapRecords, function (record) {
      var method = loaders[record.type].makeGraphic;
      method && results.push(method(mapName, record, hostKey));
    });
    return results;
  },

  /**
   * @param hostKey For cache.
   */
  removeGraphic: function (mapName, hostKey) {
    var mapRecords = retrieveMap(mapName);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(mapRecords, function (record) {
      var method = loaders[record.type].makeGraphic;
      method && method(mapName, record, hostKey);
    });
  }
});

function mapNotExistsError(mapName) {
  if (true) {
    console.error('Map ' + mapName + ' not exists. The GeoJSON of the map must be provided.');
  }
}

function retrieveMap(mapName) {
  var mapRecords = _mapDataStorage__WEBPACK_IMPORTED_MODULE_4__.default.retrieveMap(mapName) || [];

  if (true) {
    if (!mapRecords.length) {
      mapNotExistsError(mapName);
    }
  }

  return mapRecords;
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/parallel/AxisModel.js":
/*!**************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/parallel/AxisModel.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");
/* harmony import */ var _model_mixin_makeStyleMapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/mixin/makeStyleMapper */ "./node_modules/echarts/lib/model/mixin/makeStyleMapper.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _axisModelCommonMixin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../axisModelCommonMixin */ "./node_modules/echarts/lib/coord/axisModelCommonMixin.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/







var ParallelAxisModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ParallelAxisModel, _super);

  function ParallelAxisModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ParallelAxisModel.type;
    /**
     * @readOnly
     */

    _this.activeIntervals = [];
    return _this;
  }

  ParallelAxisModel.prototype.getAreaSelectStyle = function () {
    return (0,_model_mixin_makeStyleMapper__WEBPACK_IMPORTED_MODULE_1__.default)([['fill', 'color'], ['lineWidth', 'borderWidth'], ['stroke', 'borderColor'], ['width', 'width'], ['opacity', 'opacity'] // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
    // So do not transfer decal directly.
    ])(this.getModel('areaSelectStyle'));
  };
  /**
   * The code of this feature is put on AxisModel but not ParallelAxis,
   * because axisModel can be alive after echarts updating but instance of
   * ParallelAxis having been disposed. this._activeInterval should be kept
   * when action dispatched (i.e. legend click).
   *
   * @param intervals `interval.length === 0` means set all active.
   */


  ParallelAxisModel.prototype.setActiveIntervals = function (intervals) {
    var activeIntervals = this.activeIntervals = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.clone(intervals); // Normalize

    if (activeIntervals) {
      for (var i = activeIntervals.length - 1; i >= 0; i--) {
        _util_number__WEBPACK_IMPORTED_MODULE_3__.asc(activeIntervals[i]);
      }
    }
  };
  /**
   * @param value When only attempting detect whether 'no activeIntervals set',
   *        `value` is not needed to be input.
   */


  ParallelAxisModel.prototype.getActiveState = function (value) {
    var activeIntervals = this.activeIntervals;

    if (!activeIntervals.length) {
      return 'normal';
    }

    if (value == null || isNaN(+value)) {
      return 'inactive';
    } // Simple optimization


    if (activeIntervals.length === 1) {
      var interval = activeIntervals[0];

      if (interval[0] <= value && value <= interval[1]) {
        return 'active';
      }
    } else {
      for (var i = 0, len = activeIntervals.length; i < len; i++) {
        if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {
          return 'active';
        }
      }
    }

    return 'inactive';
  };

  return ParallelAxisModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_4__.default);

zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_2__.mixin(ParallelAxisModel, _axisModelCommonMixin__WEBPACK_IMPORTED_MODULE_5__.AxisModelCommonMixin);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ParallelAxisModel);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/parallel/Parallel.js":
/*!*************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/parallel/Parallel.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/core/matrix */ "./node_modules/zrender/lib/core/matrix.js");
/* harmony import */ var _util_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/layout */ "./node_modules/echarts/lib/util/layout.js");
/* harmony import */ var _coord_axisHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../coord/axisHelper */ "./node_modules/echarts/lib/coord/axisHelper.js");
/* harmony import */ var _ParallelAxis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ParallelAxis */ "./node_modules/echarts/lib/coord/parallel/ParallelAxis.js");
/* harmony import */ var _util_graphic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/graphic */ "./node_modules/echarts/lib/util/graphic.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _component_helper_sliderMove__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../component/helper/sliderMove */ "./node_modules/echarts/lib/component/helper/sliderMove.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Parallel Coordinates
 * <https://en.wikipedia.org/wiki/Parallel_coordinates>
 */








var each = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each;
var mathMin = Math.min;
var mathMax = Math.max;
var mathFloor = Math.floor;
var mathCeil = Math.ceil;
var round = _util_number__WEBPACK_IMPORTED_MODULE_1__.round;
var PI = Math.PI;

var Parallel =
/** @class */
function () {
  function Parallel(parallelModel, ecModel, api) {
    this.type = 'parallel';
    /**
     * key: dimension
     */

    this._axesMap = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.createHashMap();
    /**
     * key: dimension
     * value: {position: [], rotation, }
     */

    this._axesLayout = {};
    this.dimensions = parallelModel.dimensions;
    this._model = parallelModel;

    this._init(parallelModel, ecModel, api);
  }

  Parallel.prototype._init = function (parallelModel, ecModel, api) {
    var dimensions = parallelModel.dimensions;
    var parallelAxisIndex = parallelModel.parallelAxisIndex;
    each(dimensions, function (dim, idx) {
      var axisIndex = parallelAxisIndex[idx];
      var axisModel = ecModel.getComponent('parallelAxis', axisIndex);

      var axis = this._axesMap.set(dim, new _ParallelAxis__WEBPACK_IMPORTED_MODULE_2__.default(dim, _coord_axisHelper__WEBPACK_IMPORTED_MODULE_3__.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisIndex));

      var isCategory = axis.type === 'category';
      axis.onBand = isCategory && axisModel.get('boundaryGap');
      axis.inverse = axisModel.get('inverse'); // Injection

      axisModel.axis = axis;
      axis.model = axisModel;
      axis.coordinateSystem = axisModel.coordinateSystem = this;
    }, this);
  };
  /**
   * Update axis scale after data processed
   */


  Parallel.prototype.update = function (ecModel, api) {
    this._updateAxesFromSeries(this._model, ecModel);
  };

  Parallel.prototype.containPoint = function (point) {
    var layoutInfo = this._makeLayoutInfo();

    var axisBase = layoutInfo.axisBase;
    var layoutBase = layoutInfo.layoutBase;
    var pixelDimIndex = layoutInfo.pixelDimIndex;
    var pAxis = point[1 - pixelDimIndex];
    var pLayout = point[pixelDimIndex];
    return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;
  };

  Parallel.prototype.getModel = function () {
    return this._model;
  };
  /**
   * Update properties from series
   */


  Parallel.prototype._updateAxesFromSeries = function (parallelModel, ecModel) {
    ecModel.eachSeries(function (seriesModel) {
      if (!parallelModel.contains(seriesModel, ecModel)) {
        return;
      }

      var data = seriesModel.getData();
      each(this.dimensions, function (dim) {
        var axis = this._axesMap.get(dim);

        axis.scale.unionExtentFromData(data, data.mapDimension(dim));
        _coord_axisHelper__WEBPACK_IMPORTED_MODULE_3__.niceScaleExtent(axis.scale, axis.model);
      }, this);
    }, this);
  };
  /**
   * Resize the parallel coordinate system.
   */


  Parallel.prototype.resize = function (parallelModel, api) {
    this._rect = _util_layout__WEBPACK_IMPORTED_MODULE_4__.getLayoutRect(parallelModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });

    this._layoutAxes();
  };

  Parallel.prototype.getRect = function () {
    return this._rect;
  };

  Parallel.prototype._makeLayoutInfo = function () {
    var parallelModel = this._model;
    var rect = this._rect;
    var xy = ['x', 'y'];
    var wh = ['width', 'height'];
    var layout = parallelModel.get('layout');
    var pixelDimIndex = layout === 'horizontal' ? 0 : 1;
    var layoutLength = rect[wh[pixelDimIndex]];
    var layoutExtent = [0, layoutLength];
    var axisCount = this.dimensions.length;
    var axisExpandWidth = restrict(parallelModel.get('axisExpandWidth'), layoutExtent);
    var axisExpandCount = restrict(parallelModel.get('axisExpandCount') || 0, [0, axisCount]);
    var axisExpandable = parallelModel.get('axisExpandable') && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0; // `axisExpandWindow` is According to the coordinates of [0, axisExpandLength],
    // for sake of consider the case that axisCollapseWidth is 0 (when screen is narrow),
    // where collapsed axes should be overlapped.

    var axisExpandWindow = parallelModel.get('axisExpandWindow');
    var winSize;

    if (!axisExpandWindow) {
      winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent);
      var axisExpandCenter = parallelModel.get('axisExpandCenter') || mathFloor(axisCount / 2);
      axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];
      axisExpandWindow[1] = axisExpandWindow[0] + winSize;
    } else {
      winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);
      axisExpandWindow[1] = axisExpandWindow[0] + winSize;
    }

    var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount); // Avoid axisCollapseWidth is too small.

    axisCollapseWidth < 3 && (axisCollapseWidth = 0); // Find the first and last indices > ewin[0] and < ewin[1].

    var winInnerIndices = [mathFloor(round(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil(round(axisExpandWindow[1] / axisExpandWidth, 1)) - 1]; // Pos in ec coordinates.

    var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];
    return {
      layout: layout,
      pixelDimIndex: pixelDimIndex,
      layoutBase: rect[xy[pixelDimIndex]],
      layoutLength: layoutLength,
      axisBase: rect[xy[1 - pixelDimIndex]],
      axisLength: rect[wh[1 - pixelDimIndex]],
      axisExpandable: axisExpandable,
      axisExpandWidth: axisExpandWidth,
      axisCollapseWidth: axisCollapseWidth,
      axisExpandWindow: axisExpandWindow,
      axisCount: axisCount,
      winInnerIndices: winInnerIndices,
      axisExpandWindow0Pos: axisExpandWindow0Pos
    };
  };

  Parallel.prototype._layoutAxes = function () {
    var rect = this._rect;
    var axes = this._axesMap;
    var dimensions = this.dimensions;

    var layoutInfo = this._makeLayoutInfo();

    var layout = layoutInfo.layout;
    axes.each(function (axis) {
      var axisExtent = [0, layoutInfo.axisLength];
      var idx = axis.inverse ? 1 : 0;
      axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);
    });
    each(dimensions, function (dim, idx) {
      var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);
      var positionTable = {
        horizontal: {
          x: posInfo.position,
          y: layoutInfo.axisLength
        },
        vertical: {
          x: 0,
          y: posInfo.position
        }
      };
      var rotationTable = {
        horizontal: PI / 2,
        vertical: 0
      };
      var position = [positionTable[layout].x + rect.x, positionTable[layout].y + rect.y];
      var rotation = rotationTable[layout];
      var transform = zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_5__.create();
      zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_5__.rotate(transform, transform, rotation);
      zrender_lib_core_matrix__WEBPACK_IMPORTED_MODULE_5__.translate(transform, transform, position); // TODO
      // tick layout info
      // TODO
      // update dimensions info based on axis order.

      this._axesLayout[dim] = {
        position: position,
        rotation: rotation,
        transform: transform,
        axisNameAvailableWidth: posInfo.axisNameAvailableWidth,
        axisLabelShow: posInfo.axisLabelShow,
        nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,
        tickDirection: 1,
        labelDirection: 1
      };
    }, this);
  };
  /**
   * Get axis by dim.
   */


  Parallel.prototype.getAxis = function (dim) {
    return this._axesMap.get(dim);
  };
  /**
   * Convert a dim value of a single item of series data to Point.
   */


  Parallel.prototype.dataToPoint = function (value, dim) {
    return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);
  };
  /**
   * Travel data for one time, get activeState of each data item.
   * @param start the start dataIndex that travel from.
   * @param end the next dataIndex of the last dataIndex will be travel.
   */


  Parallel.prototype.eachActiveState = function (data, callback, start, end) {
    start == null && (start = 0);
    end == null && (end = data.count());
    var axesMap = this._axesMap;
    var dimensions = this.dimensions;
    var dataDimensions = [];
    var axisModels = [];
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(dimensions, function (axisDim) {
      dataDimensions.push(data.mapDimension(axisDim));
      axisModels.push(axesMap.get(axisDim).model);
    });
    var hasActiveSet = this.hasAxisBrushed();

    for (var dataIndex = start; dataIndex < end; dataIndex++) {
      var activeState = void 0;

      if (!hasActiveSet) {
        activeState = 'normal';
      } else {
        activeState = 'active';
        var values = data.getValues(dataDimensions, dataIndex);

        for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
          var state = axisModels[j].getActiveState(values[j]);

          if (state === 'inactive') {
            activeState = 'inactive';
            break;
          }
        }
      }

      callback(activeState, dataIndex);
    }
  };
  /**
   * Whether has any activeSet.
   */


  Parallel.prototype.hasAxisBrushed = function () {
    var dimensions = this.dimensions;
    var axesMap = this._axesMap;
    var hasActiveSet = false;

    for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
      if (axesMap.get(dimensions[j]).model.getActiveState() !== 'normal') {
        hasActiveSet = true;
      }
    }

    return hasActiveSet;
  };
  /**
   * Convert coords of each axis to Point.
   *  Return point. For example: [10, 20]
   */


  Parallel.prototype.axisCoordToPoint = function (coord, dim) {
    var axisLayout = this._axesLayout[dim];
    return _util_graphic__WEBPACK_IMPORTED_MODULE_6__.applyTransform([coord, 0], axisLayout.transform);
  };
  /**
   * Get axis layout.
   */


  Parallel.prototype.getAxisLayout = function (dim) {
    return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.clone(this._axesLayout[dim]);
  };
  /**
   * @return {Object} {axisExpandWindow, delta, behavior: 'jump' | 'slide' | 'none'}.
   */


  Parallel.prototype.getSlidedAxisExpandWindow = function (point) {
    var layoutInfo = this._makeLayoutInfo();

    var pixelDimIndex = layoutInfo.pixelDimIndex;
    var axisExpandWindow = layoutInfo.axisExpandWindow.slice();
    var winSize = axisExpandWindow[1] - axisExpandWindow[0];
    var extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)]; // Out of the area of coordinate system.

    if (!this.containPoint(point)) {
      return {
        behavior: 'none',
        axisExpandWindow: axisExpandWindow
      };
    } // Conver the point from global to expand coordinates.


    var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos; // For dragging operation convenience, the window should not be
    // slided when mouse is the center area of the window.

    var delta;
    var behavior = 'slide';
    var axisCollapseWidth = layoutInfo.axisCollapseWidth;

    var triggerArea = this._model.get('axisExpandSlideTriggerArea'); // But consider touch device, jump is necessary.


    var useJump = triggerArea[0] != null;

    if (axisCollapseWidth) {
      if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {
        behavior = 'jump';
        delta = pointCoord - winSize * triggerArea[2];
      } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {
        behavior = 'jump';
        delta = pointCoord - winSize * (1 - triggerArea[2]);
      } else {
        (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);
      }

      delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;
      delta ? (0,_component_helper_sliderMove__WEBPACK_IMPORTED_MODULE_7__.default)(delta, axisExpandWindow, extent, 'all') // Avoid nonsense triger on mousemove.
      : behavior = 'none';
    } // When screen is too narrow, make it visible and slidable, although it is hard to interact.
    else {
        var winSize2 = axisExpandWindow[1] - axisExpandWindow[0];
        var pos = extent[1] * pointCoord / winSize2;
        axisExpandWindow = [mathMax(0, pos - winSize2 / 2)];
        axisExpandWindow[1] = mathMin(extent[1], axisExpandWindow[0] + winSize2);
        axisExpandWindow[0] = axisExpandWindow[1] - winSize2;
      }

    return {
      axisExpandWindow: axisExpandWindow,
      behavior: behavior
    };
  };

  return Parallel;
}();

function restrict(len, extent) {
  return mathMin(mathMax(len, extent[0]), extent[1]);
}

function layoutAxisWithoutExpand(axisIndex, layoutInfo) {
  var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);
  return {
    position: step * axisIndex,
    axisNameAvailableWidth: step,
    axisLabelShow: true
  };
}

function layoutAxisWithExpand(axisIndex, layoutInfo) {
  var layoutLength = layoutInfo.layoutLength;
  var axisExpandWidth = layoutInfo.axisExpandWidth;
  var axisCount = layoutInfo.axisCount;
  var axisCollapseWidth = layoutInfo.axisCollapseWidth;
  var winInnerIndices = layoutInfo.winInnerIndices;
  var position;
  var axisNameAvailableWidth = axisCollapseWidth;
  var axisLabelShow = false;
  var nameTruncateMaxWidth;

  if (axisIndex < winInnerIndices[0]) {
    position = axisIndex * axisCollapseWidth;
    nameTruncateMaxWidth = axisCollapseWidth;
  } else if (axisIndex <= winInnerIndices[1]) {
    position = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];
    axisNameAvailableWidth = axisExpandWidth;
    axisLabelShow = true;
  } else {
    position = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;
    nameTruncateMaxWidth = axisCollapseWidth;
  }

  return {
    position: position,
    axisNameAvailableWidth: axisNameAvailableWidth,
    axisLabelShow: axisLabelShow,
    nameTruncateMaxWidth: nameTruncateMaxWidth
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Parallel);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/parallel/ParallelAxis.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/parallel/ParallelAxis.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Axis */ "./node_modules/echarts/lib/coord/Axis.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var ParallelAxis =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ParallelAxis, _super);

  function ParallelAxis(dim, scale, coordExtent, axisType, axisIndex) {
    var _this = _super.call(this, dim, scale, coordExtent) || this;

    _this.type = axisType || 'value';
    _this.axisIndex = axisIndex;
    return _this;
  }

  ParallelAxis.prototype.isHorizontal = function () {
    return this.coordinateSystem.getModel().get('layout') !== 'horizontal';
  };

  return ParallelAxis;
}(_Axis__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ParallelAxis);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/parallel/ParallelModel.js":
/*!******************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/parallel/ParallelModel.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/




var ParallelModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ParallelModel, _super);

  function ParallelModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ParallelModel.type;
    return _this;
  }

  ParallelModel.prototype.init = function () {
    _super.prototype.init.apply(this, arguments);

    this.mergeOption({});
  };

  ParallelModel.prototype.mergeOption = function (newOption) {
    var thisOption = this.option;
    newOption && zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge(thisOption, newOption, true);

    this._initDimensions();
  };
  /**
   * Whether series or axis is in this coordinate system.
   */


  ParallelModel.prototype.contains = function (model, ecModel) {
    var parallelIndex = model.get('parallelIndex');
    return parallelIndex != null && ecModel.getComponent('parallel', parallelIndex) === this;
  };

  ParallelModel.prototype.setAxisExpand = function (opt) {
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(['axisExpandable', 'axisExpandCenter', 'axisExpandCount', 'axisExpandWidth', 'axisExpandWindow'], function (name) {
      if (opt.hasOwnProperty(name)) {
        // @ts-ignore FIXME: why "never" inferred in this.option[name]?
        this.option[name] = opt[name];
      }
    }, this);
  };

  ParallelModel.prototype._initDimensions = function () {
    var dimensions = this.dimensions = [];
    var parallelAxisIndex = this.parallelAxisIndex = [];
    var axisModels = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.filter(this.ecModel.queryComponents({
      mainType: 'parallelAxis'
    }), function (axisModel) {
      // Can not use this.contains here, because
      // initialization has not been completed yet.
      return (axisModel.get('parallelIndex') || 0) === this.componentIndex;
    }, this);
    zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.each(axisModels, function (axisModel) {
      dimensions.push('dim' + axisModel.get('dim'));
      parallelAxisIndex.push(axisModel.componentIndex);
    });
  };

  ParallelModel.type = 'parallel';
  ParallelModel.dependencies = ['parallelAxis'];
  ParallelModel.layoutMode = 'box';
  ParallelModel.defaultOption = {
    zlevel: 0,
    z: 0,
    left: 80,
    top: 60,
    right: 80,
    bottom: 60,
    // width: {totalWidth} - left - right,
    // height: {totalHeight} - top - bottom,
    layout: 'horizontal',
    // FIXME
    // naming?
    axisExpandable: false,
    axisExpandCenter: null,
    axisExpandCount: 0,
    axisExpandWidth: 50,
    axisExpandRate: 17,
    axisExpandDebounce: 50,
    // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
    // Do not doc to user until necessary.
    axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
    axisExpandTriggerOn: 'click',
    parallelAxisDefault: null
  };
  return ParallelModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_2__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ParallelModel);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/parallel/parallelCreator.js":
/*!********************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/parallel/parallelCreator.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Parallel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Parallel */ "./node_modules/echarts/lib/coord/parallel/Parallel.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Parallel coordinate system creater.
 */



function createParallelCoordSys(ecModel, api) {
  var coordSysList = [];
  ecModel.eachComponent('parallel', function (parallelModel, idx) {
    var coordSys = new _Parallel__WEBPACK_IMPORTED_MODULE_0__.default(parallelModel, ecModel, api);
    coordSys.name = 'parallel_' + idx;
    coordSys.resize(parallelModel, api);
    parallelModel.coordinateSystem = coordSys;
    coordSys.model = parallelModel;
    coordSysList.push(coordSys);
  }); // Inject the coordinateSystems into seriesModel

  ecModel.eachSeries(function (seriesModel) {
    if (seriesModel.get('coordinateSystem') === 'parallel') {
      var parallelModel = seriesModel.getReferringComponents('parallel', _util_model__WEBPACK_IMPORTED_MODULE_1__.SINGLE_REFERRING).models[0];
      seriesModel.coordinateSystem = parallelModel.coordinateSystem;
    }
  });
  return coordSysList;
}

var parallelCoordSysCreator = {
  create: createParallelCoordSys
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parallelCoordSysCreator);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/parallel/parallelPreprocessor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/parallel/parallelPreprocessor.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ parallelPreprocessor)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/model */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


function parallelPreprocessor(option) {
  createParallelIfNeeded(option);
  mergeAxisOptionFromParallel(option);
}
/**
 * Create a parallel coordinate if not exists.
 * @inner
 */

function createParallelIfNeeded(option) {
  if (option.parallel) {
    return;
  }

  var hasParallelSeries = false;
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(option.series, function (seriesOpt) {
    if (seriesOpt && seriesOpt.type === 'parallel') {
      hasParallelSeries = true;
    }
  });

  if (hasParallelSeries) {
    option.parallel = [{}];
  }
}
/**
 * Merge aixs definition from parallel option (if exists) to axis option.
 * @inner
 */


function mergeAxisOptionFromParallel(option) {
  var axes = _util_model__WEBPACK_IMPORTED_MODULE_1__.normalizeToArray(option.parallelAxis);
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(axes, function (axisOption) {
    if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject(axisOption)) {
      return;
    }

    var parallelIndex = axisOption.parallelIndex || 0;
    var parallelOption = _util_model__WEBPACK_IMPORTED_MODULE_1__.normalizeToArray(option.parallel)[parallelIndex];

    if (parallelOption && parallelOption.parallelAxisDefault) {
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.merge(axisOption, parallelOption.parallelAxisDefault, false);
    }
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/coord/radar/IndicatorAxis.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/radar/IndicatorAxis.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Axis */ "./node_modules/echarts/lib/coord/Axis.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var IndicatorAxis =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(IndicatorAxis, _super);

  function IndicatorAxis(dim, scale, radiusExtent) {
    var _this = _super.call(this, dim, scale, radiusExtent) || this;

    _this.type = 'value';
    _this.angle = 0;
    _this.name = '';
    return _this;
  }

  return IndicatorAxis;
}(_Axis__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IndicatorAxis);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/radar/Radar.js":
/*!*******************************************************!*\
  !*** ./node_modules/echarts/lib/coord/radar/Radar.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _IndicatorAxis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IndicatorAxis */ "./node_modules/echarts/lib/coord/radar/IndicatorAxis.js");
/* harmony import */ var _scale_Interval__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../scale/Interval */ "./node_modules/echarts/lib/scale/Interval.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/number */ "./node_modules/echarts/lib/util/number.js");
/* harmony import */ var _axisHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../axisHelper */ "./node_modules/echarts/lib/coord/axisHelper.js");
/* harmony import */ var _scaleRawExtentInfo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../scaleRawExtentInfo */ "./node_modules/echarts/lib/coord/scaleRawExtentInfo.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// TODO clockwise







var Radar =
/** @class */
function () {
  function Radar(radarModel, ecModel, api) {
    /**
     *
     * Radar dimensions
     */
    this.dimensions = [];
    this._model = radarModel;
    this._indicatorAxes = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map)(radarModel.getIndicatorModels(), function (indicatorModel, idx) {
      var dim = 'indicator_' + idx;
      var indicatorAxis = new _IndicatorAxis__WEBPACK_IMPORTED_MODULE_1__.default(dim, new _scale_Interval__WEBPACK_IMPORTED_MODULE_2__.default() // (indicatorModel.get('axisType') === 'log') ? new LogScale() : new IntervalScale()
      );
      indicatorAxis.name = indicatorModel.get('name'); // Inject model and axis

      indicatorAxis.model = indicatorModel;
      indicatorModel.axis = indicatorAxis;
      this.dimensions.push(dim);
      return indicatorAxis;
    }, this);
    this.resize(radarModel, api);
  }

  Radar.prototype.getIndicatorAxes = function () {
    return this._indicatorAxes;
  };

  Radar.prototype.dataToPoint = function (value, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
  }; // TODO: API should be coordToPoint([coord, indicatorIndex])


  Radar.prototype.coordToPoint = function (coord, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    var angle = indicatorAxis.angle;
    var x = this.cx + coord * Math.cos(angle);
    var y = this.cy - coord * Math.sin(angle);
    return [x, y];
  };

  Radar.prototype.pointToData = function (pt) {
    var dx = pt[0] - this.cx;
    var dy = pt[1] - this.cy;
    var radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    var radian = Math.atan2(-dy, dx); // Find the closest angle
    // FIXME index can calculated directly

    var minRadianDiff = Infinity;
    var closestAxis;
    var closestAxisIdx = -1;

    for (var i = 0; i < this._indicatorAxes.length; i++) {
      var indicatorAxis = this._indicatorAxes[i];
      var diff = Math.abs(radian - indicatorAxis.angle);

      if (diff < minRadianDiff) {
        closestAxis = indicatorAxis;
        closestAxisIdx = i;
        minRadianDiff = diff;
      }
    }

    return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];
  };

  Radar.prototype.resize = function (radarModel, api) {
    var center = radarModel.get('center');
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    var viewSize = Math.min(viewWidth, viewHeight) / 2;
    this.cx = _util_number__WEBPACK_IMPORTED_MODULE_3__.parsePercent(center[0], viewWidth);
    this.cy = _util_number__WEBPACK_IMPORTED_MODULE_3__.parsePercent(center[1], viewHeight);
    this.startAngle = radarModel.get('startAngle') * Math.PI / 180; // radius may be single value like `20`, `'80%'`, or array like `[10, '80%']`

    var radius = radarModel.get('radius');

    if (typeof radius === 'string' || typeof radius === 'number') {
      radius = [0, radius];
    }

    this.r0 = _util_number__WEBPACK_IMPORTED_MODULE_3__.parsePercent(radius[0], viewSize);
    this.r = _util_number__WEBPACK_IMPORTED_MODULE_3__.parsePercent(radius[1], viewSize);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(this._indicatorAxes, function (indicatorAxis, idx) {
      indicatorAxis.setExtent(this.r0, this.r);
      var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length; // Normalize to [-PI, PI]

      angle = Math.atan2(Math.sin(angle), Math.cos(angle));
      indicatorAxis.angle = angle;
    }, this);
  };

  Radar.prototype.update = function (ecModel, api) {
    var indicatorAxes = this._indicatorAxes;
    var radarModel = this._model;
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(indicatorAxes, function (indicatorAxis) {
      indicatorAxis.scale.setExtent(Infinity, -Infinity);
    });
    ecModel.eachSeriesByType('radar', function (radarSeries, idx) {
      if (radarSeries.get('coordinateSystem') !== 'radar' // @ts-ignore
      || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel) {
        return;
      }

      var data = radarSeries.getData();
      (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(indicatorAxes, function (indicatorAxis) {
        indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));
      });
    }, this);
    var splitNumber = radarModel.get('splitNumber');

    function increaseInterval(interval) {
      var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10)); // Increase interval

      var f = interval / exp10;

      if (f === 2) {
        f = 5;
      } else {
        // f is 2 or 5
        f *= 2;
      }

      return f * exp10;
    } // Force all the axis fixing the maxSplitNumber.


    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(indicatorAxes, function (indicatorAxis, idx) {
      var rawExtent = (0,_axisHelper__WEBPACK_IMPORTED_MODULE_4__.getScaleExtent)(indicatorAxis.scale, indicatorAxis.model).extent;
      (0,_axisHelper__WEBPACK_IMPORTED_MODULE_4__.niceScaleExtent)(indicatorAxis.scale, indicatorAxis.model);
      var axisModel = indicatorAxis.model;
      var scale = indicatorAxis.scale;
      var fixedMin = (0,_scaleRawExtentInfo__WEBPACK_IMPORTED_MODULE_5__.parseAxisModelMinMax)(scale, axisModel.get('min', true));
      var fixedMax = (0,_scaleRawExtentInfo__WEBPACK_IMPORTED_MODULE_5__.parseAxisModelMinMax)(scale, axisModel.get('max', true));
      var interval = scale.getInterval();

      if (fixedMin != null && fixedMax != null) {
        // User set min, max, divide to get new interval
        scale.setExtent(+fixedMin, +fixedMax);
        scale.setInterval((fixedMax - fixedMin) / splitNumber);
      } else if (fixedMin != null) {
        var max = void 0; // User set min, expand extent on the other side

        do {
          max = fixedMin + interval * splitNumber;
          scale.setExtent(+fixedMin, max); // Interval must been set after extent
          // FIXME

          scale.setInterval(interval);
          interval = increaseInterval(interval);
        } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));
      } else if (fixedMax != null) {
        var min = void 0; // User set min, expand extent on the other side

        do {
          min = fixedMax - interval * splitNumber;
          scale.setExtent(min, +fixedMax);
          scale.setInterval(interval);
          interval = increaseInterval(interval);
        } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));
      } else {
        var nicedSplitNumber = scale.getTicks().length - 1;

        if (nicedSplitNumber > splitNumber) {
          interval = increaseInterval(interval);
        } // TODO


        var max = Math.ceil(rawExtent[1] / interval) * interval;
        var min = _util_number__WEBPACK_IMPORTED_MODULE_3__.round(max - interval * splitNumber);
        scale.setExtent(min, max);
        scale.setInterval(interval);
      }
    });
  };

  Radar.prototype.convertToPixel = function (ecModel, finder, value) {
    console.warn('Not implemented.');
    return null;
  };

  Radar.prototype.convertFromPixel = function (ecModel, finder, pixel) {
    console.warn('Not implemented.');
    return null;
  };

  Radar.prototype.containPoint = function (point) {
    console.warn('Not implemented.');
    return false;
  };

  Radar.create = function (ecModel, api) {
    var radarList = [];
    ecModel.eachComponent('radar', function (radarModel) {
      var radar = new Radar(radarModel, ecModel, api);
      radarList.push(radar);
      radarModel.coordinateSystem = radar;
    });
    ecModel.eachSeriesByType('radar', function (radarSeries) {
      if (radarSeries.get('coordinateSystem') === 'radar') {
        // Inject coordinate system
        // @ts-ignore
        radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];
      }
    });
    return radarList;
  };
  /**
   * Radar dimensions is based on the data
   */


  Radar.dimensions = [];
  return Radar;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Radar);

/***/ }),

/***/ "./node_modules/echarts/lib/coord/radar/RadarModel.js":
/*!************************************************************!*\
  !*** ./node_modules/echarts/lib/coord/radar/RadarModel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/echarts/node_modules/tslib/tslib.es6.js");
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _axisDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../axisDefault */ "./node_modules/echarts/lib/coord/axisDefault.js");
/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/Model */ "./node_modules/echarts/lib/model/Model.js");
/* harmony import */ var _axisModelCommonMixin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../axisModelCommonMixin */ "./node_modules/echarts/lib/coord/axisModelCommonMixin.js");
/* harmony import */ var _model_Component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../model/Component */ "./node_modules/echarts/lib/model/Component.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






var valueAxisDefault = _axisDefault__WEBPACK_IMPORTED_MODULE_0__.default.value;

function defaultsShow(opt, show) {
  return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults({
    show: show
  }, opt);
}

var RadarModel =
/** @class */
function (_super) {
  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(RadarModel, _super);

  function RadarModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = RadarModel.type;
    return _this;
  }

  RadarModel.prototype.optionUpdated = function () {
    var boundaryGap = this.get('boundaryGap');
    var splitNumber = this.get('splitNumber');
    var scale = this.get('scale');
    var axisLine = this.get('axisLine');
    var axisTick = this.get('axisTick'); // let axisType = this.get('axisType');

    var axisLabel = this.get('axisLabel');
    var nameTextStyle = this.get('axisName');
    var showName = this.get(['axisName', 'show']);
    var nameFormatter = this.get(['axisName', 'formatter']);
    var nameGap = this.get('axisNameGap');
    var triggerEvent = this.get('triggerEvent');
    var indicatorModels = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.map(this.get('indicator') || [], function (indicatorOpt) {
      // PENDING
      if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {
        indicatorOpt.min = 0;
      } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {
        indicatorOpt.max = 0;
      }

      var iNameTextStyle = nameTextStyle;

      if (indicatorOpt.color != null) {
        iNameTextStyle = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.defaults({
          color: indicatorOpt.color
        }, nameTextStyle);
      } // Use same configuration


      var innerIndicatorOpt = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge(zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.clone(indicatorOpt), {
        boundaryGap: boundaryGap,
        splitNumber: splitNumber,
        scale: scale,
        axisLine: axisLine,
        axisTick: axisTick,
        // axisType: axisType,
        axisLabel: axisLabel,
        // Compatible with 2 and use text
        name: indicatorOpt.text,
        nameLocation: 'end',
        nameGap: nameGap,
        // min: 0,
        nameTextStyle: iNameTextStyle,
        triggerEvent: triggerEvent
      }, false);

      if (!showName) {
        innerIndicatorOpt.name = '';
      }

      if (typeof nameFormatter === 'string') {
        var indName = innerIndicatorOpt.name;
        innerIndicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '');
      } else if (typeof nameFormatter === 'function') {
        innerIndicatorOpt.name = nameFormatter(innerIndicatorOpt.name, innerIndicatorOpt);
      }

      var model = new _model_Model__WEBPACK_IMPORTED_MODULE_3__.default(innerIndicatorOpt, null, this.ecModel);
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.mixin(model, _axisModelCommonMixin__WEBPACK_IMPORTED_MODULE_4__.AxisModelCommonMixin.prototype); // For triggerEvent.

      model.mainType = 'radar';
      model.componentIndex = this.componentIndex;
      return model;
    }, this);
    this._indicatorModels = indicatorModels;
  };

  RadarModel.prototype.getIndicatorModels = function () {
    return this._indicatorModels;
  };

  RadarModel.type = 'radar';
  RadarModel.defaultOption = {
    zlevel: 0,
    z: 0,
    center: ['50%', '50%'],
    radius: '75%',
    startAngle: 90,
    axisName: {
      show: true // formatter: null
      // textStyle: {}

    },
    boundaryGap: [0, 0],
    splitNumber: 5,
    axisNameGap: 15,
    scale: false,
    // Polygon or circle
    shape: 'polygon',
    axisLine: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_1__.merge({
      lineStyle: {
        color: '#bbb'
      }
    }, valueAxisDefault.axisLine),
    axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
    axisTick: defaultsShow(valueAxisDefault.axisTick, false),
    // axisType: 'value',
    splitLine: defaultsShow(valueAxisDefault.splitLine, true),
    splitArea: defaultsShow(valueAxisDefault.splitArea, true),
    // {text, min, max}
    indicator: []
  };
  return RadarModel;
}(_model_Component__WEBPACK_IMPORTED_MODULE_5__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadarModel);

/***/ }),

/***/ "./node_modules/echarts/lib/util/styleCompat.js":
/*!******************************************************!*\
  !*** ./node_modules/echarts/lib/util/styleCompat.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isEC4CompatibleStyle": () => (/* binding */ isEC4CompatibleStyle),
/* harmony export */   "convertFromEC4CompatibleStyle": () => (/* binding */ convertFromEC4CompatibleStyle),
/* harmony export */   "convertToEC4StyleForCustomSerise": () => (/* binding */ convertToEC4StyleForCustomSerise),
/* harmony export */   "warnDeprecated": () => (/* binding */ warnDeprecated)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

var deprecatedLogs = {};
/**
 * Whether need to call `convertEC4CompatibleStyle`.
 */

function isEC4CompatibleStyle(style, elType, hasOwnTextContentOption, hasOwnTextConfig) {
  // Since echarts5, `RectText` is separated from its host element and style.text
  // does not exist any more. The compat work brings some extra burden on performance.
  // So we provide:
  // `legacy: true` force make compat.
  // `legacy: false`, force do not compat.
  // `legacy` not set: auto detect wheter legacy.
  //     But in this case we do not compat (difficult to detect and rare case):
  //     Becuse custom series and graphic component support "merge", users may firstly
  //     only set `textStrokeWidth` style or secondly only set `text`.
  return style && (style.legacy || style.legacy !== false && !hasOwnTextContentOption && !hasOwnTextConfig && elType !== 'tspan' // Difficult to detect whether legacy for a "text" el.
  && (elType === 'text' || (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(style, 'text')));
}
/**
 * `EC4CompatibleStyle` is style that might be in echarts4 format or echarts5 format.
 * @param hostStyle The properties might be modified.
 * @return If be text el, `textContentStyle` and `textConfig` will not be retured.
 *         Otherwise a `textContentStyle` and `textConfig` will be created, whose props area
 *         retried from the `hostStyle`.
 */

function convertFromEC4CompatibleStyle(hostStyle, elType, isNormal) {
  var srcStyle = hostStyle;
  var textConfig;
  var textContent;
  var textContentStyle;

  if (elType === 'text') {
    textContentStyle = srcStyle;
  } else {
    textContentStyle = {};
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'text') && (textContentStyle.text = srcStyle.text);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'rich') && (textContentStyle.rich = srcStyle.rich);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'textFill') && (textContentStyle.fill = srcStyle.textFill);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'textStroke') && (textContentStyle.stroke = srcStyle.textStroke);
    textContent = {
      type: 'text',
      style: textContentStyle,
      // ec4 do not support rectText trigger.
      // And when text postion is different in normal and emphasis
      // => hover text trigger emphasis;
      // => text position changed, leave mouse pointer immediately;
      // That might cause state incorrect.
      silent: true
    };
    textConfig = {};
    var hasOwnPos = (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'textPosition');

    if (isNormal) {
      textConfig.position = hasOwnPos ? srcStyle.textPosition : 'inside';
    } else {
      hasOwnPos && (textConfig.position = srcStyle.textPosition);
    }

    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'textPosition') && (textConfig.position = srcStyle.textPosition);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'textOffset') && (textConfig.offset = srcStyle.textOffset);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'textRotation') && (textConfig.rotation = srcStyle.textRotation);
    (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'textDistance') && (textConfig.distance = srcStyle.textDistance);
  }

  convertEC4CompatibleRichItem(textContentStyle, hostStyle);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(textContentStyle.rich, function (richItem) {
    convertEC4CompatibleRichItem(richItem, richItem);
  });
  return {
    textConfig: textConfig,
    textContent: textContent
  };
}
/**
 * The result will be set to `out`.
 */

function convertEC4CompatibleRichItem(out, richItem) {
  if (!richItem) {
    return;
  } // (1) For simplicity, make textXXX properties (deprecated since ec5) has
  // higher priority. For example, consider in ec4 `borderColor: 5, textBorderColor: 10`
  // on a rect means `borderColor: 4` on the rect and `borderColor: 10` on an attached
  // richText in ec5.
  // (2) `out === richItem` if and only if `out` is text el or rich item.
  // So we can overwite existing props in `out` since textXXX has higher priority.


  richItem.font = richItem.textFont || richItem.font;
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textStrokeWidth') && (out.lineWidth = richItem.textStrokeWidth);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textAlign') && (out.align = richItem.textAlign);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textVerticalAlign') && (out.verticalAlign = richItem.textVerticalAlign);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textLineHeight') && (out.lineHeight = richItem.textLineHeight);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textWidth') && (out.width = richItem.textWidth);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textHeight') && (out.height = richItem.textHeight);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBackgroundColor') && (out.backgroundColor = richItem.textBackgroundColor);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textPadding') && (out.padding = richItem.textPadding);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBorderColor') && (out.borderColor = richItem.textBorderColor);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBorderWidth') && (out.borderWidth = richItem.textBorderWidth);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBorderRadius') && (out.borderRadius = richItem.textBorderRadius);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBoxShadowColor') && (out.shadowColor = richItem.textBoxShadowColor);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBoxShadowBlur') && (out.shadowBlur = richItem.textBoxShadowBlur);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBoxShadowOffsetX') && (out.shadowOffsetX = richItem.textBoxShadowOffsetX);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBoxShadowOffsetY') && (out.shadowOffsetY = richItem.textBoxShadowOffsetY);
}
/**
 * Convert to pure echarts4 format style.
 * `itemStyle` will be modified, added with ec4 style properties from
 * `textStyle` and `textConfig`.
 *
 * [Caveat]: For simplicity, `insideRollback` in ec4 does not compat, where
 * `styleEmphasis: {textFill: 'red'}` will remove the normal auto added stroke.
 */


function convertToEC4StyleForCustomSerise(itemStl, txStl, txCfg) {
  var out = itemStl; // See `custom.ts`, a trick to set extra `textPosition` firstly.

  out.textPosition = out.textPosition || txCfg.position || 'inside';
  txCfg.offset != null && (out.textOffset = txCfg.offset);
  txCfg.rotation != null && (out.textRotation = txCfg.rotation);
  txCfg.distance != null && (out.textDistance = txCfg.distance);
  var isInside = out.textPosition.indexOf('inside') >= 0;
  var hostFill = itemStl.fill || '#000';
  convertToEC4RichItem(out, txStl);
  var textFillNotSet = out.textFill == null;

  if (isInside) {
    if (textFillNotSet) {
      out.textFill = txCfg.insideFill || '#fff';
      !out.textStroke && txCfg.insideStroke && (out.textStroke = txCfg.insideStroke);
      !out.textStroke && (out.textStroke = hostFill);
      out.textStrokeWidth == null && (out.textStrokeWidth = 2);
    }
  } else {
    if (textFillNotSet) {
      out.textFill = txCfg.outsideFill || hostFill;
    }

    !out.textStroke && txCfg.outsideStroke && (out.textStroke = txCfg.outsideStroke);
  }

  out.text = txStl.text;
  out.rich = txStl.rich;
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each)(txStl.rich, function (richItem) {
    convertToEC4RichItem(richItem, richItem);
  });
  return out;
}

function convertToEC4RichItem(out, richItem) {
  if (!richItem) {
    return;
  }

  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'fill') && (out.textFill = richItem.fill);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'stroke') && (out.textStroke = richItem.fill);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'lineWidth') && (out.textStrokeWidth = richItem.lineWidth);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'font') && (out.font = richItem.font);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'fontStyle') && (out.fontStyle = richItem.fontStyle);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'fontWeight') && (out.fontWeight = richItem.fontWeight);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'fontSize') && (out.fontSize = richItem.fontSize);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'fontFamily') && (out.fontFamily = richItem.fontFamily);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'align') && (out.textAlign = richItem.align);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'verticalAlign') && (out.textVerticalAlign = richItem.verticalAlign);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'lineHeight') && (out.textLineHeight = richItem.lineHeight);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'width') && (out.textWidth = richItem.width);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'height') && (out.textHeight = richItem.height);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'backgroundColor') && (out.textBackgroundColor = richItem.backgroundColor);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'padding') && (out.textPadding = richItem.padding);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'borderColor') && (out.textBorderColor = richItem.borderColor);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'borderWidth') && (out.textBorderWidth = richItem.borderWidth);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'borderRadius') && (out.textBorderRadius = richItem.borderRadius);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'shadowColor') && (out.textBoxShadowColor = richItem.shadowColor);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'shadowBlur') && (out.textBoxShadowBlur = richItem.shadowBlur);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'shadowOffsetX') && (out.textBoxShadowOffsetX = richItem.shadowOffsetX);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'shadowOffsetY') && (out.textBoxShadowOffsetY = richItem.shadowOffsetY);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textShadowColor') && (out.textShadowColor = richItem.textShadowColor);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textShadowBlur') && (out.textShadowBlur = richItem.textShadowBlur);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textShadowOffsetX') && (out.textShadowOffsetX = richItem.textShadowOffsetX);
  (0,zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textShadowOffsetY') && (out.textShadowOffsetY = richItem.textShadowOffsetY);
}

function warnDeprecated(deprecated, insteadApproach) {
  if (true) {
    var key = deprecated + '^_^' + insteadApproach;

    if (!deprecatedLogs[key]) {
      console.warn("[ECharts] DEPRECATED: \"" + deprecated + "\" has been deprecated. " + insteadApproach);
      deprecatedLogs[key] = true;
    }
  }
}

/***/ }),

/***/ "./node_modules/echarts/lib/visual/VisualMapping.js":
/*!**********************************************************!*\
  !*** ./node_modules/echarts/lib/visual/VisualMapping.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/tool/color */ "./node_modules/zrender/lib/tool/color.js");
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/number */ "./node_modules/echarts/lib/util/number.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/



var each = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each;
var isObject = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject;
var CATEGORY_DEFAULT_VISUAL_INDEX = -1;

var VisualMapping =
/** @class */
function () {
  function VisualMapping(option) {
    var mappingMethod = option.mappingMethod;
    var visualType = option.type;
    var thisOption = this.option = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.clone(option);
    this.type = visualType;
    this.mappingMethod = mappingMethod;
    this._normalizeData = normalizers[mappingMethod];
    var visualHandler = VisualMapping.visualHandlers[visualType];
    this.applyVisual = visualHandler.applyVisual;
    this.getColorMapper = visualHandler.getColorMapper;
    this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];

    if (mappingMethod === 'piecewise') {
      normalizeVisualRange(thisOption);
      preprocessForPiecewise(thisOption);
    } else if (mappingMethod === 'category') {
      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,
      // which need no more preprocess except normalize visual.
      : normalizeVisualRange(thisOption, true);
    } else {
      // mappingMethod === 'linear' or 'fixed'
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.assert(mappingMethod !== 'linear' || thisOption.dataExtent);
      normalizeVisualRange(thisOption);
    }
  }

  VisualMapping.prototype.mapValueToVisual = function (value) {
    var normalized = this._normalizeData(value);

    return this._normalizedToVisual(normalized, value);
  };

  VisualMapping.prototype.getNormalizer = function () {
    return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.bind(this._normalizeData, this);
  };
  /**
   * List available visual types.
   *
   * @public
   * @return {Array.<string>}
   */


  VisualMapping.listVisualTypes = function () {
    return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.keys(VisualMapping.visualHandlers);
  }; // /**
  //  * @public
  //  */
  // static addVisualHandler(name, handler) {
  //     visualHandlers[name] = handler;
  // }

  /**
   * @public
   */


  VisualMapping.isValidType = function (visualType) {
    return VisualMapping.visualHandlers.hasOwnProperty(visualType);
  };
  /**
   * Convinent method.
   * Visual can be Object or Array or primary type.
   */


  VisualMapping.eachVisual = function (visual, callback, context) {
    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject(visual)) {
      zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(visual, callback, context);
    } else {
      callback.call(context, visual);
    }
  };

  VisualMapping.mapVisual = function (visual, callback, context) {
    var isPrimary;
    var newVisual = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(visual) ? [] : zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject(visual) ? {} : (isPrimary = true, null);
    VisualMapping.eachVisual(visual, function (v, key) {
      var newVal = callback.call(context, v, key);
      isPrimary ? newVisual = newVal : newVisual[key] = newVal;
    });
    return newVisual;
  };
  /**
   * Retrieve visual properties from given object.
   */


  VisualMapping.retrieveVisuals = function (obj) {
    var ret = {};
    var hasVisual;
    obj && each(VisualMapping.visualHandlers, function (h, visualType) {
      if (obj.hasOwnProperty(visualType)) {
        ret[visualType] = obj[visualType];
        hasVisual = true;
      }
    });
    return hasVisual ? ret : null;
  };
  /**
   * Give order to visual types, considering colorSaturation, colorAlpha depends on color.
   *
   * @public
   * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}
   *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']
   * @return {Array.<string>} Sorted visual types.
   */


  VisualMapping.prepareVisualTypes = function (visualTypes) {
    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(visualTypes)) {
      visualTypes = visualTypes.slice();
    } else if (isObject(visualTypes)) {
      var types_1 = [];
      each(visualTypes, function (item, type) {
        types_1.push(type);
      });
      visualTypes = types_1;
    } else {
      return [];
    }

    visualTypes.sort(function (type1, type2) {
      // color should be front of colorSaturation, colorAlpha, ...
      // symbol and symbolSize do not matter.
      return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;
    });
    return visualTypes;
  };
  /**
   * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.
   * Other visuals are only depends on themself.
   */


  VisualMapping.dependsOn = function (visualType1, visualType2) {
    return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
  };
  /**
   * @param value
   * @param pieceList [{value: ..., interval: [min, max]}, ...]
   *                         Always from small to big.
   * @param findClosestWhenOutside Default to be false
   * @return index
   */


  VisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {
    var possibleI;
    var abs = Infinity; // value has the higher priority.

    for (var i = 0, len = pieceList.length; i < len; i++) {
      var pieceValue = pieceList[i].value;

      if (pieceValue != null) {
        if (pieceValue === value // FIXME
        // It is supposed to compare value according to value type of dimension,
        // but currently value type can exactly be string or number.
        // Compromise for numeric-like string (like '12'), especially
        // in the case that visualMap.categories is ['22', '33'].
        || typeof pieceValue === 'string' && pieceValue === value + '') {
          return i;
        }

        findClosestWhenOutside && updatePossible(pieceValue, i);
      }
    }

    for (var i = 0, len = pieceList.length; i < len; i++) {
      var piece = pieceList[i];
      var interval = piece.interval;
      var close_1 = piece.close;

      if (interval) {
        if (interval[0] === -Infinity) {
          if (littleThan(close_1[1], value, interval[1])) {
            return i;
          }
        } else if (interval[1] === Infinity) {
          if (littleThan(close_1[0], interval[0], value)) {
            return i;
          }
        } else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) {
          return i;
        }

        findClosestWhenOutside && updatePossible(interval[0], i);
        findClosestWhenOutside && updatePossible(interval[1], i);
      }
    }

    if (findClosestWhenOutside) {
      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;
    }

    function updatePossible(val, index) {
      var newAbs = Math.abs(val - value);

      if (newAbs < abs) {
        abs = newAbs;
        possibleI = index;
      }
    }
  };

  VisualMapping.visualHandlers = {
    color: {
      applyVisual: makeApplyVisual('color'),
      getColorMapper: function () {
        var thisOption = this.option;
        return zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {
          !isNormalized && (value = this._normalizeData(value));
          return doMapCategory.call(this, value);
        } : function (value, isNormalized, out) {
          // If output rgb array
          // which will be much faster and useful in pixel manipulation
          var returnRGBArray = !!out;
          !isNormalized && (value = this._normalizeData(value));
          out = zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_1__.fastLerp(value, thisOption.parsedVisual, out);
          return returnRGBArray ? out : zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_1__.stringify(out, 'rgba');
        }, this);
      },
      _normalizedToVisual: {
        linear: function (normalized) {
          return zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_1__.stringify(zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_1__.fastLerp(normalized, this.option.parsedVisual), 'rgba');
        },
        category: doMapCategory,
        piecewise: function (normalized, value) {
          var result = getSpecifiedVisual.call(this, value);

          if (result == null) {
            result = zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_1__.stringify(zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_1__.fastLerp(normalized, this.option.parsedVisual), 'rgba');
          }

          return result;
        },
        fixed: doMapFixed
      }
    },
    colorHue: makePartialColorVisualHandler(function (color, value) {
      return zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_1__.modifyHSL(color, value);
    }),
    colorSaturation: makePartialColorVisualHandler(function (color, value) {
      return zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_1__.modifyHSL(color, null, value);
    }),
    colorLightness: makePartialColorVisualHandler(function (color, value) {
      return zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_1__.modifyHSL(color, null, null, value);
    }),
    colorAlpha: makePartialColorVisualHandler(function (color, value) {
      return zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_1__.modifyAlpha(color, value);
    }),
    decal: {
      applyVisual: makeApplyVisual('decal'),
      _normalizedToVisual: {
        linear: null,
        category: doMapCategory,
        piecewise: null,
        fixed: null
      }
    },
    opacity: {
      applyVisual: makeApplyVisual('opacity'),
      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
    },
    liftZ: {
      applyVisual: makeApplyVisual('liftZ'),
      _normalizedToVisual: {
        linear: doMapFixed,
        category: doMapFixed,
        piecewise: doMapFixed,
        fixed: doMapFixed
      }
    },
    symbol: {
      applyVisual: function (value, getter, setter) {
        var symbolCfg = this.mapValueToVisual(value);
        setter('symbol', symbolCfg);
      },
      _normalizedToVisual: {
        linear: doMapToArray,
        category: doMapCategory,
        piecewise: function (normalized, value) {
          var result = getSpecifiedVisual.call(this, value);

          if (result == null) {
            result = doMapToArray.call(this, normalized);
          }

          return result;
        },
        fixed: doMapFixed
      }
    },
    symbolSize: {
      applyVisual: makeApplyVisual('symbolSize'),
      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
    }
  };
  return VisualMapping;
}();

function preprocessForPiecewise(thisOption) {
  var pieceList = thisOption.pieceList;
  thisOption.hasSpecialVisual = false;
  zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.each(pieceList, function (piece, index) {
    piece.originIndex = index; // piece.visual is "result visual value" but not
    // a visual range, so it does not need to be normalized.

    if (piece.visual != null) {
      thisOption.hasSpecialVisual = true;
    }
  });
}

function preprocessForSpecifiedCategory(thisOption) {
  // Hash categories.
  var categories = thisOption.categories;
  var categoryMap = thisOption.categoryMap = {};
  var visual = thisOption.visual;
  each(categories, function (cate, index) {
    categoryMap[cate] = index;
  }); // Process visual map input.

  if (!zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isArray(visual)) {
    var visualArr_1 = [];

    if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject(visual)) {
      each(visual, function (v, cate) {
        var index = categoryMap[cate];
        visualArr_1[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
      });
    } else {
      // Is primary type, represents default visual.
      visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
    }

    visual = setVisualToOption(thisOption, visualArr_1);
  } // Remove categories that has no visual,
  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.


  for (var i = categories.length - 1; i >= 0; i--) {
    if (visual[i] == null) {
      delete categoryMap[categories[i]];
      categories.pop();
    }
  }
}

function normalizeVisualRange(thisOption, isCategory) {
  var visual = thisOption.visual;
  var visualArr = [];

  if (zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.isObject(visual)) {
    each(visual, function (v) {
      visualArr.push(v);
    });
  } else if (visual != null) {
    visualArr.push(visual);
  }

  var doNotNeedPair = {
    color: 1,
    symbol: 1
  };

  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {
    // Do not care visualArr.length === 0, which is illegal.
    visualArr[1] = visualArr[0];
  }

  setVisualToOption(thisOption, visualArr);
}

function makePartialColorVisualHandler(applyValue) {
  return {
    applyVisual: function (value, getter, setter) {
      // Only used in HSL
      var colorChannel = this.mapValueToVisual(value); // Must not be array value

      setter('color', applyValue(getter('color'), colorChannel));
    },
    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
  };
}

function doMapToArray(normalized) {
  var visual = this.option.visual;
  return visual[Math.round((0,_util_number__WEBPACK_IMPORTED_MODULE_2__.linearMap)(normalized, [0, 1], [0, visual.length - 1], true))] || {}; // TODO {}?
}

function makeApplyVisual(visualType) {
  return function (value, getter, setter) {
    setter(visualType, this.mapValueToVisual(value));
  };
}

function doMapCategory(normalized) {
  var visual = this.option.visual;
  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
}

function doMapFixed() {
  // visual will be convert to array.
  return this.option.visual[0];
}
/**
 * Create mapped to numeric visual
 */


function createNormalizedToNumericVisual(sourceExtent) {
  return {
    linear: function (normalized) {
      return (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.linearMap)(normalized, sourceExtent, this.option.visual, true);
    },
    category: doMapCategory,
    piecewise: function (normalized, value) {
      var result = getSpecifiedVisual.call(this, value);

      if (result == null) {
        result = (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.linearMap)(normalized, sourceExtent, this.option.visual, true);
      }

      return result;
    },
    fixed: doMapFixed
  };
}

function getSpecifiedVisual(value) {
  var thisOption = this.option;
  var pieceList = thisOption.pieceList;

  if (thisOption.hasSpecialVisual) {
    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
    var piece = pieceList[pieceIndex];

    if (piece && piece.visual) {
      return piece.visual[this.type];
    }
  }
}

function setVisualToOption(thisOption, visualArr) {
  thisOption.visual = visualArr;

  if (thisOption.type === 'color') {
    thisOption.parsedVisual = zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.map(visualArr, function (item) {
      return zrender_lib_tool_color__WEBPACK_IMPORTED_MODULE_1__.parse(item);
    });
  }

  return visualArr;
}
/**
 * Normalizers by mapping methods.
 */


var normalizers = {
  linear: function (value) {
    return (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.linearMap)(value, this.option.dataExtent, [0, 1], true);
  },
  piecewise: function (value) {
    var pieceList = this.option.pieceList;
    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);

    if (pieceIndex != null) {
      return (0,_util_number__WEBPACK_IMPORTED_MODULE_2__.linearMap)(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
    }
  },
  category: function (value) {
    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal value

    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;
  },
  fixed: zrender_lib_core_util__WEBPACK_IMPORTED_MODULE_0__.noop
};

function littleThan(close, a, b) {
  return close ? a <= b : a < b;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VisualMapping);

/***/ }),

/***/ "./node_modules/zrender/lib/tool/parseSVG.js":
/*!***************************************************!*\
  !*** ./node_modules/zrender/lib/tool/parseSVG.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeViewBoxTransform": () => (/* binding */ makeViewBoxTransform),
/* harmony export */   "parseSVG": () => (/* binding */ parseSVG),
/* harmony export */   "parseXML": () => (/* reexport safe */ _parseXML__WEBPACK_IMPORTED_MODULE_0__.parseXML)
/* harmony export */ });
/* harmony import */ var _graphic_Group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graphic/Group */ "./node_modules/zrender/lib/graphic/Group.js");
/* harmony import */ var _graphic_Image__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../graphic/Image */ "./node_modules/zrender/lib/graphic/Image.js");
/* harmony import */ var _graphic_shape_Circle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../graphic/shape/Circle */ "./node_modules/zrender/lib/graphic/shape/Circle.js");
/* harmony import */ var _graphic_shape_Rect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../graphic/shape/Rect */ "./node_modules/zrender/lib/graphic/shape/Rect.js");
/* harmony import */ var _graphic_shape_Ellipse__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../graphic/shape/Ellipse */ "./node_modules/zrender/lib/graphic/shape/Ellipse.js");
/* harmony import */ var _graphic_shape_Line__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../graphic/shape/Line */ "./node_modules/zrender/lib/graphic/shape/Line.js");
/* harmony import */ var _graphic_Path__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../graphic/Path */ "./node_modules/zrender/lib/graphic/Path.js");
/* harmony import */ var _graphic_shape_Polygon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../graphic/shape/Polygon */ "./node_modules/zrender/lib/graphic/shape/Polygon.js");
/* harmony import */ var _graphic_shape_Polyline__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../graphic/shape/Polyline */ "./node_modules/zrender/lib/graphic/shape/Polyline.js");
/* harmony import */ var _core_matrix__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../core/matrix */ "./node_modules/zrender/lib/core/matrix.js");
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./path */ "./node_modules/zrender/lib/tool/path.js");
/* harmony import */ var _core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/util */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _graphic_LinearGradient__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../graphic/LinearGradient */ "./node_modules/zrender/lib/graphic/LinearGradient.js");
/* harmony import */ var _graphic_TSpan__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../graphic/TSpan */ "./node_modules/zrender/lib/graphic/TSpan.js");
/* harmony import */ var _parseXML__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parseXML */ "./node_modules/zrender/lib/tool/parseXML.js");















var DILIMITER_REG = /[\s,]+/;
var nodeParsers;
var SVGParser = (function () {
    function SVGParser() {
        this._defs = {};
        this._root = null;
        this._isDefine = false;
        this._isText = false;
    }
    SVGParser.prototype.parse = function (xml, opt) {
        opt = opt || {};
        var svg = (0,_parseXML__WEBPACK_IMPORTED_MODULE_0__.parseXML)(xml);
        if (!svg) {
            throw new Error('Illegal svg');
        }
        var root = new _graphic_Group__WEBPACK_IMPORTED_MODULE_1__.default();
        this._root = root;
        var viewBox = svg.getAttribute('viewBox') || '';
        var width = parseFloat((svg.getAttribute('width') || opt.width));
        var height = parseFloat((svg.getAttribute('height') || opt.height));
        isNaN(width) && (width = null);
        isNaN(height) && (height = null);
        parseAttributes(svg, root, null, true);
        var child = svg.firstChild;
        while (child) {
            this._parseNode(child, root);
            child = child.nextSibling;
        }
        var viewBoxRect;
        var viewBoxTransform;
        if (viewBox) {
            var viewBoxArr = (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.trim)(viewBox).split(DILIMITER_REG);
            if (viewBoxArr.length >= 4) {
                viewBoxRect = {
                    x: parseFloat((viewBoxArr[0] || 0)),
                    y: parseFloat((viewBoxArr[1] || 0)),
                    width: parseFloat(viewBoxArr[2]),
                    height: parseFloat(viewBoxArr[3])
                };
            }
        }
        if (viewBoxRect && width != null && height != null) {
            viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);
            if (!opt.ignoreViewBox) {
                var elRoot = root;
                root = new _graphic_Group__WEBPACK_IMPORTED_MODULE_1__.default();
                root.add(elRoot);
                elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;
                elRoot.x = viewBoxTransform.x;
                elRoot.y = viewBoxTransform.y;
            }
        }
        if (!opt.ignoreRootClip && width != null && height != null) {
            root.setClipPath(new _graphic_shape_Rect__WEBPACK_IMPORTED_MODULE_3__.default({
                shape: { x: 0, y: 0, width: width, height: height }
            }));
        }
        return {
            root: root,
            width: width,
            height: height,
            viewBoxRect: viewBoxRect,
            viewBoxTransform: viewBoxTransform
        };
    };
    SVGParser.prototype._parseNode = function (xmlNode, parentGroup) {
        var nodeName = xmlNode.nodeName.toLowerCase();
        if (nodeName === 'defs') {
            this._isDefine = true;
        }
        else if (nodeName === 'text') {
            this._isText = true;
        }
        var el;
        if (this._isDefine) {
            var parser = defineParsers[nodeName];
            if (parser) {
                var def = parser.call(this, xmlNode);
                var id = xmlNode.getAttribute('id');
                if (id) {
                    this._defs[id] = def;
                }
            }
        }
        else {
            var parser = nodeParsers[nodeName];
            if (parser) {
                el = parser.call(this, xmlNode, parentGroup);
                parentGroup.add(el);
            }
        }
        if (el) {
            var child = xmlNode.firstChild;
            while (child) {
                if (child.nodeType === 1) {
                    this._parseNode(child, el);
                }
                if (child.nodeType === 3 && this._isText) {
                    this._parseText(child, el);
                }
                child = child.nextSibling;
            }
        }
        if (nodeName === 'defs') {
            this._isDefine = false;
        }
        else if (nodeName === 'text') {
            this._isText = false;
        }
    };
    SVGParser.prototype._parseText = function (xmlNode, parentGroup) {
        if (xmlNode.nodeType === 1) {
            var dx = xmlNode.getAttribute('dx') || 0;
            var dy = xmlNode.getAttribute('dy') || 0;
            this._textX += parseFloat(dx);
            this._textY += parseFloat(dy);
        }
        var text = new _graphic_TSpan__WEBPACK_IMPORTED_MODULE_4__.default({
            style: {
                text: xmlNode.textContent
            },
            x: this._textX || 0,
            y: this._textY || 0
        });
        inheritStyle(parentGroup, text);
        parseAttributes(xmlNode, text, this._defs);
        var textStyle = text.style;
        var fontSize = textStyle.fontSize;
        if (fontSize && fontSize < 9) {
            textStyle.fontSize = 9;
            text.scaleX *= fontSize / 9;
            text.scaleY *= fontSize / 9;
        }
        var font = (textStyle.fontSize || textStyle.fontFamily) && [
            textStyle.fontStyle,
            textStyle.fontWeight,
            (textStyle.fontSize || 12) + 'px',
            textStyle.fontFamily || 'sans-serif'
        ].join(' ');
        textStyle.font = font;
        var rect = text.getBoundingRect();
        this._textX += rect.width;
        parentGroup.add(text);
        return text;
    };
    SVGParser.internalField = (function () {
        nodeParsers = {
            'g': function (xmlNode, parentGroup) {
                var g = new _graphic_Group__WEBPACK_IMPORTED_MODULE_1__.default();
                inheritStyle(parentGroup, g);
                parseAttributes(xmlNode, g, this._defs);
                return g;
            },
            'rect': function (xmlNode, parentGroup) {
                var rect = new _graphic_shape_Rect__WEBPACK_IMPORTED_MODULE_3__.default();
                inheritStyle(parentGroup, rect);
                parseAttributes(xmlNode, rect, this._defs);
                rect.setShape({
                    x: parseFloat(xmlNode.getAttribute('x') || '0'),
                    y: parseFloat(xmlNode.getAttribute('y') || '0'),
                    width: parseFloat(xmlNode.getAttribute('width') || '0'),
                    height: parseFloat(xmlNode.getAttribute('height') || '0')
                });
                return rect;
            },
            'circle': function (xmlNode, parentGroup) {
                var circle = new _graphic_shape_Circle__WEBPACK_IMPORTED_MODULE_5__.default();
                inheritStyle(parentGroup, circle);
                parseAttributes(xmlNode, circle, this._defs);
                circle.setShape({
                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),
                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),
                    r: parseFloat(xmlNode.getAttribute('r') || '0')
                });
                return circle;
            },
            'line': function (xmlNode, parentGroup) {
                var line = new _graphic_shape_Line__WEBPACK_IMPORTED_MODULE_6__.default();
                inheritStyle(parentGroup, line);
                parseAttributes(xmlNode, line, this._defs);
                line.setShape({
                    x1: parseFloat(xmlNode.getAttribute('x1') || '0'),
                    y1: parseFloat(xmlNode.getAttribute('y1') || '0'),
                    x2: parseFloat(xmlNode.getAttribute('x2') || '0'),
                    y2: parseFloat(xmlNode.getAttribute('y2') || '0')
                });
                return line;
            },
            'ellipse': function (xmlNode, parentGroup) {
                var ellipse = new _graphic_shape_Ellipse__WEBPACK_IMPORTED_MODULE_7__.default();
                inheritStyle(parentGroup, ellipse);
                parseAttributes(xmlNode, ellipse, this._defs);
                ellipse.setShape({
                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),
                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),
                    rx: parseFloat(xmlNode.getAttribute('rx') || '0'),
                    ry: parseFloat(xmlNode.getAttribute('ry') || '0')
                });
                return ellipse;
            },
            'polygon': function (xmlNode, parentGroup) {
                var pointsStr = xmlNode.getAttribute('points');
                var pointsArr;
                if (pointsStr) {
                    pointsArr = parsePoints(pointsStr);
                }
                var polygon = new _graphic_shape_Polygon__WEBPACK_IMPORTED_MODULE_8__.default({
                    shape: {
                        points: pointsArr || []
                    }
                });
                inheritStyle(parentGroup, polygon);
                parseAttributes(xmlNode, polygon, this._defs);
                return polygon;
            },
            'polyline': function (xmlNode, parentGroup) {
                var path = new _graphic_Path__WEBPACK_IMPORTED_MODULE_9__.default();
                inheritStyle(parentGroup, path);
                parseAttributes(xmlNode, path, this._defs);
                var pointsStr = xmlNode.getAttribute('points');
                var pointsArr;
                if (pointsStr) {
                    pointsArr = parsePoints(pointsStr);
                }
                var polyline = new _graphic_shape_Polyline__WEBPACK_IMPORTED_MODULE_10__.default({
                    shape: {
                        points: pointsArr || []
                    }
                });
                return polyline;
            },
            'image': function (xmlNode, parentGroup) {
                var img = new _graphic_Image__WEBPACK_IMPORTED_MODULE_11__.default();
                inheritStyle(parentGroup, img);
                parseAttributes(xmlNode, img, this._defs);
                img.setStyle({
                    image: xmlNode.getAttribute('xlink:href'),
                    x: +xmlNode.getAttribute('x'),
                    y: +xmlNode.getAttribute('y'),
                    width: +xmlNode.getAttribute('width'),
                    height: +xmlNode.getAttribute('height')
                });
                return img;
            },
            'text': function (xmlNode, parentGroup) {
                var x = xmlNode.getAttribute('x') || '0';
                var y = xmlNode.getAttribute('y') || '0';
                var dx = xmlNode.getAttribute('dx') || '0';
                var dy = xmlNode.getAttribute('dy') || '0';
                this._textX = parseFloat(x) + parseFloat(dx);
                this._textY = parseFloat(y) + parseFloat(dy);
                var g = new _graphic_Group__WEBPACK_IMPORTED_MODULE_1__.default();
                inheritStyle(parentGroup, g);
                parseAttributes(xmlNode, g, this._defs);
                return g;
            },
            'tspan': function (xmlNode, parentGroup) {
                var x = xmlNode.getAttribute('x');
                var y = xmlNode.getAttribute('y');
                if (x != null) {
                    this._textX = parseFloat(x);
                }
                if (y != null) {
                    this._textY = parseFloat(y);
                }
                var dx = xmlNode.getAttribute('dx') || 0;
                var dy = xmlNode.getAttribute('dy') || 0;
                var g = new _graphic_Group__WEBPACK_IMPORTED_MODULE_1__.default();
                inheritStyle(parentGroup, g);
                parseAttributes(xmlNode, g, this._defs);
                this._textX += dx;
                this._textY += dy;
                return g;
            },
            'path': function (xmlNode, parentGroup) {
                var d = xmlNode.getAttribute('d') || '';
                var path = (0,_path__WEBPACK_IMPORTED_MODULE_12__.createFromString)(d);
                inheritStyle(parentGroup, path);
                parseAttributes(xmlNode, path, this._defs);
                return path;
            }
        };
    })();
    return SVGParser;
}());
var defineParsers = {
    'lineargradient': function (xmlNode) {
        var x1 = parseInt(xmlNode.getAttribute('x1') || '0', 10);
        var y1 = parseInt(xmlNode.getAttribute('y1') || '0', 10);
        var x2 = parseInt(xmlNode.getAttribute('x2') || '10', 10);
        var y2 = parseInt(xmlNode.getAttribute('y2') || '0', 10);
        var gradient = new _graphic_LinearGradient__WEBPACK_IMPORTED_MODULE_13__.default(x1, y1, x2, y2);
        _parseGradientColorStops(xmlNode, gradient);
        return gradient;
    }
};
function _parseGradientColorStops(xmlNode, gradient) {
    var stop = xmlNode.firstChild;
    while (stop) {
        if (stop.nodeType === 1) {
            var offsetStr = stop.getAttribute('offset');
            var offset = void 0;
            if (offsetStr.indexOf('%') > 0) {
                offset = parseInt(offsetStr, 10) / 100;
            }
            else if (offsetStr) {
                offset = parseFloat(offsetStr);
            }
            else {
                offset = 0;
            }
            var stopColor = stop.getAttribute('stop-color') || '#000000';
            gradient.colorStops.push({
                offset: offset,
                color: stopColor
            });
        }
        stop = stop.nextSibling;
    }
}
function inheritStyle(parent, child) {
    if (parent && parent.__inheritedStyle) {
        if (!child.__inheritedStyle) {
            child.__inheritedStyle = {};
        }
        (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.defaults)(child.__inheritedStyle, parent.__inheritedStyle);
    }
}
function parsePoints(pointsString) {
    var list = (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.trim)(pointsString).split(DILIMITER_REG);
    var points = [];
    for (var i = 0; i < list.length; i += 2) {
        var x = parseFloat(list[i]);
        var y = parseFloat(list[i + 1]);
        points.push([x, y]);
    }
    return points;
}
var attributesMap = {
    'fill': 'fill',
    'stroke': 'stroke',
    'stroke-width': 'lineWidth',
    'opacity': 'opacity',
    'fill-opacity': 'fillOpacity',
    'stroke-opacity': 'strokeOpacity',
    'stroke-dasharray': 'lineDash',
    'stroke-dashoffset': 'lineDashOffset',
    'stroke-linecap': 'lineCap',
    'stroke-linejoin': 'lineJoin',
    'stroke-miterlimit': 'miterLimit',
    'font-family': 'fontFamily',
    'font-size': 'fontSize',
    'font-style': 'fontStyle',
    'font-weight': 'fontWeight',
    'text-align': 'textAlign',
    'alignment-baseline': 'textBaseline'
};
function parseAttributes(xmlNode, el, defs, onlyInlineStyle) {
    var disp = el;
    var zrStyle = disp.__inheritedStyle || {};
    if (xmlNode.nodeType === 1) {
        parseTransformAttribute(xmlNode, el);
        (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.extend)(zrStyle, parseStyleAttribute(xmlNode));
        if (!onlyInlineStyle) {
            for (var svgAttrName in attributesMap) {
                if (attributesMap.hasOwnProperty(svgAttrName)) {
                    var attrValue = xmlNode.getAttribute(svgAttrName);
                    if (attrValue != null) {
                        zrStyle[attributesMap[svgAttrName]] = attrValue;
                    }
                }
            }
        }
    }
    disp.style = disp.style || {};
    zrStyle.fill != null && (disp.style.fill = getPaint(zrStyle.fill, defs));
    zrStyle.stroke != null && (disp.style.stroke = getPaint(zrStyle.stroke, defs));
    (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.each)([
        'lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'
    ], function (propName) {
        zrStyle[propName] != null && (disp.style[propName] = parseFloat(zrStyle[propName]));
    });
    if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {
        zrStyle.textBaseline = 'alphabetic';
    }
    if (zrStyle.textBaseline === 'alphabetic') {
        zrStyle.textBaseline = 'bottom';
    }
    if (zrStyle.textAlign === 'start') {
        zrStyle.textAlign = 'left';
    }
    if (zrStyle.textAlign === 'end') {
        zrStyle.textAlign = 'right';
    }
    (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.each)(['lineDashOffset', 'lineCap', 'lineJoin',
        'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'
    ], function (propName) {
        zrStyle[propName] != null && (disp.style[propName] = zrStyle[propName]);
    });
    if (zrStyle.lineDash) {
        disp.style.lineDash = (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.map)((0,_core_util__WEBPACK_IMPORTED_MODULE_2__.trim)(zrStyle.lineDash).split(DILIMITER_REG), function (str) {
            return parseFloat(str);
        });
    }
    disp.__inheritedStyle = zrStyle;
}
var urlRegex = /url\(\s*#(.*?)\)/;
function getPaint(str, defs) {
    var urlMatch = defs && str && str.match(urlRegex);
    if (urlMatch) {
        var url = (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.trim)(urlMatch[1]);
        var def = defs[url];
        return def;
    }
    return str;
}
var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g;
function parseTransformAttribute(xmlNode, node) {
    var transform = xmlNode.getAttribute('transform');
    if (transform) {
        transform = transform.replace(/,/g, ' ');
        var transformOps_1 = [];
        var m = null;
        transform.replace(transformRegex, function (str, type, value) {
            transformOps_1.push(type, value);
            return '';
        });
        for (var i = transformOps_1.length - 1; i > 0; i -= 2) {
            var value = transformOps_1[i];
            var type = transformOps_1[i - 1];
            var valueArr = void 0;
            m = m || _core_matrix__WEBPACK_IMPORTED_MODULE_14__.create();
            switch (type) {
                case 'translate':
                    valueArr = (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.trim)(value).split(DILIMITER_REG);
                    _core_matrix__WEBPACK_IMPORTED_MODULE_14__.translate(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || '0')]);
                    break;
                case 'scale':
                    valueArr = (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.trim)(value).split(DILIMITER_REG);
                    _core_matrix__WEBPACK_IMPORTED_MODULE_14__.scale(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);
                    break;
                case 'rotate':
                    valueArr = (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.trim)(value).split(DILIMITER_REG);
                    _core_matrix__WEBPACK_IMPORTED_MODULE_14__.rotate(m, m, parseFloat(valueArr[0]));
                    break;
                case 'skew':
                    valueArr = (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.trim)(value).split(DILIMITER_REG);
                    console.warn('Skew transform is not supported yet');
                    break;
                case 'matrix':
                    valueArr = (0,_core_util__WEBPACK_IMPORTED_MODULE_2__.trim)(value).split(DILIMITER_REG);
                    m[0] = parseFloat(valueArr[0]);
                    m[1] = parseFloat(valueArr[1]);
                    m[2] = parseFloat(valueArr[2]);
                    m[3] = parseFloat(valueArr[3]);
                    m[4] = parseFloat(valueArr[4]);
                    m[5] = parseFloat(valueArr[5]);
                    break;
            }
        }
        node.setLocalTransform(m);
    }
}
var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function parseStyleAttribute(xmlNode) {
    var style = xmlNode.getAttribute('style');
    var result = {};
    if (!style) {
        return result;
    }
    var styleList = {};
    styleRegex.lastIndex = 0;
    var styleRegResult;
    while ((styleRegResult = styleRegex.exec(style)) != null) {
        styleList[styleRegResult[1]] = styleRegResult[2];
    }
    for (var svgAttrName in attributesMap) {
        if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {
            result[attributesMap[svgAttrName]] = styleList[svgAttrName];
        }
    }
    return result;
}
function makeViewBoxTransform(viewBoxRect, width, height) {
    var scaleX = width / viewBoxRect.width;
    var scaleY = height / viewBoxRect.height;
    var scale = Math.min(scaleX, scaleY);
    return {
        scale: scale,
        x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2,
        y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2
    };
}
function parseSVG(xml, opt) {
    var parser = new SVGParser();
    return parser.parse(xml, opt);
}



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2FjdGlvbi9yb2FtSGVscGVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL0xpbmUuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGluZURyYXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGluZVBhdGguanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvU3ltYm9sLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL1N5bWJvbERyYXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvbGFiZWxIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9BeGlzQnVpbGRlci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL0F4aXNWaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQ2FydGVzaWFuQXhpc1ZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9QYXJhbGxlbEF4aXNWaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvYXhpc1NwbGl0SGVscGVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvcGFyYWxsZWxBeGlzQWN0aW9uLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL21vZGVsSGVscGVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2dlby9HZW9WaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2dlby9pbnN0YWxsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2dyaWQvaW5zdGFsbFNpbXBsZS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hDb250cm9sbGVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9NYXBEcmF3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvYnJ1c2hIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2N1cnNvckhlbHBlci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvaW50ZXJhY3Rpb25NdXRleC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvcm9hbUhlbHBlci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvc2xpZGVyTW92ZS5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9wYXJhbGxlbC9QYXJhbGxlbFZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvcGFyYWxsZWwvaW5zdGFsbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9yYWRhci9SYWRhclZpZXcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvcmFkYXIvaW5zdGFsbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL0Nvb3JkaW5hdGVTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9WaWV3LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc0NvbW1vblR5cGVzLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc0RlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9heGlzTW9kZWxDcmVhdG9yLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0F4aXMyRC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vQ2FydGVzaWFuLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbjJELmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0dyaWQuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vR3JpZE1vZGVsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL2NhcnRlc2lhbkF4aXNIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9nZW8vR2VvLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL0dlb01vZGVsLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL2ZpeC9kaWFveXVJc2xhbmQuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9nZW8vZml4L2dlb0Nvb3JkLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL2ZpeC9uYW5oYWkuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9nZW8vZml4L3RleHRDb29yZC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2dlby9nZW9DcmVhdG9yLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL2dlb0pTT05Mb2FkZXIuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9nZW8vZ2VvU1ZHTG9hZGVyLmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL2dlb1NvdXJjZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9wYXJhbGxlbC9BeGlzTW9kZWwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9wYXJhbGxlbC9QYXJhbGxlbC5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL3BhcmFsbGVsL1BhcmFsbGVsQXhpcy5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL3BhcmFsbGVsL1BhcmFsbGVsTW9kZWwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9wYXJhbGxlbC9wYXJhbGxlbENyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9wYXJhbGxlbC9wYXJhbGxlbFByZXByb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL3JhZGFyL0luZGljYXRvckF4aXMuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9yYWRhci9SYWRhci5qcyIsIndlYnBhY2s6Ly9kaS13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL3JhZGFyL1JhZGFyTW9kZWwuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL3N0eWxlQ29tcGF0LmpzIiwid2VicGFjazovL2RpLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlzdWFsL1Zpc3VhbE1hcHBpbmcuanMiLCJ3ZWJwYWNrOi8vZGktd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi90b29sL3BhcnNlU1ZHLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlFQTtB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RUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLENBQUMsQ0FBQyxrREFBYTs7QUFFZixpRUFBZSxJQUFJLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6Y25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDZjtBQUMrQjs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxx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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDb0IiLCJmaWxlIjoiZGFzaGJvYXJkL2pzL2Rhc2hib2FyZGQ5ZGVmNGNkNDA0YjU0MWI1YjNhLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQ2VudGVyQW5kWm9vbSh2aWV3LCBwYXlsb2FkLCB6b29tTGltaXQpIHtcbiAgdmFyIHByZXZpb3VzWm9vbSA9IHZpZXcuZ2V0Wm9vbSgpO1xuICB2YXIgY2VudGVyID0gdmlldy5nZXRDZW50ZXIoKTtcbiAgdmFyIHpvb20gPSBwYXlsb2FkLnpvb207XG4gIHZhciBwb2ludCA9IHZpZXcuZGF0YVRvUG9pbnQoY2VudGVyKTtcblxuICBpZiAocGF5bG9hZC5keCAhPSBudWxsICYmIHBheWxvYWQuZHkgIT0gbnVsbCkge1xuICAgIHBvaW50WzBdIC09IHBheWxvYWQuZHg7XG4gICAgcG9pbnRbMV0gLT0gcGF5bG9hZC5keTtcbiAgICB2aWV3LnNldENlbnRlcih2aWV3LnBvaW50VG9EYXRhKHBvaW50KSk7XG4gIH1cblxuICBpZiAoem9vbSAhPSBudWxsKSB7XG4gICAgaWYgKHpvb21MaW1pdCkge1xuICAgICAgdmFyIHpvb21NaW4gPSB6b29tTGltaXQubWluIHx8IDA7XG4gICAgICB2YXIgem9vbU1heCA9IHpvb21MaW1pdC5tYXggfHwgSW5maW5pdHk7XG4gICAgICB6b29tID0gTWF0aC5tYXgoTWF0aC5taW4ocHJldmlvdXNab29tICogem9vbSwgem9vbU1heCksIHpvb21NaW4pIC8gcHJldmlvdXNab29tO1xuICAgIH0gLy8gWm9vbSBvbiBnaXZlbiBwb2ludChvcmlnaW5YLCBvcmlnaW5ZKVxuXG5cbiAgICB2aWV3LnNjYWxlWCAqPSB6b29tO1xuICAgIHZpZXcuc2NhbGVZICo9IHpvb207XG4gICAgdmFyIGZpeFggPSAocGF5bG9hZC5vcmlnaW5YIC0gdmlldy54KSAqICh6b29tIC0gMSk7XG4gICAgdmFyIGZpeFkgPSAocGF5bG9hZC5vcmlnaW5ZIC0gdmlldy55KSAqICh6b29tIC0gMSk7XG4gICAgdmlldy54IC09IGZpeFg7XG4gICAgdmlldy55IC09IGZpeFk7XG4gICAgdmlldy51cGRhdGVUcmFuc2Zvcm0oKTsgLy8gR2V0IHRoZSBuZXcgY2VudGVyXG5cbiAgICB2aWV3LnNldENlbnRlcih2aWV3LnBvaW50VG9EYXRhKHBvaW50KSk7XG4gICAgdmlldy5zZXRab29tKHpvb20gKiBwcmV2aW91c1pvb20pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjZW50ZXI6IHZpZXcuZ2V0Q2VudGVyKCksXG4gICAgem9vbTogdmlldy5nZXRab29tKClcbiAgfTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCAqIGFzIHZlY3RvciBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvcic7XG5pbXBvcnQgKiBhcyBzeW1ib2xVdGlsIGZyb20gJy4uLy4uL3V0aWwvc3ltYm9sJztcbmltcG9ydCBFQ0xpbmVQYXRoIGZyb20gJy4vTGluZVBhdGgnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IHsgZW5hYmxlSG92ZXJFbXBoYXNpcywgZW50ZXJFbXBoYXNpcywgbGVhdmVFbXBoYXNpcywgU1BFQ0lBTF9TVEFURVMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcyc7XG5pbXBvcnQgeyBnZXRMYWJlbFN0YXRlc01vZGVscywgc2V0TGFiZWxTdHlsZSB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUnO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG52YXIgU1lNQk9MX0NBVEVHT1JJRVMgPSBbJ2Zyb21TeW1ib2wnLCAndG9TeW1ib2wnXTtcblxuZnVuY3Rpb24gbWFrZVN5bWJvbFR5cGVLZXkoc3ltYm9sQ2F0ZWdvcnkpIHtcbiAgcmV0dXJuICdfJyArIHN5bWJvbENhdGVnb3J5ICsgJ1R5cGUnO1xufVxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVN5bWJvbChuYW1lLCBsaW5lRGF0YSwgaWR4KSB7XG4gIHZhciBzeW1ib2xUeXBlID0gbGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsIG5hbWUpO1xuXG4gIGlmICghc3ltYm9sVHlwZSB8fCBzeW1ib2xUeXBlID09PSAnbm9uZScpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc3ltYm9sU2l6ZSA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCBuYW1lICsgJ1NpemUnKTtcbiAgdmFyIHN5bWJvbFJvdGF0ZSA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCBuYW1lICsgJ1JvdGF0ZScpO1xuICB2YXIgc3ltYm9sU2l6ZUFyciA9IHpyVXRpbC5pc0FycmF5KHN5bWJvbFNpemUpID8gc3ltYm9sU2l6ZSA6IFtzeW1ib2xTaXplLCBzeW1ib2xTaXplXTtcbiAgdmFyIHN5bWJvbFBhdGggPSBzeW1ib2xVdGlsLmNyZWF0ZVN5bWJvbChzeW1ib2xUeXBlLCAtc3ltYm9sU2l6ZUFyclswXSAvIDIsIC1zeW1ib2xTaXplQXJyWzFdIC8gMiwgc3ltYm9sU2l6ZUFyclswXSwgc3ltYm9sU2l6ZUFyclsxXSk7XG4gIHN5bWJvbFBhdGguX19zcGVjaWZpZWRSb3RhdGlvbiA9IHN5bWJvbFJvdGF0ZSA9PSBudWxsIHx8IGlzTmFOKHN5bWJvbFJvdGF0ZSkgPyB2b2lkIDAgOiArc3ltYm9sUm90YXRlICogTWF0aC5QSSAvIDE4MCB8fCAwO1xuICBzeW1ib2xQYXRoLm5hbWUgPSBuYW1lO1xuICByZXR1cm4gc3ltYm9sUGF0aDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGluZShwb2ludHMpIHtcbiAgdmFyIGxpbmUgPSBuZXcgRUNMaW5lUGF0aCh7XG4gICAgbmFtZTogJ2xpbmUnLFxuICAgIHN1YlBpeGVsT3B0aW1pemU6IHRydWVcbiAgfSk7XG4gIHNldExpbmVQb2ludHMobGluZS5zaGFwZSwgcG9pbnRzKTtcbiAgcmV0dXJuIGxpbmU7XG59XG5cbmZ1bmN0aW9uIHNldExpbmVQb2ludHModGFyZ2V0U2hhcGUsIHBvaW50cykge1xuICB0YXJnZXRTaGFwZS54MSA9IHBvaW50c1swXVswXTtcbiAgdGFyZ2V0U2hhcGUueTEgPSBwb2ludHNbMF1bMV07XG4gIHRhcmdldFNoYXBlLngyID0gcG9pbnRzWzFdWzBdO1xuICB0YXJnZXRTaGFwZS55MiA9IHBvaW50c1sxXVsxXTtcbiAgdGFyZ2V0U2hhcGUucGVyY2VudCA9IDE7XG4gIHZhciBjcDEgPSBwb2ludHNbMl07XG5cbiAgaWYgKGNwMSkge1xuICAgIHRhcmdldFNoYXBlLmNweDEgPSBjcDFbMF07XG4gICAgdGFyZ2V0U2hhcGUuY3B5MSA9IGNwMVsxXTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRTaGFwZS5jcHgxID0gTmFOO1xuICAgIHRhcmdldFNoYXBlLmNweTEgPSBOYU47XG4gIH1cbn1cblxudmFyIExpbmUgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTGluZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBMaW5lKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF90aGlzLl9jcmVhdGVMaW5lKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIExpbmUucHJvdG90eXBlLl9jcmVhdGVMaW5lID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgdmFyIHNlcmllc01vZGVsID0gbGluZURhdGEuaG9zdE1vZGVsO1xuICAgIHZhciBsaW5lUG9pbnRzID0gbGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgIHZhciBsaW5lID0gY3JlYXRlTGluZShsaW5lUG9pbnRzKTtcbiAgICBsaW5lLnNoYXBlLnBlcmNlbnQgPSAwO1xuICAgIGdyYXBoaWMuaW5pdFByb3BzKGxpbmUsIHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHBlcmNlbnQ6IDFcbiAgICAgIH1cbiAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICB0aGlzLmFkZChsaW5lKTtcbiAgICB6clV0aWwuZWFjaChTWU1CT0xfQ0FURUdPUklFUywgZnVuY3Rpb24gKHN5bWJvbENhdGVnb3J5KSB7XG4gICAgICB2YXIgc3ltYm9sID0gY3JlYXRlU3ltYm9sKHN5bWJvbENhdGVnb3J5LCBsaW5lRGF0YSwgaWR4KTsgLy8gc3ltYm9scyBtdXN0IGFkZGVkIGFmdGVyIGxpbmUgdG8gbWFrZSBzdXJlXG4gICAgICAvLyBpdCB3aWxsIGJlIHVwZGF0ZWQgYWZ0ZXIgbGluZSN1cGRhdGUuXG4gICAgICAvLyBPciBzeW1ib2wgcG9zaXRpb24gYW5kIHJvdGF0aW9uIHVwZGF0ZSBpbiBsaW5lI2JlZm9yZVVwZGF0ZSB3aWxsIGJlIG9uZSBmcmFtZSBzbG93XG5cbiAgICAgIHRoaXMuYWRkKHN5bWJvbCk7XG4gICAgICB0aGlzW21ha2VTeW1ib2xUeXBlS2V5KHN5bWJvbENhdGVnb3J5KV0gPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgc3ltYm9sQ2F0ZWdvcnkpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fdXBkYXRlQ29tbW9uU3RsKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbiAgfTsgLy8gVE9ETyBNb3JlIHN0cmljdCBvbiB0aGUgTGlzdCB0eXBlIGluIHBhcmFtZXRlcnM/XG5cblxuICBMaW5lLnByb3RvdHlwZS51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgdmFyIHNlcmllc01vZGVsID0gbGluZURhdGEuaG9zdE1vZGVsO1xuICAgIHZhciBsaW5lID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZScpO1xuICAgIHZhciBsaW5lUG9pbnRzID0gbGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICBzaGFwZToge31cbiAgICB9O1xuICAgIHNldExpbmVQb2ludHModGFyZ2V0LnNoYXBlLCBsaW5lUG9pbnRzKTtcbiAgICBncmFwaGljLnVwZGF0ZVByb3BzKGxpbmUsIHRhcmdldCwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgenJVdGlsLmVhY2goU1lNQk9MX0NBVEVHT1JJRVMsIGZ1bmN0aW9uIChzeW1ib2xDYXRlZ29yeSkge1xuICAgICAgdmFyIHN5bWJvbFR5cGUgPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgc3ltYm9sQ2F0ZWdvcnkpO1xuICAgICAgdmFyIGtleSA9IG1ha2VTeW1ib2xUeXBlS2V5KHN5bWJvbENhdGVnb3J5KTsgLy8gU3ltYm9sIGNoYW5nZWRcblxuICAgICAgaWYgKHRoaXNba2V5XSAhPT0gc3ltYm9sVHlwZSkge1xuICAgICAgICB0aGlzLnJlbW92ZSh0aGlzLmNoaWxkT2ZOYW1lKHN5bWJvbENhdGVnb3J5KSk7XG4gICAgICAgIHZhciBzeW1ib2wgPSBjcmVhdGVTeW1ib2woc3ltYm9sQ2F0ZWdvcnksIGxpbmVEYXRhLCBpZHgpO1xuICAgICAgICB0aGlzLmFkZChzeW1ib2wpO1xuICAgICAgfVxuXG4gICAgICB0aGlzW2tleV0gPSBzeW1ib2xUeXBlO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fdXBkYXRlQ29tbW9uU3RsKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbiAgfTtcblxuICA7XG5cbiAgTGluZS5wcm90b3R5cGUuZ2V0TGluZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRBdCgwKTtcbiAgfTtcblxuICBMaW5lLnByb3RvdHlwZS5fdXBkYXRlQ29tbW9uU3RsID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgdmFyIHNlcmllc01vZGVsID0gbGluZURhdGEuaG9zdE1vZGVsO1xuICAgIHZhciBsaW5lID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZScpO1xuICAgIHZhciBlbXBoYXNpc0xpbmVTdHlsZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmVtcGhhc2lzTGluZVN0eWxlO1xuICAgIHZhciBibHVyTGluZVN0eWxlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuYmx1ckxpbmVTdHlsZTtcbiAgICB2YXIgc2VsZWN0TGluZVN0eWxlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuc2VsZWN0TGluZVN0eWxlO1xuICAgIHZhciBsYWJlbFN0YXRlc01vZGVscyA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmxhYmVsU3RhdGVzTW9kZWxzOyAvLyBPcHRpbWl6YXRpb24gZm9yIGxhcmdlIGRhdGFzZXRcblxuICAgIGlmICghc2VyaWVzU2NvcGUgfHwgbGluZURhdGEuaGFzSXRlbU9wdGlvbikge1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGxpbmVEYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgZW1waGFzaXNMaW5lU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoWydlbXBoYXNpcycsICdsaW5lU3R5bGUnXSkuZ2V0TGluZVN0eWxlKCk7XG4gICAgICBibHVyTGluZVN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKFsnYmx1cicsICdsaW5lU3R5bGUnXSkuZ2V0TGluZVN0eWxlKCk7XG4gICAgICBzZWxlY3RMaW5lU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoWydzZWxlY3QnLCAnbGluZVN0eWxlJ10pLmdldExpbmVTdHlsZSgpO1xuICAgICAgbGFiZWxTdGF0ZXNNb2RlbHMgPSBnZXRMYWJlbFN0YXRlc01vZGVscyhpdGVtTW9kZWwpO1xuICAgIH1cblxuICAgIHZhciBsaW5lU3R5bGUgPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJyk7XG4gICAgdmFyIHZpc3VhbENvbG9yID0gbGluZVN0eWxlLnN0cm9rZTtcbiAgICBsaW5lLnVzZVN0eWxlKGxpbmVTdHlsZSk7XG4gICAgbGluZS5zdHlsZS5maWxsID0gbnVsbDtcbiAgICBsaW5lLnN0eWxlLnN0cm9rZU5vU2NhbGUgPSB0cnVlO1xuICAgIGxpbmUuZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJykuc3R5bGUgPSBlbXBoYXNpc0xpbmVTdHlsZTtcbiAgICBsaW5lLmVuc3VyZVN0YXRlKCdibHVyJykuc3R5bGUgPSBibHVyTGluZVN0eWxlO1xuICAgIGxpbmUuZW5zdXJlU3RhdGUoJ3NlbGVjdCcpLnN0eWxlID0gc2VsZWN0TGluZVN0eWxlOyAvLyBVcGRhdGUgc3ltYm9sXG5cbiAgICB6clV0aWwuZWFjaChTWU1CT0xfQ0FURUdPUklFUywgZnVuY3Rpb24gKHN5bWJvbENhdGVnb3J5KSB7XG4gICAgICB2YXIgc3ltYm9sID0gdGhpcy5jaGlsZE9mTmFtZShzeW1ib2xDYXRlZ29yeSk7XG5cbiAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgLy8gU2hhcmUgb3BhY2l0eSBhbmQgY29sb3Igd2l0aCBsaW5lLlxuICAgICAgICBzeW1ib2wuc2V0Q29sb3IodmlzdWFsQ29sb3IpO1xuICAgICAgICBzeW1ib2wuc3R5bGUub3BhY2l0eSA9IGxpbmVTdHlsZS5vcGFjaXR5O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU1BFQ0lBTF9TVEFURVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc3RhdGVOYW1lID0gU1BFQ0lBTF9TVEFURVNbaV07XG4gICAgICAgICAgdmFyIGxpbmVTdGF0ZSA9IGxpbmUuZ2V0U3RhdGUoc3RhdGVOYW1lKTtcblxuICAgICAgICAgIGlmIChsaW5lU3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lU3RhdGVTdHlsZSA9IGxpbmVTdGF0ZS5zdHlsZSB8fCB7fTtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN5bWJvbC5lbnN1cmVTdGF0ZShzdGF0ZU5hbWUpO1xuICAgICAgICAgICAgdmFyIHN0YXRlU3R5bGUgPSBzdGF0ZS5zdHlsZSB8fCAoc3RhdGUuc3R5bGUgPSB7fSk7XG5cbiAgICAgICAgICAgIGlmIChsaW5lU3RhdGVTdHlsZS5zdHJva2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdGF0ZVN0eWxlW3N5bWJvbC5fX2lzRW1wdHlCcnVzaCA/ICdzdHJva2UnIDogJ2ZpbGwnXSA9IGxpbmVTdGF0ZVN0eWxlLnN0cm9rZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxpbmVTdGF0ZVN0eWxlLm9wYWNpdHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdGF0ZVN0eWxlLm9wYWNpdHkgPSBsaW5lU3RhdGVTdHlsZS5vcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN5bWJvbC5tYXJrUmVkcmF3KCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdmFyIHJhd1ZhbCA9IHNlcmllc01vZGVsLmdldFJhd1ZhbHVlKGlkeCk7XG4gICAgc2V0TGFiZWxTdHlsZSh0aGlzLCBsYWJlbFN0YXRlc01vZGVscywge1xuICAgICAgbGFiZWxEYXRhSW5kZXg6IGlkeCxcbiAgICAgIGxhYmVsRmV0Y2hlcjoge1xuICAgICAgICBnZXRGb3JtYXR0ZWRMYWJlbDogZnVuY3Rpb24gKGRhdGFJbmRleCwgc3RhdGVOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHNlcmllc01vZGVsLmdldEZvcm1hdHRlZExhYmVsKGRhdGFJbmRleCwgc3RhdGVOYW1lLCBsaW5lRGF0YS5kYXRhVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbmhlcml0Q29sb3I6IHZpc3VhbENvbG9yIHx8ICcjMDAwJyxcbiAgICAgIGRlZmF1bHRPcGFjaXR5OiBsaW5lU3R5bGUub3BhY2l0eSxcbiAgICAgIGRlZmF1bHRUZXh0OiAocmF3VmFsID09IG51bGwgPyBsaW5lRGF0YS5nZXROYW1lKGlkeCkgOiBpc0Zpbml0ZShyYXdWYWwpID8gcm91bmQocmF3VmFsKSA6IHJhd1ZhbCkgKyAnJ1xuICAgIH0pO1xuICAgIHZhciBsYWJlbCA9IHRoaXMuZ2V0VGV4dENvbnRlbnQoKTsgLy8gQWx3YXlzIHNldCBgdGV4dFN0eWxlYCBldmVuIGlmIGBub3JtYWxTdHlsZS50ZXh0YCBpcyBudWxsLCBiZWNhdXNlIGRlZmF1bHRcbiAgICAvLyB2YWx1ZXMgaGF2ZSB0byBiZSBzZXQgb24gYG5vcm1hbFN0eWxlYC5cblxuICAgIGlmIChsYWJlbCkge1xuICAgICAgdmFyIGxhYmVsTm9ybWFsTW9kZWwgPSBsYWJlbFN0YXRlc01vZGVscy5ub3JtYWw7XG4gICAgICBsYWJlbC5fX2FsaWduID0gbGFiZWwuc3R5bGUuYWxpZ247XG4gICAgICBsYWJlbC5fX3ZlcnRpY2FsQWxpZ24gPSBsYWJlbC5zdHlsZS52ZXJ0aWNhbEFsaWduOyAvLyAnc3RhcnQnLCAnbWlkZGxlJywgJ2VuZCdcblxuICAgICAgbGFiZWwuX19wb3NpdGlvbiA9IGxhYmVsTm9ybWFsTW9kZWwuZ2V0KCdwb3NpdGlvbicpIHx8ICdtaWRkbGUnO1xuICAgICAgdmFyIGRpc3RhbmNlID0gbGFiZWxOb3JtYWxNb2RlbC5nZXQoJ2Rpc3RhbmNlJyk7XG5cbiAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoZGlzdGFuY2UpKSB7XG4gICAgICAgIGRpc3RhbmNlID0gW2Rpc3RhbmNlLCBkaXN0YW5jZV07XG4gICAgICB9XG5cbiAgICAgIGxhYmVsLl9fbGFiZWxEaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VGV4dENvbmZpZyh7XG4gICAgICBwb3NpdGlvbjogbnVsbCxcbiAgICAgIGxvY2FsOiB0cnVlLFxuICAgICAgaW5zaWRlOiBmYWxzZSAvLyBDYW4ndCBiZSBpbnNpZGUgZm9yIHN0cm9rZSBlbGVtZW50LlxuXG4gICAgfSk7XG4gICAgZW5hYmxlSG92ZXJFbXBoYXNpcyh0aGlzKTtcbiAgfTtcblxuICBMaW5lLnByb3RvdHlwZS5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZW50ZXJFbXBoYXNpcyh0aGlzKTtcbiAgfTtcblxuICBMaW5lLnByb3RvdHlwZS5kb3ducGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZWF2ZUVtcGhhc2lzKHRoaXMpO1xuICB9O1xuXG4gIExpbmUucHJvdG90eXBlLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4KSB7XG4gICAgdGhpcy5zZXRMaW5lUG9pbnRzKGxpbmVEYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSk7XG4gIH07XG5cbiAgTGluZS5wcm90b3R5cGUuc2V0TGluZVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICB2YXIgbGluZVBhdGggPSB0aGlzLmNoaWxkT2ZOYW1lKCdsaW5lJyk7XG4gICAgc2V0TGluZVBvaW50cyhsaW5lUGF0aC5zaGFwZSwgcG9pbnRzKTtcbiAgICBsaW5lUGF0aC5kaXJ0eSgpO1xuICB9O1xuXG4gIExpbmUucHJvdG90eXBlLmJlZm9yZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGluZUdyb3VwID0gdGhpcztcbiAgICB2YXIgc3ltYm9sRnJvbSA9IGxpbmVHcm91cC5jaGlsZE9mTmFtZSgnZnJvbVN5bWJvbCcpO1xuICAgIHZhciBzeW1ib2xUbyA9IGxpbmVHcm91cC5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcbiAgICB2YXIgbGFiZWwgPSBsaW5lR3JvdXAuZ2V0VGV4dENvbnRlbnQoKTsgLy8gUXVpY2sgcmVqZWN0XG5cbiAgICBpZiAoIXN5bWJvbEZyb20gJiYgIXN5bWJvbFRvICYmICghbGFiZWwgfHwgbGFiZWwuaWdub3JlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnZTY2FsZSA9IDE7XG4gICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudDtcblxuICAgIHdoaWxlIChwYXJlbnROb2RlKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS5zY2FsZVgpIHtcbiAgICAgICAgaW52U2NhbGUgLz0gcGFyZW50Tm9kZS5zY2FsZVg7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXIgbGluZSA9IGxpbmVHcm91cC5jaGlsZE9mTmFtZSgnbGluZScpOyAvLyBJZiBsaW5lIG5vdCBjaGFuZ2VkXG4gICAgLy8gRklYTUUgUGFyZW50IHNjYWxlIGNoYW5nZWRcblxuICAgIGlmICghdGhpcy5fX2RpcnR5ICYmICFsaW5lLl9fZGlydHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGVyY2VudCA9IGxpbmUuc2hhcGUucGVyY2VudDtcbiAgICB2YXIgZnJvbVBvcyA9IGxpbmUucG9pbnRBdCgwKTtcbiAgICB2YXIgdG9Qb3MgPSBsaW5lLnBvaW50QXQocGVyY2VudCk7XG4gICAgdmFyIGQgPSB2ZWN0b3Iuc3ViKFtdLCB0b1BvcywgZnJvbVBvcyk7XG4gICAgdmVjdG9yLm5vcm1hbGl6ZShkLCBkKTtcblxuICAgIGZ1bmN0aW9uIHNldFN5bWJvbFJvdGF0aW9uKHN5bWJvbCwgcGVyY2VudCkge1xuICAgICAgLy8gRml4ICMxMjM4OFxuICAgICAgLy8gd2hlbiBzeW1ib2wgaXMgc2V0IHRvIGJlICdhcnJvdycgaW4gbWFya0xpbmUsXG4gICAgICAvLyBzeW1ib2xSb3RhdGUgdmFsdWUgd2lsbCBiZSBpZ25vcmVkLCBhbmQgY29tcHVsc2l2ZWx5IHVzZSB0YW5nZW50IGFuZ2xlLlxuICAgICAgLy8gcm90YXRlIGJ5IGRlZmF1bHQgaWYgc3ltYm9sIHJvdGF0aW9uIGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgIHZhciBzcGVjaWZpZWRSb3RhdGlvbiA9IHN5bWJvbC5fX3NwZWNpZmllZFJvdGF0aW9uO1xuXG4gICAgICBpZiAoc3BlY2lmaWVkUm90YXRpb24gPT0gbnVsbCkge1xuICAgICAgICB2YXIgdGFuZ2VudCA9IGxpbmUudGFuZ2VudEF0KHBlcmNlbnQpO1xuICAgICAgICBzeW1ib2wuYXR0cigncm90YXRpb24nLCAocGVyY2VudCA9PT0gMSA/IC0xIDogMSkgKiBNYXRoLlBJIC8gMiAtIE1hdGguYXRhbjIodGFuZ2VudFsxXSwgdGFuZ2VudFswXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ltYm9sLmF0dHIoJ3JvdGF0aW9uJywgc3BlY2lmaWVkUm90YXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzeW1ib2xGcm9tKSB7XG4gICAgICBzeW1ib2xGcm9tLnNldFBvc2l0aW9uKGZyb21Qb3MpO1xuICAgICAgc2V0U3ltYm9sUm90YXRpb24oc3ltYm9sRnJvbSwgMCk7XG4gICAgICBzeW1ib2xGcm9tLnNjYWxlWCA9IHN5bWJvbEZyb20uc2NhbGVZID0gaW52U2NhbGUgKiBwZXJjZW50O1xuICAgICAgc3ltYm9sRnJvbS5tYXJrUmVkcmF3KCk7XG4gICAgfVxuXG4gICAgaWYgKHN5bWJvbFRvKSB7XG4gICAgICBzeW1ib2xUby5zZXRQb3NpdGlvbih0b1Bvcyk7XG4gICAgICBzZXRTeW1ib2xSb3RhdGlvbihzeW1ib2xUbywgMSk7XG4gICAgICBzeW1ib2xUby5zY2FsZVggPSBzeW1ib2xUby5zY2FsZVkgPSBpbnZTY2FsZSAqIHBlcmNlbnQ7XG4gICAgICBzeW1ib2xUby5tYXJrUmVkcmF3KCk7XG4gICAgfVxuXG4gICAgaWYgKGxhYmVsICYmICFsYWJlbC5pZ25vcmUpIHtcbiAgICAgIGxhYmVsLnggPSBsYWJlbC55ID0gMDtcbiAgICAgIGxhYmVsLm9yaWdpblggPSBsYWJlbC5vcmlnaW5ZID0gMDtcbiAgICAgIHZhciB0ZXh0QWxpZ24gPSB2b2lkIDA7XG4gICAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSB2b2lkIDA7XG4gICAgICB2YXIgZGlzdGFuY2UgPSBsYWJlbC5fX2xhYmVsRGlzdGFuY2U7XG4gICAgICB2YXIgZGlzdGFuY2VYID0gZGlzdGFuY2VbMF0gKiBpbnZTY2FsZTtcbiAgICAgIHZhciBkaXN0YW5jZVkgPSBkaXN0YW5jZVsxXSAqIGludlNjYWxlO1xuICAgICAgdmFyIGhhbGZQZXJjZW50ID0gcGVyY2VudCAvIDI7XG4gICAgICB2YXIgdGFuZ2VudCA9IGxpbmUudGFuZ2VudEF0KGhhbGZQZXJjZW50KTtcbiAgICAgIHZhciBuID0gW3RhbmdlbnRbMV0sIC10YW5nZW50WzBdXTtcbiAgICAgIHZhciBjcCA9IGxpbmUucG9pbnRBdChoYWxmUGVyY2VudCk7XG5cbiAgICAgIGlmIChuWzFdID4gMCkge1xuICAgICAgICBuWzBdID0gLW5bMF07XG4gICAgICAgIG5bMV0gPSAtblsxXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpciA9IHRhbmdlbnRbMF0gPCAwID8gLTEgOiAxO1xuXG4gICAgICBpZiAobGFiZWwuX19wb3NpdGlvbiAhPT0gJ3N0YXJ0JyAmJiBsYWJlbC5fX3Bvc2l0aW9uICE9PSAnZW5kJykge1xuICAgICAgICB2YXIgcm90YXRpb24gPSAtTWF0aC5hdGFuMih0YW5nZW50WzFdLCB0YW5nZW50WzBdKTtcblxuICAgICAgICBpZiAodG9Qb3NbMF0gPCBmcm9tUG9zWzBdKSB7XG4gICAgICAgICAgcm90YXRpb24gPSBNYXRoLlBJICsgcm90YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbC5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHkgPSB2b2lkIDA7XG5cbiAgICAgIHN3aXRjaCAobGFiZWwuX19wb3NpdGlvbikge1xuICAgICAgICBjYXNlICdpbnNpZGVTdGFydFRvcCc6XG4gICAgICAgIGNhc2UgJ2luc2lkZU1pZGRsZVRvcCc6XG4gICAgICAgIGNhc2UgJ2luc2lkZUVuZFRvcCc6XG4gICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgZHkgPSAtZGlzdGFuY2VZO1xuICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaW5zaWRlU3RhcnRCb3R0b20nOlxuICAgICAgICBjYXNlICdpbnNpZGVNaWRkbGVCb3R0b20nOlxuICAgICAgICBjYXNlICdpbnNpZGVFbmRCb3R0b20nOlxuICAgICAgICAgIGR5ID0gZGlzdGFuY2VZO1xuICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ3RvcCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkeSA9IDA7XG4gICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChsYWJlbC5fX3Bvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgbGFiZWwueCA9IGRbMF0gKiBkaXN0YW5jZVggKyB0b1Bvc1swXTtcbiAgICAgICAgICBsYWJlbC55ID0gZFsxXSAqIGRpc3RhbmNlWSArIHRvUG9zWzFdO1xuICAgICAgICAgIHRleHRBbGlnbiA9IGRbMF0gPiAwLjggPyAnbGVmdCcgOiBkWzBdIDwgLTAuOCA/ICdyaWdodCcgOiAnY2VudGVyJztcbiAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IGRbMV0gPiAwLjggPyAndG9wJyA6IGRbMV0gPCAtMC44ID8gJ2JvdHRvbScgOiAnbWlkZGxlJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgbGFiZWwueCA9IC1kWzBdICogZGlzdGFuY2VYICsgZnJvbVBvc1swXTtcbiAgICAgICAgICBsYWJlbC55ID0gLWRbMV0gKiBkaXN0YW5jZVkgKyBmcm9tUG9zWzFdO1xuICAgICAgICAgIHRleHRBbGlnbiA9IGRbMF0gPiAwLjggPyAncmlnaHQnIDogZFswXSA8IC0wLjggPyAnbGVmdCcgOiAnY2VudGVyJztcbiAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IGRbMV0gPiAwLjggPyAnYm90dG9tJyA6IGRbMV0gPCAtMC44ID8gJ3RvcCcgOiAnbWlkZGxlJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdpbnNpZGVTdGFydFRvcCc6XG4gICAgICAgIGNhc2UgJ2luc2lkZVN0YXJ0JzpcbiAgICAgICAgY2FzZSAnaW5zaWRlU3RhcnRCb3R0b20nOlxuICAgICAgICAgIGxhYmVsLnggPSBkaXN0YW5jZVggKiBkaXIgKyBmcm9tUG9zWzBdO1xuICAgICAgICAgIGxhYmVsLnkgPSBmcm9tUG9zWzFdICsgZHk7XG4gICAgICAgICAgdGV4dEFsaWduID0gdGFuZ2VudFswXSA8IDAgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgIGxhYmVsLm9yaWdpblggPSAtZGlzdGFuY2VYICogZGlyO1xuICAgICAgICAgIGxhYmVsLm9yaWdpblkgPSAtZHk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaW5zaWRlTWlkZGxlVG9wJzpcbiAgICAgICAgY2FzZSAnaW5zaWRlTWlkZGxlJzpcbiAgICAgICAgY2FzZSAnaW5zaWRlTWlkZGxlQm90dG9tJzpcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICBsYWJlbC54ID0gY3BbMF07XG4gICAgICAgICAgbGFiZWwueSA9IGNwWzFdICsgZHk7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgbGFiZWwub3JpZ2luWSA9IC1keTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdpbnNpZGVFbmRUb3AnOlxuICAgICAgICBjYXNlICdpbnNpZGVFbmQnOlxuICAgICAgICBjYXNlICdpbnNpZGVFbmRCb3R0b20nOlxuICAgICAgICAgIGxhYmVsLnggPSAtZGlzdGFuY2VYICogZGlyICsgdG9Qb3NbMF07XG4gICAgICAgICAgbGFiZWwueSA9IHRvUG9zWzFdICsgZHk7XG4gICAgICAgICAgdGV4dEFsaWduID0gdGFuZ2VudFswXSA+PSAwID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICBsYWJlbC5vcmlnaW5YID0gZGlzdGFuY2VYICogZGlyO1xuICAgICAgICAgIGxhYmVsLm9yaWdpblkgPSAtZHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGxhYmVsLnNjYWxlWCA9IGxhYmVsLnNjYWxlWSA9IGludlNjYWxlO1xuICAgICAgbGFiZWwuc2V0U3R5bGUoe1xuICAgICAgICAvLyBVc2UgdGhlIHVzZXIgc3BlY2lmaWVkIHRleHQgYWxpZ24gYW5kIGJhc2VsaW5lIGZpcnN0XG4gICAgICAgIHZlcnRpY2FsQWxpZ246IGxhYmVsLl9fdmVydGljYWxBbGlnbiB8fCB0ZXh0VmVydGljYWxBbGlnbixcbiAgICAgICAgYWxpZ246IGxhYmVsLl9fYWxpZ24gfHwgdGV4dEFsaWduXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIExpbmU7XG59KGdyYXBoaWMuR3JvdXApO1xuXG5leHBvcnQgZGVmYXVsdCBMaW5lOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgTGluZUdyb3VwIGZyb20gJy4vTGluZSc7XG5pbXBvcnQgeyBnZXRMYWJlbFN0YXRlc01vZGVscyB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUnO1xuXG52YXIgTGluZURyYXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaW5lRHJhdyhMaW5lQ3Rvcikge1xuICAgIHRoaXMuZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIHRoaXMuX0xpbmVDdG9yID0gTGluZUN0b3IgfHwgTGluZUdyb3VwO1xuICB9XG5cbiAgTGluZURyYXcucHJvdG90eXBlLmlzUGVyc2lzdGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICA7XG5cbiAgTGluZURyYXcucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAobGluZURhdGEpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGxpbmVEcmF3ID0gdGhpcztcbiAgICB2YXIgZ3JvdXAgPSBsaW5lRHJhdy5ncm91cDtcbiAgICB2YXIgb2xkTGluZURhdGEgPSBsaW5lRHJhdy5fbGluZURhdGE7XG4gICAgbGluZURyYXcuX2xpbmVEYXRhID0gbGluZURhdGE7IC8vIFRoZXJlIGlzIG5vIG9sZExpbmVEYXRhIG9ubHkgd2hlbiBmaXJzdCByZW5kZXJpbmcgb3Igc3dpdGNoaW5nIGZyb21cbiAgICAvLyBzdHJlYW0gbW9kZSB0byBub3JtYWwgbW9kZSwgd2hlcmUgcHJldmlvdXMgZWxlbWVudHMgc2hvdWxkIGJlIHJlbW92ZWQuXG5cbiAgICBpZiAoIW9sZExpbmVEYXRhKSB7XG4gICAgICBncm91cC5yZW1vdmVBbGwoKTtcbiAgICB9XG5cbiAgICB2YXIgc2VyaWVzU2NvcGUgPSBtYWtlU2VyaWVzU2NvcGUobGluZURhdGEpO1xuICAgIGxpbmVEYXRhLmRpZmYob2xkTGluZURhdGEpLmFkZChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICBfdGhpcy5fZG9BZGQobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpO1xuICAgIH0pLnVwZGF0ZShmdW5jdGlvbiAobmV3SWR4LCBvbGRJZHgpIHtcbiAgICAgIF90aGlzLl9kb1VwZGF0ZShvbGRMaW5lRGF0YSwgbGluZURhdGEsIG9sZElkeCwgbmV3SWR4LCBzZXJpZXNTY29wZSk7XG4gICAgfSkucmVtb3ZlKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIGdyb3VwLnJlbW92ZShvbGRMaW5lRGF0YS5nZXRJdGVtR3JhcGhpY0VsKGlkeCkpO1xuICAgIH0pLmV4ZWN1dGUoKTtcbiAgfTtcblxuICA7XG5cbiAgTGluZURyYXcucHJvdG90eXBlLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGluZURhdGEgPSB0aGlzLl9saW5lRGF0YTsgLy8gRG8gbm90IHN1cHBvcnQgdXBkYXRlIGxheW91dCBpbiBpbmNyZW1lbnRhbCBtb2RlLlxuXG4gICAgaWYgKCFsaW5lRGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxpbmVEYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICBlbC51cGRhdGVMYXlvdXQobGluZURhdGEsIGlkeCk7XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbiAgO1xuXG4gIExpbmVEcmF3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFByZXBhcmVVcGRhdGUgPSBmdW5jdGlvbiAobGluZURhdGEpIHtcbiAgICB0aGlzLl9zZXJpZXNTY29wZSA9IG1ha2VTZXJpZXNTY29wZShsaW5lRGF0YSk7XG4gICAgdGhpcy5fbGluZURhdGEgPSBudWxsO1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gIH07XG5cbiAgO1xuXG4gIExpbmVEcmF3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFVwZGF0ZSA9IGZ1bmN0aW9uICh0YXNrUGFyYW1zLCBsaW5lRGF0YSkge1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUluY3JlbWVudGFsQW5kSG92ZXIoZWwpIHtcbiAgICAgIGlmICghZWwuaXNHcm91cCAmJiAhaXNFZmZlY3RPYmplY3QoZWwpKSB7XG4gICAgICAgIGVsLmluY3JlbWVudGFsID0gdHJ1ZTtcbiAgICAgICAgZWwuZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJykuaG92ZXJMYXllciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaWR4ID0gdGFza1BhcmFtcy5zdGFydDsgaWR4IDwgdGFza1BhcmFtcy5lbmQ7IGlkeCsrKSB7XG4gICAgICB2YXIgaXRlbUxheW91dCA9IGxpbmVEYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcblxuICAgICAgaWYgKGxpbmVOZWVkc0RyYXcoaXRlbUxheW91dCkpIHtcbiAgICAgICAgdmFyIGVsID0gbmV3IHRoaXMuX0xpbmVDdG9yKGxpbmVEYXRhLCBpZHgsIHRoaXMuX3Nlcmllc1Njb3BlKTtcbiAgICAgICAgZWwudHJhdmVyc2UodXBkYXRlSW5jcmVtZW50YWxBbmRIb3Zlcik7XG4gICAgICAgIHRoaXMuZ3JvdXAuYWRkKGVsKTtcbiAgICAgICAgbGluZURhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIGVsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgO1xuXG4gIExpbmVEcmF3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgfTtcblxuICA7XG5cbiAgTGluZURyYXcucHJvdG90eXBlLl9kb0FkZCA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICAgIHZhciBpdGVtTGF5b3V0ID0gbGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuXG4gICAgaWYgKCFsaW5lTmVlZHNEcmF3KGl0ZW1MYXlvdXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsID0gbmV3IHRoaXMuX0xpbmVDdG9yKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbiAgICBsaW5lRGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgZWwpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKGVsKTtcbiAgfTtcblxuICBMaW5lRHJhdy5wcm90b3R5cGUuX2RvVXBkYXRlID0gZnVuY3Rpb24gKG9sZExpbmVEYXRhLCBuZXdMaW5lRGF0YSwgb2xkSWR4LCBuZXdJZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgdmFyIGl0ZW1FbCA9IG9sZExpbmVEYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcblxuICAgIGlmICghbGluZU5lZWRzRHJhdyhuZXdMaW5lRGF0YS5nZXRJdGVtTGF5b3V0KG5ld0lkeCkpKSB7XG4gICAgICB0aGlzLmdyb3VwLnJlbW92ZShpdGVtRWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaXRlbUVsKSB7XG4gICAgICBpdGVtRWwgPSBuZXcgdGhpcy5fTGluZUN0b3IobmV3TGluZURhdGEsIG5ld0lkeCwgc2VyaWVzU2NvcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtRWwudXBkYXRlRGF0YShuZXdMaW5lRGF0YSwgbmV3SWR4LCBzZXJpZXNTY29wZSk7XG4gICAgfVxuXG4gICAgbmV3TGluZURhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIGl0ZW1FbCk7XG4gICAgdGhpcy5ncm91cC5hZGQoaXRlbUVsKTtcbiAgfTtcblxuICByZXR1cm4gTGluZURyYXc7XG59KCk7XG5cbmZ1bmN0aW9uIGlzRWZmZWN0T2JqZWN0KGVsKSB7XG4gIHJldHVybiBlbC5hbmltYXRvcnMgJiYgZWwuYW5pbWF0b3JzLmxlbmd0aCA+IDA7XG59XG5cbmZ1bmN0aW9uIG1ha2VTZXJpZXNTY29wZShsaW5lRGF0YSkge1xuICB2YXIgaG9zdE1vZGVsID0gbGluZURhdGEuaG9zdE1vZGVsO1xuICByZXR1cm4ge1xuICAgIGxpbmVTdHlsZTogaG9zdE1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKSxcbiAgICBlbXBoYXNpc0xpbmVTdHlsZTogaG9zdE1vZGVsLmdldE1vZGVsKFsnZW1waGFzaXMnLCAnbGluZVN0eWxlJ10pLmdldExpbmVTdHlsZSgpLFxuICAgIGJsdXJMaW5lU3R5bGU6IGhvc3RNb2RlbC5nZXRNb2RlbChbJ2JsdXInLCAnbGluZVN0eWxlJ10pLmdldExpbmVTdHlsZSgpLFxuICAgIHNlbGVjdExpbmVTdHlsZTogaG9zdE1vZGVsLmdldE1vZGVsKFsnc2VsZWN0JywgJ2xpbmVTdHlsZSddKS5nZXRMaW5lU3R5bGUoKSxcbiAgICBsYWJlbFN0YXRlc01vZGVsczogZ2V0TGFiZWxTdGF0ZXNNb2RlbHMoaG9zdE1vZGVsKVxuICB9O1xufVxuXG5mdW5jdGlvbiBpc1BvaW50TmFOKHB0KSB7XG4gIHJldHVybiBpc05hTihwdFswXSkgfHwgaXNOYU4ocHRbMV0pO1xufVxuXG5mdW5jdGlvbiBsaW5lTmVlZHNEcmF3KHB0cykge1xuICByZXR1cm4gIWlzUG9pbnROYU4ocHRzWzBdKSAmJiAhaXNQb2ludE5hTihwdHNbMV0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBMaW5lRHJhdzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG4vKipcbiAqIExpbmUgcGF0aCBmb3IgYmV6aWVyIGFuZCBzdHJhaWdodCBsaW5lIGRyYXdcbiAqL1xuXG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJztcbnZhciBzdHJhaWdodExpbmVQcm90byA9IGdyYXBoaWMuTGluZS5wcm90b3R5cGU7XG52YXIgYmV6aWVyQ3VydmVQcm90byA9IGdyYXBoaWMuQmV6aWVyQ3VydmUucHJvdG90eXBlO1xuXG52YXIgU3RyYWlnaHRMaW5lU2hhcGUgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHJhaWdodExpbmVTaGFwZSgpIHtcbiAgICAvLyBTdGFydCBwb2ludFxuICAgIHRoaXMueDEgPSAwO1xuICAgIHRoaXMueTEgPSAwOyAvLyBFbmQgcG9pbnRcblxuICAgIHRoaXMueDIgPSAwO1xuICAgIHRoaXMueTIgPSAwO1xuICAgIHRoaXMucGVyY2VudCA9IDE7XG4gIH1cblxuICByZXR1cm4gU3RyYWlnaHRMaW5lU2hhcGU7XG59KCk7XG5cbnZhciBDdXJ2ZVNoYXBlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEN1cnZlU2hhcGUsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gQ3VydmVTaGFwZSgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gQ3VydmVTaGFwZTtcbn0oU3RyYWlnaHRMaW5lU2hhcGUpO1xuXG5mdW5jdGlvbiBpc1N0cmFpZ2h0TGluZShzaGFwZSkge1xuICByZXR1cm4gaXNOYU4oK3NoYXBlLmNweDEpIHx8IGlzTmFOKCtzaGFwZS5jcHkxKTtcbn1cblxudmFyIEVDTGluZVBhdGggPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRUNMaW5lUGF0aCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBFQ0xpbmVQYXRoKG9wdHMpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9ICdlYy1saW5lJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBFQ0xpbmVQYXRoLnByb3RvdHlwZS5nZXREZWZhdWx0U3R5bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cm9rZTogJyMwMDAnLFxuICAgICAgZmlsbDogbnVsbFxuICAgIH07XG4gIH07XG5cbiAgRUNMaW5lUGF0aC5wcm90b3R5cGUuZ2V0RGVmYXVsdFNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3RyYWlnaHRMaW5lU2hhcGUoKTtcbiAgfTtcblxuICBFQ0xpbmVQYXRoLnByb3RvdHlwZS5idWlsZFBhdGggPSBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIGlmIChpc1N0cmFpZ2h0TGluZShzaGFwZSkpIHtcbiAgICAgIHN0cmFpZ2h0TGluZVByb3RvLmJ1aWxkUGF0aC5jYWxsKHRoaXMsIGN0eCwgc2hhcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiZXppZXJDdXJ2ZVByb3RvLmJ1aWxkUGF0aC5jYWxsKHRoaXMsIGN0eCwgc2hhcGUpO1xuICAgIH1cbiAgfTtcblxuICBFQ0xpbmVQYXRoLnByb3RvdHlwZS5wb2ludEF0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICBpZiAoaXNTdHJhaWdodExpbmUodGhpcy5zaGFwZSkpIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVQcm90by5wb2ludEF0LmNhbGwodGhpcywgdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiZXppZXJDdXJ2ZVByb3RvLnBvaW50QXQuY2FsbCh0aGlzLCB0KTtcbiAgICB9XG4gIH07XG5cbiAgRUNMaW5lUGF0aC5wcm90b3R5cGUudGFuZ2VudEF0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgIHZhciBwID0gaXNTdHJhaWdodExpbmUoc2hhcGUpID8gW3NoYXBlLngyIC0gc2hhcGUueDEsIHNoYXBlLnkyIC0gc2hhcGUueTFdIDogYmV6aWVyQ3VydmVQcm90by50YW5nZW50QXQuY2FsbCh0aGlzLCB0KTtcbiAgICByZXR1cm4gdmVjMi5ub3JtYWxpemUocCwgcCk7XG4gIH07XG5cbiAgcmV0dXJuIEVDTGluZVBhdGg7XG59KGdyYXBoaWMuUGF0aCk7XG5cbmV4cG9ydCBkZWZhdWx0IEVDTGluZVBhdGg7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgY3JlYXRlU3ltYm9sIH0gZnJvbSAnLi4vLi4vdXRpbC9zeW1ib2wnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlJztcbmltcG9ydCB7IGVudGVyRW1waGFzaXMsIGxlYXZlRW1waGFzaXMsIGVuYWJsZUhvdmVyRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcyc7XG5pbXBvcnQgeyBwYXJzZVBlcmNlbnQgfSBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG5pbXBvcnQgeyBnZXREZWZhdWx0TGFiZWwgfSBmcm9tICcuL2xhYmVsSGVscGVyJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBzZXRMYWJlbFN0eWxlLCBnZXRMYWJlbFN0YXRlc01vZGVscyB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUnO1xuaW1wb3J0IFpSSW1hZ2UgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZSc7XG5cbnZhciBTeW1ib2wgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU3ltYm9sLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFN5bWJvbChkYXRhLCBpZHgsIHNlcmllc1Njb3BlLCBvcHRzKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF90aGlzLnVwZGF0ZURhdGEoZGF0YSwgaWR4LCBzZXJpZXNTY29wZSwgb3B0cyk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBTeW1ib2wucHJvdG90eXBlLl9jcmVhdGVTeW1ib2wgPSBmdW5jdGlvbiAoc3ltYm9sVHlwZSwgZGF0YSwgaWR4LCBzeW1ib2xTaXplLCBrZWVwQXNwZWN0KSB7XG4gICAgLy8gUmVtb3ZlIHBhdGhzIGNyZWF0ZWQgYmVmb3JlXG4gICAgdGhpcy5yZW1vdmVBbGwoKTsgLy8gbGV0IHN5bWJvbFBhdGggPSBjcmVhdGVTeW1ib2woXG4gICAgLy8gICAgIHN5bWJvbFR5cGUsIC0wLjUsIC0wLjUsIDEsIDEsIGNvbG9yXG4gICAgLy8gKTtcbiAgICAvLyBJZiB3aWR0aC9oZWlnaHQgYXJlIHNldCB0b28gc21hbGwgKGUuZy4sIHNldCB0byAxKSBvbiBpb3MxMFxuICAgIC8vIGFuZCBtYWNPUyBTaWVycmEsIGEgY2lyY2xlIHN0cm9rZSBiZWNvbWUgYSByZWN0LCBubyBtYXR0ZXIgd2hhdFxuICAgIC8vIHRoZSBzY2FsZSBpcyBzZXQuIFNvIHdlIHNldCB3aWR0aC9oZWlnaHQgYXMgMi4gU2VlICM0MTUwLlxuXG4gICAgdmFyIHN5bWJvbFBhdGggPSBjcmVhdGVTeW1ib2woc3ltYm9sVHlwZSwgLTEsIC0xLCAyLCAyLCBudWxsLCBrZWVwQXNwZWN0KTtcbiAgICBzeW1ib2xQYXRoLmF0dHIoe1xuICAgICAgejI6IDEwMCxcbiAgICAgIGN1bGxpbmc6IHRydWUsXG4gICAgICBzY2FsZVg6IHN5bWJvbFNpemVbMF0gLyAyLFxuICAgICAgc2NhbGVZOiBzeW1ib2xTaXplWzFdIC8gMlxuICAgIH0pOyAvLyBSZXdyaXRlIGRyaWZ0IG1ldGhvZFxuXG4gICAgc3ltYm9sUGF0aC5kcmlmdCA9IGRyaWZ0U3ltYm9sO1xuICAgIHRoaXMuX3N5bWJvbFR5cGUgPSBzeW1ib2xUeXBlO1xuICAgIHRoaXMuYWRkKHN5bWJvbFBhdGgpO1xuICB9O1xuICAvKipcbiAgICogU3RvcCBhbmltYXRpb25cbiAgICogQHBhcmFtIHtib29sZWFufSB0b0xhc3RGcmFtZVxuICAgKi9cblxuXG4gIFN5bWJvbC5wcm90b3R5cGUuc3RvcFN5bWJvbEFuaW1hdGlvbiA9IGZ1bmN0aW9uICh0b0xhc3RGcmFtZSkge1xuICAgIHRoaXMuY2hpbGRBdCgwKS5zdG9wQW5pbWF0aW9uKG51bGwsIHRvTGFzdEZyYW1lKTtcbiAgfTtcbiAgLyoqXG4gICAqIEZJWE1FOlxuICAgKiBDYXV0aW9uOiBUaGlzIG1ldGhvZCBicmVha3MgdGhlIGVuY2Fwc3VsYXRpb24gb2YgdGhpcyBtb2R1bGUsXG4gICAqIGJ1dCBpdCBpbmRlZWQgYnJpbmdzIGNvbnZlbmllbmNlLiBTbyBkbyBub3QgdXNlIHRoZSBtZXRob2RcbiAgICogdW5sZXNzIHlvdSBkZXRhaWxlZGx5IGtub3cgYWxsIHRoZSBpbXBsZW1lbnRzIG9mIGBTeW1ib2xgLFxuICAgKiBlc3BlY2lhbGx5IGFuaW1hdGlvbi5cbiAgICpcbiAgICogR2V0IHN5bWJvbCBwYXRoIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgU3ltYm9sLnByb3RvdHlwZS5nZXRTeW1ib2xQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkQXQoMCk7XG4gIH07XG4gIC8qKlxuICAgKiBIaWdobGlnaHQgc3ltYm9sXG4gICAqL1xuXG5cbiAgU3ltYm9sLnByb3RvdHlwZS5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZW50ZXJFbXBoYXNpcyh0aGlzLmNoaWxkQXQoMCkpO1xuICB9O1xuICAvKipcbiAgICogRG93bnBsYXkgc3ltYm9sXG4gICAqL1xuXG5cbiAgU3ltYm9sLnByb3RvdHlwZS5kb3ducGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZWF2ZUVtcGhhc2lzKHRoaXMuY2hpbGRBdCgwKSk7XG4gIH07XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6XG4gICAqL1xuXG5cbiAgU3ltYm9sLnByb3RvdHlwZS5zZXRaID0gZnVuY3Rpb24gKHpsZXZlbCwgeikge1xuICAgIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICAgIHN5bWJvbFBhdGguemxldmVsID0gemxldmVsO1xuICAgIHN5bWJvbFBhdGgueiA9IHo7XG4gIH07XG5cbiAgU3ltYm9sLnByb3RvdHlwZS5zZXREcmFnZ2FibGUgPSBmdW5jdGlvbiAoZHJhZ2dhYmxlKSB7XG4gICAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gICAgc3ltYm9sUGF0aC5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XG4gICAgc3ltYm9sUGF0aC5jdXJzb3IgPSBkcmFnZ2FibGUgPyAnbW92ZScgOiBzeW1ib2xQYXRoLmN1cnNvcjtcbiAgfTtcbiAgLyoqXG4gICAqIFVwZGF0ZSBzeW1ib2wgcHJvcGVydGllc1xuICAgKi9cblxuXG4gIFN5bWJvbC5wcm90b3R5cGUudXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBpZHgsIHNlcmllc1Njb3BlLCBvcHRzKSB7XG4gICAgdGhpcy5zaWxlbnQgPSBmYWxzZTtcbiAgICB2YXIgc3ltYm9sVHlwZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKSB8fCAnY2lyY2xlJztcbiAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICB2YXIgc3ltYm9sU2l6ZSA9IFN5bWJvbC5nZXRTeW1ib2xTaXplKGRhdGEsIGlkeCk7XG4gICAgdmFyIGlzSW5pdCA9IHN5bWJvbFR5cGUgIT09IHRoaXMuX3N5bWJvbFR5cGU7XG4gICAgdmFyIGRpc2FibGVBbmltYXRpb24gPSBvcHRzICYmIG9wdHMuZGlzYWJsZUFuaW1hdGlvbjtcblxuICAgIGlmIChpc0luaXQpIHtcbiAgICAgIHZhciBrZWVwQXNwZWN0ID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbEtlZXBBc3BlY3QnKTtcblxuICAgICAgdGhpcy5fY3JlYXRlU3ltYm9sKHN5bWJvbFR5cGUsIGRhdGEsIGlkeCwgc3ltYm9sU2l6ZSwga2VlcEFzcGVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICAgICAgc3ltYm9sUGF0aC5zaWxlbnQgPSBmYWxzZTtcbiAgICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICAgIHNjYWxlWDogc3ltYm9sU2l6ZVswXSAvIDIsXG4gICAgICAgIHNjYWxlWTogc3ltYm9sU2l6ZVsxXSAvIDJcbiAgICAgIH07XG4gICAgICBkaXNhYmxlQW5pbWF0aW9uID8gc3ltYm9sUGF0aC5hdHRyKHRhcmdldCkgOiBncmFwaGljLnVwZGF0ZVByb3BzKHN5bWJvbFBhdGgsIHRhcmdldCwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlQ29tbW9uKGRhdGEsIGlkeCwgc3ltYm9sU2l6ZSwgc2VyaWVzU2NvcGUsIG9wdHMpO1xuXG4gICAgaWYgKGlzSW5pdCkge1xuICAgICAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG5cbiAgICAgIGlmICghZGlzYWJsZUFuaW1hdGlvbikge1xuICAgICAgICB2YXIgdGFyZ2V0ID0ge1xuICAgICAgICAgIHNjYWxlWDogdGhpcy5fc2l6ZVgsXG4gICAgICAgICAgc2NhbGVZOiB0aGlzLl9zaXplWSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgLy8gQWx3YXlzIGZhZGVJbi4gQmVjYXVzZSBpdCBoYXMgZmFkZU91dCBhbmltYXRpb24gd2hlbiBzeW1ib2wgaXMgcmVtb3ZlZC4uXG4gICAgICAgICAgICBvcGFjaXR5OiBzeW1ib2xQYXRoLnN0eWxlLm9wYWNpdHlcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHN5bWJvbFBhdGguc2NhbGVYID0gc3ltYm9sUGF0aC5zY2FsZVkgPSAwO1xuICAgICAgICBzeW1ib2xQYXRoLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICBncmFwaGljLmluaXRQcm9wcyhzeW1ib2xQYXRoLCB0YXJnZXQsIHNlcmllc01vZGVsLCBpZHgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXNhYmxlQW5pbWF0aW9uKSB7XG4gICAgICAvLyBNdXN0IHN0b3AgcmVtb3ZlIGFuaW1hdGlvbiBtYW51YWxseSBpZiBkb24ndCBjYWxsIGluaXRQcm9wcyBvciB1cGRhdGVQcm9wcy5cbiAgICAgIHRoaXMuY2hpbGRBdCgwKS5zdG9wQW5pbWF0aW9uKCdyZW1vdmUnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXJpZXNNb2RlbCA9IHNlcmllc01vZGVsO1xuICB9O1xuXG4gIFN5bWJvbC5wcm90b3R5cGUuX3VwZGF0ZUNvbW1vbiA9IGZ1bmN0aW9uIChkYXRhLCBpZHgsIHN5bWJvbFNpemUsIHNlcmllc1Njb3BlLCBvcHRzKSB7XG4gICAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgdmFyIGVtcGhhc2lzSXRlbVN0eWxlO1xuICAgIHZhciBibHVySXRlbVN0eWxlO1xuICAgIHZhciBzZWxlY3RJdGVtU3R5bGU7XG4gICAgdmFyIGZvY3VzO1xuICAgIHZhciBibHVyU2NvcGU7XG4gICAgdmFyIHN5bWJvbE9mZnNldDtcbiAgICB2YXIgbGFiZWxTdGF0ZXNNb2RlbHM7XG4gICAgdmFyIGhvdmVyU2NhbGU7XG4gICAgdmFyIGN1cnNvclN0eWxlO1xuXG4gICAgaWYgKHNlcmllc1Njb3BlKSB7XG4gICAgICBlbXBoYXNpc0l0ZW1TdHlsZSA9IHNlcmllc1Njb3BlLmVtcGhhc2lzSXRlbVN0eWxlO1xuICAgICAgYmx1ckl0ZW1TdHlsZSA9IHNlcmllc1Njb3BlLmJsdXJJdGVtU3R5bGU7XG4gICAgICBzZWxlY3RJdGVtU3R5bGUgPSBzZXJpZXNTY29wZS5zZWxlY3RJdGVtU3R5bGU7XG4gICAgICBmb2N1cyA9IHNlcmllc1Njb3BlLmZvY3VzO1xuICAgICAgYmx1clNjb3BlID0gc2VyaWVzU2NvcGUuYmx1clNjb3BlO1xuICAgICAgc3ltYm9sT2Zmc2V0ID0gc2VyaWVzU2NvcGUuc3ltYm9sT2Zmc2V0O1xuICAgICAgbGFiZWxTdGF0ZXNNb2RlbHMgPSBzZXJpZXNTY29wZS5sYWJlbFN0YXRlc01vZGVscztcbiAgICAgIGhvdmVyU2NhbGUgPSBzZXJpZXNTY29wZS5ob3ZlclNjYWxlO1xuICAgICAgY3Vyc29yU3R5bGUgPSBzZXJpZXNTY29wZS5jdXJzb3JTdHlsZTtcbiAgICB9XG5cbiAgICBpZiAoIXNlcmllc1Njb3BlIHx8IGRhdGEuaGFzSXRlbU9wdGlvbikge1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLml0ZW1Nb2RlbCA/IHNlcmllc1Njb3BlLml0ZW1Nb2RlbCA6IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICB2YXIgZW1waGFzaXNNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKTtcbiAgICAgIGVtcGhhc2lzSXRlbVN0eWxlID0gZW1waGFzaXNNb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJykuZ2V0SXRlbVN0eWxlKCk7XG4gICAgICBzZWxlY3RJdGVtU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoWydzZWxlY3QnLCAnaXRlbVN0eWxlJ10pLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgYmx1ckl0ZW1TdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChbJ2JsdXInLCAnaXRlbVN0eWxlJ10pLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgZm9jdXMgPSBlbXBoYXNpc01vZGVsLmdldCgnZm9jdXMnKTtcbiAgICAgIGJsdXJTY29wZSA9IGVtcGhhc2lzTW9kZWwuZ2V0KCdibHVyU2NvcGUnKTtcbiAgICAgIHN5bWJvbE9mZnNldCA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2xPZmZzZXQnKTtcbiAgICAgIGxhYmVsU3RhdGVzTW9kZWxzID0gZ2V0TGFiZWxTdGF0ZXNNb2RlbHMoaXRlbU1vZGVsKTtcbiAgICAgIGhvdmVyU2NhbGUgPSBlbXBoYXNpc01vZGVsLmdldFNoYWxsb3coJ3NjYWxlJyk7XG4gICAgICBjdXJzb3JTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdjdXJzb3InKTtcbiAgICB9XG5cbiAgICB2YXIgc3ltYm9sUm90YXRlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFJvdGF0ZScpO1xuICAgIHN5bWJvbFBhdGguYXR0cigncm90YXRpb24nLCAoc3ltYm9sUm90YXRlIHx8IDApICogTWF0aC5QSSAvIDE4MCB8fCAwKTtcblxuICAgIGlmIChzeW1ib2xPZmZzZXQpIHtcbiAgICAgIHN5bWJvbFBhdGgueCA9IHBhcnNlUGVyY2VudChzeW1ib2xPZmZzZXRbMF0sIHN5bWJvbFNpemVbMF0pO1xuICAgICAgc3ltYm9sUGF0aC55ID0gcGFyc2VQZXJjZW50KHN5bWJvbE9mZnNldFsxXSwgc3ltYm9sU2l6ZVsxXSk7XG4gICAgfVxuXG4gICAgY3Vyc29yU3R5bGUgJiYgc3ltYm9sUGF0aC5hdHRyKCdjdXJzb3InLCBjdXJzb3JTdHlsZSk7XG4gICAgdmFyIHN5bWJvbFN0eWxlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJyk7XG4gICAgdmFyIHZpc3VhbENvbG9yID0gc3ltYm9sU3R5bGUuZmlsbDtcblxuICAgIGlmIChzeW1ib2xQYXRoIGluc3RhbmNlb2YgWlJJbWFnZSkge1xuICAgICAgdmFyIHBhdGhTdHlsZSA9IHN5bWJvbFBhdGguc3R5bGU7XG4gICAgICBzeW1ib2xQYXRoLnVzZVN0eWxlKGV4dGVuZCh7XG4gICAgICAgIC8vIFRPRE8gb3RoZXIgcHJvcGVydGllcyBsaWtlIHgsIHkgP1xuICAgICAgICBpbWFnZTogcGF0aFN0eWxlLmltYWdlLFxuICAgICAgICB4OiBwYXRoU3R5bGUueCxcbiAgICAgICAgeTogcGF0aFN0eWxlLnksXG4gICAgICAgIHdpZHRoOiBwYXRoU3R5bGUud2lkdGgsXG4gICAgICAgIGhlaWdodDogcGF0aFN0eWxlLmhlaWdodFxuICAgICAgfSwgc3ltYm9sU3R5bGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN5bWJvbFBhdGguX19pc0VtcHR5QnJ1c2gpIHtcbiAgICAgICAgLy8gZmlsbCBhbmQgc3Ryb2tlIHdpbGwgYmUgc3dhcHBlZCBpZiBpdCdzIGVtcHR5LlxuICAgICAgICAvLyBTbyB3ZSBjbG9uZWQgYSBuZXcgc3R5bGUgdG8gYXZvaWQgaXQgYWZmZWN0aW5nIHRoZSBvcmlnaW5hbCBzdHlsZSBpbiB2aXN1YWwgc3RvcmFnZS5cbiAgICAgICAgLy8gVE9ETyBCZXR0ZXIgaW1wbGVtZW50YXRpb24uIE5vIGVtcHR5IGxvZ2ljIVxuICAgICAgICBzeW1ib2xQYXRoLnVzZVN0eWxlKGV4dGVuZCh7fSwgc3ltYm9sU3R5bGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN5bWJvbFBhdGgudXNlU3R5bGUoc3ltYm9sU3R5bGUpO1xuICAgICAgfSAvLyBEaXNhYmxlIGRlY2FsIGJlY2F1c2Ugc3ltYm9sIHNjYWxlIHdpbGwgYmVlbiBhcHBsaWVkIG9uIHRoZSBkZWNhbC5cblxuXG4gICAgICBzeW1ib2xQYXRoLnN0eWxlLmRlY2FsID0gbnVsbDtcbiAgICAgIHN5bWJvbFBhdGguc2V0Q29sb3IodmlzdWFsQ29sb3IsIG9wdHMgJiYgb3B0cy5zeW1ib2xJbm5lckNvbG9yKTtcbiAgICAgIHN5bWJvbFBhdGguc3R5bGUuc3Ryb2tlTm9TY2FsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxpZnRaID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2xpZnRaJyk7XG4gICAgdmFyIHoyT3JpZ2luID0gdGhpcy5fejI7XG5cbiAgICBpZiAobGlmdFogIT0gbnVsbCkge1xuICAgICAgaWYgKHoyT3JpZ2luID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fejIgPSBzeW1ib2xQYXRoLnoyO1xuICAgICAgICBzeW1ib2xQYXRoLnoyICs9IGxpZnRaO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoejJPcmlnaW4gIT0gbnVsbCkge1xuICAgICAgc3ltYm9sUGF0aC56MiA9IHoyT3JpZ2luO1xuICAgICAgdGhpcy5fejIgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciB1c2VOYW1lTGFiZWwgPSBvcHRzICYmIG9wdHMudXNlTmFtZUxhYmVsO1xuICAgIHNldExhYmVsU3R5bGUoc3ltYm9sUGF0aCwgbGFiZWxTdGF0ZXNNb2RlbHMsIHtcbiAgICAgIGxhYmVsRmV0Y2hlcjogc2VyaWVzTW9kZWwsXG4gICAgICBsYWJlbERhdGFJbmRleDogaWR4LFxuICAgICAgZGVmYXVsdFRleHQ6IGdldExhYmVsRGVmYXVsdFRleHQsXG4gICAgICBpbmhlcml0Q29sb3I6IHZpc3VhbENvbG9yLFxuICAgICAgZGVmYXVsdE9wYWNpdHk6IHN5bWJvbFN0eWxlLm9wYWNpdHlcbiAgICB9KTsgLy8gRG8gbm90IGV4ZWN1dGUgdXRpbCBuZWVkZWQuXG5cbiAgICBmdW5jdGlvbiBnZXRMYWJlbERlZmF1bHRUZXh0KGlkeCkge1xuICAgICAgcmV0dXJuIHVzZU5hbWVMYWJlbCA/IGRhdGEuZ2V0TmFtZShpZHgpIDogZ2V0RGVmYXVsdExhYmVsKGRhdGEsIGlkeCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2l6ZVggPSBzeW1ib2xTaXplWzBdIC8gMjtcbiAgICB0aGlzLl9zaXplWSA9IHN5bWJvbFNpemVbMV0gLyAyO1xuICAgIHZhciBlbXBoYXNpc1N0YXRlID0gc3ltYm9sUGF0aC5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKTtcbiAgICBlbXBoYXNpc1N0YXRlLnN0eWxlID0gZW1waGFzaXNJdGVtU3R5bGU7XG4gICAgc3ltYm9sUGF0aC5lbnN1cmVTdGF0ZSgnc2VsZWN0Jykuc3R5bGUgPSBzZWxlY3RJdGVtU3R5bGU7XG4gICAgc3ltYm9sUGF0aC5lbnN1cmVTdGF0ZSgnYmx1cicpLnN0eWxlID0gYmx1ckl0ZW1TdHlsZTtcblxuICAgIGlmIChob3ZlclNjYWxlKSB7XG4gICAgICB2YXIgc2NhbGVSYXRpbyA9IE1hdGgubWF4KDEuMSwgMyAvIHRoaXMuX3NpemVZKTtcbiAgICAgIGVtcGhhc2lzU3RhdGUuc2NhbGVYID0gdGhpcy5fc2l6ZVggKiBzY2FsZVJhdGlvO1xuICAgICAgZW1waGFzaXNTdGF0ZS5zY2FsZVkgPSB0aGlzLl9zaXplWSAqIHNjYWxlUmF0aW87XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTeW1ib2xTY2FsZSgxKTtcbiAgICBlbmFibGVIb3ZlckVtcGhhc2lzKHRoaXMsIGZvY3VzLCBibHVyU2NvcGUpO1xuICB9O1xuXG4gIFN5bWJvbC5wcm90b3R5cGUuc2V0U3ltYm9sU2NhbGUgPSBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICB0aGlzLnNjYWxlWCA9IHRoaXMuc2NhbGVZID0gc2NhbGU7XG4gIH07XG5cbiAgU3ltYm9sLnByb3RvdHlwZS5mYWRlT3V0ID0gZnVuY3Rpb24gKGNiLCBvcHQpIHtcbiAgICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICB2YXIgc2VyaWVzTW9kZWwgPSB0aGlzLl9zZXJpZXNNb2RlbDtcbiAgICB2YXIgZGF0YUluZGV4ID0gZ2V0RUNEYXRhKHRoaXMpLmRhdGFJbmRleDtcbiAgICB2YXIgYW5pbWF0aW9uT3B0ID0gb3B0ICYmIG9wdC5hbmltYXRpb247IC8vIEF2b2lkIG1pc3Rha2VuIGhvdmVyIHdoZW4gZmFkaW5nIG91dFxuXG4gICAgdGhpcy5zaWxlbnQgPSBzeW1ib2xQYXRoLnNpbGVudCA9IHRydWU7IC8vIE5vdCBzaG93IHRleHQgd2hlbiBhbmltYXRpbmdcblxuICAgIGlmIChvcHQgJiYgb3B0LmZhZGVMYWJlbCkge1xuICAgICAgdmFyIHRleHRDb250ZW50ID0gc3ltYm9sUGF0aC5nZXRUZXh0Q29udGVudCgpO1xuXG4gICAgICBpZiAodGV4dENvbnRlbnQpIHtcbiAgICAgICAgZ3JhcGhpYy5yZW1vdmVFbGVtZW50KHRleHRDb250ZW50LCB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHNlcmllc01vZGVsLCB7XG4gICAgICAgICAgZGF0YUluZGV4OiBkYXRhSW5kZXgsXG4gICAgICAgICAgcmVtb3ZlT3B0OiBhbmltYXRpb25PcHQsXG4gICAgICAgICAgY2I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN5bWJvbFBhdGgucmVtb3ZlVGV4dENvbnRlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzeW1ib2xQYXRoLnJlbW92ZVRleHRDb250ZW50KCk7XG4gICAgfVxuXG4gICAgZ3JhcGhpYy5yZW1vdmVFbGVtZW50KHN5bWJvbFBhdGgsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0sXG4gICAgICBzY2FsZVg6IDAsXG4gICAgICBzY2FsZVk6IDBcbiAgICB9LCBzZXJpZXNNb2RlbCwge1xuICAgICAgZGF0YUluZGV4OiBkYXRhSW5kZXgsXG4gICAgICBjYjogY2IsXG4gICAgICByZW1vdmVPcHQ6IGFuaW1hdGlvbk9wdFxuICAgIH0pO1xuICB9O1xuXG4gIFN5bWJvbC5nZXRTeW1ib2xTaXplID0gZnVuY3Rpb24gKGRhdGEsIGlkeCkge1xuICAgIHZhciBzeW1ib2xTaXplID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFNpemUnKTtcbiAgICByZXR1cm4gc3ltYm9sU2l6ZSBpbnN0YW5jZW9mIEFycmF5ID8gc3ltYm9sU2l6ZS5zbGljZSgpIDogWytzeW1ib2xTaXplLCArc3ltYm9sU2l6ZV07XG4gIH07XG5cbiAgcmV0dXJuIFN5bWJvbDtcbn0oZ3JhcGhpYy5Hcm91cCk7XG5cbmZ1bmN0aW9uIGRyaWZ0U3ltYm9sKGR4LCBkeSkge1xuICB0aGlzLnBhcmVudC5kcmlmdChkeCwgZHkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCBTeW1ib2xDbHogZnJvbSAnLi9TeW1ib2wnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgZ2V0TGFiZWxTdGF0ZXNNb2RlbHMgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlJztcblxuZnVuY3Rpb24gc3ltYm9sTmVlZHNEcmF3KGRhdGEsIHBvaW50LCBpZHgsIG9wdCkge1xuICByZXR1cm4gcG9pbnQgJiYgIWlzTmFOKHBvaW50WzBdKSAmJiAhaXNOYU4ocG9pbnRbMV0pICYmICEob3B0LmlzSWdub3JlICYmIG9wdC5pc0lnbm9yZShpZHgpKSAvLyBXZSBkbyBub3Qgc2V0IGNsaXBTaGFwZSBvbiBncm91cCwgYmVjYXVzZSBpdCB3aWxsIGN1dCBwYXJ0IG9mXG4gIC8vIHRoZSBzeW1ib2wgZWxlbWVudCBzaGFwZS4gV2UgdXNlIHRoZSBzYW1lIGNsaXAgc2hhcGUgaGVyZSBhc1xuICAvLyB0aGUgbGluZSBjbGlwLlxuICAmJiAhKG9wdC5jbGlwU2hhcGUgJiYgIW9wdC5jbGlwU2hhcGUuY29udGFpbihwb2ludFswXSwgcG9pbnRbMV0pKSAmJiBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJykgIT09ICdub25lJztcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVXBkYXRlT3B0KG9wdCkge1xuICBpZiAob3B0ICE9IG51bGwgJiYgIWlzT2JqZWN0KG9wdCkpIHtcbiAgICBvcHQgPSB7XG4gICAgICBpc0lnbm9yZTogb3B0XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBvcHQgfHwge307XG59XG5cbmZ1bmN0aW9uIG1ha2VTZXJpZXNTY29wZShkYXRhKSB7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICB2YXIgZW1waGFzaXNNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdlbXBoYXNpcycpO1xuICByZXR1cm4ge1xuICAgIGVtcGhhc2lzSXRlbVN0eWxlOiBlbXBoYXNpc01vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKS5nZXRJdGVtU3R5bGUoKSxcbiAgICBibHVySXRlbVN0eWxlOiBzZXJpZXNNb2RlbC5nZXRNb2RlbChbJ2JsdXInLCAnaXRlbVN0eWxlJ10pLmdldEl0ZW1TdHlsZSgpLFxuICAgIHNlbGVjdEl0ZW1TdHlsZTogc2VyaWVzTW9kZWwuZ2V0TW9kZWwoWydzZWxlY3QnLCAnaXRlbVN0eWxlJ10pLmdldEl0ZW1TdHlsZSgpLFxuICAgIGZvY3VzOiBlbXBoYXNpc01vZGVsLmdldCgnZm9jdXMnKSxcbiAgICBibHVyU2NvcGU6IGVtcGhhc2lzTW9kZWwuZ2V0KCdibHVyU2NvcGUnKSxcbiAgICBzeW1ib2xSb3RhdGU6IHNlcmllc01vZGVsLmdldCgnc3ltYm9sUm90YXRlJyksXG4gICAgc3ltYm9sT2Zmc2V0OiBzZXJpZXNNb2RlbC5nZXQoJ3N5bWJvbE9mZnNldCcpLFxuICAgIGhvdmVyU2NhbGU6IGVtcGhhc2lzTW9kZWwuZ2V0KCdzY2FsZScpLFxuICAgIGxhYmVsU3RhdGVzTW9kZWxzOiBnZXRMYWJlbFN0YXRlc01vZGVscyhzZXJpZXNNb2RlbCksXG4gICAgY3Vyc29yU3R5bGU6IHNlcmllc01vZGVsLmdldCgnY3Vyc29yJylcbiAgfTtcbn1cblxudmFyIFN5bWJvbERyYXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTeW1ib2xEcmF3KFN5bWJvbEN0b3IpIHtcbiAgICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICB0aGlzLl9TeW1ib2xDdG9yID0gU3ltYm9sQ3RvciB8fCBTeW1ib2xDbHo7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBzeW1ib2xzIGRyYXcgYnkgbmV3IGRhdGFcbiAgICovXG5cblxuICBTeW1ib2xEcmF3LnByb3RvdHlwZS51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGRhdGEsIG9wdCkge1xuICAgIG9wdCA9IG5vcm1hbGl6ZVVwZGF0ZU9wdChvcHQpO1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBTeW1ib2xDdG9yID0gdGhpcy5fU3ltYm9sQ3RvcjtcbiAgICB2YXIgZGlzYWJsZUFuaW1hdGlvbiA9IG9wdC5kaXNhYmxlQW5pbWF0aW9uO1xuICAgIHZhciBzZXJpZXNTY29wZSA9IG1ha2VTZXJpZXNTY29wZShkYXRhKTtcbiAgICB2YXIgc3ltYm9sVXBkYXRlT3B0ID0ge1xuICAgICAgZGlzYWJsZUFuaW1hdGlvbjogZGlzYWJsZUFuaW1hdGlvblxuICAgIH07XG5cbiAgICB2YXIgZ2V0U3ltYm9sUG9pbnQgPSBvcHQuZ2V0U3ltYm9sUG9pbnQgfHwgZnVuY3Rpb24gKGlkeCkge1xuICAgICAgcmV0dXJuIGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgIH07IC8vIFRoZXJlIGlzIG5vIG9sZExpbmVEYXRhIG9ubHkgd2hlbiBmaXJzdCByZW5kZXJpbmcgb3Igc3dpdGNoaW5nIGZyb21cbiAgICAvLyBzdHJlYW0gbW9kZSB0byBub3JtYWwgbW9kZSwgd2hlcmUgcHJldmlvdXMgZWxlbWVudHMgc2hvdWxkIGJlIHJlbW92ZWQuXG5cblxuICAgIGlmICghb2xkRGF0YSkge1xuICAgICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgfVxuXG4gICAgZGF0YS5kaWZmKG9sZERhdGEpLmFkZChmdW5jdGlvbiAobmV3SWR4KSB7XG4gICAgICB2YXIgcG9pbnQgPSBnZXRTeW1ib2xQb2ludChuZXdJZHgpO1xuXG4gICAgICBpZiAoc3ltYm9sTmVlZHNEcmF3KGRhdGEsIHBvaW50LCBuZXdJZHgsIG9wdCkpIHtcbiAgICAgICAgdmFyIHN5bWJvbEVsID0gbmV3IFN5bWJvbEN0b3IoZGF0YSwgbmV3SWR4LCBzZXJpZXNTY29wZSwgc3ltYm9sVXBkYXRlT3B0KTtcbiAgICAgICAgc3ltYm9sRWwuc2V0UG9zaXRpb24ocG9pbnQpO1xuICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBzeW1ib2xFbCk7XG4gICAgICAgIGdyb3VwLmFkZChzeW1ib2xFbCk7XG4gICAgICB9XG4gICAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgdmFyIHN5bWJvbEVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgICB2YXIgcG9pbnQgPSBnZXRTeW1ib2xQb2ludChuZXdJZHgpO1xuXG4gICAgICBpZiAoIXN5bWJvbE5lZWRzRHJhdyhkYXRhLCBwb2ludCwgbmV3SWR4LCBvcHQpKSB7XG4gICAgICAgIGdyb3VwLnJlbW92ZShzeW1ib2xFbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzeW1ib2xFbCkge1xuICAgICAgICBzeW1ib2xFbCA9IG5ldyBTeW1ib2xDdG9yKGRhdGEsIG5ld0lkeCk7XG4gICAgICAgIHN5bWJvbEVsLnNldFBvc2l0aW9uKHBvaW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN5bWJvbEVsLnVwZGF0ZURhdGEoZGF0YSwgbmV3SWR4LCBzZXJpZXNTY29wZSwgc3ltYm9sVXBkYXRlT3B0KTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHtcbiAgICAgICAgICB4OiBwb2ludFswXSxcbiAgICAgICAgICB5OiBwb2ludFsxXVxuICAgICAgICB9O1xuICAgICAgICBkaXNhYmxlQW5pbWF0aW9uID8gc3ltYm9sRWwuYXR0cih0YXJnZXQpIDogZ3JhcGhpYy51cGRhdGVQcm9wcyhzeW1ib2xFbCwgdGFyZ2V0LCBzZXJpZXNNb2RlbCk7XG4gICAgICB9IC8vIEFkZCBiYWNrXG5cblxuICAgICAgZ3JvdXAuYWRkKHN5bWJvbEVsKTtcbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIHN5bWJvbEVsKTtcbiAgICB9KS5yZW1vdmUoZnVuY3Rpb24gKG9sZElkeCkge1xuICAgICAgdmFyIGVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgICBlbCAmJiBlbC5mYWRlT3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICAgIH0pO1xuICAgIH0pLmV4ZWN1dGUoKTtcbiAgICB0aGlzLl9nZXRTeW1ib2xQb2ludCA9IGdldFN5bWJvbFBvaW50O1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9O1xuXG4gIDtcblxuICBTeW1ib2xEcmF3LnByb3RvdHlwZS5pc1BlcnNpc3RlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgO1xuXG4gIFN5bWJvbERyYXcucHJvdG90eXBlLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIC8vIE5vdCB1c2UgYW5pbWF0aW9uXG4gICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICAgIHZhciBwb2ludCA9IF90aGlzLl9nZXRTeW1ib2xQb2ludChpZHgpO1xuXG4gICAgICAgIGVsLnNldFBvc2l0aW9uKHBvaW50KTtcbiAgICAgICAgZWwubWFya1JlZHJhdygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIDtcblxuICBTeW1ib2xEcmF3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFByZXBhcmVVcGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuX3Nlcmllc1Njb3BlID0gbWFrZVNlcmllc1Njb3BlKGRhdGEpO1xuICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gIH07XG5cbiAgO1xuICAvKipcbiAgICogVXBkYXRlIHN5bWJvbHMgZHJhdyBieSBuZXcgZGF0YVxuICAgKi9cblxuICBTeW1ib2xEcmF3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFVwZGF0ZSA9IGZ1bmN0aW9uICh0YXNrUGFyYW1zLCBkYXRhLCBvcHQpIHtcbiAgICBvcHQgPSBub3JtYWxpemVVcGRhdGVPcHQob3B0KTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUluY3JlbWVudGFsQW5kSG92ZXIoZWwpIHtcbiAgICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgICBlbC5pbmNyZW1lbnRhbCA9IHRydWU7XG4gICAgICAgIGVsLmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpLmhvdmVyTGF5ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGlkeCA9IHRhc2tQYXJhbXMuc3RhcnQ7IGlkeCA8IHRhc2tQYXJhbXMuZW5kOyBpZHgrKykge1xuICAgICAgdmFyIHBvaW50ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG5cbiAgICAgIGlmIChzeW1ib2xOZWVkc0RyYXcoZGF0YSwgcG9pbnQsIGlkeCwgb3B0KSkge1xuICAgICAgICB2YXIgZWwgPSBuZXcgdGhpcy5fU3ltYm9sQ3RvcihkYXRhLCBpZHgsIHRoaXMuX3Nlcmllc1Njb3BlKTtcbiAgICAgICAgZWwudHJhdmVyc2UodXBkYXRlSW5jcmVtZW50YWxBbmRIb3Zlcik7XG4gICAgICAgIGVsLnNldFBvc2l0aW9uKHBvaW50KTtcbiAgICAgICAgdGhpcy5ncm91cC5hZGQoZWwpO1xuICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoaWR4LCBlbCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIDtcblxuICBTeW1ib2xEcmF3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZW5hYmxlQW5pbWF0aW9uKSB7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7IC8vIEluY3JlbWVudGFsIG1vZGVsIGRvIG5vdCBoYXZlIHRoaXMuX2RhdGEuXG5cbiAgICBpZiAoZGF0YSAmJiBlbmFibGVBbmltYXRpb24pIHtcbiAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLmZhZGVPdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIH1cbiAgfTtcblxuICA7XG4gIHJldHVybiBTeW1ib2xEcmF3O1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2xEcmF3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyByZXRyaWV2ZVJhd1ZhbHVlIH0gZnJvbSAnLi4vLi4vZGF0YS9oZWxwZXIvZGF0YVByb3ZpZGVyJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuLyoqXG4gKiBAcmV0dXJuIGxhYmVsIHN0cmluZy4gTm90IG51bGwvdW5kZWZpbmVkXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRMYWJlbChkYXRhLCBkYXRhSW5kZXgpIHtcbiAgdmFyIGxhYmVsRGltcyA9IGRhdGEubWFwRGltZW5zaW9uc0FsbCgnZGVmYXVsdGVkTGFiZWwnKTtcbiAgdmFyIGxlbiA9IGxhYmVsRGltcy5sZW5ndGg7IC8vIFNpbXBsZSBvcHRpbWl6YXRpb24gKGluIGxvdHMgb2YgY2FzZXMsIGxhYmVsIGRpbXMgbGVuZ3RoIGlzIDEpXG5cbiAgaWYgKGxlbiA9PT0gMSkge1xuICAgIHZhciByYXdWYWwgPSByZXRyaWV2ZVJhd1ZhbHVlKGRhdGEsIGRhdGFJbmRleCwgbGFiZWxEaW1zWzBdKTtcbiAgICByZXR1cm4gcmF3VmFsICE9IG51bGwgPyByYXdWYWwgKyAnJyA6IG51bGw7XG4gIH0gZWxzZSBpZiAobGVuKSB7XG4gICAgdmFyIHZhbHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxEaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxzLnB1c2gocmV0cmlldmVSYXdWYWx1ZShkYXRhLCBkYXRhSW5kZXgsIGxhYmVsRGltc1tpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxzLmpvaW4oJyAnKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRJbnRlcnBvbGF0ZWRMYWJlbChkYXRhLCBpbnRlcnBvbGF0ZWRWYWx1ZSkge1xuICB2YXIgbGFiZWxEaW1zID0gZGF0YS5tYXBEaW1lbnNpb25zQWxsKCdkZWZhdWx0ZWRMYWJlbCcpO1xuXG4gIGlmICghaXNBcnJheShpbnRlcnBvbGF0ZWRWYWx1ZSkpIHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGVkVmFsdWUgKyAnJztcbiAgfVxuXG4gIHZhciB2YWxzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbERpbXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGltSW5mbyA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhsYWJlbERpbXNbaV0pO1xuXG4gICAgaWYgKGRpbUluZm8pIHtcbiAgICAgIHZhbHMucHVzaChpbnRlcnBvbGF0ZWRWYWx1ZVtkaW1JbmZvLmluZGV4XSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHMuam9pbignICcpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyByZXRyaWV2ZSwgZGVmYXVsdHMsIGV4dGVuZCwgZWFjaCwgaXNPYmplY3QgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlJztcbmltcG9ydCB7IGNyZWF0ZVRleHRTdHlsZSB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUnO1xuaW1wb3J0IE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL01vZGVsJztcbmltcG9ydCB7IGlzUmFkaWFuQXJvdW5kWmVybywgcmVtUmFkaWFuIH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXInO1xuaW1wb3J0IHsgY3JlYXRlU3ltYm9sIH0gZnJvbSAnLi4vLi4vdXRpbC9zeW1ib2wnO1xuaW1wb3J0ICogYXMgbWF0cml4VXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeCc7XG5pbXBvcnQgeyBhcHBseVRyYW5zZm9ybSBhcyB2MkFwcGx5VHJhbnNmb3JtIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS92ZWN0b3InO1xuaW1wb3J0IHsgc2hvdWxkU2hvd0FsbExhYmVscyB9IGZyb20gJy4uLy4uL2Nvb3JkL2F4aXNIZWxwZXInO1xudmFyIFBJID0gTWF0aC5QSTtcbi8qKlxuICogQSBmaW5hbCBheGlzIGlzIHRyYW5zbGF0ZWQgYW5kIHJvdGF0ZWQgZnJvbSBhIFwic3RhbmRhcmQgYXhpc1wiLlxuICogU28gb3B0LnBvc2l0aW9uIGFuZCBvcHQucm90YXRpb24gaXMgcmVxdWlyZWQuXG4gKlxuICogQSBzdGFuZGFyZCBheGlzIGlzIGFuZCBheGlzIGZyb20gWzAsIDBdIHRvIFswLCBheGlzRXh0ZW50WzFdXSxcbiAqIGZvciBleGFtcGxlOiAoMCwgMCkgLS0tLS0tLS0tLS0tPiAoMCwgNTApXG4gKlxuICogbmFtZURpcmVjdGlvbiBvciB0aWNrRGlyZWN0aW9uIG9yIGxhYmVsRGlyZWN0aW9uIGlzIDEgbWVhbnMgdGlja1xuICogb3IgbGFiZWwgaXMgYmVsb3cgdGhlIHN0YW5kYXJkIGF4aXMsIHdoZXJlYXMgaXMgLTEgbWVhbnMgYWJvdmVcbiAqIHRoZSBzdGFuZGFyZCBheGlzLiBsYWJlbE9mZnNldCBtZWFucyBvZmZzZXQgYmV0d2VlbiBsYWJlbCBhbmQgYXhpcyxcbiAqIHdoaWNoIGlzIHVzZWZ1bCB3aGVuICdvblplcm8nLCB3aGVyZSBheGlzTGFiZWwgaXMgaW4gdGhlIGdyaWQgYW5kXG4gKiBsYWJlbCBpbiBvdXRzaWRlIGdyaWQuXG4gKlxuICogVGlwczogbGlrZSBhbHdheXMsXG4gKiBwb3NpdGl2ZSByb3RhdGlvbiByZXByZXNlbnRzIGFudGljbG9ja3dpc2UsIGFuZCBuZWdhdGl2ZSByb3RhdGlvblxuICogcmVwcmVzZW50cyBjbG9ja3dpc2UuXG4gKiBUaGUgZGlyZWN0aW9uIG9mIHBvc2l0aW9uIGNvb3JkaW5hdGUgaXMgdGhlIHNhbWUgYXMgdGhlIGRpcmVjdGlvblxuICogb2Ygc2NyZWVuIGNvb3JkaW5hdGUuXG4gKlxuICogRG8gbm90IG5lZWQgdG8gY29uc2lkZXIgYXhpcyAnaW52ZXJzZScsIHdoaWNoIGlzIGF1dG8gcHJvY2Vzc2VkIGJ5XG4gKiBheGlzIGV4dGVudC5cbiAqL1xuXG52YXIgQXhpc0J1aWxkZXIgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBeGlzQnVpbGRlcihheGlzTW9kZWwsIG9wdCkge1xuICAgIHRoaXMuZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIHRoaXMub3B0ID0gb3B0O1xuICAgIHRoaXMuYXhpc01vZGVsID0gYXhpc01vZGVsOyAvLyBEZWZhdWx0IHZhbHVlXG5cbiAgICBkZWZhdWx0cyhvcHQsIHtcbiAgICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgICAgbmFtZURpcmVjdGlvbjogMSxcbiAgICAgIHRpY2tEaXJlY3Rpb246IDEsXG4gICAgICBsYWJlbERpcmVjdGlvbjogMSxcbiAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgIGhhbmRsZUF1dG9TaG93bjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTsgLy8gRklYTUUgTm90IHVzZSBhIHNlcGVyYXRlIHRleHQgZ3JvdXA/XG5cbiAgICB2YXIgdHJhbnNmb3JtR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCh7XG4gICAgICB4OiBvcHQucG9zaXRpb25bMF0sXG4gICAgICB5OiBvcHQucG9zaXRpb25bMV0sXG4gICAgICByb3RhdGlvbjogb3B0LnJvdGF0aW9uXG4gICAgfSk7IC8vIHRoaXMuZ3JvdXAuYWRkKHRyYW5zZm9ybUdyb3VwKTtcbiAgICAvLyB0aGlzLl90cmFuc2Zvcm1Hcm91cCA9IHRyYW5zZm9ybUdyb3VwO1xuXG4gICAgdHJhbnNmb3JtR3JvdXAudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgdGhpcy5fdHJhbnNmb3JtR3JvdXAgPSB0cmFuc2Zvcm1Hcm91cDtcbiAgfVxuXG4gIEF4aXNCdWlsZGVyLnByb3RvdHlwZS5oYXNCdWlsZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gISFidWlsZGVyc1tuYW1lXTtcbiAgfTtcblxuICBBeGlzQnVpbGRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBidWlsZGVyc1tuYW1lXSh0aGlzLm9wdCwgdGhpcy5heGlzTW9kZWwsIHRoaXMuZ3JvdXAsIHRoaXMuX3RyYW5zZm9ybUdyb3VwKTtcbiAgfTtcblxuICBBeGlzQnVpbGRlci5wcm90b3R5cGUuZ2V0R3JvdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXA7XG4gIH07XG5cbiAgQXhpc0J1aWxkZXIuaW5uZXJUZXh0TGF5b3V0ID0gZnVuY3Rpb24gKGF4aXNSb3RhdGlvbiwgdGV4dFJvdGF0aW9uLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgcm90YXRpb25EaWZmID0gcmVtUmFkaWFuKHRleHRSb3RhdGlvbiAtIGF4aXNSb3RhdGlvbik7XG4gICAgdmFyIHRleHRBbGlnbjtcbiAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ247XG5cbiAgICBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZikpIHtcbiAgICAgIC8vIExhYmVsIGlzIHBhcmFsbGVsIHdpdGggYXhpcyBsaW5lLlxuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSBkaXJlY3Rpb24gPiAwID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIH0gZWxzZSBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZiAtIFBJKSkge1xuICAgICAgLy8gTGFiZWwgaXMgaW52ZXJzZSBwYXJhbGxlbCB3aXRoIGF4aXMgbGluZS5cbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gZGlyZWN0aW9uID4gMCA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcblxuICAgICAgaWYgKHJvdGF0aW9uRGlmZiA+IDAgJiYgcm90YXRpb25EaWZmIDwgUEkpIHtcbiAgICAgICAgdGV4dEFsaWduID0gZGlyZWN0aW9uID4gMCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0QWxpZ24gPSBkaXJlY3Rpb24gPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRpb246IHJvdGF0aW9uRGlmZixcbiAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gICAgfTtcbiAgfTtcblxuICBBeGlzQnVpbGRlci5tYWtlQXhpc0V2ZW50RGF0YUJhc2UgPSBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgdmFyIGV2ZW50RGF0YSA9IHtcbiAgICAgIGNvbXBvbmVudFR5cGU6IGF4aXNNb2RlbC5tYWluVHlwZSxcbiAgICAgIGNvbXBvbmVudEluZGV4OiBheGlzTW9kZWwuY29tcG9uZW50SW5kZXhcbiAgICB9O1xuICAgIGV2ZW50RGF0YVtheGlzTW9kZWwubWFpblR5cGUgKyAnSW5kZXgnXSA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcbiAgICByZXR1cm4gZXZlbnREYXRhO1xuICB9O1xuXG4gIEF4aXNCdWlsZGVyLmlzTGFiZWxTaWxlbnQgPSBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgdmFyIHRvb2x0aXBPcHQgPSBheGlzTW9kZWwuZ2V0KCd0b29sdGlwJyk7XG4gICAgcmV0dXJuIGF4aXNNb2RlbC5nZXQoJ3NpbGVudCcpIC8vIENvbnNpZGVyIG1vdXNlIGN1cnNvciwgYWRkIHRoZXNlIHJlc3RyaWN0aW9ucy5cbiAgICB8fCAhKGF4aXNNb2RlbC5nZXQoJ3RyaWdnZXJFdmVudCcpIHx8IHRvb2x0aXBPcHQgJiYgdG9vbHRpcE9wdC5zaG93KTtcbiAgfTtcblxuICByZXR1cm4gQXhpc0J1aWxkZXI7XG59KCk7XG5cbjtcbnZhciBidWlsZGVycyA9IHtcbiAgYXhpc0xpbmU6IGZ1bmN0aW9uIChvcHQsIGF4aXNNb2RlbCwgZ3JvdXAsIHRyYW5zZm9ybUdyb3VwKSB7XG4gICAgdmFyIHNob3duID0gYXhpc01vZGVsLmdldChbJ2F4aXNMaW5lJywgJ3Nob3cnXSk7XG5cbiAgICBpZiAoc2hvd24gPT09ICdhdXRvJyAmJiBvcHQuaGFuZGxlQXV0b1Nob3duKSB7XG4gICAgICBzaG93biA9IG9wdC5oYW5kbGVBdXRvU2hvd24oJ2F4aXNMaW5lJyk7XG4gICAgfVxuXG4gICAgaWYgKCFzaG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBleHRlbnQgPSBheGlzTW9kZWwuYXhpcy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgbWF0cml4ID0gdHJhbnNmb3JtR3JvdXAudHJhbnNmb3JtO1xuICAgIHZhciBwdDEgPSBbZXh0ZW50WzBdLCAwXTtcbiAgICB2YXIgcHQyID0gW2V4dGVudFsxXSwgMF07XG5cbiAgICBpZiAobWF0cml4KSB7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHB0MSwgcHQxLCBtYXRyaXgpO1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShwdDIsIHB0MiwgbWF0cml4KTtcbiAgICB9XG5cbiAgICB2YXIgbGluZVN0eWxlID0gZXh0ZW5kKHtcbiAgICAgIGxpbmVDYXA6ICdyb3VuZCdcbiAgICB9LCBheGlzTW9kZWwuZ2V0TW9kZWwoWydheGlzTGluZScsICdsaW5lU3R5bGUnXSkuZ2V0TGluZVN0eWxlKCkpO1xuICAgIHZhciBsaW5lID0gbmV3IGdyYXBoaWMuTGluZSh7XG4gICAgICAvLyBJZCBmb3IgYW5pbWF0aW9uXG4gICAgICBzdWJQaXhlbE9wdGltaXplOiB0cnVlLFxuICAgICAgc2hhcGU6IHtcbiAgICAgICAgeDE6IHB0MVswXSxcbiAgICAgICAgeTE6IHB0MVsxXSxcbiAgICAgICAgeDI6IHB0MlswXSxcbiAgICAgICAgeTI6IHB0MlsxXVxuICAgICAgfSxcbiAgICAgIHN0eWxlOiBsaW5lU3R5bGUsXG4gICAgICBzdHJva2VDb250YWluVGhyZXNob2xkOiBvcHQuc3Ryb2tlQ29udGFpblRocmVzaG9sZCB8fCA1LFxuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgejI6IDFcbiAgICB9KTtcbiAgICBsaW5lLmFuaWQgPSAnbGluZSc7XG4gICAgZ3JvdXAuYWRkKGxpbmUpO1xuICAgIHZhciBhcnJvd3MgPSBheGlzTW9kZWwuZ2V0KFsnYXhpc0xpbmUnLCAnc3ltYm9sJ10pO1xuICAgIHZhciBhcnJvd1NpemUgPSBheGlzTW9kZWwuZ2V0KFsnYXhpc0xpbmUnLCAnc3ltYm9sU2l6ZSddKTtcbiAgICB2YXIgYXJyb3dPZmZzZXQgPSBheGlzTW9kZWwuZ2V0KFsnYXhpc0xpbmUnLCAnc3ltYm9sT2Zmc2V0J10pIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIGFycm93T2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgYXJyb3dPZmZzZXQgPSBbYXJyb3dPZmZzZXQsIGFycm93T2Zmc2V0XTtcbiAgICB9XG5cbiAgICBpZiAoYXJyb3dzICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJyb3dzID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBVc2UgdGhlIHNhbWUgYXJyb3cgZm9yIHN0YXJ0IGFuZCBlbmQgcG9pbnRcbiAgICAgICAgYXJyb3dzID0gW2Fycm93cywgYXJyb3dzXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBhcnJvd1NpemUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhcnJvd1NpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgc2FtZSBzaXplIGZvciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgIGFycm93U2l6ZSA9IFthcnJvd1NpemUsIGFycm93U2l6ZV07XG4gICAgICB9XG5cbiAgICAgIHZhciBzeW1ib2xXaWR0aF8xID0gYXJyb3dTaXplWzBdO1xuICAgICAgdmFyIHN5bWJvbEhlaWdodF8xID0gYXJyb3dTaXplWzFdO1xuICAgICAgZWFjaChbe1xuICAgICAgICByb3RhdGU6IG9wdC5yb3RhdGlvbiArIE1hdGguUEkgLyAyLFxuICAgICAgICBvZmZzZXQ6IGFycm93T2Zmc2V0WzBdLFxuICAgICAgICByOiAwXG4gICAgICB9LCB7XG4gICAgICAgIHJvdGF0ZTogb3B0LnJvdGF0aW9uIC0gTWF0aC5QSSAvIDIsXG4gICAgICAgIG9mZnNldDogYXJyb3dPZmZzZXRbMV0sXG4gICAgICAgIHI6IE1hdGguc3FydCgocHQxWzBdIC0gcHQyWzBdKSAqIChwdDFbMF0gLSBwdDJbMF0pICsgKHB0MVsxXSAtIHB0MlsxXSkgKiAocHQxWzFdIC0gcHQyWzFdKSlcbiAgICAgIH1dLCBmdW5jdGlvbiAocG9pbnQsIGluZGV4KSB7XG4gICAgICAgIGlmIChhcnJvd3NbaW5kZXhdICE9PSAnbm9uZScgJiYgYXJyb3dzW2luZGV4XSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHN5bWJvbCA9IGNyZWF0ZVN5bWJvbChhcnJvd3NbaW5kZXhdLCAtc3ltYm9sV2lkdGhfMSAvIDIsIC1zeW1ib2xIZWlnaHRfMSAvIDIsIHN5bWJvbFdpZHRoXzEsIHN5bWJvbEhlaWdodF8xLCBsaW5lU3R5bGUuc3Ryb2tlLCB0cnVlKTsgLy8gQ2FsY3VsYXRlIGFycm93IHBvc2l0aW9uIHdpdGggb2Zmc2V0XG5cbiAgICAgICAgICB2YXIgciA9IHBvaW50LnIgKyBwb2ludC5vZmZzZXQ7XG4gICAgICAgICAgc3ltYm9sLmF0dHIoe1xuICAgICAgICAgICAgcm90YXRpb246IHBvaW50LnJvdGF0ZSxcbiAgICAgICAgICAgIHg6IHB0MVswXSArIHIgKiBNYXRoLmNvcyhvcHQucm90YXRpb24pLFxuICAgICAgICAgICAgeTogcHQxWzFdIC0gciAqIE1hdGguc2luKG9wdC5yb3RhdGlvbiksXG4gICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICB6MjogMTFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBncm91cC5hZGQoc3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBheGlzVGlja0xhYmVsOiBmdW5jdGlvbiAob3B0LCBheGlzTW9kZWwsIGdyb3VwLCB0cmFuc2Zvcm1Hcm91cCkge1xuICAgIHZhciB0aWNrc0VscyA9IGJ1aWxkQXhpc01ham9yVGlja3MoZ3JvdXAsIHRyYW5zZm9ybUdyb3VwLCBheGlzTW9kZWwsIG9wdCk7XG4gICAgdmFyIGxhYmVsRWxzID0gYnVpbGRBeGlzTGFiZWwoZ3JvdXAsIHRyYW5zZm9ybUdyb3VwLCBheGlzTW9kZWwsIG9wdCk7XG4gICAgZml4TWluTWF4TGFiZWxTaG93KGF4aXNNb2RlbCwgbGFiZWxFbHMsIHRpY2tzRWxzKTtcbiAgICBidWlsZEF4aXNNaW5vclRpY2tzKGdyb3VwLCB0cmFuc2Zvcm1Hcm91cCwgYXhpc01vZGVsLCBvcHQudGlja0RpcmVjdGlvbik7XG4gIH0sXG4gIGF4aXNOYW1lOiBmdW5jdGlvbiAob3B0LCBheGlzTW9kZWwsIGdyb3VwLCB0cmFuc2Zvcm1Hcm91cCkge1xuICAgIHZhciBuYW1lID0gcmV0cmlldmUob3B0LmF4aXNOYW1lLCBheGlzTW9kZWwuZ2V0KCduYW1lJykpO1xuXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5hbWVMb2NhdGlvbiA9IGF4aXNNb2RlbC5nZXQoJ25hbWVMb2NhdGlvbicpO1xuICAgIHZhciBuYW1lRGlyZWN0aW9uID0gb3B0Lm5hbWVEaXJlY3Rpb247XG4gICAgdmFyIHRleHRTdHlsZU1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCduYW1lVGV4dFN0eWxlJyk7XG4gICAgdmFyIGdhcCA9IGF4aXNNb2RlbC5nZXQoJ25hbWVHYXAnKSB8fCAwO1xuICAgIHZhciBleHRlbnQgPSBheGlzTW9kZWwuYXhpcy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgZ2FwU2lnbmFsID0gZXh0ZW50WzBdID4gZXh0ZW50WzFdID8gLTEgOiAxO1xuICAgIHZhciBwb3MgPSBbbmFtZUxvY2F0aW9uID09PSAnc3RhcnQnID8gZXh0ZW50WzBdIC0gZ2FwU2lnbmFsICogZ2FwIDogbmFtZUxvY2F0aW9uID09PSAnZW5kJyA/IGV4dGVudFsxXSArIGdhcFNpZ25hbCAqIGdhcCA6IChleHRlbnRbMF0gKyBleHRlbnRbMV0pIC8gMiwgLy8gUmV1c2UgbGFiZWxPZmZzZXQuXG4gICAgaXNOYW1lTG9jYXRpb25DZW50ZXIobmFtZUxvY2F0aW9uKSA/IG9wdC5sYWJlbE9mZnNldCArIG5hbWVEaXJlY3Rpb24gKiBnYXAgOiAwXTtcbiAgICB2YXIgbGFiZWxMYXlvdXQ7XG4gICAgdmFyIG5hbWVSb3RhdGlvbiA9IGF4aXNNb2RlbC5nZXQoJ25hbWVSb3RhdGUnKTtcblxuICAgIGlmIChuYW1lUm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgbmFtZVJvdGF0aW9uID0gbmFtZVJvdGF0aW9uICogUEkgLyAxODA7IC8vIFRvIHJhZGlhbi5cbiAgICB9XG5cbiAgICB2YXIgYXhpc05hbWVBdmFpbGFibGVXaWR0aDtcblxuICAgIGlmIChpc05hbWVMb2NhdGlvbkNlbnRlcihuYW1lTG9jYXRpb24pKSB7XG4gICAgICBsYWJlbExheW91dCA9IEF4aXNCdWlsZGVyLmlubmVyVGV4dExheW91dChvcHQucm90YXRpb24sIG5hbWVSb3RhdGlvbiAhPSBudWxsID8gbmFtZVJvdGF0aW9uIDogb3B0LnJvdGF0aW9uLCAvLyBBZGFwdCB0byBheGlzLlxuICAgICAgbmFtZURpcmVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsTGF5b3V0ID0gZW5kVGV4dExheW91dChvcHQucm90YXRpb24sIG5hbWVMb2NhdGlvbiwgbmFtZVJvdGF0aW9uIHx8IDAsIGV4dGVudCk7XG4gICAgICBheGlzTmFtZUF2YWlsYWJsZVdpZHRoID0gb3B0LmF4aXNOYW1lQXZhaWxhYmxlV2lkdGg7XG5cbiAgICAgIGlmIChheGlzTmFtZUF2YWlsYWJsZVdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgYXhpc05hbWVBdmFpbGFibGVXaWR0aCA9IE1hdGguYWJzKGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggLyBNYXRoLnNpbihsYWJlbExheW91dC5yb3RhdGlvbikpO1xuICAgICAgICAhaXNGaW5pdGUoYXhpc05hbWVBdmFpbGFibGVXaWR0aCkgJiYgKGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggPSBudWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGV4dEZvbnQgPSB0ZXh0U3R5bGVNb2RlbC5nZXRGb250KCk7XG4gICAgdmFyIHRydW5jYXRlT3B0ID0gYXhpc01vZGVsLmdldCgnbmFtZVRydW5jYXRlJywgdHJ1ZSkgfHwge307XG4gICAgdmFyIGVsbGlwc2lzID0gdHJ1bmNhdGVPcHQuZWxsaXBzaXM7XG4gICAgdmFyIG1heFdpZHRoID0gcmV0cmlldmUob3B0Lm5hbWVUcnVuY2F0ZU1heFdpZHRoLCB0cnVuY2F0ZU9wdC5tYXhXaWR0aCwgYXhpc05hbWVBdmFpbGFibGVXaWR0aCk7XG4gICAgdmFyIHRvb2x0aXBPcHQgPSBheGlzTW9kZWwuZ2V0KCd0b29sdGlwJywgdHJ1ZSk7XG4gICAgdmFyIG1haW5UeXBlID0gYXhpc01vZGVsLm1haW5UeXBlO1xuICAgIHZhciBmb3JtYXR0ZXJQYXJhbXMgPSB7XG4gICAgICBjb21wb25lbnRUeXBlOiBtYWluVHlwZSxcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAkdmFyczogWyduYW1lJ11cbiAgICB9O1xuICAgIGZvcm1hdHRlclBhcmFtc1ttYWluVHlwZSArICdJbmRleCddID0gYXhpc01vZGVsLmNvbXBvbmVudEluZGV4O1xuICAgIHZhciB0ZXh0RWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIHg6IHBvc1swXSxcbiAgICAgIHk6IHBvc1sxXSxcbiAgICAgIHJvdGF0aW9uOiBsYWJlbExheW91dC5yb3RhdGlvbixcbiAgICAgIHNpbGVudDogQXhpc0J1aWxkZXIuaXNMYWJlbFNpbGVudChheGlzTW9kZWwpLFxuICAgICAgc3R5bGU6IGNyZWF0ZVRleHRTdHlsZSh0ZXh0U3R5bGVNb2RlbCwge1xuICAgICAgICB0ZXh0OiBuYW1lLFxuICAgICAgICBmb250OiB0ZXh0Rm9udCxcbiAgICAgICAgb3ZlcmZsb3c6ICd0cnVuY2F0ZScsXG4gICAgICAgIHdpZHRoOiBtYXhXaWR0aCxcbiAgICAgICAgZWxsaXBzaXM6IGVsbGlwc2lzLFxuICAgICAgICBmaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBheGlzTW9kZWwuZ2V0KFsnYXhpc0xpbmUnLCAnbGluZVN0eWxlJywgJ2NvbG9yJ10pLFxuICAgICAgICBhbGlnbjogdGV4dFN0eWxlTW9kZWwuZ2V0KCdhbGlnbicpIHx8IGxhYmVsTGF5b3V0LnRleHRBbGlnbixcbiAgICAgICAgdmVydGljYWxBbGlnbjogdGV4dFN0eWxlTW9kZWwuZ2V0KCd2ZXJ0aWNhbEFsaWduJykgfHwgbGFiZWxMYXlvdXQudGV4dFZlcnRpY2FsQWxpZ25cbiAgICAgIH0pLFxuICAgICAgejI6IDFcbiAgICB9KTtcbiAgICB0ZXh0RWwudG9vbHRpcCA9IHRvb2x0aXBPcHQgJiYgdG9vbHRpcE9wdC5zaG93ID8gZXh0ZW5kKHtcbiAgICAgIGNvbnRlbnQ6IG5hbWUsXG4gICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9LFxuICAgICAgZm9ybWF0dGVyUGFyYW1zOiBmb3JtYXR0ZXJQYXJhbXNcbiAgICB9LCB0b29sdGlwT3B0KSA6IG51bGw7XG4gICAgdGV4dEVsLl9fZnVsbFRleHQgPSBuYW1lOyAvLyBJZCBmb3IgYW5pbWF0aW9uXG5cbiAgICB0ZXh0RWwuYW5pZCA9ICduYW1lJztcblxuICAgIGlmIChheGlzTW9kZWwuZ2V0KCd0cmlnZ2VyRXZlbnQnKSkge1xuICAgICAgdmFyIGV2ZW50RGF0YSA9IEF4aXNCdWlsZGVyLm1ha2VBeGlzRXZlbnREYXRhQmFzZShheGlzTW9kZWwpO1xuICAgICAgZXZlbnREYXRhLnRhcmdldFR5cGUgPSAnYXhpc05hbWUnO1xuICAgICAgZXZlbnREYXRhLm5hbWUgPSBuYW1lO1xuICAgICAgZ2V0RUNEYXRhKHRleHRFbCkuZXZlbnREYXRhID0gZXZlbnREYXRhO1xuICAgIH0gLy8gRklYTUVcblxuXG4gICAgdHJhbnNmb3JtR3JvdXAuYWRkKHRleHRFbCk7XG4gICAgdGV4dEVsLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIGdyb3VwLmFkZCh0ZXh0RWwpO1xuICAgIHRleHRFbC5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZW5kVGV4dExheW91dChyb3RhdGlvbiwgdGV4dFBvc2l0aW9uLCB0ZXh0Um90YXRlLCBleHRlbnQpIHtcbiAgdmFyIHJvdGF0aW9uRGlmZiA9IHJlbVJhZGlhbih0ZXh0Um90YXRlIC0gcm90YXRpb24pO1xuICB2YXIgdGV4dEFsaWduO1xuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ247XG4gIHZhciBpbnZlcnNlID0gZXh0ZW50WzBdID4gZXh0ZW50WzFdO1xuICB2YXIgb25MZWZ0ID0gdGV4dFBvc2l0aW9uID09PSAnc3RhcnQnICYmICFpbnZlcnNlIHx8IHRleHRQb3NpdGlvbiAhPT0gJ3N0YXJ0JyAmJiBpbnZlcnNlO1xuXG4gIGlmIChpc1JhZGlhbkFyb3VuZFplcm8ocm90YXRpb25EaWZmIC0gUEkgLyAyKSkge1xuICAgIHRleHRWZXJ0aWNhbEFsaWduID0gb25MZWZ0ID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgfSBlbHNlIGlmIChpc1JhZGlhbkFyb3VuZFplcm8ocm90YXRpb25EaWZmIC0gUEkgKiAxLjUpKSB7XG4gICAgdGV4dFZlcnRpY2FsQWxpZ24gPSBvbkxlZnQgPyAndG9wJyA6ICdib3R0b20nO1xuICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICB9IGVsc2Uge1xuICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG5cbiAgICBpZiAocm90YXRpb25EaWZmIDwgUEkgKiAxLjUgJiYgcm90YXRpb25EaWZmID4gUEkgLyAyKSB7XG4gICAgICB0ZXh0QWxpZ24gPSBvbkxlZnQgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0QWxpZ24gPSBvbkxlZnQgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcm90YXRpb246IHJvdGF0aW9uRGlmZixcbiAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICB0ZXh0VmVydGljYWxBbGlnbjogdGV4dFZlcnRpY2FsQWxpZ25cbiAgfTtcbn1cblxuZnVuY3Rpb24gZml4TWluTWF4TGFiZWxTaG93KGF4aXNNb2RlbCwgbGFiZWxFbHMsIHRpY2tFbHMpIHtcbiAgaWYgKHNob3VsZFNob3dBbGxMYWJlbHMoYXhpc01vZGVsLmF4aXMpKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIElmIG1pbiBvciBtYXggYXJlIHVzZXIgc2V0LCB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIElmIHRoZSB0aWNrIG9uIG1pbihtYXgpIGFyZSBvdmVybGFwIG9uIHRoZWlyIG5laWdoYm91ciB0aWNrXG4gIC8vIElmIHRoZXkgYXJlIG92ZXJsYXBwZWQsIHdlIG5lZWQgdG8gaGlkZSB0aGUgbWluKG1heCkgdGljayBsYWJlbFxuXG5cbiAgdmFyIHNob3dNaW5MYWJlbCA9IGF4aXNNb2RlbC5nZXQoWydheGlzTGFiZWwnLCAnc2hvd01pbkxhYmVsJ10pO1xuICB2YXIgc2hvd01heExhYmVsID0gYXhpc01vZGVsLmdldChbJ2F4aXNMYWJlbCcsICdzaG93TWF4TGFiZWwnXSk7IC8vIEZJWE1FXG4gIC8vIEhhdmUgbm90IGNvbnNpZGVyIG9uQmFuZCB5ZXQsIHdoZXJlIHRpY2sgZWxzIGlzIG1vcmUgdGhhbiBsYWJlbCBlbHMuXG5cbiAgbGFiZWxFbHMgPSBsYWJlbEVscyB8fCBbXTtcbiAgdGlja0VscyA9IHRpY2tFbHMgfHwgW107XG4gIHZhciBmaXJzdExhYmVsID0gbGFiZWxFbHNbMF07XG4gIHZhciBuZXh0TGFiZWwgPSBsYWJlbEVsc1sxXTtcbiAgdmFyIGxhc3RMYWJlbCA9IGxhYmVsRWxzW2xhYmVsRWxzLmxlbmd0aCAtIDFdO1xuICB2YXIgcHJldkxhYmVsID0gbGFiZWxFbHNbbGFiZWxFbHMubGVuZ3RoIC0gMl07XG4gIHZhciBmaXJzdFRpY2sgPSB0aWNrRWxzWzBdO1xuICB2YXIgbmV4dFRpY2sgPSB0aWNrRWxzWzFdO1xuICB2YXIgbGFzdFRpY2sgPSB0aWNrRWxzW3RpY2tFbHMubGVuZ3RoIC0gMV07XG4gIHZhciBwcmV2VGljayA9IHRpY2tFbHNbdGlja0Vscy5sZW5ndGggLSAyXTtcblxuICBpZiAoc2hvd01pbkxhYmVsID09PSBmYWxzZSkge1xuICAgIGlnbm9yZUVsKGZpcnN0TGFiZWwpO1xuICAgIGlnbm9yZUVsKGZpcnN0VGljayk7XG4gIH0gZWxzZSBpZiAoaXNUd29MYWJlbE92ZXJsYXBwZWQoZmlyc3RMYWJlbCwgbmV4dExhYmVsKSkge1xuICAgIGlmIChzaG93TWluTGFiZWwpIHtcbiAgICAgIGlnbm9yZUVsKG5leHRMYWJlbCk7XG4gICAgICBpZ25vcmVFbChuZXh0VGljayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlnbm9yZUVsKGZpcnN0TGFiZWwpO1xuICAgICAgaWdub3JlRWwoZmlyc3RUaWNrKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2hvd01heExhYmVsID09PSBmYWxzZSkge1xuICAgIGlnbm9yZUVsKGxhc3RMYWJlbCk7XG4gICAgaWdub3JlRWwobGFzdFRpY2spO1xuICB9IGVsc2UgaWYgKGlzVHdvTGFiZWxPdmVybGFwcGVkKHByZXZMYWJlbCwgbGFzdExhYmVsKSkge1xuICAgIGlmIChzaG93TWF4TGFiZWwpIHtcbiAgICAgIGlnbm9yZUVsKHByZXZMYWJlbCk7XG4gICAgICBpZ25vcmVFbChwcmV2VGljayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlnbm9yZUVsKGxhc3RMYWJlbCk7XG4gICAgICBpZ25vcmVFbChsYXN0VGljayk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlnbm9yZUVsKGVsKSB7XG4gIGVsICYmIChlbC5pZ25vcmUgPSB0cnVlKTtcbn1cblxuZnVuY3Rpb24gaXNUd29MYWJlbE92ZXJsYXBwZWQoY3VycmVudCwgbmV4dCkge1xuICAvLyBjdXJyZW50IGFuZCBuZXh0IGhhcyB0aGUgc2FtZSByb3RhdGlvbi5cbiAgdmFyIGZpcnN0UmVjdCA9IGN1cnJlbnQgJiYgY3VycmVudC5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xuICB2YXIgbmV4dFJlY3QgPSBuZXh0ICYmIG5leHQuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcblxuICBpZiAoIWZpcnN0UmVjdCB8fCAhbmV4dFJlY3QpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gV2hlbiBjaGVja2luZyBpbnRlcnNlY3Qgb2YgdHdvIHJvdGF0ZWQgbGFiZWxzLCB3ZSB1c2UgbVJvdGF0aW9uQmFja1xuICAvLyB0byBhdm9pZCB0aGF0IGJvdW5kaW5nUmVjdCBpcyBlbmxhcmdlIHdoZW4gdXNpbmcgYGJvdW5kaW5nUmVjdC5hcHBseVRyYW5zZm9ybWAuXG5cblxuICB2YXIgbVJvdGF0aW9uQmFjayA9IG1hdHJpeFV0aWwuaWRlbnRpdHkoW10pO1xuICBtYXRyaXhVdGlsLnJvdGF0ZShtUm90YXRpb25CYWNrLCBtUm90YXRpb25CYWNrLCAtY3VycmVudC5yb3RhdGlvbik7XG4gIGZpcnN0UmVjdC5hcHBseVRyYW5zZm9ybShtYXRyaXhVdGlsLm11bChbXSwgbVJvdGF0aW9uQmFjaywgY3VycmVudC5nZXRMb2NhbFRyYW5zZm9ybSgpKSk7XG4gIG5leHRSZWN0LmFwcGx5VHJhbnNmb3JtKG1hdHJpeFV0aWwubXVsKFtdLCBtUm90YXRpb25CYWNrLCBuZXh0LmdldExvY2FsVHJhbnNmb3JtKCkpKTtcbiAgcmV0dXJuIGZpcnN0UmVjdC5pbnRlcnNlY3QobmV4dFJlY3QpO1xufVxuXG5mdW5jdGlvbiBpc05hbWVMb2NhdGlvbkNlbnRlcihuYW1lTG9jYXRpb24pIHtcbiAgcmV0dXJuIG5hbWVMb2NhdGlvbiA9PT0gJ21pZGRsZScgfHwgbmFtZUxvY2F0aW9uID09PSAnY2VudGVyJztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGlja3ModGlja3NDb29yZHMsIHRpY2tUcmFuc2Zvcm0sIHRpY2tFbmRDb29yZCwgdGlja0xpbmVTdHlsZSwgYW5pZFByZWZpeCkge1xuICB2YXIgdGlja0VscyA9IFtdO1xuICB2YXIgcHQxID0gW107XG4gIHZhciBwdDIgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzQ29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRpY2tDb29yZCA9IHRpY2tzQ29vcmRzW2ldLmNvb3JkO1xuICAgIHB0MVswXSA9IHRpY2tDb29yZDtcbiAgICBwdDFbMV0gPSAwO1xuICAgIHB0MlswXSA9IHRpY2tDb29yZDtcbiAgICBwdDJbMV0gPSB0aWNrRW5kQ29vcmQ7XG5cbiAgICBpZiAodGlja1RyYW5zZm9ybSkge1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShwdDEsIHB0MSwgdGlja1RyYW5zZm9ybSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHB0MiwgcHQyLCB0aWNrVHJhbnNmb3JtKTtcbiAgICB9IC8vIFRpY2sgbGluZSwgTm90IHVzZSBncm91cCB0cmFuc2Zvcm0gdG8gaGF2ZSBiZXR0ZXIgbGluZSBkcmF3XG5cblxuICAgIHZhciB0aWNrRWwgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcbiAgICAgIHN1YlBpeGVsT3B0aW1pemU6IHRydWUsXG4gICAgICBzaGFwZToge1xuICAgICAgICB4MTogcHQxWzBdLFxuICAgICAgICB5MTogcHQxWzFdLFxuICAgICAgICB4MjogcHQyWzBdLFxuICAgICAgICB5MjogcHQyWzFdXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHRpY2tMaW5lU3R5bGUsXG4gICAgICB6MjogMixcbiAgICAgIGF1dG9CYXRjaDogdHJ1ZSxcbiAgICAgIHNpbGVudDogdHJ1ZVxuICAgIH0pO1xuICAgIHRpY2tFbC5hbmlkID0gYW5pZFByZWZpeCArICdfJyArIHRpY2tzQ29vcmRzW2ldLnRpY2tWYWx1ZTtcbiAgICB0aWNrRWxzLnB1c2godGlja0VsKTtcbiAgfVxuXG4gIHJldHVybiB0aWNrRWxzO1xufVxuXG5mdW5jdGlvbiBidWlsZEF4aXNNYWpvclRpY2tzKGdyb3VwLCB0cmFuc2Zvcm1Hcm91cCwgYXhpc01vZGVsLCBvcHQpIHtcbiAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgdmFyIHRpY2tNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc1RpY2snKTtcbiAgdmFyIHNob3duID0gdGlja01vZGVsLmdldCgnc2hvdycpO1xuXG4gIGlmIChzaG93biA9PT0gJ2F1dG8nICYmIG9wdC5oYW5kbGVBdXRvU2hvd24pIHtcbiAgICBzaG93biA9IG9wdC5oYW5kbGVBdXRvU2hvd24oJ2F4aXNUaWNrJyk7XG4gIH1cblxuICBpZiAoIXNob3duIHx8IGF4aXMuc2NhbGUuaXNCbGFuaygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxpbmVTdHlsZU1vZGVsID0gdGlja01vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgdmFyIHRpY2tFbmRDb29yZCA9IG9wdC50aWNrRGlyZWN0aW9uICogdGlja01vZGVsLmdldCgnbGVuZ3RoJyk7XG4gIHZhciB0aWNrc0Nvb3JkcyA9IGF4aXMuZ2V0VGlja3NDb29yZHMoKTtcbiAgdmFyIHRpY2tzRWxzID0gY3JlYXRlVGlja3ModGlja3NDb29yZHMsIHRyYW5zZm9ybUdyb3VwLnRyYW5zZm9ybSwgdGlja0VuZENvb3JkLCBkZWZhdWx0cyhsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKSwge1xuICAgIHN0cm9rZTogYXhpc01vZGVsLmdldChbJ2F4aXNMaW5lJywgJ2xpbmVTdHlsZScsICdjb2xvciddKVxuICB9KSwgJ3RpY2tzJyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc0Vscy5sZW5ndGg7IGkrKykge1xuICAgIGdyb3VwLmFkZCh0aWNrc0Vsc1tpXSk7XG4gIH1cblxuICByZXR1cm4gdGlja3NFbHM7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQXhpc01pbm9yVGlja3MoZ3JvdXAsIHRyYW5zZm9ybUdyb3VwLCBheGlzTW9kZWwsIHRpY2tEaXJlY3Rpb24pIHtcbiAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgdmFyIG1pbm9yVGlja01vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdtaW5vclRpY2snKTtcblxuICBpZiAoIW1pbm9yVGlja01vZGVsLmdldCgnc2hvdycpIHx8IGF4aXMuc2NhbGUuaXNCbGFuaygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1pbm9yVGlja3NDb29yZHMgPSBheGlzLmdldE1pbm9yVGlja3NDb29yZHMoKTtcblxuICBpZiAoIW1pbm9yVGlja3NDb29yZHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxpbmVTdHlsZU1vZGVsID0gbWlub3JUaWNrTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICB2YXIgdGlja0VuZENvb3JkID0gdGlja0RpcmVjdGlvbiAqIG1pbm9yVGlja01vZGVsLmdldCgnbGVuZ3RoJyk7XG4gIHZhciBtaW5vclRpY2tMaW5lU3R5bGUgPSBkZWZhdWx0cyhsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKSwgZGVmYXVsdHMoYXhpc01vZGVsLmdldE1vZGVsKCdheGlzVGljaycpLmdldExpbmVTdHlsZSgpLCB7XG4gICAgc3Ryb2tlOiBheGlzTW9kZWwuZ2V0KFsnYXhpc0xpbmUnLCAnbGluZVN0eWxlJywgJ2NvbG9yJ10pXG4gIH0pKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbm9yVGlja3NDb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWlub3JUaWNrc0VscyA9IGNyZWF0ZVRpY2tzKG1pbm9yVGlja3NDb29yZHNbaV0sIHRyYW5zZm9ybUdyb3VwLnRyYW5zZm9ybSwgdGlja0VuZENvb3JkLCBtaW5vclRpY2tMaW5lU3R5bGUsICdtaW5vcnRpY2tzXycgKyBpKTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbWlub3JUaWNrc0Vscy5sZW5ndGg7IGsrKykge1xuICAgICAgZ3JvdXAuYWRkKG1pbm9yVGlja3NFbHNba10pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEF4aXNMYWJlbChncm91cCwgdHJhbnNmb3JtR3JvdXAsIGF4aXNNb2RlbCwgb3B0KSB7XG4gIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gIHZhciBzaG93ID0gcmV0cmlldmUob3B0LmF4aXNMYWJlbFNob3csIGF4aXNNb2RlbC5nZXQoWydheGlzTGFiZWwnLCAnc2hvdyddKSk7XG5cbiAgaWYgKCFzaG93IHx8IGF4aXMuc2NhbGUuaXNCbGFuaygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxhYmVsTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNMYWJlbCcpO1xuICB2YXIgbGFiZWxNYXJnaW4gPSBsYWJlbE1vZGVsLmdldCgnbWFyZ2luJyk7XG4gIHZhciBsYWJlbHMgPSBheGlzLmdldFZpZXdMYWJlbHMoKTsgLy8gU3BlY2lhbCBsYWJlbCByb3RhdGUuXG5cbiAgdmFyIGxhYmVsUm90YXRpb24gPSAocmV0cmlldmUob3B0LmxhYmVsUm90YXRlLCBsYWJlbE1vZGVsLmdldCgncm90YXRlJykpIHx8IDApICogUEkgLyAxODA7XG4gIHZhciBsYWJlbExheW91dCA9IEF4aXNCdWlsZGVyLmlubmVyVGV4dExheW91dChvcHQucm90YXRpb24sIGxhYmVsUm90YXRpb24sIG9wdC5sYWJlbERpcmVjdGlvbik7XG4gIHZhciByYXdDYXRlZ29yeURhdGEgPSBheGlzTW9kZWwuZ2V0Q2F0ZWdvcmllcyAmJiBheGlzTW9kZWwuZ2V0Q2F0ZWdvcmllcyh0cnVlKTtcbiAgdmFyIGxhYmVsRWxzID0gW107XG4gIHZhciBzaWxlbnQgPSBBeGlzQnVpbGRlci5pc0xhYmVsU2lsZW50KGF4aXNNb2RlbCk7XG4gIHZhciB0cmlnZ2VyRXZlbnQgPSBheGlzTW9kZWwuZ2V0KCd0cmlnZ2VyRXZlbnQnKTtcbiAgZWFjaChsYWJlbHMsIGZ1bmN0aW9uIChsYWJlbEl0ZW0sIGluZGV4KSB7XG4gICAgdmFyIHRpY2tWYWx1ZSA9IGF4aXMuc2NhbGUudHlwZSA9PT0gJ29yZGluYWwnID8gYXhpcy5zY2FsZS5nZXRSYXdPcmRpbmFsTnVtYmVyKGxhYmVsSXRlbS50aWNrVmFsdWUpIDogbGFiZWxJdGVtLnRpY2tWYWx1ZTtcbiAgICB2YXIgZm9ybWF0dGVkTGFiZWwgPSBsYWJlbEl0ZW0uZm9ybWF0dGVkTGFiZWw7XG4gICAgdmFyIHJhd0xhYmVsID0gbGFiZWxJdGVtLnJhd0xhYmVsO1xuICAgIHZhciBpdGVtTGFiZWxNb2RlbCA9IGxhYmVsTW9kZWw7XG5cbiAgICBpZiAocmF3Q2F0ZWdvcnlEYXRhICYmIHJhd0NhdGVnb3J5RGF0YVt0aWNrVmFsdWVdKSB7XG4gICAgICB2YXIgcmF3Q2F0ZWdvcnlJdGVtID0gcmF3Q2F0ZWdvcnlEYXRhW3RpY2tWYWx1ZV07XG5cbiAgICAgIGlmIChpc09iamVjdChyYXdDYXRlZ29yeUl0ZW0pICYmIHJhd0NhdGVnb3J5SXRlbS50ZXh0U3R5bGUpIHtcbiAgICAgICAgaXRlbUxhYmVsTW9kZWwgPSBuZXcgTW9kZWwocmF3Q2F0ZWdvcnlJdGVtLnRleHRTdHlsZSwgbGFiZWxNb2RlbCwgYXhpc01vZGVsLmVjTW9kZWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0ZXh0Q29sb3IgPSBpdGVtTGFiZWxNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBheGlzTW9kZWwuZ2V0KFsnYXhpc0xpbmUnLCAnbGluZVN0eWxlJywgJ2NvbG9yJ10pO1xuICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLmRhdGFUb0Nvb3JkKHRpY2tWYWx1ZSk7XG4gICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgeDogdGlja0Nvb3JkLFxuICAgICAgeTogb3B0LmxhYmVsT2Zmc2V0ICsgb3B0LmxhYmVsRGlyZWN0aW9uICogbGFiZWxNYXJnaW4sXG4gICAgICByb3RhdGlvbjogbGFiZWxMYXlvdXQucm90YXRpb24sXG4gICAgICBzaWxlbnQ6IHNpbGVudCxcbiAgICAgIHoyOiAxMCxcbiAgICAgIHN0eWxlOiBjcmVhdGVUZXh0U3R5bGUoaXRlbUxhYmVsTW9kZWwsIHtcbiAgICAgICAgdGV4dDogZm9ybWF0dGVkTGFiZWwsXG4gICAgICAgIGFsaWduOiBpdGVtTGFiZWxNb2RlbC5nZXRTaGFsbG93KCdhbGlnbicsIHRydWUpIHx8IGxhYmVsTGF5b3V0LnRleHRBbGlnbixcbiAgICAgICAgdmVydGljYWxBbGlnbjogaXRlbUxhYmVsTW9kZWwuZ2V0U2hhbGxvdygndmVydGljYWxBbGlnbicsIHRydWUpIHx8IGl0ZW1MYWJlbE1vZGVsLmdldFNoYWxsb3coJ2Jhc2VsaW5lJywgdHJ1ZSkgfHwgbGFiZWxMYXlvdXQudGV4dFZlcnRpY2FsQWxpZ24sXG4gICAgICAgIGZpbGw6IHR5cGVvZiB0ZXh0Q29sb3IgPT09ICdmdW5jdGlvbicgPyB0ZXh0Q29sb3IoIC8vICgxKSBJbiBjYXRlZ29yeSBheGlzIHdpdGggZGF0YSB6b29tLCB0aWNrIGlzIG5vdCB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gaW5kZXggb2YgYXhpcy5kYXRhLiBTbyB0aWNrIHNob3VsZCBub3QgYmUgZXhwb3NlZCB0byB1c2VyXG4gICAgICAgIC8vIGluIGNhdGVnb3J5IGF4aXMuXG4gICAgICAgIC8vICgyKSBDb21wYXRpYmxlIHdpdGggcHJldmlvdXMgdmVyc2lvbiwgd2hpY2ggYWx3YXlzIHVzZSBmb3JtYXR0ZWQgbGFiZWwgYXNcbiAgICAgICAgLy8gaW5wdXQuIEJ1dCBpbiBpbnRlcnZhbCBzY2FsZSB0aGUgZm9ybWF0dGVkIGxhYmVsIGlzIGxpa2UgJzIyMyw0NDUnLCB3aGljaFxuICAgICAgICAvLyBtYWtlZCB1c2VyIHJlcGFsY2UgJywnLiBTbyB3ZSBtb2RpZnkgaXQgdG8gcmV0dXJuIG9yaWdpbmFsIHZhbCBidXQgcmVtYWluXG4gICAgICAgIC8vIGl0IGFzICdzdHJpbmcnIHRvIGF2b2lkIGVycm9yIGluIHJlcGxhY2luZy5cbiAgICAgICAgYXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gcmF3TGFiZWwgOiBheGlzLnR5cGUgPT09ICd2YWx1ZScgPyB0aWNrVmFsdWUgKyAnJyA6IHRpY2tWYWx1ZSwgaW5kZXgpIDogdGV4dENvbG9yXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHRleHRFbC5hbmlkID0gJ2xhYmVsXycgKyB0aWNrVmFsdWU7IC8vIFBhY2sgZGF0YSBmb3IgbW91c2UgZXZlbnRcblxuICAgIGlmICh0cmlnZ2VyRXZlbnQpIHtcbiAgICAgIHZhciBldmVudERhdGEgPSBBeGlzQnVpbGRlci5tYWtlQXhpc0V2ZW50RGF0YUJhc2UoYXhpc01vZGVsKTtcbiAgICAgIGV2ZW50RGF0YS50YXJnZXRUeXBlID0gJ2F4aXNMYWJlbCc7XG4gICAgICBldmVudERhdGEudmFsdWUgPSByYXdMYWJlbDtcbiAgICAgIGdldEVDRGF0YSh0ZXh0RWwpLmV2ZW50RGF0YSA9IGV2ZW50RGF0YTtcbiAgICB9IC8vIEZJWE1FXG5cblxuICAgIHRyYW5zZm9ybUdyb3VwLmFkZCh0ZXh0RWwpO1xuICAgIHRleHRFbC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICBsYWJlbEVscy5wdXNoKHRleHRFbCk7XG4gICAgZ3JvdXAuYWRkKHRleHRFbCk7XG4gICAgdGV4dEVsLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICB9KTtcbiAgcmV0dXJuIGxhYmVsRWxzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBBeGlzQnVpbGRlcjsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBheGlzUG9pbnRlck1vZGVsSGVscGVyIGZyb20gJy4uL2F4aXNQb2ludGVyL21vZGVsSGVscGVyJztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50JztcbnZhciBheGlzUG9pbnRlckNsYXp6ID0ge307XG4vKipcbiAqIEJhc2UgY2xhc3Mgb2YgQXhpc1ZpZXcuXG4gKi9cblxudmFyIEF4aXNWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEF4aXNWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEF4aXNWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IEF4aXNWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBBeGlzVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgLy8gRklYTUVcbiAgICAvLyBUaGlzIHByb2Nlc3Mgc2hvdWxkIHByb2Zvcm1lZCBhZnRlciBjb29yZGluYXRlIHN5c3RlbXMgdXBkYXRlZFxuICAgIC8vIChheGlzIHNjYWxlIHVwZGF0ZWQpLCBhbmQgc2hvdWxkIGJlIHBlcmZvcm1lZCBlYWNoIHRpbWUgdXBkYXRlLlxuICAgIC8vIFNvIHB1dCBpdCBoZXJlIHRlbXBvcmFyaWx5LCBhbHRob3VnaCBpdCBpcyBub3QgYXBwcm9wcmlhdGUgdG9cbiAgICAvLyBwdXQgYSBtb2RlbC13cml0aW5nIHByb2NlZHVyZSBpbiBgdmlld2AuXG4gICAgdGhpcy5heGlzUG9pbnRlckNsYXNzICYmIGF4aXNQb2ludGVyTW9kZWxIZWxwZXIuZml4VmFsdWUoYXhpc01vZGVsKTtcblxuICAgIF9zdXBlci5wcm90b3R5cGUucmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLl9kb1VwZGF0ZUF4aXNQb2ludGVyQ2xhc3MoYXhpc01vZGVsLCBhcGksIHRydWUpO1xuICB9O1xuICAvKipcbiAgICogQWN0aW9uIGhhbmRsZXIuXG4gICAqL1xuXG5cbiAgQXhpc1ZpZXcucHJvdG90eXBlLnVwZGF0ZUF4aXNQb2ludGVyID0gZnVuY3Rpb24gKGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdGhpcy5fZG9VcGRhdGVBeGlzUG9pbnRlckNsYXNzKGF4aXNNb2RlbCwgYXBpLCBmYWxzZSk7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBBeGlzVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBheGlzUG9pbnRlciA9IHRoaXMuX2F4aXNQb2ludGVyO1xuICAgIGF4aXNQb2ludGVyICYmIGF4aXNQb2ludGVyLnJlbW92ZShhcGkpO1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgQXhpc1ZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5fZGlzcG9zZUF4aXNQb2ludGVyKGFwaSk7XG5cbiAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICBBeGlzVmlldy5wcm90b3R5cGUuX2RvVXBkYXRlQXhpc1BvaW50ZXJDbGFzcyA9IGZ1bmN0aW9uIChheGlzTW9kZWwsIGFwaSwgZm9yY2VSZW5kZXIpIHtcbiAgICB2YXIgQ2xhenogPSBBeGlzVmlldy5nZXRBeGlzUG9pbnRlckNsYXNzKHRoaXMuYXhpc1BvaW50ZXJDbGFzcyk7XG5cbiAgICBpZiAoIUNsYXp6KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF4aXNQb2ludGVyTW9kZWwgPSBheGlzUG9pbnRlck1vZGVsSGVscGVyLmdldEF4aXNQb2ludGVyTW9kZWwoYXhpc01vZGVsKTtcbiAgICBheGlzUG9pbnRlck1vZGVsID8gKHRoaXMuX2F4aXNQb2ludGVyIHx8ICh0aGlzLl9heGlzUG9pbnRlciA9IG5ldyBDbGF6eigpKSkucmVuZGVyKGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpLCBmb3JjZVJlbmRlcikgOiB0aGlzLl9kaXNwb3NlQXhpc1BvaW50ZXIoYXBpKTtcbiAgfTtcblxuICBBeGlzVmlldy5wcm90b3R5cGUuX2Rpc3Bvc2VBeGlzUG9pbnRlciA9IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB0aGlzLl9heGlzUG9pbnRlciAmJiB0aGlzLl9heGlzUG9pbnRlci5kaXNwb3NlKGFwaSk7XG4gICAgdGhpcy5fYXhpc1BvaW50ZXIgPSBudWxsO1xuICB9O1xuXG4gIEF4aXNWaWV3LnJlZ2lzdGVyQXhpc1BvaW50ZXJDbGFzcyA9IGZ1bmN0aW9uICh0eXBlLCBjbGF6eikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoYXhpc1BvaW50ZXJDbGF6elt0eXBlXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F4aXNQb2ludGVyICcgKyB0eXBlICsgJyBleGlzdHMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBheGlzUG9pbnRlckNsYXp6W3R5cGVdID0gY2xheno7XG4gIH07XG5cbiAgO1xuXG4gIEF4aXNWaWV3LmdldEF4aXNQb2ludGVyQ2xhc3MgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiB0eXBlICYmIGF4aXNQb2ludGVyQ2xhenpbdHlwZV07XG4gIH07XG5cbiAgO1xuICBBeGlzVmlldy50eXBlID0gJ2F4aXMnO1xuICByZXR1cm4gQXhpc1ZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuXG5leHBvcnQgZGVmYXVsdCBBeGlzVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCBBeGlzQnVpbGRlciBmcm9tICcuL0F4aXNCdWlsZGVyJztcbmltcG9ydCBBeGlzVmlldyBmcm9tICcuL0F4aXNWaWV3JztcbmltcG9ydCAqIGFzIGNhcnRlc2lhbkF4aXNIZWxwZXIgZnJvbSAnLi4vLi4vY29vcmQvY2FydGVzaWFuL2NhcnRlc2lhbkF4aXNIZWxwZXInO1xuaW1wb3J0IHsgcmVjdENvb3JkQXhpc0J1aWxkU3BsaXRBcmVhLCByZWN0Q29vcmRBeGlzSGFuZGxlUmVtb3ZlIH0gZnJvbSAnLi9heGlzU3BsaXRIZWxwZXInO1xudmFyIGF4aXNCdWlsZGVyQXR0cnMgPSBbJ2F4aXNMaW5lJywgJ2F4aXNUaWNrTGFiZWwnLCAnYXhpc05hbWUnXTtcbnZhciBzZWxmQnVpbGRlckF0dHJzID0gWydzcGxpdEFyZWEnLCAnc3BsaXRMaW5lJywgJ21pbm9yU3BsaXRMaW5lJ107XG5cbnZhciBDYXJ0ZXNpYW5BeGlzVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDYXJ0ZXNpYW5BeGlzVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBDYXJ0ZXNpYW5BeGlzVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBDYXJ0ZXNpYW5BeGlzVmlldy50eXBlO1xuICAgIF90aGlzLmF4aXNQb2ludGVyQ2xhc3MgPSAnQ2FydGVzaWFuQXhpc1BvaW50ZXInO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgQ2FydGVzaWFuQXhpc1ZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgdmFyIG9sZEF4aXNHcm91cCA9IHRoaXMuX2F4aXNHcm91cDtcbiAgICB0aGlzLl9heGlzR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2F4aXNHcm91cCk7XG5cbiAgICBpZiAoIWF4aXNNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBncmlkTW9kZWwgPSBheGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpO1xuICAgIHZhciBsYXlvdXQgPSBjYXJ0ZXNpYW5BeGlzSGVscGVyLmxheW91dChncmlkTW9kZWwsIGF4aXNNb2RlbCk7XG4gICAgdmFyIGF4aXNCdWlsZGVyID0gbmV3IEF4aXNCdWlsZGVyKGF4aXNNb2RlbCwgenJVdGlsLmV4dGVuZCh7XG4gICAgICBoYW5kbGVBdXRvU2hvd246IGZ1bmN0aW9uIChlbGVtZW50VHlwZSkge1xuICAgICAgICB2YXIgY2FydGVzaWFucyA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldENhcnRlc2lhbnMoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhcnRlc2lhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgb3RoZXJBeGlzVHlwZSA9IGNhcnRlc2lhbnNbaV0uZ2V0T3RoZXJBeGlzKGF4aXNNb2RlbC5heGlzKS50eXBlO1xuXG4gICAgICAgICAgaWYgKG90aGVyQXhpc1R5cGUgPT09ICd2YWx1ZScgfHwgb3RoZXJBeGlzVHlwZSA9PT0gJ2xvZycpIHtcbiAgICAgICAgICAgIC8vIFN0aWxsIHNob3cgYXhpcyB0aWNrIG9yIGF4aXNMaW5lIGlmIG90aGVyIGF4aXMgaXMgdmFsdWUgLyBsb2dcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBOb3Qgc2hvdyBheGlzVGljayBvciBheGlzTGluZSBpZiBvdGhlciBheGlzIGlzIGNhdGVnb3J5IC8gdGltZVxuXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIGxheW91dCkpO1xuICAgIHpyVXRpbC5lYWNoKGF4aXNCdWlsZGVyQXR0cnMsIGF4aXNCdWlsZGVyLmFkZCwgYXhpc0J1aWxkZXIpO1xuXG4gICAgdGhpcy5fYXhpc0dyb3VwLmFkZChheGlzQnVpbGRlci5nZXRHcm91cCgpKTtcblxuICAgIHpyVXRpbC5lYWNoKHNlbGZCdWlsZGVyQXR0cnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAoYXhpc01vZGVsLmdldChbbmFtZSwgJ3Nob3cnXSkpIHtcbiAgICAgICAgYXhpc0VsZW1lbnRCdWlsZGVyc1tuYW1lXSh0aGlzLCB0aGlzLl9heGlzR3JvdXAsIGF4aXNNb2RlbCwgZ3JpZE1vZGVsKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICBncmFwaGljLmdyb3VwVHJhbnNpdGlvbihvbGRBeGlzR3JvdXAsIHRoaXMuX2F4aXNHcm91cCwgYXhpc01vZGVsKTtcblxuICAgIF9zdXBlci5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcywgYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICB9O1xuXG4gIENhcnRlc2lhbkF4aXNWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVjdENvb3JkQXhpc0hhbmRsZVJlbW92ZSh0aGlzKTtcbiAgfTtcblxuICBDYXJ0ZXNpYW5BeGlzVmlldy50eXBlID0gJ2NhcnRlc2lhbkF4aXMnO1xuICByZXR1cm4gQ2FydGVzaWFuQXhpc1ZpZXc7XG59KEF4aXNWaWV3KTtcblxudmFyIGF4aXNFbGVtZW50QnVpbGRlcnMgPSB7XG4gIHNwbGl0TGluZTogZnVuY3Rpb24gKGF4aXNWaWV3LCBheGlzR3JvdXAsIGF4aXNNb2RlbCwgZ3JpZE1vZGVsKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcblxuICAgIGlmIChheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzcGxpdExpbmVNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRMaW5lJyk7XG4gICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gc3BsaXRMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICAgIHZhciBsaW5lQ29sb3JzID0gbGluZVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuICAgIGxpbmVDb2xvcnMgPSB6clV0aWwuaXNBcnJheShsaW5lQ29sb3JzKSA/IGxpbmVDb2xvcnMgOiBbbGluZUNvbG9yc107XG4gICAgdmFyIGdyaWRSZWN0ID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpO1xuICAgIHZhciBpc0hvcml6b250YWwgPSBheGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIHZhciBsaW5lQ291bnQgPSAwO1xuICAgIHZhciB0aWNrc0Nvb3JkcyA9IGF4aXMuZ2V0VGlja3NDb29yZHMoe1xuICAgICAgdGlja01vZGVsOiBzcGxpdExpbmVNb2RlbFxuICAgIH0pO1xuICAgIHZhciBwMSA9IFtdO1xuICAgIHZhciBwMiA9IFtdO1xuICAgIHZhciBsaW5lU3R5bGUgPSBsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3NDb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLnRvR2xvYmFsQ29vcmQodGlja3NDb29yZHNbaV0uY29vcmQpO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHAxWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICBwMVsxXSA9IGdyaWRSZWN0Lnk7XG4gICAgICAgIHAyWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICBwMlsxXSA9IGdyaWRSZWN0LnkgKyBncmlkUmVjdC5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwMVswXSA9IGdyaWRSZWN0Lng7XG4gICAgICAgIHAxWzFdID0gdGlja0Nvb3JkO1xuICAgICAgICBwMlswXSA9IGdyaWRSZWN0LnggKyBncmlkUmVjdC53aWR0aDtcbiAgICAgICAgcDJbMV0gPSB0aWNrQ29vcmQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvckluZGV4ID0gbGluZUNvdW50KysgJSBsaW5lQ29sb3JzLmxlbmd0aDtcbiAgICAgIHZhciB0aWNrVmFsdWUgPSB0aWNrc0Nvb3Jkc1tpXS50aWNrVmFsdWU7XG4gICAgICBheGlzR3JvdXAuYWRkKG5ldyBncmFwaGljLkxpbmUoe1xuICAgICAgICBhbmlkOiB0aWNrVmFsdWUgIT0gbnVsbCA/ICdsaW5lXycgKyB0aWNrc0Nvb3Jkc1tpXS50aWNrVmFsdWUgOiBudWxsLFxuICAgICAgICBzdWJQaXhlbE9wdGltaXplOiB0cnVlLFxuICAgICAgICBhdXRvQmF0Y2g6IHRydWUsXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgeDE6IHAxWzBdLFxuICAgICAgICAgIHkxOiBwMVsxXSxcbiAgICAgICAgICB4MjogcDJbMF0sXG4gICAgICAgICAgeTI6IHAyWzFdXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgIHN0cm9rZTogbGluZUNvbG9yc1tjb2xvckluZGV4XVxuICAgICAgICB9LCBsaW5lU3R5bGUpLFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sXG4gIG1pbm9yU3BsaXRMaW5lOiBmdW5jdGlvbiAoYXhpc1ZpZXcsIGF4aXNHcm91cCwgYXhpc01vZGVsLCBncmlkTW9kZWwpIHtcbiAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgIHZhciBtaW5vclNwbGl0TGluZU1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdtaW5vclNwbGl0TGluZScpO1xuICAgIHZhciBsaW5lU3R5bGVNb2RlbCA9IG1pbm9yU3BsaXRMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICAgIHZhciBncmlkUmVjdCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFJlY3QoKTtcbiAgICB2YXIgaXNIb3Jpem9udGFsID0gYXhpcy5pc0hvcml6b250YWwoKTtcbiAgICB2YXIgbWlub3JUaWNrc0Nvb3JkcyA9IGF4aXMuZ2V0TWlub3JUaWNrc0Nvb3JkcygpO1xuXG4gICAgaWYgKCFtaW5vclRpY2tzQ29vcmRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwMSA9IFtdO1xuICAgIHZhciBwMiA9IFtdO1xuICAgIHZhciBsaW5lU3R5bGUgPSBsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWlub3JUaWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBtaW5vclRpY2tzQ29vcmRzW2ldLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLnRvR2xvYmFsQ29vcmQobWlub3JUaWNrc0Nvb3Jkc1tpXVtrXS5jb29yZCk7XG5cbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgIHAxWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICAgIHAxWzFdID0gZ3JpZFJlY3QueTtcbiAgICAgICAgICBwMlswXSA9IHRpY2tDb29yZDtcbiAgICAgICAgICBwMlsxXSA9IGdyaWRSZWN0LnkgKyBncmlkUmVjdC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcDFbMF0gPSBncmlkUmVjdC54O1xuICAgICAgICAgIHAxWzFdID0gdGlja0Nvb3JkO1xuICAgICAgICAgIHAyWzBdID0gZ3JpZFJlY3QueCArIGdyaWRSZWN0LndpZHRoO1xuICAgICAgICAgIHAyWzFdID0gdGlja0Nvb3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc0dyb3VwLmFkZChuZXcgZ3JhcGhpYy5MaW5lKHtcbiAgICAgICAgICBhbmlkOiAnbWlub3JfbGluZV8nICsgbWlub3JUaWNrc0Nvb3Jkc1tpXVtrXS50aWNrVmFsdWUsXG4gICAgICAgICAgc3ViUGl4ZWxPcHRpbWl6ZTogdHJ1ZSxcbiAgICAgICAgICBhdXRvQmF0Y2g6IHRydWUsXG4gICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHgxOiBwMVswXSxcbiAgICAgICAgICAgIHkxOiBwMVsxXSxcbiAgICAgICAgICAgIHgyOiBwMlswXSxcbiAgICAgICAgICAgIHkyOiBwMlsxXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3R5bGU6IGxpbmVTdHlsZSxcbiAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc3BsaXRBcmVhOiBmdW5jdGlvbiAoYXhpc1ZpZXcsIGF4aXNHcm91cCwgYXhpc01vZGVsLCBncmlkTW9kZWwpIHtcbiAgICByZWN0Q29vcmRBeGlzQnVpbGRTcGxpdEFyZWEoYXhpc1ZpZXcsIGF4aXNHcm91cCwgYXhpc01vZGVsLCBncmlkTW9kZWwpO1xuICB9XG59O1xuXG52YXIgQ2FydGVzaWFuWEF4aXNWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKENhcnRlc2lhblhBeGlzVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBDYXJ0ZXNpYW5YQXhpc1ZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gQ2FydGVzaWFuWEF4aXNWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgQ2FydGVzaWFuWEF4aXNWaWV3LnR5cGUgPSAneEF4aXMnO1xuICByZXR1cm4gQ2FydGVzaWFuWEF4aXNWaWV3O1xufShDYXJ0ZXNpYW5BeGlzVmlldyk7XG5cbmV4cG9ydCB7IENhcnRlc2lhblhBeGlzVmlldyB9O1xuXG52YXIgQ2FydGVzaWFuWUF4aXNWaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKENhcnRlc2lhbllBeGlzVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBDYXJ0ZXNpYW5ZQXhpc1ZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gQ2FydGVzaWFuWEF4aXNWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgQ2FydGVzaWFuWUF4aXNWaWV3LnR5cGUgPSAneUF4aXMnO1xuICByZXR1cm4gQ2FydGVzaWFuWUF4aXNWaWV3O1xufShDYXJ0ZXNpYW5BeGlzVmlldyk7XG5cbmV4cG9ydCB7IENhcnRlc2lhbllBeGlzVmlldyB9O1xuZXhwb3J0IGRlZmF1bHQgQ2FydGVzaWFuQXhpc1ZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgQXhpc0J1aWxkZXIgZnJvbSAnLi9BeGlzQnVpbGRlcic7XG5pbXBvcnQgQnJ1c2hDb250cm9sbGVyIGZyb20gJy4uL2hlbHBlci9CcnVzaENvbnRyb2xsZXInO1xuaW1wb3J0ICogYXMgYnJ1c2hIZWxwZXIgZnJvbSAnLi4vaGVscGVyL2JydXNoSGVscGVyJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50JztcbnZhciBlbGVtZW50TGlzdCA9IFsnYXhpc0xpbmUnLCAnYXhpc1RpY2tMYWJlbCcsICdheGlzTmFtZSddO1xuXG52YXIgUGFyYWxsZWxBeGlzVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQYXJhbGxlbEF4aXNWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFBhcmFsbGVsQXhpc1ZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gUGFyYWxsZWxBeGlzVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFBhcmFsbGVsQXhpc1ZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAodGhpcy5fYnJ1c2hDb250cm9sbGVyID0gbmV3IEJydXNoQ29udHJvbGxlcihhcGkuZ2V0WnIoKSkpLm9uKCdicnVzaCcsIHpyVXRpbC5iaW5kKHRoaXMuX29uQnJ1c2gsIHRoaXMpKTtcbiAgfTtcblxuICBQYXJhbGxlbEF4aXNWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICBpZiAoZnJvbUF4aXNBcmVhU2VsZWN0KGF4aXNNb2RlbCwgZWNNb2RlbCwgcGF5bG9hZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmF4aXNNb2RlbCA9IGF4aXNNb2RlbDtcbiAgICB0aGlzLmFwaSA9IGFwaTtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHZhciBvbGRBeGlzR3JvdXAgPSB0aGlzLl9heGlzR3JvdXA7XG4gICAgdGhpcy5fYXhpc0dyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLl9heGlzR3JvdXApO1xuXG4gICAgaWYgKCFheGlzTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29vcmRTeXNNb2RlbCA9IGdldENvb3JkU3lzTW9kZWwoYXhpc01vZGVsLCBlY01vZGVsKTtcbiAgICB2YXIgY29vcmRTeXMgPSBjb29yZFN5c01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGFyZWFTZWxlY3RTdHlsZSA9IGF4aXNNb2RlbC5nZXRBcmVhU2VsZWN0U3R5bGUoKTtcbiAgICB2YXIgYXJlYVdpZHRoID0gYXJlYVNlbGVjdFN0eWxlLndpZHRoO1xuICAgIHZhciBkaW0gPSBheGlzTW9kZWwuYXhpcy5kaW07XG4gICAgdmFyIGF4aXNMYXlvdXQgPSBjb29yZFN5cy5nZXRBeGlzTGF5b3V0KGRpbSk7XG4gICAgdmFyIGJ1aWxkZXJPcHQgPSB6clV0aWwuZXh0ZW5kKHtcbiAgICAgIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IGFyZWFXaWR0aFxuICAgIH0sIGF4aXNMYXlvdXQpO1xuICAgIHZhciBheGlzQnVpbGRlciA9IG5ldyBBeGlzQnVpbGRlcihheGlzTW9kZWwsIGJ1aWxkZXJPcHQpO1xuICAgIHpyVXRpbC5lYWNoKGVsZW1lbnRMaXN0LCBheGlzQnVpbGRlci5hZGQsIGF4aXNCdWlsZGVyKTtcblxuICAgIHRoaXMuX2F4aXNHcm91cC5hZGQoYXhpc0J1aWxkZXIuZ2V0R3JvdXAoKSk7XG5cbiAgICB0aGlzLl9yZWZyZXNoQnJ1c2hDb250cm9sbGVyKGJ1aWxkZXJPcHQsIGFyZWFTZWxlY3RTdHlsZSwgYXhpc01vZGVsLCBjb29yZFN5c01vZGVsLCBhcmVhV2lkdGgsIGFwaSk7XG5cbiAgICBncmFwaGljLmdyb3VwVHJhbnNpdGlvbihvbGRBeGlzR3JvdXAsIHRoaXMuX2F4aXNHcm91cCwgYXhpc01vZGVsKTtcbiAgfTsgLy8gLyoqXG4gIC8vICAqIEBvdmVycmlkZVxuICAvLyAgKi9cbiAgLy8gdXBkYXRlVmlzdWFsKGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gIC8vICAgICB0aGlzLl9icnVzaENvbnRyb2xsZXIgJiYgdGhpcy5fYnJ1c2hDb250cm9sbGVyXG4gIC8vICAgICAgICAgLnVwZGF0ZUNvdmVycyhnZXRDb3ZlckluZm9MaXN0KGF4aXNNb2RlbCkpO1xuICAvLyB9XG5cblxuICBQYXJhbGxlbEF4aXNWaWV3LnByb3RvdHlwZS5fcmVmcmVzaEJydXNoQ29udHJvbGxlciA9IGZ1bmN0aW9uIChidWlsZGVyT3B0LCBhcmVhU2VsZWN0U3R5bGUsIGF4aXNNb2RlbCwgY29vcmRTeXNNb2RlbCwgYXJlYVdpZHRoLCBhcGkpIHtcbiAgICAvLyBBZnRlciBmaWx0ZXJpbmcsIGF4aXMgbWF5IGNoYW5nZSwgc2VsZWN0IGFyZWEgbmVlZHMgdG8gYmUgdXBkYXRlLlxuICAgIHZhciBleHRlbnQgPSBheGlzTW9kZWwuYXhpcy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgZXh0ZW50TGVuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICAgIHZhciBleHRyYSA9IE1hdGgubWluKDMwLCBNYXRoLmFicyhleHRlbnRMZW4pICogMC4xKTsgLy8gQXJiaXRyYXJ5IHZhbHVlLlxuICAgIC8vIHdpZHRoL2hlaWdodCBtaWdodCBiZSBuZWdhdGl2ZSwgd2hpY2ggd2lsbCBiZVxuICAgIC8vIG5vcm1hbGl6ZWQgaW4gQm91bmRpbmdSZWN0LlxuXG4gICAgdmFyIHJlY3QgPSBncmFwaGljLkJvdW5kaW5nUmVjdC5jcmVhdGUoe1xuICAgICAgeDogZXh0ZW50WzBdLFxuICAgICAgeTogLWFyZWFXaWR0aCAvIDIsXG4gICAgICB3aWR0aDogZXh0ZW50TGVuLFxuICAgICAgaGVpZ2h0OiBhcmVhV2lkdGhcbiAgICB9KTtcbiAgICByZWN0LnggLT0gZXh0cmE7XG4gICAgcmVjdC53aWR0aCArPSAyICogZXh0cmE7XG5cbiAgICB0aGlzLl9icnVzaENvbnRyb2xsZXIubW91bnQoe1xuICAgICAgZW5hYmxlR2xvYmFsUGFuOiB0cnVlLFxuICAgICAgcm90YXRpb246IGJ1aWxkZXJPcHQucm90YXRpb24sXG4gICAgICB4OiBidWlsZGVyT3B0LnBvc2l0aW9uWzBdLFxuICAgICAgeTogYnVpbGRlck9wdC5wb3NpdGlvblsxXVxuICAgIH0pLnNldFBhbmVscyhbe1xuICAgICAgcGFuZWxJZDogJ3BsJyxcbiAgICAgIGNsaXBQYXRoOiBicnVzaEhlbHBlci5tYWtlUmVjdFBhbmVsQ2xpcFBhdGgocmVjdCksXG4gICAgICBpc1RhcmdldEJ5Q3Vyc29yOiBicnVzaEhlbHBlci5tYWtlUmVjdElzVGFyZ2V0QnlDdXJzb3IocmVjdCwgYXBpLCBjb29yZFN5c01vZGVsKSxcbiAgICAgIGdldExpbmVhckJydXNoT3RoZXJFeHRlbnQ6IGJydXNoSGVscGVyLm1ha2VMaW5lYXJCcnVzaE90aGVyRXh0ZW50KHJlY3QsIDApXG4gICAgfV0pLmVuYWJsZUJydXNoKHtcbiAgICAgIGJydXNoVHlwZTogJ2xpbmVYJyxcbiAgICAgIGJydXNoU3R5bGU6IGFyZWFTZWxlY3RTdHlsZSxcbiAgICAgIHJlbW92ZU9uQ2xpY2s6IHRydWVcbiAgICB9KS51cGRhdGVDb3ZlcnMoZ2V0Q292ZXJJbmZvTGlzdChheGlzTW9kZWwpKTtcbiAgfTtcblxuICBQYXJhbGxlbEF4aXNWaWV3LnByb3RvdHlwZS5fb25CcnVzaCA9IGZ1bmN0aW9uIChldmVudFBhcmFtKSB7XG4gICAgdmFyIGNvdmVySW5mb0xpc3QgPSBldmVudFBhcmFtLmFyZWFzOyAvLyBEbyBub3QgY2FjaGUgdGhlc2Ugb2JqZWN0LCBiZWNhdXNlIHRoZSBtZXkgYmUgY2hhbmdlZC5cblxuICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmF4aXNNb2RlbDtcbiAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgIHZhciBpbnRlcnZhbHMgPSB6clV0aWwubWFwKGNvdmVySW5mb0xpc3QsIGZ1bmN0aW9uIChjb3ZlckluZm8pIHtcbiAgICAgIHJldHVybiBbYXhpcy5jb29yZFRvRGF0YShjb3ZlckluZm8ucmFuZ2VbMF0sIHRydWUpLCBheGlzLmNvb3JkVG9EYXRhKGNvdmVySW5mby5yYW5nZVsxXSwgdHJ1ZSldO1xuICAgIH0pOyAvLyBJZiByZWFsdGltZSBpcyB0cnVlLCBhY3Rpb24gaXMgbm90IGRpc3BhdGNoZWQgb24gZHJhZyBlbmQsIGJlY2F1c2VcbiAgICAvLyB0aGUgZHJhZyBlbmQgZW1pdHMgdGhlIHNhbWUgcGFyYW1zIHdpdGggdGhlIGxhc3QgZHJhZyBtb3ZlIGV2ZW50LFxuICAgIC8vIGFuZCBtYXkgaGF2ZSBzb21lIGRlbGF5IHdoZW4gdXNpbmcgdG91Y2ggcGFkLlxuXG4gICAgaWYgKCFheGlzTW9kZWwub3B0aW9uLnJlYWx0aW1lID09PSBldmVudFBhcmFtLmlzRW5kIHx8IGV2ZW50UGFyYW0ucmVtb3ZlT25DbGljaykge1xuICAgICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgIHR5cGU6ICdheGlzQXJlYVNlbGVjdCcsXG4gICAgICAgIHBhcmFsbGVsQXhpc0lkOiBheGlzTW9kZWwuaWQsXG4gICAgICAgIGludGVydmFsczogaW50ZXJ2YWxzXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgUGFyYWxsZWxBeGlzVmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9icnVzaENvbnRyb2xsZXIuZGlzcG9zZSgpO1xuICB9O1xuXG4gIFBhcmFsbGVsQXhpc1ZpZXcudHlwZSA9ICdwYXJhbGxlbEF4aXMnO1xuICByZXR1cm4gUGFyYWxsZWxBeGlzVmlldztcbn0oQ29tcG9uZW50Vmlldyk7XG5cbmZ1bmN0aW9uIGZyb21BeGlzQXJlYVNlbGVjdChheGlzTW9kZWwsIGVjTW9kZWwsIHBheWxvYWQpIHtcbiAgcmV0dXJuIHBheWxvYWQgJiYgcGF5bG9hZC50eXBlID09PSAnYXhpc0FyZWFTZWxlY3QnICYmIGVjTW9kZWwuZmluZENvbXBvbmVudHMoe1xuICAgIG1haW5UeXBlOiAncGFyYWxsZWxBeGlzJyxcbiAgICBxdWVyeTogcGF5bG9hZFxuICB9KVswXSA9PT0gYXhpc01vZGVsO1xufVxuXG5mdW5jdGlvbiBnZXRDb3ZlckluZm9MaXN0KGF4aXNNb2RlbCkge1xuICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICByZXR1cm4genJVdGlsLm1hcChheGlzTW9kZWwuYWN0aXZlSW50ZXJ2YWxzLCBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnJ1c2hUeXBlOiAnbGluZVgnLFxuICAgICAgcGFuZWxJZDogJ3BsJyxcbiAgICAgIHJhbmdlOiBbYXhpcy5kYXRhVG9Db29yZChpbnRlcnZhbFswXSwgdHJ1ZSksIGF4aXMuZGF0YVRvQ29vcmQoaW50ZXJ2YWxbMV0sIHRydWUpXVxuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRDb29yZFN5c01vZGVsKGF4aXNNb2RlbCwgZWNNb2RlbCkge1xuICByZXR1cm4gZWNNb2RlbC5nZXRDb21wb25lbnQoJ3BhcmFsbGVsJywgYXhpc01vZGVsLmdldCgncGFyYWxsZWxJbmRleCcpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFyYWxsZWxBeGlzVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xuZXhwb3J0IGZ1bmN0aW9uIHJlY3RDb29yZEF4aXNCdWlsZFNwbGl0QXJlYShheGlzVmlldywgYXhpc0dyb3VwLCBheGlzTW9kZWwsIGdyaWRNb2RlbCkge1xuICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuXG4gIGlmIChheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBUT0RPOiBUWVBFXG5cblxuICB2YXIgc3BsaXRBcmVhTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ3NwbGl0QXJlYScpO1xuICB2YXIgYXJlYVN0eWxlTW9kZWwgPSBzcGxpdEFyZWFNb2RlbC5nZXRNb2RlbCgnYXJlYVN0eWxlJyk7XG4gIHZhciBhcmVhQ29sb3JzID0gYXJlYVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuICB2YXIgZ3JpZFJlY3QgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG4gIHZhciB0aWNrc0Nvb3JkcyA9IGF4aXMuZ2V0VGlja3NDb29yZHMoe1xuICAgIHRpY2tNb2RlbDogc3BsaXRBcmVhTW9kZWwsXG4gICAgY2xhbXA6IHRydWVcbiAgfSk7XG5cbiAgaWYgKCF0aWNrc0Nvb3Jkcy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gRm9yIE1ha2luZyBhcHByb3ByaWF0ZSBzcGxpdEFyZWEgYW5pbWF0aW9uLCB0aGUgY29sb3IgYW5kIGFuaWRcbiAgLy8gc2hvdWxkIGJlIGNvcnJlc3BvbmRpbmcgdG8gcHJldmlvdXMgb25lIGlmIHBvc3NpYmxlLlxuXG5cbiAgdmFyIGFyZWFDb2xvcnNMZW4gPSBhcmVhQ29sb3JzLmxlbmd0aDtcbiAgdmFyIGxhc3RTcGxpdEFyZWFDb2xvcnMgPSBpbm5lcihheGlzVmlldykuc3BsaXRBcmVhQ29sb3JzO1xuICB2YXIgbmV3U3BsaXRBcmVhQ29sb3JzID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgdmFyIGNvbG9ySW5kZXggPSAwO1xuXG4gIGlmIChsYXN0U3BsaXRBcmVhQ29sb3JzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNJbmRleCA9IGxhc3RTcGxpdEFyZWFDb2xvcnMuZ2V0KHRpY2tzQ29vcmRzW2ldLnRpY2tWYWx1ZSk7XG5cbiAgICAgIGlmIChjSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBjb2xvckluZGV4ID0gKGNJbmRleCArIChhcmVhQ29sb3JzTGVuIC0gMSkgKiBpKSAlIGFyZWFDb2xvcnNMZW47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwcmV2ID0gYXhpcy50b0dsb2JhbENvb3JkKHRpY2tzQ29vcmRzWzBdLmNvb3JkKTtcbiAgdmFyIGFyZWFTdHlsZSA9IGFyZWFTdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpO1xuICBhcmVhQ29sb3JzID0genJVdGlsLmlzQXJyYXkoYXJlYUNvbG9ycykgPyBhcmVhQ29sb3JzIDogW2FyZWFDb2xvcnNdO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgdGlja3NDb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGlja0Nvb3JkID0gYXhpcy50b0dsb2JhbENvb3JkKHRpY2tzQ29vcmRzW2ldLmNvb3JkKTtcbiAgICB2YXIgeCA9IHZvaWQgMDtcbiAgICB2YXIgeSA9IHZvaWQgMDtcbiAgICB2YXIgd2lkdGggPSB2b2lkIDA7XG4gICAgdmFyIGhlaWdodCA9IHZvaWQgMDtcblxuICAgIGlmIChheGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB4ID0gcHJldjtcbiAgICAgIHkgPSBncmlkUmVjdC55O1xuICAgICAgd2lkdGggPSB0aWNrQ29vcmQgLSB4O1xuICAgICAgaGVpZ2h0ID0gZ3JpZFJlY3QuaGVpZ2h0O1xuICAgICAgcHJldiA9IHggKyB3aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IGdyaWRSZWN0Lng7XG4gICAgICB5ID0gcHJldjtcbiAgICAgIHdpZHRoID0gZ3JpZFJlY3Qud2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aWNrQ29vcmQgLSB5O1xuICAgICAgcHJldiA9IHkgKyBoZWlnaHQ7XG4gICAgfVxuXG4gICAgdmFyIHRpY2tWYWx1ZSA9IHRpY2tzQ29vcmRzW2kgLSAxXS50aWNrVmFsdWU7XG4gICAgdGlja1ZhbHVlICE9IG51bGwgJiYgbmV3U3BsaXRBcmVhQ29sb3JzLnNldCh0aWNrVmFsdWUsIGNvbG9ySW5kZXgpO1xuICAgIGF4aXNHcm91cC5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICBhbmlkOiB0aWNrVmFsdWUgIT0gbnVsbCA/ICdhcmVhXycgKyB0aWNrVmFsdWUgOiBudWxsLFxuICAgICAgc2hhcGU6IHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfSxcbiAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICBmaWxsOiBhcmVhQ29sb3JzW2NvbG9ySW5kZXhdXG4gICAgICB9LCBhcmVhU3R5bGUpLFxuICAgICAgYXV0b0JhdGNoOiB0cnVlLFxuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSkpO1xuICAgIGNvbG9ySW5kZXggPSAoY29sb3JJbmRleCArIDEpICUgYXJlYUNvbG9yc0xlbjtcbiAgfVxuXG4gIGlubmVyKGF4aXNWaWV3KS5zcGxpdEFyZWFDb2xvcnMgPSBuZXdTcGxpdEFyZWFDb2xvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVjdENvb3JkQXhpc0hhbmRsZVJlbW92ZShheGlzVmlldykge1xuICBpbm5lcihheGlzVmlldykuc3BsaXRBcmVhQ29sb3JzID0gbnVsbDtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIGFjdGlvbkluZm8gPSB7XG4gIHR5cGU6ICdheGlzQXJlYVNlbGVjdCcsXG4gIGV2ZW50OiAnYXhpc0FyZWFTZWxlY3RlZCcgLy8gdXBkYXRlOiAndXBkYXRlVmlzdWFsJ1xuXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGxQYXJhbGxlbEFjdGlvbnMocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbihhY3Rpb25JbmZvLCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgICBtYWluVHlwZTogJ3BhcmFsbGVsQXhpcycsXG4gICAgICBxdWVyeTogcGF5bG9hZFxuICAgIH0sIGZ1bmN0aW9uIChwYXJhbGxlbEF4aXNNb2RlbCkge1xuICAgICAgcGFyYWxsZWxBeGlzTW9kZWwuYXhpcy5tb2RlbC5zZXRBY3RpdmVJbnRlcnZhbHMocGF5bG9hZC5pbnRlcnZhbHMpO1xuICAgIH0pO1xuICB9KTtcbiAgLyoqXG4gICAqIEBwYXlsb2FkXG4gICAqL1xuXG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbigncGFyYWxsZWxBeGlzRXhwYW5kJywgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6ICdwYXJhbGxlbCcsXG4gICAgICBxdWVyeTogcGF5bG9hZFxuICAgIH0sIGZ1bmN0aW9uIChwYXJhbGxlbE1vZGVsKSB7XG4gICAgICBwYXJhbGxlbE1vZGVsLnNldEF4aXNFeHBhbmQocGF5bG9hZCk7XG4gICAgfSk7XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvTW9kZWwnO1xuaW1wb3J0IHsgZWFjaCwgY3VycnksIGNsb25lLCBkZWZhdWx0cywgaXNBcnJheSwgaW5kZXhPZiB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7IC8vIEJ1aWxkIGF4aXNQb2ludGVyTW9kZWwsIG1lcmdpbiB0b29sdGlwLmF4aXNQb2ludGVyIG1vZGVsIGZvciBlYWNoIGF4aXMuXG4vLyBhbGxBeGVzSW5mbyBzaG91bGQgYmUgdXBkYXRlZCB3aGVuIHNldE9wdGlvbiBwZXJmb3JtZWQuXG5cbmV4cG9ydCBmdW5jdGlvbiBjb2xsZWN0KGVjTW9kZWwsIGFwaSkge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIC8qKlxuICAgICAqIGtleTogbWFrZUtleShheGlzLm1vZGVsKVxuICAgICAqIHZhbHVlOiB7XG4gICAgICogICAgICBheGlzLFxuICAgICAqICAgICAgY29vcmRTeXMsXG4gICAgICogICAgICBheGlzUG9pbnRlck1vZGVsLFxuICAgICAqICAgICAgdHJpZ2dlclRvb2x0aXAsXG4gICAgICogICAgICBpbnZvbHZlU2VyaWVzLFxuICAgICAqICAgICAgc25hcCxcbiAgICAgKiAgICAgIHNlcmllc01vZGVscyxcbiAgICAgKiAgICAgIHNlcmllc0RhdGFDb3VudFxuICAgICAqIH1cbiAgICAgKi9cbiAgICBheGVzSW5mbzoge30sXG4gICAgc2VyaWVzSW52b2x2ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICoga2V5OiBtYWtlS2V5KGNvb3JkU3lzLm1vZGVsKVxuICAgICAqIHZhbHVlOiBPYmplY3Q6IGtleSBtYWtlS2V5KGF4aXMubW9kZWwpLCB2YWx1ZTogYXhpc0luZm9cbiAgICAgKi9cbiAgICBjb29yZFN5c0F4ZXNJbmZvOiB7fSxcbiAgICBjb29yZFN5c01hcDoge31cbiAgfTtcbiAgY29sbGVjdEF4ZXNJbmZvKHJlc3VsdCwgZWNNb2RlbCwgYXBpKTsgLy8gQ2hlY2sgc2VyaWVzSW52b2x2ZWQgZm9yIHBlcmZvcm1hbmNlLCBpbiBjYXNlIHRvbyBtYW55IHNlcmllcyBpbiBzb21lIGNoYXJ0LlxuXG4gIHJlc3VsdC5zZXJpZXNJbnZvbHZlZCAmJiBjb2xsZWN0U2VyaWVzSW5mbyhyZXN1bHQsIGVjTW9kZWwpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0QXhlc0luZm8ocmVzdWx0LCBlY01vZGVsLCBhcGkpIHtcbiAgdmFyIGdsb2JhbFRvb2x0aXBNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCd0b29sdGlwJyk7XG4gIHZhciBnbG9iYWxBeGlzUG9pbnRlck1vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ2F4aXNQb2ludGVyJyk7IC8vIGxpbmtzIGNhbiBvbmx5IGJlIHNldCBvbiBnbG9iYWwuXG5cbiAgdmFyIGxpbmtzT3B0aW9uID0gZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xpbmsnLCB0cnVlKSB8fCBbXTtcbiAgdmFyIGxpbmtHcm91cHMgPSBbXTsgLy8gQ29sbGVjdCBheGVzIGluZm8uXG5cbiAgZWFjaChhcGkuZ2V0Q29vcmRpbmF0ZVN5c3RlbXMoKSwgZnVuY3Rpb24gKGNvb3JkU3lzKSB7XG4gICAgLy8gU29tZSBjb29yZGluYXRlIHN5c3RlbSBkbyBub3Qgc3VwcG9ydCBheGVzLCBsaWtlIGdlby5cbiAgICBpZiAoIWNvb3JkU3lzLmF4aXNQb2ludGVyRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb29yZFN5c0tleSA9IG1ha2VLZXkoY29vcmRTeXMubW9kZWwpO1xuICAgIHZhciBheGVzSW5mb0luQ29vcmRTeXMgPSByZXN1bHQuY29vcmRTeXNBeGVzSW5mb1tjb29yZFN5c0tleV0gPSB7fTtcbiAgICByZXN1bHQuY29vcmRTeXNNYXBbY29vcmRTeXNLZXldID0gY29vcmRTeXM7IC8vIFNldCB0b29sdGlwIChsaWtlICdjcm9zcycpIGlzIGEgY29udmllbmVudCB3YXkgdG8gc2hvdyBheGlzUG9pbnRlclxuICAgIC8vIGZvciB1c2VyLiBTbyB3ZSBlbmFibGUgc2V0aW5nIHRvb2x0aXAgb24gY29vcmRTeXMgbW9kZWwuXG5cbiAgICB2YXIgY29vcmRTeXNNb2RlbCA9IGNvb3JkU3lzLm1vZGVsO1xuICAgIHZhciBiYXNlVG9vbHRpcE1vZGVsID0gY29vcmRTeXNNb2RlbC5nZXRNb2RlbCgndG9vbHRpcCcsIGdsb2JhbFRvb2x0aXBNb2RlbCk7XG4gICAgZWFjaChjb29yZFN5cy5nZXRBeGVzKCksIGN1cnJ5KHNhdmVUb29sdGlwQXhpc0luZm8sIGZhbHNlLCBudWxsKSk7IC8vIElmIGF4aXMgdG9vbHRpcCB1c2VkLCBjaG9vc2UgdG9vbHRpcCBheGlzIGZvciBlYWNoIGNvb3JkU3lzLlxuICAgIC8vIE5vdGljZSB0aGlzIGNhc2U6IGNvb3JkU3lzIGlzIGBncmlkYCBidXQgbm90IGBjYXJ0ZXNpYW4yRGAgaGVyZS5cblxuICAgIGlmIChjb29yZFN5cy5nZXRUb29sdGlwQXhlcyAmJiBnbG9iYWxUb29sdGlwTW9kZWwgLy8gSWYgdG9vbHRpcC5zaG93Q29udGVudCBpcyBzZXQgYXMgZmFsc2UsIHRvb2x0aXAgd2lsbCBub3RcbiAgICAvLyBzaG93IGJ1dCBheGlzUG9pbnRlciB3aWxsIHNob3cgYXMgbm9ybWFsLlxuICAgICYmIGJhc2VUb29sdGlwTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgIC8vIENvbXBhdGlibGUgd2l0aCBwcmV2aW91cyBsb2dpYy4gQnV0IHNlcmllcy50b29sdGlwLnRyaWdnZXI6ICdheGlzJ1xuICAgICAgLy8gb3Igc2VyaWVzLmRhdGFbbl0udG9vbHRpcC50cmlnZ2VyOiAnYXhpcycgYXJlIG5vdCBzdXBwb3J0IGFueSBtb3JlLlxuICAgICAgdmFyIHRyaWdnZXJBeGlzID0gYmFzZVRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXInKSA9PT0gJ2F4aXMnO1xuICAgICAgdmFyIGNyb3NzID0gYmFzZVRvb2x0aXBNb2RlbC5nZXQoWydheGlzUG9pbnRlcicsICd0eXBlJ10pID09PSAnY3Jvc3MnO1xuICAgICAgdmFyIHRvb2x0aXBBeGVzID0gY29vcmRTeXMuZ2V0VG9vbHRpcEF4ZXMoYmFzZVRvb2x0aXBNb2RlbC5nZXQoWydheGlzUG9pbnRlcicsICdheGlzJ10pKTtcblxuICAgICAgaWYgKHRyaWdnZXJBeGlzIHx8IGNyb3NzKSB7XG4gICAgICAgIGVhY2godG9vbHRpcEF4ZXMuYmFzZUF4ZXMsIGN1cnJ5KHNhdmVUb29sdGlwQXhpc0luZm8sIGNyb3NzID8gJ2Nyb3NzJyA6IHRydWUsIHRyaWdnZXJBeGlzKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjcm9zcykge1xuICAgICAgICBlYWNoKHRvb2x0aXBBeGVzLm90aGVyQXhlcywgY3Vycnkoc2F2ZVRvb2x0aXBBeGlzSW5mbywgJ2Nyb3NzJywgZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9IC8vIGZyb21Ub29sdGlwOiB0cnVlIHwgZmFsc2UgfCAnY3Jvc3MnXG4gICAgLy8gdHJpZ2dlclRvb2x0aXA6IHRydWUgfCBmYWxzZSB8IG51bGxcblxuXG4gICAgZnVuY3Rpb24gc2F2ZVRvb2x0aXBBeGlzSW5mbyhmcm9tVG9vbHRpcCwgdHJpZ2dlclRvb2x0aXAsIGF4aXMpIHtcbiAgICAgIHZhciBheGlzUG9pbnRlck1vZGVsID0gYXhpcy5tb2RlbC5nZXRNb2RlbCgnYXhpc1BvaW50ZXInLCBnbG9iYWxBeGlzUG9pbnRlck1vZGVsKTtcbiAgICAgIHZhciBheGlzUG9pbnRlclNob3cgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc2hvdycpO1xuXG4gICAgICBpZiAoIWF4aXNQb2ludGVyU2hvdyB8fCBheGlzUG9pbnRlclNob3cgPT09ICdhdXRvJyAmJiAhZnJvbVRvb2x0aXAgJiYgIWlzSGFuZGxlVHJpZ2dlcihheGlzUG9pbnRlck1vZGVsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmlnZ2VyVG9vbHRpcCA9PSBudWxsKSB7XG4gICAgICAgIHRyaWdnZXJUb29sdGlwID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3RyaWdnZXJUb29sdGlwJyk7XG4gICAgICB9XG5cbiAgICAgIGF4aXNQb2ludGVyTW9kZWwgPSBmcm9tVG9vbHRpcCA/IG1ha2VBeGlzUG9pbnRlck1vZGVsKGF4aXMsIGJhc2VUb29sdGlwTW9kZWwsIGdsb2JhbEF4aXNQb2ludGVyTW9kZWwsIGVjTW9kZWwsIGZyb21Ub29sdGlwLCB0cmlnZ2VyVG9vbHRpcCkgOiBheGlzUG9pbnRlck1vZGVsO1xuICAgICAgdmFyIHNuYXAgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc25hcCcpO1xuICAgICAgdmFyIGF4aXNLZXkgPSBtYWtlS2V5KGF4aXMubW9kZWwpO1xuICAgICAgdmFyIGludm9sdmVTZXJpZXMgPSB0cmlnZ2VyVG9vbHRpcCB8fCBzbmFwIHx8IGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JzsgLy8gSWYgcmVzdWx0LmF4ZXNJbmZvW2tleV0gZXhpc3QsIG92ZXJyaWRlIGl0ICh0b29sdGlwIGhhcyBoaWdoZXIgcHJpb3JpdHkpLlxuXG4gICAgICB2YXIgYXhpc0luZm8gPSByZXN1bHQuYXhlc0luZm9bYXhpc0tleV0gPSB7XG4gICAgICAgIGtleTogYXhpc0tleSxcbiAgICAgICAgYXhpczogYXhpcyxcbiAgICAgICAgY29vcmRTeXM6IGNvb3JkU3lzLFxuICAgICAgICBheGlzUG9pbnRlck1vZGVsOiBheGlzUG9pbnRlck1vZGVsLFxuICAgICAgICB0cmlnZ2VyVG9vbHRpcDogdHJpZ2dlclRvb2x0aXAsXG4gICAgICAgIGludm9sdmVTZXJpZXM6IGludm9sdmVTZXJpZXMsXG4gICAgICAgIHNuYXA6IHNuYXAsXG4gICAgICAgIHVzZUhhbmRsZTogaXNIYW5kbGVUcmlnZ2VyKGF4aXNQb2ludGVyTW9kZWwpLFxuICAgICAgICBzZXJpZXNNb2RlbHM6IFtdLFxuICAgICAgICBsaW5rR3JvdXA6IG51bGxcbiAgICAgIH07XG4gICAgICBheGVzSW5mb0luQ29vcmRTeXNbYXhpc0tleV0gPSBheGlzSW5mbztcbiAgICAgIHJlc3VsdC5zZXJpZXNJbnZvbHZlZCA9IHJlc3VsdC5zZXJpZXNJbnZvbHZlZCB8fCBpbnZvbHZlU2VyaWVzO1xuICAgICAgdmFyIGdyb3VwSW5kZXggPSBnZXRMaW5rR3JvdXBJbmRleChsaW5rc09wdGlvbiwgYXhpcyk7XG5cbiAgICAgIGlmIChncm91cEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGxpbmtHcm91cCA9IGxpbmtHcm91cHNbZ3JvdXBJbmRleF0gfHwgKGxpbmtHcm91cHNbZ3JvdXBJbmRleF0gPSB7XG4gICAgICAgICAgYXhlc0luZm86IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBsaW5rR3JvdXAuYXhlc0luZm9bYXhpc0tleV0gPSBheGlzSW5mbztcbiAgICAgICAgbGlua0dyb3VwLm1hcHBlciA9IGxpbmtzT3B0aW9uW2dyb3VwSW5kZXhdLm1hcHBlcjtcbiAgICAgICAgYXhpc0luZm8ubGlua0dyb3VwID0gbGlua0dyb3VwO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VBeGlzUG9pbnRlck1vZGVsKGF4aXMsIGJhc2VUb29sdGlwTW9kZWwsIGdsb2JhbEF4aXNQb2ludGVyTW9kZWwsIGVjTW9kZWwsIGZyb21Ub29sdGlwLCB0cmlnZ2VyVG9vbHRpcCkge1xuICB2YXIgdG9vbHRpcEF4aXNQb2ludGVyTW9kZWwgPSBiYXNlVG9vbHRpcE1vZGVsLmdldE1vZGVsKCdheGlzUG9pbnRlcicpO1xuICB2YXIgZmllbGRzID0gWyd0eXBlJywgJ3NuYXAnLCAnbGluZVN0eWxlJywgJ3NoYWRvd1N0eWxlJywgJ2xhYmVsJywgJ2FuaW1hdGlvbicsICdhbmltYXRpb25EdXJhdGlvblVwZGF0ZScsICdhbmltYXRpb25FYXNpbmdVcGRhdGUnLCAneiddO1xuICB2YXIgdm9sYXRpbGVPcHRpb24gPSB7fTtcbiAgZWFjaChmaWVsZHMsIGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIHZvbGF0aWxlT3B0aW9uW2ZpZWxkXSA9IGNsb25lKHRvb2x0aXBBeGlzUG9pbnRlck1vZGVsLmdldChmaWVsZCkpO1xuICB9KTsgLy8gY2F0ZWdvcnkgYXhpcyBkbyBub3QgYXV0byBzbmFwLCBvdGhlcndpc2Ugc29tZSB0aWNrIHRoYXQgZG8gbm90XG4gIC8vIGhhcyB2YWx1ZSBjYW4gbm90IGJlIGhvdmVyZWQuIHZhbHVlL3RpbWUvbG9nIGF4aXMgZGVmYXVsdCBzbmFwIGlmXG4gIC8vIHRyaWdnZXJlZCBmcm9tIHRvb2x0aXAgYW5kIHRyaWdnZXIgdG9vbHRpcC5cblxuICB2b2xhdGlsZU9wdGlvbi5zbmFwID0gYXhpcy50eXBlICE9PSAnY2F0ZWdvcnknICYmICEhdHJpZ2dlclRvb2x0aXA7IC8vIENvbXBhdGliZWwgd2l0aCBwcmV2aW91cyBiZWhhdmlvciwgdG9vbHRpcCBheGlzIGRvIG5vdCBzaG93IGxhYmVsIGJ5IGRlZmF1bHQuXG4gIC8vIE9ubHkgdGhlc2UgcHJvcGVydGllcyBjYW4gYmUgb3ZlcnJpZGVkIGZyb20gdG9vbHRpcCB0byBheGlzUG9pbnRlci5cblxuICBpZiAodG9vbHRpcEF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJykgPT09ICdjcm9zcycpIHtcbiAgICB2b2xhdGlsZU9wdGlvbi50eXBlID0gJ2xpbmUnO1xuICB9XG5cbiAgdmFyIGxhYmVsT3B0aW9uID0gdm9sYXRpbGVPcHRpb24ubGFiZWwgfHwgKHZvbGF0aWxlT3B0aW9uLmxhYmVsID0ge30pOyAvLyBGb2xsb3cgdGhlIGNvbnZlbnRpb24sIGRvIG5vdCBzaG93IGxhYmVsIHdoZW4gdHJpZ2dlcmVkIGJ5IHRvb2x0aXAgYnkgZGVmYXVsdC5cblxuICBsYWJlbE9wdGlvbi5zaG93ID09IG51bGwgJiYgKGxhYmVsT3B0aW9uLnNob3cgPSBmYWxzZSk7XG5cbiAgaWYgKGZyb21Ub29sdGlwID09PSAnY3Jvc3MnKSB7XG4gICAgLy8gV2hlbiAnY3Jvc3MnLCBib3RoIGF4ZXMgc2hvdyBsYWJlbHMuXG4gICAgdmFyIHRvb2x0aXBBeGlzUG9pbnRlckxhYmVsU2hvdyA9IHRvb2x0aXBBeGlzUG9pbnRlck1vZGVsLmdldChbJ2xhYmVsJywgJ3Nob3cnXSk7XG4gICAgbGFiZWxPcHRpb24uc2hvdyA9IHRvb2x0aXBBeGlzUG9pbnRlckxhYmVsU2hvdyAhPSBudWxsID8gdG9vbHRpcEF4aXNQb2ludGVyTGFiZWxTaG93IDogdHJ1ZTsgLy8gSWYgdHJpZ2dlclRvb2x0aXAsIHRoaXMgaXMgYSBiYXNlIGF4aXMsIHdoaWNoIHNob3VsZCBiZXR0ZXIgbm90IHVzZSBjcm9zcyBzdHlsZVxuICAgIC8vIChjcm9zcyBzdHlsZSBpcyBkYXNoZWQgYnkgZGVmYXVsdClcblxuICAgIGlmICghdHJpZ2dlclRvb2x0aXApIHtcbiAgICAgIHZhciBjcm9zc1N0eWxlID0gdm9sYXRpbGVPcHRpb24ubGluZVN0eWxlID0gdG9vbHRpcEF4aXNQb2ludGVyTW9kZWwuZ2V0KCdjcm9zc1N0eWxlJyk7XG4gICAgICBjcm9zc1N0eWxlICYmIGRlZmF1bHRzKGxhYmVsT3B0aW9uLCBjcm9zc1N0eWxlLnRleHRTdHlsZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF4aXMubW9kZWwuZ2V0TW9kZWwoJ2F4aXNQb2ludGVyJywgbmV3IE1vZGVsKHZvbGF0aWxlT3B0aW9uLCBnbG9iYWxBeGlzUG9pbnRlck1vZGVsLCBlY01vZGVsKSk7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3RTZXJpZXNJbmZvKHJlc3VsdCwgZWNNb2RlbCkge1xuICAvLyBQcmVwYXJlIGRhdGEgZm9yIGF4aXMgdHJpZ2dlclxuICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgLy8gTm90aWNlIHRoaXMgY2FzZTogdGhpcyBjb29yZFN5cyBpcyBgY2FydGVzaWFuMkRgIGJ1dCBub3QgYGdyaWRgLlxuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIHNlcmllc1Rvb2x0aXBUcmlnZ2VyID0gc2VyaWVzTW9kZWwuZ2V0KFsndG9vbHRpcCcsICd0cmlnZ2VyJ10sIHRydWUpO1xuICAgIHZhciBzZXJpZXNUb29sdGlwU2hvdyA9IHNlcmllc01vZGVsLmdldChbJ3Rvb2x0aXAnLCAnc2hvdyddLCB0cnVlKTtcblxuICAgIGlmICghY29vcmRTeXMgfHwgc2VyaWVzVG9vbHRpcFRyaWdnZXIgPT09ICdub25lJyB8fCBzZXJpZXNUb29sdGlwVHJpZ2dlciA9PT0gZmFsc2UgfHwgc2VyaWVzVG9vbHRpcFRyaWdnZXIgPT09ICdpdGVtJyB8fCBzZXJpZXNUb29sdGlwU2hvdyA9PT0gZmFsc2UgfHwgc2VyaWVzTW9kZWwuZ2V0KFsnYXhpc1BvaW50ZXInLCAnc2hvdyddLCB0cnVlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlYWNoKHJlc3VsdC5jb29yZFN5c0F4ZXNJbmZvW21ha2VLZXkoY29vcmRTeXMubW9kZWwpXSwgZnVuY3Rpb24gKGF4aXNJbmZvKSB7XG4gICAgICB2YXIgYXhpcyA9IGF4aXNJbmZvLmF4aXM7XG5cbiAgICAgIGlmIChjb29yZFN5cy5nZXRBeGlzKGF4aXMuZGltKSA9PT0gYXhpcykge1xuICAgICAgICBheGlzSW5mby5zZXJpZXNNb2RlbHMucHVzaChzZXJpZXNNb2RlbCk7XG4gICAgICAgIGF4aXNJbmZvLnNlcmllc0RhdGFDb3VudCA9PSBudWxsICYmIChheGlzSW5mby5zZXJpZXNEYXRhQ291bnQgPSAwKTtcbiAgICAgICAgYXhpc0luZm8uc2VyaWVzRGF0YUNvdW50ICs9IHNlcmllc01vZGVsLmdldERhdGEoKS5jb3VudCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cbi8qKlxuICogRm9yIGV4YW1wbGU6XG4gKiB7XG4gKiAgICAgYXhpc1BvaW50ZXI6IHtcbiAqICAgICAgICAgbGlua3M6IFt7XG4gKiAgICAgICAgICAgICB4QXhpc0luZGV4OiBbMiwgNF0sXG4gKiAgICAgICAgICAgICB5QXhpc0luZGV4OiAnYWxsJ1xuICogICAgICAgICB9LCB7XG4gKiAgICAgICAgICAgICB4QXhpc0lkOiBbJ2E1JywgJ2E3J10sXG4gKiAgICAgICAgICAgICB4QXhpc05hbWU6ICd4eHgnXG4gKiAgICAgICAgIH1dXG4gKiAgICAgfVxuICogfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGlua0dyb3VwSW5kZXgobGlua3NPcHRpb24sIGF4aXMpIHtcbiAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gIHZhciBkaW0gPSBheGlzLmRpbTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmtzT3B0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmtPcHRpb24gPSBsaW5rc09wdGlvbltpXSB8fCB7fTtcblxuICAgIGlmIChjaGVja1Byb3BJbkxpbmsobGlua09wdGlvbltkaW0gKyAnQXhpc0lkJ10sIGF4aXNNb2RlbC5pZCkgfHwgY2hlY2tQcm9wSW5MaW5rKGxpbmtPcHRpb25bZGltICsgJ0F4aXNJbmRleCddLCBheGlzTW9kZWwuY29tcG9uZW50SW5kZXgpIHx8IGNoZWNrUHJvcEluTGluayhsaW5rT3B0aW9uW2RpbSArICdBeGlzTmFtZSddLCBheGlzTW9kZWwubmFtZSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BJbkxpbmsobGlua1Byb3BWYWx1ZSwgYXhpc1Byb3BWYWx1ZSkge1xuICByZXR1cm4gbGlua1Byb3BWYWx1ZSA9PT0gJ2FsbCcgfHwgaXNBcnJheShsaW5rUHJvcFZhbHVlKSAmJiBpbmRleE9mKGxpbmtQcm9wVmFsdWUsIGF4aXNQcm9wVmFsdWUpID49IDAgfHwgbGlua1Byb3BWYWx1ZSA9PT0gYXhpc1Byb3BWYWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpeFZhbHVlKGF4aXNNb2RlbCkge1xuICB2YXIgYXhpc0luZm8gPSBnZXRBeGlzSW5mbyhheGlzTW9kZWwpO1xuXG4gIGlmICghYXhpc0luZm8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYXhpc1BvaW50ZXJNb2RlbCA9IGF4aXNJbmZvLmF4aXNQb2ludGVyTW9kZWw7XG4gIHZhciBzY2FsZSA9IGF4aXNJbmZvLmF4aXMuc2NhbGU7XG4gIHZhciBvcHRpb24gPSBheGlzUG9pbnRlck1vZGVsLm9wdGlvbjtcbiAgdmFyIHN0YXR1cyA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzdGF0dXMnKTtcbiAgdmFyIHZhbHVlID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3ZhbHVlJyk7IC8vIFBhcnNlIGluaXQgdmFsdWUgZm9yIGNhdGVnb3J5IGFuZCB0aW1lIGF4aXMuXG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB2YWx1ZSA9IHNjYWxlLnBhcnNlKHZhbHVlKTtcbiAgfVxuXG4gIHZhciB1c2VIYW5kbGUgPSBpc0hhbmRsZVRyaWdnZXIoYXhpc1BvaW50ZXJNb2RlbCk7IC8vIElmIGBoYW5kbGVgIHVzZWQsIGBheGlzUG9pbnRlcmAgd2lsbCBhbHdheXMgYmUgZGlzcGxheWVkLCBzbyB2YWx1ZVxuICAvLyBhbmQgc3RhdHVzIHNob3VsZCBiZSBpbml0aWFsaXplZC5cblxuICBpZiAoc3RhdHVzID09IG51bGwpIHtcbiAgICBvcHRpb24uc3RhdHVzID0gdXNlSGFuZGxlID8gJ3Nob3cnIDogJ2hpZGUnO1xuICB9XG5cbiAgdmFyIGV4dGVudCA9IHNjYWxlLmdldEV4dGVudCgpLnNsaWNlKCk7XG4gIGV4dGVudFswXSA+IGV4dGVudFsxXSAmJiBleHRlbnQucmV2ZXJzZSgpO1xuXG4gIGlmICggLy8gUGljayBhIHZhbHVlIG9uIGF4aXMgd2hlbiBpbml0aWFsaXppbmcuXG4gIHZhbHVlID09IG51bGwgLy8gSWYgYm90aCBgaGFuZGxlYCBhbmQgYGRhdGFab29tYCBhcmUgdXNlZCwgdmFsdWUgbWF5IGJlIG91dCBvZiBheGlzIGV4dGVudCxcbiAgLy8gd2hlcmUgd2Ugc2hvdWxkIHJlLXBpY2sgYSB2YWx1ZSB0byBrZWVwIGBoYW5kbGVgIGRpc3BsYXlpbmcgbm9ybWFsbHkuXG4gIHx8IHZhbHVlID4gZXh0ZW50WzFdKSB7XG4gICAgLy8gTWFrZSBoYW5kbGUgZGlzcGxheWVkIG9uIHRoZSBlbmQgb2YgdGhlIGF4aXMgd2hlbiBpbml0LCB3aGljaCBsb29rcyBiZXR0ZXIuXG4gICAgdmFsdWUgPSBleHRlbnRbMV07XG4gIH1cblxuICBpZiAodmFsdWUgPCBleHRlbnRbMF0pIHtcbiAgICB2YWx1ZSA9IGV4dGVudFswXTtcbiAgfVxuXG4gIG9wdGlvbi52YWx1ZSA9IHZhbHVlO1xuXG4gIGlmICh1c2VIYW5kbGUpIHtcbiAgICBvcHRpb24uc3RhdHVzID0gYXhpc0luZm8uYXhpcy5zY2FsZS5pc0JsYW5rKCkgPyAnaGlkZScgOiAnc2hvdyc7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBeGlzSW5mbyhheGlzTW9kZWwpIHtcbiAgdmFyIGNvb3JkU3lzQXhlc0luZm8gPSAoYXhpc01vZGVsLmVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpIHx8IHt9KS5jb29yZFN5c0F4ZXNJbmZvO1xuICByZXR1cm4gY29vcmRTeXNBeGVzSW5mbyAmJiBjb29yZFN5c0F4ZXNJbmZvLmF4ZXNJbmZvW21ha2VLZXkoYXhpc01vZGVsKV07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QXhpc1BvaW50ZXJNb2RlbChheGlzTW9kZWwpIHtcbiAgdmFyIGF4aXNJbmZvID0gZ2V0QXhpc0luZm8oYXhpc01vZGVsKTtcbiAgcmV0dXJuIGF4aXNJbmZvICYmIGF4aXNJbmZvLmF4aXNQb2ludGVyTW9kZWw7XG59XG5cbmZ1bmN0aW9uIGlzSGFuZGxlVHJpZ2dlcihheGlzUG9pbnRlck1vZGVsKSB7XG4gIHJldHVybiAhIWF4aXNQb2ludGVyTW9kZWwuZ2V0KFsnaGFuZGxlJywgJ3Nob3cnXSk7XG59XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IG1vZGVsXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHVuaXF1ZSBrZXlcbiAqL1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlS2V5KG1vZGVsKSB7XG4gIHJldHVybiBtb2RlbC50eXBlICsgJ3x8JyArIG1vZGVsLmlkO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBNYXBEcmF3IGZyb20gJy4uL2hlbHBlci9NYXBEcmF3JztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50JztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZSc7XG5cbnZhciBHZW9WaWV3ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEdlb1ZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gR2VvVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBHZW9WaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgR2VvVmlldy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgbWFwRHJhdyA9IG5ldyBNYXBEcmF3KGFwaSk7XG4gICAgdGhpcy5fbWFwRHJhdyA9IG1hcERyYXc7XG4gICAgdGhpcy5ncm91cC5hZGQobWFwRHJhdy5ncm91cCk7XG4gICAgdGhpcy5fYXBpID0gYXBpO1xuICB9O1xuXG4gIEdlb1ZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChnZW9Nb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdmFyIG1hcERyYXcgPSB0aGlzLl9tYXBEcmF3O1xuXG4gICAgaWYgKGdlb01vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICBtYXBEcmF3LmRyYXcoZ2VvTW9kZWwsIGVjTW9kZWwsIGFwaSwgdGhpcywgcGF5bG9hZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcERyYXcuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgfVxuXG4gICAgbWFwRHJhdy5ncm91cC5vbignY2xpY2snLCB0aGlzLl9oYW5kbGVSZWdpb25DbGljaywgdGhpcyk7XG4gICAgbWFwRHJhdy5ncm91cC5zaWxlbnQgPSBnZW9Nb2RlbC5nZXQoJ3NpbGVudCcpO1xuICAgIHRoaXMuX21vZGVsID0gZ2VvTW9kZWw7XG4gICAgdGhpcy51cGRhdGVTZWxlY3RTdGF0dXMoZ2VvTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gIH07XG5cbiAgR2VvVmlldy5wcm90b3R5cGUuX2hhbmRsZVJlZ2lvbkNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgY3VycmVudCA9IGUudGFyZ2V0O1xuICAgIHZhciBldmVudERhdGE7IC8vIFRPRE8gZXh0cmFjdCBhIHV0aWwgZnVuY3Rpb25cblxuICAgIHdoaWxlIChjdXJyZW50ICYmIChldmVudERhdGEgPSBnZXRFQ0RhdGEoY3VycmVudCkuZXZlbnREYXRhKSA9PSBudWxsKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5fX2hvc3RUYXJnZXQgfHwgY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50RGF0YSkge1xuICAgICAgdGhpcy5fYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ2dlb1RvZ2dsZVNlbGVjdCcsXG4gICAgICAgIGdlb0lkOiB0aGlzLl9tb2RlbC5pZCxcbiAgICAgICAgbmFtZTogZXZlbnREYXRhLm5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBHZW9WaWV3LnByb3RvdHlwZS51cGRhdGVTZWxlY3RTdGF0dXMgPSBmdW5jdGlvbiAobW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9tYXBEcmF3Lmdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgZXZlbnREYXRhID0gZ2V0RUNEYXRhKG5vZGUpLmV2ZW50RGF0YTtcblxuICAgICAgaWYgKGV2ZW50RGF0YSkge1xuICAgICAgICBfdGhpcy5fbW9kZWwuaXNTZWxlY3RlZChldmVudERhdGEubmFtZSkgPyBhcGkuZW50ZXJTZWxlY3Qobm9kZSkgOiBhcGkubGVhdmVTZWxlY3Qobm9kZSk7IC8vIE5vIG5lZWQgdG8gdHJhdmVyc2UgY2hpbGRyZW4uXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgR2VvVmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9tYXBEcmF3ICYmIHRoaXMuX21hcERyYXcucmVtb3ZlKCk7XG4gIH07XG5cbiAgR2VvVmlldy50eXBlID0gJ2dlbyc7XG4gIHJldHVybiBHZW9WaWV3O1xufShDb21wb25lbnRWaWV3KTtcblxuZXhwb3J0IGRlZmF1bHQgR2VvVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IEdlb01vZGVsIGZyb20gJy4uLy4uL2Nvb3JkL2dlby9HZW9Nb2RlbCc7XG5pbXBvcnQgZ2VvQ3JlYXRvciBmcm9tICcuLi8uLi9jb29yZC9nZW8vZ2VvQ3JlYXRvcic7XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCB7IHVwZGF0ZUNlbnRlckFuZFpvb20gfSBmcm9tICcuLi8uLi9hY3Rpb24vcm9hbUhlbHBlcic7XG5pbXBvcnQgR2VvVmlldyBmcm9tICcuL0dlb1ZpZXcnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvb3JkaW5hdGVTeXN0ZW0oJ2dlbycsIGdlb0NyZWF0b3IpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChHZW9Nb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoR2VvVmlldyk7XG5cbiAgZnVuY3Rpb24gbWFrZUFjdGlvbihtZXRob2QsIGFjdGlvbkluZm8pIHtcbiAgICBhY3Rpb25JbmZvLnVwZGF0ZSA9ICdnZW86dXBkYXRlU2VsZWN0U3RhdHVzJztcbiAgICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oYWN0aW9uSW5mbywgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHt9O1xuICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgICAgbWFpblR5cGU6ICdnZW8nLFxuICAgICAgICBxdWVyeTogcGF5bG9hZFxuICAgICAgfSwgZnVuY3Rpb24gKGdlb01vZGVsKSB7XG4gICAgICAgIGdlb01vZGVsW21ldGhvZF0ocGF5bG9hZC5uYW1lKTtcbiAgICAgICAgdmFyIGdlbyA9IGdlb01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgIGVhY2goZ2VvLnJlZ2lvbnMsIGZ1bmN0aW9uIChyZWdpb24pIHtcbiAgICAgICAgICBzZWxlY3RlZFtyZWdpb24ubmFtZV0gPSBnZW9Nb2RlbC5pc1NlbGVjdGVkKHJlZ2lvbi5uYW1lKSB8fCBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgICAgbmFtZTogcGF5bG9hZC5uYW1lXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgbWFrZUFjdGlvbigndG9nZ2xlU2VsZWN0ZWQnLCB7XG4gICAgdHlwZTogJ2dlb1RvZ2dsZVNlbGVjdCcsXG4gICAgZXZlbnQ6ICdnZW9zZWxlY3RjaGFuZ2VkJ1xuICB9KTtcbiAgbWFrZUFjdGlvbignc2VsZWN0Jywge1xuICAgIHR5cGU6ICdnZW9TZWxlY3QnLFxuICAgIGV2ZW50OiAnZ2Vvc2VsZWN0ZWQnXG4gIH0pO1xuICBtYWtlQWN0aW9uKCd1blNlbGVjdCcsIHtcbiAgICB0eXBlOiAnZ2VvVW5TZWxlY3QnLFxuICAgIGV2ZW50OiAnZ2VvdW5zZWxlY3RlZCdcbiAgfSk7XG4gIC8qKlxuICAgKiBAcGF5bG9hZFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbXBvbmVudFR5cGU9c2VyaWVzXVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2R4XVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2R5XVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW3pvb21dXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3JpZ2luWF1cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcmlnaW5ZXVxuICAgKi9cblxuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oe1xuICAgIHR5cGU6ICdnZW9Sb2FtJyxcbiAgICBldmVudDogJ2dlb1JvYW0nLFxuICAgIHVwZGF0ZTogJ3VwZGF0ZVRyYW5zZm9ybSdcbiAgfSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgICB2YXIgY29tcG9uZW50VHlwZSA9IHBheWxvYWQuY29tcG9uZW50VHlwZSB8fCAnc2VyaWVzJztcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6IGNvbXBvbmVudFR5cGUsXG4gICAgICBxdWVyeTogcGF5bG9hZFxuICAgIH0sIGZ1bmN0aW9uIChjb21wb25lbnRNb2RlbCkge1xuICAgICAgdmFyIGdlbyA9IGNvbXBvbmVudE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICAgIGlmIChnZW8udHlwZSAhPT0gJ2dlbycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzID0gdXBkYXRlQ2VudGVyQW5kWm9vbShnZW8sIHBheWxvYWQsIGNvbXBvbmVudE1vZGVsLmdldCgnc2NhbGVMaW1pdCcpKTtcbiAgICAgIGNvbXBvbmVudE1vZGVsLnNldENlbnRlciAmJiBjb21wb25lbnRNb2RlbC5zZXRDZW50ZXIocmVzLmNlbnRlcik7XG4gICAgICBjb21wb25lbnRNb2RlbC5zZXRab29tICYmIGNvbXBvbmVudE1vZGVsLnNldFpvb20ocmVzLnpvb20pOyAvLyBBbGwgbWFwIHNlcmllcyB3aXRoIHNhbWUgYG1hcGAgdXNlIHRoZSBzYW1lIGdlbyBjb29yZGluYXRlIHN5c3RlbVxuICAgICAgLy8gU28gdGhlIGNlbnRlciBhbmQgem9vbSBtdXN0IGJlIGluIHN5bmMuIEluY2x1ZGUgdGhlIHNlcmllcyBub3Qgc2VsZWN0ZWQgYnkgbGVnZW5kXG5cbiAgICAgIGlmIChjb21wb25lbnRUeXBlID09PSAnc2VyaWVzJykge1xuICAgICAgICBlYWNoKGNvbXBvbmVudE1vZGVsLnNlcmllc0dyb3VwLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICBzZXJpZXNNb2RlbC5zZXRDZW50ZXIocmVzLmNlbnRlcik7XG4gICAgICAgICAgc2VyaWVzTW9kZWwuc2V0Wm9vbShyZXMuem9vbSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQ29tcG9uZW50VmlldyBmcm9tICcuLi8uLi92aWV3L0NvbXBvbmVudCc7XG5pbXBvcnQgR3JpZE1vZGVsIGZyb20gJy4uLy4uL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWwnO1xuaW1wb3J0IHsgUmVjdCB9IGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgeyBkZWZhdWx0cyB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBDYXJ0ZXNpYW5BeGlzTW9kZWwgfSBmcm9tICcuLi8uLi9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsJztcbmltcG9ydCBheGlzTW9kZWxDcmVhdG9yIGZyb20gJy4uLy4uL2Nvb3JkL2F4aXNNb2RlbENyZWF0b3InO1xuaW1wb3J0IEdyaWQgZnJvbSAnLi4vLi4vY29vcmQvY2FydGVzaWFuL0dyaWQnO1xuaW1wb3J0IHsgQ2FydGVzaWFuWEF4aXNWaWV3LCBDYXJ0ZXNpYW5ZQXhpc1ZpZXcgfSBmcm9tICcuLi9heGlzL0NhcnRlc2lhbkF4aXNWaWV3JzsgLy8gR3JpZCB2aWV3XG5cbnZhciBHcmlkVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhHcmlkVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBHcmlkVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSAnZ3JpZCc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgR3JpZFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChncmlkTW9kZWwsIGVjTW9kZWwpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgaWYgKGdyaWRNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgdGhpcy5ncm91cC5hZGQobmV3IFJlY3Qoe1xuICAgICAgICBzaGFwZTogZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpLFxuICAgICAgICBzdHlsZTogZGVmYXVsdHMoe1xuICAgICAgICAgIGZpbGw6IGdyaWRNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpXG4gICAgICAgIH0sIGdyaWRNb2RlbC5nZXRJdGVtU3R5bGUoKSksXG4gICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgejI6IC0xXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4gIEdyaWRWaWV3LnR5cGUgPSAnZ3JpZCc7XG4gIHJldHVybiBHcmlkVmlldztcbn0oQ29tcG9uZW50Vmlldyk7XG5cbnZhciBleHRyYU9wdGlvbiA9IHtcbiAgLy8gZ3JpZEluZGV4OiAwLFxuICAvLyBncmlkSWQ6ICcnLFxuICBvZmZzZXQ6IDBcbn07XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhHcmlkVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKEdyaWRNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvb3JkaW5hdGVTeXN0ZW0oJ2NhcnRlc2lhbjJkJywgR3JpZCk7XG4gIGF4aXNNb2RlbENyZWF0b3IocmVnaXN0ZXJzLCAneCcsIENhcnRlc2lhbkF4aXNNb2RlbCwgZXh0cmFPcHRpb24pO1xuICBheGlzTW9kZWxDcmVhdG9yKHJlZ2lzdGVycywgJ3knLCBDYXJ0ZXNpYW5BeGlzTW9kZWwsIGV4dHJhT3B0aW9uKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhDYXJ0ZXNpYW5YQXhpc1ZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KENhcnRlc2lhbllBeGlzVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgLy8gT25seSBjcmVhdGUgZ3JpZCB3aGVuIG5lZWRcbiAgICBpZiAob3B0aW9uLnhBeGlzICYmIG9wdGlvbi55QXhpcyAmJiAhb3B0aW9uLmdyaWQpIHtcbiAgICAgIG9wdGlvbi5ncmlkID0ge307XG4gICAgfVxuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBjdXJyeSwgZWFjaCwgbWFwLCBiaW5kLCBtZXJnZSwgY2xvbmUsIGRlZmF1bHRzLCBhc3NlcnQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IEV2ZW50ZnVsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvRXZlbnRmdWwnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMnO1xuaW1wb3J0ICogYXMgaW50ZXJhY3Rpb25NdXRleCBmcm9tICcuL2ludGVyYWN0aW9uTXV0ZXgnO1xuaW1wb3J0IERhdGFEaWZmZXIgZnJvbSAnLi4vLi4vZGF0YS9EYXRhRGlmZmVyJztcbnZhciBCUlVTSF9QQU5FTF9HTE9CQUwgPSB0cnVlO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aFBvdyA9IE1hdGgucG93O1xudmFyIENPVkVSX1ogPSAxMDAwMDtcbnZhciBVTlNFTEVDVF9USFJFU0hPTEQgPSA2O1xudmFyIE1JTl9SRVNJWkVfTElORV9XSURUSCA9IDY7XG52YXIgTVVURVhfUkVTT1VSQ0VfS0VZID0gJ2dsb2JhbFBhbic7XG52YXIgRElSRUNUSU9OX01BUCA9IHtcbiAgdzogWzAsIDBdLFxuICBlOiBbMCwgMV0sXG4gIG46IFsxLCAwXSxcbiAgczogWzEsIDFdXG59O1xudmFyIENVUlNPUl9NQVAgPSB7XG4gIHc6ICdldycsXG4gIGU6ICdldycsXG4gIG46ICducycsXG4gIHM6ICducycsXG4gIG5lOiAnbmVzdycsXG4gIHN3OiAnbmVzdycsXG4gIG53OiAnbndzZScsXG4gIHNlOiAnbndzZSdcbn07XG52YXIgREVGQVVMVF9CUlVTSF9PUFQgPSB7XG4gIGJydXNoU3R5bGU6IHtcbiAgICBsaW5lV2lkdGg6IDIsXG4gICAgc3Ryb2tlOiAncmdiYSgyMTAsMjE5LDIzOCwwLjMpJyxcbiAgICBmaWxsOiAnI0QyREJFRSdcbiAgfSxcbiAgdHJhbnNmb3JtYWJsZTogdHJ1ZSxcbiAgYnJ1c2hNb2RlOiAnc2luZ2xlJyxcbiAgcmVtb3ZlT25DbGljazogZmFsc2Vcbn07XG52YXIgYmFzZVVJRCA9IDA7XG4vKipcbiAqIHBhcmFtczpcbiAqICAgICBhcmVhczogQXJyYXkuPEFycmF5PiwgY29vcmQgcmVsYXRlcyB0byBjb250YWluZXIgZ3JvdXAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm8gY29udGFpbmVyIHNwZWNpZmllZCwgdG8gZ2xvYmFsLlxuICogICAgIG9wdCB7XG4gKiAgICAgICAgIGlzRW5kOiBib29sZWFuLFxuICogICAgICAgICByZW1vdmVPbkNsaWNrOiBib29sZWFuXG4gKiAgICAgfVxuICovXG5cbnZhciBCcnVzaENvbnRyb2xsZXIgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQnJ1c2hDb250cm9sbGVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEJydXNoQ29udHJvbGxlcih6cikge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG5cblxuICAgIF90aGlzLl90cmFjayA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuXG4gICAgX3RoaXMuX2NvdmVycyA9IFtdO1xuICAgIF90aGlzLl9oYW5kbGVycyA9IHt9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydCh6cik7XG4gICAgfVxuXG4gICAgX3RoaXMuX3pyID0genI7XG4gICAgX3RoaXMuZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIF90aGlzLl91aWQgPSAnYnJ1c2hDb250cm9sbGVyXycgKyBiYXNlVUlEKys7XG4gICAgZWFjaChwb2ludGVySGFuZGxlcnMsIGZ1bmN0aW9uIChoYW5kbGVyLCBldmVudE5hbWUpIHtcbiAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0gPSBiaW5kKGhhbmRsZXIsIHRoaXMpO1xuICAgIH0sIF90aGlzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIElmIHNldCB0byBgZmFsc2VgLCBzZWxlY3QgZGlzYWJsZWQuXG4gICAqL1xuXG5cbiAgQnJ1c2hDb250cm9sbGVyLnByb3RvdHlwZS5lbmFibGVCcnVzaCA9IGZ1bmN0aW9uIChicnVzaE9wdGlvbikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnQodGhpcy5fbW91bnRlZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYnJ1c2hUeXBlICYmIHRoaXMuX2RvRGlzYWJsZUJydXNoKCk7XG4gICAgYnJ1c2hPcHRpb24uYnJ1c2hUeXBlICYmIHRoaXMuX2RvRW5hYmxlQnJ1c2goYnJ1c2hPcHRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJydXNoQ29udHJvbGxlci5wcm90b3R5cGUuX2RvRW5hYmxlQnJ1c2ggPSBmdW5jdGlvbiAoYnJ1c2hPcHRpb24pIHtcbiAgICB2YXIgenIgPSB0aGlzLl96cjsgLy8gQ29uc2lkZXIgcm9hbSwgd2hpY2ggdGFrZXMgZ2xvYmFsUGFuIHRvby5cblxuICAgIGlmICghdGhpcy5fZW5hYmxlR2xvYmFsUGFuKSB7XG4gICAgICBpbnRlcmFjdGlvbk11dGV4LnRha2UoenIsIE1VVEVYX1JFU09VUkNFX0tFWSwgdGhpcy5fdWlkKTtcbiAgICB9XG5cbiAgICBlYWNoKHRoaXMuX2hhbmRsZXJzLCBmdW5jdGlvbiAoaGFuZGxlciwgZXZlbnROYW1lKSB7XG4gICAgICB6ci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2JydXNoVHlwZSA9IGJydXNoT3B0aW9uLmJydXNoVHlwZTtcbiAgICB0aGlzLl9icnVzaE9wdGlvbiA9IG1lcmdlKGNsb25lKERFRkFVTFRfQlJVU0hfT1BUKSwgYnJ1c2hPcHRpb24sIHRydWUpO1xuICB9O1xuXG4gIEJydXNoQ29udHJvbGxlci5wcm90b3R5cGUuX2RvRGlzYWJsZUJydXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB6ciA9IHRoaXMuX3pyO1xuICAgIGludGVyYWN0aW9uTXV0ZXgucmVsZWFzZSh6ciwgTVVURVhfUkVTT1VSQ0VfS0VZLCB0aGlzLl91aWQpO1xuICAgIGVhY2godGhpcy5faGFuZGxlcnMsIGZ1bmN0aW9uIChoYW5kbGVyLCBldmVudE5hbWUpIHtcbiAgICAgIHpyLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2JydXNoVHlwZSA9IHRoaXMuX2JydXNoT3B0aW9uID0gbnVsbDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSBwYW5lbE9wdHMgSWYgbm90IHBhc3MsIGl0IGlzIGdsb2JhbCBicnVzaC5cbiAgICovXG5cblxuICBCcnVzaENvbnRyb2xsZXIucHJvdG90eXBlLnNldFBhbmVscyA9IGZ1bmN0aW9uIChwYW5lbE9wdHMpIHtcbiAgICBpZiAocGFuZWxPcHRzICYmIHBhbmVsT3B0cy5sZW5ndGgpIHtcbiAgICAgIHZhciBwYW5lbHNfMSA9IHRoaXMuX3BhbmVscyA9IHt9O1xuICAgICAgZWFjaChwYW5lbE9wdHMsIGZ1bmN0aW9uIChwYW5lbE9wdHMpIHtcbiAgICAgICAgcGFuZWxzXzFbcGFuZWxPcHRzLnBhbmVsSWRdID0gY2xvbmUocGFuZWxPcHRzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYW5lbHMgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJydXNoQ29udHJvbGxlci5wcm90b3R5cGUubW91bnQgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRoaXMuX21vdW50ZWQgPSB0cnVlOyAvLyBzaG91bGQgYmUgYXQgZmlyc3QuXG4gICAgfVxuXG4gICAgdGhpcy5fZW5hYmxlR2xvYmFsUGFuID0gb3B0LmVuYWJsZUdsb2JhbFBhbjtcbiAgICB2YXIgdGhpc0dyb3VwID0gdGhpcy5ncm91cDtcblxuICAgIHRoaXMuX3pyLmFkZCh0aGlzR3JvdXApO1xuXG4gICAgdGhpc0dyb3VwLmF0dHIoe1xuICAgICAgeDogb3B0LnggfHwgMCxcbiAgICAgIHk6IG9wdC55IHx8IDAsXG4gICAgICByb3RhdGlvbjogb3B0LnJvdGF0aW9uIHx8IDAsXG4gICAgICBzY2FsZVg6IG9wdC5zY2FsZVggfHwgMSxcbiAgICAgIHNjYWxlWTogb3B0LnNjYWxlWSB8fCAxXG4gICAgfSk7XG4gICAgdGhpcy5fdHJhbnNmb3JtID0gdGhpc0dyb3VwLmdldExvY2FsVHJhbnNmb3JtKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07IC8vIGVhY2hDb3ZlcihjYiwgY29udGV4dCk6IHZvaWQge1xuICAvLyAgICAgZWFjaCh0aGlzLl9jb3ZlcnMsIGNiLCBjb250ZXh0KTtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgY292ZXJzLlxuICAgKiBAcGFyYW0gY292ZXJDb25maWdMaXN0XG4gICAqICAgICAgICBJZiBjb3ZlckNvbmZpZ0xpc3QgaXMgbnVsbC91bmRlZmluZWQsIGFsbCBjb3ZlcnMgcmVtb3ZlZC5cbiAgICovXG5cblxuICBCcnVzaENvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZUNvdmVycyA9IGZ1bmN0aW9uIChjb3ZlckNvbmZpZ0xpc3QpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0KHRoaXMuX21vdW50ZWQpO1xuICAgIH1cblxuICAgIGNvdmVyQ29uZmlnTGlzdCA9IG1hcChjb3ZlckNvbmZpZ0xpc3QsIGZ1bmN0aW9uIChjb3ZlckNvbmZpZykge1xuICAgICAgcmV0dXJuIG1lcmdlKGNsb25lKERFRkFVTFRfQlJVU0hfT1BUKSwgY292ZXJDb25maWcsIHRydWUpO1xuICAgIH0pO1xuICAgIHZhciB0bXBJZFByZWZpeCA9ICdcXDAtYnJ1c2gtaW5kZXgtJztcbiAgICB2YXIgb2xkQ292ZXJzID0gdGhpcy5fY292ZXJzO1xuICAgIHZhciBuZXdDb3ZlcnMgPSB0aGlzLl9jb3ZlcnMgPSBbXTtcbiAgICB2YXIgY29udHJvbGxlciA9IHRoaXM7XG4gICAgdmFyIGNyZWF0aW5nQ292ZXIgPSB0aGlzLl9jcmVhdGluZ0NvdmVyO1xuICAgIG5ldyBEYXRhRGlmZmVyKG9sZENvdmVycywgY292ZXJDb25maWdMaXN0LCBvbGRHZXRLZXksIGdldEtleSkuYWRkKGFkZE9yVXBkYXRlKS51cGRhdGUoYWRkT3JVcGRhdGUpLnJlbW92ZShyZW1vdmUpLmV4ZWN1dGUoKTtcbiAgICByZXR1cm4gdGhpcztcblxuICAgIGZ1bmN0aW9uIGdldEtleShicnVzaE9wdGlvbiwgaW5kZXgpIHtcbiAgICAgIHJldHVybiAoYnJ1c2hPcHRpb24uaWQgIT0gbnVsbCA/IGJydXNoT3B0aW9uLmlkIDogdG1wSWRQcmVmaXggKyBpbmRleCkgKyAnLScgKyBicnVzaE9wdGlvbi5icnVzaFR5cGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2xkR2V0S2V5KGNvdmVyLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGdldEtleShjb3Zlci5fX2JydXNoT3B0aW9uLCBpbmRleCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkT3JVcGRhdGUobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gICAgICB2YXIgbmV3QnJ1c2hJbnRlcm5hbCA9IGNvdmVyQ29uZmlnTGlzdFtuZXdJbmRleF07IC8vIENvbnNpZGVyIHNldE9wdGlvbiBpbiBldmVudCBsaXN0ZW5lciBvZiBicnVzaFNlbGVjdCxcbiAgICAgIC8vIHdoZXJlIHVwZGF0aW5nIGNvdmVyIHdoZW4gY3JlYXRpbmcgc2hvdWxkIGJlIGZvcmJpZGVuLlxuXG4gICAgICBpZiAob2xkSW5kZXggIT0gbnVsbCAmJiBvbGRDb3ZlcnNbb2xkSW5kZXhdID09PSBjcmVhdGluZ0NvdmVyKSB7XG4gICAgICAgIG5ld0NvdmVyc1tuZXdJbmRleF0gPSBvbGRDb3ZlcnNbb2xkSW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvdmVyID0gbmV3Q292ZXJzW25ld0luZGV4XSA9IG9sZEluZGV4ICE9IG51bGwgPyAob2xkQ292ZXJzW29sZEluZGV4XS5fX2JydXNoT3B0aW9uID0gbmV3QnJ1c2hJbnRlcm5hbCwgb2xkQ292ZXJzW29sZEluZGV4XSkgOiBlbmRDcmVhdGluZyhjb250cm9sbGVyLCBjcmVhdGVDb3Zlcihjb250cm9sbGVyLCBuZXdCcnVzaEludGVybmFsKSk7XG4gICAgICAgIHVwZGF0ZUNvdmVyQWZ0ZXJDcmVhdGlvbihjb250cm9sbGVyLCBjb3Zlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKG9sZEluZGV4KSB7XG4gICAgICBpZiAob2xkQ292ZXJzW29sZEluZGV4XSAhPT0gY3JlYXRpbmdDb3Zlcikge1xuICAgICAgICBjb250cm9sbGVyLmdyb3VwLnJlbW92ZShvbGRDb3ZlcnNbb2xkSW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQnJ1c2hDb250cm9sbGVyLnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIXRoaXMuX21vdW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZW5hYmxlQnJ1c2goZmFsc2UpOyAvLyBjb250YWluZXIgbWF5ICdyZW1vdmVBbGwnIG91dHNpZGUuXG5cbiAgICBjbGVhckNvdmVycyh0aGlzKTtcblxuICAgIHRoaXMuX3pyLnJlbW92ZSh0aGlzLmdyb3VwKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aGlzLl9tb3VudGVkID0gZmFsc2U7IC8vIHNob3VsZCBiZSBhdCBsYXN0LlxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJydXNoQ29udHJvbGxlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnVubW91bnQoKTtcbiAgICB0aGlzLm9mZigpO1xuICB9O1xuXG4gIHJldHVybiBCcnVzaENvbnRyb2xsZXI7XG59KEV2ZW50ZnVsKTtcblxuZnVuY3Rpb24gY3JlYXRlQ292ZXIoY29udHJvbGxlciwgYnJ1c2hPcHRpb24pIHtcbiAgdmFyIGNvdmVyID0gY292ZXJSZW5kZXJlcnNbYnJ1c2hPcHRpb24uYnJ1c2hUeXBlXS5jcmVhdGVDb3Zlcihjb250cm9sbGVyLCBicnVzaE9wdGlvbik7XG4gIGNvdmVyLl9fYnJ1c2hPcHRpb24gPSBicnVzaE9wdGlvbjtcbiAgdXBkYXRlWihjb3ZlciwgYnJ1c2hPcHRpb24pO1xuICBjb250cm9sbGVyLmdyb3VwLmFkZChjb3Zlcik7XG4gIHJldHVybiBjb3Zlcjtcbn1cblxuZnVuY3Rpb24gZW5kQ3JlYXRpbmcoY29udHJvbGxlciwgY3JlYXRpbmdDb3Zlcikge1xuICB2YXIgY292ZXJSZW5kZXJlciA9IGdldENvdmVyUmVuZGVyZXIoY3JlYXRpbmdDb3Zlcik7XG5cbiAgaWYgKGNvdmVyUmVuZGVyZXIuZW5kQ3JlYXRpbmcpIHtcbiAgICBjb3ZlclJlbmRlcmVyLmVuZENyZWF0aW5nKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIpO1xuICAgIHVwZGF0ZVooY3JlYXRpbmdDb3ZlciwgY3JlYXRpbmdDb3Zlci5fX2JydXNoT3B0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGluZ0NvdmVyO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb3ZlclNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyKSB7XG4gIHZhciBicnVzaE9wdGlvbiA9IGNvdmVyLl9fYnJ1c2hPcHRpb247XG4gIGdldENvdmVyUmVuZGVyZXIoY292ZXIpLnVwZGF0ZUNvdmVyU2hhcGUoY29udHJvbGxlciwgY292ZXIsIGJydXNoT3B0aW9uLnJhbmdlLCBicnVzaE9wdGlvbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVooY292ZXIsIGJydXNoT3B0aW9uKSB7XG4gIHZhciB6ID0gYnJ1c2hPcHRpb24uejtcbiAgeiA9PSBudWxsICYmICh6ID0gQ09WRVJfWik7XG4gIGNvdmVyLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgIGVsLnogPSB6O1xuICAgIGVsLnoyID0gejsgLy8gQ29uc2lkZXIgaW4gZ2l2ZW4gY29udGFpbmVyLlxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ292ZXJBZnRlckNyZWF0aW9uKGNvbnRyb2xsZXIsIGNvdmVyKSB7XG4gIGdldENvdmVyUmVuZGVyZXIoY292ZXIpLnVwZGF0ZUNvbW1vbihjb250cm9sbGVyLCBjb3Zlcik7XG4gIHVwZGF0ZUNvdmVyU2hhcGUoY29udHJvbGxlciwgY292ZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRDb3ZlclJlbmRlcmVyKGNvdmVyKSB7XG4gIHJldHVybiBjb3ZlclJlbmRlcmVyc1tjb3Zlci5fX2JydXNoT3B0aW9uLmJydXNoVHlwZV07XG59IC8vIHJldHVybiB0YXJnZXQgcGFuZWwgb3IgYHRydWVgIChtZWFucyBnbG9iYWwgcGFuZWwpXG5cblxuZnVuY3Rpb24gZ2V0UGFuZWxCeVBvaW50KGNvbnRyb2xsZXIsIGUsIGxvY2FsQ3Vyc29yUG9pbnQpIHtcbiAgdmFyIHBhbmVscyA9IGNvbnRyb2xsZXIuX3BhbmVscztcblxuICBpZiAoIXBhbmVscykge1xuICAgIHJldHVybiBCUlVTSF9QQU5FTF9HTE9CQUw7IC8vIEdsb2JhbCBwYW5lbFxuICB9XG5cbiAgdmFyIHBhbmVsO1xuICB2YXIgdHJhbnNmb3JtID0gY29udHJvbGxlci5fdHJhbnNmb3JtO1xuICBlYWNoKHBhbmVscywgZnVuY3Rpb24gKHBuKSB7XG4gICAgcG4uaXNUYXJnZXRCeUN1cnNvcihlLCBsb2NhbEN1cnNvclBvaW50LCB0cmFuc2Zvcm0pICYmIChwYW5lbCA9IHBuKTtcbiAgfSk7XG4gIHJldHVybiBwYW5lbDtcbn0gLy8gUmV0dXJuIGEgcGFuZWwgb3IgdHJ1ZVxuXG5cbmZ1bmN0aW9uIGdldFBhbmVsQnlDb3Zlcihjb250cm9sbGVyLCBjb3Zlcikge1xuICB2YXIgcGFuZWxzID0gY29udHJvbGxlci5fcGFuZWxzO1xuXG4gIGlmICghcGFuZWxzKSB7XG4gICAgcmV0dXJuIEJSVVNIX1BBTkVMX0dMT0JBTDsgLy8gR2xvYmFsIHBhbmVsXG4gIH1cblxuICB2YXIgcGFuZWxJZCA9IGNvdmVyLl9fYnJ1c2hPcHRpb24ucGFuZWxJZDsgLy8gVXNlciBtYXkgZ2l2ZSBjb3ZlciB3aXRob3V0IGNvb3JkIHN5cyBpbmZvLFxuICAvLyB3aGljaCBpcyB0aGVuIHRyZWF0ZWQgYXMgZ2xvYmFsIHBhbmVsLlxuXG4gIHJldHVybiBwYW5lbElkICE9IG51bGwgPyBwYW5lbHNbcGFuZWxJZF0gOiBCUlVTSF9QQU5FTF9HTE9CQUw7XG59XG5cbmZ1bmN0aW9uIGNsZWFyQ292ZXJzKGNvbnRyb2xsZXIpIHtcbiAgdmFyIGNvdmVycyA9IGNvbnRyb2xsZXIuX2NvdmVycztcbiAgdmFyIG9yaWdpbmFsTGVuZ3RoID0gY292ZXJzLmxlbmd0aDtcbiAgZWFjaChjb3ZlcnMsIGZ1bmN0aW9uIChjb3Zlcikge1xuICAgIGNvbnRyb2xsZXIuZ3JvdXAucmVtb3ZlKGNvdmVyKTtcbiAgfSwgY29udHJvbGxlcik7XG4gIGNvdmVycy5sZW5ndGggPSAwO1xuICByZXR1cm4gISFvcmlnaW5hbExlbmd0aDtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlcihjb250cm9sbGVyLCBvcHQpIHtcbiAgdmFyIGFyZWFzID0gbWFwKGNvbnRyb2xsZXIuX2NvdmVycywgZnVuY3Rpb24gKGNvdmVyKSB7XG4gICAgdmFyIGJydXNoT3B0aW9uID0gY292ZXIuX19icnVzaE9wdGlvbjtcbiAgICB2YXIgcmFuZ2UgPSBjbG9uZShicnVzaE9wdGlvbi5yYW5nZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJydXNoVHlwZTogYnJ1c2hPcHRpb24uYnJ1c2hUeXBlLFxuICAgICAgcGFuZWxJZDogYnJ1c2hPcHRpb24ucGFuZWxJZCxcbiAgICAgIHJhbmdlOiByYW5nZVxuICAgIH07XG4gIH0pO1xuICBjb250cm9sbGVyLnRyaWdnZXIoJ2JydXNoJywge1xuICAgIGFyZWFzOiBhcmVhcyxcbiAgICBpc0VuZDogISFvcHQuaXNFbmQsXG4gICAgcmVtb3ZlT25DbGljazogISFvcHQucmVtb3ZlT25DbGlja1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkU2hvd0NvdmVyKGNvbnRyb2xsZXIpIHtcbiAgdmFyIHRyYWNrID0gY29udHJvbGxlci5fdHJhY2s7XG5cbiAgaWYgKCF0cmFjay5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcDIgPSB0cmFja1t0cmFjay5sZW5ndGggLSAxXTtcbiAgdmFyIHAxID0gdHJhY2tbMF07XG4gIHZhciBkeCA9IHAyWzBdIC0gcDFbMF07XG4gIHZhciBkeSA9IHAyWzFdIC0gcDFbMV07XG4gIHZhciBkaXN0ID0gbWF0aFBvdyhkeCAqIGR4ICsgZHkgKiBkeSwgMC41KTtcbiAgcmV0dXJuIGRpc3QgPiBVTlNFTEVDVF9USFJFU0hPTEQ7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNrRW5kcyh0cmFjaykge1xuICB2YXIgdGFpbCA9IHRyYWNrLmxlbmd0aCAtIDE7XG4gIHRhaWwgPCAwICYmICh0YWlsID0gMCk7XG4gIHJldHVybiBbdHJhY2tbMF0sIHRyYWNrW3RhaWxdXTtcbn1cblxuO1xuXG5mdW5jdGlvbiBjcmVhdGVCYXNlUmVjdENvdmVyKHJlY3RSYW5nZUNvbnZlcnRlciwgY29udHJvbGxlciwgYnJ1c2hPcHRpb24sIGVkZ2VOYW1lU2VxdWVuY2VzKSB7XG4gIHZhciBjb3ZlciA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gIGNvdmVyLmFkZChuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICBuYW1lOiAnbWFpbicsXG4gICAgc3R5bGU6IG1ha2VTdHlsZShicnVzaE9wdGlvbiksXG4gICAgc2lsZW50OiB0cnVlLFxuICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICBjdXJzb3I6ICdtb3ZlJyxcbiAgICBkcmlmdDogY3VycnkoZHJpZnRSZWN0LCByZWN0UmFuZ2VDb252ZXJ0ZXIsIGNvbnRyb2xsZXIsIGNvdmVyLCBbJ24nLCAncycsICd3JywgJ2UnXSksXG4gICAgb25kcmFnZW5kOiBjdXJyeSh0cmlnZ2VyLCBjb250cm9sbGVyLCB7XG4gICAgICBpc0VuZDogdHJ1ZVxuICAgIH0pXG4gIH0pKTtcbiAgZWFjaChlZGdlTmFtZVNlcXVlbmNlcywgZnVuY3Rpb24gKG5hbWVTZXF1ZW5jZSkge1xuICAgIGNvdmVyLmFkZChuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgIG5hbWU6IG5hbWVTZXF1ZW5jZS5qb2luKCcnKSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0sXG4gICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICBpbnZpc2libGU6IHRydWUsXG4gICAgICBkcmlmdDogY3VycnkoZHJpZnRSZWN0LCByZWN0UmFuZ2VDb252ZXJ0ZXIsIGNvbnRyb2xsZXIsIGNvdmVyLCBuYW1lU2VxdWVuY2UpLFxuICAgICAgb25kcmFnZW5kOiBjdXJyeSh0cmlnZ2VyLCBjb250cm9sbGVyLCB7XG4gICAgICAgIGlzRW5kOiB0cnVlXG4gICAgICB9KVxuICAgIH0pKTtcbiAgfSk7XG4gIHJldHVybiBjb3Zlcjtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQmFzZVJlY3QoY29udHJvbGxlciwgY292ZXIsIGxvY2FsUmFuZ2UsIGJydXNoT3B0aW9uKSB7XG4gIHZhciBsaW5lV2lkdGggPSBicnVzaE9wdGlvbi5icnVzaFN0eWxlLmxpbmVXaWR0aCB8fCAwO1xuICB2YXIgaGFuZGxlU2l6ZSA9IG1hdGhNYXgobGluZVdpZHRoLCBNSU5fUkVTSVpFX0xJTkVfV0lEVEgpO1xuICB2YXIgeCA9IGxvY2FsUmFuZ2VbMF1bMF07XG4gIHZhciB5ID0gbG9jYWxSYW5nZVsxXVswXTtcbiAgdmFyIHhhID0geCAtIGxpbmVXaWR0aCAvIDI7XG4gIHZhciB5YSA9IHkgLSBsaW5lV2lkdGggLyAyO1xuICB2YXIgeDIgPSBsb2NhbFJhbmdlWzBdWzFdO1xuICB2YXIgeTIgPSBsb2NhbFJhbmdlWzFdWzFdO1xuICB2YXIgeDJhID0geDIgLSBoYW5kbGVTaXplICsgbGluZVdpZHRoIC8gMjtcbiAgdmFyIHkyYSA9IHkyIC0gaGFuZGxlU2l6ZSArIGxpbmVXaWR0aCAvIDI7XG4gIHZhciB3aWR0aCA9IHgyIC0geDtcbiAgdmFyIGhlaWdodCA9IHkyIC0geTtcbiAgdmFyIHdpZHRoYSA9IHdpZHRoICsgbGluZVdpZHRoO1xuICB2YXIgaGVpZ2h0YSA9IGhlaWdodCArIGxpbmVXaWR0aDtcbiAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnbWFpbicsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXG4gIGlmIChicnVzaE9wdGlvbi50cmFuc2Zvcm1hYmxlKSB7XG4gICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAndycsIHhhLCB5YSwgaGFuZGxlU2l6ZSwgaGVpZ2h0YSk7XG4gICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnZScsIHgyYSwgeWEsIGhhbmRsZVNpemUsIGhlaWdodGEpO1xuICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ24nLCB4YSwgeWEsIHdpZHRoYSwgaGFuZGxlU2l6ZSk7XG4gICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAncycsIHhhLCB5MmEsIHdpZHRoYSwgaGFuZGxlU2l6ZSk7XG4gICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnbncnLCB4YSwgeWEsIGhhbmRsZVNpemUsIGhhbmRsZVNpemUpO1xuICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ25lJywgeDJhLCB5YSwgaGFuZGxlU2l6ZSwgaGFuZGxlU2l6ZSk7XG4gICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnc3cnLCB4YSwgeTJhLCBoYW5kbGVTaXplLCBoYW5kbGVTaXplKTtcbiAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdzZScsIHgyYSwgeTJhLCBoYW5kbGVTaXplLCBoYW5kbGVTaXplKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21tb24oY29udHJvbGxlciwgY292ZXIpIHtcbiAgdmFyIGJydXNoT3B0aW9uID0gY292ZXIuX19icnVzaE9wdGlvbjtcbiAgdmFyIHRyYW5zZm9ybWFibGUgPSBicnVzaE9wdGlvbi50cmFuc2Zvcm1hYmxlO1xuICB2YXIgbWFpbkVsID0gY292ZXIuY2hpbGRBdCgwKTtcbiAgbWFpbkVsLnVzZVN0eWxlKG1ha2VTdHlsZShicnVzaE9wdGlvbikpO1xuICBtYWluRWwuYXR0cih7XG4gICAgc2lsZW50OiAhdHJhbnNmb3JtYWJsZSxcbiAgICBjdXJzb3I6IHRyYW5zZm9ybWFibGUgPyAnbW92ZScgOiAnZGVmYXVsdCdcbiAgfSk7XG4gIGVhY2goW1sndyddLCBbJ2UnXSwgWyduJ10sIFsncyddLCBbJ3MnLCAnZSddLCBbJ3MnLCAndyddLCBbJ24nLCAnZSddLCBbJ24nLCAndyddXSwgZnVuY3Rpb24gKG5hbWVTZXF1ZW5jZSkge1xuICAgIHZhciBlbCA9IGNvdmVyLmNoaWxkT2ZOYW1lKG5hbWVTZXF1ZW5jZS5qb2luKCcnKSk7XG4gICAgdmFyIGdsb2JhbERpciA9IG5hbWVTZXF1ZW5jZS5sZW5ndGggPT09IDEgPyBnZXRHbG9iYWxEaXJlY3Rpb24xKGNvbnRyb2xsZXIsIG5hbWVTZXF1ZW5jZVswXSkgOiBnZXRHbG9iYWxEaXJlY3Rpb24yKGNvbnRyb2xsZXIsIG5hbWVTZXF1ZW5jZSk7XG4gICAgZWwgJiYgZWwuYXR0cih7XG4gICAgICBzaWxlbnQ6ICF0cmFuc2Zvcm1hYmxlLFxuICAgICAgaW52aXNpYmxlOiAhdHJhbnNmb3JtYWJsZSxcbiAgICAgIGN1cnNvcjogdHJhbnNmb3JtYWJsZSA/IENVUlNPUl9NQVBbZ2xvYmFsRGlyXSArICctcmVzaXplJyA6IG51bGxcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgbmFtZSwgeCwgeSwgdywgaCkge1xuICB2YXIgZWwgPSBjb3Zlci5jaGlsZE9mTmFtZShuYW1lKTtcbiAgZWwgJiYgZWwuc2V0U2hhcGUocG9pbnRzVG9SZWN0KGNsaXBCeVBhbmVsKGNvbnRyb2xsZXIsIGNvdmVyLCBbW3gsIHldLCBbeCArIHcsIHkgKyBoXV0pKSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VTdHlsZShicnVzaE9wdGlvbikge1xuICByZXR1cm4gZGVmYXVsdHMoe1xuICAgIHN0cm9rZU5vU2NhbGU6IHRydWVcbiAgfSwgYnJ1c2hPcHRpb24uYnJ1c2hTdHlsZSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFJlY3RSYW5nZSh4LCB5LCB4MiwgeTIpIHtcbiAgdmFyIG1pbiA9IFttYXRoTWluKHgsIHgyKSwgbWF0aE1pbih5LCB5MildO1xuICB2YXIgbWF4ID0gW21hdGhNYXgoeCwgeDIpLCBtYXRoTWF4KHksIHkyKV07XG4gIHJldHVybiBbW21pblswXSwgbWF4WzBdXSwgW21pblsxXSwgbWF4WzFdXSAvLyB5IHJhbmdlXG4gIF07XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybShjb250cm9sbGVyKSB7XG4gIHJldHVybiBncmFwaGljLmdldFRyYW5zZm9ybShjb250cm9sbGVyLmdyb3VwKTtcbn1cblxuZnVuY3Rpb24gZ2V0R2xvYmFsRGlyZWN0aW9uMShjb250cm9sbGVyLCBsb2NhbERpck5hbWUpIHtcbiAgdmFyIG1hcCA9IHtcbiAgICB3OiAnbGVmdCcsXG4gICAgZTogJ3JpZ2h0JyxcbiAgICBuOiAndG9wJyxcbiAgICBzOiAnYm90dG9tJ1xuICB9O1xuICB2YXIgaW52ZXJzZU1hcCA9IHtcbiAgICBsZWZ0OiAndycsXG4gICAgcmlnaHQ6ICdlJyxcbiAgICB0b3A6ICduJyxcbiAgICBib3R0b206ICdzJ1xuICB9O1xuICB2YXIgZGlyID0gZ3JhcGhpYy50cmFuc2Zvcm1EaXJlY3Rpb24obWFwW2xvY2FsRGlyTmFtZV0sIGdldFRyYW5zZm9ybShjb250cm9sbGVyKSk7XG4gIHJldHVybiBpbnZlcnNlTWFwW2Rpcl07XG59XG5cbmZ1bmN0aW9uIGdldEdsb2JhbERpcmVjdGlvbjIoY29udHJvbGxlciwgbG9jYWxEaXJOYW1lU2VxKSB7XG4gIHZhciBnbG9iYWxEaXIgPSBbZ2V0R2xvYmFsRGlyZWN0aW9uMShjb250cm9sbGVyLCBsb2NhbERpck5hbWVTZXFbMF0pLCBnZXRHbG9iYWxEaXJlY3Rpb24xKGNvbnRyb2xsZXIsIGxvY2FsRGlyTmFtZVNlcVsxXSldO1xuICAoZ2xvYmFsRGlyWzBdID09PSAnZScgfHwgZ2xvYmFsRGlyWzBdID09PSAndycpICYmIGdsb2JhbERpci5yZXZlcnNlKCk7XG4gIHJldHVybiBnbG9iYWxEaXIuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGRyaWZ0UmVjdChyZWN0UmFuZ2VDb252ZXJ0ZXIsIGNvbnRyb2xsZXIsIGNvdmVyLCBkaXJOYW1lU2VxdWVuY2UsIGR4LCBkeSkge1xuICB2YXIgYnJ1c2hPcHRpb24gPSBjb3Zlci5fX2JydXNoT3B0aW9uO1xuICB2YXIgcmVjdFJhbmdlID0gcmVjdFJhbmdlQ29udmVydGVyLnRvUmVjdFJhbmdlKGJydXNoT3B0aW9uLnJhbmdlKTtcbiAgdmFyIGxvY2FsRGVsdGEgPSB0b0xvY2FsRGVsdGEoY29udHJvbGxlciwgZHgsIGR5KTtcbiAgZWFjaChkaXJOYW1lU2VxdWVuY2UsIGZ1bmN0aW9uIChkaXJOYW1lKSB7XG4gICAgdmFyIGluZCA9IERJUkVDVElPTl9NQVBbZGlyTmFtZV07XG4gICAgcmVjdFJhbmdlW2luZFswXV1baW5kWzFdXSArPSBsb2NhbERlbHRhW2luZFswXV07XG4gIH0pO1xuICBicnVzaE9wdGlvbi5yYW5nZSA9IHJlY3RSYW5nZUNvbnZlcnRlci5mcm9tUmVjdFJhbmdlKGZvcm1hdFJlY3RSYW5nZShyZWN0UmFuZ2VbMF1bMF0sIHJlY3RSYW5nZVsxXVswXSwgcmVjdFJhbmdlWzBdWzFdLCByZWN0UmFuZ2VbMV1bMV0pKTtcbiAgdXBkYXRlQ292ZXJBZnRlckNyZWF0aW9uKGNvbnRyb2xsZXIsIGNvdmVyKTtcbiAgdHJpZ2dlcihjb250cm9sbGVyLCB7XG4gICAgaXNFbmQ6IGZhbHNlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkcmlmdFBvbHlnb24oY29udHJvbGxlciwgY292ZXIsIGR4LCBkeSkge1xuICB2YXIgcmFuZ2UgPSBjb3Zlci5fX2JydXNoT3B0aW9uLnJhbmdlO1xuICB2YXIgbG9jYWxEZWx0YSA9IHRvTG9jYWxEZWx0YShjb250cm9sbGVyLCBkeCwgZHkpO1xuICBlYWNoKHJhbmdlLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICBwb2ludFswXSArPSBsb2NhbERlbHRhWzBdO1xuICAgIHBvaW50WzFdICs9IGxvY2FsRGVsdGFbMV07XG4gIH0pO1xuICB1cGRhdGVDb3ZlckFmdGVyQ3JlYXRpb24oY29udHJvbGxlciwgY292ZXIpO1xuICB0cmlnZ2VyKGNvbnRyb2xsZXIsIHtcbiAgICBpc0VuZDogZmFsc2VcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRvTG9jYWxEZWx0YShjb250cm9sbGVyLCBkeCwgZHkpIHtcbiAgdmFyIHRoaXNHcm91cCA9IGNvbnRyb2xsZXIuZ3JvdXA7XG4gIHZhciBsb2NhbEQgPSB0aGlzR3JvdXAudHJhbnNmb3JtQ29vcmRUb0xvY2FsKGR4LCBkeSk7XG4gIHZhciBsb2NhbFplcm8gPSB0aGlzR3JvdXAudHJhbnNmb3JtQ29vcmRUb0xvY2FsKDAsIDApO1xuICByZXR1cm4gW2xvY2FsRFswXSAtIGxvY2FsWmVyb1swXSwgbG9jYWxEWzFdIC0gbG9jYWxaZXJvWzFdXTtcbn1cblxuZnVuY3Rpb24gY2xpcEJ5UGFuZWwoY29udHJvbGxlciwgY292ZXIsIGRhdGEpIHtcbiAgdmFyIHBhbmVsID0gZ2V0UGFuZWxCeUNvdmVyKGNvbnRyb2xsZXIsIGNvdmVyKTtcbiAgcmV0dXJuIHBhbmVsICYmIHBhbmVsICE9PSBCUlVTSF9QQU5FTF9HTE9CQUwgPyBwYW5lbC5jbGlwUGF0aChkYXRhLCBjb250cm9sbGVyLl90cmFuc2Zvcm0pIDogY2xvbmUoZGF0YSk7XG59XG5cbmZ1bmN0aW9uIHBvaW50c1RvUmVjdChwb2ludHMpIHtcbiAgdmFyIHhtaW4gPSBtYXRoTWluKHBvaW50c1swXVswXSwgcG9pbnRzWzFdWzBdKTtcbiAgdmFyIHltaW4gPSBtYXRoTWluKHBvaW50c1swXVsxXSwgcG9pbnRzWzFdWzFdKTtcbiAgdmFyIHhtYXggPSBtYXRoTWF4KHBvaW50c1swXVswXSwgcG9pbnRzWzFdWzBdKTtcbiAgdmFyIHltYXggPSBtYXRoTWF4KHBvaW50c1swXVsxXSwgcG9pbnRzWzFdWzFdKTtcbiAgcmV0dXJuIHtcbiAgICB4OiB4bWluLFxuICAgIHk6IHltaW4sXG4gICAgd2lkdGg6IHhtYXggLSB4bWluLFxuICAgIGhlaWdodDogeW1heCAtIHltaW5cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzZXRDdXJzb3IoY29udHJvbGxlciwgZSwgbG9jYWxDdXJzb3JQb2ludCkge1xuICBpZiAoIC8vIENoZWNrIGFjdGl2ZVxuICAhY29udHJvbGxlci5fYnJ1c2hUeXBlIC8vIHJlc2V0Q3Vyc29yIHNob3VsZCBiZSBhbHdheXMgY2FsbGVkIHdoZW4gbW91c2UgaXMgaW4genIgYXJlYSxcbiAgLy8gYnV0IG5vdCBjYWxsZWQgd2hlbiBtb3VzZSBpcyBvdXQgb2YgenIgYXJlYSB0byBhdm9pZCBiYWQgaW5mbHVlbmNlXG4gIC8vIGlmIGBtb3VzZW1vdmVgLCBgbW91c2V1cGAgYXJlIHRyaWdnZXJlZCBmcm9tIGBkb2N1bWVudGAgZXZlbnQuXG4gIHx8IGlzT3V0c2lkZVpyQXJlYShjb250cm9sbGVyLCBlLm9mZnNldFgsIGUub2Zmc2V0WSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgenIgPSBjb250cm9sbGVyLl96cjtcbiAgdmFyIGNvdmVycyA9IGNvbnRyb2xsZXIuX2NvdmVycztcbiAgdmFyIGN1cnJQYW5lbCA9IGdldFBhbmVsQnlQb2ludChjb250cm9sbGVyLCBlLCBsb2NhbEN1cnNvclBvaW50KTsgLy8gQ2hlY2sgd2hldGhlciBpbiBjb3ZlcnMuXG5cbiAgaWYgKCFjb250cm9sbGVyLl9kcmFnZ2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY292ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYnJ1c2hPcHRpb24gPSBjb3ZlcnNbaV0uX19icnVzaE9wdGlvbjtcblxuICAgICAgaWYgKGN1cnJQYW5lbCAmJiAoY3VyclBhbmVsID09PSBCUlVTSF9QQU5FTF9HTE9CQUwgfHwgYnJ1c2hPcHRpb24ucGFuZWxJZCA9PT0gY3VyclBhbmVsLnBhbmVsSWQpICYmIGNvdmVyUmVuZGVyZXJzW2JydXNoT3B0aW9uLmJydXNoVHlwZV0uY29udGFpbihjb3ZlcnNbaV0sIGxvY2FsQ3Vyc29yUG9pbnRbMF0sIGxvY2FsQ3Vyc29yUG9pbnRbMV0pKSB7XG4gICAgICAgIC8vIFVzZSBjdXJzb3Igc3R5bGUgc2V0IG9uIGNvdmVyLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3VyclBhbmVsICYmIHpyLnNldEN1cnNvclN0eWxlKCdjcm9zc2hhaXInKTtcbn1cblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xuICB2YXIgcmF3RSA9IGUuZXZlbnQ7XG4gIHJhd0UucHJldmVudERlZmF1bHQgJiYgcmF3RS5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5mdW5jdGlvbiBtYWluU2hhcGVDb250YWluKGNvdmVyLCB4LCB5KSB7XG4gIHJldHVybiBjb3Zlci5jaGlsZE9mTmFtZSgnbWFpbicpLmNvbnRhaW4oeCwgeSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvdmVyQnlNb3VzZShjb250cm9sbGVyLCBlLCBsb2NhbEN1cnNvclBvaW50LCBpc0VuZCkge1xuICB2YXIgY3JlYXRpbmdDb3ZlciA9IGNvbnRyb2xsZXIuX2NyZWF0aW5nQ292ZXI7XG4gIHZhciBwYW5lbCA9IGNvbnRyb2xsZXIuX2NyZWF0aW5nUGFuZWw7XG4gIHZhciB0aGlzQnJ1c2hPcHRpb24gPSBjb250cm9sbGVyLl9icnVzaE9wdGlvbjtcbiAgdmFyIGV2ZW50UGFyYW1zO1xuXG4gIGNvbnRyb2xsZXIuX3RyYWNrLnB1c2gobG9jYWxDdXJzb3JQb2ludC5zbGljZSgpKTtcblxuICBpZiAoc2hvdWxkU2hvd0NvdmVyKGNvbnRyb2xsZXIpIHx8IGNyZWF0aW5nQ292ZXIpIHtcbiAgICBpZiAocGFuZWwgJiYgIWNyZWF0aW5nQ292ZXIpIHtcbiAgICAgIHRoaXNCcnVzaE9wdGlvbi5icnVzaE1vZGUgPT09ICdzaW5nbGUnICYmIGNsZWFyQ292ZXJzKGNvbnRyb2xsZXIpO1xuICAgICAgdmFyIGJydXNoT3B0aW9uID0gY2xvbmUodGhpc0JydXNoT3B0aW9uKTtcbiAgICAgIGJydXNoT3B0aW9uLmJydXNoVHlwZSA9IGRldGVybWluZUJydXNoVHlwZShicnVzaE9wdGlvbi5icnVzaFR5cGUsIHBhbmVsKTtcbiAgICAgIGJydXNoT3B0aW9uLnBhbmVsSWQgPSBwYW5lbCA9PT0gQlJVU0hfUEFORUxfR0xPQkFMID8gbnVsbCA6IHBhbmVsLnBhbmVsSWQ7XG4gICAgICBjcmVhdGluZ0NvdmVyID0gY29udHJvbGxlci5fY3JlYXRpbmdDb3ZlciA9IGNyZWF0ZUNvdmVyKGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uKTtcblxuICAgICAgY29udHJvbGxlci5fY292ZXJzLnB1c2goY3JlYXRpbmdDb3Zlcik7XG4gICAgfVxuXG4gICAgaWYgKGNyZWF0aW5nQ292ZXIpIHtcbiAgICAgIHZhciBjb3ZlclJlbmRlcmVyID0gY292ZXJSZW5kZXJlcnNbZGV0ZXJtaW5lQnJ1c2hUeXBlKGNvbnRyb2xsZXIuX2JydXNoVHlwZSwgcGFuZWwpXTtcbiAgICAgIHZhciBjb3ZlckJydXNoT3B0aW9uID0gY3JlYXRpbmdDb3Zlci5fX2JydXNoT3B0aW9uO1xuICAgICAgY292ZXJCcnVzaE9wdGlvbi5yYW5nZSA9IGNvdmVyUmVuZGVyZXIuZ2V0Q3JlYXRpbmdSYW5nZShjbGlwQnlQYW5lbChjb250cm9sbGVyLCBjcmVhdGluZ0NvdmVyLCBjb250cm9sbGVyLl90cmFjaykpO1xuXG4gICAgICBpZiAoaXNFbmQpIHtcbiAgICAgICAgZW5kQ3JlYXRpbmcoY29udHJvbGxlciwgY3JlYXRpbmdDb3Zlcik7XG4gICAgICAgIGNvdmVyUmVuZGVyZXIudXBkYXRlQ29tbW9uKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVDb3ZlclNoYXBlKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIpO1xuICAgICAgZXZlbnRQYXJhbXMgPSB7XG4gICAgICAgIGlzRW5kOiBpc0VuZFxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbmQgJiYgdGhpc0JydXNoT3B0aW9uLmJydXNoTW9kZSA9PT0gJ3NpbmdsZScgJiYgdGhpc0JydXNoT3B0aW9uLnJlbW92ZU9uQ2xpY2spIHtcbiAgICAvLyBIZWxwIHVzZXIgdG8gcmVtb3ZlIGNvdmVycyBlYXNpbHksIG9ubHkgYnkgYSB0aW55IGRyYWcsIGluICdzaW5nbGUnIG1vZGUuXG4gICAgLy8gQnV0IGEgc2luZ2xlIGNsaWNrIGRvIG5vdCBjbGVhciBjb3ZlcnMsIGJlY2F1c2UgdXNlciBtYXkgaGF2ZSBjYXN1YWxcbiAgICAvLyBjbGlja3MgKGZvciBleGFtcGxlLCBjbGljayBvbiBvdGhlciBjb21wb25lbnQgYW5kIGRvIG5vdCBleHBlY3QgY292ZXJzXG4gICAgLy8gZGlzYXBwZWFyKS5cbiAgICAvLyBPbmx5IHNvbWUgY292ZXIgcmVtb3ZlZCwgdHJpZ2dlciBhY3Rpb24sIGJ1dCBub3QgZXZlcnkgY2xpY2sgdHJpZ2dlciBhY3Rpb24uXG4gICAgaWYgKGdldFBhbmVsQnlQb2ludChjb250cm9sbGVyLCBlLCBsb2NhbEN1cnNvclBvaW50KSAmJiBjbGVhckNvdmVycyhjb250cm9sbGVyKSkge1xuICAgICAgZXZlbnRQYXJhbXMgPSB7XG4gICAgICAgIGlzRW5kOiBpc0VuZCxcbiAgICAgICAgcmVtb3ZlT25DbGljazogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnRQYXJhbXM7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZUJydXNoVHlwZShicnVzaFR5cGUsIHBhbmVsKSB7XG4gIGlmIChicnVzaFR5cGUgPT09ICdhdXRvJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnQocGFuZWwgJiYgcGFuZWwuZGVmYXVsdEJydXNoVHlwZSwgJ01VU1QgaGF2ZSBkZWZhdWx0QnJ1c2hUeXBlIHdoZW4gYnJ1c2hUeXBlIGlzIFwiYXR1b1wiJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhbmVsLmRlZmF1bHRCcnVzaFR5cGU7XG4gIH1cblxuICByZXR1cm4gYnJ1c2hUeXBlO1xufVxuXG52YXIgcG9pbnRlckhhbmRsZXJzID0ge1xuICBtb3VzZWRvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHRoaXMuX2RyYWdnaW5nKSB7XG4gICAgICAvLyBJbiBjYXNlIHNvbWUgYnJvd3NlciBkbyBub3Qgc3VwcG9ydCBnbG9iYWxPdXQsXG4gICAgICAvLyBhbmQgcmVsZWFzZSBtb3VzZSBvdXQgc2lkZSB0aGUgYnJvd3Nlci5cbiAgICAgIGhhbmRsZURyYWdFbmQodGhpcywgZSk7XG4gICAgfSBlbHNlIGlmICghZS50YXJnZXQgfHwgIWUudGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICB2YXIgbG9jYWxDdXJzb3JQb2ludCA9IHRoaXMuZ3JvdXAudHJhbnNmb3JtQ29vcmRUb0xvY2FsKGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcbiAgICAgIHRoaXMuX2NyZWF0aW5nQ292ZXIgPSBudWxsO1xuICAgICAgdmFyIHBhbmVsID0gdGhpcy5fY3JlYXRpbmdQYW5lbCA9IGdldFBhbmVsQnlQb2ludCh0aGlzLCBlLCBsb2NhbEN1cnNvclBvaW50KTtcblxuICAgICAgaWYgKHBhbmVsKSB7XG4gICAgICAgIHRoaXMuX2RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdHJhY2sgPSBbbG9jYWxDdXJzb3JQb2ludC5zbGljZSgpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdXNlbW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgICB2YXIgeSA9IGUub2Zmc2V0WTtcbiAgICB2YXIgbG9jYWxDdXJzb3JQb2ludCA9IHRoaXMuZ3JvdXAudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgIHJlc2V0Q3Vyc29yKHRoaXMsIGUsIGxvY2FsQ3Vyc29yUG9pbnQpO1xuXG4gICAgaWYgKHRoaXMuX2RyYWdnaW5nKSB7XG4gICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIHZhciBldmVudFBhcmFtcyA9IHVwZGF0ZUNvdmVyQnlNb3VzZSh0aGlzLCBlLCBsb2NhbEN1cnNvclBvaW50LCBmYWxzZSk7XG4gICAgICBldmVudFBhcmFtcyAmJiB0cmlnZ2VyKHRoaXMsIGV2ZW50UGFyYW1zKTtcbiAgICB9XG4gIH0sXG4gIG1vdXNldXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgaGFuZGxlRHJhZ0VuZCh0aGlzLCBlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaGFuZGxlRHJhZ0VuZChjb250cm9sbGVyLCBlKSB7XG4gIGlmIChjb250cm9sbGVyLl9kcmFnZ2luZykge1xuICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgIHZhciB4ID0gZS5vZmZzZXRYO1xuICAgIHZhciB5ID0gZS5vZmZzZXRZO1xuICAgIHZhciBsb2NhbEN1cnNvclBvaW50ID0gY29udHJvbGxlci5ncm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgdmFyIGV2ZW50UGFyYW1zID0gdXBkYXRlQ292ZXJCeU1vdXNlKGNvbnRyb2xsZXIsIGUsIGxvY2FsQ3Vyc29yUG9pbnQsIHRydWUpO1xuICAgIGNvbnRyb2xsZXIuX2RyYWdnaW5nID0gZmFsc2U7XG4gICAgY29udHJvbGxlci5fdHJhY2sgPSBbXTtcbiAgICBjb250cm9sbGVyLl9jcmVhdGluZ0NvdmVyID0gbnVsbDsgLy8gdHJpZ2dlciBldmVudCBzaG91bGUgYmUgYXQgZmluYWwsIGFmdGVyIHByb2NlZHVyZSB3aWxsIGJlIG5lc3RlZC5cblxuICAgIGV2ZW50UGFyYW1zICYmIHRyaWdnZXIoY29udHJvbGxlciwgZXZlbnRQYXJhbXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzT3V0c2lkZVpyQXJlYShjb250cm9sbGVyLCB4LCB5KSB7XG4gIHZhciB6ciA9IGNvbnRyb2xsZXIuX3pyO1xuICByZXR1cm4geCA8IDAgfHwgeCA+IHpyLmdldFdpZHRoKCkgfHwgeSA8IDAgfHwgeSA+IHpyLmdldEhlaWdodCgpO1xufVxuLyoqXG4gKiBrZXk6IGJydXNoVHlwZVxuICovXG5cblxudmFyIGNvdmVyUmVuZGVyZXJzID0ge1xuICBsaW5lWDogZ2V0TGluZVJlbmRlcmVyKDApLFxuICBsaW5lWTogZ2V0TGluZVJlbmRlcmVyKDEpLFxuICByZWN0OiB7XG4gICAgY3JlYXRlQ292ZXI6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBicnVzaE9wdGlvbikge1xuICAgICAgZnVuY3Rpb24gcmV0dXJuSW5wdXQocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlQmFzZVJlY3RDb3Zlcih7XG4gICAgICAgIHRvUmVjdFJhbmdlOiByZXR1cm5JbnB1dCxcbiAgICAgICAgZnJvbVJlY3RSYW5nZTogcmV0dXJuSW5wdXRcbiAgICAgIH0sIGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uLCBbWyd3J10sIFsnZSddLCBbJ24nXSwgWydzJ10sIFsncycsICdlJ10sIFsncycsICd3J10sIFsnbicsICdlJ10sIFsnbicsICd3J11dKTtcbiAgICB9LFxuICAgIGdldENyZWF0aW5nUmFuZ2U6IGZ1bmN0aW9uIChsb2NhbFRyYWNrKSB7XG4gICAgICB2YXIgZW5kcyA9IGdldFRyYWNrRW5kcyhsb2NhbFRyYWNrKTtcbiAgICAgIHJldHVybiBmb3JtYXRSZWN0UmFuZ2UoZW5kc1sxXVswXSwgZW5kc1sxXVsxXSwgZW5kc1swXVswXSwgZW5kc1swXVsxXSk7XG4gICAgfSxcbiAgICB1cGRhdGVDb3ZlclNoYXBlOiBmdW5jdGlvbiAoY29udHJvbGxlciwgY292ZXIsIGxvY2FsUmFuZ2UsIGJydXNoT3B0aW9uKSB7XG4gICAgICB1cGRhdGVCYXNlUmVjdChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pO1xuICAgIH0sXG4gICAgdXBkYXRlQ29tbW9uOiB1cGRhdGVDb21tb24sXG4gICAgY29udGFpbjogbWFpblNoYXBlQ29udGFpblxuICB9LFxuICBwb2x5Z29uOiB7XG4gICAgY3JlYXRlQ292ZXI6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBicnVzaE9wdGlvbikge1xuICAgICAgdmFyIGNvdmVyID0gbmV3IGdyYXBoaWMuR3JvdXAoKTsgLy8gRG8gbm90IHVzZSBncmFwaGljLlBvbHlnb24gYmVjYXVzZSBncmFwaGljLlBvbHlsaW5lIGRvIG5vdCBjbG9zZSB0aGVcbiAgICAgIC8vIGJvcmRlciBvZiB0aGUgc2hhcGUgd2hlbiBkcmF3aW5nLCB3aGljaCBpcyBhIGJldHRlciBleHBlcmllbmNlIGZvciB1c2VyLlxuXG4gICAgICBjb3Zlci5hZGQobmV3IGdyYXBoaWMuUG9seWxpbmUoe1xuICAgICAgICBuYW1lOiAnbWFpbicsXG4gICAgICAgIHN0eWxlOiBtYWtlU3R5bGUoYnJ1c2hPcHRpb24pLFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBjb3ZlcjtcbiAgICB9LFxuICAgIGdldENyZWF0aW5nUmFuZ2U6IGZ1bmN0aW9uIChsb2NhbFRyYWNrKSB7XG4gICAgICByZXR1cm4gbG9jYWxUcmFjaztcbiAgICB9LFxuICAgIGVuZENyZWF0aW5nOiBmdW5jdGlvbiAoY29udHJvbGxlciwgY292ZXIpIHtcbiAgICAgIGNvdmVyLnJlbW92ZShjb3Zlci5jaGlsZEF0KDApKTsgLy8gVXNlIGdyYXBoaWMuUG9seWdvbiBjbG9zZSB0aGUgc2hhcGUuXG5cbiAgICAgIGNvdmVyLmFkZChuZXcgZ3JhcGhpYy5Qb2x5Z29uKHtcbiAgICAgICAgbmFtZTogJ21haW4nLFxuICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgIGRyaWZ0OiBjdXJyeShkcmlmdFBvbHlnb24sIGNvbnRyb2xsZXIsIGNvdmVyKSxcbiAgICAgICAgb25kcmFnZW5kOiBjdXJyeSh0cmlnZ2VyLCBjb250cm9sbGVyLCB7XG4gICAgICAgICAgaXNFbmQ6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvdmVyU2hhcGU6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pIHtcbiAgICAgIGNvdmVyLmNoaWxkQXQoMCkuc2V0U2hhcGUoe1xuICAgICAgICBwb2ludHM6IGNsaXBCeVBhbmVsKGNvbnRyb2xsZXIsIGNvdmVyLCBsb2NhbFJhbmdlKVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB1cGRhdGVDb21tb246IHVwZGF0ZUNvbW1vbixcbiAgICBjb250YWluOiBtYWluU2hhcGVDb250YWluXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldExpbmVSZW5kZXJlcih4eUluZGV4KSB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlQ292ZXI6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBicnVzaE9wdGlvbikge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJhc2VSZWN0Q292ZXIoe1xuICAgICAgICB0b1JlY3RSYW5nZTogZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgdmFyIHJlY3RSYW5nZSA9IFtyYW5nZSwgWzAsIDEwMF1dO1xuICAgICAgICAgIHh5SW5kZXggJiYgcmVjdFJhbmdlLnJldmVyc2UoKTtcbiAgICAgICAgICByZXR1cm4gcmVjdFJhbmdlO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tUmVjdFJhbmdlOiBmdW5jdGlvbiAocmVjdFJhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlY3RSYW5nZVt4eUluZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSwgY29udHJvbGxlciwgYnJ1c2hPcHRpb24sIFtbWyd3J10sIFsnZSddXSwgW1snbiddLCBbJ3MnXV1dW3h5SW5kZXhdKTtcbiAgICB9LFxuICAgIGdldENyZWF0aW5nUmFuZ2U6IGZ1bmN0aW9uIChsb2NhbFRyYWNrKSB7XG4gICAgICB2YXIgZW5kcyA9IGdldFRyYWNrRW5kcyhsb2NhbFRyYWNrKTtcbiAgICAgIHZhciBtaW4gPSBtYXRoTWluKGVuZHNbMF1beHlJbmRleF0sIGVuZHNbMV1beHlJbmRleF0pO1xuICAgICAgdmFyIG1heCA9IG1hdGhNYXgoZW5kc1swXVt4eUluZGV4XSwgZW5kc1sxXVt4eUluZGV4XSk7XG4gICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvdmVyU2hhcGU6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pIHtcbiAgICAgIHZhciBvdGhlckV4dGVudDsgLy8gSWYgYnJ1c2hXaWR0aCBub3Qgc3BlY2lmaWVkLCBmaXQgdGhlIHBhbmVsLlxuXG4gICAgICB2YXIgcGFuZWwgPSBnZXRQYW5lbEJ5Q292ZXIoY29udHJvbGxlciwgY292ZXIpO1xuXG4gICAgICBpZiAocGFuZWwgIT09IEJSVVNIX1BBTkVMX0dMT0JBTCAmJiBwYW5lbC5nZXRMaW5lYXJCcnVzaE90aGVyRXh0ZW50KSB7XG4gICAgICAgIG90aGVyRXh0ZW50ID0gcGFuZWwuZ2V0TGluZWFyQnJ1c2hPdGhlckV4dGVudCh4eUluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB6ciA9IGNvbnRyb2xsZXIuX3pyO1xuICAgICAgICBvdGhlckV4dGVudCA9IFswLCBbenIuZ2V0V2lkdGgoKSwgenIuZ2V0SGVpZ2h0KCldWzEgLSB4eUluZGV4XV07XG4gICAgICB9XG5cbiAgICAgIHZhciByZWN0UmFuZ2UgPSBbbG9jYWxSYW5nZSwgb3RoZXJFeHRlbnRdO1xuICAgICAgeHlJbmRleCAmJiByZWN0UmFuZ2UucmV2ZXJzZSgpO1xuICAgICAgdXBkYXRlQmFzZVJlY3QoY29udHJvbGxlciwgY292ZXIsIHJlY3RSYW5nZSwgYnJ1c2hPcHRpb24pO1xuICAgIH0sXG4gICAgdXBkYXRlQ29tbW9uOiB1cGRhdGVDb21tb24sXG4gICAgY29udGFpbjogbWFpblNoYXBlQ29udGFpblxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBCcnVzaENvbnRyb2xsZXI7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IFJvYW1Db250cm9sbGVyIGZyb20gJy4vUm9hbUNvbnRyb2xsZXInO1xuaW1wb3J0ICogYXMgcm9hbUhlbHBlciBmcm9tICcuLi8uLi9jb21wb25lbnQvaGVscGVyL3JvYW1IZWxwZXInO1xuaW1wb3J0IHsgb25JcnJlbGV2YW50RWxlbWVudCB9IGZyb20gJy4uLy4uL2NvbXBvbmVudC9oZWxwZXIvY3Vyc29ySGVscGVyJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCB7IGVuYWJsZUhvdmVyRW1waGFzaXMsIERJU1BMQVlfU1RBVEVTIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMnO1xuaW1wb3J0IGdlb1NvdXJjZU1hbmFnZXIgZnJvbSAnLi4vLi4vY29vcmQvZ2VvL2dlb1NvdXJjZU1hbmFnZXInO1xuaW1wb3J0IHsgZ2V0VUlEIH0gZnJvbSAnLi4vLi4vdXRpbC9jb21wb25lbnQnO1xuaW1wb3J0IFRyYW5zZm9ybWFibGUgZnJvbSAnenJlbmRlci9saWIvY29yZS9UcmFuc2Zvcm1hYmxlJztcbmltcG9ydCB7IHNldExhYmVsU3R5bGUsIGdldExhYmVsU3RhdGVzTW9kZWxzIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZSc7XG5pbXBvcnQgeyBnZXRFQ0RhdGEgfSBmcm9tICcuLi8uLi91dGlsL2lubmVyU3RvcmUnO1xuaW1wb3J0IHsgY3JlYXRlT3JVcGRhdGVQYXR0ZXJuRnJvbURlY2FsIH0gZnJvbSAnLi4vLi4vdXRpbC9kZWNhbCc7XG5cbmZ1bmN0aW9uIGdldEZpeGVkSXRlbVN0eWxlKG1vZGVsKSB7XG4gIHZhciBpdGVtU3R5bGUgPSBtb2RlbC5nZXRJdGVtU3R5bGUoKTtcbiAgdmFyIGFyZWFDb2xvciA9IG1vZGVsLmdldCgnYXJlYUNvbG9yJyk7IC8vIElmIHVzZXIgd2FudCB0aGUgY29sb3Igbm90IHRvIGJlIGNoYW5nZWQgd2hlbiBob3ZlcixcbiAgLy8gdGhleSBzaG91bGQgYm90aCBzZXQgYXJlYUNvbG9yIGFuZCBjb2xvciB0byBiZSBudWxsLlxuXG4gIGlmIChhcmVhQ29sb3IgIT0gbnVsbCkge1xuICAgIGl0ZW1TdHlsZS5maWxsID0gYXJlYUNvbG9yO1xuICB9XG5cbiAgcmV0dXJuIGl0ZW1TdHlsZTtcbn1cblxudmFyIE1hcERyYXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXBEcmF3KGFwaSkge1xuICAgIHZhciBncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgdGhpcy51aWQgPSBnZXRVSUQoJ2VjX21hcF9kcmF3Jyk7IC8vIEB0cy1pZ25vcmUgRklYTUU6VFNcblxuICAgIHRoaXMuX2NvbnRyb2xsZXIgPSBuZXcgUm9hbUNvbnRyb2xsZXIoYXBpLmdldFpyKCkpO1xuICAgIHRoaXMuX2NvbnRyb2xsZXJIb3N0ID0ge1xuICAgICAgdGFyZ2V0OiBncm91cFxuICAgIH07XG4gICAgdGhpcy5ncm91cCA9IGdyb3VwO1xuICAgIGdyb3VwLmFkZCh0aGlzLl9yZWdpb25zR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpKTtcbiAgICBncm91cC5hZGQodGhpcy5fYmFja2dyb3VuZEdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKSk7XG4gIH1cblxuICBNYXBEcmF3LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKG1hcE9yR2VvTW9kZWwsIGVjTW9kZWwsIGFwaSwgZnJvbVZpZXcsIHBheWxvYWQpIHtcbiAgICB2YXIgaXNHZW8gPSBtYXBPckdlb01vZGVsLm1haW5UeXBlID09PSAnZ2VvJzsgLy8gTWFwIHNlcmllcyBoYXMgZGF0YS4gR0VPIG1vZGVsIHRoYXQgY29udHJvbGxlZCBieSBtYXAgc2VyaWVzXG4gICAgLy8gd2lsbCBiZSBhc3NpZ25lZCB3aXRoIG1hcCBkYXRhLiBPdGhlciBHRU8gbW9kZWwgaGFzIG5vIGRhdGEuXG5cbiAgICB2YXIgZGF0YSA9IG1hcE9yR2VvTW9kZWwuZ2V0RGF0YSAmJiBtYXBPckdlb01vZGVsLmdldERhdGEoKTtcbiAgICBpc0dlbyAmJiBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6ICdzZXJpZXMnLFxuICAgICAgc3ViVHlwZTogJ21hcCdcbiAgICB9LCBmdW5jdGlvbiAobWFwU2VyaWVzKSB7XG4gICAgICBpZiAoIWRhdGEgJiYgbWFwU2VyaWVzLmdldEhvc3RHZW9Nb2RlbCgpID09PSBtYXBPckdlb01vZGVsKSB7XG4gICAgICAgIGRhdGEgPSBtYXBTZXJpZXMuZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBnZW8gPSBtYXBPckdlb01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICB0aGlzLl91cGRhdGVCYWNrZ3JvdW5kKGdlbyk7XG5cbiAgICB2YXIgcmVnaW9uc0dyb3VwID0gdGhpcy5fcmVnaW9uc0dyb3VwO1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIHRyYW5zZm9ybUluZm8gPSBnZW8uZ2V0VHJhbnNmb3JtSW5mbygpOyAvLyBObyBhbmltYXRpb24gd2hlbiBmaXJzdCBkcmF3IG9yIGluIGFjdGlvblxuXG4gICAgdmFyIGlzRmlyc3REcmF3ID0gIXJlZ2lvbnNHcm91cC5jaGlsZEF0KDApIHx8IHBheWxvYWQ7XG4gICAgdmFyIHRhcmdldFNjYWxlWDtcbiAgICB2YXIgdGFyZ2V0U2NhbGVZO1xuXG4gICAgaWYgKGlzRmlyc3REcmF3KSB7XG4gICAgICBncm91cC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1JbmZvLnJvYW1UcmFuc2Zvcm07XG4gICAgICBncm91cC5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcbiAgICAgIGdyb3VwLmRpcnR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXcgVHJhbnNmb3JtYWJsZSgpO1xuICAgICAgdGFyZ2V0LnRyYW5zZm9ybSA9IHRyYW5zZm9ybUluZm8ucm9hbVRyYW5zZm9ybTtcbiAgICAgIHRhcmdldC5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgc2NhbGVYOiB0YXJnZXQuc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHRhcmdldC5zY2FsZVksXG4gICAgICAgIHg6IHRhcmdldC54LFxuICAgICAgICB5OiB0YXJnZXQueVxuICAgICAgfTtcbiAgICAgIHRhcmdldFNjYWxlWCA9IHRhcmdldC5zY2FsZVg7XG4gICAgICB0YXJnZXRTY2FsZVkgPSB0YXJnZXQuc2NhbGVZO1xuICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhncm91cCwgcHJvcHMsIG1hcE9yR2VvTW9kZWwpO1xuICAgIH1cblxuICAgIHJlZ2lvbnNHcm91cC5yZW1vdmVBbGwoKTtcbiAgICB2YXIgbmFtZU1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gICAgdmFyIGlzVmlzdWFsRW5jb2RlZEJ5VmlzdWFsTWFwID0gZGF0YSAmJiBkYXRhLmdldFZpc3VhbCgndmlzdWFsTWV0YScpICYmIGRhdGEuZ2V0VmlzdWFsKCd2aXN1YWxNZXRhJykubGVuZ3RoID4gMDtcbiAgICB6clV0aWwuZWFjaChnZW8ucmVnaW9ucywgZnVuY3Rpb24gKHJlZ2lvbikge1xuICAgICAgLy8gQ29uc2lkZXIgaW4gR2VvSnNvbiBwcm9wZXJ0aWVzLm5hbWUgbWF5IGJlIGR1cGxpY2F0ZWQsIGZvciBleGFtcGxlLFxuICAgICAgLy8gdGhlcmUgaXMgbXVsdGlwbGUgcmVnaW9uIG5hbWVkIFwiVW5pdGVkIEtpbmRvbVwiIG9yIFwiRnJhbmNlXCIgKHNvIG1hbnlcbiAgICAgIC8vIGNvbG9uaWVzKS4gQW5kIGl0IGlzIG5vdCBhcHByb3ByaWF0ZSB0byBtZXJnZSB0aGVtIGluIGdlbywgd2hpY2hcbiAgICAgIC8vIHdpbGwgbWFrZSB0aGVtIHNoYXJlIHRoZSBzYW1lIGxhYmVsIGFuZCBicmluZyB0cm91YmxlIGluIGxhYmVsXG4gICAgICAvLyBsb2NhdGlvbiBjYWxjdWxhdGlvbi5cbiAgICAgIHZhciByZWdpb25Hcm91cCA9IG5hbWVNYXAuZ2V0KHJlZ2lvbi5uYW1lKSB8fCBuYW1lTWFwLnNldChyZWdpb24ubmFtZSwgbmV3IGdyYXBoaWMuR3JvdXAoKSk7XG4gICAgICB2YXIgY29tcG91bmRQYXRoID0gbmV3IGdyYXBoaWMuQ29tcG91bmRQYXRoKHtcbiAgICAgICAgc2VnbWVudElnbm9yZVRocmVzaG9sZDogMSxcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICBwYXRoczogW11cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZWdpb25Hcm91cC5hZGQoY29tcG91bmRQYXRoKTtcbiAgICAgIHZhciByZWdpb25Nb2RlbCA9IG1hcE9yR2VvTW9kZWwuZ2V0UmVnaW9uTW9kZWwocmVnaW9uLm5hbWUpIHx8IG1hcE9yR2VvTW9kZWw7IC8vIEB0cy1pZ25vcmUgRklYTUU6VFMgZml4IHRoZSBcImNvbXBhdGlibGUgd2l0aCBlYWNoIG90aGVyXCI/XG5cbiAgICAgIHZhciBpdGVtU3R5bGVNb2RlbCA9IHJlZ2lvbk1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKTsgLy8gQHRzLWlnbm9yZSBGSVhNRTpUUyBmaXggdGhlIFwiY29tcGF0aWJsZSB3aXRoIGVhY2ggb3RoZXJcIj9cblxuICAgICAgdmFyIGVtcGhhc2lzTW9kZWwgPSByZWdpb25Nb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKTtcbiAgICAgIHZhciBlbXBoYXNpc0l0ZW1TdHlsZU1vZGVsID0gZW1waGFzaXNNb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJyk7IC8vIEB0cy1pZ25vcmUgRklYTUU6VFMgZml4IHRoZSBcImNvbXBhdGlibGUgd2l0aCBlYWNoIG90aGVyXCI/XG5cbiAgICAgIHZhciBibHVySXRlbVN0eWxlTW9kZWwgPSByZWdpb25Nb2RlbC5nZXRNb2RlbChbJ2JsdXInLCAnaXRlbVN0eWxlJ10pOyAvLyBAdHMtaWdub3JlIEZJWE1FOlRTIGZpeCB0aGUgXCJjb21wYXRpYmxlIHdpdGggZWFjaCBvdGhlclwiP1xuXG4gICAgICB2YXIgc2VsZWN0SXRlbVN0eWxlTW9kZWwgPSByZWdpb25Nb2RlbC5nZXRNb2RlbChbJ3NlbGVjdCcsICdpdGVtU3R5bGUnXSk7IC8vIE5PVEU6IERPTlQgdXNlICdzdHlsZScgaW4gdmlzdWFsIHdoZW4gZHJhd2luZyBtYXAuXG4gICAgICAvLyBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIGZvciBkcmF3aW5nIHVuZGVybHlpbmcgbWFwIGZvciBib3RoIGdlbyBjb21wb25lbnQgYW5kIG1hcCBzZXJpZXMuXG5cbiAgICAgIHZhciBpdGVtU3R5bGUgPSBnZXRGaXhlZEl0ZW1TdHlsZShpdGVtU3R5bGVNb2RlbCk7XG4gICAgICB2YXIgZW1waGFzaXNJdGVtU3R5bGUgPSBnZXRGaXhlZEl0ZW1TdHlsZShlbXBoYXNpc0l0ZW1TdHlsZU1vZGVsKTtcbiAgICAgIHZhciBibHVySXRlbVN0eWxlID0gZ2V0Rml4ZWRJdGVtU3R5bGUoYmx1ckl0ZW1TdHlsZU1vZGVsKTtcbiAgICAgIHZhciBzZWxlY3RJdGVtU3R5bGUgPSBnZXRGaXhlZEl0ZW1TdHlsZShzZWxlY3RJdGVtU3R5bGVNb2RlbCk7XG4gICAgICB2YXIgZGF0YUlkeDsgLy8gVXNlIHRoZSBpdGVtU3R5bGUgaW4gZGF0YSBpZiBoYXMgZGF0YVxuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhSWR4ID0gZGF0YS5pbmRleE9mTmFtZShyZWdpb24ubmFtZSk7IC8vIE9ubHkgdmlzdWFsIGNvbG9yIG9mIGVhY2ggaXRlbSB3aWxsIGJlIHVzZWQuIEl0IGNhbiBiZSBlbmNvZGVkIGJ5IHZpc3VhbE1hcFxuICAgICAgICAvLyBCdXQgdmlzdWFsIGNvbG9yIG9mIHNlcmllcyBpcyB1c2VkIGluIHN5bWJvbCBkcmF3aW5nXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFZpc3VhbCBjb2xvciBmb3IgZWFjaCBzZXJpZXMgaXMgZm9yIHRoZSBzeW1ib2wgZHJhd1xuXG4gICAgICAgIHZhciBzdHlsZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSWR4LCAnc3R5bGUnKTtcbiAgICAgICAgdmFyIGRlY2FsID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJZHgsICdkZWNhbCcpO1xuXG4gICAgICAgIGlmIChpc1Zpc3VhbEVuY29kZWRCeVZpc3VhbE1hcCAmJiBzdHlsZS5maWxsKSB7XG4gICAgICAgICAgaXRlbVN0eWxlLmZpbGwgPSBzdHlsZS5maWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlY2FsKSB7XG4gICAgICAgICAgaXRlbVN0eWxlLmRlY2FsID0gY3JlYXRlT3JVcGRhdGVQYXR0ZXJuRnJvbURlY2FsKGRlY2FsLCBhcGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzeCA9IHRyYW5zZm9ybUluZm8ucmF3U2NhbGVYO1xuICAgICAgdmFyIHN5ID0gdHJhbnNmb3JtSW5mby5yYXdTY2FsZVk7XG4gICAgICB2YXIgb2Zmc2V0WCA9IHRyYW5zZm9ybUluZm8ucmF3WDtcbiAgICAgIHZhciBvZmZzZXRZID0gdHJhbnNmb3JtSW5mby5yYXdZO1xuXG4gICAgICB2YXIgdHJhbnNmb3JtUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIFtwb2ludFswXSAqIHN4ICsgb2Zmc2V0WCwgcG9pbnRbMV0gKiBzeSArIG9mZnNldFldO1xuICAgICAgfTtcblxuICAgICAgenJVdGlsLmVhY2gocmVnaW9uLmdlb21ldHJpZXMsIGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICBpZiAoZ2VvbWV0cnkudHlwZSAhPT0gJ3BvbHlnb24nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkuZXh0ZXJpb3IubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBwb2ludHMucHVzaCh0cmFuc2Zvcm1Qb2ludChnZW9tZXRyeS5leHRlcmlvcltpXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG91bmRQYXRoLnNoYXBlLnBhdGhzLnB1c2gobmV3IGdyYXBoaWMuUG9seWdvbih7XG4gICAgICAgICAgc2VnbWVudElnbm9yZVRocmVzaG9sZDogMSxcbiAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChnZW9tZXRyeS5pbnRlcmlvcnMgPyBnZW9tZXRyeS5pbnRlcmlvcnMubGVuZ3RoIDogMCk7ICsraSkge1xuICAgICAgICAgIHZhciBpbnRlcmlvciA9IGdlb21ldHJ5LmludGVyaW9yc1tpXTtcbiAgICAgICAgICB2YXIgcG9pbnRzXzEgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW50ZXJpb3IubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHBvaW50c18xLnB1c2godHJhbnNmb3JtUG9pbnQoaW50ZXJpb3Jbal0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb21wb3VuZFBhdGguc2hhcGUucGF0aHMucHVzaChuZXcgZ3JhcGhpYy5Qb2x5Z29uKHtcbiAgICAgICAgICAgIHNlZ21lbnRJZ25vcmVUaHJlc2hvbGQ6IDEsXG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICBwb2ludHM6IHBvaW50c18xXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbXBvdW5kUGF0aC5zZXRTdHlsZShpdGVtU3R5bGUpO1xuICAgICAgY29tcG91bmRQYXRoLnN0eWxlLnN0cm9rZU5vU2NhbGUgPSB0cnVlO1xuICAgICAgY29tcG91bmRQYXRoLmN1bGxpbmcgPSB0cnVlO1xuICAgICAgY29tcG91bmRQYXRoLmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpLnN0eWxlID0gZW1waGFzaXNJdGVtU3R5bGU7XG4gICAgICBjb21wb3VuZFBhdGguZW5zdXJlU3RhdGUoJ2JsdXInKS5zdHlsZSA9IGJsdXJJdGVtU3R5bGU7XG4gICAgICBjb21wb3VuZFBhdGguZW5zdXJlU3RhdGUoJ3NlbGVjdCcpLnN0eWxlID0gc2VsZWN0SXRlbVN0eWxlO1xuICAgICAgdmFyIHNob3dMYWJlbCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IERJU1BMQVlfU1RBVEVTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdGF0ZU5hbWUgPSBESVNQTEFZX1NUQVRFU1tpXTsgLy8gQHRzLWlnbm9yZSBGSVhNRTpUUyBmaXggdGhlIFwiY29tcGF0aWJsZSB3aXRoIGVhY2ggb3RoZXJcIj9cblxuICAgICAgICBpZiAocmVnaW9uTW9kZWwuZ2V0KHN0YXRlTmFtZSA9PT0gJ25vcm1hbCcgPyBbJ2xhYmVsJywgJ3Nob3cnXSA6IFtzdGF0ZU5hbWUsICdsYWJlbCcsICdzaG93J10pKSB7XG4gICAgICAgICAgc2hvd0xhYmVsID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXNEYXRhTmFOID0gZGF0YSAmJiBpc05hTihkYXRhLmdldChkYXRhLm1hcERpbWVuc2lvbigndmFsdWUnKSwgZGF0YUlkeCkpO1xuICAgICAgdmFyIGl0ZW1MYXlvdXQgPSBkYXRhICYmIGRhdGEuZ2V0SXRlbUxheW91dChkYXRhSWR4KTsgLy8gSW4gdGhlIGZvbGxvd2luZyBjYXNlcyBsYWJlbCB3aWxsIGJlIGRyYXduXG4gICAgICAvLyAxLiBJbiBtYXAgc2VyaWVzIGFuZCBkYXRhIHZhbHVlIGlzIE5hTlxuICAgICAgLy8gMi4gSW4gZ2VvIGNvbXBvbmVudFxuICAgICAgLy8gNC4gUmVnaW9uIGhhcyBubyBzZXJpZXMgbGVnZW5kU3ltYm9sLCB3aGljaCB3aWxsIGJlIGFkZCBhIHNob3dMYWJlbCBmbGFnIGluIG1hcFN5bWJvbExheW91dFxuXG4gICAgICBpZiAoaXNHZW8gfHwgaXNEYXRhTmFOICYmIHNob3dMYWJlbCB8fCBpdGVtTGF5b3V0ICYmIGl0ZW1MYXlvdXQuc2hvd0xhYmVsKSB7XG4gICAgICAgIHZhciBxdWVyeSA9ICFpc0dlbyA/IGRhdGFJZHggOiByZWdpb24ubmFtZTtcbiAgICAgICAgdmFyIGxhYmVsRmV0Y2hlciA9IHZvaWQgMDsgLy8gQ29uc2lkZXIgZGF0YUlkeCBub3QgZm91bmQuXG5cbiAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGFJZHggPj0gMCkge1xuICAgICAgICAgIGxhYmVsRmV0Y2hlciA9IG1hcE9yR2VvTW9kZWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2VudGVyUHQgPSB0cmFuc2Zvcm1Qb2ludChyZWdpb24uY2VudGVyKTtcbiAgICAgICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgICAgIHg6IGNlbnRlclB0WzBdLFxuICAgICAgICAgIHk6IGNlbnRlclB0WzFdLFxuICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgLy8gbGFiZWwgcm90YXRpb24gaXMgbm90IHN1cHBvcnQgeWV0IGluIGdlbyBvciByZWdpb25zIG9mIHNlcmllcy1tYXBcbiAgICAgICAgICAvLyB0aGF0IGhhcyBubyBkYXRhLiBUaGUgcm90YXRpb24gd2lsbCBiZSBlZmZlY3RlZCBieSB0aGlzIGBzY2FsZWAuXG4gICAgICAgICAgLy8gU28gbmVlZGVkIHRvIGNoYW5nZSB0byBSZWN0VGV4dD9cbiAgICAgICAgICBzY2FsZVg6IDEgLyBncm91cC5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZOiAxIC8gZ3JvdXAuc2NhbGVZLFxuICAgICAgICAgIHoyOiAxMCxcbiAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHNldExhYmVsU3R5bGUodGV4dEVsLCBnZXRMYWJlbFN0YXRlc01vZGVscyhyZWdpb25Nb2RlbCksIHtcbiAgICAgICAgICBsYWJlbEZldGNoZXI6IGxhYmVsRmV0Y2hlcixcbiAgICAgICAgICBsYWJlbERhdGFJbmRleDogcXVlcnksXG4gICAgICAgICAgZGVmYXVsdFRleHQ6IHJlZ2lvbi5uYW1lXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29tcG91bmRQYXRoLnNldFRleHRDb250ZW50KHRleHRFbCk7XG4gICAgICAgIGNvbXBvdW5kUGF0aC5zZXRUZXh0Q29uZmlnKHtcbiAgICAgICAgICBsb2NhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29tcG91bmRQYXRoLmRpc2FibGVMYWJlbEFuaW1hdGlvbiA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFpc0ZpcnN0RHJhdykge1xuICAgICAgICAgIC8vIFRleHQgYW5pbWF0aW9uXG4gICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyh0ZXh0RWwsIHtcbiAgICAgICAgICAgIHNjYWxlWDogMSAvIHRhcmdldFNjYWxlWCxcbiAgICAgICAgICAgIHNjYWxlWTogMSAvIHRhcmdldFNjYWxlWVxuICAgICAgICAgIH0sIG1hcE9yR2VvTW9kZWwpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHNldEl0ZW1HcmFwaGljRWwsIHNldEhvdmVyU3R5bGUgYWZ0ZXIgYWxsIHBvbHlnb25zIGFuZCBsYWJlbHNcbiAgICAgIC8vIGFyZSBhZGRlZCB0byB0aGUgcmlnaW9uR3JvdXBcblxuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoZGF0YUlkeCwgcmVnaW9uR3JvdXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlZ2lvbk1vZGVsXzEgPSBtYXBPckdlb01vZGVsLmdldFJlZ2lvbk1vZGVsKHJlZ2lvbi5uYW1lKTsgLy8gUGFja2FnZSBjdXN0b20gbW91c2UgZXZlbnQgZm9yIGdlbyBjb21wb25lbnRcblxuICAgICAgICBnZXRFQ0RhdGEoY29tcG91bmRQYXRoKS5ldmVudERhdGEgPSB7XG4gICAgICAgICAgY29tcG9uZW50VHlwZTogJ2dlbycsXG4gICAgICAgICAgY29tcG9uZW50SW5kZXg6IG1hcE9yR2VvTW9kZWwuY29tcG9uZW50SW5kZXgsXG4gICAgICAgICAgZ2VvSW5kZXg6IG1hcE9yR2VvTW9kZWwuY29tcG9uZW50SW5kZXgsXG4gICAgICAgICAgbmFtZTogcmVnaW9uLm5hbWUsXG4gICAgICAgICAgcmVnaW9uOiByZWdpb25Nb2RlbF8xICYmIHJlZ2lvbk1vZGVsXzEub3B0aW9uIHx8IHt9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBncm91cFJlZ2lvbnMgPSByZWdpb25Hcm91cC5fX3JlZ2lvbnMgfHwgKHJlZ2lvbkdyb3VwLl9fcmVnaW9ucyA9IFtdKTtcbiAgICAgIGdyb3VwUmVnaW9ucy5wdXNoKHJlZ2lvbik7IC8vIEB0cy1pZ25vcmUgRklYTUU6VFMgZml4IHRoZSBcImNvbXBhdGlibGUgd2l0aCBlYWNoIG90aGVyXCI/XG5cbiAgICAgIHJlZ2lvbkdyb3VwLmhpZ2hEb3duU2lsZW50T25Ub3VjaCA9ICEhbWFwT3JHZW9Nb2RlbC5nZXQoJ3NlbGVjdGVkTW9kZScpO1xuICAgICAgZW5hYmxlSG92ZXJFbXBoYXNpcyhyZWdpb25Hcm91cCwgZW1waGFzaXNNb2RlbC5nZXQoJ2ZvY3VzJyksIGVtcGhhc2lzTW9kZWwuZ2V0KCdibHVyU2NvcGUnKSk7XG4gICAgICByZWdpb25zR3JvdXAuYWRkKHJlZ2lvbkdyb3VwKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3VwZGF0ZUNvbnRyb2xsZXIobWFwT3JHZW9Nb2RlbCwgZWNNb2RlbCwgYXBpKTtcblxuICAgIHRoaXMuX3VwZGF0ZU1hcFNlbGVjdEhhbmRsZXIobWFwT3JHZW9Nb2RlbCwgcmVnaW9uc0dyb3VwLCBhcGksIGZyb21WaWV3KTtcbiAgfTtcblxuICBNYXBEcmF3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVnaW9uc0dyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgdGhpcy5fYmFja2dyb3VuZEdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgdGhpcy5fY29udHJvbGxlci5kaXNwb3NlKCk7XG5cbiAgICB0aGlzLl9tYXBOYW1lICYmIGdlb1NvdXJjZU1hbmFnZXIucmVtb3ZlR3JhcGhpYyh0aGlzLl9tYXBOYW1lLCB0aGlzLnVpZCk7XG4gICAgdGhpcy5fbWFwTmFtZSA9IG51bGw7XG4gICAgdGhpcy5fY29udHJvbGxlckhvc3QgPSBudWxsO1xuICB9O1xuXG4gIE1hcERyYXcucHJvdG90eXBlLl91cGRhdGVCYWNrZ3JvdW5kID0gZnVuY3Rpb24gKGdlbykge1xuICAgIHZhciBtYXBOYW1lID0gZ2VvLm1hcDtcblxuICAgIGlmICh0aGlzLl9tYXBOYW1lICE9PSBtYXBOYW1lKSB7XG4gICAgICB6clV0aWwuZWFjaChnZW9Tb3VyY2VNYW5hZ2VyLm1ha2VHcmFwaGljKG1hcE5hbWUsIHRoaXMudWlkKSwgZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZEdyb3VwLmFkZChyb290KTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuX21hcE5hbWUgPSBtYXBOYW1lO1xuICB9O1xuXG4gIE1hcERyYXcucHJvdG90eXBlLl91cGRhdGVDb250cm9sbGVyID0gZnVuY3Rpb24gKG1hcE9yR2VvTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBnZW8gPSBtYXBPckdlb01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVyO1xuICAgIHZhciBjb250cm9sbGVySG9zdCA9IHRoaXMuX2NvbnRyb2xsZXJIb3N0OyAvLyBAdHMtaWdub3JlIEZJWE1FOlRTXG5cbiAgICBjb250cm9sbGVySG9zdC56b29tTGltaXQgPSBtYXBPckdlb01vZGVsLmdldCgnc2NhbGVMaW1pdCcpO1xuICAgIGNvbnRyb2xsZXJIb3N0Lnpvb20gPSBnZW8uZ2V0Wm9vbSgpOyAvLyByb2FtVHlwZSBpcyB3aWxsIGJlIHNldCBkZWZhdWx0IHRydWUgaWYgaXQgaXMgbnVsbFxuICAgIC8vIEB0cy1pZ25vcmUgRklYTUU6VFNcblxuICAgIGNvbnRyb2xsZXIuZW5hYmxlKG1hcE9yR2VvTW9kZWwuZ2V0KCdyb2FtJykgfHwgZmFsc2UpO1xuICAgIHZhciBtYWluVHlwZSA9IG1hcE9yR2VvTW9kZWwubWFpblR5cGU7XG5cbiAgICBmdW5jdGlvbiBtYWtlQWN0aW9uQmFzZSgpIHtcbiAgICAgIHZhciBhY3Rpb24gPSB7XG4gICAgICAgIHR5cGU6ICdnZW9Sb2FtJyxcbiAgICAgICAgY29tcG9uZW50VHlwZTogbWFpblR5cGVcbiAgICAgIH07XG4gICAgICBhY3Rpb25bbWFpblR5cGUgKyAnSWQnXSA9IG1hcE9yR2VvTW9kZWwuaWQ7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH1cblxuICAgIGNvbnRyb2xsZXIub2ZmKCdwYW4nKS5vbigncGFuJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX21vdXNlRG93bkZsYWcgPSBmYWxzZTtcbiAgICAgIHJvYW1IZWxwZXIudXBkYXRlVmlld09uUGFuKGNvbnRyb2xsZXJIb3N0LCBlLmR4LCBlLmR5KTtcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih6clV0aWwuZXh0ZW5kKG1ha2VBY3Rpb25CYXNlKCksIHtcbiAgICAgICAgZHg6IGUuZHgsXG4gICAgICAgIGR5OiBlLmR5XG4gICAgICB9KSk7XG4gICAgfSwgdGhpcyk7XG4gICAgY29udHJvbGxlci5vZmYoJ3pvb20nKS5vbignem9vbScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9tb3VzZURvd25GbGFnID0gZmFsc2U7XG4gICAgICByb2FtSGVscGVyLnVwZGF0ZVZpZXdPblpvb20oY29udHJvbGxlckhvc3QsIGUuc2NhbGUsIGUub3JpZ2luWCwgZS5vcmlnaW5ZKTtcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih6clV0aWwuZXh0ZW5kKG1ha2VBY3Rpb25CYXNlKCksIHtcbiAgICAgICAgem9vbTogZS5zY2FsZSxcbiAgICAgICAgb3JpZ2luWDogZS5vcmlnaW5YLFxuICAgICAgICBvcmlnaW5ZOiBlLm9yaWdpbllcbiAgICAgIH0pKTtcbiAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG5cbiAgICAgIHRoaXMuX3JlZ2lvbnNHcm91cC50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIHRleHRDb250ZW50ID0gZWwuZ2V0VGV4dENvbnRlbnQoKTtcblxuICAgICAgICBpZiAodGV4dENvbnRlbnQpIHtcbiAgICAgICAgICB0ZXh0Q29udGVudC5zY2FsZVggPSAxIC8gZ3JvdXAuc2NhbGVYO1xuICAgICAgICAgIHRleHRDb250ZW50LnNjYWxlWSA9IDEgLyBncm91cC5zY2FsZVk7XG4gICAgICAgICAgdGV4dENvbnRlbnQubWFya1JlZHJhdygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcbiAgICBjb250cm9sbGVyLnNldFBvaW50ZXJDaGVja2VyKGZ1bmN0aW9uIChlLCB4LCB5KSB7XG4gICAgICByZXR1cm4gZ2VvLmdldFZpZXdSZWN0QWZ0ZXJSb2FtKCkuY29udGFpbih4LCB5KSAmJiAhb25JcnJlbGV2YW50RWxlbWVudChlLCBhcGksIG1hcE9yR2VvTW9kZWwpO1xuICAgIH0pO1xuICB9O1xuXG4gIE1hcERyYXcucHJvdG90eXBlLl91cGRhdGVNYXBTZWxlY3RIYW5kbGVyID0gZnVuY3Rpb24gKG1hcE9yR2VvTW9kZWwsIHJlZ2lvbnNHcm91cCwgYXBpLCBmcm9tVmlldykge1xuICAgIHZhciBtYXBEcmF3ID0gdGhpcztcbiAgICByZWdpb25zR3JvdXAub2ZmKCdtb3VzZWRvd24nKTsgLy8gQHRzLWlnbm9yZSBGSVhNRTpUUyByZXNvbHZlIHR5cGUgY29uZmxpY3RcblxuICAgIGlmIChtYXBPckdlb01vZGVsLmdldCgnc2VsZWN0ZWRNb2RlJykpIHtcbiAgICAgIHJlZ2lvbnNHcm91cC5vbignbW91c2Vkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBtYXBEcmF3Ll9tb3VzZURvd25GbGFnID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgcmVnaW9uc0dyb3VwLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghbWFwRHJhdy5fbW91c2VEb3duRmxhZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcERyYXcuX21vdXNlRG93bkZsYWcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTWFwRHJhdztcbn0oKTtcblxuO1xuZXhwb3J0IGRlZmF1bHQgTWFwRHJhdzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgRXZlbnRmdWwgZnJvbSAnenJlbmRlci9saWIvY29yZS9FdmVudGZ1bCc7XG5pbXBvcnQgKiBhcyBldmVudFRvb2wgZnJvbSAnenJlbmRlci9saWIvY29yZS9ldmVudCc7XG5pbXBvcnQgKiBhcyBpbnRlcmFjdGlvbk11dGV4IGZyb20gJy4vaW50ZXJhY3Rpb25NdXRleCc7XG5pbXBvcnQgeyBpc1N0cmluZywgYmluZCwgZGVmYXVsdHMsIGNsb25lIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcblxudmFyIFJvYW1Db250cm9sbGVyID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFJvYW1Db250cm9sbGVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFJvYW1Db250cm9sbGVyKHpyKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF90aGlzLl96ciA9IHpyOyAvLyBBdm9pZCB0d28gcm9hbUNvbnRyb2xsZXIgYmluZCB0aGUgc2FtZSBoYW5kbGVyXG5cbiAgICB2YXIgbW91c2Vkb3duSGFuZGxlciA9IGJpbmQoX3RoaXMuX21vdXNlZG93bkhhbmRsZXIsIF90aGlzKTtcbiAgICB2YXIgbW91c2Vtb3ZlSGFuZGxlciA9IGJpbmQoX3RoaXMuX21vdXNlbW92ZUhhbmRsZXIsIF90aGlzKTtcbiAgICB2YXIgbW91c2V1cEhhbmRsZXIgPSBiaW5kKF90aGlzLl9tb3VzZXVwSGFuZGxlciwgX3RoaXMpO1xuICAgIHZhciBtb3VzZXdoZWVsSGFuZGxlciA9IGJpbmQoX3RoaXMuX21vdXNld2hlZWxIYW5kbGVyLCBfdGhpcyk7XG4gICAgdmFyIHBpbmNoSGFuZGxlciA9IGJpbmQoX3RoaXMuX3BpbmNoSGFuZGxlciwgX3RoaXMpO1xuICAgIC8qKlxuICAgICAqIE5vdGljZTogb25seSBlbmFibGUgbmVlZGVkIHR5cGVzLiBGb3IgZXhhbXBsZSwgaWYgJ3pvb20nXG4gICAgICogaXMgbm90IG5lZWRlZCwgJ3pvb20nIHNob3VsZCBub3QgYmUgZW5hYmxlZCwgb3RoZXJ3aXNlXG4gICAgICogZGVmYXVsdCBtb3VzZXdoZWVsIGJlaGF2aW91ciAoc2Nyb2xsIHBhZ2UpIHdpbGwgYmUgZGlzYWJsZWQuXG4gICAgICovXG5cbiAgICBfdGhpcy5lbmFibGUgPSBmdW5jdGlvbiAoY29udHJvbFR5cGUsIG9wdCkge1xuICAgICAgLy8gRGlzYWJsZSBwcmV2aW91cyBmaXJzdFxuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICB0aGlzLl9vcHQgPSBkZWZhdWx0cyhjbG9uZShvcHQpIHx8IHt9LCB7XG4gICAgICAgIHpvb21Pbk1vdXNlV2hlZWw6IHRydWUsXG4gICAgICAgIG1vdmVPbk1vdXNlTW92ZTogdHJ1ZSxcbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgd2hlZWwgZG8gbm90IHRyaWdnZXIgbW92ZS5cbiAgICAgICAgbW92ZU9uTW91c2VXaGVlbDogZmFsc2UsXG4gICAgICAgIHByZXZlbnREZWZhdWx0TW91c2VNb3ZlOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKGNvbnRyb2xUeXBlID09IG51bGwpIHtcbiAgICAgICAgY29udHJvbFR5cGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udHJvbFR5cGUgPT09IHRydWUgfHwgY29udHJvbFR5cGUgPT09ICdtb3ZlJyB8fCBjb250cm9sVHlwZSA9PT0gJ3BhbicpIHtcbiAgICAgICAgenIub24oJ21vdXNlZG93bicsIG1vdXNlZG93bkhhbmRsZXIpO1xuICAgICAgICB6ci5vbignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlSGFuZGxlcik7XG4gICAgICAgIHpyLm9uKCdtb3VzZXVwJywgbW91c2V1cEhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udHJvbFR5cGUgPT09IHRydWUgfHwgY29udHJvbFR5cGUgPT09ICdzY2FsZScgfHwgY29udHJvbFR5cGUgPT09ICd6b29tJykge1xuICAgICAgICB6ci5vbignbW91c2V3aGVlbCcsIG1vdXNld2hlZWxIYW5kbGVyKTtcbiAgICAgICAgenIub24oJ3BpbmNoJywgcGluY2hIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHpyLm9mZignbW91c2Vkb3duJywgbW91c2Vkb3duSGFuZGxlcik7XG4gICAgICB6ci5vZmYoJ21vdXNlbW92ZScsIG1vdXNlbW92ZUhhbmRsZXIpO1xuICAgICAgenIub2ZmKCdtb3VzZXVwJywgbW91c2V1cEhhbmRsZXIpO1xuICAgICAgenIub2ZmKCdtb3VzZXdoZWVsJywgbW91c2V3aGVlbEhhbmRsZXIpO1xuICAgICAgenIub2ZmKCdwaW5jaCcsIHBpbmNoSGFuZGxlcik7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFJvYW1Db250cm9sbGVyLnByb3RvdHlwZS5pc0RyYWdnaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9kcmFnZ2luZztcbiAgfTtcblxuICBSb2FtQ29udHJvbGxlci5wcm90b3R5cGUuaXNQaW5jaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGluY2hpbmc7XG4gIH07XG5cbiAgUm9hbUNvbnRyb2xsZXIucHJvdG90eXBlLnNldFBvaW50ZXJDaGVja2VyID0gZnVuY3Rpb24gKHBvaW50ZXJDaGVja2VyKSB7XG4gICAgdGhpcy5wb2ludGVyQ2hlY2tlciA9IHBvaW50ZXJDaGVja2VyO1xuICB9O1xuXG4gIFJvYW1Db250cm9sbGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICB9O1xuXG4gIFJvYW1Db250cm9sbGVyLnByb3RvdHlwZS5fbW91c2Vkb3duSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGV2ZW50VG9vbC5pc01pZGRsZU9yUmlnaHRCdXR0b25Pbk1vdXNlVXBEb3duKGUpIHx8IGUudGFyZ2V0ICYmIGUudGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB4ID0gZS5vZmZzZXRYO1xuICAgIHZhciB5ID0gZS5vZmZzZXRZOyAvLyBPbmx5IGNoZWNrIG9uIG1vc2Vkb3duLCBidXQgbm90IG1vdXNlbW92ZS5cbiAgICAvLyBNb3VzZSBjYW4gYmUgb3V0IG9mIHRhcmdldCB3aGVuIG1vdXNlIG1vdmluZy5cblxuICAgIGlmICh0aGlzLnBvaW50ZXJDaGVja2VyICYmIHRoaXMucG9pbnRlckNoZWNrZXIoZSwgeCwgeSkpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICB0aGlzLl9kcmFnZ2luZyA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIFJvYW1Db250cm9sbGVyLnByb3RvdHlwZS5fbW91c2Vtb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKCF0aGlzLl9kcmFnZ2luZyB8fCAhaXNBdmFpbGFibGVCZWhhdmlvcignbW92ZU9uTW91c2VNb3ZlJywgZSwgdGhpcy5fb3B0KSB8fCBlLmdlc3R1cmVFdmVudCA9PT0gJ3BpbmNoJyB8fCBpbnRlcmFjdGlvbk11dGV4LmlzVGFrZW4odGhpcy5fenIsICdnbG9iYWxQYW4nKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB4ID0gZS5vZmZzZXRYO1xuICAgIHZhciB5ID0gZS5vZmZzZXRZO1xuICAgIHZhciBvbGRYID0gdGhpcy5feDtcbiAgICB2YXIgb2xkWSA9IHRoaXMuX3k7XG4gICAgdmFyIGR4ID0geCAtIG9sZFg7XG4gICAgdmFyIGR5ID0geSAtIG9sZFk7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgdGhpcy5fb3B0LnByZXZlbnREZWZhdWx0TW91c2VNb3ZlICYmIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xuICAgIHRyaWdnZXIodGhpcywgJ3BhbicsICdtb3ZlT25Nb3VzZU1vdmUnLCBlLCB7XG4gICAgICBkeDogZHgsXG4gICAgICBkeTogZHksXG4gICAgICBvbGRYOiBvbGRYLFxuICAgICAgb2xkWTogb2xkWSxcbiAgICAgIG5ld1g6IHgsXG4gICAgICBuZXdZOiB5LFxuICAgICAgaXNBdmFpbGFibGVCZWhhdmlvcjogbnVsbFxuICAgIH0pO1xuICB9O1xuXG4gIFJvYW1Db250cm9sbGVyLnByb3RvdHlwZS5fbW91c2V1cEhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmICghZXZlbnRUb29sLmlzTWlkZGxlT3JSaWdodEJ1dHRvbk9uTW91c2VVcERvd24oZSkpIHtcbiAgICAgIHRoaXMuX2RyYWdnaW5nID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIFJvYW1Db250cm9sbGVyLnByb3RvdHlwZS5fbW91c2V3aGVlbEhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzaG91bGRab29tID0gaXNBdmFpbGFibGVCZWhhdmlvcignem9vbU9uTW91c2VXaGVlbCcsIGUsIHRoaXMuX29wdCk7XG4gICAgdmFyIHNob3VsZE1vdmUgPSBpc0F2YWlsYWJsZUJlaGF2aW9yKCdtb3ZlT25Nb3VzZVdoZWVsJywgZSwgdGhpcy5fb3B0KTtcbiAgICB2YXIgd2hlZWxEZWx0YSA9IGUud2hlZWxEZWx0YTtcbiAgICB2YXIgYWJzV2hlZWxEZWx0YURlbHRhID0gTWF0aC5hYnMod2hlZWxEZWx0YSk7XG4gICAgdmFyIG9yaWdpblggPSBlLm9mZnNldFg7XG4gICAgdmFyIG9yaWdpblkgPSBlLm9mZnNldFk7IC8vIHdoZWVsRGVsdGEgbWF5YmUgLTAgaW4gY2hyb21lIG1hYy5cblxuICAgIGlmICh3aGVlbERlbHRhID09PSAwIHx8ICFzaG91bGRab29tICYmICFzaG91bGRNb3ZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiBib3RoIGBzaG91bGRab29tYCBhbmQgYHNob3VsZE1vdmVgIGlzIHRydWUsIHRyaWdnZXJcbiAgICAvLyB0aGVpciBldmVudCBib3RoLCBhbmQgdGhlIGZpbmFsIGJlaGF2aW9yIGlzIGRldGVybWluZWRcbiAgICAvLyBieSBldmVudCBsaXN0ZW5lciB0aGVtc2VsdmVzLlxuXG5cbiAgICBpZiAoc2hvdWxkWm9vbSkge1xuICAgICAgLy8gQ29udmVuaWVuY2U6XG4gICAgICAvLyBNYWMgYW5kIFZNIFdpbmRvd3Mgb24gTWFjOiBzY3JvbGwgdXA6IHpvb20gb3V0LlxuICAgICAgLy8gV2luZG93czogc2Nyb2xsIHVwOiB6b29tIGluLlxuICAgICAgLy8gRklYTUU6IFNob3VsZCBkbyBtb3JlIHRlc3QgaW4gZGlmZmVyZW50IGVudmlyb25tZW50LlxuICAgICAgLy8gd2hlZWxEZWx0YSBpcyB0b28gY29tcGxpY2F0ZWQgaW4gZGlmZmVyZW5jZSBudmlyb25tZW50XG4gICAgICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL21vdXNld2hlZWwpLFxuICAgICAgLy8gYWx0aG91Z2ggaXQgaGFzIGJlZW4gbm9ybWFsbGl6ZWQgYnkgenJlbmRlci5cbiAgICAgIC8vIHdoZWVsRGVsdGEgb2YgbW91c2Ugd2hlZWwgaXMgYmlnZ2VyIHRoYW4gdG91Y2ggcGFkLlxuICAgICAgdmFyIGZhY3RvciA9IGFic1doZWVsRGVsdGFEZWx0YSA+IDMgPyAxLjQgOiBhYnNXaGVlbERlbHRhRGVsdGEgPiAxID8gMS4yIDogMS4xO1xuICAgICAgdmFyIHNjYWxlID0gd2hlZWxEZWx0YSA+IDAgPyBmYWN0b3IgOiAxIC8gZmFjdG9yO1xuICAgICAgY2hlY2tQb2ludGVyQW5kVHJpZ2dlcih0aGlzLCAnem9vbScsICd6b29tT25Nb3VzZVdoZWVsJywgZSwge1xuICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgIG9yaWdpblg6IG9yaWdpblgsXG4gICAgICAgIG9yaWdpblk6IG9yaWdpblksXG4gICAgICAgIGlzQXZhaWxhYmxlQmVoYXZpb3I6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRNb3ZlKSB7XG4gICAgICAvLyBGSVhNRTogU2hvdWxkIGRvIG1vcmUgdGVzdCBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnQuXG4gICAgICB2YXIgYWJzRGVsdGEgPSBNYXRoLmFicyh3aGVlbERlbHRhKTsgLy8gd2hlZWxEZWx0YSBvZiBtb3VzZSB3aGVlbCBpcyBiaWdnZXIgdGhhbiB0b3VjaCBwYWQuXG5cbiAgICAgIHZhciBzY3JvbGxEZWx0YSA9ICh3aGVlbERlbHRhID4gMCA/IDEgOiAtMSkgKiAoYWJzRGVsdGEgPiAzID8gMC40IDogYWJzRGVsdGEgPiAxID8gMC4xNSA6IDAuMDUpO1xuICAgICAgY2hlY2tQb2ludGVyQW5kVHJpZ2dlcih0aGlzLCAnc2Nyb2xsTW92ZScsICdtb3ZlT25Nb3VzZVdoZWVsJywgZSwge1xuICAgICAgICBzY3JvbGxEZWx0YTogc2Nyb2xsRGVsdGEsXG4gICAgICAgIG9yaWdpblg6IG9yaWdpblgsXG4gICAgICAgIG9yaWdpblk6IG9yaWdpblksXG4gICAgICAgIGlzQXZhaWxhYmxlQmVoYXZpb3I6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBSb2FtQ29udHJvbGxlci5wcm90b3R5cGUuX3BpbmNoSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGludGVyYWN0aW9uTXV0ZXguaXNUYWtlbih0aGlzLl96ciwgJ2dsb2JhbFBhbicpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlID0gZS5waW5jaFNjYWxlID4gMSA/IDEuMSA6IDEgLyAxLjE7XG4gICAgY2hlY2tQb2ludGVyQW5kVHJpZ2dlcih0aGlzLCAnem9vbScsIG51bGwsIGUsIHtcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgIG9yaWdpblg6IGUucGluY2hYLFxuICAgICAgb3JpZ2luWTogZS5waW5jaFksXG4gICAgICBpc0F2YWlsYWJsZUJlaGF2aW9yOiBudWxsXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFJvYW1Db250cm9sbGVyO1xufShFdmVudGZ1bCk7XG5cbmZ1bmN0aW9uIGNoZWNrUG9pbnRlckFuZFRyaWdnZXIoY29udHJvbGxlciwgZXZlbnROYW1lLCBiZWhhdmlvclRvQ2hlY2ssIGUsIGNvbnRvbGxlckV2ZW50KSB7XG4gIGlmIChjb250cm9sbGVyLnBvaW50ZXJDaGVja2VyICYmIGNvbnRyb2xsZXIucG9pbnRlckNoZWNrZXIoZSwgY29udG9sbGVyRXZlbnQub3JpZ2luWCwgY29udG9sbGVyRXZlbnQub3JpZ2luWSkpIHtcbiAgICAvLyBXaGVuIG1vdXNlIGlzIG91dCBvZiByb2FtQ29udHJvbGxlciByZWN0LFxuICAgIC8vIGRlZmF1bHQgYmVmYXZvaXVzIHNob3VsZCBub3QgYmUgYmUgZGlzYWJsZWQsIG90aGVyd2lzZVxuICAgIC8vIHBhZ2Ugc2xpZGluZyBpcyBkaXNhYmxlZCwgY29udHJhcnkgdG8gZXhwZWN0YXRpb24uXG4gICAgZXZlbnRUb29sLnN0b3AoZS5ldmVudCk7XG4gICAgdHJpZ2dlcihjb250cm9sbGVyLCBldmVudE5hbWUsIGJlaGF2aW9yVG9DaGVjaywgZSwgY29udG9sbGVyRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIoY29udHJvbGxlciwgZXZlbnROYW1lLCBiZWhhdmlvclRvQ2hlY2ssIGUsIGNvbnRvbGxlckV2ZW50KSB7XG4gIC8vIEFsc28gcHJvdmlkZSBiZWhhdmlvciBjaGVja2VyIGZvciBldmVudCBsaXN0ZW5lciwgZm9yIHNvbWUgY2FzZSB0aGF0XG4gIC8vIG11bHRpcGxlIGNvbXBvbmVudHMgc2hhcmUgb25lIGxpc3RlbmVyLlxuICBjb250b2xsZXJFdmVudC5pc0F2YWlsYWJsZUJlaGF2aW9yID0gYmluZChpc0F2YWlsYWJsZUJlaGF2aW9yLCBudWxsLCBiZWhhdmlvclRvQ2hlY2ssIGUpO1xuICBjb250cm9sbGVyLnRyaWdnZXIoZXZlbnROYW1lLCBjb250b2xsZXJFdmVudCk7XG59IC8vIHNldHRpbmdzOiB7XG4vLyAgICAgem9vbU9uTW91c2VXaGVlbFxuLy8gICAgIG1vdmVPbk1vdXNlTW92ZVxuLy8gICAgIG1vdmVPbk1vdXNlV2hlZWxcbi8vIH1cbi8vIFRoZSB2YWx1ZSBjYW4gYmU6IHRydWUgLyBmYWxzZSAvICdzaGlmdCcgLyAnY3RybCcgLyAnYWx0Jy5cblxuXG5mdW5jdGlvbiBpc0F2YWlsYWJsZUJlaGF2aW9yKGJlaGF2aW9yVG9DaGVjaywgZSwgc2V0dGluZ3MpIHtcbiAgdmFyIHNldHRpbmcgPSBzZXR0aW5nc1tiZWhhdmlvclRvQ2hlY2tdO1xuICByZXR1cm4gIWJlaGF2aW9yVG9DaGVjayB8fCBzZXR0aW5nICYmICghaXNTdHJpbmcoc2V0dGluZykgfHwgZS5ldmVudFtzZXR0aW5nICsgJ0tleSddKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUm9hbUNvbnRyb2xsZXI7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCBCb3VuZGluZ1JlY3QgZnJvbSAnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnO1xuaW1wb3J0IHsgb25JcnJlbGV2YW50RWxlbWVudCB9IGZyb20gJy4vY3Vyc29ySGVscGVyJztcbmltcG9ydCAqIGFzIGdyYXBoaWNVdGlsIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlY3RQYW5lbENsaXBQYXRoKHJlY3QpIHtcbiAgcmVjdCA9IG5vcm1hbGl6ZVJlY3QocmVjdCk7XG4gIHJldHVybiBmdW5jdGlvbiAobG9jYWxQb2ludHMpIHtcbiAgICByZXR1cm4gZ3JhcGhpY1V0aWwuY2xpcFBvaW50c0J5UmVjdChsb2NhbFBvaW50cywgcmVjdCk7XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZUxpbmVhckJydXNoT3RoZXJFeHRlbnQocmVjdCwgc3BlY2lmaWVkWFlJbmRleCkge1xuICByZWN0ID0gbm9ybWFsaXplUmVjdChyZWN0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4eUluZGV4KSB7XG4gICAgdmFyIGlkeCA9IHNwZWNpZmllZFhZSW5kZXggIT0gbnVsbCA/IHNwZWNpZmllZFhZSW5kZXggOiB4eUluZGV4O1xuICAgIHZhciBicnVzaFdpZHRoID0gaWR4ID8gcmVjdC53aWR0aCA6IHJlY3QuaGVpZ2h0O1xuICAgIHZhciBiYXNlID0gaWR4ID8gcmVjdC54IDogcmVjdC55O1xuICAgIHJldHVybiBbYmFzZSwgYmFzZSArIChicnVzaFdpZHRoIHx8IDApXTtcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUmVjdElzVGFyZ2V0QnlDdXJzb3IocmVjdCwgYXBpLCB0YXJnZXRNb2RlbCkge1xuICB2YXIgYm91bmRpbmdSZWN0ID0gbm9ybWFsaXplUmVjdChyZWN0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlLCBsb2NhbEN1cnNvclBvaW50KSB7XG4gICAgcmV0dXJuIGJvdW5kaW5nUmVjdC5jb250YWluKGxvY2FsQ3Vyc29yUG9pbnRbMF0sIGxvY2FsQ3Vyc29yUG9pbnRbMV0pICYmICFvbklycmVsZXZhbnRFbGVtZW50KGUsIGFwaSwgdGFyZ2V0TW9kZWwpO1xuICB9O1xufSAvLyBDb25zaWRlciB3aWR0aC9oZWlnaHQgaXMgbmVnYXRpdmUuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlY3QocmVjdCkge1xuICByZXR1cm4gQm91bmRpbmdSZWN0LmNyZWF0ZShyZWN0KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIElSUkVMRVZBTlRfRVhDTFVERVMgPSB7XG4gICdheGlzUG9pbnRlcic6IDEsXG4gICd0b29sdGlwJzogMSxcbiAgJ2JydXNoJzogMVxufTtcbi8qKlxuICogQXZvaWQgdGhhdDogbW91c2UgY2xpY2sgb24gYSBlbGVtZW50cyB0aGF0IGlzIG92ZXIgZ2VvIG9yIGdyYXBoLFxuICogYnV0IHJvYW0gaXMgdHJpZ2dlcmVkLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBvbklycmVsZXZhbnRFbGVtZW50KGUsIGFwaSwgdGFyZ2V0Q29vcmRTeXNNb2RlbCkge1xuICB2YXIgbW9kZWwgPSBhcGkuZ2V0Q29tcG9uZW50QnlFbGVtZW50KGUudG9wVGFyZ2V0KTsgLy8gSWYgbW9kZWwgaXMgYXhpc01vZGVsLCBpdCB3b3JrcyBvbmx5IGlmIGl0IGlzIGluamVjdGVkIHdpdGggY29vcmRpbmF0ZVN5c3RlbS5cblxuICB2YXIgY29vcmRTeXMgPSBtb2RlbCAmJiBtb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICByZXR1cm4gbW9kZWwgJiYgbW9kZWwgIT09IHRhcmdldENvb3JkU3lzTW9kZWwgJiYgIUlSUkVMRVZBTlRfRVhDTFVERVMuaGFzT3duUHJvcGVydHkobW9kZWwubWFpblR5cGUpICYmIGNvb3JkU3lzICYmIGNvb3JkU3lzLm1vZGVsICE9PSB0YXJnZXRDb29yZFN5c01vZGVsO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vLyBAdHMtbm9jaGVja1xuaW1wb3J0ICogYXMgZWNoYXJ0cyBmcm9tICcuLi8uLi9jb3JlL2VjaGFydHMnO1xudmFyIEFUVFIgPSAnXFwwX2VjX2ludGVyYWN0aW9uX211dGV4JztcbmV4cG9ydCBmdW5jdGlvbiB0YWtlKHpyLCByZXNvdXJjZUtleSwgdXNlcktleSkge1xuICB2YXIgc3RvcmUgPSBnZXRTdG9yZSh6cik7XG4gIHN0b3JlW3Jlc291cmNlS2V5XSA9IHVzZXJLZXk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVsZWFzZSh6ciwgcmVzb3VyY2VLZXksIHVzZXJLZXkpIHtcbiAgdmFyIHN0b3JlID0gZ2V0U3RvcmUoenIpO1xuICB2YXIgdUtleSA9IHN0b3JlW3Jlc291cmNlS2V5XTtcblxuICBpZiAodUtleSA9PT0gdXNlcktleSkge1xuICAgIHN0b3JlW3Jlc291cmNlS2V5XSA9IG51bGw7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1Rha2VuKHpyLCByZXNvdXJjZUtleSkge1xuICByZXR1cm4gISFnZXRTdG9yZSh6cilbcmVzb3VyY2VLZXldO1xufVxuXG5mdW5jdGlvbiBnZXRTdG9yZSh6cikge1xuICByZXR1cm4genJbQVRUUl0gfHwgKHpyW0FUVFJdID0ge30pO1xufVxuLyoqXG4gKiBwYXlsb2FkOiB7XG4gKiAgICAgdHlwZTogJ3Rha2VHbG9iYWxDdXJzb3InLFxuICogICAgIGtleTogJ2RhdGFab29tU2VsZWN0Jywgb3IgJ2JydXNoJywgb3IgLi4uLFxuICogICAgICAgICBJZiBubyB1c2VyS2V5LCByZWxlYXNlIGdsb2JhbCBjdXJzb3IuXG4gKiB9XG4gKi9cbi8vIFRPRE86IFNFTEYgUkVHSVNURVJFRC5cblxuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ3Rha2VHbG9iYWxDdXJzb3InLFxuICBldmVudDogJ2dsb2JhbEN1cnNvclRha2VuJyxcbiAgdXBkYXRlOiAndXBkYXRlJ1xufSwgZnVuY3Rpb24gKCkge30pOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogRm9yIGdlbyBhbmQgZ3JhcGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVWaWV3T25QYW4oY29udHJvbGxlckhvc3QsIGR4LCBkeSkge1xuICB2YXIgdGFyZ2V0ID0gY29udHJvbGxlckhvc3QudGFyZ2V0O1xuICB0YXJnZXQueCArPSBkeDtcbiAgdGFyZ2V0LnkgKz0gZHk7XG4gIHRhcmdldC5kaXJ0eSgpO1xufVxuLyoqXG4gKiBGb3IgZ2VvIGFuZCBncmFwaC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlVmlld09uWm9vbShjb250cm9sbGVySG9zdCwgem9vbURlbHRhLCB6b29tWCwgem9vbVkpIHtcbiAgdmFyIHRhcmdldCA9IGNvbnRyb2xsZXJIb3N0LnRhcmdldDtcbiAgdmFyIHpvb21MaW1pdCA9IGNvbnRyb2xsZXJIb3N0Lnpvb21MaW1pdDtcbiAgdmFyIG5ld1pvb20gPSBjb250cm9sbGVySG9zdC56b29tID0gY29udHJvbGxlckhvc3Quem9vbSB8fCAxO1xuICBuZXdab29tICo9IHpvb21EZWx0YTtcblxuICBpZiAoem9vbUxpbWl0KSB7XG4gICAgdmFyIHpvb21NaW4gPSB6b29tTGltaXQubWluIHx8IDA7XG4gICAgdmFyIHpvb21NYXggPSB6b29tTGltaXQubWF4IHx8IEluZmluaXR5O1xuICAgIG5ld1pvb20gPSBNYXRoLm1heChNYXRoLm1pbih6b29tTWF4LCBuZXdab29tKSwgem9vbU1pbik7XG4gIH1cblxuICB2YXIgem9vbVNjYWxlID0gbmV3Wm9vbSAvIGNvbnRyb2xsZXJIb3N0Lnpvb207XG4gIGNvbnRyb2xsZXJIb3N0Lnpvb20gPSBuZXdab29tOyAvLyBLZWVwIHRoZSBtb3VzZSBjZW50ZXIgd2hlbiBzY2FsaW5nXG5cbiAgdGFyZ2V0LnggLT0gKHpvb21YIC0gdGFyZ2V0LngpICogKHpvb21TY2FsZSAtIDEpO1xuICB0YXJnZXQueSAtPSAoem9vbVkgLSB0YXJnZXQueSkgKiAoem9vbVNjYWxlIC0gMSk7XG4gIHRhcmdldC5zY2FsZVggKj0gem9vbVNjYWxlO1xuICB0YXJnZXQuc2NhbGVZICo9IHpvb21TY2FsZTtcbiAgdGFyZ2V0LmRpcnR5KCk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBDYWxjdWxhdGUgc2xpZGVyIG1vdmUgcmVzdWx0LlxuICogVXNhZ2U6XG4gKiAoMSkgSWYgYm90aCBoYW5kbGUwIGFuZCBoYW5kbGUxIGFyZSBuZWVkZWQgdG8gYmUgbW92ZWQsIHNldCBtaW5TcGFuIHRoZSBzYW1lIGFzXG4gKiBtYXhTcGFuIGFuZCB0aGUgc2FtZSBhcyBgTWF0aC5hYnMoaGFuZGxlRW5kWzFdIC0gaGFuZGxlRW5kc1swXSlgLlxuICogKDIpIElmIGhhbmRsZTAgaXMgZm9yYmlkZGVuIHRvIGNyb3NzIGhhbmRsZTEsIHNldCBtaW5TcGFuIGFzIGAwYC5cbiAqXG4gKiBAcGFyYW0gZGVsdGEgTW92ZSBsZW5ndGguXG4gKiBAcGFyYW0gaGFuZGxlRW5kcyBoYW5kbGVFbmRzWzBdIGNhbiBiZSBiaWdnZXIgdGhlbiBoYW5kbGVFbmRzWzFdLlxuICogICAgICAgICAgICAgIGhhbmRsZUVuZHMgd2lsbCBiZSBtb2RpZmllZCBpbiB0aGlzIG1ldGhvZC5cbiAqIEBwYXJhbSBleHRlbnQgaGFuZGxlRW5kcyBpcyByZXN0cmljdGVkIGJ5IGV4dGVudC5cbiAqICAgICAgICAgICAgICBleHRlbnRbMF0gc2hvdWxkIGxlc3Mgb3IgZXF1YWxzIHRoYW4gZXh0ZW50WzFdLlxuICogQHBhcmFtIGhhbmRsZUluZGV4IENhbiBiZSAnYWxsJywgbWVhbnMgdGhhdCBib3RoIG1vdmUgdGhlIHR3byBoYW5kbGVFbmRzLlxuICogQHBhcmFtIG1pblNwYW4gVGhlIHJhbmdlIG9mIGRhdGFab29tIGNhbiBub3QgYmUgc21hbGxlciB0aGFuIHRoYXQuXG4gKiAgICAgICAgICAgICAgSWYgbm90IHNldCwgaGFuZGxlMCBhbmQgY3Jvc3MgaGFuZGxlMS4gSWYgc2V0IGFzIGEgbm9uLW5lZ2F0aXZlXG4gKiAgICAgICAgICAgICAgbnVtYmVyIChpbmNsdWRpbmcgYDBgKSwgaGFuZGxlcyB3aWxsIHB1c2ggZWFjaCBvdGhlciB3aGVuIHJlYWNoaW5nXG4gKiAgICAgICAgICAgICAgdGhlIG1pblNwYW4uXG4gKiBAcGFyYW0gbWF4U3BhbiBUaGUgcmFuZ2Ugb2YgZGF0YVpvb20gY2FuIG5vdCBiZSBsYXJnZXIgdGhhbiB0aGF0LlxuICogQHJldHVybiBUaGUgaW5wdXQgaGFuZGxlRW5kcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2xpZGVyTW92ZShkZWx0YSwgaGFuZGxlRW5kcywgZXh0ZW50LCBoYW5kbGVJbmRleCwgbWluU3BhbiwgbWF4U3Bhbikge1xuICBkZWx0YSA9IGRlbHRhIHx8IDA7XG4gIHZhciBleHRlbnRTcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdOyAvLyBOb3RpY2UgbWF4U3BhbiBhbmQgbWluU3BhbiBjYW4gYmUgbnVsbC91bmRlZmluZWQuXG5cbiAgaWYgKG1pblNwYW4gIT0gbnVsbCkge1xuICAgIG1pblNwYW4gPSByZXN0cmljdChtaW5TcGFuLCBbMCwgZXh0ZW50U3Bhbl0pO1xuICB9XG5cbiAgaWYgKG1heFNwYW4gIT0gbnVsbCkge1xuICAgIG1heFNwYW4gPSBNYXRoLm1heChtYXhTcGFuLCBtaW5TcGFuICE9IG51bGwgPyBtaW5TcGFuIDogMCk7XG4gIH1cblxuICBpZiAoaGFuZGxlSW5kZXggPT09ICdhbGwnKSB7XG4gICAgdmFyIGhhbmRsZVNwYW4gPSBNYXRoLmFicyhoYW5kbGVFbmRzWzFdIC0gaGFuZGxlRW5kc1swXSk7XG4gICAgaGFuZGxlU3BhbiA9IHJlc3RyaWN0KGhhbmRsZVNwYW4sIFswLCBleHRlbnRTcGFuXSk7XG4gICAgbWluU3BhbiA9IG1heFNwYW4gPSByZXN0cmljdChoYW5kbGVTcGFuLCBbbWluU3BhbiwgbWF4U3Bhbl0pO1xuICAgIGhhbmRsZUluZGV4ID0gMDtcbiAgfVxuXG4gIGhhbmRsZUVuZHNbMF0gPSByZXN0cmljdChoYW5kbGVFbmRzWzBdLCBleHRlbnQpO1xuICBoYW5kbGVFbmRzWzFdID0gcmVzdHJpY3QoaGFuZGxlRW5kc1sxXSwgZXh0ZW50KTtcbiAgdmFyIG9yaWdpbmFsRGlzdFNpZ24gPSBnZXRTcGFuU2lnbihoYW5kbGVFbmRzLCBoYW5kbGVJbmRleCk7XG4gIGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdICs9IGRlbHRhOyAvLyBSZXN0cmljdCBpbiBleHRlbnQuXG5cbiAgdmFyIGV4dGVudE1pblNwYW4gPSBtaW5TcGFuIHx8IDA7XG4gIHZhciByZWFsRXh0ZW50ID0gZXh0ZW50LnNsaWNlKCk7XG4gIG9yaWdpbmFsRGlzdFNpZ24uc2lnbiA8IDAgPyByZWFsRXh0ZW50WzBdICs9IGV4dGVudE1pblNwYW4gOiByZWFsRXh0ZW50WzFdIC09IGV4dGVudE1pblNwYW47XG4gIGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdID0gcmVzdHJpY3QoaGFuZGxlRW5kc1toYW5kbGVJbmRleF0sIHJlYWxFeHRlbnQpOyAvLyBFeHBhbmQgc3Bhbi5cblxuICB2YXIgY3VyckRpc3RTaWduO1xuICBjdXJyRGlzdFNpZ24gPSBnZXRTcGFuU2lnbihoYW5kbGVFbmRzLCBoYW5kbGVJbmRleCk7XG5cbiAgaWYgKG1pblNwYW4gIT0gbnVsbCAmJiAoY3VyckRpc3RTaWduLnNpZ24gIT09IG9yaWdpbmFsRGlzdFNpZ24uc2lnbiB8fCBjdXJyRGlzdFNpZ24uc3BhbiA8IG1pblNwYW4pKSB7XG4gICAgLy8gSWYgbWluU3BhbiBleGlzdHMsICdjcm9zcycgaXMgZm9yYmlkZGVuLlxuICAgIGhhbmRsZUVuZHNbMSAtIGhhbmRsZUluZGV4XSA9IGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdICsgb3JpZ2luYWxEaXN0U2lnbi5zaWduICogbWluU3BhbjtcbiAgfSAvLyBTaHJpbmsgc3Bhbi5cblxuXG4gIGN1cnJEaXN0U2lnbiA9IGdldFNwYW5TaWduKGhhbmRsZUVuZHMsIGhhbmRsZUluZGV4KTtcblxuICBpZiAobWF4U3BhbiAhPSBudWxsICYmIGN1cnJEaXN0U2lnbi5zcGFuID4gbWF4U3Bhbikge1xuICAgIGhhbmRsZUVuZHNbMSAtIGhhbmRsZUluZGV4XSA9IGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdICsgY3VyckRpc3RTaWduLnNpZ24gKiBtYXhTcGFuO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZUVuZHM7XG59XG5cbmZ1bmN0aW9uIGdldFNwYW5TaWduKGhhbmRsZUVuZHMsIGhhbmRsZUluZGV4KSB7XG4gIHZhciBkaXN0ID0gaGFuZGxlRW5kc1toYW5kbGVJbmRleF0gLSBoYW5kbGVFbmRzWzEgLSBoYW5kbGVJbmRleF07IC8vIElmIGBoYW5kbGVFbmRzWzBdID09PSBoYW5kbGVFbmRzWzFdYCwgYWx3YXlzIGJlbGlldmUgdGhhdCBoYW5kbGVFbmRbMF1cbiAgLy8gaXMgYXQgbGVmdCBvZiBoYW5kbGVFbmRzWzFdIGZvciBub24tY3Jvc3MgY2FzZS5cblxuICByZXR1cm4ge1xuICAgIHNwYW46IE1hdGguYWJzKGRpc3QpLFxuICAgIHNpZ246IGRpc3QgPiAwID8gLTEgOiBkaXN0IDwgMCA/IDEgOiBoYW5kbGVJbmRleCA/IC0xIDogMVxuICB9O1xufVxuXG5mdW5jdGlvbiByZXN0cmljdCh2YWx1ZSwgZXh0ZW5kKSB7XG4gIHJldHVybiBNYXRoLm1pbihleHRlbmRbMV0gIT0gbnVsbCA/IGV4dGVuZFsxXSA6IEluZmluaXR5LCBNYXRoLm1heChleHRlbmRbMF0gIT0gbnVsbCA/IGV4dGVuZFswXSA6IC1JbmZpbml0eSwgdmFsdWUpKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQ29tcG9uZW50VmlldyBmcm9tICcuLi8uLi92aWV3L0NvbXBvbmVudCc7XG5pbXBvcnQgeyBlYWNoLCBiaW5kLCBleHRlbmQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgY3JlYXRlT3JVcGRhdGUgfSBmcm9tICcuLi8uLi91dGlsL3Rocm90dGxlJztcbnZhciBDTElDS19USFJFU0hPTEQgPSA1OyAvLyA+IDRcblxudmFyIFBhcmFsbGVsVmlldyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQYXJhbGxlbFZpZXcsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gUGFyYWxsZWxWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9IFBhcmFsbGVsVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFBhcmFsbGVsVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHBhcmFsbGVsTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuX21vZGVsID0gcGFyYWxsZWxNb2RlbDtcbiAgICB0aGlzLl9hcGkgPSBhcGk7XG5cbiAgICBpZiAoIXRoaXMuX2hhbmRsZXJzKSB7XG4gICAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuICAgICAgZWFjaChoYW5kbGVycywgZnVuY3Rpb24gKGhhbmRsZXIsIGV2ZW50TmFtZSkge1xuICAgICAgICBhcGkuZ2V0WnIoKS5vbihldmVudE5hbWUsIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0gPSBiaW5kKGhhbmRsZXIsIHRoaXMpKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIGNyZWF0ZU9yVXBkYXRlKHRoaXMsICdfdGhyb3R0bGVkRGlzcGF0Y2hFeHBhbmQnLCBwYXJhbGxlbE1vZGVsLmdldCgnYXhpc0V4cGFuZFJhdGUnKSwgJ2ZpeFJhdGUnKTtcbiAgfTtcblxuICBQYXJhbGxlbFZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgZWFjaCh0aGlzLl9oYW5kbGVycywgZnVuY3Rpb24gKGhhbmRsZXIsIGV2ZW50TmFtZSkge1xuICAgICAgYXBpLmdldFpyKCkub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfSk7XG4gICAgdGhpcy5faGFuZGxlcnMgPSBudWxsO1xuICB9O1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XSBJZiBudWxsLCBjYW5jbGUgdGhlIGxhc3QgYWN0aW9uIHRyaWdnZXJpbmcgZm9yIGRlYm91bmNlLlxuICAgKi9cblxuXG4gIFBhcmFsbGVsVmlldy5wcm90b3R5cGUuX3Rocm90dGxlZERpc3BhdGNoRXhwYW5kID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIHRoaXMuX2Rpc3BhdGNoRXhwYW5kKG9wdCk7XG4gIH07XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBQYXJhbGxlbFZpZXcucHJvdG90eXBlLl9kaXNwYXRjaEV4cGFuZCA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICBvcHQgJiYgdGhpcy5fYXBpLmRpc3BhdGNoQWN0aW9uKGV4dGVuZCh7XG4gICAgICB0eXBlOiAncGFyYWxsZWxBeGlzRXhwYW5kJ1xuICAgIH0sIG9wdCkpO1xuICB9O1xuXG4gIFBhcmFsbGVsVmlldy50eXBlID0gJ3BhcmFsbGVsJztcbiAgcmV0dXJuIFBhcmFsbGVsVmlldztcbn0oQ29tcG9uZW50Vmlldyk7XG5cbnZhciBoYW5kbGVycyA9IHtcbiAgbW91c2Vkb3duOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChjaGVja1RyaWdnZXIodGhpcywgJ2NsaWNrJykpIHtcbiAgICAgIHRoaXMuX21vdXNlRG93blBvaW50ID0gW2Uub2Zmc2V0WCwgZS5vZmZzZXRZXTtcbiAgICB9XG4gIH0sXG4gIG1vdXNldXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1vdXNlRG93blBvaW50ID0gdGhpcy5fbW91c2VEb3duUG9pbnQ7XG5cbiAgICBpZiAoY2hlY2tUcmlnZ2VyKHRoaXMsICdjbGljaycpICYmIG1vdXNlRG93blBvaW50KSB7XG4gICAgICB2YXIgcG9pbnQgPSBbZS5vZmZzZXRYLCBlLm9mZnNldFldO1xuICAgICAgdmFyIGRpc3QgPSBNYXRoLnBvdyhtb3VzZURvd25Qb2ludFswXSAtIHBvaW50WzBdLCAyKSArIE1hdGgucG93KG1vdXNlRG93blBvaW50WzFdIC0gcG9pbnRbMV0sIDIpO1xuXG4gICAgICBpZiAoZGlzdCA+IENMSUNLX1RIUkVTSE9MRCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9tb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFNsaWRlZEF4aXNFeHBhbmRXaW5kb3coW2Uub2Zmc2V0WCwgZS5vZmZzZXRZXSk7XG5cbiAgICAgIHJlc3VsdC5iZWhhdmlvciAhPT0gJ25vbmUnICYmIHRoaXMuX2Rpc3BhdGNoRXhwYW5kKHtcbiAgICAgICAgYXhpc0V4cGFuZFdpbmRvdzogcmVzdWx0LmF4aXNFeHBhbmRXaW5kb3dcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX21vdXNlRG93blBvaW50ID0gbnVsbDtcbiAgfSxcbiAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgIC8vIFNob3VsZCBkbyBub3RoaW5nIHdoZW4gYnJ1c2hpbmcuXG4gICAgaWYgKHRoaXMuX21vdXNlRG93blBvaW50IHx8ICFjaGVja1RyaWdnZXIodGhpcywgJ21vdXNlbW92ZScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgdmFyIHJlc3VsdCA9IG1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0U2xpZGVkQXhpc0V4cGFuZFdpbmRvdyhbZS5vZmZzZXRYLCBlLm9mZnNldFldKTtcbiAgICB2YXIgYmVoYXZpb3IgPSByZXN1bHQuYmVoYXZpb3I7XG4gICAgYmVoYXZpb3IgPT09ICdqdW1wJyAmJiB0aGlzLl90aHJvdHRsZWREaXNwYXRjaEV4cGFuZC5kZWJvdW5jZU5leHRDYWxsKG1vZGVsLmdldCgnYXhpc0V4cGFuZERlYm91bmNlJykpO1xuXG4gICAgdGhpcy5fdGhyb3R0bGVkRGlzcGF0Y2hFeHBhbmQoYmVoYXZpb3IgPT09ICdub25lJyA/IG51bGwgLy8gQ2FuY2xlIHRoZSBsYXN0IHRyaWdnZXIsIGluIGNhc2UgdGhhdCBtb3VzZSBzbGlkZSBvdXQgb2YgdGhlIGFyZWEgcXVpY2tseS5cbiAgICA6IHtcbiAgICAgIGF4aXNFeHBhbmRXaW5kb3c6IHJlc3VsdC5heGlzRXhwYW5kV2luZG93LFxuICAgICAgLy8gSnVtcGluZyB1c2VzIGFuaW1hdGlvbiwgYW5kIHNsaWRpbmcgc3VwcHJlc3NlcyBhbmltYXRpb24uXG4gICAgICBhbmltYXRpb246IGJlaGF2aW9yID09PSAnanVtcCcgPyBudWxsIDoge1xuICAgICAgICBkdXJhdGlvbjogMCAvLyBEaXNhYmxlIGFuaW1hdGlvbi5cblxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjaGVja1RyaWdnZXIodmlldywgdHJpZ2dlck9uKSB7XG4gIHZhciBtb2RlbCA9IHZpZXcuX21vZGVsO1xuICByZXR1cm4gbW9kZWwuZ2V0KCdheGlzRXhwYW5kYWJsZScpICYmIG1vZGVsLmdldCgnYXhpc0V4cGFuZFRyaWdnZXJPbicpID09PSB0cmlnZ2VyT247XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhcmFsbGVsVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHBhcmFsbGVsUHJlcHJvY2Vzc29yIGZyb20gJy4uLy4uL2Nvb3JkL3BhcmFsbGVsL3BhcmFsbGVsUHJlcHJvY2Vzc29yJztcbmltcG9ydCBQYXJhbGxlbFZpZXcgZnJvbSAnLi9QYXJhbGxlbFZpZXcnO1xuaW1wb3J0IFBhcmFsbGVsTW9kZWwgZnJvbSAnLi4vLi4vY29vcmQvcGFyYWxsZWwvUGFyYWxsZWxNb2RlbCc7XG5pbXBvcnQgcGFyYWxsZWxDb29yZFN5c0NyZWF0b3IgZnJvbSAnLi4vLi4vY29vcmQvcGFyYWxsZWwvcGFyYWxsZWxDcmVhdG9yJztcbmltcG9ydCBheGlzTW9kZWxDcmVhdG9yIGZyb20gJy4uLy4uL2Nvb3JkL2F4aXNNb2RlbENyZWF0b3InO1xuaW1wb3J0IFBhcmFsbGVsQXhpc01vZGVsIGZyb20gJy4uLy4uL2Nvb3JkL3BhcmFsbGVsL0F4aXNNb2RlbCc7XG5pbXBvcnQgUGFyYWxsZWxBeGlzVmlldyBmcm9tICcuLi9heGlzL1BhcmFsbGVsQXhpc1ZpZXcnO1xuaW1wb3J0IHsgaW5zdGFsbFBhcmFsbGVsQWN0aW9ucyB9IGZyb20gJy4uL2F4aXMvcGFyYWxsZWxBeGlzQWN0aW9uJztcbnZhciBkZWZhdWx0QXhpc09wdGlvbiA9IHtcbiAgdHlwZTogJ3ZhbHVlJyxcbiAgYXJlYVNlbGVjdFN0eWxlOiB7XG4gICAgd2lkdGg6IDIwLFxuICAgIGJvcmRlcldpZHRoOiAxLFxuICAgIGJvcmRlckNvbG9yOiAncmdiYSgxNjAsMTk3LDIzMiknLFxuICAgIGNvbG9yOiAncmdiYSgxNjAsMTk3LDIzMiknLFxuICAgIG9wYWNpdHk6IDAuM1xuICB9LFxuICByZWFsdGltZTogdHJ1ZSxcbiAgejogMTBcbn07XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhQYXJhbGxlbFZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChQYXJhbGxlbE1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29vcmRpbmF0ZVN5c3RlbSgncGFyYWxsZWwnLCBwYXJhbGxlbENvb3JkU3lzQ3JlYXRvcik7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByZXByb2Nlc3NvcihwYXJhbGxlbFByZXByb2Nlc3Nvcik7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKFBhcmFsbGVsQXhpc01vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhQYXJhbGxlbEF4aXNWaWV3KTtcbiAgYXhpc01vZGVsQ3JlYXRvcihyZWdpc3RlcnMsICdwYXJhbGxlbCcsIFBhcmFsbGVsQXhpc01vZGVsLCBkZWZhdWx0QXhpc09wdGlvbik7XG4gIGluc3RhbGxQYXJhbGxlbEFjdGlvbnMocmVnaXN0ZXJzKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBBeGlzQnVpbGRlciBmcm9tICcuLi9heGlzL0F4aXNCdWlsZGVyJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljJztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50JztcbnZhciBheGlzQnVpbGRlckF0dHJzID0gWydheGlzTGluZScsICdheGlzVGlja0xhYmVsJywgJ2F4aXNOYW1lJ107XG5cbnZhciBSYWRhclZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUmFkYXJWaWV3LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFJhZGFyVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBSYWRhclZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBSYWRhclZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChyYWRhck1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgdGhpcy5fYnVpbGRBeGVzKHJhZGFyTW9kZWwpO1xuXG4gICAgdGhpcy5fYnVpbGRTcGxpdExpbmVBbmRBcmVhKHJhZGFyTW9kZWwpO1xuICB9O1xuXG4gIFJhZGFyVmlldy5wcm90b3R5cGUuX2J1aWxkQXhlcyA9IGZ1bmN0aW9uIChyYWRhck1vZGVsKSB7XG4gICAgdmFyIHJhZGFyID0gcmFkYXJNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBpbmRpY2F0b3JBeGVzID0gcmFkYXIuZ2V0SW5kaWNhdG9yQXhlcygpO1xuICAgIHZhciBheGlzQnVpbGRlcnMgPSB6clV0aWwubWFwKGluZGljYXRvckF4ZXMsIGZ1bmN0aW9uIChpbmRpY2F0b3JBeGlzKSB7XG4gICAgICB2YXIgYXhpc0J1aWxkZXIgPSBuZXcgQXhpc0J1aWxkZXIoaW5kaWNhdG9yQXhpcy5tb2RlbCwge1xuICAgICAgICBwb3NpdGlvbjogW3JhZGFyLmN4LCByYWRhci5jeV0sXG4gICAgICAgIHJvdGF0aW9uOiBpbmRpY2F0b3JBeGlzLmFuZ2xlLFxuICAgICAgICBsYWJlbERpcmVjdGlvbjogLTEsXG4gICAgICAgIHRpY2tEaXJlY3Rpb246IC0xLFxuICAgICAgICBuYW1lRGlyZWN0aW9uOiAxXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBheGlzQnVpbGRlcjtcbiAgICB9KTtcbiAgICB6clV0aWwuZWFjaChheGlzQnVpbGRlcnMsIGZ1bmN0aW9uIChheGlzQnVpbGRlcikge1xuICAgICAgenJVdGlsLmVhY2goYXhpc0J1aWxkZXJBdHRycywgYXhpc0J1aWxkZXIuYWRkLCBheGlzQnVpbGRlcik7XG4gICAgICB0aGlzLmdyb3VwLmFkZChheGlzQnVpbGRlci5nZXRHcm91cCgpKTtcbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuICBSYWRhclZpZXcucHJvdG90eXBlLl9idWlsZFNwbGl0TGluZUFuZEFyZWEgPSBmdW5jdGlvbiAocmFkYXJNb2RlbCkge1xuICAgIHZhciByYWRhciA9IHJhZGFyTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgaW5kaWNhdG9yQXhlcyA9IHJhZGFyLmdldEluZGljYXRvckF4ZXMoKTtcblxuICAgIGlmICghaW5kaWNhdG9yQXhlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGUgPSByYWRhck1vZGVsLmdldCgnc2hhcGUnKTtcbiAgICB2YXIgc3BsaXRMaW5lTW9kZWwgPSByYWRhck1vZGVsLmdldE1vZGVsKCdzcGxpdExpbmUnKTtcbiAgICB2YXIgc3BsaXRBcmVhTW9kZWwgPSByYWRhck1vZGVsLmdldE1vZGVsKCdzcGxpdEFyZWEnKTtcbiAgICB2YXIgbGluZVN0eWxlTW9kZWwgPSBzcGxpdExpbmVNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJyk7XG4gICAgdmFyIGFyZWFTdHlsZU1vZGVsID0gc3BsaXRBcmVhTW9kZWwuZ2V0TW9kZWwoJ2FyZWFTdHlsZScpO1xuICAgIHZhciBzaG93U3BsaXRMaW5lID0gc3BsaXRMaW5lTW9kZWwuZ2V0KCdzaG93Jyk7XG4gICAgdmFyIHNob3dTcGxpdEFyZWEgPSBzcGxpdEFyZWFNb2RlbC5nZXQoJ3Nob3cnKTtcbiAgICB2YXIgc3BsaXRMaW5lQ29sb3JzID0gbGluZVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuICAgIHZhciBzcGxpdEFyZWFDb2xvcnMgPSBhcmVhU3R5bGVNb2RlbC5nZXQoJ2NvbG9yJyk7XG4gICAgdmFyIHNwbGl0TGluZUNvbG9yc0FyciA9IHpyVXRpbC5pc0FycmF5KHNwbGl0TGluZUNvbG9ycykgPyBzcGxpdExpbmVDb2xvcnMgOiBbc3BsaXRMaW5lQ29sb3JzXTtcbiAgICB2YXIgc3BsaXRBcmVhQ29sb3JzQXJyID0genJVdGlsLmlzQXJyYXkoc3BsaXRBcmVhQ29sb3JzKSA/IHNwbGl0QXJlYUNvbG9ycyA6IFtzcGxpdEFyZWFDb2xvcnNdO1xuICAgIHZhciBzcGxpdExpbmVzID0gW107XG4gICAgdmFyIHNwbGl0QXJlYXMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGdldENvbG9ySW5kZXgoYXJlYU9yTGluZSwgYXJlYU9yTGluZUNvbG9yTGlzdCwgaWR4KSB7XG4gICAgICB2YXIgY29sb3JJbmRleCA9IGlkeCAlIGFyZWFPckxpbmVDb2xvckxpc3QubGVuZ3RoO1xuICAgICAgYXJlYU9yTGluZVtjb2xvckluZGV4XSA9IGFyZWFPckxpbmVbY29sb3JJbmRleF0gfHwgW107XG4gICAgICByZXR1cm4gY29sb3JJbmRleDtcbiAgICB9XG5cbiAgICBpZiAoc2hhcGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICB2YXIgdGlja3NSYWRpdXMgPSBpbmRpY2F0b3JBeGVzWzBdLmdldFRpY2tzQ29vcmRzKCk7XG4gICAgICB2YXIgY3ggPSByYWRhci5jeDtcbiAgICAgIHZhciBjeSA9IHJhZGFyLmN5O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzUmFkaXVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzaG93U3BsaXRMaW5lKSB7XG4gICAgICAgICAgdmFyIGNvbG9ySW5kZXggPSBnZXRDb2xvckluZGV4KHNwbGl0TGluZXMsIHNwbGl0TGluZUNvbG9yc0FyciwgaSk7XG4gICAgICAgICAgc3BsaXRMaW5lc1tjb2xvckluZGV4XS5wdXNoKG5ldyBncmFwaGljLkNpcmNsZSh7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgcjogdGlja3NSYWRpdXNbaV0uY29vcmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvd1NwbGl0QXJlYSAmJiBpIDwgdGlja3NSYWRpdXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHZhciBjb2xvckluZGV4ID0gZ2V0Q29sb3JJbmRleChzcGxpdEFyZWFzLCBzcGxpdEFyZWFDb2xvcnNBcnIsIGkpO1xuICAgICAgICAgIHNwbGl0QXJlYXNbY29sb3JJbmRleF0ucHVzaChuZXcgZ3JhcGhpYy5SaW5nKHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICByMDogdGlja3NSYWRpdXNbaV0uY29vcmQsXG4gICAgICAgICAgICAgIHI6IHRpY2tzUmFkaXVzW2kgKyAxXS5jb29yZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gUG9seXlvblxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVhbFNwbGl0TnVtYmVyXzE7XG4gICAgICAgIHZhciBheGVzVGlja3NQb2ludHMgPSB6clV0aWwubWFwKGluZGljYXRvckF4ZXMsIGZ1bmN0aW9uIChpbmRpY2F0b3JBeGlzLCBpZHgpIHtcbiAgICAgICAgICB2YXIgdGlja3NDb29yZHMgPSBpbmRpY2F0b3JBeGlzLmdldFRpY2tzQ29vcmRzKCk7XG4gICAgICAgICAgcmVhbFNwbGl0TnVtYmVyXzEgPSByZWFsU3BsaXROdW1iZXJfMSA9PSBudWxsID8gdGlja3NDb29yZHMubGVuZ3RoIC0gMSA6IE1hdGgubWluKHRpY2tzQ29vcmRzLmxlbmd0aCAtIDEsIHJlYWxTcGxpdE51bWJlcl8xKTtcbiAgICAgICAgICByZXR1cm4genJVdGlsLm1hcCh0aWNrc0Nvb3JkcywgZnVuY3Rpb24gKHRpY2tDb29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJhZGFyLmNvb3JkVG9Qb2ludCh0aWNrQ29vcmQuY29vcmQsIGlkeCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJldlBvaW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHJlYWxTcGxpdE51bWJlcl8xOyBpKyspIHtcbiAgICAgICAgICB2YXIgcG9pbnRzID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGluZGljYXRvckF4ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGF4ZXNUaWNrc1BvaW50c1tqXVtpXSk7XG4gICAgICAgICAgfSAvLyBDbG9zZVxuXG5cbiAgICAgICAgICBpZiAocG9pbnRzWzBdKSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaChwb2ludHNbMF0uc2xpY2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhblxcJ3QgZHJhdyB2YWx1ZSBheGlzICcgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvd1NwbGl0TGluZSkge1xuICAgICAgICAgICAgdmFyIGNvbG9ySW5kZXggPSBnZXRDb2xvckluZGV4KHNwbGl0TGluZXMsIHNwbGl0TGluZUNvbG9yc0FyciwgaSk7XG4gICAgICAgICAgICBzcGxpdExpbmVzW2NvbG9ySW5kZXhdLnB1c2gobmV3IGdyYXBoaWMuUG9seWxpbmUoe1xuICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvd1NwbGl0QXJlYSAmJiBwcmV2UG9pbnRzKSB7XG4gICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9IGdldENvbG9ySW5kZXgoc3BsaXRBcmVhcywgc3BsaXRBcmVhQ29sb3JzQXJyLCBpIC0gMSk7XG4gICAgICAgICAgICBzcGxpdEFyZWFzW2NvbG9ySW5kZXhdLnB1c2gobmV3IGdyYXBoaWMuUG9seWdvbih7XG4gICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMuY29uY2F0KHByZXZQb2ludHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcmV2UG9pbnRzID0gcG9pbnRzLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB2YXIgbGluZVN0eWxlID0gbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCk7XG4gICAgdmFyIGFyZWFTdHlsZSA9IGFyZWFTdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpOyAvLyBBZGQgc3BsaXRBcmVhIGJlZm9yZSBzcGxpdExpbmVcblxuICAgIHpyVXRpbC5lYWNoKHNwbGl0QXJlYXMsIGZ1bmN0aW9uIChzcGxpdEFyZWFzLCBpZHgpIHtcbiAgICAgIHRoaXMuZ3JvdXAuYWRkKGdyYXBoaWMubWVyZ2VQYXRoKHNwbGl0QXJlYXMsIHtcbiAgICAgICAgc3R5bGU6IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgICAgc3Ryb2tlOiAnbm9uZScsXG4gICAgICAgICAgZmlsbDogc3BsaXRBcmVhQ29sb3JzQXJyW2lkeCAlIHNwbGl0QXJlYUNvbG9yc0Fyci5sZW5ndGhdXG4gICAgICAgIH0sIGFyZWFTdHlsZSksXG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH0sIHRoaXMpO1xuICAgIHpyVXRpbC5lYWNoKHNwbGl0TGluZXMsIGZ1bmN0aW9uIChzcGxpdExpbmVzLCBpZHgpIHtcbiAgICAgIHRoaXMuZ3JvdXAuYWRkKGdyYXBoaWMubWVyZ2VQYXRoKHNwbGl0TGluZXMsIHtcbiAgICAgICAgc3R5bGU6IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgIHN0cm9rZTogc3BsaXRMaW5lQ29sb3JzQXJyW2lkeCAlIHNwbGl0TGluZUNvbG9yc0Fyci5sZW5ndGhdXG4gICAgICAgIH0sIGxpbmVTdHlsZSksXG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4gIFJhZGFyVmlldy50eXBlID0gJ3JhZGFyJztcbiAgcmV0dXJuIFJhZGFyVmlldztcbn0oQ29tcG9uZW50Vmlldyk7XG5cbmV4cG9ydCBkZWZhdWx0IFJhZGFyVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IFJhZGFyTW9kZWwgZnJvbSAnLi4vLi4vY29vcmQvcmFkYXIvUmFkYXJNb2RlbCc7XG5pbXBvcnQgUmFkYXJWaWV3IGZyb20gJy4vUmFkYXJWaWV3JztcbmltcG9ydCBSYWRhciBmcm9tICcuLi8uLi9jb29yZC9yYWRhci9SYWRhcic7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29vcmRpbmF0ZVN5c3RlbSgncmFkYXInLCBSYWRhcik7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKFJhZGFyTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KFJhZGFyVmlldyk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Nvb3JkaW5hdGVTeXN0ZW1UeXBlKGNvb3JkU3lzLCB0eXBlKSB7XG4gIHJldHVybiBjb29yZFN5cy50eXBlID09PSB0eXBlO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbi8qKlxuICogU2ltcGxlIHZpZXcgY29vcmRpbmF0ZSBzeXN0ZW1cbiAqIE1hcHBpbmcgZ2l2ZW4geCwgeSB0byB0cmFuc2Zvcm1kIHZpZXcgeCwgeVxuICovXG5cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgdmVjdG9yIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJztcbmltcG9ydCAqIGFzIG1hdHJpeCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeCc7XG5pbXBvcnQgQm91bmRpbmdSZWN0IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0JztcbmltcG9ydCBUcmFuc2Zvcm1hYmxlIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvVHJhbnNmb3JtYWJsZSc7XG52YXIgdjJBcHBseVRyYW5zZm9ybSA9IHZlY3Rvci5hcHBseVRyYW5zZm9ybTtcblxudmFyIFZpZXcgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVmlldywgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBWaWV3KG5hbWUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudHlwZSA9ICd2aWV3JztcbiAgICBfdGhpcy5kaW1lbnNpb25zID0gWyd4JywgJ3knXTtcbiAgICBfdGhpcy5fcm9hbVRyYW5zZm9ybWFibGUgPSBuZXcgVHJhbnNmb3JtYWJsZSgpO1xuICAgIF90aGlzLl9yYXdUcmFuc2Zvcm1hYmxlID0gbmV3IFRyYW5zZm9ybWFibGUoKTtcbiAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH0gLy8gUEVORElORyB0byBnZXRSZWN0XG5cblxuICBWaWV3LnByb3RvdHlwZS5zZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuX3JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICB9O1xuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICAvLyBQRU5ESU5HIHRvIGdldFJlY3RcblxuXG4gIFZpZXcucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgfTtcblxuICBWaWV3LnByb3RvdHlwZS5zZXRWaWV3UmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy50cmFuc2Zvcm1Ubyh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLl92aWV3UmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIH07XG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1lZCB0byBwYXJ0aWN1bGFyIHBvc2l0aW9uIGFuZCBzaXplXG4gICAqL1xuXG5cbiAgVmlldy5wcm90b3R5cGUudHJhbnNmb3JtVG8gPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgcmF3VHJhbnNmb3JtID0gdGhpcy5fcmF3VHJhbnNmb3JtYWJsZTtcbiAgICByYXdUcmFuc2Zvcm0udHJhbnNmb3JtID0gcmVjdC5jYWxjdWxhdGVUcmFuc2Zvcm0obmV3IEJvdW5kaW5nUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgcmF3VHJhbnNmb3JtLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuXG4gICAgdGhpcy5fdXBkYXRlVHJhbnNmb3JtKCk7XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgY2VudGVyIG9mIHZpZXdcbiAgICovXG5cblxuICBWaWV3LnByb3RvdHlwZS5zZXRDZW50ZXIgPSBmdW5jdGlvbiAoY2VudGVyQ29vcmQpIHtcbiAgICBpZiAoIWNlbnRlckNvb3JkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY2VudGVyID0gY2VudGVyQ29vcmQ7XG5cbiAgICB0aGlzLl91cGRhdGVDZW50ZXJBbmRab29tKCk7XG4gIH07XG5cbiAgVmlldy5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uICh6b29tKSB7XG4gICAgem9vbSA9IHpvb20gfHwgMTtcbiAgICB2YXIgem9vbUxpbWl0ID0gdGhpcy56b29tTGltaXQ7XG5cbiAgICBpZiAoem9vbUxpbWl0KSB7XG4gICAgICBpZiAoem9vbUxpbWl0Lm1heCAhPSBudWxsKSB7XG4gICAgICAgIHpvb20gPSBNYXRoLm1pbih6b29tTGltaXQubWF4LCB6b29tKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHpvb21MaW1pdC5taW4gIT0gbnVsbCkge1xuICAgICAgICB6b29tID0gTWF0aC5tYXgoem9vbUxpbWl0Lm1pbiwgem9vbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fem9vbSA9IHpvb207XG5cbiAgICB0aGlzLl91cGRhdGVDZW50ZXJBbmRab29tKCk7XG4gIH07XG4gIC8qKlxuICAgKiBHZXQgZGVmYXVsdCBjZW50ZXIgd2l0aG91dCByb2FtXG4gICAqL1xuXG5cbiAgVmlldy5wcm90b3R5cGUuZ2V0RGVmYXVsdENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZWN0IGJlZm9yZSBhbnkgdHJhbnNmb3JtXG4gICAgdmFyIHJhd1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBjeCA9IHJhd1JlY3QueCArIHJhd1JlY3Qud2lkdGggLyAyO1xuICAgIHZhciBjeSA9IHJhd1JlY3QueSArIHJhd1JlY3QuaGVpZ2h0IC8gMjtcbiAgICByZXR1cm4gW2N4LCBjeV07XG4gIH07XG5cbiAgVmlldy5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jZW50ZXIgfHwgdGhpcy5nZXREZWZhdWx0Q2VudGVyKCk7XG4gIH07XG5cbiAgVmlldy5wcm90b3R5cGUuZ2V0Wm9vbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fem9vbSB8fCAxO1xuICB9O1xuXG4gIFZpZXcucHJvdG90eXBlLmdldFJvYW1UcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvYW1UcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtKCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZW1vdmUgcm9hbVxuICAgKi9cblxuXG4gIFZpZXcucHJvdG90eXBlLl91cGRhdGVDZW50ZXJBbmRab29tID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIE11c3QgdXBkYXRlIGFmdGVyIHZpZXcgdHJhbnNmb3JtIHVwZGF0ZWRcbiAgICB2YXIgcmF3VHJhbnNmb3JtTWF0cml4ID0gdGhpcy5fcmF3VHJhbnNmb3JtYWJsZS5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuXG4gICAgdmFyIHJvYW1UcmFuc2Zvcm0gPSB0aGlzLl9yb2FtVHJhbnNmb3JtYWJsZTtcbiAgICB2YXIgZGVmYXVsdENlbnRlciA9IHRoaXMuZ2V0RGVmYXVsdENlbnRlcigpO1xuICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xuICAgIHZhciB6b29tID0gdGhpcy5nZXRab29tKCk7XG4gICAgY2VudGVyID0gdmVjdG9yLmFwcGx5VHJhbnNmb3JtKFtdLCBjZW50ZXIsIHJhd1RyYW5zZm9ybU1hdHJpeCk7XG4gICAgZGVmYXVsdENlbnRlciA9IHZlY3Rvci5hcHBseVRyYW5zZm9ybShbXSwgZGVmYXVsdENlbnRlciwgcmF3VHJhbnNmb3JtTWF0cml4KTtcbiAgICByb2FtVHJhbnNmb3JtLm9yaWdpblggPSBjZW50ZXJbMF07XG4gICAgcm9hbVRyYW5zZm9ybS5vcmlnaW5ZID0gY2VudGVyWzFdO1xuICAgIHJvYW1UcmFuc2Zvcm0ueCA9IGRlZmF1bHRDZW50ZXJbMF0gLSBjZW50ZXJbMF07XG4gICAgcm9hbVRyYW5zZm9ybS55ID0gZGVmYXVsdENlbnRlclsxXSAtIGNlbnRlclsxXTtcbiAgICByb2FtVHJhbnNmb3JtLnNjYWxlWCA9IHJvYW1UcmFuc2Zvcm0uc2NhbGVZID0gem9vbTtcblxuICAgIHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSgpO1xuICB9O1xuICAvKipcbiAgICogVXBkYXRlIHRyYW5zZm9ybSBmcm9tIHJvYW0gYW5kIG1hcExvY2F0aW9uXG4gICAqL1xuXG5cbiAgVmlldy5wcm90b3R5cGUuX3VwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcm9hbVRyYW5zZm9ybWFibGUgPSB0aGlzLl9yb2FtVHJhbnNmb3JtYWJsZTtcbiAgICB2YXIgcmF3VHJhbnNmb3JtYWJsZSA9IHRoaXMuX3Jhd1RyYW5zZm9ybWFibGU7XG4gICAgcmF3VHJhbnNmb3JtYWJsZS5wYXJlbnQgPSByb2FtVHJhbnNmb3JtYWJsZTtcbiAgICByb2FtVHJhbnNmb3JtYWJsZS51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICByYXdUcmFuc2Zvcm1hYmxlLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIG1hdHJpeC5jb3B5KHRoaXMudHJhbnNmb3JtIHx8ICh0aGlzLnRyYW5zZm9ybSA9IFtdKSwgcmF3VHJhbnNmb3JtYWJsZS50cmFuc2Zvcm0gfHwgbWF0cml4LmNyZWF0ZSgpKTtcbiAgICB0aGlzLl9yYXdUcmFuc2Zvcm0gPSByYXdUcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtKCk7XG4gICAgdGhpcy5pbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybSB8fCBbXTtcbiAgICBtYXRyaXguaW52ZXJ0KHRoaXMuaW52VHJhbnNmb3JtLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgdGhpcy5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcbiAgfTtcblxuICBWaWV3LnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1JbmZvID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByb2FtVHJhbnNmb3JtID0gdGhpcy5fcm9hbVRyYW5zZm9ybWFibGUudHJhbnNmb3JtO1xuICAgIHZhciByYXdUcmFuc2Zvcm1hYmxlID0gdGhpcy5fcmF3VHJhbnNmb3JtYWJsZTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9hbVRyYW5zZm9ybTogcm9hbVRyYW5zZm9ybSA/IHpyVXRpbC5zbGljZShyb2FtVHJhbnNmb3JtKSA6IG1hdHJpeC5jcmVhdGUoKSxcbiAgICAgIHJhd1NjYWxlWDogcmF3VHJhbnNmb3JtYWJsZS5zY2FsZVgsXG4gICAgICByYXdTY2FsZVk6IHJhd1RyYW5zZm9ybWFibGUuc2NhbGVZLFxuICAgICAgcmF3WDogcmF3VHJhbnNmb3JtYWJsZS54LFxuICAgICAgcmF3WTogcmF3VHJhbnNmb3JtYWJsZS55XG4gICAgfTtcbiAgfTtcblxuICBWaWV3LnByb3RvdHlwZS5nZXRWaWV3UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld1JlY3Q7XG4gIH07XG4gIC8qKlxuICAgKiBHZXQgdmlldyByZWN0IGFmdGVyIHJvYW0gdHJhbnNmb3JtXG4gICAqL1xuXG5cbiAgVmlldy5wcm90b3R5cGUuZ2V0Vmlld1JlY3RBZnRlclJvYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgcmVjdC5hcHBseVRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgc2luZ2xlIChsb24sIGxhdCkgZGF0YSBpdGVtIHRvICh4LCB5KSBwb2ludC5cbiAgICovXG5cblxuICBWaWV3LnByb3RvdHlwZS5kYXRhVG9Qb2ludCA9IGZ1bmN0aW9uIChkYXRhLCBub1JvYW0sIG91dCkge1xuICAgIHZhciB0cmFuc2Zvcm0gPSBub1JvYW0gPyB0aGlzLl9yYXdUcmFuc2Zvcm0gOiB0aGlzLnRyYW5zZm9ybTtcbiAgICBvdXQgPSBvdXQgfHwgW107XG4gICAgcmV0dXJuIHRyYW5zZm9ybSA/IHYyQXBwbHlUcmFuc2Zvcm0ob3V0LCBkYXRhLCB0cmFuc2Zvcm0pIDogdmVjdG9yLmNvcHkob3V0LCBkYXRhKTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnQgYSAoeCwgeSkgcG9pbnQgdG8gKGxvbiwgbGF0KSBkYXRhXG4gICAqL1xuXG5cbiAgVmlldy5wcm90b3R5cGUucG9pbnRUb0RhdGEgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm07XG4gICAgcmV0dXJuIGludlRyYW5zZm9ybSA/IHYyQXBwbHlUcmFuc2Zvcm0oW10sIHBvaW50LCBpbnZUcmFuc2Zvcm0pIDogW3BvaW50WzBdLCBwb2ludFsxXV07XG4gIH07XG5cbiAgVmlldy5wcm90b3R5cGUuY29udmVydFRvUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkge1xuICAgIHZhciBjb29yZFN5cyA9IGdldENvb3JkU3lzKGZpbmRlcik7XG4gICAgcmV0dXJuIGNvb3JkU3lzID09PSB0aGlzID8gY29vcmRTeXMuZGF0YVRvUG9pbnQodmFsdWUpIDogbnVsbDtcbiAgfTtcblxuICBWaWV3LnByb3RvdHlwZS5jb252ZXJ0RnJvbVBpeGVsID0gZnVuY3Rpb24gKGVjTW9kZWwsIGZpbmRlciwgcGl4ZWwpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBnZXRDb29yZFN5cyhmaW5kZXIpO1xuICAgIHJldHVybiBjb29yZFN5cyA9PT0gdGhpcyA/IGNvb3JkU3lzLnBvaW50VG9EYXRhKHBpeGVsKSA6IG51bGw7XG4gIH07XG4gIC8qKlxuICAgKiBAaW1wbGVtZW50c1xuICAgKi9cblxuXG4gIFZpZXcucHJvdG90eXBlLmNvbnRhaW5Qb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHJldHVybiB0aGlzLmdldFZpZXdSZWN0QWZ0ZXJSb2FtKCkuY29udGFpbihwb2ludFswXSwgcG9pbnRbMV0pO1xuICB9O1xuXG4gIFZpZXcuZGltZW5zaW9ucyA9IFsneCcsICd5J107XG4gIHJldHVybiBWaWV3O1xufShUcmFuc2Zvcm1hYmxlKTtcblxuZnVuY3Rpb24gZ2V0Q29vcmRTeXMoZmluZGVyKSB7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGZpbmRlci5zZXJpZXNNb2RlbDtcbiAgcmV0dXJuIHNlcmllc01vZGVsID8gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA6IG51bGw7IC8vIGUuZy4sIGdyYXBoLlxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5leHBvcnQgdmFyIEFYSVNfVFlQRVMgPSB7XG4gIHZhbHVlOiAxLFxuICBjYXRlZ29yeTogMSxcbiAgdGltZTogMSxcbiAgbG9nOiAxXG59OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbnZhciBkZWZhdWx0T3B0aW9uID0ge1xuICBzaG93OiB0cnVlLFxuICB6bGV2ZWw6IDAsXG4gIHo6IDAsXG4gIC8vIEludmVyc2UgdGhlIGF4aXMuXG4gIGludmVyc2U6IGZhbHNlLFxuICAvLyBBeGlzIG5hbWUgZGlzcGxheWVkLlxuICBuYW1lOiAnJyxcbiAgLy8gJ3N0YXJ0JyB8ICdtaWRkbGUnIHwgJ2VuZCdcbiAgbmFtZUxvY2F0aW9uOiAnZW5kJyxcbiAgLy8gQnkgZGVncmVlLiBCeSBkZWZhdWx0IGF1dG8gcm90YXRlIGJ5IG5hbWVMb2NhdGlvbi5cbiAgbmFtZVJvdGF0ZTogbnVsbCxcbiAgbmFtZVRydW5jYXRlOiB7XG4gICAgbWF4V2lkdGg6IG51bGwsXG4gICAgZWxsaXBzaXM6ICcuLi4nLFxuICAgIHBsYWNlaG9sZGVyOiAnLidcbiAgfSxcbiAgLy8gVXNlIGdsb2JhbCB0ZXh0IHN0eWxlIGJ5IGRlZmF1bHQuXG4gIG5hbWVUZXh0U3R5bGU6IHt9LFxuICAvLyBUaGUgZ2FwIGJldHdlZW4gYXhpc05hbWUgYW5kIGF4aXNMaW5lLlxuICBuYW1lR2FwOiAxNSxcbiAgLy8gRGVmYXVsdCBgZmFsc2VgIHRvIHN1cHBvcnQgdG9vbHRpcC5cbiAgc2lsZW50OiBmYWxzZSxcbiAgLy8gRGVmYXVsdCBgZmFsc2VgIHRvIGF2b2lkIGxlZ2FjeSB1c2VyIGV2ZW50IGxpc3RlbmVyIGZhaWwuXG4gIHRyaWdnZXJFdmVudDogZmFsc2UsXG4gIHRvb2x0aXA6IHtcbiAgICBzaG93OiBmYWxzZVxuICB9LFxuICBheGlzUG9pbnRlcjoge30sXG4gIGF4aXNMaW5lOiB7XG4gICAgc2hvdzogdHJ1ZSxcbiAgICBvblplcm86IHRydWUsXG4gICAgb25aZXJvQXhpc0luZGV4OiBudWxsLFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgY29sb3I6ICcjNkU3MDc5JyxcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgIH0sXG4gICAgLy8gVGhlIGFycm93IGF0IGJvdGggZW5kcyB0aGUgdGhlIGF4aXMuXG4gICAgc3ltYm9sOiBbJ25vbmUnLCAnbm9uZSddLFxuICAgIHN5bWJvbFNpemU6IFsxMCwgMTVdXG4gIH0sXG4gIGF4aXNUaWNrOiB7XG4gICAgc2hvdzogdHJ1ZSxcbiAgICAvLyBXaGV0aGVyIGF4aXNUaWNrIGlzIGluc2lkZSB0aGUgZ3JpZCBvciBvdXRzaWRlIHRoZSBncmlkLlxuICAgIGluc2lkZTogZmFsc2UsXG4gICAgLy8gVGhlIGxlbmd0aCBvZiBheGlzVGljay5cbiAgICBsZW5ndGg6IDUsXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICB3aWR0aDogMVxuICAgIH1cbiAgfSxcbiAgYXhpc0xhYmVsOiB7XG4gICAgc2hvdzogdHJ1ZSxcbiAgICAvLyBXaGV0aGVyIGF4aXNMYWJlbCBpcyBpbnNpZGUgdGhlIGdyaWQgb3Igb3V0c2lkZSB0aGUgZ3JpZC5cbiAgICBpbnNpZGU6IGZhbHNlLFxuICAgIHJvdGF0ZTogMCxcbiAgICAvLyB0cnVlIHwgZmFsc2UgfCBudWxsL3VuZGVmaW5lZCAoYXV0bylcbiAgICBzaG93TWluTGFiZWw6IG51bGwsXG4gICAgLy8gdHJ1ZSB8IGZhbHNlIHwgbnVsbC91bmRlZmluZWQgKGF1dG8pXG4gICAgc2hvd01heExhYmVsOiBudWxsLFxuICAgIG1hcmdpbjogOCxcbiAgICAvLyBmb3JtYXR0ZXI6IG51bGwsXG4gICAgZm9udFNpemU6IDEyXG4gIH0sXG4gIHNwbGl0TGluZToge1xuICAgIHNob3c6IHRydWUsXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICBjb2xvcjogWycjRTBFNkYxJ10sXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICB9XG4gIH0sXG4gIHNwbGl0QXJlYToge1xuICAgIHNob3c6IGZhbHNlLFxuICAgIGFyZWFTdHlsZToge1xuICAgICAgY29sb3I6IFsncmdiYSgyNTAsMjUwLDI1MCwwLjIpJywgJ3JnYmEoMjEwLDIxOSwyMzgsMC4yKSddXG4gICAgfVxuICB9XG59O1xudmFyIGNhdGVnb3J5QXhpcyA9IHpyVXRpbC5tZXJnZSh7XG4gIC8vIFRoZSBnYXAgYXQgYm90aCBlbmRzIG9mIHRoZSBheGlzLiBGb3IgY2F0ZWdvcnlBeGlzLCBib29sZWFuLlxuICBib3VuZGFyeUdhcDogdHJ1ZSxcbiAgLy8gU2V0IGZhbHNlIHRvIGZhc3RlciBjYXRlZ29yeSBjb2xsZWN0aW9uLlxuICBkZWR1cGxpY2F0aW9uOiBudWxsLFxuICAvLyBzcGxpdEFyZWE6IHtcbiAgLy8gc2hvdzogZmFsc2VcbiAgLy8gfSxcbiAgc3BsaXRMaW5lOiB7XG4gICAgc2hvdzogZmFsc2VcbiAgfSxcbiAgYXhpc1RpY2s6IHtcbiAgICAvLyBJZiB0aWNrIGlzIGFsaWduIHdpdGggbGFiZWwgd2hlbiBib3VuZGFyeUdhcCBpcyB0cnVlXG4gICAgYWxpZ25XaXRoTGFiZWw6IGZhbHNlLFxuICAgIGludGVydmFsOiAnYXV0bydcbiAgfSxcbiAgYXhpc0xhYmVsOiB7XG4gICAgaW50ZXJ2YWw6ICdhdXRvJ1xuICB9XG59LCBkZWZhdWx0T3B0aW9uKTtcbnZhciB2YWx1ZUF4aXMgPSB6clV0aWwubWVyZ2Uoe1xuICBib3VuZGFyeUdhcDogWzAsIDBdLFxuICBheGlzTGluZToge1xuICAgIC8vIE5vdCBzaG93biB3aGVuIG90aGVyIGF4aXMgaXMgY2F0ZWdvcnlBeGlzIGluIGNhcnRlc2lhblxuICAgIHNob3c6ICdhdXRvJ1xuICB9LFxuICBheGlzVGljazoge1xuICAgIC8vIE5vdCBzaG93biB3aGVuIG90aGVyIGF4aXMgaXMgY2F0ZWdvcnlBeGlzIGluIGNhcnRlc2lhblxuICAgIHNob3c6ICdhdXRvJ1xuICB9LFxuICAvLyBUT0RPXG4gIC8vIG1pbi9tYXg6IFszMCwgZGF0YW1pbiwgNjBdIG9yIFsyMCwgZGF0YW1pbl0gb3IgW2RhdGFtaW4sIDYwXVxuICBzcGxpdE51bWJlcjogNSxcbiAgbWlub3JUaWNrOiB7XG4gICAgLy8gTWlub3IgdGljaywgbm90IGF2YWlsYWJsZSBmb3IgY2F0ZW9ncnkgYXhpcy5cbiAgICBzaG93OiBmYWxzZSxcbiAgICAvLyBTcGxpdCBudW1iZXIgb2YgbWlub3IgdGlja3MuIFRoZSB2YWx1ZSBzaG91bGQgYmUgaW4gcmFuZ2Ugb2YgKDAsIDEwMClcbiAgICBzcGxpdE51bWJlcjogNSxcbiAgICAvLyBMZW5naHQgb2YgbWlub3IgdGlja1xuICAgIGxlbmd0aDogMyxcbiAgICAvLyBMaW5lIHN0eWxlXG4gICAgbGluZVN0eWxlOiB7Ly8gRGVmYXVsdCB0byBiZSBzYW1lIHdpdGggYXhpc1RpY2tcbiAgICB9XG4gIH0sXG4gIG1pbm9yU3BsaXRMaW5lOiB7XG4gICAgc2hvdzogZmFsc2UsXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNGNEY3RkQnLFxuICAgICAgd2lkdGg6IDFcbiAgICB9XG4gIH1cbn0sIGRlZmF1bHRPcHRpb24pO1xudmFyIHRpbWVBeGlzID0genJVdGlsLm1lcmdlKHtcbiAgc2NhbGU6IHRydWUsXG4gIHNwbGl0TnVtYmVyOiA2LFxuICBheGlzTGFiZWw6IHtcbiAgICAvLyBUbyBlbGltaW5hdGUgbGFiZWxzIHRoYXQgYXJlIG5vdCBuaWNlXG4gICAgc2hvd01pbkxhYmVsOiBmYWxzZSxcbiAgICBzaG93TWF4TGFiZWw6IGZhbHNlLFxuICAgIHJpY2g6IHtcbiAgICAgIHByaW1hcnk6IHtcbiAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzcGxpdExpbmU6IHtcbiAgICBzaG93OiBmYWxzZVxuICB9XG59LCB2YWx1ZUF4aXMpO1xudmFyIGxvZ0F4aXMgPSB6clV0aWwuZGVmYXVsdHMoe1xuICBzY2FsZTogdHJ1ZSxcbiAgbG9nQmFzZTogMTBcbn0sIHZhbHVlQXhpcyk7XG5leHBvcnQgZGVmYXVsdCB7XG4gIGNhdGVnb3J5OiBjYXRlZ29yeUF4aXMsXG4gIHZhbHVlOiB2YWx1ZUF4aXMsXG4gIHRpbWU6IHRpbWVBeGlzLFxuICBsb2c6IGxvZ0F4aXNcbn07IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IGF4aXNEZWZhdWx0IGZyb20gJy4vYXhpc0RlZmF1bHQnO1xuaW1wb3J0IHsgZ2V0TGF5b3V0UGFyYW1zLCBtZXJnZUxheW91dFBhcmFtLCBmZXRjaExheW91dE1vZGUgfSBmcm9tICcuLi91dGlsL2xheW91dCc7XG5pbXBvcnQgT3JkaW5hbE1ldGEgZnJvbSAnLi4vZGF0YS9PcmRpbmFsTWV0YSc7XG5pbXBvcnQgeyBBWElTX1RZUEVTIH0gZnJvbSAnLi9heGlzQ29tbW9uVHlwZXMnO1xuaW1wb3J0IHsgZWFjaCwgbWVyZ2UgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuLyoqXG4gKiBHZW5lcmF0ZSBzdWIgYXhpcyBtb2RlbCBjbGFzc1xuICogQHBhcmFtIGF4aXNOYW1lICd4JyAneScgJ3JhZGl1cycgJ2FuZ2xlJyAncGFyYWxsZWwnIC4uLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGF4aXNNb2RlbENyZWF0b3IocmVnaXN0ZXJzLCBheGlzTmFtZSwgQmFzZUF4aXNNb2RlbENsYXNzLCBleHRyYURlZmF1bHRPcHRpb24pIHtcbiAgZWFjaChBWElTX1RZUEVTLCBmdW5jdGlvbiAodiwgYXhpc1R5cGUpIHtcbiAgICB2YXIgZGVmYXVsdE9wdGlvbiA9IG1lcmdlKG1lcmdlKHt9LCBheGlzRGVmYXVsdFtheGlzVHlwZV0sIHRydWUpLCBleHRyYURlZmF1bHRPcHRpb24sIHRydWUpO1xuXG4gICAgdmFyIEF4aXNNb2RlbCA9XG4gICAgLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyhBeGlzTW9kZWwsIF9zdXBlcik7XG5cbiAgICAgIGZ1bmN0aW9uIEF4aXNNb2RlbCgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmdzKSB8fCB0aGlzO1xuXG4gICAgICAgIF90aGlzLnR5cGUgPSBheGlzTmFtZSArICdBeGlzLicgKyBheGlzVHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuXG4gICAgICBBeGlzTW9kZWwucHJvdG90eXBlLm1lcmdlRGVmYXVsdEFuZFRoZW1lID0gZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICB2YXIgbGF5b3V0TW9kZSA9IGZldGNoTGF5b3V0TW9kZSh0aGlzKTtcbiAgICAgICAgdmFyIGlucHV0UG9zaXRpb25QYXJhbXMgPSBsYXlvdXRNb2RlID8gZ2V0TGF5b3V0UGFyYW1zKG9wdGlvbikgOiB7fTtcbiAgICAgICAgdmFyIHRoZW1lTW9kZWwgPSBlY01vZGVsLmdldFRoZW1lKCk7XG4gICAgICAgIG1lcmdlKG9wdGlvbiwgdGhlbWVNb2RlbC5nZXQoYXhpc1R5cGUgKyAnQXhpcycpKTtcbiAgICAgICAgbWVyZ2Uob3B0aW9uLCB0aGlzLmdldERlZmF1bHRPcHRpb24oKSk7XG4gICAgICAgIG9wdGlvbi50eXBlID0gZ2V0QXhpc1R5cGUob3B0aW9uKTtcblxuICAgICAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgICAgIG1lcmdlTGF5b3V0UGFyYW0ob3B0aW9uLCBpbnB1dFBvc2l0aW9uUGFyYW1zLCBsYXlvdXRNb2RlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQXhpc01vZGVsLnByb3RvdHlwZS5vcHRpb25VcGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzT3B0aW9uLnR5cGUgPT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgICB0aGlzLl9fb3JkaW5hbE1ldGEgPSBPcmRpbmFsTWV0YS5jcmVhdGVCeUF4aXNNb2RlbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogU2hvdWxkIG5vdCBiZSBjYWxsZWQgYmVmb3JlIGFsbCBvZiAnZ2V0SW5pdGFpbERhdGEnIGZpbmlzaGVkLlxuICAgICAgICogQmVjYXVzZSBjYXRlZ29yaWVzIGFyZSBjb2xsZWN0ZWQgZHVyaW5nIGluaXRpYWxpemluZyBkYXRhLlxuICAgICAgICovXG5cblxuICAgICAgQXhpc01vZGVsLnByb3RvdHlwZS5nZXRDYXRlZ29yaWVzID0gZnVuY3Rpb24gKHJhd0RhdGEpIHtcbiAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uOyAvLyBGSVhNRVxuICAgICAgICAvLyB3YXJuaW5nIGlmIGNhbGxlZCBiZWZvcmUgYWxsIG9mICdnZXRJbml0YWlsRGF0YScgZmluaXNoZWQuXG5cbiAgICAgICAgaWYgKG9wdGlvbi50eXBlID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICAgICAgaWYgKHJhd0RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uZGF0YTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5fX29yZGluYWxNZXRhLmNhdGVnb3JpZXM7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIEF4aXNNb2RlbC5wcm90b3R5cGUuZ2V0T3JkaW5hbE1ldGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fb3JkaW5hbE1ldGE7XG4gICAgICB9O1xuXG4gICAgICBBeGlzTW9kZWwudHlwZSA9IGF4aXNOYW1lICsgJ0F4aXMuJyArIGF4aXNUeXBlO1xuICAgICAgQXhpc01vZGVsLmRlZmF1bHRPcHRpb24gPSBkZWZhdWx0T3B0aW9uO1xuICAgICAgcmV0dXJuIEF4aXNNb2RlbDtcbiAgICB9KEJhc2VBeGlzTW9kZWxDbGFzcyk7XG5cbiAgICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChBeGlzTW9kZWwpO1xuICB9KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlcihheGlzTmFtZSArICdBeGlzJywgZ2V0QXhpc1R5cGUpO1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzVHlwZShvcHRpb24pIHtcbiAgLy8gRGVmYXVsdCBheGlzIHdpdGggZGF0YSBpcyBjYXRlZ29yeSBheGlzXG4gIHJldHVybiBvcHRpb24udHlwZSB8fCAob3B0aW9uLmRhdGEgPyAnY2F0ZWdvcnknIDogJ3ZhbHVlJyk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IEF4aXMgZnJvbSAnLi4vQXhpcyc7XG5cbnZhciBBeGlzMkQgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQXhpczJELCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEF4aXMyRChkaW0sIHNjYWxlLCBjb29yZEV4dGVudCwgYXhpc1R5cGUsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGltLCBzY2FsZSwgY29vcmRFeHRlbnQpIHx8IHRoaXM7XG4gICAgLyoqXG4gICAgICogSW5kZXggb2YgYXhpcywgY2FuIGJlIHVzZWQgYXMga2V5XG4gICAgICogSW5qZWN0ZWQgb3V0c2lkZS5cbiAgICAgKi9cblxuXG4gICAgX3RoaXMuaW5kZXggPSAwO1xuICAgIF90aGlzLnR5cGUgPSBheGlzVHlwZSB8fCAndmFsdWUnO1xuICAgIF90aGlzLnBvc2l0aW9uID0gcG9zaXRpb24gfHwgJ2JvdHRvbSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgQXhpczJELnByb3RvdHlwZS5pc0hvcml6b250YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfTtcbiAgLyoqXG4gICAqIEVhY2ggaXRlbSBjb29yZXNwb25kcyB0byB0aGlzLmdldEV4dGVudCgpLCB3aGljaFxuICAgKiBtZWFucyBnbG9iYWxFeHRlbnRbMF0gbWF5IGdyZWF0ZXIgdGhhbiBnbG9iYWxFeHRlbnRbMV0sXG4gICAqIHVubGVzcyBgYXNjYCBpcyBpbnB1dC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbYXNjXVxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG5cblxuICBBeGlzMkQucHJvdG90eXBlLmdldEdsb2JhbEV4dGVudCA9IGZ1bmN0aW9uIChhc2MpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICByZXRbMF0gPSB0aGlzLnRvR2xvYmFsQ29vcmQocmV0WzBdKTtcbiAgICByZXRbMV0gPSB0aGlzLnRvR2xvYmFsQ29vcmQocmV0WzFdKTtcbiAgICBhc2MgJiYgcmV0WzBdID4gcmV0WzFdICYmIHJldC5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBBeGlzMkQucHJvdG90eXBlLnBvaW50VG9EYXRhID0gZnVuY3Rpb24gKHBvaW50LCBjbGFtcCkge1xuICAgIHJldHVybiB0aGlzLmNvb3JkVG9EYXRhKHRoaXMudG9Mb2NhbENvb3JkKHBvaW50W3RoaXMuZGltID09PSAneCcgPyAwIDogMV0pLCBjbGFtcCk7XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgb3JkaW5hbFNvcnRJbmZvXG4gICAqIEBwYXJhbSBpbmZvIG5ldyBPcmRpbmFsU29ydEluZm9cbiAgICovXG5cblxuICBBeGlzMkQucHJvdG90eXBlLnNldENhdGVnb3J5U29ydEluZm8gPSBmdW5jdGlvbiAoaW5mbykge1xuICAgIGlmICh0aGlzLnR5cGUgIT09ICdjYXRlZ29yeScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLm1vZGVsLm9wdGlvbi5jYXRlZ29yeVNvcnRJbmZvID0gaW5mbztcbiAgICB0aGlzLnNjYWxlLnNldFNvcnRJbmZvKGluZm8pO1xuICB9O1xuXG4gIHJldHVybiBBeGlzMkQ7XG59KEF4aXMpO1xuXG5leHBvcnQgZGVmYXVsdCBBeGlzMkQ7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50JztcbmltcG9ydCB7IEF4aXNNb2RlbENvbW1vbk1peGluIH0gZnJvbSAnLi4vYXhpc01vZGVsQ29tbW9uTWl4aW4nO1xuaW1wb3J0IHsgU0lOR0xFX1JFRkVSUklORyB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwnO1xuXG52YXIgQ2FydGVzaWFuQXhpc01vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKENhcnRlc2lhbkF4aXNNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBDYXJ0ZXNpYW5BeGlzTW9kZWwoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgQ2FydGVzaWFuQXhpc01vZGVsLnByb3RvdHlwZS5nZXRDb29yZFN5c01vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ2dyaWQnLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG4gIH07XG5cbiAgQ2FydGVzaWFuQXhpc01vZGVsLnR5cGUgPSAnY2FydGVzaWFuMmRBeGlzJztcbiAgcmV0dXJuIENhcnRlc2lhbkF4aXNNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuXG5leHBvcnQgeyBDYXJ0ZXNpYW5BeGlzTW9kZWwgfTtcbnpyVXRpbC5taXhpbihDYXJ0ZXNpYW5BeGlzTW9kZWwsIEF4aXNNb2RlbENvbW1vbk1peGluKTtcbmV4cG9ydCBkZWZhdWx0IENhcnRlc2lhbkF4aXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5cbnZhciBDYXJ0ZXNpYW4gPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYXJ0ZXNpYW4obmFtZSkge1xuICAgIHRoaXMudHlwZSA9ICdjYXJ0ZXNpYW4nO1xuICAgIHRoaXMuX2RpbUxpc3QgPSBbXTtcbiAgICB0aGlzLl9heGVzID0ge307XG4gICAgdGhpcy5uYW1lID0gbmFtZSB8fCAnJztcbiAgfVxuXG4gIENhcnRlc2lhbi5wcm90b3R5cGUuZ2V0QXhpcyA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgICByZXR1cm4gdGhpcy5fYXhlc1tkaW1dO1xuICB9O1xuXG4gIENhcnRlc2lhbi5wcm90b3R5cGUuZ2V0QXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4genJVdGlsLm1hcCh0aGlzLl9kaW1MaXN0LCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXhlc1tkaW1dO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4gIENhcnRlc2lhbi5wcm90b3R5cGUuZ2V0QXhlc0J5U2NhbGUgPSBmdW5jdGlvbiAoc2NhbGVUeXBlKSB7XG4gICAgc2NhbGVUeXBlID0gc2NhbGVUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIHpyVXRpbC5maWx0ZXIodGhpcy5nZXRBeGVzKCksIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICByZXR1cm4gYXhpcy5zY2FsZS50eXBlID09PSBzY2FsZVR5cGU7XG4gICAgfSk7XG4gIH07XG5cbiAgQ2FydGVzaWFuLnByb3RvdHlwZS5hZGRBeGlzID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICB2YXIgZGltID0gYXhpcy5kaW07XG4gICAgdGhpcy5fYXhlc1tkaW1dID0gYXhpcztcblxuICAgIHRoaXMuX2RpbUxpc3QucHVzaChkaW0pO1xuICB9O1xuXG4gIHJldHVybiBDYXJ0ZXNpYW47XG59KCk7XG5cbjtcbmV4cG9ydCBkZWZhdWx0IENhcnRlc2lhbjsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQm91bmRpbmdSZWN0IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0JztcbmltcG9ydCBDYXJ0ZXNpYW4gZnJvbSAnLi9DYXJ0ZXNpYW4nO1xuaW1wb3J0IHsgaW52ZXJ0IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS9tYXRyaXgnO1xuaW1wb3J0IHsgYXBwbHlUcmFuc2Zvcm0gfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvcic7XG5leHBvcnQgdmFyIGNhcnRlc2lhbjJERGltZW5zaW9ucyA9IFsneCcsICd5J107XG5cbmZ1bmN0aW9uIGNhbkNhbGN1bGF0ZUFmZmluZVRyYW5zZm9ybShzY2FsZSkge1xuICByZXR1cm4gc2NhbGUudHlwZSA9PT0gJ2ludGVydmFsJyB8fCBzY2FsZS50eXBlID09PSAndGltZSc7XG59XG5cbnZhciBDYXJ0ZXNpYW4yRCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDYXJ0ZXNpYW4yRCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBDYXJ0ZXNpYW4yRCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSAnY2FydGVzaWFuMmQnO1xuICAgIF90aGlzLmRpbWVuc2lvbnMgPSBjYXJ0ZXNpYW4yRERpbWVuc2lvbnM7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYW4gYWZmaW5lIHRyYW5zZm9ybSBtYXRyaXggaWYgdHdvIGF4ZXMgYXJlIHRpbWUgb3IgdmFsdWUuXG4gICAqIEl0J3MgbWFpbmx5IGZvciBhY2NlbGFydGlvbiBvbiB0aGUgbGFyZ2UgdGltZSBzZXJpZXMgZGF0YS5cbiAgICovXG5cblxuICBDYXJ0ZXNpYW4yRC5wcm90b3R5cGUuY2FsY0FmZmluZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm0gPSB0aGlzLl9pbnZUcmFuc2Zvcm0gPSBudWxsO1xuICAgIHZhciB4QXhpc1NjYWxlID0gdGhpcy5nZXRBeGlzKCd4Jykuc2NhbGU7XG4gICAgdmFyIHlBeGlzU2NhbGUgPSB0aGlzLmdldEF4aXMoJ3knKS5zY2FsZTtcblxuICAgIGlmICghY2FuQ2FsY3VsYXRlQWZmaW5lVHJhbnNmb3JtKHhBeGlzU2NhbGUpIHx8ICFjYW5DYWxjdWxhdGVBZmZpbmVUcmFuc2Zvcm0oeUF4aXNTY2FsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgeFNjYWxlRXh0ZW50ID0geEF4aXNTY2FsZS5nZXRFeHRlbnQoKTtcbiAgICB2YXIgeVNjYWxlRXh0ZW50ID0geUF4aXNTY2FsZS5nZXRFeHRlbnQoKTtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLmRhdGFUb1BvaW50KFt4U2NhbGVFeHRlbnRbMF0sIHlTY2FsZUV4dGVudFswXV0pO1xuICAgIHZhciBlbmQgPSB0aGlzLmRhdGFUb1BvaW50KFt4U2NhbGVFeHRlbnRbMV0sIHlTY2FsZUV4dGVudFsxXV0pO1xuICAgIHZhciB4U2NhbGVTcGFuID0geFNjYWxlRXh0ZW50WzFdIC0geFNjYWxlRXh0ZW50WzBdO1xuICAgIHZhciB5U2NhbGVTcGFuID0geVNjYWxlRXh0ZW50WzFdIC0geVNjYWxlRXh0ZW50WzBdO1xuXG4gICAgaWYgKCF4U2NhbGVTcGFuIHx8ICF5U2NhbGVTcGFuKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBBY2NlbGVyYXRlIGRhdGEgdG8gcG9pbnQgY2FsY3VsYXRpb24gb24gdGhlIHNwZWNpYWwgbGFyZ2UgdGltZSBzZXJpZXMgZGF0YS5cblxuXG4gICAgdmFyIHNjYWxlWCA9IChlbmRbMF0gLSBzdGFydFswXSkgLyB4U2NhbGVTcGFuO1xuICAgIHZhciBzY2FsZVkgPSAoZW5kWzFdIC0gc3RhcnRbMV0pIC8geVNjYWxlU3BhbjtcbiAgICB2YXIgdHJhbnNsYXRlWCA9IHN0YXJ0WzBdIC0geFNjYWxlRXh0ZW50WzBdICogc2NhbGVYO1xuICAgIHZhciB0cmFuc2xhdGVZID0gc3RhcnRbMV0gLSB5U2NhbGVFeHRlbnRbMF0gKiBzY2FsZVk7XG4gICAgdmFyIG0gPSB0aGlzLl90cmFuc2Zvcm0gPSBbc2NhbGVYLCAwLCAwLCBzY2FsZVksIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldO1xuICAgIHRoaXMuX2ludlRyYW5zZm9ybSA9IGludmVydChbXSwgbSk7XG4gIH07XG4gIC8qKlxuICAgKiBCYXNlIGF4aXMgd2lsbCBiZSB1c2VkIG9uIHN0YWNraW5nLlxuICAgKi9cblxuXG4gIENhcnRlc2lhbjJELnByb3RvdHlwZS5nZXRCYXNlQXhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBeGVzQnlTY2FsZSgnb3JkaW5hbCcpWzBdIHx8IHRoaXMuZ2V0QXhlc0J5U2NhbGUoJ3RpbWUnKVswXSB8fCB0aGlzLmdldEF4aXMoJ3gnKTtcbiAgfTtcblxuICBDYXJ0ZXNpYW4yRC5wcm90b3R5cGUuY29udGFpblBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgdmFyIGF4aXNYID0gdGhpcy5nZXRBeGlzKCd4Jyk7XG4gICAgdmFyIGF4aXNZID0gdGhpcy5nZXRBeGlzKCd5Jyk7XG4gICAgcmV0dXJuIGF4aXNYLmNvbnRhaW4oYXhpc1gudG9Mb2NhbENvb3JkKHBvaW50WzBdKSkgJiYgYXhpc1kuY29udGFpbihheGlzWS50b0xvY2FsQ29vcmQocG9pbnRbMV0pKTtcbiAgfTtcblxuICBDYXJ0ZXNpYW4yRC5wcm90b3R5cGUuY29udGFpbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLmdldEF4aXMoJ3gnKS5jb250YWluRGF0YShkYXRhWzBdKSAmJiB0aGlzLmdldEF4aXMoJ3knKS5jb250YWluRGF0YShkYXRhWzFdKTtcbiAgfTtcblxuICBDYXJ0ZXNpYW4yRC5wcm90b3R5cGUuZGF0YVRvUG9pbnQgPSBmdW5jdGlvbiAoZGF0YSwgcmVzZXJ2ZWQsIG91dCkge1xuICAgIG91dCA9IG91dCB8fCBbXTtcbiAgICB2YXIgeFZhbCA9IGRhdGFbMF07XG4gICAgdmFyIHlWYWwgPSBkYXRhWzFdOyAvLyBGYXN0IHBhdGhcblxuICAgIGlmICh0aGlzLl90cmFuc2Zvcm0gLy8gSXQncyBzdXBwb3J0ZWQgdGhhdCBpZiBkYXRhIGlzIGxpa2UgYFtJbmlmaXR5LCAxMjNdYCwgd2hlcmUgb25seSBZIHBpeGVsIGNhbGN1bGF0ZWQuXG4gICAgJiYgeFZhbCAhPSBudWxsICYmIGlzRmluaXRlKHhWYWwpICYmIHlWYWwgIT0gbnVsbCAmJiBpc0Zpbml0ZSh5VmFsKSkge1xuICAgICAgcmV0dXJuIGFwcGx5VHJhbnNmb3JtKG91dCwgZGF0YSwgdGhpcy5fdHJhbnNmb3JtKTtcbiAgICB9XG5cbiAgICB2YXIgeEF4aXMgPSB0aGlzLmdldEF4aXMoJ3gnKTtcbiAgICB2YXIgeUF4aXMgPSB0aGlzLmdldEF4aXMoJ3knKTtcbiAgICBvdXRbMF0gPSB4QXhpcy50b0dsb2JhbENvb3JkKHhBeGlzLmRhdGFUb0Nvb3JkKHhWYWwpKTtcbiAgICBvdXRbMV0gPSB5QXhpcy50b0dsb2JhbENvb3JkKHlBeGlzLmRhdGFUb0Nvb3JkKHlWYWwpKTtcbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIENhcnRlc2lhbjJELnByb3RvdHlwZS5jbGFtcERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgb3V0KSB7XG4gICAgdmFyIHhTY2FsZSA9IHRoaXMuZ2V0QXhpcygneCcpLnNjYWxlO1xuICAgIHZhciB5U2NhbGUgPSB0aGlzLmdldEF4aXMoJ3knKS5zY2FsZTtcbiAgICB2YXIgeEF4aXNFeHRlbnQgPSB4U2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIHlBeGlzRXh0ZW50ID0geVNjYWxlLmdldEV4dGVudCgpO1xuICAgIHZhciB4ID0geFNjYWxlLnBhcnNlKGRhdGFbMF0pO1xuICAgIHZhciB5ID0geVNjYWxlLnBhcnNlKGRhdGFbMV0pO1xuICAgIG91dCA9IG91dCB8fCBbXTtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihNYXRoLm1heChNYXRoLm1pbih4QXhpc0V4dGVudFswXSwgeEF4aXNFeHRlbnRbMV0pLCB4KSwgTWF0aC5tYXgoeEF4aXNFeHRlbnRbMF0sIHhBeGlzRXh0ZW50WzFdKSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oTWF0aC5tYXgoTWF0aC5taW4oeUF4aXNFeHRlbnRbMF0sIHlBeGlzRXh0ZW50WzFdKSwgeSksIE1hdGgubWF4KHlBeGlzRXh0ZW50WzBdLCB5QXhpc0V4dGVudFsxXSkpO1xuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgQ2FydGVzaWFuMkQucHJvdG90eXBlLnBvaW50VG9EYXRhID0gZnVuY3Rpb24gKHBvaW50LCBvdXQpIHtcbiAgICBvdXQgPSBvdXQgfHwgW107XG5cbiAgICBpZiAodGhpcy5faW52VHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4gYXBwbHlUcmFuc2Zvcm0ob3V0LCBwb2ludCwgdGhpcy5faW52VHJhbnNmb3JtKTtcbiAgICB9XG5cbiAgICB2YXIgeEF4aXMgPSB0aGlzLmdldEF4aXMoJ3gnKTtcbiAgICB2YXIgeUF4aXMgPSB0aGlzLmdldEF4aXMoJ3knKTtcbiAgICBvdXRbMF0gPSB4QXhpcy5jb29yZFRvRGF0YSh4QXhpcy50b0xvY2FsQ29vcmQocG9pbnRbMF0pKTtcbiAgICBvdXRbMV0gPSB5QXhpcy5jb29yZFRvRGF0YSh5QXhpcy50b0xvY2FsQ29vcmQocG9pbnRbMV0pKTtcbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIENhcnRlc2lhbjJELnByb3RvdHlwZS5nZXRPdGhlckF4aXMgPSBmdW5jdGlvbiAoYXhpcykge1xuICAgIHJldHVybiB0aGlzLmdldEF4aXMoYXhpcy5kaW0gPT09ICd4JyA/ICd5JyA6ICd4Jyk7XG4gIH07XG4gIC8qKlxuICAgKiBHZXQgcmVjdCBhcmVhIG9mIGNhcnRlc2lhbi5cbiAgICogQXJlYSB3aWxsIGhhdmUgYSBjb250YWluIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhIHBvaW50IGlzIGluIHRoZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICovXG5cblxuICBDYXJ0ZXNpYW4yRC5wcm90b3R5cGUuZ2V0QXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgeEV4dGVudCA9IHRoaXMuZ2V0QXhpcygneCcpLmdldEdsb2JhbEV4dGVudCgpO1xuICAgIHZhciB5RXh0ZW50ID0gdGhpcy5nZXRBeGlzKCd5JykuZ2V0R2xvYmFsRXh0ZW50KCk7XG4gICAgdmFyIHggPSBNYXRoLm1pbih4RXh0ZW50WzBdLCB4RXh0ZW50WzFdKTtcbiAgICB2YXIgeSA9IE1hdGgubWluKHlFeHRlbnRbMF0sIHlFeHRlbnRbMV0pO1xuICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KHhFeHRlbnRbMF0sIHhFeHRlbnRbMV0pIC0geDtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoeUV4dGVudFswXSwgeUV4dGVudFsxXSkgLSB5O1xuICAgIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuXG4gIHJldHVybiBDYXJ0ZXNpYW4yRDtcbn0oQ2FydGVzaWFuKTtcblxuO1xuZXhwb3J0IGRlZmF1bHQgQ2FydGVzaWFuMkQ7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBHcmlkIGlzIGEgcmVnaW9uIHdoaWNoIGNvbnRhaW5zIGF0IG1vc3QgNCBjYXJ0ZXNpYW4gc3lzdGVtc1xuICpcbiAqIFRPRE8gRGVmYXVsdCBjYXJ0ZXNpYW5cbiAqL1xuaW1wb3J0IHsgaXNPYmplY3QsIGVhY2gsIGluZGV4T2YsIHJldHJpZXZlMyB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBnZXRMYXlvdXRSZWN0IH0gZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQnO1xuaW1wb3J0IHsgY3JlYXRlU2NhbGVCeU1vZGVsLCBpZkF4aXNDcm9zc1plcm8sIG5pY2VTY2FsZUV4dGVudCwgZXN0aW1hdGVMYWJlbFVuaW9uUmVjdCwgZ2V0RGF0YURpbWVuc2lvbnNPbkF4aXMgfSBmcm9tICcuLi8uLi9jb29yZC9heGlzSGVscGVyJztcbmltcG9ydCBDYXJ0ZXNpYW4yRCwgeyBjYXJ0ZXNpYW4yRERpbWVuc2lvbnMgfSBmcm9tICcuL0NhcnRlc2lhbjJEJztcbmltcG9ydCBBeGlzMkQgZnJvbSAnLi9BeGlzMkQnO1xuaW1wb3J0IHsgU0lOR0xFX1JFRkVSUklORyB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwnO1xuaW1wb3J0IHsgaXNDYXJ0ZXNpYW4yRFNlcmllcywgZmluZEF4aXNNb2RlbHMgfSBmcm9tICcuL2NhcnRlc2lhbkF4aXNIZWxwZXInO1xuXG52YXIgR3JpZCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdyaWQoZ3JpZE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAvLyBGSVhNRTpUUyB3aGVyZSB1c2VkIChkaWZmZXJlbnQgZnJvbSByZWdpc3RlcmVkIHR5cGUgJ2NhcnRlc2lhbjJkJyk/XG4gICAgdGhpcy50eXBlID0gJ2dyaWQnO1xuICAgIHRoaXMuX2Nvb3Jkc01hcCA9IHt9O1xuICAgIHRoaXMuX2Nvb3Jkc0xpc3QgPSBbXTtcbiAgICB0aGlzLl9heGVzTWFwID0ge307XG4gICAgdGhpcy5fYXhlc0xpc3QgPSBbXTtcbiAgICB0aGlzLmF4aXNQb2ludGVyRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gY2FydGVzaWFuMkREaW1lbnNpb25zO1xuXG4gICAgdGhpcy5faW5pdENhcnRlc2lhbihncmlkTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG5cbiAgICB0aGlzLm1vZGVsID0gZ3JpZE1vZGVsO1xuICB9XG5cbiAgR3JpZC5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgfTtcblxuICBHcmlkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGF4ZXNNYXAgPSB0aGlzLl9heGVzTWFwO1xuXG4gICAgdGhpcy5fdXBkYXRlU2NhbGUoZWNNb2RlbCwgdGhpcy5tb2RlbCk7XG5cbiAgICBlYWNoKGF4ZXNNYXAueCwgZnVuY3Rpb24gKHhBeGlzKSB7XG4gICAgICBuaWNlU2NhbGVFeHRlbnQoeEF4aXMuc2NhbGUsIHhBeGlzLm1vZGVsKTtcbiAgICB9KTtcbiAgICBlYWNoKGF4ZXNNYXAueSwgZnVuY3Rpb24gKHlBeGlzKSB7XG4gICAgICBuaWNlU2NhbGVFeHRlbnQoeUF4aXMuc2NhbGUsIHlBeGlzLm1vZGVsKTtcbiAgICB9KTsgLy8gS2V5OiBheGlzRGltX2F4aXNJbmRleCwgdmFsdWU6IGJvb2xlYW4sIHdoZXRoZXIgb25aZXJvIHRhcmdldC5cblxuICAgIHZhciBvblplcm9SZWNvcmRzID0ge307XG4gICAgZWFjaChheGVzTWFwLngsIGZ1bmN0aW9uICh4QXhpcykge1xuICAgICAgZml4QXhpc09uWmVybyhheGVzTWFwLCAneScsIHhBeGlzLCBvblplcm9SZWNvcmRzKTtcbiAgICB9KTtcbiAgICBlYWNoKGF4ZXNNYXAueSwgZnVuY3Rpb24gKHlBeGlzKSB7XG4gICAgICBmaXhBeGlzT25aZXJvKGF4ZXNNYXAsICd4JywgeUF4aXMsIG9uWmVyb1JlY29yZHMpO1xuICAgIH0pOyAvLyBSZXNpemUgYWdhaW4gaWYgY29udGFpbkxhYmVsIGlzIGVuYWJsZWRcbiAgICAvLyBGSVhNRSBJdCBtYXkgY2F1c2UgZ2V0dGluZyB3cm9uZyBncmlkIHNpemUgaW4gZGF0YSBwcm9jZXNzaW5nIHN0YWdlXG5cbiAgICB0aGlzLnJlc2l6ZSh0aGlzLm1vZGVsLCBhcGkpO1xuICB9O1xuICAvKipcbiAgICogUmVzaXplIHRoZSBncmlkXG4gICAqL1xuXG5cbiAgR3JpZC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKGdyaWRNb2RlbCwgYXBpLCBpZ25vcmVDb250YWluTGFiZWwpIHtcbiAgICB2YXIgYm94TGF5b3V0UGFyYW1zID0gZ3JpZE1vZGVsLmdldEJveExheW91dFBhcmFtcygpO1xuICAgIHZhciBpc0NvbnRhaW5MYWJlbCA9ICFpZ25vcmVDb250YWluTGFiZWwgJiYgZ3JpZE1vZGVsLmdldCgnY29udGFpbkxhYmVsJyk7XG4gICAgdmFyIGdyaWRSZWN0ID0gZ2V0TGF5b3V0UmVjdChib3hMYXlvdXRQYXJhbXMsIHtcbiAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgfSk7XG4gICAgdGhpcy5fcmVjdCA9IGdyaWRSZWN0O1xuICAgIHZhciBheGVzTGlzdCA9IHRoaXMuX2F4ZXNMaXN0O1xuICAgIGFkanVzdEF4ZXMoKTsgLy8gTWludXMgbGFiZWwgc2l6ZVxuXG4gICAgaWYgKGlzQ29udGFpbkxhYmVsKSB7XG4gICAgICBlYWNoKGF4ZXNMaXN0LCBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICBpZiAoIWF4aXMubW9kZWwuZ2V0KFsnYXhpc0xhYmVsJywgJ2luc2lkZSddKSkge1xuICAgICAgICAgIHZhciBsYWJlbFVuaW9uUmVjdCA9IGVzdGltYXRlTGFiZWxVbmlvblJlY3QoYXhpcyk7XG5cbiAgICAgICAgICBpZiAobGFiZWxVbmlvblJlY3QpIHtcbiAgICAgICAgICAgIHZhciBkaW0gPSBheGlzLmlzSG9yaXpvbnRhbCgpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICAgICAgdmFyIG1hcmdpbiA9IGF4aXMubW9kZWwuZ2V0KFsnYXhpc0xhYmVsJywgJ21hcmdpbiddKTtcbiAgICAgICAgICAgIGdyaWRSZWN0W2RpbV0gLT0gbGFiZWxVbmlvblJlY3RbZGltXSArIG1hcmdpbjtcblxuICAgICAgICAgICAgaWYgKGF4aXMucG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgIGdyaWRSZWN0LnkgKz0gbGFiZWxVbmlvblJlY3QuaGVpZ2h0ICsgbWFyZ2luO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChheGlzLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgZ3JpZFJlY3QueCArPSBsYWJlbFVuaW9uUmVjdC53aWR0aCArIG1hcmdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYWRqdXN0QXhlcygpO1xuICAgIH1cblxuICAgIGVhY2godGhpcy5fY29vcmRzTGlzdCwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgYWZmaW5lIG1hdHJpeCB0byBhY2NlbGVyYXRlIHRoZSBkYXRhIHRvIHBvaW50IHRyYW5zZm9ybS5cbiAgICAgIC8vIElmIGFsbCB0aGUgYXhlcyBzY2FsZXMgYXJlIHRpbWUgb3IgdmFsdWUuXG4gICAgICBjb29yZC5jYWxjQWZmaW5lVHJhbnNmb3JtKCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGp1c3RBeGVzKCkge1xuICAgICAgZWFjaChheGVzTGlzdCwgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGF4aXMuaXNIb3Jpem9udGFsKCk7XG4gICAgICAgIHZhciBleHRlbnQgPSBpc0hvcml6b250YWwgPyBbMCwgZ3JpZFJlY3Qud2lkdGhdIDogWzAsIGdyaWRSZWN0LmhlaWdodF07XG4gICAgICAgIHZhciBpZHggPSBheGlzLmludmVyc2UgPyAxIDogMDtcbiAgICAgICAgYXhpcy5zZXRFeHRlbnQoZXh0ZW50W2lkeF0sIGV4dGVudFsxIC0gaWR4XSk7XG4gICAgICAgIHVwZGF0ZUF4aXNUcmFuc2Zvcm0oYXhpcywgaXNIb3Jpem9udGFsID8gZ3JpZFJlY3QueCA6IGdyaWRSZWN0LnkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIEdyaWQucHJvdG90eXBlLmdldEF4aXMgPSBmdW5jdGlvbiAoZGltLCBheGlzSW5kZXgpIHtcbiAgICB2YXIgYXhlc01hcE9uRGltID0gdGhpcy5fYXhlc01hcFtkaW1dO1xuXG4gICAgaWYgKGF4ZXNNYXBPbkRpbSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gYXhlc01hcE9uRGltW2F4aXNJbmRleCB8fCAwXTsgLy8gaWYgKGF4aXNJbmRleCA9PSBudWxsKSB7XG4gICAgICAvLyAgICAgRmluZCBmaXJzdCBheGlzXG4gICAgICAvLyAgICAgZm9yIChsZXQgbmFtZSBpbiBheGVzTWFwT25EaW0pIHtcbiAgICAgIC8vICAgICAgICAgaWYgKGF4ZXNNYXBPbkRpbS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgLy8gICAgICAgICAgICAgcmV0dXJuIGF4ZXNNYXBPbkRpbVtuYW1lXTtcbiAgICAgIC8vICAgICAgICAgfVxuICAgICAgLy8gICAgIH1cbiAgICAgIC8vIH1cbiAgICAgIC8vIHJldHVybiBheGVzTWFwT25EaW1bYXhpc0luZGV4XTtcbiAgICB9XG4gIH07XG5cbiAgR3JpZC5wcm90b3R5cGUuZ2V0QXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXhlc0xpc3Quc2xpY2UoKTtcbiAgfTtcblxuICBHcmlkLnByb3RvdHlwZS5nZXRDYXJ0ZXNpYW4gPSBmdW5jdGlvbiAoeEF4aXNJbmRleCwgeUF4aXNJbmRleCkge1xuICAgIGlmICh4QXhpc0luZGV4ICE9IG51bGwgJiYgeUF4aXNJbmRleCAhPSBudWxsKSB7XG4gICAgICB2YXIga2V5ID0gJ3gnICsgeEF4aXNJbmRleCArICd5JyArIHlBeGlzSW5kZXg7XG4gICAgICByZXR1cm4gdGhpcy5fY29vcmRzTWFwW2tleV07XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KHhBeGlzSW5kZXgpKSB7XG4gICAgICB5QXhpc0luZGV4ID0geEF4aXNJbmRleC55QXhpc0luZGV4O1xuICAgICAgeEF4aXNJbmRleCA9IHhBeGlzSW5kZXgueEF4aXNJbmRleDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgY29vcmRMaXN0ID0gdGhpcy5fY29vcmRzTGlzdDsgaSA8IGNvb3JkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNvb3JkTGlzdFtpXS5nZXRBeGlzKCd4JykuaW5kZXggPT09IHhBeGlzSW5kZXggfHwgY29vcmRMaXN0W2ldLmdldEF4aXMoJ3knKS5pbmRleCA9PT0geUF4aXNJbmRleCkge1xuICAgICAgICByZXR1cm4gY29vcmRMaXN0W2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBHcmlkLnByb3RvdHlwZS5nZXRDYXJ0ZXNpYW5zID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jb29yZHNMaXN0LnNsaWNlKCk7XG4gIH07XG4gIC8qKlxuICAgKiBAaW1wbGVtZW50c1xuICAgKi9cblxuXG4gIEdyaWQucHJvdG90eXBlLmNvbnZlcnRUb1BpeGVsID0gZnVuY3Rpb24gKGVjTW9kZWwsIGZpbmRlciwgdmFsdWUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fZmluZENvbnZlcnRUYXJnZXQoZmluZGVyKTtcblxuICAgIHJldHVybiB0YXJnZXQuY2FydGVzaWFuID8gdGFyZ2V0LmNhcnRlc2lhbi5kYXRhVG9Qb2ludCh2YWx1ZSkgOiB0YXJnZXQuYXhpcyA/IHRhcmdldC5heGlzLnRvR2xvYmFsQ29vcmQodGFyZ2V0LmF4aXMuZGF0YVRvQ29vcmQodmFsdWUpKSA6IG51bGw7XG4gIH07XG4gIC8qKlxuICAgKiBAaW1wbGVtZW50c1xuICAgKi9cblxuXG4gIEdyaWQucHJvdG90eXBlLmNvbnZlcnRGcm9tUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl9maW5kQ29udmVydFRhcmdldChmaW5kZXIpO1xuXG4gICAgcmV0dXJuIHRhcmdldC5jYXJ0ZXNpYW4gPyB0YXJnZXQuY2FydGVzaWFuLnBvaW50VG9EYXRhKHZhbHVlKSA6IHRhcmdldC5heGlzID8gdGFyZ2V0LmF4aXMuY29vcmRUb0RhdGEodGFyZ2V0LmF4aXMudG9Mb2NhbENvb3JkKHZhbHVlKSkgOiBudWxsO1xuICB9O1xuXG4gIEdyaWQucHJvdG90eXBlLl9maW5kQ29udmVydFRhcmdldCA9IGZ1bmN0aW9uIChmaW5kZXIpIHtcbiAgICB2YXIgc2VyaWVzTW9kZWwgPSBmaW5kZXIuc2VyaWVzTW9kZWw7XG4gICAgdmFyIHhBeGlzTW9kZWwgPSBmaW5kZXIueEF4aXNNb2RlbCB8fCBzZXJpZXNNb2RlbCAmJiBzZXJpZXNNb2RlbC5nZXRSZWZlcnJpbmdDb21wb25lbnRzKCd4QXhpcycsIFNJTkdMRV9SRUZFUlJJTkcpLm1vZGVsc1swXTtcbiAgICB2YXIgeUF4aXNNb2RlbCA9IGZpbmRlci55QXhpc01vZGVsIHx8IHNlcmllc01vZGVsICYmIHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3lBeGlzJywgU0lOR0xFX1JFRkVSUklORykubW9kZWxzWzBdO1xuICAgIHZhciBncmlkTW9kZWwgPSBmaW5kZXIuZ3JpZE1vZGVsO1xuICAgIHZhciBjb29yZHNMaXN0ID0gdGhpcy5fY29vcmRzTGlzdDtcbiAgICB2YXIgY2FydGVzaWFuO1xuICAgIHZhciBheGlzO1xuXG4gICAgaWYgKHNlcmllc01vZGVsKSB7XG4gICAgICBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgaW5kZXhPZihjb29yZHNMaXN0LCBjYXJ0ZXNpYW4pIDwgMCAmJiAoY2FydGVzaWFuID0gbnVsbCk7XG4gICAgfSBlbHNlIGlmICh4QXhpc01vZGVsICYmIHlBeGlzTW9kZWwpIHtcbiAgICAgIGNhcnRlc2lhbiA9IHRoaXMuZ2V0Q2FydGVzaWFuKHhBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgsIHlBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoeEF4aXNNb2RlbCkge1xuICAgICAgYXhpcyA9IHRoaXMuZ2V0QXhpcygneCcsIHhBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoeUF4aXNNb2RlbCkge1xuICAgICAgYXhpcyA9IHRoaXMuZ2V0QXhpcygneScsIHlBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgIH0gLy8gTG93ZXN0IHByaW9yaXR5LlxuICAgIGVsc2UgaWYgKGdyaWRNb2RlbCkge1xuICAgICAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgICAgIGlmIChncmlkID09PSB0aGlzKSB7XG4gICAgICAgICAgY2FydGVzaWFuID0gdGhpcy5fY29vcmRzTGlzdFswXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNhcnRlc2lhbjogY2FydGVzaWFuLFxuICAgICAgYXhpczogYXhpc1xuICAgIH07XG4gIH07XG4gIC8qKlxuICAgKiBAaW1wbGVtZW50c1xuICAgKi9cblxuXG4gIEdyaWQucHJvdG90eXBlLmNvbnRhaW5Qb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciBjb29yZCA9IHRoaXMuX2Nvb3Jkc0xpc3RbMF07XG5cbiAgICBpZiAoY29vcmQpIHtcbiAgICAgIHJldHVybiBjb29yZC5jb250YWluUG9pbnQocG9pbnQpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgY2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtc1xuICAgKi9cblxuXG4gIEdyaWQucHJvdG90eXBlLl9pbml0Q2FydGVzaWFuID0gZnVuY3Rpb24gKGdyaWRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBncmlkID0gdGhpcztcbiAgICB2YXIgYXhpc1Bvc2l0aW9uVXNlZCA9IHtcbiAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgcmlnaHQ6IGZhbHNlLFxuICAgICAgdG9wOiBmYWxzZSxcbiAgICAgIGJvdHRvbTogZmFsc2VcbiAgICB9O1xuICAgIHZhciBheGVzTWFwID0ge1xuICAgICAgeDoge30sXG4gICAgICB5OiB7fVxuICAgIH07XG4gICAgdmFyIGF4ZXNDb3VudCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTsgLy8vIENyZWF0ZSBheGlzXG5cbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ3hBeGlzJywgY3JlYXRlQXhpc0NyZWF0b3IoJ3gnKSwgdGhpcyk7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCd5QXhpcycsIGNyZWF0ZUF4aXNDcmVhdG9yKCd5JyksIHRoaXMpO1xuXG4gICAgaWYgKCFheGVzQ291bnQueCB8fCAhYXhlc0NvdW50LnkpIHtcbiAgICAgIC8vIFJvbGwgYmFjayB3aGVuIHRoZXJlIG5vIGVpdGhlciB4IG9yIHkgYXhpc1xuICAgICAgdGhpcy5fYXhlc01hcCA9IHt9O1xuICAgICAgdGhpcy5fYXhlc0xpc3QgPSBbXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9heGVzTWFwID0gYXhlc01hcDsgLy8vIENyZWF0ZSBjYXJ0ZXNpYW4yZFxuXG4gICAgZWFjaChheGVzTWFwLngsIGZ1bmN0aW9uICh4QXhpcywgeEF4aXNJbmRleCkge1xuICAgICAgZWFjaChheGVzTWFwLnksIGZ1bmN0aW9uICh5QXhpcywgeUF4aXNJbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gJ3gnICsgeEF4aXNJbmRleCArICd5JyArIHlBeGlzSW5kZXg7XG4gICAgICAgIHZhciBjYXJ0ZXNpYW4gPSBuZXcgQ2FydGVzaWFuMkQoa2V5KTtcbiAgICAgICAgY2FydGVzaWFuLm1hc3RlciA9IF90aGlzO1xuICAgICAgICBjYXJ0ZXNpYW4ubW9kZWwgPSBncmlkTW9kZWw7XG4gICAgICAgIF90aGlzLl9jb29yZHNNYXBba2V5XSA9IGNhcnRlc2lhbjtcblxuICAgICAgICBfdGhpcy5fY29vcmRzTGlzdC5wdXNoKGNhcnRlc2lhbik7XG5cbiAgICAgICAgY2FydGVzaWFuLmFkZEF4aXMoeEF4aXMpO1xuICAgICAgICBjYXJ0ZXNpYW4uYWRkQXhpcyh5QXhpcyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUF4aXNDcmVhdG9yKGRpbU5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXhpc01vZGVsLCBpZHgpIHtcbiAgICAgICAgaWYgKCFpc0F4aXNVc2VkSW5UaGVHcmlkKGF4aXNNb2RlbCwgZ3JpZE1vZGVsKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBheGlzUG9zaXRpb24gPSBheGlzTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuXG4gICAgICAgIGlmIChkaW1OYW1lID09PSAneCcpIHtcbiAgICAgICAgICAvLyBGaXggcG9zaXRpb25cbiAgICAgICAgICBpZiAoYXhpc1Bvc2l0aW9uICE9PSAndG9wJyAmJiBheGlzUG9zaXRpb24gIT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGJvdHRvbSBvZiBYXG4gICAgICAgICAgICBheGlzUG9zaXRpb24gPSBheGlzUG9zaXRpb25Vc2VkLmJvdHRvbSA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZpeCBwb3NpdGlvblxuICAgICAgICAgIGlmIChheGlzUG9zaXRpb24gIT09ICdsZWZ0JyAmJiBheGlzUG9zaXRpb24gIT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgbGVmdCBvZiBZXG4gICAgICAgICAgICBheGlzUG9zaXRpb24gPSBheGlzUG9zaXRpb25Vc2VkLmxlZnQgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNQb3NpdGlvblVzZWRbYXhpc1Bvc2l0aW9uXSA9IHRydWU7XG4gICAgICAgIHZhciBheGlzID0gbmV3IEF4aXMyRChkaW1OYW1lLCBjcmVhdGVTY2FsZUJ5TW9kZWwoYXhpc01vZGVsKSwgWzAsIDBdLCBheGlzTW9kZWwuZ2V0KCd0eXBlJyksIGF4aXNQb3NpdGlvbik7XG4gICAgICAgIHZhciBpc0NhdGVnb3J5ID0gYXhpcy50eXBlID09PSAnY2F0ZWdvcnknO1xuICAgICAgICBheGlzLm9uQmFuZCA9IGlzQ2F0ZWdvcnkgJiYgYXhpc01vZGVsLmdldCgnYm91bmRhcnlHYXAnKTtcbiAgICAgICAgYXhpcy5pbnZlcnNlID0gYXhpc01vZGVsLmdldCgnaW52ZXJzZScpOyAvLyBJbmplY3QgYXhpcyBpbnRvIGF4aXNNb2RlbFxuXG4gICAgICAgIGF4aXNNb2RlbC5heGlzID0gYXhpczsgLy8gSW5qZWN0IGF4aXNNb2RlbCBpbnRvIGF4aXNcblxuICAgICAgICBheGlzLm1vZGVsID0gYXhpc01vZGVsOyAvLyBJbmplY3QgZ3JpZCBpbmZvIGF4aXNcblxuICAgICAgICBheGlzLmdyaWQgPSBncmlkOyAvLyBJbmRleCBvZiBheGlzLCBjYW4gYmUgdXNlZCBhcyBrZXlcblxuICAgICAgICBheGlzLmluZGV4ID0gaWR4O1xuXG4gICAgICAgIGdyaWQuX2F4ZXNMaXN0LnB1c2goYXhpcyk7XG5cbiAgICAgICAgYXhlc01hcFtkaW1OYW1lXVtpZHhdID0gYXhpcztcbiAgICAgICAgYXhlc0NvdW50W2RpbU5hbWVdKys7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFVwZGF0ZSBjYXJ0ZXNpYW4gcHJvcGVydGllcyBmcm9tIHNlcmllcy5cbiAgICovXG5cblxuICBHcmlkLnByb3RvdHlwZS5fdXBkYXRlU2NhbGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZ3JpZE1vZGVsKSB7XG4gICAgLy8gUmVzZXQgc2NhbGVcbiAgICBlYWNoKHRoaXMuX2F4ZXNMaXN0LCBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgYXhpcy5zY2FsZS5zZXRFeHRlbnQoSW5maW5pdHksIC1JbmZpbml0eSk7XG5cbiAgICAgIGlmIChheGlzLnR5cGUgPT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgdmFyIGNhdGVnb3J5U29ydEluZm8gPSBheGlzLm1vZGVsLmdldCgnY2F0ZWdvcnlTb3J0SW5mbycpO1xuICAgICAgICBheGlzLnNjYWxlLnNldFNvcnRJbmZvKGNhdGVnb3J5U29ydEluZm8pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIGlmIChpc0NhcnRlc2lhbjJEU2VyaWVzKHNlcmllc01vZGVsKSkge1xuICAgICAgICB2YXIgYXhlc01vZGVsTWFwID0gZmluZEF4aXNNb2RlbHMoc2VyaWVzTW9kZWwpO1xuICAgICAgICB2YXIgeEF4aXNNb2RlbCA9IGF4ZXNNb2RlbE1hcC54QXhpc01vZGVsO1xuICAgICAgICB2YXIgeUF4aXNNb2RlbCA9IGF4ZXNNb2RlbE1hcC55QXhpc01vZGVsO1xuXG4gICAgICAgIGlmICghaXNBeGlzVXNlZEluVGhlR3JpZCh4QXhpc01vZGVsLCBncmlkTW9kZWwpIHx8ICFpc0F4aXNVc2VkSW5UaGVHcmlkKHlBeGlzTW9kZWwsIGdyaWRNb2RlbCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FydGVzaWFuID0gdGhpcy5nZXRDYXJ0ZXNpYW4oeEF4aXNNb2RlbC5jb21wb25lbnRJbmRleCwgeUF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICB2YXIgeEF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QXhpcygneCcpO1xuICAgICAgICB2YXIgeUF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QXhpcygneScpO1xuXG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICAgIHVuaW9uRXh0ZW50KGRhdGEsIHhBeGlzKTtcbiAgICAgICAgICB1bmlvbkV4dGVudChkYXRhLCB5QXhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIGZ1bmN0aW9uIHVuaW9uRXh0ZW50KGRhdGEsIGF4aXMpIHtcbiAgICAgIGVhY2goZ2V0RGF0YURpbWVuc2lvbnNPbkF4aXMoZGF0YSwgYXhpcy5kaW0pLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIGF4aXMuc2NhbGUudW5pb25FeHRlbnRGcm9tRGF0YShkYXRhLCBkaW0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHBhcmFtIGRpbSAneCcgb3IgJ3knIG9yICdhdXRvJyBvciBudWxsL3VuZGVmaW5lZFxuICAgKi9cblxuXG4gIEdyaWQucHJvdG90eXBlLmdldFRvb2x0aXBBeGVzID0gZnVuY3Rpb24gKGRpbSkge1xuICAgIHZhciBiYXNlQXhlcyA9IFtdO1xuICAgIHZhciBvdGhlckF4ZXMgPSBbXTtcbiAgICBlYWNoKHRoaXMuZ2V0Q2FydGVzaWFucygpLCBmdW5jdGlvbiAoY2FydGVzaWFuKSB7XG4gICAgICB2YXIgYmFzZUF4aXMgPSBkaW0gIT0gbnVsbCAmJiBkaW0gIT09ICdhdXRvJyA/IGNhcnRlc2lhbi5nZXRBeGlzKGRpbSkgOiBjYXJ0ZXNpYW4uZ2V0QmFzZUF4aXMoKTtcbiAgICAgIHZhciBvdGhlckF4aXMgPSBjYXJ0ZXNpYW4uZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKTtcbiAgICAgIGluZGV4T2YoYmFzZUF4ZXMsIGJhc2VBeGlzKSA8IDAgJiYgYmFzZUF4ZXMucHVzaChiYXNlQXhpcyk7XG4gICAgICBpbmRleE9mKG90aGVyQXhlcywgb3RoZXJBeGlzKSA8IDAgJiYgb3RoZXJBeGVzLnB1c2gob3RoZXJBeGlzKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZUF4ZXM6IGJhc2VBeGVzLFxuICAgICAgb3RoZXJBeGVzOiBvdGhlckF4ZXNcbiAgICB9O1xuICB9O1xuXG4gIEdyaWQuY3JlYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBncmlkcyA9IFtdO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnZ3JpZCcsIGZ1bmN0aW9uIChncmlkTW9kZWwsIGlkeCkge1xuICAgICAgdmFyIGdyaWQgPSBuZXcgR3JpZChncmlkTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgICBncmlkLm5hbWUgPSAnZ3JpZF8nICsgaWR4OyAvLyBkYXRhU2FtcGxpbmcgcmVxdWlyZXMgYXhpcyBleHRlbnQsIHNvIHJlc2l6ZVxuICAgICAgLy8gc2hvdWxkIGJlIHBlcmZvcm1lZCBpbiBjcmVhdGUgc3RhZ2UuXG5cbiAgICAgIGdyaWQucmVzaXplKGdyaWRNb2RlbCwgYXBpLCB0cnVlKTtcbiAgICAgIGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gZ3JpZDtcbiAgICAgIGdyaWRzLnB1c2goZ3JpZCk7XG4gICAgfSk7IC8vIEluamVjdCB0aGUgY29vcmRpbmF0ZVN5c3RlbXMgaW50byBzZXJpZXNNb2RlbFxuXG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgaWYgKCFpc0NhcnRlc2lhbjJEU2VyaWVzKHNlcmllc01vZGVsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBheGVzTW9kZWxNYXAgPSBmaW5kQXhpc01vZGVscyhzZXJpZXNNb2RlbCk7XG4gICAgICB2YXIgeEF4aXNNb2RlbCA9IGF4ZXNNb2RlbE1hcC54QXhpc01vZGVsO1xuICAgICAgdmFyIHlBeGlzTW9kZWwgPSBheGVzTW9kZWxNYXAueUF4aXNNb2RlbDtcbiAgICAgIHZhciBncmlkTW9kZWwgPSB4QXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKCFncmlkTW9kZWwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dyaWQgXCInICsgcmV0cmlldmUzKHhBeGlzTW9kZWwuZ2V0KCdncmlkSW5kZXgnKSwgeEF4aXNNb2RlbC5nZXQoJ2dyaWRJZCcpLCAwKSArICdcIiBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4QXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKSAhPT0geUF4aXNNb2RlbC5nZXRDb29yZFN5c01vZGVsKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3hBeGlzIGFuZCB5QXhpcyBtdXN0IHVzZSB0aGUgc2FtZSBncmlkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGdyaWQgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSBncmlkLmdldENhcnRlc2lhbih4QXhpc01vZGVsLmNvbXBvbmVudEluZGV4LCB5QXhpc01vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZ3JpZHM7XG4gIH07IC8vIEZvciBkZWNpZGluZyB3aGljaCBkaW1lbnNpb25zIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGxpc3QgZGF0YVxuXG5cbiAgR3JpZC5kaW1lbnNpb25zID0gY2FydGVzaWFuMkREaW1lbnNpb25zO1xuICByZXR1cm4gR3JpZDtcbn0oKTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGF4aXMgaXMgdXNlZCBpbiB0aGUgc3BlY2lmaWVkIGdyaWQuXG4gKi9cblxuXG5mdW5jdGlvbiBpc0F4aXNVc2VkSW5UaGVHcmlkKGF4aXNNb2RlbCwgZ3JpZE1vZGVsKSB7XG4gIHJldHVybiBheGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpID09PSBncmlkTW9kZWw7XG59XG5cbmZ1bmN0aW9uIGZpeEF4aXNPblplcm8oYXhlc01hcCwgb3RoZXJBeGlzRGltLCBheGlzLCAvLyBLZXk6IHNlZSBgZ2V0T25aZXJvUmVjb3JkS2V5YFxub25aZXJvUmVjb3Jkcykge1xuICBheGlzLmdldEF4ZXNPblplcm9PZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiBvblplcm8gb2YgbXVsdGlwbGUgYXhlcy5cbiAgICByZXR1cm4gb3RoZXJBeGlzT25aZXJvT2YgPyBbb3RoZXJBeGlzT25aZXJvT2ZdIDogW107XG4gIH07IC8vIG9uWmVybyBjYW4gbm90IGJlIGVuYWJsZWQgaW4gdGhlc2UgdHdvIHNpdHVhdGlvbnM6XG4gIC8vIDEuIFdoZW4gYW55IG90aGVyIGF4aXMgaXMgYSBjYXRlZ29yeSBheGlzLlxuICAvLyAyLiBXaGVuIG5vIGF4aXMgaXMgY3Jvc3MgMCBwb2ludC5cblxuXG4gIHZhciBvdGhlckF4ZXMgPSBheGVzTWFwW290aGVyQXhpc0RpbV07XG4gIHZhciBvdGhlckF4aXNPblplcm9PZjtcbiAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gIHZhciBvblplcm8gPSBheGlzTW9kZWwuZ2V0KFsnYXhpc0xpbmUnLCAnb25aZXJvJ10pO1xuICB2YXIgb25aZXJvQXhpc0luZGV4ID0gYXhpc01vZGVsLmdldChbJ2F4aXNMaW5lJywgJ29uWmVyb0F4aXNJbmRleCddKTtcblxuICBpZiAoIW9uWmVybykge1xuICAgIHJldHVybjtcbiAgfSAvLyBJZiB0YXJnZXQgYXhpcyBpcyBzcGVjaWZpZWQuXG5cblxuICBpZiAob25aZXJvQXhpc0luZGV4ICE9IG51bGwpIHtcbiAgICBpZiAoY2FuT25aZXJvVG9BeGlzKG90aGVyQXhlc1tvblplcm9BeGlzSW5kZXhdKSkge1xuICAgICAgb3RoZXJBeGlzT25aZXJvT2YgPSBvdGhlckF4ZXNbb25aZXJvQXhpc0luZGV4XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgYXZhaWxhYmxlIG90aGVyIGF4aXMuXG4gICAgZm9yICh2YXIgaWR4IGluIG90aGVyQXhlcykge1xuICAgICAgaWYgKG90aGVyQXhlcy5oYXNPd25Qcm9wZXJ0eShpZHgpICYmIGNhbk9uWmVyb1RvQXhpcyhvdGhlckF4ZXNbaWR4XSkgLy8gQ29uc2lkZXIgdGhhdCB0d28gWSBheGVzIG9uIG9uZSB2YWx1ZSBheGlzLFxuICAgICAgLy8gaWYgYm90aCBvblplcm8sIHRoZSB0d28gWSBheGVzIG92ZXJsYXAuXG4gICAgICAmJiAhb25aZXJvUmVjb3Jkc1tnZXRPblplcm9SZWNvcmRLZXkob3RoZXJBeGVzW2lkeF0pXSkge1xuICAgICAgICBvdGhlckF4aXNPblplcm9PZiA9IG90aGVyQXhlc1tpZHhdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAob3RoZXJBeGlzT25aZXJvT2YpIHtcbiAgICBvblplcm9SZWNvcmRzW2dldE9uWmVyb1JlY29yZEtleShvdGhlckF4aXNPblplcm9PZildID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9uWmVyb1JlY29yZEtleShheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMuZGltICsgJ18nICsgYXhpcy5pbmRleDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5Pblplcm9Ub0F4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyAmJiBheGlzLnR5cGUgIT09ICdjYXRlZ29yeScgJiYgYXhpcy50eXBlICE9PSAndGltZScgJiYgaWZBeGlzQ3Jvc3NaZXJvKGF4aXMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVBeGlzVHJhbnNmb3JtKGF4aXMsIGNvb3JkQmFzZSkge1xuICB2YXIgYXhpc0V4dGVudCA9IGF4aXMuZ2V0RXh0ZW50KCk7XG4gIHZhciBheGlzRXh0ZW50U3VtID0gYXhpc0V4dGVudFswXSArIGF4aXNFeHRlbnRbMV07IC8vIEZhc3QgdHJhbnNmb3JtXG5cbiAgYXhpcy50b0dsb2JhbENvb3JkID0gYXhpcy5kaW0gPT09ICd4JyA/IGZ1bmN0aW9uIChjb29yZCkge1xuICAgIHJldHVybiBjb29yZCArIGNvb3JkQmFzZTtcbiAgfSA6IGZ1bmN0aW9uIChjb29yZCkge1xuICAgIHJldHVybiBheGlzRXh0ZW50U3VtIC0gY29vcmQgKyBjb29yZEJhc2U7XG4gIH07XG4gIGF4aXMudG9Mb2NhbENvb3JkID0gYXhpcy5kaW0gPT09ICd4JyA/IGZ1bmN0aW9uIChjb29yZCkge1xuICAgIHJldHVybiBjb29yZCAtIGNvb3JkQmFzZTtcbiAgfSA6IGZ1bmN0aW9uIChjb29yZCkge1xuICAgIHJldHVybiBheGlzRXh0ZW50U3VtIC0gY29vcmQgKyBjb29yZEJhc2U7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdyaWQ7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IENvbXBvbmVudE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL0NvbXBvbmVudCc7XG5cbnZhciBHcmlkTW9kZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoR3JpZE1vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEdyaWRNb2RlbCgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICBHcmlkTW9kZWwudHlwZSA9ICdncmlkJztcbiAgR3JpZE1vZGVsLmRlcGVuZGVuY2llcyA9IFsneEF4aXMnLCAneUF4aXMnXTtcbiAgR3JpZE1vZGVsLmxheW91dE1vZGUgPSAnYm94JztcbiAgR3JpZE1vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgc2hvdzogZmFsc2UsXG4gICAgemxldmVsOiAwLFxuICAgIHo6IDAsXG4gICAgbGVmdDogJzEwJScsXG4gICAgdG9wOiA2MCxcbiAgICByaWdodDogJzEwJScsXG4gICAgYm90dG9tOiA3MCxcbiAgICAvLyBJZiBncmlkIHNpemUgY29udGFpbiBsYWJlbFxuICAgIGNvbnRhaW5MYWJlbDogZmFsc2UsXG4gICAgLy8gd2lkdGg6IHt0b3RhbFdpZHRofSAtIGxlZnQgLSByaWdodCxcbiAgICAvLyBoZWlnaHQ6IHt0b3RhbEhlaWdodH0gLSB0b3AgLSBib3R0b20sXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgYm9yZGVyQ29sb3I6ICcjY2NjJ1xuICB9O1xuICByZXR1cm4gR3JpZE1vZGVsO1xufShDb21wb25lbnRNb2RlbCk7XG5cbmV4cG9ydCBkZWZhdWx0IEdyaWRNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgeyBTSU5HTEVfUkVGRVJSSU5HIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG4vKipcbiAqIENhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciBjb29yZGluYXRlIHN5c3RlbSBjcmVhdGlvbiBzdGFnZS5cbiAqIChDYW4gYmUgY2FsbGVkIGJlZm9yZSBjb29yZGluYXRlIHN5c3RlbSB1cGRhdGUgc3RhZ2UpLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsYXlvdXQoZ3JpZE1vZGVsLCBheGlzTW9kZWwsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG4gIHZhciBncmlkID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gIHZhciBsYXlvdXQgPSB7fTtcbiAgdmFyIG90aGVyQXhpc09uWmVyb09mID0gYXhpcy5nZXRBeGVzT25aZXJvT2YoKVswXTtcbiAgdmFyIHJhd0F4aXNQb3NpdGlvbiA9IGF4aXMucG9zaXRpb247XG4gIHZhciBheGlzUG9zaXRpb24gPSBvdGhlckF4aXNPblplcm9PZiA/ICdvblplcm8nIDogcmF3QXhpc1Bvc2l0aW9uO1xuICB2YXIgYXhpc0RpbSA9IGF4aXMuZGltO1xuICB2YXIgcmVjdCA9IGdyaWQuZ2V0UmVjdCgpO1xuICB2YXIgcmVjdEJvdW5kID0gW3JlY3QueCwgcmVjdC54ICsgcmVjdC53aWR0aCwgcmVjdC55LCByZWN0LnkgKyByZWN0LmhlaWdodF07XG4gIHZhciBpZHggPSB7XG4gICAgbGVmdDogMCxcbiAgICByaWdodDogMSxcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiAxLFxuICAgIG9uWmVybzogMlxuICB9O1xuICB2YXIgYXhpc09mZnNldCA9IGF4aXNNb2RlbC5nZXQoJ29mZnNldCcpIHx8IDA7XG4gIHZhciBwb3NCb3VuZCA9IGF4aXNEaW0gPT09ICd4JyA/IFtyZWN0Qm91bmRbMl0gLSBheGlzT2Zmc2V0LCByZWN0Qm91bmRbM10gKyBheGlzT2Zmc2V0XSA6IFtyZWN0Qm91bmRbMF0gLSBheGlzT2Zmc2V0LCByZWN0Qm91bmRbMV0gKyBheGlzT2Zmc2V0XTtcblxuICBpZiAob3RoZXJBeGlzT25aZXJvT2YpIHtcbiAgICB2YXIgb25aZXJvQ29vcmQgPSBvdGhlckF4aXNPblplcm9PZi50b0dsb2JhbENvb3JkKG90aGVyQXhpc09uWmVyb09mLmRhdGFUb0Nvb3JkKDApKTtcbiAgICBwb3NCb3VuZFtpZHgub25aZXJvXSA9IE1hdGgubWF4KE1hdGgubWluKG9uWmVyb0Nvb3JkLCBwb3NCb3VuZFsxXSksIHBvc0JvdW5kWzBdKTtcbiAgfSAvLyBBeGlzIHBvc2l0aW9uXG5cblxuICBsYXlvdXQucG9zaXRpb24gPSBbYXhpc0RpbSA9PT0gJ3knID8gcG9zQm91bmRbaWR4W2F4aXNQb3NpdGlvbl1dIDogcmVjdEJvdW5kWzBdLCBheGlzRGltID09PSAneCcgPyBwb3NCb3VuZFtpZHhbYXhpc1Bvc2l0aW9uXV0gOiByZWN0Qm91bmRbM11dOyAvLyBBeGlzIHJvdGF0aW9uXG5cbiAgbGF5b3V0LnJvdGF0aW9uID0gTWF0aC5QSSAvIDIgKiAoYXhpc0RpbSA9PT0gJ3gnID8gMCA6IDEpOyAvLyBUaWNrIGFuZCBsYWJlbCBkaXJlY3Rpb24sIHggeSBpcyBheGlzRGltXG5cbiAgdmFyIGRpck1hcCA9IHtcbiAgICB0b3A6IC0xLFxuICAgIGJvdHRvbTogMSxcbiAgICBsZWZ0OiAtMSxcbiAgICByaWdodDogMVxuICB9O1xuICBsYXlvdXQubGFiZWxEaXJlY3Rpb24gPSBsYXlvdXQudGlja0RpcmVjdGlvbiA9IGxheW91dC5uYW1lRGlyZWN0aW9uID0gZGlyTWFwW3Jhd0F4aXNQb3NpdGlvbl07XG4gIGxheW91dC5sYWJlbE9mZnNldCA9IG90aGVyQXhpc09uWmVyb09mID8gcG9zQm91bmRbaWR4W3Jhd0F4aXNQb3NpdGlvbl1dIC0gcG9zQm91bmRbaWR4Lm9uWmVyb10gOiAwO1xuXG4gIGlmIChheGlzTW9kZWwuZ2V0KFsnYXhpc1RpY2snLCAnaW5zaWRlJ10pKSB7XG4gICAgbGF5b3V0LnRpY2tEaXJlY3Rpb24gPSAtbGF5b3V0LnRpY2tEaXJlY3Rpb247XG4gIH1cblxuICBpZiAoenJVdGlsLnJldHJpZXZlKG9wdC5sYWJlbEluc2lkZSwgYXhpc01vZGVsLmdldChbJ2F4aXNMYWJlbCcsICdpbnNpZGUnXSkpKSB7XG4gICAgbGF5b3V0LmxhYmVsRGlyZWN0aW9uID0gLWxheW91dC5sYWJlbERpcmVjdGlvbjtcbiAgfSAvLyBTcGVjaWFsIGxhYmVsIHJvdGF0aW9uXG5cblxuICB2YXIgbGFiZWxSb3RhdGUgPSBheGlzTW9kZWwuZ2V0KFsnYXhpc0xhYmVsJywgJ3JvdGF0ZSddKTtcbiAgbGF5b3V0LmxhYmVsUm90YXRlID0gYXhpc1Bvc2l0aW9uID09PSAndG9wJyA/IC1sYWJlbFJvdGF0ZSA6IGxhYmVsUm90YXRlOyAvLyBPdmVyIHNwbGl0TGluZSBhbmQgc3BsaXRBcmVhXG5cbiAgbGF5b3V0LnoyID0gMTtcbiAgcmV0dXJuIGxheW91dDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0NhcnRlc2lhbjJEU2VyaWVzKHNlcmllc01vZGVsKSB7XG4gIHJldHVybiBzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKSA9PT0gJ2NhcnRlc2lhbjJkJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQXhpc01vZGVscyhzZXJpZXNNb2RlbCkge1xuICB2YXIgYXhpc01vZGVsTWFwID0ge1xuICAgIHhBeGlzTW9kZWw6IG51bGwsXG4gICAgeUF4aXNNb2RlbDogbnVsbFxuICB9O1xuICB6clV0aWwuZWFjaChheGlzTW9kZWxNYXAsIGZ1bmN0aW9uICh2LCBrZXkpIHtcbiAgICB2YXIgYXhpc1R5cGUgPSBrZXkucmVwbGFjZSgvTW9kZWwkLywgJycpO1xuICAgIHZhciBheGlzTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRSZWZlcnJpbmdDb21wb25lbnRzKGF4aXNUeXBlLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFheGlzTW9kZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGF4aXNUeXBlICsgJyBcIicgKyB6clV0aWwucmV0cmlldmUzKHNlcmllc01vZGVsLmdldChheGlzVHlwZSArICdJbmRleCcpLCBzZXJpZXNNb2RlbC5nZXQoYXhpc1R5cGUgKyAnSWQnKSwgMCkgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXhpc01vZGVsTWFwW2tleV0gPSBheGlzTW9kZWw7XG4gIH0pO1xuICByZXR1cm4gYXhpc01vZGVsTWFwO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IEJvdW5kaW5nUmVjdCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCc7XG5pbXBvcnQgVmlldyBmcm9tICcuLi9WaWV3JztcbmltcG9ydCBnZW9Tb3VyY2VNYW5hZ2VyIGZyb20gJy4vZ2VvU291cmNlTWFuYWdlcic7XG5pbXBvcnQgeyBTSU5HTEVfUkVGRVJSSU5HIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG5cbnZhciBHZW8gPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoR2VvLCBfc3VwZXIpO1xuICAvKipcbiAgICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSBvcmdpbmFsIGludGVyZmFjZTpcbiAgICogYG5hbWUsIG1hcCwgZ2VvSnNvbiwgc3BlY2lhbEFyZWFzLCBuYW1lTWFwYCBpcyBrZXB0LlxuICAgKlxuICAgKiBAcGFyYW0gbWFwIE1hcCB0eXBlIFNwZWNpZnkgdGhlIHBvc2l0aW9uZWQgYXJlYXMgYnkgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0LlxuICAgKiBAcGFyYW0gW25hbWVNYXBdIFNwZWNpZnkgbmFtZSBhbGlhc1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIEdlbyhuYW1lLCBtYXAsIG5hbWVNYXAsIGludmVydExvbmdpdHV0ZSkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5kaW1lbnNpb25zID0gWydsbmcnLCAnbGF0J107XG4gICAgX3RoaXMudHlwZSA9ICdnZW8nO1xuICAgIF90aGlzLm1hcCA9IG1hcDtcbiAgICB2YXIgc291cmNlID0gZ2VvU291cmNlTWFuYWdlci5sb2FkKG1hcCwgbmFtZU1hcCk7XG4gICAgX3RoaXMuX25hbWVDb29yZE1hcCA9IHNvdXJjZS5uYW1lQ29vcmRNYXA7XG4gICAgX3RoaXMuX3JlZ2lvbnNNYXAgPSBzb3VyY2UucmVnaW9uc01hcDtcbiAgICBfdGhpcy5faW52ZXJ0TG9uZ2l0dXRlID0gaW52ZXJ0TG9uZ2l0dXRlID09IG51bGwgPyB0cnVlIDogaW52ZXJ0TG9uZ2l0dXRlO1xuICAgIF90aGlzLnJlZ2lvbnMgPSBzb3VyY2UucmVnaW9ucztcbiAgICBfdGhpcy5fcmVjdCA9IHNvdXJjZS5ib3VuZGluZ1JlY3Q7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIGNvbnRhaW4gdGhlIGdpdmVuIFtsbmcsIGxhdF0gY29vcmQuXG4gICAqL1xuXG5cbiAgR2VvLnByb3RvdHlwZS5jb250YWluQ29vcmQgPSBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICB2YXIgcmVnaW9ucyA9IHRoaXMucmVnaW9ucztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlZ2lvbnNbaV0uY29udGFpbihjb29yZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIEdlby5wcm90b3R5cGUudHJhbnNmb3JtVG8gPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgaW52ZXJ0TG9uZ2l0dXRlID0gdGhpcy5faW52ZXJ0TG9uZ2l0dXRlO1xuICAgIHJlY3QgPSByZWN0LmNsb25lKCk7XG5cbiAgICBpZiAoaW52ZXJ0TG9uZ2l0dXRlKSB7XG4gICAgICAvLyBMb25naXR1dGUgaXMgaW52ZXJ0ZWRcbiAgICAgIHJlY3QueSA9IC1yZWN0LnkgLSByZWN0LmhlaWdodDtcbiAgICB9XG5cbiAgICB2YXIgcmF3VHJhbnNmb3JtYWJsZSA9IHRoaXMuX3Jhd1RyYW5zZm9ybWFibGU7XG4gICAgcmF3VHJhbnNmb3JtYWJsZS50cmFuc2Zvcm0gPSByZWN0LmNhbGN1bGF0ZVRyYW5zZm9ybShuZXcgQm91bmRpbmdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcbiAgICByYXdUcmFuc2Zvcm1hYmxlLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuXG4gICAgaWYgKGludmVydExvbmdpdHV0ZSkge1xuICAgICAgcmF3VHJhbnNmb3JtYWJsZS5zY2FsZVkgPSAtcmF3VHJhbnNmb3JtYWJsZS5zY2FsZVk7XG4gICAgfVxuXG4gICAgcmF3VHJhbnNmb3JtYWJsZS51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgIHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSgpO1xuICB9O1xuXG4gIEdlby5wcm90b3R5cGUuZ2V0UmVnaW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVnaW9uc01hcC5nZXQobmFtZSk7XG4gIH07XG5cbiAgR2VvLnByb3RvdHlwZS5nZXRSZWdpb25CeUNvb3JkID0gZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgdmFyIHJlZ2lvbnMgPSB0aGlzLnJlZ2lvbnM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWdpb25zW2ldLmNvbnRhaW4oY29vcmQpKSB7XG4gICAgICAgIHJldHVybiByZWdpb25zW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEFkZCBnZW9Db29yZCBmb3IgaW5kZXhpbmcgYnkgbmFtZVxuICAgKi9cblxuXG4gIEdlby5wcm90b3R5cGUuYWRkR2VvQ29vcmQgPSBmdW5jdGlvbiAobmFtZSwgZ2VvQ29vcmQpIHtcbiAgICB0aGlzLl9uYW1lQ29vcmRNYXAuc2V0KG5hbWUsIGdlb0Nvb3JkKTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldCBnZW9Db29yZCBieSBuYW1lXG4gICAqL1xuXG5cbiAgR2VvLnByb3RvdHlwZS5nZXRHZW9Db29yZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVDb29yZE1hcC5nZXQobmFtZSk7XG4gIH07XG5cbiAgR2VvLnByb3RvdHlwZS5nZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gIH07XG5cbiAgR2VvLnByb3RvdHlwZS5kYXRhVG9Qb2ludCA9IGZ1bmN0aW9uIChkYXRhLCBub1JvYW0sIG91dCkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIE1hcCBhcmVhIG5hbWUgdG8gZ2VvQ29vcmRcbiAgICAgIGRhdGEgPSB0aGlzLmdldEdlb0Nvb3JkKGRhdGEpO1xuICAgIH1cblxuICAgIGlmIChkYXRhKSB7XG4gICAgICByZXR1cm4gVmlldy5wcm90b3R5cGUuZGF0YVRvUG9pbnQuY2FsbCh0aGlzLCBkYXRhLCBub1JvYW0sIG91dCk7XG4gICAgfVxuICB9O1xuXG4gIEdlby5wcm90b3R5cGUuY29udmVydFRvUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkge1xuICAgIHZhciBjb29yZFN5cyA9IGdldENvb3JkU3lzKGZpbmRlcik7XG4gICAgcmV0dXJuIGNvb3JkU3lzID09PSB0aGlzID8gY29vcmRTeXMuZGF0YVRvUG9pbnQodmFsdWUpIDogbnVsbDtcbiAgfTtcblxuICBHZW8ucHJvdG90eXBlLmNvbnZlcnRGcm9tUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCBwaXhlbCkge1xuICAgIHZhciBjb29yZFN5cyA9IGdldENvb3JkU3lzKGZpbmRlcik7XG4gICAgcmV0dXJuIGNvb3JkU3lzID09PSB0aGlzID8gY29vcmRTeXMucG9pbnRUb0RhdGEocGl4ZWwpIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gR2VvO1xufShWaWV3KTtcblxuO1xuenJVdGlsLm1peGluKEdlbywgVmlldyk7XG5cbmZ1bmN0aW9uIGdldENvb3JkU3lzKGZpbmRlcikge1xuICB2YXIgZ2VvTW9kZWwgPSBmaW5kZXIuZ2VvTW9kZWw7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGZpbmRlci5zZXJpZXNNb2RlbDtcbiAgcmV0dXJuIGdlb01vZGVsID8gZ2VvTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA6IHNlcmllc01vZGVsID8gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSAvLyBGb3IgbWFwIHNlcmllcy5cbiAgfHwgKHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ2dlbycsIFNJTkdMRV9SRUZFUlJJTkcpLm1vZGVsc1swXSB8fCB7fSkuY29vcmRpbmF0ZVN5c3RlbSA6IG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdlbzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCAqIGFzIG1vZGVsVXRpbCBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcbmltcG9ydCBDb21wb25lbnRNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Db21wb25lbnQnO1xuaW1wb3J0IE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL01vZGVsJztcbmltcG9ydCBnZW9DcmVhdG9yIGZyb20gJy4vZ2VvQ3JlYXRvcic7XG47XG47XG5cbnZhciBHZW9Nb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhHZW9Nb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBHZW9Nb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBHZW9Nb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEdlb01vZGVsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKTsgLy8gRGVmYXVsdCBsYWJlbCBlbXBoYXNpcyBgc2hvd2BcblxuXG4gICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyhvcHRpb24sICdsYWJlbCcsIFsnc2hvdyddKTtcbiAgfTtcblxuICBHZW9Nb2RlbC5wcm90b3R5cGUub3B0aW9uVXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIG9wdGlvbi5yZWdpb25zID0gZ2VvQ3JlYXRvci5nZXRGaWxsZWRSZWdpb25zKG9wdGlvbi5yZWdpb25zLCBvcHRpb24ubWFwLCBvcHRpb24ubmFtZU1hcCk7XG4gICAgdmFyIHNlbGVjdGVkTWFwID0ge307XG4gICAgdGhpcy5fb3B0aW9uTW9kZWxNYXAgPSB6clV0aWwucmVkdWNlKG9wdGlvbi5yZWdpb25zIHx8IFtdLCBmdW5jdGlvbiAob3B0aW9uTW9kZWxNYXAsIHJlZ2lvbk9wdCkge1xuICAgICAgdmFyIHJlZ2lvbk5hbWUgPSByZWdpb25PcHQubmFtZTtcblxuICAgICAgaWYgKHJlZ2lvbk5hbWUpIHtcbiAgICAgICAgb3B0aW9uTW9kZWxNYXAuc2V0KHJlZ2lvbk5hbWUsIG5ldyBNb2RlbChyZWdpb25PcHQsIHNlbGYpKTtcblxuICAgICAgICBpZiAocmVnaW9uT3B0LnNlbGVjdGVkKSB7XG4gICAgICAgICAgc2VsZWN0ZWRNYXBbcmVnaW9uTmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25Nb2RlbE1hcDtcbiAgICB9LCB6clV0aWwuY3JlYXRlSGFzaE1hcCgpKTtcblxuICAgIGlmICghb3B0aW9uLnNlbGVjdGVkTWFwKSB7XG4gICAgICBvcHRpb24uc2VsZWN0ZWRNYXAgPSBzZWxlY3RlZE1hcDtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBHZXQgbW9kZWwgb2YgcmVnaW9uLlxuICAgKi9cblxuXG4gIEdlb01vZGVsLnByb3RvdHlwZS5nZXRSZWdpb25Nb2RlbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbk1vZGVsTWFwLmdldChuYW1lKSB8fCBuZXcgTW9kZWwobnVsbCwgdGhpcywgdGhpcy5lY01vZGVsKTtcbiAgfTtcbiAgLyoqXG4gICAqIEZvcm1hdCBsYWJlbFxuICAgKiBAcGFyYW0gbmFtZSBSZWdpb24gbmFtZVxuICAgKi9cblxuXG4gIEdlb01vZGVsLnByb3RvdHlwZS5nZXRGb3JtYXR0ZWRMYWJlbCA9IGZ1bmN0aW9uIChuYW1lLCBzdGF0dXMpIHtcbiAgICB2YXIgcmVnaW9uTW9kZWwgPSB0aGlzLmdldFJlZ2lvbk1vZGVsKG5hbWUpO1xuICAgIHZhciBmb3JtYXR0ZXIgPSBzdGF0dXMgPT09ICdub3JtYWwnID8gcmVnaW9uTW9kZWwuZ2V0KFsnbGFiZWwnLCAnZm9ybWF0dGVyJ10pIDogcmVnaW9uTW9kZWwuZ2V0KFsnZW1waGFzaXMnLCAnbGFiZWwnLCAnZm9ybWF0dGVyJ10pO1xuICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICBuYW1lOiBuYW1lXG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwYXJhbXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcihwYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIucmVwbGFjZSgne2F9JywgbmFtZSAhPSBudWxsID8gbmFtZSA6ICcnKTtcbiAgICB9XG4gIH07XG5cbiAgR2VvTW9kZWwucHJvdG90eXBlLnNldFpvb20gPSBmdW5jdGlvbiAoem9vbSkge1xuICAgIHRoaXMub3B0aW9uLnpvb20gPSB6b29tO1xuICB9O1xuXG4gIEdlb01vZGVsLnByb3RvdHlwZS5zZXRDZW50ZXIgPSBmdW5jdGlvbiAoY2VudGVyKSB7XG4gICAgdGhpcy5vcHRpb24uY2VudGVyID0gY2VudGVyO1xuICB9OyAvLyBQRU5HSU5HIElmIHNlbGVjdGVkTW9kZSBpcyBudWxsID9cblxuXG4gIEdlb01vZGVsLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgc2VsZWN0ZWRNb2RlID0gb3B0aW9uLnNlbGVjdGVkTW9kZTtcblxuICAgIGlmICghc2VsZWN0ZWRNb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGVkTW9kZSAhPT0gJ211bHRpcGxlJykge1xuICAgICAgb3B0aW9uLnNlbGVjdGVkTWFwID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0ZWRNYXAgPSBvcHRpb24uc2VsZWN0ZWRNYXAgfHwgKG9wdGlvbi5zZWxlY3RlZE1hcCA9IHt9KTtcbiAgICBzZWxlY3RlZE1hcFtuYW1lXSA9IHRydWU7XG4gIH07XG5cbiAgR2VvTW9kZWwucHJvdG90eXBlLnVuU2VsZWN0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc2VsZWN0ZWRNYXAgPSB0aGlzLm9wdGlvbi5zZWxlY3RlZE1hcDtcblxuICAgIGlmIChzZWxlY3RlZE1hcCkge1xuICAgICAgc2VsZWN0ZWRNYXBbbmFtZV0gPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgR2VvTW9kZWwucHJvdG90eXBlLnRvZ2dsZVNlbGVjdGVkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aGlzW3RoaXMuaXNTZWxlY3RlZChuYW1lKSA/ICd1blNlbGVjdCcgOiAnc2VsZWN0J10obmFtZSk7XG4gIH07XG5cbiAgR2VvTW9kZWwucHJvdG90eXBlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzZWxlY3RlZE1hcCA9IHRoaXMub3B0aW9uLnNlbGVjdGVkTWFwO1xuICAgIHJldHVybiAhIShzZWxlY3RlZE1hcCAmJiBzZWxlY3RlZE1hcFtuYW1lXSk7XG4gIH07XG5cbiAgR2VvTW9kZWwucHJvdG90eXBlLl9pbml0U2VsZWN0ZWRNYXBGcm9tRGF0YSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIEdlb01vZGVsLnR5cGUgPSAnZ2VvJztcbiAgR2VvTW9kZWwubGF5b3V0TW9kZSA9ICdib3gnO1xuICBHZW9Nb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIHpsZXZlbDogMCxcbiAgICB6OiAwLFxuICAgIHNob3c6IHRydWUsXG4gICAgbGVmdDogJ2NlbnRlcicsXG4gICAgdG9wOiAnY2VudGVyJyxcbiAgICAvLyBJZiBzdmcgdXNlZCwgYXNwZWN0U2NhbGUgaXMgMSBieSBkZWZhdWx0LlxuICAgIC8vIGFzcGVjdFNjYWxlOiAwLjc1LFxuICAgIGFzcGVjdFNjYWxlOiBudWxsLFxuICAgIC8vLy8vIExheW91dCB3aXRoIGNlbnRlciBhbmQgc2l6ZVxuICAgIC8vIElmIHlvdSB3YW4ndCB0byBwdXQgbWFwIGluIGEgZml4ZWQgc2l6ZSBib3ggd2l0aCByaWdodCBhc3BlY3QgcmF0aW9cbiAgICAvLyBUaGlzIHR3byBwcm9wZXJ0aWVzIG1heSBtb3JlIGNvbnZlbmluZXRcbiAgICAvLyBsYXlvdXRDZW50ZXI6IFs1MCUsIDUwJV1cbiAgICAvLyBsYXlvdXRTaXplOiAxMDBcbiAgICBzaWxlbnQ6IGZhbHNlLFxuICAgIC8vIE1hcCB0eXBlXG4gICAgbWFwOiAnJyxcbiAgICAvLyBEZWZpbmUgbGVmdC10b3AsIHJpZ2h0LWJvdHRvbSBjb29yZHMgdG8gY29udHJvbCB2aWV3XG4gICAgLy8gRm9yIGV4YW1wbGUsIFsgWzE4MCwgOTBdLCBbLTE4MCwgLTkwXSBdXG4gICAgYm91bmRpbmdDb29yZHM6IG51bGwsXG4gICAgLy8gRGVmYXVsdCBvbiBjZW50ZXIgb2YgbWFwXG4gICAgY2VudGVyOiBudWxsLFxuICAgIHpvb206IDEsXG4gICAgc2NhbGVMaW1pdDogbnVsbCxcbiAgICAvLyBzZWxlY3RlZE1vZGU6IGZhbHNlXG4gICAgbGFiZWw6IHtcbiAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgY29sb3I6ICcjMDAwJ1xuICAgIH0sXG4gICAgaXRlbVN0eWxlOiB7XG4gICAgICAvLyBjb2xvcjog5ZCE5byCLFxuICAgICAgYm9yZGVyV2lkdGg6IDAuNSxcbiAgICAgIGJvcmRlckNvbG9yOiAnIzQ0NCcsXG4gICAgICBjb2xvcjogJyNlZWUnXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgY29sb3I6ICdyZ2IoMTAwLDAsMCknXG4gICAgICB9LFxuICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAncmdiYSgyNTUsMjE1LDAsMC44KSdcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdDoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgY29sb3I6ICdyZ2IoMTAwLDAsMCknXG4gICAgICB9LFxuICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAncmdiYSgyNTUsMjE1LDAsMC44KSdcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlZ2lvbnM6IFtdXG4gIH07XG4gIHJldHVybiBHZW9Nb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBHZW9Nb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gRml4IGZvciDpkpPpsbzlsptcbi8vIGxldCBSZWdpb24gPSByZXF1aXJlKCcuLi9SZWdpb24nKTtcbi8vIGxldCB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbi8vIGxldCBnZW9Db29yZCA9IFsxMjYsIDI1XTtcbnZhciBwb2ludHMgPSBbW1sxMjMuNDUxNjUyNTI2ODU1NDcsIDI1LjczNTI3MTY0NDAyMjYxXSwgWzEyMy40OTczMTQ0NTMxMjQ5OSwgMjUuNzM1MjcxNjQ0MDIyNjFdLCBbMTIzLjQ5NzMxNDQ1MzEyNDk5LCAyNS43NTA3MzQwNjQ2MDA4ODRdLCBbMTIzLjQ1MTY1MjUyNjg1NTQ3LCAyNS43NTA3MzQwNjQ2MDA4ODRdLCBbMTIzLjQ1MTY1MjUyNjg1NTQ3LCAyNS43MzUyNzE2NDQwMjI2MV1dXTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpeERpYW95dUlzbGFuZChtYXBUeXBlLCByZWdpb24pIHtcbiAgaWYgKG1hcFR5cGUgPT09ICdjaGluYScgJiYgcmVnaW9uLm5hbWUgPT09ICflj7Dmub4nKSB7XG4gICAgcmVnaW9uLmdlb21ldHJpZXMucHVzaCh7XG4gICAgICB0eXBlOiAncG9seWdvbicsXG4gICAgICBleHRlcmlvcjogcG9pbnRzWzBdXG4gICAgfSk7XG4gIH1cbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIGdlb0Nvb3JkTWFwID0ge1xuICAnUnVzc2lhJzogWzEwMCwgNjBdLFxuICAnVW5pdGVkIFN0YXRlcyc6IFstOTksIDM4XSxcbiAgJ1VuaXRlZCBTdGF0ZXMgb2YgQW1lcmljYSc6IFstOTksIDM4XVxufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpeEdlb0Nvb3JkcyhtYXBUeXBlLCByZWdpb24pIHtcbiAgaWYgKG1hcFR5cGUgPT09ICd3b3JsZCcpIHtcbiAgICB2YXIgZ2VvQ29vcmQgPSBnZW9Db29yZE1hcFtyZWdpb24ubmFtZV07XG5cbiAgICBpZiAoZ2VvQ29vcmQpIHtcbiAgICAgIHZhciBjcCA9IHJlZ2lvbi5jZW50ZXI7XG4gICAgICBjcFswXSA9IGdlb0Nvb3JkWzBdO1xuICAgICAgY3BbMV0gPSBnZW9Db29yZFsxXTtcbiAgICB9XG4gIH1cbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gRml4IGZvciDljZfmtbfor7jlsptcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IFJlZ2lvbiBmcm9tICcuLi9SZWdpb24nO1xudmFyIGdlb0Nvb3JkID0gWzEyNiwgMjVdO1xudmFyIHBvaW50cyA9IFtbWzAsIDMuNV0sIFs3LCAxMS4yXSwgWzE1LCAxMS45XSwgWzMwLCA3XSwgWzQyLCAwLjddLCBbNTIsIDAuN10sIFs1NiwgNy43XSwgWzU5LCAwLjddLCBbNjQsIDAuN10sIFs2NCwgMF0sIFs1LCAwXSwgWzAsIDMuNV1dLCBbWzEzLCAxNi4xXSwgWzE5LCAxNC43XSwgWzE2LCAyMS43XSwgWzExLCAyMy4xXSwgWzEzLCAxNi4xXV0sIFtbMTIsIDMyLjJdLCBbMTQsIDM4LjVdLCBbMTUsIDM4LjVdLCBbMTMsIDMyLjJdLCBbMTIsIDMyLjJdXSwgW1sxNiwgNDcuNl0sIFsxMiwgNTMuMl0sIFsxMywgNTMuMl0sIFsxOCwgNDcuNl0sIFsxNiwgNDcuNl1dLCBbWzYsIDY0LjRdLCBbOCwgNzBdLCBbOSwgNzBdLCBbOCwgNjQuNF0sIFs2LCA2NC40XV0sIFtbMjMsIDgyLjZdLCBbMjksIDc5LjhdLCBbMzAsIDc5LjhdLCBbMjUsIDgyLjZdLCBbMjMsIDgyLjZdXSwgW1szNywgNzAuN10sIFs0MywgNjIuM10sIFs0NCwgNjIuM10sIFszOSwgNzAuN10sIFszNywgNzAuN11dLCBbWzQ4LCA1MS4xXSwgWzUxLCA0NS41XSwgWzUzLCA0NS41XSwgWzUwLCA1MS4xXSwgWzQ4LCA1MS4xXV0sIFtbNTEsIDM1XSwgWzUxLCAyOC43XSwgWzUzLCAyOC43XSwgWzUzLCAzNV0sIFs1MSwgMzVdXSwgW1s1MiwgMjIuNF0sIFs1NSwgMTcuNV0sIFs1NiwgMTcuNV0sIFs1MywgMjIuNF0sIFs1MiwgMjIuNF1dLCBbWzU4LCAxMi42XSwgWzYyLCA3XSwgWzYzLCA3XSwgWzYwLCAxMi42XSwgWzU4LCAxMi42XV0sIFtbMCwgMy41XSwgWzAsIDkzLjFdLCBbNjQsIDkzLjFdLCBbNjQsIDBdLCBbNjMsIDBdLCBbNjMsIDkyLjRdLCBbMSwgOTIuNF0sIFsxLCAzLjVdLCBbMCwgMy41XV1dO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICBmb3IgKHZhciBrID0gMDsgayA8IHBvaW50c1tpXS5sZW5ndGg7IGsrKykge1xuICAgIHBvaW50c1tpXVtrXVswXSAvPSAxMC41O1xuICAgIHBvaW50c1tpXVtrXVsxXSAvPSAtMTAuNSAvIDAuNzU7XG4gICAgcG9pbnRzW2ldW2tdWzBdICs9IGdlb0Nvb3JkWzBdO1xuICAgIHBvaW50c1tpXVtrXVsxXSArPSBnZW9Db29yZFsxXTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaXhOYW5oYWkobWFwVHlwZSwgcmVnaW9ucykge1xuICBpZiAobWFwVHlwZSA9PT0gJ2NoaW5hJykge1xuICAgIHJlZ2lvbnMucHVzaChuZXcgUmVnaW9uKCfljZfmtbfor7jlspsnLCB6clV0aWwubWFwKHBvaW50cywgZnVuY3Rpb24gKGV4dGVyaW9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAncG9seWdvbicsXG4gICAgICAgIGV4dGVyaW9yOiBleHRlcmlvclxuICAgICAgfTtcbiAgICB9KSwgZ2VvQ29vcmQpKTtcbiAgfVxufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG52YXIgY29vcmRzT2Zmc2V0TWFwID0ge1xuICAn5Y2X5rW36K+45bKbJzogWzMyLCA4MF0sXG4gIC8vIOWFqOWbvVxuICAn5bm/5LicJzogWzAsIC0xMF0sXG4gICfpppnmuK8nOiBbMTAsIDVdLFxuICAn5r6z6ZeoJzogWy0xMCwgMTBdLFxuICAvLyfljJfkuqwnOiBbLTEwLCAwXSxcbiAgJ+Wkqea0pSc6IFs1LCA1XVxufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpeFRleHRDb29yZHMobWFwVHlwZSwgcmVnaW9uKSB7XG4gIGlmIChtYXBUeXBlID09PSAnY2hpbmEnKSB7XG4gICAgdmFyIGNvb3JkRml4ID0gY29vcmRzT2Zmc2V0TWFwW3JlZ2lvbi5uYW1lXTtcblxuICAgIGlmIChjb29yZEZpeCkge1xuICAgICAgdmFyIGNwID0gcmVnaW9uLmNlbnRlcjtcbiAgICAgIGNwWzBdICs9IGNvb3JkRml4WzBdIC8gMTAuNTtcbiAgICAgIGNwWzFdICs9IC1jb29yZEZpeFsxXSAvICgxMC41IC8gMC43NSk7XG4gICAgfVxuICB9XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IEdlbyBmcm9tICcuL0dlbyc7XG5pbXBvcnQgKiBhcyBsYXlvdXQgZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQnO1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi8uLi91dGlsL251bWJlcic7XG5pbXBvcnQgZ2VvU291cmNlTWFuYWdlciBmcm9tICcuL2dlb1NvdXJjZU1hbmFnZXInO1xuaW1wb3J0IG1hcERhdGFTdG9yYWdlIGZyb20gJy4vbWFwRGF0YVN0b3JhZ2UnO1xuLyoqXG4gKiBSZXNpemUgbWV0aG9kIGJvdW5kIHRvIHRoZSBnZW9cbiAqL1xuXG5mdW5jdGlvbiByZXNpemVHZW8oZ2VvTW9kZWwsIGFwaSkge1xuICB2YXIgYm91bmRpbmdDb29yZHMgPSBnZW9Nb2RlbC5nZXQoJ2JvdW5kaW5nQ29vcmRzJyk7XG5cbiAgaWYgKGJvdW5kaW5nQ29vcmRzICE9IG51bGwpIHtcbiAgICB2YXIgbGVmdFRvcCA9IGJvdW5kaW5nQ29vcmRzWzBdO1xuICAgIHZhciByaWdodEJvdHRvbSA9IGJvdW5kaW5nQ29vcmRzWzFdO1xuXG4gICAgaWYgKGlzTmFOKGxlZnRUb3BbMF0pIHx8IGlzTmFOKGxlZnRUb3BbMV0pIHx8IGlzTmFOKHJpZ2h0Qm90dG9tWzBdKSB8fCBpc05hTihyaWdodEJvdHRvbVsxXSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgYm91bmRpbmdDb29yZHMnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRCb3VuZGluZ1JlY3QobGVmdFRvcFswXSwgbGVmdFRvcFsxXSwgcmlnaHRCb3R0b21bMF0gLSBsZWZ0VG9wWzBdLCByaWdodEJvdHRvbVsxXSAtIGxlZnRUb3BbMV0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgdmFyIGNlbnRlck9wdGlvbiA9IGdlb01vZGVsLmdldCgnbGF5b3V0Q2VudGVyJyk7XG4gIHZhciBzaXplT3B0aW9uID0gZ2VvTW9kZWwuZ2V0KCdsYXlvdXRTaXplJyk7XG4gIHZhciB2aWV3V2lkdGggPSBhcGkuZ2V0V2lkdGgoKTtcbiAgdmFyIHZpZXdIZWlnaHQgPSBhcGkuZ2V0SGVpZ2h0KCk7XG4gIHZhciBhc3BlY3QgPSByZWN0LndpZHRoIC8gcmVjdC5oZWlnaHQgKiB0aGlzLmFzcGVjdFNjYWxlO1xuICB2YXIgdXNlQ2VudGVyQW5kU2l6ZSA9IGZhbHNlO1xuICB2YXIgY2VudGVyO1xuICB2YXIgc2l6ZTtcblxuICBpZiAoY2VudGVyT3B0aW9uICYmIHNpemVPcHRpb24pIHtcbiAgICBjZW50ZXIgPSBbbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoY2VudGVyT3B0aW9uWzBdLCB2aWV3V2lkdGgpLCBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChjZW50ZXJPcHRpb25bMV0sIHZpZXdIZWlnaHQpXTtcbiAgICBzaXplID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoc2l6ZU9wdGlvbiwgTWF0aC5taW4odmlld1dpZHRoLCB2aWV3SGVpZ2h0KSk7XG5cbiAgICBpZiAoIWlzTmFOKGNlbnRlclswXSkgJiYgIWlzTmFOKGNlbnRlclsxXSkgJiYgIWlzTmFOKHNpemUpKSB7XG4gICAgICB1c2VDZW50ZXJBbmRTaXplID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdHaXZlbiBsYXlvdXRDZW50ZXIgb3IgbGF5b3V0U2l6ZSBkYXRhIGFyZSBpbnZhbGlkLiBVc2UgbGVmdC90b3Avd2lkdGgvaGVpZ2h0IGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHZpZXdSZWN0O1xuXG4gIGlmICh1c2VDZW50ZXJBbmRTaXplKSB7XG4gICAgdmlld1JlY3QgPSB7fTtcblxuICAgIGlmIChhc3BlY3QgPiAxKSB7XG4gICAgICAvLyBXaWR0aCBpcyBzYW1lIHdpdGggc2l6ZVxuICAgICAgdmlld1JlY3Qud2lkdGggPSBzaXplO1xuICAgICAgdmlld1JlY3QuaGVpZ2h0ID0gc2l6ZSAvIGFzcGVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlld1JlY3QuaGVpZ2h0ID0gc2l6ZTtcbiAgICAgIHZpZXdSZWN0LndpZHRoID0gc2l6ZSAqIGFzcGVjdDtcbiAgICB9XG5cbiAgICB2aWV3UmVjdC55ID0gY2VudGVyWzFdIC0gdmlld1JlY3QuaGVpZ2h0IC8gMjtcbiAgICB2aWV3UmVjdC54ID0gY2VudGVyWzBdIC0gdmlld1JlY3Qud2lkdGggLyAyO1xuICB9IGVsc2Uge1xuICAgIC8vIFVzZSBsZWZ0L3RvcC93aWR0aC9oZWlnaHRcbiAgICB2YXIgYm94TGF5b3V0T3B0aW9uID0gZ2VvTW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCk7IC8vIDAuNzUgcmF0ZVxuXG4gICAgYm94TGF5b3V0T3B0aW9uLmFzcGVjdCA9IGFzcGVjdDtcbiAgICB2aWV3UmVjdCA9IGxheW91dC5nZXRMYXlvdXRSZWN0KGJveExheW91dE9wdGlvbiwge1xuICAgICAgd2lkdGg6IHZpZXdXaWR0aCxcbiAgICAgIGhlaWdodDogdmlld0hlaWdodFxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zZXRWaWV3UmVjdCh2aWV3UmVjdC54LCB2aWV3UmVjdC55LCB2aWV3UmVjdC53aWR0aCwgdmlld1JlY3QuaGVpZ2h0KTtcbiAgdGhpcy5zZXRDZW50ZXIoZ2VvTW9kZWwuZ2V0KCdjZW50ZXInKSk7XG4gIHRoaXMuc2V0Wm9vbShnZW9Nb2RlbC5nZXQoJ3pvb20nKSk7XG59IC8vIEJhY2sgY29tcGF0IGZvciBFQ2hhcnRzMiwgd2hlcmUgdGhlIGNvb3JkIG1hcCBpcyBzZXQgb24gbWFwIHNlcmllczpcbi8vIHt0eXBlOiAnbWFwJywgZ2VvQ29vcmQ6IHsnY2l0eUEnOiBbMTE2LjQ2LDM5LjkyXSwgJ2NpdHlBJzogWzExOS4xMiwyNC42MV19fSxcblxuXG5mdW5jdGlvbiBzZXRHZW9Db29yZHMoZ2VvLCBtb2RlbCkge1xuICB6clV0aWwuZWFjaChtb2RlbC5nZXQoJ2dlb0Nvb3JkJyksIGZ1bmN0aW9uIChnZW9Db29yZCwgbmFtZSkge1xuICAgIGdlby5hZGRHZW9Db29yZChuYW1lLCBnZW9Db29yZCk7XG4gIH0pO1xufVxuXG52YXIgR2VvQ3JlYXRvciA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdlb0NyZWF0b3IoKSB7XG4gICAgLy8gRm9yIGRlY2lkaW5nIHdoaWNoIGRpbWVuc2lvbnMgdG8gdXNlIHdoZW4gY3JlYXRpbmcgbGlzdCBkYXRhXG4gICAgdGhpcy5kaW1lbnNpb25zID0gR2VvLnByb3RvdHlwZS5kaW1lbnNpb25zO1xuICB9XG5cbiAgR2VvQ3JlYXRvci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBnZW9MaXN0ID0gW107IC8vIEZJWE1FIENyZWF0ZSBlYWNoIHRpbWUgbWF5IGJlIHNsb3dcblxuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnZ2VvJywgZnVuY3Rpb24gKGdlb01vZGVsLCBpZHgpIHtcbiAgICAgIHZhciBuYW1lID0gZ2VvTW9kZWwuZ2V0KCdtYXAnKTtcbiAgICAgIHZhciBhc3BlY3RTY2FsZSA9IGdlb01vZGVsLmdldCgnYXNwZWN0U2NhbGUnKTtcbiAgICAgIHZhciBpbnZlcnRMb25naXR1dGUgPSB0cnVlO1xuICAgICAgdmFyIG1hcFJlY29yZHMgPSBtYXBEYXRhU3RvcmFnZS5yZXRyaWV2ZU1hcChuYW1lKTtcblxuICAgICAgaWYgKG1hcFJlY29yZHMgJiYgbWFwUmVjb3Jkc1swXSAmJiBtYXBSZWNvcmRzWzBdLnR5cGUgPT09ICdzdmcnKSB7XG4gICAgICAgIGFzcGVjdFNjYWxlID09IG51bGwgJiYgKGFzcGVjdFNjYWxlID0gMSk7XG4gICAgICAgIGludmVydExvbmdpdHV0ZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNwZWN0U2NhbGUgPT0gbnVsbCAmJiAoYXNwZWN0U2NhbGUgPSAwLjc1KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGdlbyA9IG5ldyBHZW8obmFtZSArIGlkeCwgbmFtZSwgZ2VvTW9kZWwuZ2V0KCduYW1lTWFwJyksIGludmVydExvbmdpdHV0ZSk7XG4gICAgICBnZW8uYXNwZWN0U2NhbGUgPSBhc3BlY3RTY2FsZTtcbiAgICAgIGdlby56b29tTGltaXQgPSBnZW9Nb2RlbC5nZXQoJ3NjYWxlTGltaXQnKTtcbiAgICAgIGdlb0xpc3QucHVzaChnZW8pOyAvLyBzZXRHZW9Db29yZHMoZ2VvLCBnZW9Nb2RlbCk7XG5cbiAgICAgIGdlb01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSBnZW87XG4gICAgICBnZW8ubW9kZWwgPSBnZW9Nb2RlbDsgLy8gSW5qZWN0IHJlc2l6ZSBtZXRob2RcblxuICAgICAgZ2VvLnJlc2l6ZSA9IHJlc2l6ZUdlbztcbiAgICAgIGdlby5yZXNpemUoZ2VvTW9kZWwsIGFwaSk7XG4gICAgfSk7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJyk7XG5cbiAgICAgIGlmIChjb29yZFN5cyA9PT0gJ2dlbycpIHtcbiAgICAgICAgdmFyIGdlb0luZGV4ID0gc2VyaWVzTW9kZWwuZ2V0KCdnZW9JbmRleCcpIHx8IDA7XG4gICAgICAgIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSBnZW9MaXN0W2dlb0luZGV4XTtcbiAgICAgIH1cbiAgICB9KTsgLy8gSWYgaGFzIG1hcCBzZXJpZXNcblxuICAgIHZhciBtYXBNb2RlbEdyb3VwQnlTZXJpZXMgPSB7fTtcbiAgICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ21hcCcsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgaWYgKCFzZXJpZXNNb2RlbC5nZXRIb3N0R2VvTW9kZWwoKSkge1xuICAgICAgICB2YXIgbWFwVHlwZSA9IHNlcmllc01vZGVsLmdldE1hcFR5cGUoKTtcbiAgICAgICAgbWFwTW9kZWxHcm91cEJ5U2VyaWVzW21hcFR5cGVdID0gbWFwTW9kZWxHcm91cEJ5U2VyaWVzW21hcFR5cGVdIHx8IFtdO1xuICAgICAgICBtYXBNb2RlbEdyb3VwQnlTZXJpZXNbbWFwVHlwZV0ucHVzaChzZXJpZXNNb2RlbCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgenJVdGlsLmVhY2gobWFwTW9kZWxHcm91cEJ5U2VyaWVzLCBmdW5jdGlvbiAobWFwU2VyaWVzLCBtYXBUeXBlKSB7XG4gICAgICB2YXIgbmFtZU1hcExpc3QgPSB6clV0aWwubWFwKG1hcFNlcmllcywgZnVuY3Rpb24gKHNpbmdsZU1hcFNlcmllcykge1xuICAgICAgICByZXR1cm4gc2luZ2xlTWFwU2VyaWVzLmdldCgnbmFtZU1hcCcpO1xuICAgICAgfSk7XG4gICAgICB2YXIgZ2VvID0gbmV3IEdlbyhtYXBUeXBlLCBtYXBUeXBlLCB6clV0aWwubWVyZ2VBbGwobmFtZU1hcExpc3QpKTtcbiAgICAgIGdlby56b29tTGltaXQgPSB6clV0aWwucmV0cmlldmUuYXBwbHkobnVsbCwgenJVdGlsLm1hcChtYXBTZXJpZXMsIGZ1bmN0aW9uIChzaW5nbGVNYXBTZXJpZXMpIHtcbiAgICAgICAgcmV0dXJuIHNpbmdsZU1hcFNlcmllcy5nZXQoJ3NjYWxlTGltaXQnKTtcbiAgICAgIH0pKTtcbiAgICAgIGdlb0xpc3QucHVzaChnZW8pOyAvLyBJbmplY3QgcmVzaXplIG1ldGhvZFxuXG4gICAgICBnZW8ucmVzaXplID0gcmVzaXplR2VvO1xuICAgICAgZ2VvLmFzcGVjdFNjYWxlID0gbWFwU2VyaWVzWzBdLmdldCgnYXNwZWN0U2NhbGUnKTtcbiAgICAgIGdlby5yZXNpemUobWFwU2VyaWVzWzBdLCBhcGkpO1xuICAgICAgenJVdGlsLmVhY2gobWFwU2VyaWVzLCBmdW5jdGlvbiAoc2luZ2xlTWFwU2VyaWVzKSB7XG4gICAgICAgIHNpbmdsZU1hcFNlcmllcy5jb29yZGluYXRlU3lzdGVtID0gZ2VvO1xuICAgICAgICBzZXRHZW9Db29yZHMoZ2VvLCBzaW5nbGVNYXBTZXJpZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdlb0xpc3Q7XG4gIH07XG4gIC8qKlxuICAgKiBGaWxsIGdpdmVuIHJlZ2lvbnMgYXJyYXlcbiAgICovXG5cblxuICBHZW9DcmVhdG9yLnByb3RvdHlwZS5nZXRGaWxsZWRSZWdpb25zID0gZnVuY3Rpb24gKG9yaWdpblJlZ2lvbkFyciwgbWFwTmFtZSwgbmFtZU1hcCkge1xuICAgIC8vIE5vdCB1c2UgdGhlIG9yaWdpbmFsXG4gICAgdmFyIHJlZ2lvbnNBcnIgPSAob3JpZ2luUmVnaW9uQXJyIHx8IFtdKS5zbGljZSgpO1xuICAgIHZhciBkYXRhTmFtZU1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lvbnNBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFOYW1lTWFwLnNldChyZWdpb25zQXJyW2ldLm5hbWUsIHJlZ2lvbnNBcnJbaV0pO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2UgPSBnZW9Tb3VyY2VNYW5hZ2VyLmxvYWQobWFwTmFtZSwgbmFtZU1hcCk7XG4gICAgenJVdGlsLmVhY2goc291cmNlLnJlZ2lvbnMsIGZ1bmN0aW9uIChyZWdpb24pIHtcbiAgICAgIHZhciBuYW1lID0gcmVnaW9uLm5hbWU7XG4gICAgICAhZGF0YU5hbWVNYXAuZ2V0KG5hbWUpICYmIHJlZ2lvbnNBcnIucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZWdpb25zQXJyO1xuICB9O1xuXG4gIHJldHVybiBHZW9DcmVhdG9yO1xufSgpO1xuXG52YXIgZ2VvQ3JlYXRvciA9IG5ldyBHZW9DcmVhdG9yKCk7XG5leHBvcnQgZGVmYXVsdCBnZW9DcmVhdG9yOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBwYXJzZUdlb0pzb24gZnJvbSAnLi9wYXJzZUdlb0pzb24nO1xuaW1wb3J0IHsgbWFrZUlubmVyIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7IC8vIEJ1aWx0LWluIEdFTyBmaXhlci5cblxuaW1wb3J0IGZpeE5hbmhhaSBmcm9tICcuL2ZpeC9uYW5oYWknO1xuaW1wb3J0IGZpeFRleHRDb29yZCBmcm9tICcuL2ZpeC90ZXh0Q29vcmQnO1xuaW1wb3J0IGZpeEdlb0Nvb3JkIGZyb20gJy4vZml4L2dlb0Nvb3JkJztcbmltcG9ydCBmaXhEaWFveXVJc2xhbmQgZnJvbSAnLi9maXgvZGlhb3l1SXNsYW5kJztcbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xuZXhwb3J0IGRlZmF1bHQge1xuICBsb2FkOiBmdW5jdGlvbiAobWFwTmFtZSwgbWFwUmVjb3JkLCBuYW1lUHJvcGVydHkpIHtcbiAgICB2YXIgcGFyc2VkID0gaW5uZXIobWFwUmVjb3JkKS5wYXJzZWQ7XG5cbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cblxuICAgIHZhciBzcGVjaWFsQXJlYXMgPSBtYXBSZWNvcmQuc3BlY2lhbEFyZWFzIHx8IHt9O1xuICAgIHZhciBnZW9KU09OID0gbWFwUmVjb3JkLmdlb0pTT047XG4gICAgdmFyIHJlZ2lvbnM7IC8vIGh0dHBzOi8vanNwZXJmLmNvbS90cnktY2F0Y2gtcGVyZm9ybWFuY2Utb3ZlcmhlYWRcblxuICAgIHRyeSB7XG4gICAgICByZWdpb25zID0gZ2VvSlNPTiA/IHBhcnNlR2VvSnNvbihnZW9KU09OLCBuYW1lUHJvcGVydHkpIDogW107XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGdlb0pzb24gZm9ybWF0XFxuJyArIGUubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgZml4TmFuaGFpKG1hcE5hbWUsIHJlZ2lvbnMpO1xuICAgIGVhY2gocmVnaW9ucywgZnVuY3Rpb24gKHJlZ2lvbikge1xuICAgICAgdmFyIHJlZ2lvbk5hbWUgPSByZWdpb24ubmFtZTtcbiAgICAgIGZpeFRleHRDb29yZChtYXBOYW1lLCByZWdpb24pO1xuICAgICAgZml4R2VvQ29vcmQobWFwTmFtZSwgcmVnaW9uKTtcbiAgICAgIGZpeERpYW95dUlzbGFuZChtYXBOYW1lLCByZWdpb24pOyAvLyBTb21lIGFyZWEgbGlrZSBBbGFza2EgaW4gVVNBIG1hcCBuZWVkcyB0byBiZSB0YW5zZm9ybWVkXG4gICAgICAvLyB0byBsb29rIGJldHRlclxuXG4gICAgICB2YXIgc3BlY2lhbEFyZWEgPSBzcGVjaWFsQXJlYXNbcmVnaW9uTmFtZV07XG5cbiAgICAgIGlmIChzcGVjaWFsQXJlYSkge1xuICAgICAgICByZWdpb24udHJhbnNmb3JtVG8oc3BlY2lhbEFyZWEubGVmdCwgc3BlY2lhbEFyZWEudG9wLCBzcGVjaWFsQXJlYS53aWR0aCwgc3BlY2lhbEFyZWEuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaW5uZXIobWFwUmVjb3JkKS5wYXJzZWQgPSB7XG4gICAgICByZWdpb25zOiByZWdpb25zLFxuICAgICAgYm91bmRpbmdSZWN0OiBnZXRCb3VuZGluZ1JlY3QocmVnaW9ucylcbiAgICB9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QocmVnaW9ucykge1xuICB2YXIgcmVjdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVnaW9uUmVjdCA9IHJlZ2lvbnNbaV0uZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgcmVjdCA9IHJlY3QgfHwgcmVnaW9uUmVjdC5jbG9uZSgpO1xuICAgIHJlY3QudW5pb24ocmVnaW9uUmVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVjdDtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgcGFyc2VTVkcsIG1ha2VWaWV3Qm94VHJhbnNmb3JtIH0gZnJvbSAnenJlbmRlci9saWIvdG9vbC9wYXJzZVNWRyc7XG5pbXBvcnQgR3JvdXAgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9Hcm91cCc7XG5pbXBvcnQgUmVjdCBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QnO1xuaW1wb3J0IHsgYXNzZXJ0LCBjcmVhdGVIYXNoTWFwIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBCb3VuZGluZ1JlY3QgZnJvbSAnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnO1xuaW1wb3J0IHsgbWFrZUlubmVyIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgbG9hZDogZnVuY3Rpb24gKG1hcE5hbWUsIG1hcFJlY29yZCkge1xuICAgIHZhciBvcmlnaW5Sb290ID0gaW5uZXIobWFwUmVjb3JkKS5vcmlnaW5Sb290O1xuXG4gICAgaWYgKG9yaWdpblJvb3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvb3Q6IG9yaWdpblJvb3QsXG4gICAgICAgIGJvdW5kaW5nUmVjdDogaW5uZXIobWFwUmVjb3JkKS5ib3VuZGluZ1JlY3RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGdyYXBoaWMgPSBidWlsZEdyYXBoaWMobWFwUmVjb3JkKTtcbiAgICBpbm5lcihtYXBSZWNvcmQpLm9yaWdpblJvb3QgPSBncmFwaGljLnJvb3Q7XG4gICAgaW5uZXIobWFwUmVjb3JkKS5ib3VuZGluZ1JlY3QgPSBncmFwaGljLmJvdW5kaW5nUmVjdDtcbiAgICByZXR1cm4gZ3JhcGhpYztcbiAgfSxcbiAgbWFrZUdyYXBoaWM6IGZ1bmN0aW9uIChtYXBOYW1lLCBtYXBSZWNvcmQsIGhvc3RLZXkpIHtcbiAgICAvLyBGb3IgcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbiAoaW4gbGFyZ2UgU1ZHKSwgZ3JhcGhpYyBvbmx5IG1ha2VkXG4gICAgLy8gd2hlbiBuZWNlc3NhcnkgYW5kIHJldXNlIHRoZW0gYWNjb3JkaW5nIHRvIGhvc3RLZXkuXG4gICAgdmFyIGZpZWxkID0gaW5uZXIobWFwUmVjb3JkKTtcbiAgICB2YXIgcm9vdE1hcCA9IGZpZWxkLnJvb3RNYXAgfHwgKGZpZWxkLnJvb3RNYXAgPSBjcmVhdGVIYXNoTWFwKCkpO1xuICAgIHZhciByb290ID0gcm9vdE1hcC5nZXQoaG9zdEtleSk7XG5cbiAgICBpZiAocm9vdCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpblJvb3QgPSBmaWVsZC5vcmlnaW5Sb290O1xuICAgIHZhciBib3VuZGluZ1JlY3QgPSBmaWVsZC5ib3VuZGluZ1JlY3Q7IC8vIEZvciBwZXJmb3JtYW5jZSwgaWYgb3JpZ2luUm9vdCBpcyBub3QgdXNlZCBieSBhIHZpZXcsXG4gICAgLy8gYXNzaWduIGl0IHRvIGEgdmlldywgYnV0IG5vdCByZXByb2R1Y2UgZ3JhcGhpYyBlbGVtZW50cy5cblxuICAgIGlmICghZmllbGQub3JpZ2luUm9vdEhvc3RLZXkpIHtcbiAgICAgIGZpZWxkLm9yaWdpblJvb3RIb3N0S2V5ID0gaG9zdEtleTtcbiAgICAgIHJvb3QgPSBvcmlnaW5Sb290O1xuICAgIH0gZWxzZSB7XG4gICAgICByb290ID0gYnVpbGRHcmFwaGljKG1hcFJlY29yZCwgYm91bmRpbmdSZWN0KS5yb290O1xuICAgIH1cblxuICAgIHJldHVybiByb290TWFwLnNldChob3N0S2V5LCByb290KTtcbiAgfSxcbiAgcmVtb3ZlR3JhcGhpYzogZnVuY3Rpb24gKG1hcE5hbWUsIG1hcFJlY29yZCwgaG9zdEtleSkge1xuICAgIHZhciBmaWVsZCA9IGlubmVyKG1hcFJlY29yZCk7XG4gICAgdmFyIHJvb3RNYXAgPSBmaWVsZC5yb290TWFwO1xuICAgIHJvb3RNYXAgJiYgcm9vdE1hcC5yZW1vdmVLZXkoaG9zdEtleSk7XG5cbiAgICBpZiAoaG9zdEtleSA9PT0gZmllbGQub3JpZ2luUm9vdEhvc3RLZXkpIHtcbiAgICAgIGZpZWxkLm9yaWdpblJvb3RIb3N0S2V5ID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJ1aWxkR3JhcGhpYyhtYXBSZWNvcmQsIGJvdW5kaW5nUmVjdCkge1xuICB2YXIgc3ZnWE1MID0gbWFwUmVjb3JkLnN2Z1hNTDtcbiAgdmFyIHJlc3VsdDtcbiAgdmFyIHJvb3Q7XG5cbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBzdmdYTUwgJiYgcGFyc2VTVkcoc3ZnWE1MLCB7XG4gICAgICBpZ25vcmVWaWV3Qm94OiB0cnVlLFxuICAgICAgaWdub3JlUm9vdENsaXA6IHRydWVcbiAgICB9KSB8fCB7fTtcbiAgICByb290ID0gcmVzdWx0LnJvb3Q7XG4gICAgYXNzZXJ0KHJvb3QgIT0gbnVsbCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3ZnIGZvcm1hdFxcbicgKyBlLm1lc3NhZ2UpO1xuICB9XG5cbiAgdmFyIHN2Z1dpZHRoID0gcmVzdWx0LndpZHRoO1xuICB2YXIgc3ZnSGVpZ2h0ID0gcmVzdWx0LmhlaWdodDtcbiAgdmFyIHZpZXdCb3hSZWN0ID0gcmVzdWx0LnZpZXdCb3hSZWN0O1xuXG4gIGlmICghYm91bmRpbmdSZWN0KSB7XG4gICAgYm91bmRpbmdSZWN0ID0gc3ZnV2lkdGggPT0gbnVsbCB8fCBzdmdIZWlnaHQgPT0gbnVsbCA/IC8vIElmIHN2ZyB3aWR0aCAvIGhlaWdodCBub3Qgc3BlY2lmaWVkLCBjYWxjdWxhdGVcbiAgICAvLyBib3VuZGluZyByZWN0IGFzIHRoZSB3aWR0aCAvIGhlaWdodFxuICAgIHJvb3QuZ2V0Qm91bmRpbmdSZWN0KCkgOiBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuXG4gICAgaWYgKHN2Z1dpZHRoICE9IG51bGwpIHtcbiAgICAgIGJvdW5kaW5nUmVjdC53aWR0aCA9IHN2Z1dpZHRoO1xuICAgIH1cblxuICAgIGlmIChzdmdIZWlnaHQgIT0gbnVsbCkge1xuICAgICAgYm91bmRpbmdSZWN0LmhlaWdodCA9IHN2Z0hlaWdodDtcbiAgICB9XG4gIH1cblxuICBpZiAodmlld0JveFJlY3QpIHtcbiAgICB2YXIgdmlld0JveFRyYW5zZm9ybSA9IG1ha2VWaWV3Qm94VHJhbnNmb3JtKHZpZXdCb3hSZWN0LCBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpO1xuICAgIHZhciBlbFJvb3QgPSByb290O1xuICAgIHJvb3QgPSBuZXcgR3JvdXAoKTtcbiAgICByb290LmFkZChlbFJvb3QpO1xuICAgIGVsUm9vdC5zY2FsZVggPSBlbFJvb3Quc2NhbGVZID0gdmlld0JveFRyYW5zZm9ybS5zY2FsZTtcbiAgICBlbFJvb3QueCA9IHZpZXdCb3hUcmFuc2Zvcm0ueDtcbiAgICBlbFJvb3QueSA9IHZpZXdCb3hUcmFuc2Zvcm0ueTtcbiAgfVxuXG4gIHJvb3Quc2V0Q2xpcFBhdGgobmV3IFJlY3Qoe1xuICAgIHNoYXBlOiBib3VuZGluZ1JlY3QucGxhaW4oKVxuICB9KSk7XG4gIHJldHVybiB7XG4gICAgcm9vdDogcm9vdCxcbiAgICBib3VuZGluZ1JlY3Q6IGJvdW5kaW5nUmVjdFxuICB9O1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBlYWNoLCBjcmVhdGVIYXNoTWFwIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBtYXBEYXRhU3RvcmFnZSBmcm9tICcuL21hcERhdGFTdG9yYWdlJztcbmltcG9ydCBnZW9KU09OTG9hZGVyIGZyb20gJy4vZ2VvSlNPTkxvYWRlcic7XG5pbXBvcnQgZ2VvU1ZHTG9hZGVyIGZyb20gJy4vZ2VvU1ZHTG9hZGVyJztcbmltcG9ydCBCb3VuZGluZ1JlY3QgZnJvbSAnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnO1xudmFyIGxvYWRlcnMgPSB7XG4gIGdlb0pTT046IGdlb0pTT05Mb2FkZXIsXG4gIHN2ZzogZ2VvU1ZHTG9hZGVyXG59O1xuZXhwb3J0IGRlZmF1bHQge1xuICBsb2FkOiBmdW5jdGlvbiAobWFwTmFtZSwgbmFtZU1hcCwgbmFtZVByb3BlcnR5KSB7XG4gICAgdmFyIHJlZ2lvbnMgPSBbXTtcbiAgICB2YXIgcmVnaW9uc01hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgICB2YXIgbmFtZUNvb3JkTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuICAgIHZhciBib3VuZGluZ1JlY3Q7XG4gICAgdmFyIG1hcFJlY29yZHMgPSByZXRyaWV2ZU1hcChtYXBOYW1lKTtcbiAgICBlYWNoKG1hcFJlY29yZHMsIGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgIHZhciBzaW5nbGVTb3VyY2UgPSBsb2FkZXJzW3JlY29yZC50eXBlXS5sb2FkKG1hcE5hbWUsIHJlY29yZCwgbmFtZVByb3BlcnR5KTtcbiAgICAgIGVhY2goc2luZ2xlU291cmNlLnJlZ2lvbnMsIGZ1bmN0aW9uIChyZWdpb24pIHtcbiAgICAgICAgdmFyIHJlZ2lvbk5hbWUgPSByZWdpb24ubmFtZTsgLy8gVHJ5IHVzZSB0aGUgYWxpYXMgaW4gZ2VvTmFtZU1hcFxuXG4gICAgICAgIGlmIChuYW1lTWFwICYmIG5hbWVNYXAuaGFzT3duUHJvcGVydHkocmVnaW9uTmFtZSkpIHtcbiAgICAgICAgICByZWdpb24gPSByZWdpb24uY2xvbmVTaGFsbG93KHJlZ2lvbk5hbWUgPSBuYW1lTWFwW3JlZ2lvbk5hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lvbnMucHVzaChyZWdpb24pO1xuICAgICAgICByZWdpb25zTWFwLnNldChyZWdpb25OYW1lLCByZWdpb24pO1xuICAgICAgICBuYW1lQ29vcmRNYXAuc2V0KHJlZ2lvbk5hbWUsIHJlZ2lvbi5jZW50ZXIpO1xuICAgICAgfSk7XG4gICAgICB2YXIgcmVjdCA9IHNpbmdsZVNvdXJjZS5ib3VuZGluZ1JlY3Q7XG5cbiAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgIGJvdW5kaW5nUmVjdCA/IGJvdW5kaW5nUmVjdC51bmlvbihyZWN0KSA6IGJvdW5kaW5nUmVjdCA9IHJlY3QuY2xvbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaW9uczogcmVnaW9ucyxcbiAgICAgIHJlZ2lvbnNNYXA6IHJlZ2lvbnNNYXAsXG4gICAgICBuYW1lQ29vcmRNYXA6IG5hbWVDb29yZE1hcCxcbiAgICAgIC8vIEZJWE1FIEFsd2F5cyByZXR1cm4gbmV3ID9cbiAgICAgIGJvdW5kaW5nUmVjdDogYm91bmRpbmdSZWN0IHx8IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMClcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gaG9zdEtleSBGb3IgY2FjaGUuXG4gICAqIEByZXR1cm4gUm9vdHMuXG4gICAqL1xuICBtYWtlR3JhcGhpYzogZnVuY3Rpb24gKG1hcE5hbWUsIGhvc3RLZXkpIHtcbiAgICB2YXIgbWFwUmVjb3JkcyA9IHJldHJpZXZlTWFwKG1hcE5hbWUpO1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgZWFjaChtYXBSZWNvcmRzLCBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICB2YXIgbWV0aG9kID0gbG9hZGVyc1tyZWNvcmQudHlwZV0ubWFrZUdyYXBoaWM7XG4gICAgICBtZXRob2QgJiYgcmVzdWx0cy5wdXNoKG1ldGhvZChtYXBOYW1lLCByZWNvcmQsIGhvc3RLZXkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIGhvc3RLZXkgRm9yIGNhY2hlLlxuICAgKi9cbiAgcmVtb3ZlR3JhcGhpYzogZnVuY3Rpb24gKG1hcE5hbWUsIGhvc3RLZXkpIHtcbiAgICB2YXIgbWFwUmVjb3JkcyA9IHJldHJpZXZlTWFwKG1hcE5hbWUpO1xuICAgIGVhY2gobWFwUmVjb3JkcywgZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgdmFyIG1ldGhvZCA9IGxvYWRlcnNbcmVjb3JkLnR5cGVdLm1ha2VHcmFwaGljO1xuICAgICAgbWV0aG9kICYmIG1ldGhvZChtYXBOYW1lLCByZWNvcmQsIGhvc3RLZXkpO1xuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBtYXBOb3RFeGlzdHNFcnJvcihtYXBOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcignTWFwICcgKyBtYXBOYW1lICsgJyBub3QgZXhpc3RzLiBUaGUgR2VvSlNPTiBvZiB0aGUgbWFwIG11c3QgYmUgcHJvdmlkZWQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cmlldmVNYXAobWFwTmFtZSkge1xuICB2YXIgbWFwUmVjb3JkcyA9IG1hcERhdGFTdG9yYWdlLnJldHJpZXZlTWFwKG1hcE5hbWUpIHx8IFtdO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCFtYXBSZWNvcmRzLmxlbmd0aCkge1xuICAgICAgbWFwTm90RXhpc3RzRXJyb3IobWFwTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hcFJlY29yZHM7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50JztcbmltcG9ydCBtYWtlU3R5bGVNYXBwZXIgZnJvbSAnLi4vLi4vbW9kZWwvbWl4aW4vbWFrZVN0eWxlTWFwcGVyJztcbmltcG9ydCAqIGFzIG51bWJlclV0aWwgZnJvbSAnLi4vLi4vdXRpbC9udW1iZXInO1xuaW1wb3J0IHsgQXhpc01vZGVsQ29tbW9uTWl4aW4gfSBmcm9tICcuLi9heGlzTW9kZWxDb21tb25NaXhpbic7XG5cbnZhciBQYXJhbGxlbEF4aXNNb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQYXJhbGxlbEF4aXNNb2RlbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBQYXJhbGxlbEF4aXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBQYXJhbGxlbEF4aXNNb2RlbC50eXBlO1xuICAgIC8qKlxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuXG4gICAgX3RoaXMuYWN0aXZlSW50ZXJ2YWxzID0gW107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUGFyYWxsZWxBeGlzTW9kZWwucHJvdG90eXBlLmdldEFyZWFTZWxlY3RTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbWFrZVN0eWxlTWFwcGVyKFtbJ2ZpbGwnLCAnY29sb3InXSwgWydsaW5lV2lkdGgnLCAnYm9yZGVyV2lkdGgnXSwgWydzdHJva2UnLCAnYm9yZGVyQ29sb3InXSwgWyd3aWR0aCcsICd3aWR0aCddLCBbJ29wYWNpdHknLCAnb3BhY2l0eSddIC8vIE9wdGlvbiBkZWNhbCBpcyBpbiBgRGVjYWxPYmplY3RgIGJ1dCBzdHlsZS5kZWNhbCBpcyBpbiBgUGF0dGVybk9iamVjdGAuXG4gICAgLy8gU28gZG8gbm90IHRyYW5zZmVyIGRlY2FsIGRpcmVjdGx5LlxuICAgIF0pKHRoaXMuZ2V0TW9kZWwoJ2FyZWFTZWxlY3RTdHlsZScpKTtcbiAgfTtcbiAgLyoqXG4gICAqIFRoZSBjb2RlIG9mIHRoaXMgZmVhdHVyZSBpcyBwdXQgb24gQXhpc01vZGVsIGJ1dCBub3QgUGFyYWxsZWxBeGlzLFxuICAgKiBiZWNhdXNlIGF4aXNNb2RlbCBjYW4gYmUgYWxpdmUgYWZ0ZXIgZWNoYXJ0cyB1cGRhdGluZyBidXQgaW5zdGFuY2Ugb2ZcbiAgICogUGFyYWxsZWxBeGlzIGhhdmluZyBiZWVuIGRpc3Bvc2VkLiB0aGlzLl9hY3RpdmVJbnRlcnZhbCBzaG91bGQgYmUga2VwdFxuICAgKiB3aGVuIGFjdGlvbiBkaXNwYXRjaGVkIChpLmUuIGxlZ2VuZCBjbGljaykuXG4gICAqXG4gICAqIEBwYXJhbSBpbnRlcnZhbHMgYGludGVydmFsLmxlbmd0aCA9PT0gMGAgbWVhbnMgc2V0IGFsbCBhY3RpdmUuXG4gICAqL1xuXG5cbiAgUGFyYWxsZWxBeGlzTW9kZWwucHJvdG90eXBlLnNldEFjdGl2ZUludGVydmFscyA9IGZ1bmN0aW9uIChpbnRlcnZhbHMpIHtcbiAgICB2YXIgYWN0aXZlSW50ZXJ2YWxzID0gdGhpcy5hY3RpdmVJbnRlcnZhbHMgPSB6clV0aWwuY2xvbmUoaW50ZXJ2YWxzKTsgLy8gTm9ybWFsaXplXG5cbiAgICBpZiAoYWN0aXZlSW50ZXJ2YWxzKSB7XG4gICAgICBmb3IgKHZhciBpID0gYWN0aXZlSW50ZXJ2YWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIG51bWJlclV0aWwuYXNjKGFjdGl2ZUludGVydmFsc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHZhbHVlIFdoZW4gb25seSBhdHRlbXB0aW5nIGRldGVjdCB3aGV0aGVyICdubyBhY3RpdmVJbnRlcnZhbHMgc2V0JyxcbiAgICogICAgICAgIGB2YWx1ZWAgaXMgbm90IG5lZWRlZCB0byBiZSBpbnB1dC5cbiAgICovXG5cblxuICBQYXJhbGxlbEF4aXNNb2RlbC5wcm90b3R5cGUuZ2V0QWN0aXZlU3RhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgYWN0aXZlSW50ZXJ2YWxzID0gdGhpcy5hY3RpdmVJbnRlcnZhbHM7XG5cbiAgICBpZiAoIWFjdGl2ZUludGVydmFscy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAnbm9ybWFsJztcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBpc05hTigrdmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2luYWN0aXZlJztcbiAgICB9IC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cblxuXG4gICAgaWYgKGFjdGl2ZUludGVydmFscy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBpbnRlcnZhbCA9IGFjdGl2ZUludGVydmFsc1swXTtcblxuICAgICAgaWYgKGludGVydmFsWzBdIDw9IHZhbHVlICYmIHZhbHVlIDw9IGludGVydmFsWzFdKSB7XG4gICAgICAgIHJldHVybiAnYWN0aXZlJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFjdGl2ZUludGVydmFscy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoYWN0aXZlSW50ZXJ2YWxzW2ldWzBdIDw9IHZhbHVlICYmIHZhbHVlIDw9IGFjdGl2ZUludGVydmFsc1tpXVsxXSkge1xuICAgICAgICAgIHJldHVybiAnYWN0aXZlJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnaW5hY3RpdmUnO1xuICB9O1xuXG4gIHJldHVybiBQYXJhbGxlbEF4aXNNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuXG56clV0aWwubWl4aW4oUGFyYWxsZWxBeGlzTW9kZWwsIEF4aXNNb2RlbENvbW1vbk1peGluKTtcbmV4cG9ydCBkZWZhdWx0IFBhcmFsbGVsQXhpc01vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogUGFyYWxsZWwgQ29vcmRpbmF0ZXNcbiAqIDxodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYXJhbGxlbF9jb29yZGluYXRlcz5cbiAqL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgKiBhcyBtYXRyaXggZnJvbSAnenJlbmRlci9saWIvY29yZS9tYXRyaXgnO1xuaW1wb3J0ICogYXMgbGF5b3V0VXRpbCBmcm9tICcuLi8uLi91dGlsL2xheW91dCc7XG5pbXBvcnQgKiBhcyBheGlzSGVscGVyIGZyb20gJy4uLy4uL2Nvb3JkL2F4aXNIZWxwZXInO1xuaW1wb3J0IFBhcmFsbGVsQXhpcyBmcm9tICcuL1BhcmFsbGVsQXhpcyc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYyc7XG5pbXBvcnQgKiBhcyBudW1iZXJVdGlsIGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyJztcbmltcG9ydCBzbGlkZXJNb3ZlIGZyb20gJy4uLy4uL2NvbXBvbmVudC9oZWxwZXIvc2xpZGVyTW92ZSc7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aEZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBtYXRoQ2VpbCA9IE1hdGguY2VpbDtcbnZhciByb3VuZCA9IG51bWJlclV0aWwucm91bmQ7XG52YXIgUEkgPSBNYXRoLlBJO1xuXG52YXIgUGFyYWxsZWwgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXJhbGxlbChwYXJhbGxlbE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLnR5cGUgPSAncGFyYWxsZWwnO1xuICAgIC8qKlxuICAgICAqIGtleTogZGltZW5zaW9uXG4gICAgICovXG5cbiAgICB0aGlzLl9heGVzTWFwID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgICAvKipcbiAgICAgKiBrZXk6IGRpbWVuc2lvblxuICAgICAqIHZhbHVlOiB7cG9zaXRpb246IFtdLCByb3RhdGlvbiwgfVxuICAgICAqL1xuXG4gICAgdGhpcy5fYXhlc0xheW91dCA9IHt9O1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IHBhcmFsbGVsTW9kZWwuZGltZW5zaW9ucztcbiAgICB0aGlzLl9tb2RlbCA9IHBhcmFsbGVsTW9kZWw7XG5cbiAgICB0aGlzLl9pbml0KHBhcmFsbGVsTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gIH1cblxuICBQYXJhbGxlbC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAocGFyYWxsZWxNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGRpbWVuc2lvbnMgPSBwYXJhbGxlbE1vZGVsLmRpbWVuc2lvbnM7XG4gICAgdmFyIHBhcmFsbGVsQXhpc0luZGV4ID0gcGFyYWxsZWxNb2RlbC5wYXJhbGxlbEF4aXNJbmRleDtcbiAgICBlYWNoKGRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkaW0sIGlkeCkge1xuICAgICAgdmFyIGF4aXNJbmRleCA9IHBhcmFsbGVsQXhpc0luZGV4W2lkeF07XG4gICAgICB2YXIgYXhpc01vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ3BhcmFsbGVsQXhpcycsIGF4aXNJbmRleCk7XG5cbiAgICAgIHZhciBheGlzID0gdGhpcy5fYXhlc01hcC5zZXQoZGltLCBuZXcgUGFyYWxsZWxBeGlzKGRpbSwgYXhpc0hlbHBlci5jcmVhdGVTY2FsZUJ5TW9kZWwoYXhpc01vZGVsKSwgWzAsIDBdLCBheGlzTW9kZWwuZ2V0KCd0eXBlJyksIGF4aXNJbmRleCkpO1xuXG4gICAgICB2YXIgaXNDYXRlZ29yeSA9IGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgICAgIGF4aXMub25CYW5kID0gaXNDYXRlZ29yeSAmJiBheGlzTW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpO1xuICAgICAgYXhpcy5pbnZlcnNlID0gYXhpc01vZGVsLmdldCgnaW52ZXJzZScpOyAvLyBJbmplY3Rpb25cblxuICAgICAgYXhpc01vZGVsLmF4aXMgPSBheGlzO1xuICAgICAgYXhpcy5tb2RlbCA9IGF4aXNNb2RlbDtcbiAgICAgIGF4aXMuY29vcmRpbmF0ZVN5c3RlbSA9IGF4aXNNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gdGhpcztcbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgLyoqXG4gICAqIFVwZGF0ZSBheGlzIHNjYWxlIGFmdGVyIGRhdGEgcHJvY2Vzc2VkXG4gICAqL1xuXG5cbiAgUGFyYWxsZWwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLl91cGRhdGVBeGVzRnJvbVNlcmllcyh0aGlzLl9tb2RlbCwgZWNNb2RlbCk7XG4gIH07XG5cbiAgUGFyYWxsZWwucHJvdG90eXBlLmNvbnRhaW5Qb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciBsYXlvdXRJbmZvID0gdGhpcy5fbWFrZUxheW91dEluZm8oKTtcblxuICAgIHZhciBheGlzQmFzZSA9IGxheW91dEluZm8uYXhpc0Jhc2U7XG4gICAgdmFyIGxheW91dEJhc2UgPSBsYXlvdXRJbmZvLmxheW91dEJhc2U7XG4gICAgdmFyIHBpeGVsRGltSW5kZXggPSBsYXlvdXRJbmZvLnBpeGVsRGltSW5kZXg7XG4gICAgdmFyIHBBeGlzID0gcG9pbnRbMSAtIHBpeGVsRGltSW5kZXhdO1xuICAgIHZhciBwTGF5b3V0ID0gcG9pbnRbcGl4ZWxEaW1JbmRleF07XG4gICAgcmV0dXJuIHBBeGlzID49IGF4aXNCYXNlICYmIHBBeGlzIDw9IGF4aXNCYXNlICsgbGF5b3V0SW5mby5heGlzTGVuZ3RoICYmIHBMYXlvdXQgPj0gbGF5b3V0QmFzZSAmJiBwTGF5b3V0IDw9IGxheW91dEJhc2UgKyBsYXlvdXRJbmZvLmxheW91dExlbmd0aDtcbiAgfTtcblxuICBQYXJhbGxlbC5wcm90b3R5cGUuZ2V0TW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsO1xuICB9O1xuICAvKipcbiAgICogVXBkYXRlIHByb3BlcnRpZXMgZnJvbSBzZXJpZXNcbiAgICovXG5cblxuICBQYXJhbGxlbC5wcm90b3R5cGUuX3VwZGF0ZUF4ZXNGcm9tU2VyaWVzID0gZnVuY3Rpb24gKHBhcmFsbGVsTW9kZWwsIGVjTW9kZWwpIHtcbiAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICBpZiAoIXBhcmFsbGVsTW9kZWwuY29udGFpbnMoc2VyaWVzTW9kZWwsIGVjTW9kZWwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICBlYWNoKHRoaXMuZGltZW5zaW9ucywgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICB2YXIgYXhpcyA9IHRoaXMuX2F4ZXNNYXAuZ2V0KGRpbSk7XG5cbiAgICAgICAgYXhpcy5zY2FsZS51bmlvbkV4dGVudEZyb21EYXRhKGRhdGEsIGRhdGEubWFwRGltZW5zaW9uKGRpbSkpO1xuICAgICAgICBheGlzSGVscGVyLm5pY2VTY2FsZUV4dGVudChheGlzLnNjYWxlLCBheGlzLm1vZGVsKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuICAvKipcbiAgICogUmVzaXplIHRoZSBwYXJhbGxlbCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICovXG5cblxuICBQYXJhbGxlbC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHBhcmFsbGVsTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuX3JlY3QgPSBsYXlvdXRVdGlsLmdldExheW91dFJlY3QocGFyYWxsZWxNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKSwge1xuICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICB9KTtcblxuICAgIHRoaXMuX2xheW91dEF4ZXMoKTtcbiAgfTtcblxuICBQYXJhbGxlbC5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgfTtcblxuICBQYXJhbGxlbC5wcm90b3R5cGUuX21ha2VMYXlvdXRJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJhbGxlbE1vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgdmFyIHJlY3QgPSB0aGlzLl9yZWN0O1xuICAgIHZhciB4eSA9IFsneCcsICd5J107XG4gICAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXTtcbiAgICB2YXIgbGF5b3V0ID0gcGFyYWxsZWxNb2RlbC5nZXQoJ2xheW91dCcpO1xuICAgIHZhciBwaXhlbERpbUluZGV4ID0gbGF5b3V0ID09PSAnaG9yaXpvbnRhbCcgPyAwIDogMTtcbiAgICB2YXIgbGF5b3V0TGVuZ3RoID0gcmVjdFt3aFtwaXhlbERpbUluZGV4XV07XG4gICAgdmFyIGxheW91dEV4dGVudCA9IFswLCBsYXlvdXRMZW5ndGhdO1xuICAgIHZhciBheGlzQ291bnQgPSB0aGlzLmRpbWVuc2lvbnMubGVuZ3RoO1xuICAgIHZhciBheGlzRXhwYW5kV2lkdGggPSByZXN0cmljdChwYXJhbGxlbE1vZGVsLmdldCgnYXhpc0V4cGFuZFdpZHRoJyksIGxheW91dEV4dGVudCk7XG4gICAgdmFyIGF4aXNFeHBhbmRDb3VudCA9IHJlc3RyaWN0KHBhcmFsbGVsTW9kZWwuZ2V0KCdheGlzRXhwYW5kQ291bnQnKSB8fCAwLCBbMCwgYXhpc0NvdW50XSk7XG4gICAgdmFyIGF4aXNFeHBhbmRhYmxlID0gcGFyYWxsZWxNb2RlbC5nZXQoJ2F4aXNFeHBhbmRhYmxlJykgJiYgYXhpc0NvdW50ID4gMyAmJiBheGlzQ291bnQgPiBheGlzRXhwYW5kQ291bnQgJiYgYXhpc0V4cGFuZENvdW50ID4gMSAmJiBheGlzRXhwYW5kV2lkdGggPiAwICYmIGxheW91dExlbmd0aCA+IDA7IC8vIGBheGlzRXhwYW5kV2luZG93YCBpcyBBY2NvcmRpbmcgdG8gdGhlIGNvb3JkaW5hdGVzIG9mIFswLCBheGlzRXhwYW5kTGVuZ3RoXSxcbiAgICAvLyBmb3Igc2FrZSBvZiBjb25zaWRlciB0aGUgY2FzZSB0aGF0IGF4aXNDb2xsYXBzZVdpZHRoIGlzIDAgKHdoZW4gc2NyZWVuIGlzIG5hcnJvdyksXG4gICAgLy8gd2hlcmUgY29sbGFwc2VkIGF4ZXMgc2hvdWxkIGJlIG92ZXJsYXBwZWQuXG5cbiAgICB2YXIgYXhpc0V4cGFuZFdpbmRvdyA9IHBhcmFsbGVsTW9kZWwuZ2V0KCdheGlzRXhwYW5kV2luZG93Jyk7XG4gICAgdmFyIHdpblNpemU7XG5cbiAgICBpZiAoIWF4aXNFeHBhbmRXaW5kb3cpIHtcbiAgICAgIHdpblNpemUgPSByZXN0cmljdChheGlzRXhwYW5kV2lkdGggKiAoYXhpc0V4cGFuZENvdW50IC0gMSksIGxheW91dEV4dGVudCk7XG4gICAgICB2YXIgYXhpc0V4cGFuZENlbnRlciA9IHBhcmFsbGVsTW9kZWwuZ2V0KCdheGlzRXhwYW5kQ2VudGVyJykgfHwgbWF0aEZsb29yKGF4aXNDb3VudCAvIDIpO1xuICAgICAgYXhpc0V4cGFuZFdpbmRvdyA9IFtheGlzRXhwYW5kV2lkdGggKiBheGlzRXhwYW5kQ2VudGVyIC0gd2luU2l6ZSAvIDJdO1xuICAgICAgYXhpc0V4cGFuZFdpbmRvd1sxXSA9IGF4aXNFeHBhbmRXaW5kb3dbMF0gKyB3aW5TaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5TaXplID0gcmVzdHJpY3QoYXhpc0V4cGFuZFdpbmRvd1sxXSAtIGF4aXNFeHBhbmRXaW5kb3dbMF0sIGxheW91dEV4dGVudCk7XG4gICAgICBheGlzRXhwYW5kV2luZG93WzFdID0gYXhpc0V4cGFuZFdpbmRvd1swXSArIHdpblNpemU7XG4gICAgfVxuXG4gICAgdmFyIGF4aXNDb2xsYXBzZVdpZHRoID0gKGxheW91dExlbmd0aCAtIHdpblNpemUpIC8gKGF4aXNDb3VudCAtIGF4aXNFeHBhbmRDb3VudCk7IC8vIEF2b2lkIGF4aXNDb2xsYXBzZVdpZHRoIGlzIHRvbyBzbWFsbC5cblxuICAgIGF4aXNDb2xsYXBzZVdpZHRoIDwgMyAmJiAoYXhpc0NvbGxhcHNlV2lkdGggPSAwKTsgLy8gRmluZCB0aGUgZmlyc3QgYW5kIGxhc3QgaW5kaWNlcyA+IGV3aW5bMF0gYW5kIDwgZXdpblsxXS5cblxuICAgIHZhciB3aW5Jbm5lckluZGljZXMgPSBbbWF0aEZsb29yKHJvdW5kKGF4aXNFeHBhbmRXaW5kb3dbMF0gLyBheGlzRXhwYW5kV2lkdGgsIDEpKSArIDEsIG1hdGhDZWlsKHJvdW5kKGF4aXNFeHBhbmRXaW5kb3dbMV0gLyBheGlzRXhwYW5kV2lkdGgsIDEpKSAtIDFdOyAvLyBQb3MgaW4gZWMgY29vcmRpbmF0ZXMuXG5cbiAgICB2YXIgYXhpc0V4cGFuZFdpbmRvdzBQb3MgPSBheGlzQ29sbGFwc2VXaWR0aCAvIGF4aXNFeHBhbmRXaWR0aCAqIGF4aXNFeHBhbmRXaW5kb3dbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgcGl4ZWxEaW1JbmRleDogcGl4ZWxEaW1JbmRleCxcbiAgICAgIGxheW91dEJhc2U6IHJlY3RbeHlbcGl4ZWxEaW1JbmRleF1dLFxuICAgICAgbGF5b3V0TGVuZ3RoOiBsYXlvdXRMZW5ndGgsXG4gICAgICBheGlzQmFzZTogcmVjdFt4eVsxIC0gcGl4ZWxEaW1JbmRleF1dLFxuICAgICAgYXhpc0xlbmd0aDogcmVjdFt3aFsxIC0gcGl4ZWxEaW1JbmRleF1dLFxuICAgICAgYXhpc0V4cGFuZGFibGU6IGF4aXNFeHBhbmRhYmxlLFxuICAgICAgYXhpc0V4cGFuZFdpZHRoOiBheGlzRXhwYW5kV2lkdGgsXG4gICAgICBheGlzQ29sbGFwc2VXaWR0aDogYXhpc0NvbGxhcHNlV2lkdGgsXG4gICAgICBheGlzRXhwYW5kV2luZG93OiBheGlzRXhwYW5kV2luZG93LFxuICAgICAgYXhpc0NvdW50OiBheGlzQ291bnQsXG4gICAgICB3aW5Jbm5lckluZGljZXM6IHdpbklubmVySW5kaWNlcyxcbiAgICAgIGF4aXNFeHBhbmRXaW5kb3cwUG9zOiBheGlzRXhwYW5kV2luZG93MFBvc1xuICAgIH07XG4gIH07XG5cbiAgUGFyYWxsZWwucHJvdG90eXBlLl9sYXlvdXRBeGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWN0ID0gdGhpcy5fcmVjdDtcbiAgICB2YXIgYXhlcyA9IHRoaXMuX2F4ZXNNYXA7XG4gICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnM7XG5cbiAgICB2YXIgbGF5b3V0SW5mbyA9IHRoaXMuX21ha2VMYXlvdXRJbmZvKCk7XG5cbiAgICB2YXIgbGF5b3V0ID0gbGF5b3V0SW5mby5sYXlvdXQ7XG4gICAgYXhlcy5lYWNoKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICB2YXIgYXhpc0V4dGVudCA9IFswLCBsYXlvdXRJbmZvLmF4aXNMZW5ndGhdO1xuICAgICAgdmFyIGlkeCA9IGF4aXMuaW52ZXJzZSA/IDEgOiAwO1xuICAgICAgYXhpcy5zZXRFeHRlbnQoYXhpc0V4dGVudFtpZHhdLCBheGlzRXh0ZW50WzEgLSBpZHhdKTtcbiAgICB9KTtcbiAgICBlYWNoKGRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkaW0sIGlkeCkge1xuICAgICAgdmFyIHBvc0luZm8gPSAobGF5b3V0SW5mby5heGlzRXhwYW5kYWJsZSA/IGxheW91dEF4aXNXaXRoRXhwYW5kIDogbGF5b3V0QXhpc1dpdGhvdXRFeHBhbmQpKGlkeCwgbGF5b3V0SW5mbyk7XG4gICAgICB2YXIgcG9zaXRpb25UYWJsZSA9IHtcbiAgICAgICAgaG9yaXpvbnRhbDoge1xuICAgICAgICAgIHg6IHBvc0luZm8ucG9zaXRpb24sXG4gICAgICAgICAgeTogbGF5b3V0SW5mby5heGlzTGVuZ3RoXG4gICAgICAgIH0sXG4gICAgICAgIHZlcnRpY2FsOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiBwb3NJbmZvLnBvc2l0aW9uXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgcm90YXRpb25UYWJsZSA9IHtcbiAgICAgICAgaG9yaXpvbnRhbDogUEkgLyAyLFxuICAgICAgICB2ZXJ0aWNhbDogMFxuICAgICAgfTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IFtwb3NpdGlvblRhYmxlW2xheW91dF0ueCArIHJlY3QueCwgcG9zaXRpb25UYWJsZVtsYXlvdXRdLnkgKyByZWN0LnldO1xuICAgICAgdmFyIHJvdGF0aW9uID0gcm90YXRpb25UYWJsZVtsYXlvdXRdO1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IG1hdHJpeC5jcmVhdGUoKTtcbiAgICAgIG1hdHJpeC5yb3RhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIHJvdGF0aW9uKTtcbiAgICAgIG1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIHBvc2l0aW9uKTsgLy8gVE9ET1xuICAgICAgLy8gdGljayBsYXlvdXQgaW5mb1xuICAgICAgLy8gVE9ET1xuICAgICAgLy8gdXBkYXRlIGRpbWVuc2lvbnMgaW5mbyBiYXNlZCBvbiBheGlzIG9yZGVyLlxuXG4gICAgICB0aGlzLl9heGVzTGF5b3V0W2RpbV0gPSB7XG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgYXhpc05hbWVBdmFpbGFibGVXaWR0aDogcG9zSW5mby5heGlzTmFtZUF2YWlsYWJsZVdpZHRoLFxuICAgICAgICBheGlzTGFiZWxTaG93OiBwb3NJbmZvLmF4aXNMYWJlbFNob3csXG4gICAgICAgIG5hbWVUcnVuY2F0ZU1heFdpZHRoOiBwb3NJbmZvLm5hbWVUcnVuY2F0ZU1heFdpZHRoLFxuICAgICAgICB0aWNrRGlyZWN0aW9uOiAxLFxuICAgICAgICBsYWJlbERpcmVjdGlvbjogMVxuICAgICAgfTtcbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldCBheGlzIGJ5IGRpbS5cbiAgICovXG5cblxuICBQYXJhbGxlbC5wcm90b3R5cGUuZ2V0QXhpcyA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgICByZXR1cm4gdGhpcy5fYXhlc01hcC5nZXQoZGltKTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnQgYSBkaW0gdmFsdWUgb2YgYSBzaW5nbGUgaXRlbSBvZiBzZXJpZXMgZGF0YSB0byBQb2ludC5cbiAgICovXG5cblxuICBQYXJhbGxlbC5wcm90b3R5cGUuZGF0YVRvUG9pbnQgPSBmdW5jdGlvbiAodmFsdWUsIGRpbSkge1xuICAgIHJldHVybiB0aGlzLmF4aXNDb29yZFRvUG9pbnQodGhpcy5fYXhlc01hcC5nZXQoZGltKS5kYXRhVG9Db29yZCh2YWx1ZSksIGRpbSk7XG4gIH07XG4gIC8qKlxuICAgKiBUcmF2ZWwgZGF0YSBmb3Igb25lIHRpbWUsIGdldCBhY3RpdmVTdGF0ZSBvZiBlYWNoIGRhdGEgaXRlbS5cbiAgICogQHBhcmFtIHN0YXJ0IHRoZSBzdGFydCBkYXRhSW5kZXggdGhhdCB0cmF2ZWwgZnJvbS5cbiAgICogQHBhcmFtIGVuZCB0aGUgbmV4dCBkYXRhSW5kZXggb2YgdGhlIGxhc3QgZGF0YUluZGV4IHdpbGwgYmUgdHJhdmVsLlxuICAgKi9cblxuXG4gIFBhcmFsbGVsLnByb3RvdHlwZS5lYWNoQWN0aXZlU3RhdGUgPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2ssIHN0YXJ0LCBlbmQpIHtcbiAgICBzdGFydCA9PSBudWxsICYmIChzdGFydCA9IDApO1xuICAgIGVuZCA9PSBudWxsICYmIChlbmQgPSBkYXRhLmNvdW50KCkpO1xuICAgIHZhciBheGVzTWFwID0gdGhpcy5fYXhlc01hcDtcbiAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICB2YXIgZGF0YURpbWVuc2lvbnMgPSBbXTtcbiAgICB2YXIgYXhpc01vZGVscyA9IFtdO1xuICAgIHpyVXRpbC5lYWNoKGRpbWVuc2lvbnMsIGZ1bmN0aW9uIChheGlzRGltKSB7XG4gICAgICBkYXRhRGltZW5zaW9ucy5wdXNoKGRhdGEubWFwRGltZW5zaW9uKGF4aXNEaW0pKTtcbiAgICAgIGF4aXNNb2RlbHMucHVzaChheGVzTWFwLmdldChheGlzRGltKS5tb2RlbCk7XG4gICAgfSk7XG4gICAgdmFyIGhhc0FjdGl2ZVNldCA9IHRoaXMuaGFzQXhpc0JydXNoZWQoKTtcblxuICAgIGZvciAodmFyIGRhdGFJbmRleCA9IHN0YXJ0OyBkYXRhSW5kZXggPCBlbmQ7IGRhdGFJbmRleCsrKSB7XG4gICAgICB2YXIgYWN0aXZlU3RhdGUgPSB2b2lkIDA7XG5cbiAgICAgIGlmICghaGFzQWN0aXZlU2V0KSB7XG4gICAgICAgIGFjdGl2ZVN0YXRlID0gJ25vcm1hbCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVTdGF0ZSA9ICdhY3RpdmUnO1xuICAgICAgICB2YXIgdmFsdWVzID0gZGF0YS5nZXRWYWx1ZXMoZGF0YURpbWVuc2lvbnMsIGRhdGFJbmRleCk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbmogPSBkaW1lbnNpb25zLmxlbmd0aDsgaiA8IGxlbmo7IGorKykge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IGF4aXNNb2RlbHNbal0uZ2V0QWN0aXZlU3RhdGUodmFsdWVzW2pdKTtcblxuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2luYWN0aXZlJykge1xuICAgICAgICAgICAgYWN0aXZlU3RhdGUgPSAnaW5hY3RpdmUnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKGFjdGl2ZVN0YXRlLCBkYXRhSW5kZXgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgaGFzIGFueSBhY3RpdmVTZXQuXG4gICAqL1xuXG5cbiAgUGFyYWxsZWwucHJvdG90eXBlLmhhc0F4aXNCcnVzaGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zO1xuICAgIHZhciBheGVzTWFwID0gdGhpcy5fYXhlc01hcDtcbiAgICB2YXIgaGFzQWN0aXZlU2V0ID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBqID0gMCwgbGVuaiA9IGRpbWVuc2lvbnMubGVuZ3RoOyBqIDwgbGVuajsgaisrKSB7XG4gICAgICBpZiAoYXhlc01hcC5nZXQoZGltZW5zaW9uc1tqXSkubW9kZWwuZ2V0QWN0aXZlU3RhdGUoKSAhPT0gJ25vcm1hbCcpIHtcbiAgICAgICAgaGFzQWN0aXZlU2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGFzQWN0aXZlU2V0O1xuICB9O1xuICAvKipcbiAgICogQ29udmVydCBjb29yZHMgb2YgZWFjaCBheGlzIHRvIFBvaW50LlxuICAgKiAgUmV0dXJuIHBvaW50LiBGb3IgZXhhbXBsZTogWzEwLCAyMF1cbiAgICovXG5cblxuICBQYXJhbGxlbC5wcm90b3R5cGUuYXhpc0Nvb3JkVG9Qb2ludCA9IGZ1bmN0aW9uIChjb29yZCwgZGltKSB7XG4gICAgdmFyIGF4aXNMYXlvdXQgPSB0aGlzLl9heGVzTGF5b3V0W2RpbV07XG4gICAgcmV0dXJuIGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0oW2Nvb3JkLCAwXSwgYXhpc0xheW91dC50cmFuc2Zvcm0pO1xuICB9O1xuICAvKipcbiAgICogR2V0IGF4aXMgbGF5b3V0LlxuICAgKi9cblxuXG4gIFBhcmFsbGVsLnByb3RvdHlwZS5nZXRBeGlzTGF5b3V0ID0gZnVuY3Rpb24gKGRpbSkge1xuICAgIHJldHVybiB6clV0aWwuY2xvbmUodGhpcy5fYXhlc0xheW91dFtkaW1dKTtcbiAgfTtcbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdH0ge2F4aXNFeHBhbmRXaW5kb3csIGRlbHRhLCBiZWhhdmlvcjogJ2p1bXAnIHwgJ3NsaWRlJyB8ICdub25lJ30uXG4gICAqL1xuXG5cbiAgUGFyYWxsZWwucHJvdG90eXBlLmdldFNsaWRlZEF4aXNFeHBhbmRXaW5kb3cgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgbGF5b3V0SW5mbyA9IHRoaXMuX21ha2VMYXlvdXRJbmZvKCk7XG5cbiAgICB2YXIgcGl4ZWxEaW1JbmRleCA9IGxheW91dEluZm8ucGl4ZWxEaW1JbmRleDtcbiAgICB2YXIgYXhpc0V4cGFuZFdpbmRvdyA9IGxheW91dEluZm8uYXhpc0V4cGFuZFdpbmRvdy5zbGljZSgpO1xuICAgIHZhciB3aW5TaXplID0gYXhpc0V4cGFuZFdpbmRvd1sxXSAtIGF4aXNFeHBhbmRXaW5kb3dbMF07XG4gICAgdmFyIGV4dGVudCA9IFswLCBsYXlvdXRJbmZvLmF4aXNFeHBhbmRXaWR0aCAqIChsYXlvdXRJbmZvLmF4aXNDb3VudCAtIDEpXTsgLy8gT3V0IG9mIHRoZSBhcmVhIG9mIGNvb3JkaW5hdGUgc3lzdGVtLlxuXG4gICAgaWYgKCF0aGlzLmNvbnRhaW5Qb2ludChwb2ludCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJlaGF2aW9yOiAnbm9uZScsXG4gICAgICAgIGF4aXNFeHBhbmRXaW5kb3c6IGF4aXNFeHBhbmRXaW5kb3dcbiAgICAgIH07XG4gICAgfSAvLyBDb252ZXIgdGhlIHBvaW50IGZyb20gZ2xvYmFsIHRvIGV4cGFuZCBjb29yZGluYXRlcy5cblxuXG4gICAgdmFyIHBvaW50Q29vcmQgPSBwb2ludFtwaXhlbERpbUluZGV4XSAtIGxheW91dEluZm8ubGF5b3V0QmFzZSAtIGxheW91dEluZm8uYXhpc0V4cGFuZFdpbmRvdzBQb3M7IC8vIEZvciBkcmFnZ2luZyBvcGVyYXRpb24gY29udmVuaWVuY2UsIHRoZSB3aW5kb3cgc2hvdWxkIG5vdCBiZVxuICAgIC8vIHNsaWRlZCB3aGVuIG1vdXNlIGlzIHRoZSBjZW50ZXIgYXJlYSBvZiB0aGUgd2luZG93LlxuXG4gICAgdmFyIGRlbHRhO1xuICAgIHZhciBiZWhhdmlvciA9ICdzbGlkZSc7XG4gICAgdmFyIGF4aXNDb2xsYXBzZVdpZHRoID0gbGF5b3V0SW5mby5heGlzQ29sbGFwc2VXaWR0aDtcblxuICAgIHZhciB0cmlnZ2VyQXJlYSA9IHRoaXMuX21vZGVsLmdldCgnYXhpc0V4cGFuZFNsaWRlVHJpZ2dlckFyZWEnKTsgLy8gQnV0IGNvbnNpZGVyIHRvdWNoIGRldmljZSwganVtcCBpcyBuZWNlc3NhcnkuXG5cblxuICAgIHZhciB1c2VKdW1wID0gdHJpZ2dlckFyZWFbMF0gIT0gbnVsbDtcblxuICAgIGlmIChheGlzQ29sbGFwc2VXaWR0aCkge1xuICAgICAgaWYgKHVzZUp1bXAgJiYgYXhpc0NvbGxhcHNlV2lkdGggJiYgcG9pbnRDb29yZCA8IHdpblNpemUgKiB0cmlnZ2VyQXJlYVswXSkge1xuICAgICAgICBiZWhhdmlvciA9ICdqdW1wJztcbiAgICAgICAgZGVsdGEgPSBwb2ludENvb3JkIC0gd2luU2l6ZSAqIHRyaWdnZXJBcmVhWzJdO1xuICAgICAgfSBlbHNlIGlmICh1c2VKdW1wICYmIGF4aXNDb2xsYXBzZVdpZHRoICYmIHBvaW50Q29vcmQgPiB3aW5TaXplICogKDEgLSB0cmlnZ2VyQXJlYVswXSkpIHtcbiAgICAgICAgYmVoYXZpb3IgPSAnanVtcCc7XG4gICAgICAgIGRlbHRhID0gcG9pbnRDb29yZCAtIHdpblNpemUgKiAoMSAtIHRyaWdnZXJBcmVhWzJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChkZWx0YSA9IHBvaW50Q29vcmQgLSB3aW5TaXplICogdHJpZ2dlckFyZWFbMV0pID49IDAgJiYgKGRlbHRhID0gcG9pbnRDb29yZCAtIHdpblNpemUgKiAoMSAtIHRyaWdnZXJBcmVhWzFdKSkgPD0gMCAmJiAoZGVsdGEgPSAwKTtcbiAgICAgIH1cblxuICAgICAgZGVsdGEgKj0gbGF5b3V0SW5mby5heGlzRXhwYW5kV2lkdGggLyBheGlzQ29sbGFwc2VXaWR0aDtcbiAgICAgIGRlbHRhID8gc2xpZGVyTW92ZShkZWx0YSwgYXhpc0V4cGFuZFdpbmRvdywgZXh0ZW50LCAnYWxsJykgLy8gQXZvaWQgbm9uc2Vuc2UgdHJpZ2VyIG9uIG1vdXNlbW92ZS5cbiAgICAgIDogYmVoYXZpb3IgPSAnbm9uZSc7XG4gICAgfSAvLyBXaGVuIHNjcmVlbiBpcyB0b28gbmFycm93LCBtYWtlIGl0IHZpc2libGUgYW5kIHNsaWRhYmxlLCBhbHRob3VnaCBpdCBpcyBoYXJkIHRvIGludGVyYWN0LlxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgd2luU2l6ZTIgPSBheGlzRXhwYW5kV2luZG93WzFdIC0gYXhpc0V4cGFuZFdpbmRvd1swXTtcbiAgICAgICAgdmFyIHBvcyA9IGV4dGVudFsxXSAqIHBvaW50Q29vcmQgLyB3aW5TaXplMjtcbiAgICAgICAgYXhpc0V4cGFuZFdpbmRvdyA9IFttYXRoTWF4KDAsIHBvcyAtIHdpblNpemUyIC8gMildO1xuICAgICAgICBheGlzRXhwYW5kV2luZG93WzFdID0gbWF0aE1pbihleHRlbnRbMV0sIGF4aXNFeHBhbmRXaW5kb3dbMF0gKyB3aW5TaXplMik7XG4gICAgICAgIGF4aXNFeHBhbmRXaW5kb3dbMF0gPSBheGlzRXhwYW5kV2luZG93WzFdIC0gd2luU2l6ZTI7XG4gICAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYXhpc0V4cGFuZFdpbmRvdzogYXhpc0V4cGFuZFdpbmRvdyxcbiAgICAgIGJlaGF2aW9yOiBiZWhhdmlvclxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIFBhcmFsbGVsO1xufSgpO1xuXG5mdW5jdGlvbiByZXN0cmljdChsZW4sIGV4dGVudCkge1xuICByZXR1cm4gbWF0aE1pbihtYXRoTWF4KGxlbiwgZXh0ZW50WzBdKSwgZXh0ZW50WzFdKTtcbn1cblxuZnVuY3Rpb24gbGF5b3V0QXhpc1dpdGhvdXRFeHBhbmQoYXhpc0luZGV4LCBsYXlvdXRJbmZvKSB7XG4gIHZhciBzdGVwID0gbGF5b3V0SW5mby5sYXlvdXRMZW5ndGggLyAobGF5b3V0SW5mby5heGlzQ291bnQgLSAxKTtcbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogc3RlcCAqIGF4aXNJbmRleCxcbiAgICBheGlzTmFtZUF2YWlsYWJsZVdpZHRoOiBzdGVwLFxuICAgIGF4aXNMYWJlbFNob3c6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gbGF5b3V0QXhpc1dpdGhFeHBhbmQoYXhpc0luZGV4LCBsYXlvdXRJbmZvKSB7XG4gIHZhciBsYXlvdXRMZW5ndGggPSBsYXlvdXRJbmZvLmxheW91dExlbmd0aDtcbiAgdmFyIGF4aXNFeHBhbmRXaWR0aCA9IGxheW91dEluZm8uYXhpc0V4cGFuZFdpZHRoO1xuICB2YXIgYXhpc0NvdW50ID0gbGF5b3V0SW5mby5heGlzQ291bnQ7XG4gIHZhciBheGlzQ29sbGFwc2VXaWR0aCA9IGxheW91dEluZm8uYXhpc0NvbGxhcHNlV2lkdGg7XG4gIHZhciB3aW5Jbm5lckluZGljZXMgPSBsYXlvdXRJbmZvLndpbklubmVySW5kaWNlcztcbiAgdmFyIHBvc2l0aW9uO1xuICB2YXIgYXhpc05hbWVBdmFpbGFibGVXaWR0aCA9IGF4aXNDb2xsYXBzZVdpZHRoO1xuICB2YXIgYXhpc0xhYmVsU2hvdyA9IGZhbHNlO1xuICB2YXIgbmFtZVRydW5jYXRlTWF4V2lkdGg7XG5cbiAgaWYgKGF4aXNJbmRleCA8IHdpbklubmVySW5kaWNlc1swXSkge1xuICAgIHBvc2l0aW9uID0gYXhpc0luZGV4ICogYXhpc0NvbGxhcHNlV2lkdGg7XG4gICAgbmFtZVRydW5jYXRlTWF4V2lkdGggPSBheGlzQ29sbGFwc2VXaWR0aDtcbiAgfSBlbHNlIGlmIChheGlzSW5kZXggPD0gd2luSW5uZXJJbmRpY2VzWzFdKSB7XG4gICAgcG9zaXRpb24gPSBsYXlvdXRJbmZvLmF4aXNFeHBhbmRXaW5kb3cwUG9zICsgYXhpc0luZGV4ICogYXhpc0V4cGFuZFdpZHRoIC0gbGF5b3V0SW5mby5heGlzRXhwYW5kV2luZG93WzBdO1xuICAgIGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggPSBheGlzRXhwYW5kV2lkdGg7XG4gICAgYXhpc0xhYmVsU2hvdyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcG9zaXRpb24gPSBsYXlvdXRMZW5ndGggLSAoYXhpc0NvdW50IC0gMSAtIGF4aXNJbmRleCkgKiBheGlzQ29sbGFwc2VXaWR0aDtcbiAgICBuYW1lVHJ1bmNhdGVNYXhXaWR0aCA9IGF4aXNDb2xsYXBzZVdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgYXhpc05hbWVBdmFpbGFibGVXaWR0aDogYXhpc05hbWVBdmFpbGFibGVXaWR0aCxcbiAgICBheGlzTGFiZWxTaG93OiBheGlzTGFiZWxTaG93LFxuICAgIG5hbWVUcnVuY2F0ZU1heFdpZHRoOiBuYW1lVHJ1bmNhdGVNYXhXaWR0aFxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBQYXJhbGxlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQXhpcyBmcm9tICcuLi9BeGlzJztcblxudmFyIFBhcmFsbGVsQXhpcyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQYXJhbGxlbEF4aXMsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gUGFyYWxsZWxBeGlzKGRpbSwgc2NhbGUsIGNvb3JkRXh0ZW50LCBheGlzVHlwZSwgYXhpc0luZGV4KSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGltLCBzY2FsZSwgY29vcmRFeHRlbnQpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gYXhpc1R5cGUgfHwgJ3ZhbHVlJztcbiAgICBfdGhpcy5heGlzSW5kZXggPSBheGlzSW5kZXg7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUGFyYWxsZWxBeGlzLnByb3RvdHlwZS5pc0hvcml6b250YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZVN5c3RlbS5nZXRNb2RlbCgpLmdldCgnbGF5b3V0JykgIT09ICdob3Jpem9udGFsJztcbiAgfTtcblxuICByZXR1cm4gUGFyYWxsZWxBeGlzO1xufShBeGlzKTtcblxuZXhwb3J0IGRlZmF1bHQgUGFyYWxsZWxBeGlzOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xuaW1wb3J0IENvbXBvbmVudE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL0NvbXBvbmVudCc7XG5cbnZhciBQYXJhbGxlbE1vZGVsID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBhcmFsbGVsTW9kZWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gUGFyYWxsZWxNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLnR5cGUgPSBQYXJhbGxlbE1vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUGFyYWxsZWxNb2RlbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMubWVyZ2VPcHRpb24oe30pO1xuICB9O1xuXG4gIFBhcmFsbGVsTW9kZWwucHJvdG90eXBlLm1lcmdlT3B0aW9uID0gZnVuY3Rpb24gKG5ld09wdGlvbikge1xuICAgIHZhciB0aGlzT3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgbmV3T3B0aW9uICYmIHpyVXRpbC5tZXJnZSh0aGlzT3B0aW9uLCBuZXdPcHRpb24sIHRydWUpO1xuXG4gICAgdGhpcy5faW5pdERpbWVuc2lvbnMoKTtcbiAgfTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgc2VyaWVzIG9yIGF4aXMgaXMgaW4gdGhpcyBjb29yZGluYXRlIHN5c3RlbS5cbiAgICovXG5cblxuICBQYXJhbGxlbE1vZGVsLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChtb2RlbCwgZWNNb2RlbCkge1xuICAgIHZhciBwYXJhbGxlbEluZGV4ID0gbW9kZWwuZ2V0KCdwYXJhbGxlbEluZGV4Jyk7XG4gICAgcmV0dXJuIHBhcmFsbGVsSW5kZXggIT0gbnVsbCAmJiBlY01vZGVsLmdldENvbXBvbmVudCgncGFyYWxsZWwnLCBwYXJhbGxlbEluZGV4KSA9PT0gdGhpcztcbiAgfTtcblxuICBQYXJhbGxlbE1vZGVsLnByb3RvdHlwZS5zZXRBeGlzRXhwYW5kID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIHpyVXRpbC5lYWNoKFsnYXhpc0V4cGFuZGFibGUnLCAnYXhpc0V4cGFuZENlbnRlcicsICdheGlzRXhwYW5kQ291bnQnLCAnYXhpc0V4cGFuZFdpZHRoJywgJ2F4aXNFeHBhbmRXaW5kb3cnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChvcHQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRTogd2h5IFwibmV2ZXJcIiBpbmZlcnJlZCBpbiB0aGlzLm9wdGlvbltuYW1lXT9cbiAgICAgICAgdGhpcy5vcHRpb25bbmFtZV0gPSBvcHRbbmFtZV07XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbiAgUGFyYWxsZWxNb2RlbC5wcm90b3R5cGUuX2luaXREaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zID0gW107XG4gICAgdmFyIHBhcmFsbGVsQXhpc0luZGV4ID0gdGhpcy5wYXJhbGxlbEF4aXNJbmRleCA9IFtdO1xuICAgIHZhciBheGlzTW9kZWxzID0genJVdGlsLmZpbHRlcih0aGlzLmVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgIG1haW5UeXBlOiAncGFyYWxsZWxBeGlzJ1xuICAgIH0pLCBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgICAvLyBDYW4gbm90IHVzZSB0aGlzLmNvbnRhaW5zIGhlcmUsIGJlY2F1c2VcbiAgICAgIC8vIGluaXRpYWxpemF0aW9uIGhhcyBub3QgYmVlbiBjb21wbGV0ZWQgeWV0LlxuICAgICAgcmV0dXJuIChheGlzTW9kZWwuZ2V0KCdwYXJhbGxlbEluZGV4JykgfHwgMCkgPT09IHRoaXMuY29tcG9uZW50SW5kZXg7XG4gICAgfSwgdGhpcyk7XG4gICAgenJVdGlsLmVhY2goYXhpc01vZGVscywgZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgICAgZGltZW5zaW9ucy5wdXNoKCdkaW0nICsgYXhpc01vZGVsLmdldCgnZGltJykpO1xuICAgICAgcGFyYWxsZWxBeGlzSW5kZXgucHVzaChheGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgIH0pO1xuICB9O1xuXG4gIFBhcmFsbGVsTW9kZWwudHlwZSA9ICdwYXJhbGxlbCc7XG4gIFBhcmFsbGVsTW9kZWwuZGVwZW5kZW5jaWVzID0gWydwYXJhbGxlbEF4aXMnXTtcbiAgUGFyYWxsZWxNb2RlbC5sYXlvdXRNb2RlID0gJ2JveCc7XG4gIFBhcmFsbGVsTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogMCxcbiAgICBsZWZ0OiA4MCxcbiAgICB0b3A6IDYwLFxuICAgIHJpZ2h0OiA4MCxcbiAgICBib3R0b206IDYwLFxuICAgIC8vIHdpZHRoOiB7dG90YWxXaWR0aH0gLSBsZWZ0IC0gcmlnaHQsXG4gICAgLy8gaGVpZ2h0OiB7dG90YWxIZWlnaHR9IC0gdG9wIC0gYm90dG9tLFxuICAgIGxheW91dDogJ2hvcml6b250YWwnLFxuICAgIC8vIEZJWE1FXG4gICAgLy8gbmFtaW5nP1xuICAgIGF4aXNFeHBhbmRhYmxlOiBmYWxzZSxcbiAgICBheGlzRXhwYW5kQ2VudGVyOiBudWxsLFxuICAgIGF4aXNFeHBhbmRDb3VudDogMCxcbiAgICBheGlzRXhwYW5kV2lkdGg6IDUwLFxuICAgIGF4aXNFeHBhbmRSYXRlOiAxNyxcbiAgICBheGlzRXhwYW5kRGVib3VuY2U6IDUwLFxuICAgIC8vIFtvdXQsIGluLCBqdW1wVGFyZ2V0XS4gSW4gcGVyY2VudGFnZS4gSWYgdXNlIFtudWxsLCAwLjA1XSwgbnVsbCBtZWFucyBmdWxsLlxuICAgIC8vIERvIG5vdCBkb2MgdG8gdXNlciB1bnRpbCBuZWNlc3NhcnkuXG4gICAgYXhpc0V4cGFuZFNsaWRlVHJpZ2dlckFyZWE6IFstMC4xNSwgMC4wNSwgMC40XSxcbiAgICBheGlzRXhwYW5kVHJpZ2dlck9uOiAnY2xpY2snLFxuICAgIHBhcmFsbGVsQXhpc0RlZmF1bHQ6IG51bGxcbiAgfTtcbiAgcmV0dXJuIFBhcmFsbGVsTW9kZWw7XG59KENvbXBvbmVudE1vZGVsKTtcblxuZXhwb3J0IGRlZmF1bHQgUGFyYWxsZWxNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vKipcbiAqIFBhcmFsbGVsIGNvb3JkaW5hdGUgc3lzdGVtIGNyZWF0ZXIuXG4gKi9cbmltcG9ydCBQYXJhbGxlbCBmcm9tICcuL1BhcmFsbGVsJztcbmltcG9ydCB7IFNJTkdMRV9SRUZFUlJJTkcgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsJztcblxuZnVuY3Rpb24gY3JlYXRlUGFyYWxsZWxDb29yZFN5cyhlY01vZGVsLCBhcGkpIHtcbiAgdmFyIGNvb3JkU3lzTGlzdCA9IFtdO1xuICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ3BhcmFsbGVsJywgZnVuY3Rpb24gKHBhcmFsbGVsTW9kZWwsIGlkeCkge1xuICAgIHZhciBjb29yZFN5cyA9IG5ldyBQYXJhbGxlbChwYXJhbGxlbE1vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgIGNvb3JkU3lzLm5hbWUgPSAncGFyYWxsZWxfJyArIGlkeDtcbiAgICBjb29yZFN5cy5yZXNpemUocGFyYWxsZWxNb2RlbCwgYXBpKTtcbiAgICBwYXJhbGxlbE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSBjb29yZFN5cztcbiAgICBjb29yZFN5cy5tb2RlbCA9IHBhcmFsbGVsTW9kZWw7XG4gICAgY29vcmRTeXNMaXN0LnB1c2goY29vcmRTeXMpO1xuICB9KTsgLy8gSW5qZWN0IHRoZSBjb29yZGluYXRlU3lzdGVtcyBpbnRvIHNlcmllc01vZGVsXG5cbiAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIGlmIChzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgdmFyIHBhcmFsbGVsTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRSZWZlcnJpbmdDb21wb25lbnRzKCdwYXJhbGxlbCcsIFNJTkdMRV9SRUZFUlJJTkcpLm1vZGVsc1swXTtcbiAgICAgIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSBwYXJhbGxlbE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNvb3JkU3lzTGlzdDtcbn1cblxudmFyIHBhcmFsbGVsQ29vcmRTeXNDcmVhdG9yID0ge1xuICBjcmVhdGU6IGNyZWF0ZVBhcmFsbGVsQ29vcmRTeXNcbn07XG5leHBvcnQgZGVmYXVsdCBwYXJhbGxlbENvb3JkU3lzQ3JlYXRvcjsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5pbXBvcnQgKiBhcyBtb2RlbFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9tb2RlbCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJhbGxlbFByZXByb2Nlc3NvcihvcHRpb24pIHtcbiAgY3JlYXRlUGFyYWxsZWxJZk5lZWRlZChvcHRpb24pO1xuICBtZXJnZUF4aXNPcHRpb25Gcm9tUGFyYWxsZWwob3B0aW9uKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcGFyYWxsZWwgY29vcmRpbmF0ZSBpZiBub3QgZXhpc3RzLlxuICogQGlubmVyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlUGFyYWxsZWxJZk5lZWRlZChvcHRpb24pIHtcbiAgaWYgKG9wdGlvbi5wYXJhbGxlbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBoYXNQYXJhbGxlbFNlcmllcyA9IGZhbHNlO1xuICB6clV0aWwuZWFjaChvcHRpb24uc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzT3B0KSB7XG4gICAgaWYgKHNlcmllc09wdCAmJiBzZXJpZXNPcHQudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgaGFzUGFyYWxsZWxTZXJpZXMgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGhhc1BhcmFsbGVsU2VyaWVzKSB7XG4gICAgb3B0aW9uLnBhcmFsbGVsID0gW3t9XTtcbiAgfVxufVxuLyoqXG4gKiBNZXJnZSBhaXhzIGRlZmluaXRpb24gZnJvbSBwYXJhbGxlbCBvcHRpb24gKGlmIGV4aXN0cykgdG8gYXhpcyBvcHRpb24uXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlQXhpc09wdGlvbkZyb21QYXJhbGxlbChvcHRpb24pIHtcbiAgdmFyIGF4ZXMgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShvcHRpb24ucGFyYWxsZWxBeGlzKTtcbiAgenJVdGlsLmVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXNPcHRpb24pIHtcbiAgICBpZiAoIXpyVXRpbC5pc09iamVjdChheGlzT3B0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXJhbGxlbEluZGV4ID0gYXhpc09wdGlvbi5wYXJhbGxlbEluZGV4IHx8IDA7XG4gICAgdmFyIHBhcmFsbGVsT3B0aW9uID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkob3B0aW9uLnBhcmFsbGVsKVtwYXJhbGxlbEluZGV4XTtcblxuICAgIGlmIChwYXJhbGxlbE9wdGlvbiAmJiBwYXJhbGxlbE9wdGlvbi5wYXJhbGxlbEF4aXNEZWZhdWx0KSB7XG4gICAgICB6clV0aWwubWVyZ2UoYXhpc09wdGlvbiwgcGFyYWxsZWxPcHRpb24ucGFyYWxsZWxBeGlzRGVmYXVsdCwgZmFsc2UpO1xuICAgIH1cbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IEF4aXMgZnJvbSAnLi4vQXhpcyc7XG5cbnZhciBJbmRpY2F0b3JBeGlzID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEluZGljYXRvckF4aXMsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gSW5kaWNhdG9yQXhpcyhkaW0sIHNjYWxlLCByYWRpdXNFeHRlbnQpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkaW0sIHNjYWxlLCByYWRpdXNFeHRlbnQpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gJ3ZhbHVlJztcbiAgICBfdGhpcy5hbmdsZSA9IDA7XG4gICAgX3RoaXMubmFtZSA9ICcnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBJbmRpY2F0b3JBeGlzO1xufShBeGlzKTtcblxuZXhwb3J0IGRlZmF1bHQgSW5kaWNhdG9yQXhpczsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLy8gVE9ETyBjbG9ja3dpc2VcbmltcG9ydCBJbmRpY2F0b3JBeGlzIGZyb20gJy4vSW5kaWNhdG9yQXhpcyc7XG5pbXBvcnQgSW50ZXJ2YWxTY2FsZSBmcm9tICcuLi8uLi9zY2FsZS9JbnRlcnZhbCc7XG5pbXBvcnQgKiBhcyBudW1iZXJVdGlsIGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyJztcbmltcG9ydCB7IGdldFNjYWxlRXh0ZW50LCBuaWNlU2NhbGVFeHRlbnQgfSBmcm9tICcuLi9heGlzSGVscGVyJztcbmltcG9ydCB7IHBhcnNlQXhpc01vZGVsTWluTWF4IH0gZnJvbSAnLi4vc2NhbGVSYXdFeHRlbnRJbmZvJztcbmltcG9ydCB7IG1hcCwgZWFjaCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCc7XG5cbnZhciBSYWRhciA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJhZGFyKHJhZGFyTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogUmFkYXIgZGltZW5zaW9uc1xuICAgICAqL1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IFtdO1xuICAgIHRoaXMuX21vZGVsID0gcmFkYXJNb2RlbDtcbiAgICB0aGlzLl9pbmRpY2F0b3JBeGVzID0gbWFwKHJhZGFyTW9kZWwuZ2V0SW5kaWNhdG9yTW9kZWxzKCksIGZ1bmN0aW9uIChpbmRpY2F0b3JNb2RlbCwgaWR4KSB7XG4gICAgICB2YXIgZGltID0gJ2luZGljYXRvcl8nICsgaWR4O1xuICAgICAgdmFyIGluZGljYXRvckF4aXMgPSBuZXcgSW5kaWNhdG9yQXhpcyhkaW0sIG5ldyBJbnRlcnZhbFNjYWxlKCkgLy8gKGluZGljYXRvck1vZGVsLmdldCgnYXhpc1R5cGUnKSA9PT0gJ2xvZycpID8gbmV3IExvZ1NjYWxlKCkgOiBuZXcgSW50ZXJ2YWxTY2FsZSgpXG4gICAgICApO1xuICAgICAgaW5kaWNhdG9yQXhpcy5uYW1lID0gaW5kaWNhdG9yTW9kZWwuZ2V0KCduYW1lJyk7IC8vIEluamVjdCBtb2RlbCBhbmQgYXhpc1xuXG4gICAgICBpbmRpY2F0b3JBeGlzLm1vZGVsID0gaW5kaWNhdG9yTW9kZWw7XG4gICAgICBpbmRpY2F0b3JNb2RlbC5heGlzID0gaW5kaWNhdG9yQXhpcztcbiAgICAgIHRoaXMuZGltZW5zaW9ucy5wdXNoKGRpbSk7XG4gICAgICByZXR1cm4gaW5kaWNhdG9yQXhpcztcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLnJlc2l6ZShyYWRhck1vZGVsLCBhcGkpO1xuICB9XG5cbiAgUmFkYXIucHJvdG90eXBlLmdldEluZGljYXRvckF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGljYXRvckF4ZXM7XG4gIH07XG5cbiAgUmFkYXIucHJvdG90eXBlLmRhdGFUb1BvaW50ID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRpY2F0b3JJbmRleCkge1xuICAgIHZhciBpbmRpY2F0b3JBeGlzID0gdGhpcy5faW5kaWNhdG9yQXhlc1tpbmRpY2F0b3JJbmRleF07XG4gICAgcmV0dXJuIHRoaXMuY29vcmRUb1BvaW50KGluZGljYXRvckF4aXMuZGF0YVRvQ29vcmQodmFsdWUpLCBpbmRpY2F0b3JJbmRleCk7XG4gIH07IC8vIFRPRE86IEFQSSBzaG91bGQgYmUgY29vcmRUb1BvaW50KFtjb29yZCwgaW5kaWNhdG9ySW5kZXhdKVxuXG5cbiAgUmFkYXIucHJvdG90eXBlLmNvb3JkVG9Qb2ludCA9IGZ1bmN0aW9uIChjb29yZCwgaW5kaWNhdG9ySW5kZXgpIHtcbiAgICB2YXIgaW5kaWNhdG9yQXhpcyA9IHRoaXMuX2luZGljYXRvckF4ZXNbaW5kaWNhdG9ySW5kZXhdO1xuICAgIHZhciBhbmdsZSA9IGluZGljYXRvckF4aXMuYW5nbGU7XG4gICAgdmFyIHggPSB0aGlzLmN4ICsgY29vcmQgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgdmFyIHkgPSB0aGlzLmN5IC0gY29vcmQgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfTtcblxuICBSYWRhci5wcm90b3R5cGUucG9pbnRUb0RhdGEgPSBmdW5jdGlvbiAocHQpIHtcbiAgICB2YXIgZHggPSBwdFswXSAtIHRoaXMuY3g7XG4gICAgdmFyIGR5ID0gcHRbMV0gLSB0aGlzLmN5O1xuICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIGR4IC89IHJhZGl1cztcbiAgICBkeSAvPSByYWRpdXM7XG4gICAgdmFyIHJhZGlhbiA9IE1hdGguYXRhbjIoLWR5LCBkeCk7IC8vIEZpbmQgdGhlIGNsb3Nlc3QgYW5nbGVcbiAgICAvLyBGSVhNRSBpbmRleCBjYW4gY2FsY3VsYXRlZCBkaXJlY3RseVxuXG4gICAgdmFyIG1pblJhZGlhbkRpZmYgPSBJbmZpbml0eTtcbiAgICB2YXIgY2xvc2VzdEF4aXM7XG4gICAgdmFyIGNsb3Nlc3RBeGlzSWR4ID0gLTE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2luZGljYXRvckF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmRpY2F0b3JBeGlzID0gdGhpcy5faW5kaWNhdG9yQXhlc1tpXTtcbiAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMocmFkaWFuIC0gaW5kaWNhdG9yQXhpcy5hbmdsZSk7XG5cbiAgICAgIGlmIChkaWZmIDwgbWluUmFkaWFuRGlmZikge1xuICAgICAgICBjbG9zZXN0QXhpcyA9IGluZGljYXRvckF4aXM7XG4gICAgICAgIGNsb3Nlc3RBeGlzSWR4ID0gaTtcbiAgICAgICAgbWluUmFkaWFuRGlmZiA9IGRpZmY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtjbG9zZXN0QXhpc0lkeCwgKyhjbG9zZXN0QXhpcyAmJiBjbG9zZXN0QXhpcy5jb29yZFRvRGF0YShyYWRpdXMpKV07XG4gIH07XG5cbiAgUmFkYXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChyYWRhck1vZGVsLCBhcGkpIHtcbiAgICB2YXIgY2VudGVyID0gcmFkYXJNb2RlbC5nZXQoJ2NlbnRlcicpO1xuICAgIHZhciB2aWV3V2lkdGggPSBhcGkuZ2V0V2lkdGgoKTtcbiAgICB2YXIgdmlld0hlaWdodCA9IGFwaS5nZXRIZWlnaHQoKTtcbiAgICB2YXIgdmlld1NpemUgPSBNYXRoLm1pbih2aWV3V2lkdGgsIHZpZXdIZWlnaHQpIC8gMjtcbiAgICB0aGlzLmN4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoY2VudGVyWzBdLCB2aWV3V2lkdGgpO1xuICAgIHRoaXMuY3kgPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChjZW50ZXJbMV0sIHZpZXdIZWlnaHQpO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IHJhZGFyTW9kZWwuZ2V0KCdzdGFydEFuZ2xlJykgKiBNYXRoLlBJIC8gMTgwOyAvLyByYWRpdXMgbWF5IGJlIHNpbmdsZSB2YWx1ZSBsaWtlIGAyMGAsIGAnODAlJ2AsIG9yIGFycmF5IGxpa2UgYFsxMCwgJzgwJSddYFxuXG4gICAgdmFyIHJhZGl1cyA9IHJhZGFyTW9kZWwuZ2V0KCdyYWRpdXMnKTtcblxuICAgIGlmICh0eXBlb2YgcmFkaXVzID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcmFkaXVzID09PSAnbnVtYmVyJykge1xuICAgICAgcmFkaXVzID0gWzAsIHJhZGl1c107XG4gICAgfVxuXG4gICAgdGhpcy5yMCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KHJhZGl1c1swXSwgdmlld1NpemUpO1xuICAgIHRoaXMuciA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KHJhZGl1c1sxXSwgdmlld1NpemUpO1xuICAgIGVhY2godGhpcy5faW5kaWNhdG9yQXhlcywgZnVuY3Rpb24gKGluZGljYXRvckF4aXMsIGlkeCkge1xuICAgICAgaW5kaWNhdG9yQXhpcy5zZXRFeHRlbnQodGhpcy5yMCwgdGhpcy5yKTtcbiAgICAgIHZhciBhbmdsZSA9IHRoaXMuc3RhcnRBbmdsZSArIGlkeCAqIE1hdGguUEkgKiAyIC8gdGhpcy5faW5kaWNhdG9yQXhlcy5sZW5ndGg7IC8vIE5vcm1hbGl6ZSB0byBbLVBJLCBQSV1cblxuICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKE1hdGguc2luKGFuZ2xlKSwgTWF0aC5jb3MoYW5nbGUpKTtcbiAgICAgIGluZGljYXRvckF4aXMuYW5nbGUgPSBhbmdsZTtcbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuICBSYWRhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBpbmRpY2F0b3JBeGVzID0gdGhpcy5faW5kaWNhdG9yQXhlcztcbiAgICB2YXIgcmFkYXJNb2RlbCA9IHRoaXMuX21vZGVsO1xuICAgIGVhY2goaW5kaWNhdG9yQXhlcywgZnVuY3Rpb24gKGluZGljYXRvckF4aXMpIHtcbiAgICAgIGluZGljYXRvckF4aXMuc2NhbGUuc2V0RXh0ZW50KEluZmluaXR5LCAtSW5maW5pdHkpO1xuICAgIH0pO1xuICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgncmFkYXInLCBmdW5jdGlvbiAocmFkYXJTZXJpZXMsIGlkeCkge1xuICAgICAgaWYgKHJhZGFyU2VyaWVzLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpICE9PSAncmFkYXInIC8vIEB0cy1pZ25vcmVcbiAgICAgIHx8IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdyYWRhcicsIHJhZGFyU2VyaWVzLmdldCgncmFkYXJJbmRleCcpKSAhPT0gcmFkYXJNb2RlbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0gcmFkYXJTZXJpZXMuZ2V0RGF0YSgpO1xuICAgICAgZWFjaChpbmRpY2F0b3JBeGVzLCBmdW5jdGlvbiAoaW5kaWNhdG9yQXhpcykge1xuICAgICAgICBpbmRpY2F0b3JBeGlzLnNjYWxlLnVuaW9uRXh0ZW50RnJvbURhdGEoZGF0YSwgZGF0YS5tYXBEaW1lbnNpb24oaW5kaWNhdG9yQXhpcy5kaW0pKTtcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xuICAgIHZhciBzcGxpdE51bWJlciA9IHJhZGFyTW9kZWwuZ2V0KCdzcGxpdE51bWJlcicpO1xuXG4gICAgZnVuY3Rpb24gaW5jcmVhc2VJbnRlcnZhbChpbnRlcnZhbCkge1xuICAgICAgdmFyIGV4cDEwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coaW50ZXJ2YWwpIC8gTWF0aC5MTjEwKSk7IC8vIEluY3JlYXNlIGludGVydmFsXG5cbiAgICAgIHZhciBmID0gaW50ZXJ2YWwgLyBleHAxMDtcblxuICAgICAgaWYgKGYgPT09IDIpIHtcbiAgICAgICAgZiA9IDU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmIGlzIDIgb3IgNVxuICAgICAgICBmICo9IDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmICogZXhwMTA7XG4gICAgfSAvLyBGb3JjZSBhbGwgdGhlIGF4aXMgZml4aW5nIHRoZSBtYXhTcGxpdE51bWJlci5cblxuXG4gICAgZWFjaChpbmRpY2F0b3JBeGVzLCBmdW5jdGlvbiAoaW5kaWNhdG9yQXhpcywgaWR4KSB7XG4gICAgICB2YXIgcmF3RXh0ZW50ID0gZ2V0U2NhbGVFeHRlbnQoaW5kaWNhdG9yQXhpcy5zY2FsZSwgaW5kaWNhdG9yQXhpcy5tb2RlbCkuZXh0ZW50O1xuICAgICAgbmljZVNjYWxlRXh0ZW50KGluZGljYXRvckF4aXMuc2NhbGUsIGluZGljYXRvckF4aXMubW9kZWwpO1xuICAgICAgdmFyIGF4aXNNb2RlbCA9IGluZGljYXRvckF4aXMubW9kZWw7XG4gICAgICB2YXIgc2NhbGUgPSBpbmRpY2F0b3JBeGlzLnNjYWxlO1xuICAgICAgdmFyIGZpeGVkTWluID0gcGFyc2VBeGlzTW9kZWxNaW5NYXgoc2NhbGUsIGF4aXNNb2RlbC5nZXQoJ21pbicsIHRydWUpKTtcbiAgICAgIHZhciBmaXhlZE1heCA9IHBhcnNlQXhpc01vZGVsTWluTWF4KHNjYWxlLCBheGlzTW9kZWwuZ2V0KCdtYXgnLCB0cnVlKSk7XG4gICAgICB2YXIgaW50ZXJ2YWwgPSBzY2FsZS5nZXRJbnRlcnZhbCgpO1xuXG4gICAgICBpZiAoZml4ZWRNaW4gIT0gbnVsbCAmJiBmaXhlZE1heCAhPSBudWxsKSB7XG4gICAgICAgIC8vIFVzZXIgc2V0IG1pbiwgbWF4LCBkaXZpZGUgdG8gZ2V0IG5ldyBpbnRlcnZhbFxuICAgICAgICBzY2FsZS5zZXRFeHRlbnQoK2ZpeGVkTWluLCArZml4ZWRNYXgpO1xuICAgICAgICBzY2FsZS5zZXRJbnRlcnZhbCgoZml4ZWRNYXggLSBmaXhlZE1pbikgLyBzcGxpdE51bWJlcik7XG4gICAgICB9IGVsc2UgaWYgKGZpeGVkTWluICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1heCA9IHZvaWQgMDsgLy8gVXNlciBzZXQgbWluLCBleHBhbmQgZXh0ZW50IG9uIHRoZSBvdGhlciBzaWRlXG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIG1heCA9IGZpeGVkTWluICsgaW50ZXJ2YWwgKiBzcGxpdE51bWJlcjtcbiAgICAgICAgICBzY2FsZS5zZXRFeHRlbnQoK2ZpeGVkTWluLCBtYXgpOyAvLyBJbnRlcnZhbCBtdXN0IGJlZW4gc2V0IGFmdGVyIGV4dGVudFxuICAgICAgICAgIC8vIEZJWE1FXG5cbiAgICAgICAgICBzY2FsZS5zZXRJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgaW50ZXJ2YWwgPSBpbmNyZWFzZUludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgfSB3aGlsZSAobWF4IDwgcmF3RXh0ZW50WzFdICYmIGlzRmluaXRlKG1heCkgJiYgaXNGaW5pdGUocmF3RXh0ZW50WzFdKSk7XG4gICAgICB9IGVsc2UgaWYgKGZpeGVkTWF4ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1pbiA9IHZvaWQgMDsgLy8gVXNlciBzZXQgbWluLCBleHBhbmQgZXh0ZW50IG9uIHRoZSBvdGhlciBzaWRlXG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIG1pbiA9IGZpeGVkTWF4IC0gaW50ZXJ2YWwgKiBzcGxpdE51bWJlcjtcbiAgICAgICAgICBzY2FsZS5zZXRFeHRlbnQobWluLCArZml4ZWRNYXgpO1xuICAgICAgICAgIHNjYWxlLnNldEludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICBpbnRlcnZhbCA9IGluY3JlYXNlSW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICB9IHdoaWxlIChtaW4gPiByYXdFeHRlbnRbMF0gJiYgaXNGaW5pdGUobWluKSAmJiBpc0Zpbml0ZShyYXdFeHRlbnRbMF0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuaWNlZFNwbGl0TnVtYmVyID0gc2NhbGUuZ2V0VGlja3MoKS5sZW5ndGggLSAxO1xuXG4gICAgICAgIGlmIChuaWNlZFNwbGl0TnVtYmVyID4gc3BsaXROdW1iZXIpIHtcbiAgICAgICAgICBpbnRlcnZhbCA9IGluY3JlYXNlSW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICB9IC8vIFRPRE9cblxuXG4gICAgICAgIHZhciBtYXggPSBNYXRoLmNlaWwocmF3RXh0ZW50WzFdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWw7XG4gICAgICAgIHZhciBtaW4gPSBudW1iZXJVdGlsLnJvdW5kKG1heCAtIGludGVydmFsICogc3BsaXROdW1iZXIpO1xuICAgICAgICBzY2FsZS5zZXRFeHRlbnQobWluLCBtYXgpO1xuICAgICAgICBzY2FsZS5zZXRJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgUmFkYXIucHJvdG90eXBlLmNvbnZlcnRUb1BpeGVsID0gZnVuY3Rpb24gKGVjTW9kZWwsIGZpbmRlciwgdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oJ05vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBSYWRhci5wcm90b3R5cGUuY29udmVydEZyb21QaXhlbCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIsIHBpeGVsKSB7XG4gICAgY29uc29sZS53YXJuKCdOb3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgUmFkYXIucHJvdG90eXBlLmNvbnRhaW5Qb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIGNvbnNvbGUud2FybignTm90IGltcGxlbWVudGVkLicpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBSYWRhci5jcmVhdGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIHJhZGFyTGlzdCA9IFtdO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgncmFkYXInLCBmdW5jdGlvbiAocmFkYXJNb2RlbCkge1xuICAgICAgdmFyIHJhZGFyID0gbmV3IFJhZGFyKHJhZGFyTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgICByYWRhckxpc3QucHVzaChyYWRhcik7XG4gICAgICByYWRhck1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSByYWRhcjtcbiAgICB9KTtcbiAgICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ3JhZGFyJywgZnVuY3Rpb24gKHJhZGFyU2VyaWVzKSB7XG4gICAgICBpZiAocmFkYXJTZXJpZXMuZ2V0KCdjb29yZGluYXRlU3lzdGVtJykgPT09ICdyYWRhcicpIHtcbiAgICAgICAgLy8gSW5qZWN0IGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmFkYXJTZXJpZXMuY29vcmRpbmF0ZVN5c3RlbSA9IHJhZGFyTGlzdFtyYWRhclNlcmllcy5nZXQoJ3JhZGFySW5kZXgnKSB8fCAwXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmFkYXJMaXN0O1xuICB9O1xuICAvKipcbiAgICogUmFkYXIgZGltZW5zaW9ucyBpcyBiYXNlZCBvbiB0aGUgZGF0YVxuICAgKi9cblxuXG4gIFJhZGFyLmRpbWVuc2lvbnMgPSBbXTtcbiAgcmV0dXJuIFJhZGFyO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBSYWRhcjsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCBheGlzRGVmYXVsdCBmcm9tICcuLi9heGlzRGVmYXVsdCc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvTW9kZWwnO1xuaW1wb3J0IHsgQXhpc01vZGVsQ29tbW9uTWl4aW4gfSBmcm9tICcuLi9heGlzTW9kZWxDb21tb25NaXhpbic7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50JztcbnZhciB2YWx1ZUF4aXNEZWZhdWx0ID0gYXhpc0RlZmF1bHQudmFsdWU7XG5cbmZ1bmN0aW9uIGRlZmF1bHRzU2hvdyhvcHQsIHNob3cpIHtcbiAgcmV0dXJuIHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgc2hvdzogc2hvd1xuICB9LCBvcHQpO1xufVxuXG52YXIgUmFkYXJNb2RlbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhSYWRhck1vZGVsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFJhZGFyTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50eXBlID0gUmFkYXJNb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFJhZGFyTW9kZWwucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvdW5kYXJ5R2FwID0gdGhpcy5nZXQoJ2JvdW5kYXJ5R2FwJyk7XG4gICAgdmFyIHNwbGl0TnVtYmVyID0gdGhpcy5nZXQoJ3NwbGl0TnVtYmVyJyk7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5nZXQoJ3NjYWxlJyk7XG4gICAgdmFyIGF4aXNMaW5lID0gdGhpcy5nZXQoJ2F4aXNMaW5lJyk7XG4gICAgdmFyIGF4aXNUaWNrID0gdGhpcy5nZXQoJ2F4aXNUaWNrJyk7IC8vIGxldCBheGlzVHlwZSA9IHRoaXMuZ2V0KCdheGlzVHlwZScpO1xuXG4gICAgdmFyIGF4aXNMYWJlbCA9IHRoaXMuZ2V0KCdheGlzTGFiZWwnKTtcbiAgICB2YXIgbmFtZVRleHRTdHlsZSA9IHRoaXMuZ2V0KCdheGlzTmFtZScpO1xuICAgIHZhciBzaG93TmFtZSA9IHRoaXMuZ2V0KFsnYXhpc05hbWUnLCAnc2hvdyddKTtcbiAgICB2YXIgbmFtZUZvcm1hdHRlciA9IHRoaXMuZ2V0KFsnYXhpc05hbWUnLCAnZm9ybWF0dGVyJ10pO1xuICAgIHZhciBuYW1lR2FwID0gdGhpcy5nZXQoJ2F4aXNOYW1lR2FwJyk7XG4gICAgdmFyIHRyaWdnZXJFdmVudCA9IHRoaXMuZ2V0KCd0cmlnZ2VyRXZlbnQnKTtcbiAgICB2YXIgaW5kaWNhdG9yTW9kZWxzID0genJVdGlsLm1hcCh0aGlzLmdldCgnaW5kaWNhdG9yJykgfHwgW10sIGZ1bmN0aW9uIChpbmRpY2F0b3JPcHQpIHtcbiAgICAgIC8vIFBFTkRJTkdcbiAgICAgIGlmIChpbmRpY2F0b3JPcHQubWF4ICE9IG51bGwgJiYgaW5kaWNhdG9yT3B0Lm1heCA+IDAgJiYgIWluZGljYXRvck9wdC5taW4pIHtcbiAgICAgICAgaW5kaWNhdG9yT3B0Lm1pbiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGluZGljYXRvck9wdC5taW4gIT0gbnVsbCAmJiBpbmRpY2F0b3JPcHQubWluIDwgMCAmJiAhaW5kaWNhdG9yT3B0Lm1heCkge1xuICAgICAgICBpbmRpY2F0b3JPcHQubWF4ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGlOYW1lVGV4dFN0eWxlID0gbmFtZVRleHRTdHlsZTtcblxuICAgICAgaWYgKGluZGljYXRvck9wdC5jb2xvciAhPSBudWxsKSB7XG4gICAgICAgIGlOYW1lVGV4dFN0eWxlID0genJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgICBjb2xvcjogaW5kaWNhdG9yT3B0LmNvbG9yXG4gICAgICAgIH0sIG5hbWVUZXh0U3R5bGUpO1xuICAgICAgfSAvLyBVc2Ugc2FtZSBjb25maWd1cmF0aW9uXG5cblxuICAgICAgdmFyIGlubmVySW5kaWNhdG9yT3B0ID0genJVdGlsLm1lcmdlKHpyVXRpbC5jbG9uZShpbmRpY2F0b3JPcHQpLCB7XG4gICAgICAgIGJvdW5kYXJ5R2FwOiBib3VuZGFyeUdhcCxcbiAgICAgICAgc3BsaXROdW1iZXI6IHNwbGl0TnVtYmVyLFxuICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgIGF4aXNMaW5lOiBheGlzTGluZSxcbiAgICAgICAgYXhpc1RpY2s6IGF4aXNUaWNrLFxuICAgICAgICAvLyBheGlzVHlwZTogYXhpc1R5cGUsXG4gICAgICAgIGF4aXNMYWJlbDogYXhpc0xhYmVsLFxuICAgICAgICAvLyBDb21wYXRpYmxlIHdpdGggMiBhbmQgdXNlIHRleHRcbiAgICAgICAgbmFtZTogaW5kaWNhdG9yT3B0LnRleHQsXG4gICAgICAgIG5hbWVMb2NhdGlvbjogJ2VuZCcsXG4gICAgICAgIG5hbWVHYXA6IG5hbWVHYXAsXG4gICAgICAgIC8vIG1pbjogMCxcbiAgICAgICAgbmFtZVRleHRTdHlsZTogaU5hbWVUZXh0U3R5bGUsXG4gICAgICAgIHRyaWdnZXJFdmVudDogdHJpZ2dlckV2ZW50XG4gICAgICB9LCBmYWxzZSk7XG5cbiAgICAgIGlmICghc2hvd05hbWUpIHtcbiAgICAgICAgaW5uZXJJbmRpY2F0b3JPcHQubmFtZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG5hbWVGb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBpbmROYW1lID0gaW5uZXJJbmRpY2F0b3JPcHQubmFtZTtcbiAgICAgICAgaW5uZXJJbmRpY2F0b3JPcHQubmFtZSA9IG5hbWVGb3JtYXR0ZXIucmVwbGFjZSgne3ZhbHVlfScsIGluZE5hbWUgIT0gbnVsbCA/IGluZE5hbWUgOiAnJyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lRm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlubmVySW5kaWNhdG9yT3B0Lm5hbWUgPSBuYW1lRm9ybWF0dGVyKGlubmVySW5kaWNhdG9yT3B0Lm5hbWUsIGlubmVySW5kaWNhdG9yT3B0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKGlubmVySW5kaWNhdG9yT3B0LCBudWxsLCB0aGlzLmVjTW9kZWwpO1xuICAgICAgenJVdGlsLm1peGluKG1vZGVsLCBBeGlzTW9kZWxDb21tb25NaXhpbi5wcm90b3R5cGUpOyAvLyBGb3IgdHJpZ2dlckV2ZW50LlxuXG4gICAgICBtb2RlbC5tYWluVHlwZSA9ICdyYWRhcic7XG4gICAgICBtb2RlbC5jb21wb25lbnRJbmRleCA9IHRoaXMuY29tcG9uZW50SW5kZXg7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5faW5kaWNhdG9yTW9kZWxzID0gaW5kaWNhdG9yTW9kZWxzO1xuICB9O1xuXG4gIFJhZGFyTW9kZWwucHJvdG90eXBlLmdldEluZGljYXRvck1vZGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kaWNhdG9yTW9kZWxzO1xuICB9O1xuXG4gIFJhZGFyTW9kZWwudHlwZSA9ICdyYWRhcic7XG4gIFJhZGFyTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogMCxcbiAgICBjZW50ZXI6IFsnNTAlJywgJzUwJSddLFxuICAgIHJhZGl1czogJzc1JScsXG4gICAgc3RhcnRBbmdsZTogOTAsXG4gICAgYXhpc05hbWU6IHtcbiAgICAgIHNob3c6IHRydWUgLy8gZm9ybWF0dGVyOiBudWxsXG4gICAgICAvLyB0ZXh0U3R5bGU6IHt9XG5cbiAgICB9LFxuICAgIGJvdW5kYXJ5R2FwOiBbMCwgMF0sXG4gICAgc3BsaXROdW1iZXI6IDUsXG4gICAgYXhpc05hbWVHYXA6IDE1LFxuICAgIHNjYWxlOiBmYWxzZSxcbiAgICAvLyBQb2x5Z29uIG9yIGNpcmNsZVxuICAgIHNoYXBlOiAncG9seWdvbicsXG4gICAgYXhpc0xpbmU6IHpyVXRpbC5tZXJnZSh7XG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgY29sb3I6ICcjYmJiJ1xuICAgICAgfVxuICAgIH0sIHZhbHVlQXhpc0RlZmF1bHQuYXhpc0xpbmUpLFxuICAgIGF4aXNMYWJlbDogZGVmYXVsdHNTaG93KHZhbHVlQXhpc0RlZmF1bHQuYXhpc0xhYmVsLCBmYWxzZSksXG4gICAgYXhpc1RpY2s6IGRlZmF1bHRzU2hvdyh2YWx1ZUF4aXNEZWZhdWx0LmF4aXNUaWNrLCBmYWxzZSksXG4gICAgLy8gYXhpc1R5cGU6ICd2YWx1ZScsXG4gICAgc3BsaXRMaW5lOiBkZWZhdWx0c1Nob3codmFsdWVBeGlzRGVmYXVsdC5zcGxpdExpbmUsIHRydWUpLFxuICAgIHNwbGl0QXJlYTogZGVmYXVsdHNTaG93KHZhbHVlQXhpc0RlZmF1bHQuc3BsaXRBcmVhLCB0cnVlKSxcbiAgICAvLyB7dGV4dCwgbWluLCBtYXh9XG4gICAgaW5kaWNhdG9yOiBbXVxuICB9O1xuICByZXR1cm4gUmFkYXJNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBSYWRhck1vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgeyBlYWNoLCBoYXNPd24gfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnO1xudmFyIGRlcHJlY2F0ZWRMb2dzID0ge307XG4vKipcbiAqIFdoZXRoZXIgbmVlZCB0byBjYWxsIGBjb252ZXJ0RUM0Q29tcGF0aWJsZVN0eWxlYC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNFQzRDb21wYXRpYmxlU3R5bGUoc3R5bGUsIGVsVHlwZSwgaGFzT3duVGV4dENvbnRlbnRPcHRpb24sIGhhc093blRleHRDb25maWcpIHtcbiAgLy8gU2luY2UgZWNoYXJ0czUsIGBSZWN0VGV4dGAgaXMgc2VwYXJhdGVkIGZyb20gaXRzIGhvc3QgZWxlbWVudCBhbmQgc3R5bGUudGV4dFxuICAvLyBkb2VzIG5vdCBleGlzdCBhbnkgbW9yZS4gVGhlIGNvbXBhdCB3b3JrIGJyaW5ncyBzb21lIGV4dHJhIGJ1cmRlbiBvbiBwZXJmb3JtYW5jZS5cbiAgLy8gU28gd2UgcHJvdmlkZTpcbiAgLy8gYGxlZ2FjeTogdHJ1ZWAgZm9yY2UgbWFrZSBjb21wYXQuXG4gIC8vIGBsZWdhY3k6IGZhbHNlYCwgZm9yY2UgZG8gbm90IGNvbXBhdC5cbiAgLy8gYGxlZ2FjeWAgbm90IHNldDogYXV0byBkZXRlY3Qgd2hldGVyIGxlZ2FjeS5cbiAgLy8gICAgIEJ1dCBpbiB0aGlzIGNhc2Ugd2UgZG8gbm90IGNvbXBhdCAoZGlmZmljdWx0IHRvIGRldGVjdCBhbmQgcmFyZSBjYXNlKTpcbiAgLy8gICAgIEJlY3VzZSBjdXN0b20gc2VyaWVzIGFuZCBncmFwaGljIGNvbXBvbmVudCBzdXBwb3J0IFwibWVyZ2VcIiwgdXNlcnMgbWF5IGZpcnN0bHlcbiAgLy8gICAgIG9ubHkgc2V0IGB0ZXh0U3Ryb2tlV2lkdGhgIHN0eWxlIG9yIHNlY29uZGx5IG9ubHkgc2V0IGB0ZXh0YC5cbiAgcmV0dXJuIHN0eWxlICYmIChzdHlsZS5sZWdhY3kgfHwgc3R5bGUubGVnYWN5ICE9PSBmYWxzZSAmJiAhaGFzT3duVGV4dENvbnRlbnRPcHRpb24gJiYgIWhhc093blRleHRDb25maWcgJiYgZWxUeXBlICE9PSAndHNwYW4nIC8vIERpZmZpY3VsdCB0byBkZXRlY3Qgd2hldGhlciBsZWdhY3kgZm9yIGEgXCJ0ZXh0XCIgZWwuXG4gICYmIChlbFR5cGUgPT09ICd0ZXh0JyB8fCBoYXNPd24oc3R5bGUsICd0ZXh0JykpKTtcbn1cbi8qKlxuICogYEVDNENvbXBhdGlibGVTdHlsZWAgaXMgc3R5bGUgdGhhdCBtaWdodCBiZSBpbiBlY2hhcnRzNCBmb3JtYXQgb3IgZWNoYXJ0czUgZm9ybWF0LlxuICogQHBhcmFtIGhvc3RTdHlsZSBUaGUgcHJvcGVydGllcyBtaWdodCBiZSBtb2RpZmllZC5cbiAqIEByZXR1cm4gSWYgYmUgdGV4dCBlbCwgYHRleHRDb250ZW50U3R5bGVgIGFuZCBgdGV4dENvbmZpZ2Agd2lsbCBub3QgYmUgcmV0dXJlZC5cbiAqICAgICAgICAgT3RoZXJ3aXNlIGEgYHRleHRDb250ZW50U3R5bGVgIGFuZCBgdGV4dENvbmZpZ2Agd2lsbCBiZSBjcmVhdGVkLCB3aG9zZSBwcm9wcyBhcmVhXG4gKiAgICAgICAgIHJldHJpZWQgZnJvbSB0aGUgYGhvc3RTdHlsZWAuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRGcm9tRUM0Q29tcGF0aWJsZVN0eWxlKGhvc3RTdHlsZSwgZWxUeXBlLCBpc05vcm1hbCkge1xuICB2YXIgc3JjU3R5bGUgPSBob3N0U3R5bGU7XG4gIHZhciB0ZXh0Q29uZmlnO1xuICB2YXIgdGV4dENvbnRlbnQ7XG4gIHZhciB0ZXh0Q29udGVudFN0eWxlO1xuXG4gIGlmIChlbFR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHRleHRDb250ZW50U3R5bGUgPSBzcmNTdHlsZTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0Q29udGVudFN0eWxlID0ge307XG4gICAgaGFzT3duKHNyY1N0eWxlLCAndGV4dCcpICYmICh0ZXh0Q29udGVudFN0eWxlLnRleHQgPSBzcmNTdHlsZS50ZXh0KTtcbiAgICBoYXNPd24oc3JjU3R5bGUsICdyaWNoJykgJiYgKHRleHRDb250ZW50U3R5bGUucmljaCA9IHNyY1N0eWxlLnJpY2gpO1xuICAgIGhhc093bihzcmNTdHlsZSwgJ3RleHRGaWxsJykgJiYgKHRleHRDb250ZW50U3R5bGUuZmlsbCA9IHNyY1N0eWxlLnRleHRGaWxsKTtcbiAgICBoYXNPd24oc3JjU3R5bGUsICd0ZXh0U3Ryb2tlJykgJiYgKHRleHRDb250ZW50U3R5bGUuc3Ryb2tlID0gc3JjU3R5bGUudGV4dFN0cm9rZSk7XG4gICAgdGV4dENvbnRlbnQgPSB7XG4gICAgICB0eXBlOiAndGV4dCcsXG4gICAgICBzdHlsZTogdGV4dENvbnRlbnRTdHlsZSxcbiAgICAgIC8vIGVjNCBkbyBub3Qgc3VwcG9ydCByZWN0VGV4dCB0cmlnZ2VyLlxuICAgICAgLy8gQW5kIHdoZW4gdGV4dCBwb3N0aW9uIGlzIGRpZmZlcmVudCBpbiBub3JtYWwgYW5kIGVtcGhhc2lzXG4gICAgICAvLyA9PiBob3ZlciB0ZXh0IHRyaWdnZXIgZW1waGFzaXM7XG4gICAgICAvLyA9PiB0ZXh0IHBvc2l0aW9uIGNoYW5nZWQsIGxlYXZlIG1vdXNlIHBvaW50ZXIgaW1tZWRpYXRlbHk7XG4gICAgICAvLyBUaGF0IG1pZ2h0IGNhdXNlIHN0YXRlIGluY29ycmVjdC5cbiAgICAgIHNpbGVudDogdHJ1ZVxuICAgIH07XG4gICAgdGV4dENvbmZpZyA9IHt9O1xuICAgIHZhciBoYXNPd25Qb3MgPSBoYXNPd24oc3JjU3R5bGUsICd0ZXh0UG9zaXRpb24nKTtcblxuICAgIGlmIChpc05vcm1hbCkge1xuICAgICAgdGV4dENvbmZpZy5wb3NpdGlvbiA9IGhhc093blBvcyA/IHNyY1N0eWxlLnRleHRQb3NpdGlvbiA6ICdpbnNpZGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNPd25Qb3MgJiYgKHRleHRDb25maWcucG9zaXRpb24gPSBzcmNTdHlsZS50ZXh0UG9zaXRpb24pO1xuICAgIH1cblxuICAgIGhhc093bihzcmNTdHlsZSwgJ3RleHRQb3NpdGlvbicpICYmICh0ZXh0Q29uZmlnLnBvc2l0aW9uID0gc3JjU3R5bGUudGV4dFBvc2l0aW9uKTtcbiAgICBoYXNPd24oc3JjU3R5bGUsICd0ZXh0T2Zmc2V0JykgJiYgKHRleHRDb25maWcub2Zmc2V0ID0gc3JjU3R5bGUudGV4dE9mZnNldCk7XG4gICAgaGFzT3duKHNyY1N0eWxlLCAndGV4dFJvdGF0aW9uJykgJiYgKHRleHRDb25maWcucm90YXRpb24gPSBzcmNTdHlsZS50ZXh0Um90YXRpb24pO1xuICAgIGhhc093bihzcmNTdHlsZSwgJ3RleHREaXN0YW5jZScpICYmICh0ZXh0Q29uZmlnLmRpc3RhbmNlID0gc3JjU3R5bGUudGV4dERpc3RhbmNlKTtcbiAgfVxuXG4gIGNvbnZlcnRFQzRDb21wYXRpYmxlUmljaEl0ZW0odGV4dENvbnRlbnRTdHlsZSwgaG9zdFN0eWxlKTtcbiAgZWFjaCh0ZXh0Q29udGVudFN0eWxlLnJpY2gsIGZ1bmN0aW9uIChyaWNoSXRlbSkge1xuICAgIGNvbnZlcnRFQzRDb21wYXRpYmxlUmljaEl0ZW0ocmljaEl0ZW0sIHJpY2hJdGVtKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdGV4dENvbmZpZzogdGV4dENvbmZpZyxcbiAgICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnRcbiAgfTtcbn1cbi8qKlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIHNldCB0byBgb3V0YC5cbiAqL1xuXG5mdW5jdGlvbiBjb252ZXJ0RUM0Q29tcGF0aWJsZVJpY2hJdGVtKG91dCwgcmljaEl0ZW0pIHtcbiAgaWYgKCFyaWNoSXRlbSkge1xuICAgIHJldHVybjtcbiAgfSAvLyAoMSkgRm9yIHNpbXBsaWNpdHksIG1ha2UgdGV4dFhYWCBwcm9wZXJ0aWVzIChkZXByZWNhdGVkIHNpbmNlIGVjNSkgaGFzXG4gIC8vIGhpZ2hlciBwcmlvcml0eS4gRm9yIGV4YW1wbGUsIGNvbnNpZGVyIGluIGVjNCBgYm9yZGVyQ29sb3I6IDUsIHRleHRCb3JkZXJDb2xvcjogMTBgXG4gIC8vIG9uIGEgcmVjdCBtZWFucyBgYm9yZGVyQ29sb3I6IDRgIG9uIHRoZSByZWN0IGFuZCBgYm9yZGVyQ29sb3I6IDEwYCBvbiBhbiBhdHRhY2hlZFxuICAvLyByaWNoVGV4dCBpbiBlYzUuXG4gIC8vICgyKSBgb3V0ID09PSByaWNoSXRlbWAgaWYgYW5kIG9ubHkgaWYgYG91dGAgaXMgdGV4dCBlbCBvciByaWNoIGl0ZW0uXG4gIC8vIFNvIHdlIGNhbiBvdmVyd2l0ZSBleGlzdGluZyBwcm9wcyBpbiBgb3V0YCBzaW5jZSB0ZXh0WFhYIGhhcyBoaWdoZXIgcHJpb3JpdHkuXG5cblxuICByaWNoSXRlbS5mb250ID0gcmljaEl0ZW0udGV4dEZvbnQgfHwgcmljaEl0ZW0uZm9udDtcbiAgaGFzT3duKHJpY2hJdGVtLCAndGV4dFN0cm9rZVdpZHRoJykgJiYgKG91dC5saW5lV2lkdGggPSByaWNoSXRlbS50ZXh0U3Ryb2tlV2lkdGgpO1xuICBoYXNPd24ocmljaEl0ZW0sICd0ZXh0QWxpZ24nKSAmJiAob3V0LmFsaWduID0gcmljaEl0ZW0udGV4dEFsaWduKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAndGV4dFZlcnRpY2FsQWxpZ24nKSAmJiAob3V0LnZlcnRpY2FsQWxpZ24gPSByaWNoSXRlbS50ZXh0VmVydGljYWxBbGlnbik7XG4gIGhhc093bihyaWNoSXRlbSwgJ3RleHRMaW5lSGVpZ2h0JykgJiYgKG91dC5saW5lSGVpZ2h0ID0gcmljaEl0ZW0udGV4dExpbmVIZWlnaHQpO1xuICBoYXNPd24ocmljaEl0ZW0sICd0ZXh0V2lkdGgnKSAmJiAob3V0LndpZHRoID0gcmljaEl0ZW0udGV4dFdpZHRoKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAndGV4dEhlaWdodCcpICYmIChvdXQuaGVpZ2h0ID0gcmljaEl0ZW0udGV4dEhlaWdodCk7XG4gIGhhc093bihyaWNoSXRlbSwgJ3RleHRCYWNrZ3JvdW5kQ29sb3InKSAmJiAob3V0LmJhY2tncm91bmRDb2xvciA9IHJpY2hJdGVtLnRleHRCYWNrZ3JvdW5kQ29sb3IpO1xuICBoYXNPd24ocmljaEl0ZW0sICd0ZXh0UGFkZGluZycpICYmIChvdXQucGFkZGluZyA9IHJpY2hJdGVtLnRleHRQYWRkaW5nKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAndGV4dEJvcmRlckNvbG9yJykgJiYgKG91dC5ib3JkZXJDb2xvciA9IHJpY2hJdGVtLnRleHRCb3JkZXJDb2xvcik7XG4gIGhhc093bihyaWNoSXRlbSwgJ3RleHRCb3JkZXJXaWR0aCcpICYmIChvdXQuYm9yZGVyV2lkdGggPSByaWNoSXRlbS50ZXh0Qm9yZGVyV2lkdGgpO1xuICBoYXNPd24ocmljaEl0ZW0sICd0ZXh0Qm9yZGVyUmFkaXVzJykgJiYgKG91dC5ib3JkZXJSYWRpdXMgPSByaWNoSXRlbS50ZXh0Qm9yZGVyUmFkaXVzKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAndGV4dEJveFNoYWRvd0NvbG9yJykgJiYgKG91dC5zaGFkb3dDb2xvciA9IHJpY2hJdGVtLnRleHRCb3hTaGFkb3dDb2xvcik7XG4gIGhhc093bihyaWNoSXRlbSwgJ3RleHRCb3hTaGFkb3dCbHVyJykgJiYgKG91dC5zaGFkb3dCbHVyID0gcmljaEl0ZW0udGV4dEJveFNoYWRvd0JsdXIpO1xuICBoYXNPd24ocmljaEl0ZW0sICd0ZXh0Qm94U2hhZG93T2Zmc2V0WCcpICYmIChvdXQuc2hhZG93T2Zmc2V0WCA9IHJpY2hJdGVtLnRleHRCb3hTaGFkb3dPZmZzZXRYKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAndGV4dEJveFNoYWRvd09mZnNldFknKSAmJiAob3V0LnNoYWRvd09mZnNldFkgPSByaWNoSXRlbS50ZXh0Qm94U2hhZG93T2Zmc2V0WSk7XG59XG4vKipcbiAqIENvbnZlcnQgdG8gcHVyZSBlY2hhcnRzNCBmb3JtYXQgc3R5bGUuXG4gKiBgaXRlbVN0eWxlYCB3aWxsIGJlIG1vZGlmaWVkLCBhZGRlZCB3aXRoIGVjNCBzdHlsZSBwcm9wZXJ0aWVzIGZyb21cbiAqIGB0ZXh0U3R5bGVgIGFuZCBgdGV4dENvbmZpZ2AuXG4gKlxuICogW0NhdmVhdF06IEZvciBzaW1wbGljaXR5LCBgaW5zaWRlUm9sbGJhY2tgIGluIGVjNCBkb2VzIG5vdCBjb21wYXQsIHdoZXJlXG4gKiBgc3R5bGVFbXBoYXNpczoge3RleHRGaWxsOiAncmVkJ31gIHdpbGwgcmVtb3ZlIHRoZSBub3JtYWwgYXV0byBhZGRlZCBzdHJva2UuXG4gKi9cblxuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvRUM0U3R5bGVGb3JDdXN0b21TZXJpc2UoaXRlbVN0bCwgdHhTdGwsIHR4Q2ZnKSB7XG4gIHZhciBvdXQgPSBpdGVtU3RsOyAvLyBTZWUgYGN1c3RvbS50c2AsIGEgdHJpY2sgdG8gc2V0IGV4dHJhIGB0ZXh0UG9zaXRpb25gIGZpcnN0bHkuXG5cbiAgb3V0LnRleHRQb3NpdGlvbiA9IG91dC50ZXh0UG9zaXRpb24gfHwgdHhDZmcucG9zaXRpb24gfHwgJ2luc2lkZSc7XG4gIHR4Q2ZnLm9mZnNldCAhPSBudWxsICYmIChvdXQudGV4dE9mZnNldCA9IHR4Q2ZnLm9mZnNldCk7XG4gIHR4Q2ZnLnJvdGF0aW9uICE9IG51bGwgJiYgKG91dC50ZXh0Um90YXRpb24gPSB0eENmZy5yb3RhdGlvbik7XG4gIHR4Q2ZnLmRpc3RhbmNlICE9IG51bGwgJiYgKG91dC50ZXh0RGlzdGFuY2UgPSB0eENmZy5kaXN0YW5jZSk7XG4gIHZhciBpc0luc2lkZSA9IG91dC50ZXh0UG9zaXRpb24uaW5kZXhPZignaW5zaWRlJykgPj0gMDtcbiAgdmFyIGhvc3RGaWxsID0gaXRlbVN0bC5maWxsIHx8ICcjMDAwJztcbiAgY29udmVydFRvRUM0UmljaEl0ZW0ob3V0LCB0eFN0bCk7XG4gIHZhciB0ZXh0RmlsbE5vdFNldCA9IG91dC50ZXh0RmlsbCA9PSBudWxsO1xuXG4gIGlmIChpc0luc2lkZSkge1xuICAgIGlmICh0ZXh0RmlsbE5vdFNldCkge1xuICAgICAgb3V0LnRleHRGaWxsID0gdHhDZmcuaW5zaWRlRmlsbCB8fCAnI2ZmZic7XG4gICAgICAhb3V0LnRleHRTdHJva2UgJiYgdHhDZmcuaW5zaWRlU3Ryb2tlICYmIChvdXQudGV4dFN0cm9rZSA9IHR4Q2ZnLmluc2lkZVN0cm9rZSk7XG4gICAgICAhb3V0LnRleHRTdHJva2UgJiYgKG91dC50ZXh0U3Ryb2tlID0gaG9zdEZpbGwpO1xuICAgICAgb3V0LnRleHRTdHJva2VXaWR0aCA9PSBudWxsICYmIChvdXQudGV4dFN0cm9rZVdpZHRoID0gMik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0ZXh0RmlsbE5vdFNldCkge1xuICAgICAgb3V0LnRleHRGaWxsID0gdHhDZmcub3V0c2lkZUZpbGwgfHwgaG9zdEZpbGw7XG4gICAgfVxuXG4gICAgIW91dC50ZXh0U3Ryb2tlICYmIHR4Q2ZnLm91dHNpZGVTdHJva2UgJiYgKG91dC50ZXh0U3Ryb2tlID0gdHhDZmcub3V0c2lkZVN0cm9rZSk7XG4gIH1cblxuICBvdXQudGV4dCA9IHR4U3RsLnRleHQ7XG4gIG91dC5yaWNoID0gdHhTdGwucmljaDtcbiAgZWFjaCh0eFN0bC5yaWNoLCBmdW5jdGlvbiAocmljaEl0ZW0pIHtcbiAgICBjb252ZXJ0VG9FQzRSaWNoSXRlbShyaWNoSXRlbSwgcmljaEl0ZW0pO1xuICB9KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gY29udmVydFRvRUM0UmljaEl0ZW0ob3V0LCByaWNoSXRlbSkge1xuICBpZiAoIXJpY2hJdGVtKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaGFzT3duKHJpY2hJdGVtLCAnZmlsbCcpICYmIChvdXQudGV4dEZpbGwgPSByaWNoSXRlbS5maWxsKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnc3Ryb2tlJykgJiYgKG91dC50ZXh0U3Ryb2tlID0gcmljaEl0ZW0uZmlsbCk7XG4gIGhhc093bihyaWNoSXRlbSwgJ2xpbmVXaWR0aCcpICYmIChvdXQudGV4dFN0cm9rZVdpZHRoID0gcmljaEl0ZW0ubGluZVdpZHRoKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnZm9udCcpICYmIChvdXQuZm9udCA9IHJpY2hJdGVtLmZvbnQpO1xuICBoYXNPd24ocmljaEl0ZW0sICdmb250U3R5bGUnKSAmJiAob3V0LmZvbnRTdHlsZSA9IHJpY2hJdGVtLmZvbnRTdHlsZSk7XG4gIGhhc093bihyaWNoSXRlbSwgJ2ZvbnRXZWlnaHQnKSAmJiAob3V0LmZvbnRXZWlnaHQgPSByaWNoSXRlbS5mb250V2VpZ2h0KTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnZm9udFNpemUnKSAmJiAob3V0LmZvbnRTaXplID0gcmljaEl0ZW0uZm9udFNpemUpO1xuICBoYXNPd24ocmljaEl0ZW0sICdmb250RmFtaWx5JykgJiYgKG91dC5mb250RmFtaWx5ID0gcmljaEl0ZW0uZm9udEZhbWlseSk7XG4gIGhhc093bihyaWNoSXRlbSwgJ2FsaWduJykgJiYgKG91dC50ZXh0QWxpZ24gPSByaWNoSXRlbS5hbGlnbik7XG4gIGhhc093bihyaWNoSXRlbSwgJ3ZlcnRpY2FsQWxpZ24nKSAmJiAob3V0LnRleHRWZXJ0aWNhbEFsaWduID0gcmljaEl0ZW0udmVydGljYWxBbGlnbik7XG4gIGhhc093bihyaWNoSXRlbSwgJ2xpbmVIZWlnaHQnKSAmJiAob3V0LnRleHRMaW5lSGVpZ2h0ID0gcmljaEl0ZW0ubGluZUhlaWdodCk7XG4gIGhhc093bihyaWNoSXRlbSwgJ3dpZHRoJykgJiYgKG91dC50ZXh0V2lkdGggPSByaWNoSXRlbS53aWR0aCk7XG4gIGhhc093bihyaWNoSXRlbSwgJ2hlaWdodCcpICYmIChvdXQudGV4dEhlaWdodCA9IHJpY2hJdGVtLmhlaWdodCk7XG4gIGhhc093bihyaWNoSXRlbSwgJ2JhY2tncm91bmRDb2xvcicpICYmIChvdXQudGV4dEJhY2tncm91bmRDb2xvciA9IHJpY2hJdGVtLmJhY2tncm91bmRDb2xvcik7XG4gIGhhc093bihyaWNoSXRlbSwgJ3BhZGRpbmcnKSAmJiAob3V0LnRleHRQYWRkaW5nID0gcmljaEl0ZW0ucGFkZGluZyk7XG4gIGhhc093bihyaWNoSXRlbSwgJ2JvcmRlckNvbG9yJykgJiYgKG91dC50ZXh0Qm9yZGVyQ29sb3IgPSByaWNoSXRlbS5ib3JkZXJDb2xvcik7XG4gIGhhc093bihyaWNoSXRlbSwgJ2JvcmRlcldpZHRoJykgJiYgKG91dC50ZXh0Qm9yZGVyV2lkdGggPSByaWNoSXRlbS5ib3JkZXJXaWR0aCk7XG4gIGhhc093bihyaWNoSXRlbSwgJ2JvcmRlclJhZGl1cycpICYmIChvdXQudGV4dEJvcmRlclJhZGl1cyA9IHJpY2hJdGVtLmJvcmRlclJhZGl1cyk7XG4gIGhhc093bihyaWNoSXRlbSwgJ3NoYWRvd0NvbG9yJykgJiYgKG91dC50ZXh0Qm94U2hhZG93Q29sb3IgPSByaWNoSXRlbS5zaGFkb3dDb2xvcik7XG4gIGhhc093bihyaWNoSXRlbSwgJ3NoYWRvd0JsdXInKSAmJiAob3V0LnRleHRCb3hTaGFkb3dCbHVyID0gcmljaEl0ZW0uc2hhZG93Qmx1cik7XG4gIGhhc093bihyaWNoSXRlbSwgJ3NoYWRvd09mZnNldFgnKSAmJiAob3V0LnRleHRCb3hTaGFkb3dPZmZzZXRYID0gcmljaEl0ZW0uc2hhZG93T2Zmc2V0WCk7XG4gIGhhc093bihyaWNoSXRlbSwgJ3NoYWRvd09mZnNldFknKSAmJiAob3V0LnRleHRCb3hTaGFkb3dPZmZzZXRZID0gcmljaEl0ZW0uc2hhZG93T2Zmc2V0WSk7XG4gIGhhc093bihyaWNoSXRlbSwgJ3RleHRTaGFkb3dDb2xvcicpICYmIChvdXQudGV4dFNoYWRvd0NvbG9yID0gcmljaEl0ZW0udGV4dFNoYWRvd0NvbG9yKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAndGV4dFNoYWRvd0JsdXInKSAmJiAob3V0LnRleHRTaGFkb3dCbHVyID0gcmljaEl0ZW0udGV4dFNoYWRvd0JsdXIpO1xuICBoYXNPd24ocmljaEl0ZW0sICd0ZXh0U2hhZG93T2Zmc2V0WCcpICYmIChvdXQudGV4dFNoYWRvd09mZnNldFggPSByaWNoSXRlbS50ZXh0U2hhZG93T2Zmc2V0WCk7XG4gIGhhc093bihyaWNoSXRlbSwgJ3RleHRTaGFkb3dPZmZzZXRZJykgJiYgKG91dC50ZXh0U2hhZG93T2Zmc2V0WSA9IHJpY2hJdGVtLnRleHRTaGFkb3dPZmZzZXRZKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhcm5EZXByZWNhdGVkKGRlcHJlY2F0ZWQsIGluc3RlYWRBcHByb2FjaCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBrZXkgPSBkZXByZWNhdGVkICsgJ15fXicgKyBpbnN0ZWFkQXBwcm9hY2g7XG5cbiAgICBpZiAoIWRlcHJlY2F0ZWRMb2dzW2tleV0pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltFQ2hhcnRzXSBERVBSRUNBVEVEOiBcXFwiXCIgKyBkZXByZWNhdGVkICsgXCJcXFwiIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFwiICsgaW5zdGVhZEFwcHJvYWNoKTtcbiAgICAgIGRlcHJlY2F0ZWRMb2dzW2tleV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsJztcbmltcG9ydCAqIGFzIHpyQ29sb3IgZnJvbSAnenJlbmRlci9saWIvdG9vbC9jb2xvcic7XG5pbXBvcnQgeyBsaW5lYXJNYXAgfSBmcm9tICcuLi91dGlsL251bWJlcic7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIGlzT2JqZWN0ID0genJVdGlsLmlzT2JqZWN0O1xudmFyIENBVEVHT1JZX0RFRkFVTFRfVklTVUFMX0lOREVYID0gLTE7XG5cbnZhciBWaXN1YWxNYXBwaW5nID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmlzdWFsTWFwcGluZyhvcHRpb24pIHtcbiAgICB2YXIgbWFwcGluZ01ldGhvZCA9IG9wdGlvbi5tYXBwaW5nTWV0aG9kO1xuICAgIHZhciB2aXN1YWxUeXBlID0gb3B0aW9uLnR5cGU7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbiA9IHpyVXRpbC5jbG9uZShvcHRpb24pO1xuICAgIHRoaXMudHlwZSA9IHZpc3VhbFR5cGU7XG4gICAgdGhpcy5tYXBwaW5nTWV0aG9kID0gbWFwcGluZ01ldGhvZDtcbiAgICB0aGlzLl9ub3JtYWxpemVEYXRhID0gbm9ybWFsaXplcnNbbWFwcGluZ01ldGhvZF07XG4gICAgdmFyIHZpc3VhbEhhbmRsZXIgPSBWaXN1YWxNYXBwaW5nLnZpc3VhbEhhbmRsZXJzW3Zpc3VhbFR5cGVdO1xuICAgIHRoaXMuYXBwbHlWaXN1YWwgPSB2aXN1YWxIYW5kbGVyLmFwcGx5VmlzdWFsO1xuICAgIHRoaXMuZ2V0Q29sb3JNYXBwZXIgPSB2aXN1YWxIYW5kbGVyLmdldENvbG9yTWFwcGVyO1xuICAgIHRoaXMuX25vcm1hbGl6ZWRUb1Zpc3VhbCA9IHZpc3VhbEhhbmRsZXIuX25vcm1hbGl6ZWRUb1Zpc3VhbFttYXBwaW5nTWV0aG9kXTtcblxuICAgIGlmIChtYXBwaW5nTWV0aG9kID09PSAncGllY2V3aXNlJykge1xuICAgICAgbm9ybWFsaXplVmlzdWFsUmFuZ2UodGhpc09wdGlvbik7XG4gICAgICBwcmVwcm9jZXNzRm9yUGllY2V3aXNlKHRoaXNPcHRpb24pO1xuICAgIH0gZWxzZSBpZiAobWFwcGluZ01ldGhvZCA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgdGhpc09wdGlvbi5jYXRlZ29yaWVzID8gcHJlcHJvY2Vzc0ZvclNwZWNpZmllZENhdGVnb3J5KHRoaXNPcHRpb24pIC8vIGNhdGVnb3JpZXMgaXMgb3JkaW5hbCB3aGVuIHRoaXNPcHRpb24uY2F0ZWdvcmllcyBub3Qgc3BlY2lmaWVkLFxuICAgICAgLy8gd2hpY2ggbmVlZCBubyBtb3JlIHByZXByb2Nlc3MgZXhjZXB0IG5vcm1hbGl6ZSB2aXN1YWwuXG4gICAgICA6IG5vcm1hbGl6ZVZpc3VhbFJhbmdlKHRoaXNPcHRpb24sIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYXBwaW5nTWV0aG9kID09PSAnbGluZWFyJyBvciAnZml4ZWQnXG4gICAgICB6clV0aWwuYXNzZXJ0KG1hcHBpbmdNZXRob2QgIT09ICdsaW5lYXInIHx8IHRoaXNPcHRpb24uZGF0YUV4dGVudCk7XG4gICAgICBub3JtYWxpemVWaXN1YWxSYW5nZSh0aGlzT3B0aW9uKTtcbiAgICB9XG4gIH1cblxuICBWaXN1YWxNYXBwaW5nLnByb3RvdHlwZS5tYXBWYWx1ZVRvVmlzdWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWQgPSB0aGlzLl9ub3JtYWxpemVEYXRhKHZhbHVlKTtcblxuICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVkVG9WaXN1YWwobm9ybWFsaXplZCwgdmFsdWUpO1xuICB9O1xuXG4gIFZpc3VhbE1hcHBpbmcucHJvdG90eXBlLmdldE5vcm1hbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHpyVXRpbC5iaW5kKHRoaXMuX25vcm1hbGl6ZURhdGEsIHRoaXMpO1xuICB9O1xuICAvKipcbiAgICogTGlzdCBhdmFpbGFibGUgdmlzdWFsIHR5cGVzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cblxuXG4gIFZpc3VhbE1hcHBpbmcubGlzdFZpc3VhbFR5cGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB6clV0aWwua2V5cyhWaXN1YWxNYXBwaW5nLnZpc3VhbEhhbmRsZXJzKTtcbiAgfTsgLy8gLyoqXG4gIC8vICAqIEBwdWJsaWNcbiAgLy8gICovXG4gIC8vIHN0YXRpYyBhZGRWaXN1YWxIYW5kbGVyKG5hbWUsIGhhbmRsZXIpIHtcbiAgLy8gICAgIHZpc3VhbEhhbmRsZXJzW25hbWVdID0gaGFuZGxlcjtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqL1xuXG5cbiAgVmlzdWFsTWFwcGluZy5pc1ZhbGlkVHlwZSA9IGZ1bmN0aW9uICh2aXN1YWxUeXBlKSB7XG4gICAgcmV0dXJuIFZpc3VhbE1hcHBpbmcudmlzdWFsSGFuZGxlcnMuaGFzT3duUHJvcGVydHkodmlzdWFsVHlwZSk7XG4gIH07XG4gIC8qKlxuICAgKiBDb252aW5lbnQgbWV0aG9kLlxuICAgKiBWaXN1YWwgY2FuIGJlIE9iamVjdCBvciBBcnJheSBvciBwcmltYXJ5IHR5cGUuXG4gICAqL1xuXG5cbiAgVmlzdWFsTWFwcGluZy5lYWNoVmlzdWFsID0gZnVuY3Rpb24gKHZpc3VhbCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBpZiAoenJVdGlsLmlzT2JqZWN0KHZpc3VhbCkpIHtcbiAgICAgIHpyVXRpbC5lYWNoKHZpc3VhbCwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHZpc3VhbCk7XG4gICAgfVxuICB9O1xuXG4gIFZpc3VhbE1hcHBpbmcubWFwVmlzdWFsID0gZnVuY3Rpb24gKHZpc3VhbCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB2YXIgaXNQcmltYXJ5O1xuICAgIHZhciBuZXdWaXN1YWwgPSB6clV0aWwuaXNBcnJheSh2aXN1YWwpID8gW10gOiB6clV0aWwuaXNPYmplY3QodmlzdWFsKSA/IHt9IDogKGlzUHJpbWFyeSA9IHRydWUsIG51bGwpO1xuICAgIFZpc3VhbE1hcHBpbmcuZWFjaFZpc3VhbCh2aXN1YWwsIGZ1bmN0aW9uICh2LCBrZXkpIHtcbiAgICAgIHZhciBuZXdWYWwgPSBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHYsIGtleSk7XG4gICAgICBpc1ByaW1hcnkgPyBuZXdWaXN1YWwgPSBuZXdWYWwgOiBuZXdWaXN1YWxba2V5XSA9IG5ld1ZhbDtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3VmlzdWFsO1xuICB9O1xuICAvKipcbiAgICogUmV0cmlldmUgdmlzdWFsIHByb3BlcnRpZXMgZnJvbSBnaXZlbiBvYmplY3QuXG4gICAqL1xuXG5cbiAgVmlzdWFsTWFwcGluZy5yZXRyaWV2ZVZpc3VhbHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIHZhciBoYXNWaXN1YWw7XG4gICAgb2JqICYmIGVhY2goVmlzdWFsTWFwcGluZy52aXN1YWxIYW5kbGVycywgZnVuY3Rpb24gKGgsIHZpc3VhbFR5cGUpIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkodmlzdWFsVHlwZSkpIHtcbiAgICAgICAgcmV0W3Zpc3VhbFR5cGVdID0gb2JqW3Zpc3VhbFR5cGVdO1xuICAgICAgICBoYXNWaXN1YWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoYXNWaXN1YWwgPyByZXQgOiBudWxsO1xuICB9O1xuICAvKipcbiAgICogR2l2ZSBvcmRlciB0byB2aXN1YWwgdHlwZXMsIGNvbnNpZGVyaW5nIGNvbG9yU2F0dXJhdGlvbiwgY29sb3JBbHBoYSBkZXBlbmRzIG9uIGNvbG9yLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7KE9iamVjdHxBcnJheSl9IHZpc3VhbFR5cGVzIElmIE9iamVjdCwgbGlrZToge2NvbG9yOiAuLi4sIGNvbG9yU2F0dXJhdGlvbjogLi4ufVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJRiBBcnJheSwgbGlrZTogWydjb2xvcicsICdzeW1ib2wnLCAnY29sb3JTYXR1cmF0aW9uJ11cbiAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IFNvcnRlZCB2aXN1YWwgdHlwZXMuXG4gICAqL1xuXG5cbiAgVmlzdWFsTWFwcGluZy5wcmVwYXJlVmlzdWFsVHlwZXMgPSBmdW5jdGlvbiAodmlzdWFsVHlwZXMpIHtcbiAgICBpZiAoenJVdGlsLmlzQXJyYXkodmlzdWFsVHlwZXMpKSB7XG4gICAgICB2aXN1YWxUeXBlcyA9IHZpc3VhbFR5cGVzLnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2aXN1YWxUeXBlcykpIHtcbiAgICAgIHZhciB0eXBlc18xID0gW107XG4gICAgICBlYWNoKHZpc3VhbFR5cGVzLCBmdW5jdGlvbiAoaXRlbSwgdHlwZSkge1xuICAgICAgICB0eXBlc18xLnB1c2godHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHZpc3VhbFR5cGVzID0gdHlwZXNfMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZpc3VhbFR5cGVzLnNvcnQoZnVuY3Rpb24gKHR5cGUxLCB0eXBlMikge1xuICAgICAgLy8gY29sb3Igc2hvdWxkIGJlIGZyb250IG9mIGNvbG9yU2F0dXJhdGlvbiwgY29sb3JBbHBoYSwgLi4uXG4gICAgICAvLyBzeW1ib2wgYW5kIHN5bWJvbFNpemUgZG8gbm90IG1hdHRlci5cbiAgICAgIHJldHVybiB0eXBlMiA9PT0gJ2NvbG9yJyAmJiB0eXBlMSAhPT0gJ2NvbG9yJyAmJiB0eXBlMS5pbmRleE9mKCdjb2xvcicpID09PSAwID8gMSA6IC0xO1xuICAgIH0pO1xuICAgIHJldHVybiB2aXN1YWxUeXBlcztcbiAgfTtcbiAgLyoqXG4gICAqICdjb2xvcicsICdjb2xvclNhdHVyYXRpb24nLCAnY29sb3JBbHBoYScsIC4uLiBhcmUgZGVwZW5kcyBvbiAnY29sb3InLlxuICAgKiBPdGhlciB2aXN1YWxzIGFyZSBvbmx5IGRlcGVuZHMgb24gdGhlbXNlbGYuXG4gICAqL1xuXG5cbiAgVmlzdWFsTWFwcGluZy5kZXBlbmRzT24gPSBmdW5jdGlvbiAodmlzdWFsVHlwZTEsIHZpc3VhbFR5cGUyKSB7XG4gICAgcmV0dXJuIHZpc3VhbFR5cGUyID09PSAnY29sb3InID8gISEodmlzdWFsVHlwZTEgJiYgdmlzdWFsVHlwZTEuaW5kZXhPZih2aXN1YWxUeXBlMikgPT09IDApIDogdmlzdWFsVHlwZTEgPT09IHZpc3VhbFR5cGUyO1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBwaWVjZUxpc3QgW3t2YWx1ZTogLi4uLCBpbnRlcnZhbDogW21pbiwgbWF4XX0sIC4uLl1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgQWx3YXlzIGZyb20gc21hbGwgdG8gYmlnLlxuICAgKiBAcGFyYW0gZmluZENsb3Nlc3RXaGVuT3V0c2lkZSBEZWZhdWx0IHRvIGJlIGZhbHNlXG4gICAqIEByZXR1cm4gaW5kZXhcbiAgICovXG5cblxuICBWaXN1YWxNYXBwaW5nLmZpbmRQaWVjZUluZGV4ID0gZnVuY3Rpb24gKHZhbHVlLCBwaWVjZUxpc3QsIGZpbmRDbG9zZXN0V2hlbk91dHNpZGUpIHtcbiAgICB2YXIgcG9zc2libGVJO1xuICAgIHZhciBhYnMgPSBJbmZpbml0eTsgLy8gdmFsdWUgaGFzIHRoZSBoaWdoZXIgcHJpb3JpdHkuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGllY2VMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcGllY2VWYWx1ZSA9IHBpZWNlTGlzdFtpXS52YWx1ZTtcblxuICAgICAgaWYgKHBpZWNlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBpZiAocGllY2VWYWx1ZSA9PT0gdmFsdWUgLy8gRklYTUVcbiAgICAgICAgLy8gSXQgaXMgc3VwcG9zZWQgdG8gY29tcGFyZSB2YWx1ZSBhY2NvcmRpbmcgdG8gdmFsdWUgdHlwZSBvZiBkaW1lbnNpb24sXG4gICAgICAgIC8vIGJ1dCBjdXJyZW50bHkgdmFsdWUgdHlwZSBjYW4gZXhhY3RseSBiZSBzdHJpbmcgb3IgbnVtYmVyLlxuICAgICAgICAvLyBDb21wcm9taXNlIGZvciBudW1lcmljLWxpa2Ugc3RyaW5nIChsaWtlICcxMicpLCBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGluIHRoZSBjYXNlIHRoYXQgdmlzdWFsTWFwLmNhdGVnb3JpZXMgaXMgWycyMicsICczMyddLlxuICAgICAgICB8fCB0eXBlb2YgcGllY2VWYWx1ZSA9PT0gJ3N0cmluZycgJiYgcGllY2VWYWx1ZSA9PT0gdmFsdWUgKyAnJykge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluZENsb3Nlc3RXaGVuT3V0c2lkZSAmJiB1cGRhdGVQb3NzaWJsZShwaWVjZVZhbHVlLCBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGllY2VMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcGllY2UgPSBwaWVjZUxpc3RbaV07XG4gICAgICB2YXIgaW50ZXJ2YWwgPSBwaWVjZS5pbnRlcnZhbDtcbiAgICAgIHZhciBjbG9zZV8xID0gcGllY2UuY2xvc2U7XG5cbiAgICAgIGlmIChpbnRlcnZhbCkge1xuICAgICAgICBpZiAoaW50ZXJ2YWxbMF0gPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIGlmIChsaXR0bGVUaGFuKGNsb3NlXzFbMV0sIHZhbHVlLCBpbnRlcnZhbFsxXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbnRlcnZhbFsxXSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICBpZiAobGl0dGxlVGhhbihjbG9zZV8xWzBdLCBpbnRlcnZhbFswXSwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGl0dGxlVGhhbihjbG9zZV8xWzBdLCBpbnRlcnZhbFswXSwgdmFsdWUpICYmIGxpdHRsZVRoYW4oY2xvc2VfMVsxXSwgdmFsdWUsIGludGVydmFsWzFdKSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluZENsb3Nlc3RXaGVuT3V0c2lkZSAmJiB1cGRhdGVQb3NzaWJsZShpbnRlcnZhbFswXSwgaSk7XG4gICAgICAgIGZpbmRDbG9zZXN0V2hlbk91dHNpZGUgJiYgdXBkYXRlUG9zc2libGUoaW50ZXJ2YWxbMV0sIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmaW5kQ2xvc2VzdFdoZW5PdXRzaWRlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IEluZmluaXR5ID8gcGllY2VMaXN0Lmxlbmd0aCAtIDEgOiB2YWx1ZSA9PT0gLUluZmluaXR5ID8gMCA6IHBvc3NpYmxlSTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQb3NzaWJsZSh2YWwsIGluZGV4KSB7XG4gICAgICB2YXIgbmV3QWJzID0gTWF0aC5hYnModmFsIC0gdmFsdWUpO1xuXG4gICAgICBpZiAobmV3QWJzIDwgYWJzKSB7XG4gICAgICAgIGFicyA9IG5ld0FicztcbiAgICAgICAgcG9zc2libGVJID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFZpc3VhbE1hcHBpbmcudmlzdWFsSGFuZGxlcnMgPSB7XG4gICAgY29sb3I6IHtcbiAgICAgIGFwcGx5VmlzdWFsOiBtYWtlQXBwbHlWaXN1YWwoJ2NvbG9yJyksXG4gICAgICBnZXRDb2xvck1hcHBlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgICAgICByZXR1cm4genJVdGlsLmJpbmQodGhpc09wdGlvbi5tYXBwaW5nTWV0aG9kID09PSAnY2F0ZWdvcnknID8gZnVuY3Rpb24gKHZhbHVlLCBpc05vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAhaXNOb3JtYWxpemVkICYmICh2YWx1ZSA9IHRoaXMuX25vcm1hbGl6ZURhdGEodmFsdWUpKTtcbiAgICAgICAgICByZXR1cm4gZG9NYXBDYXRlZ29yeS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uICh2YWx1ZSwgaXNOb3JtYWxpemVkLCBvdXQpIHtcbiAgICAgICAgICAvLyBJZiBvdXRwdXQgcmdiIGFycmF5XG4gICAgICAgICAgLy8gd2hpY2ggd2lsbCBiZSBtdWNoIGZhc3RlciBhbmQgdXNlZnVsIGluIHBpeGVsIG1hbmlwdWxhdGlvblxuICAgICAgICAgIHZhciByZXR1cm5SR0JBcnJheSA9ICEhb3V0O1xuICAgICAgICAgICFpc05vcm1hbGl6ZWQgJiYgKHZhbHVlID0gdGhpcy5fbm9ybWFsaXplRGF0YSh2YWx1ZSkpO1xuICAgICAgICAgIG91dCA9IHpyQ29sb3IuZmFzdExlcnAodmFsdWUsIHRoaXNPcHRpb24ucGFyc2VkVmlzdWFsLCBvdXQpO1xuICAgICAgICAgIHJldHVybiByZXR1cm5SR0JBcnJheSA/IG91dCA6IHpyQ29sb3Iuc3RyaW5naWZ5KG91dCwgJ3JnYmEnKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LFxuICAgICAgX25vcm1hbGl6ZWRUb1Zpc3VhbDoge1xuICAgICAgICBsaW5lYXI6IGZ1bmN0aW9uIChub3JtYWxpemVkKSB7XG4gICAgICAgICAgcmV0dXJuIHpyQ29sb3Iuc3RyaW5naWZ5KHpyQ29sb3IuZmFzdExlcnAobm9ybWFsaXplZCwgdGhpcy5vcHRpb24ucGFyc2VkVmlzdWFsKSwgJ3JnYmEnKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2F0ZWdvcnk6IGRvTWFwQ2F0ZWdvcnksXG4gICAgICAgIHBpZWNld2lzZTogZnVuY3Rpb24gKG5vcm1hbGl6ZWQsIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGdldFNwZWNpZmllZFZpc3VhbC5jYWxsKHRoaXMsIHZhbHVlKTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0genJDb2xvci5zdHJpbmdpZnkoenJDb2xvci5mYXN0TGVycChub3JtYWxpemVkLCB0aGlzLm9wdGlvbi5wYXJzZWRWaXN1YWwpLCAncmdiYScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGZpeGVkOiBkb01hcEZpeGVkXG4gICAgICB9XG4gICAgfSxcbiAgICBjb2xvckh1ZTogbWFrZVBhcnRpYWxDb2xvclZpc3VhbEhhbmRsZXIoZnVuY3Rpb24gKGNvbG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHpyQ29sb3IubW9kaWZ5SFNMKGNvbG9yLCB2YWx1ZSk7XG4gICAgfSksXG4gICAgY29sb3JTYXR1cmF0aW9uOiBtYWtlUGFydGlhbENvbG9yVmlzdWFsSGFuZGxlcihmdW5jdGlvbiAoY29sb3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4genJDb2xvci5tb2RpZnlIU0woY29sb3IsIG51bGwsIHZhbHVlKTtcbiAgICB9KSxcbiAgICBjb2xvckxpZ2h0bmVzczogbWFrZVBhcnRpYWxDb2xvclZpc3VhbEhhbmRsZXIoZnVuY3Rpb24gKGNvbG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHpyQ29sb3IubW9kaWZ5SFNMKGNvbG9yLCBudWxsLCBudWxsLCB2YWx1ZSk7XG4gICAgfSksXG4gICAgY29sb3JBbHBoYTogbWFrZVBhcnRpYWxDb2xvclZpc3VhbEhhbmRsZXIoZnVuY3Rpb24gKGNvbG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHpyQ29sb3IubW9kaWZ5QWxwaGEoY29sb3IsIHZhbHVlKTtcbiAgICB9KSxcbiAgICBkZWNhbDoge1xuICAgICAgYXBwbHlWaXN1YWw6IG1ha2VBcHBseVZpc3VhbCgnZGVjYWwnKSxcbiAgICAgIF9ub3JtYWxpemVkVG9WaXN1YWw6IHtcbiAgICAgICAgbGluZWFyOiBudWxsLFxuICAgICAgICBjYXRlZ29yeTogZG9NYXBDYXRlZ29yeSxcbiAgICAgICAgcGllY2V3aXNlOiBudWxsLFxuICAgICAgICBmaXhlZDogbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgb3BhY2l0eToge1xuICAgICAgYXBwbHlWaXN1YWw6IG1ha2VBcHBseVZpc3VhbCgnb3BhY2l0eScpLFxuICAgICAgX25vcm1hbGl6ZWRUb1Zpc3VhbDogY3JlYXRlTm9ybWFsaXplZFRvTnVtZXJpY1Zpc3VhbChbMCwgMV0pXG4gICAgfSxcbiAgICBsaWZ0Wjoge1xuICAgICAgYXBwbHlWaXN1YWw6IG1ha2VBcHBseVZpc3VhbCgnbGlmdFonKSxcbiAgICAgIF9ub3JtYWxpemVkVG9WaXN1YWw6IHtcbiAgICAgICAgbGluZWFyOiBkb01hcEZpeGVkLFxuICAgICAgICBjYXRlZ29yeTogZG9NYXBGaXhlZCxcbiAgICAgICAgcGllY2V3aXNlOiBkb01hcEZpeGVkLFxuICAgICAgICBmaXhlZDogZG9NYXBGaXhlZFxuICAgICAgfVxuICAgIH0sXG4gICAgc3ltYm9sOiB7XG4gICAgICBhcHBseVZpc3VhbDogZnVuY3Rpb24gKHZhbHVlLCBnZXR0ZXIsIHNldHRlcikge1xuICAgICAgICB2YXIgc3ltYm9sQ2ZnID0gdGhpcy5tYXBWYWx1ZVRvVmlzdWFsKHZhbHVlKTtcbiAgICAgICAgc2V0dGVyKCdzeW1ib2wnLCBzeW1ib2xDZmcpO1xuICAgICAgfSxcbiAgICAgIF9ub3JtYWxpemVkVG9WaXN1YWw6IHtcbiAgICAgICAgbGluZWFyOiBkb01hcFRvQXJyYXksXG4gICAgICAgIGNhdGVnb3J5OiBkb01hcENhdGVnb3J5LFxuICAgICAgICBwaWVjZXdpc2U6IGZ1bmN0aW9uIChub3JtYWxpemVkLCB2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBnZXRTcGVjaWZpZWRWaXN1YWwuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGRvTWFwVG9BcnJheS5jYWxsKHRoaXMsIG5vcm1hbGl6ZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGZpeGVkOiBkb01hcEZpeGVkXG4gICAgICB9XG4gICAgfSxcbiAgICBzeW1ib2xTaXplOiB7XG4gICAgICBhcHBseVZpc3VhbDogbWFrZUFwcGx5VmlzdWFsKCdzeW1ib2xTaXplJyksXG4gICAgICBfbm9ybWFsaXplZFRvVmlzdWFsOiBjcmVhdGVOb3JtYWxpemVkVG9OdW1lcmljVmlzdWFsKFswLCAxXSlcbiAgICB9XG4gIH07XG4gIHJldHVybiBWaXN1YWxNYXBwaW5nO1xufSgpO1xuXG5mdW5jdGlvbiBwcmVwcm9jZXNzRm9yUGllY2V3aXNlKHRoaXNPcHRpb24pIHtcbiAgdmFyIHBpZWNlTGlzdCA9IHRoaXNPcHRpb24ucGllY2VMaXN0O1xuICB0aGlzT3B0aW9uLmhhc1NwZWNpYWxWaXN1YWwgPSBmYWxzZTtcbiAgenJVdGlsLmVhY2gocGllY2VMaXN0LCBmdW5jdGlvbiAocGllY2UsIGluZGV4KSB7XG4gICAgcGllY2Uub3JpZ2luSW5kZXggPSBpbmRleDsgLy8gcGllY2UudmlzdWFsIGlzIFwicmVzdWx0IHZpc3VhbCB2YWx1ZVwiIGJ1dCBub3RcbiAgICAvLyBhIHZpc3VhbCByYW5nZSwgc28gaXQgZG9lcyBub3QgbmVlZCB0byBiZSBub3JtYWxpemVkLlxuXG4gICAgaWYgKHBpZWNlLnZpc3VhbCAhPSBudWxsKSB7XG4gICAgICB0aGlzT3B0aW9uLmhhc1NwZWNpYWxWaXN1YWwgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByZXByb2Nlc3NGb3JTcGVjaWZpZWRDYXRlZ29yeSh0aGlzT3B0aW9uKSB7XG4gIC8vIEhhc2ggY2F0ZWdvcmllcy5cbiAgdmFyIGNhdGVnb3JpZXMgPSB0aGlzT3B0aW9uLmNhdGVnb3JpZXM7XG4gIHZhciBjYXRlZ29yeU1hcCA9IHRoaXNPcHRpb24uY2F0ZWdvcnlNYXAgPSB7fTtcbiAgdmFyIHZpc3VhbCA9IHRoaXNPcHRpb24udmlzdWFsO1xuICBlYWNoKGNhdGVnb3JpZXMsIGZ1bmN0aW9uIChjYXRlLCBpbmRleCkge1xuICAgIGNhdGVnb3J5TWFwW2NhdGVdID0gaW5kZXg7XG4gIH0pOyAvLyBQcm9jZXNzIHZpc3VhbCBtYXAgaW5wdXQuXG5cbiAgaWYgKCF6clV0aWwuaXNBcnJheSh2aXN1YWwpKSB7XG4gICAgdmFyIHZpc3VhbEFycl8xID0gW107XG5cbiAgICBpZiAoenJVdGlsLmlzT2JqZWN0KHZpc3VhbCkpIHtcbiAgICAgIGVhY2godmlzdWFsLCBmdW5jdGlvbiAodiwgY2F0ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBjYXRlZ29yeU1hcFtjYXRlXTtcbiAgICAgICAgdmlzdWFsQXJyXzFbaW5kZXggIT0gbnVsbCA/IGluZGV4IDogQ0FURUdPUllfREVGQVVMVF9WSVNVQUxfSU5ERVhdID0gdjtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJcyBwcmltYXJ5IHR5cGUsIHJlcHJlc2VudHMgZGVmYXVsdCB2aXN1YWwuXG4gICAgICB2aXN1YWxBcnJfMVtDQVRFR09SWV9ERUZBVUxUX1ZJU1VBTF9JTkRFWF0gPSB2aXN1YWw7XG4gICAgfVxuXG4gICAgdmlzdWFsID0gc2V0VmlzdWFsVG9PcHRpb24odGhpc09wdGlvbiwgdmlzdWFsQXJyXzEpO1xuICB9IC8vIFJlbW92ZSBjYXRlZ29yaWVzIHRoYXQgaGFzIG5vIHZpc3VhbCxcbiAgLy8gdGhlbiB3ZSBjYW4gbWFwcGluZyB0aGVtIHRvIENBVEVHT1JZX0RFRkFVTFRfVklTVUFMX0lOREVYLlxuXG5cbiAgZm9yICh2YXIgaSA9IGNhdGVnb3JpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAodmlzdWFsW2ldID09IG51bGwpIHtcbiAgICAgIGRlbGV0ZSBjYXRlZ29yeU1hcFtjYXRlZ29yaWVzW2ldXTtcbiAgICAgIGNhdGVnb3JpZXMucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZpc3VhbFJhbmdlKHRoaXNPcHRpb24sIGlzQ2F0ZWdvcnkpIHtcbiAgdmFyIHZpc3VhbCA9IHRoaXNPcHRpb24udmlzdWFsO1xuICB2YXIgdmlzdWFsQXJyID0gW107XG5cbiAgaWYgKHpyVXRpbC5pc09iamVjdCh2aXN1YWwpKSB7XG4gICAgZWFjaCh2aXN1YWwsIGZ1bmN0aW9uICh2KSB7XG4gICAgICB2aXN1YWxBcnIucHVzaCh2KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh2aXN1YWwgIT0gbnVsbCkge1xuICAgIHZpc3VhbEFyci5wdXNoKHZpc3VhbCk7XG4gIH1cblxuICB2YXIgZG9Ob3ROZWVkUGFpciA9IHtcbiAgICBjb2xvcjogMSxcbiAgICBzeW1ib2w6IDFcbiAgfTtcblxuICBpZiAoIWlzQ2F0ZWdvcnkgJiYgdmlzdWFsQXJyLmxlbmd0aCA9PT0gMSAmJiAhZG9Ob3ROZWVkUGFpci5oYXNPd25Qcm9wZXJ0eSh0aGlzT3B0aW9uLnR5cGUpKSB7XG4gICAgLy8gRG8gbm90IGNhcmUgdmlzdWFsQXJyLmxlbmd0aCA9PT0gMCwgd2hpY2ggaXMgaWxsZWdhbC5cbiAgICB2aXN1YWxBcnJbMV0gPSB2aXN1YWxBcnJbMF07XG4gIH1cblxuICBzZXRWaXN1YWxUb09wdGlvbih0aGlzT3B0aW9uLCB2aXN1YWxBcnIpO1xufVxuXG5mdW5jdGlvbiBtYWtlUGFydGlhbENvbG9yVmlzdWFsSGFuZGxlcihhcHBseVZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgYXBwbHlWaXN1YWw6IGZ1bmN0aW9uICh2YWx1ZSwgZ2V0dGVyLCBzZXR0ZXIpIHtcbiAgICAgIC8vIE9ubHkgdXNlZCBpbiBIU0xcbiAgICAgIHZhciBjb2xvckNoYW5uZWwgPSB0aGlzLm1hcFZhbHVlVG9WaXN1YWwodmFsdWUpOyAvLyBNdXN0IG5vdCBiZSBhcnJheSB2YWx1ZVxuXG4gICAgICBzZXR0ZXIoJ2NvbG9yJywgYXBwbHlWYWx1ZShnZXR0ZXIoJ2NvbG9yJyksIGNvbG9yQ2hhbm5lbCkpO1xuICAgIH0sXG4gICAgX25vcm1hbGl6ZWRUb1Zpc3VhbDogY3JlYXRlTm9ybWFsaXplZFRvTnVtZXJpY1Zpc3VhbChbMCwgMV0pXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRvTWFwVG9BcnJheShub3JtYWxpemVkKSB7XG4gIHZhciB2aXN1YWwgPSB0aGlzLm9wdGlvbi52aXN1YWw7XG4gIHJldHVybiB2aXN1YWxbTWF0aC5yb3VuZChsaW5lYXJNYXAobm9ybWFsaXplZCwgWzAsIDFdLCBbMCwgdmlzdWFsLmxlbmd0aCAtIDFdLCB0cnVlKSldIHx8IHt9OyAvLyBUT0RPIHt9P1xufVxuXG5mdW5jdGlvbiBtYWtlQXBwbHlWaXN1YWwodmlzdWFsVHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBnZXR0ZXIsIHNldHRlcikge1xuICAgIHNldHRlcih2aXN1YWxUeXBlLCB0aGlzLm1hcFZhbHVlVG9WaXN1YWwodmFsdWUpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZG9NYXBDYXRlZ29yeShub3JtYWxpemVkKSB7XG4gIHZhciB2aXN1YWwgPSB0aGlzLm9wdGlvbi52aXN1YWw7XG4gIHJldHVybiB2aXN1YWxbdGhpcy5vcHRpb24ubG9vcCAmJiBub3JtYWxpemVkICE9PSBDQVRFR09SWV9ERUZBVUxUX1ZJU1VBTF9JTkRFWCA/IG5vcm1hbGl6ZWQgJSB2aXN1YWwubGVuZ3RoIDogbm9ybWFsaXplZF07XG59XG5cbmZ1bmN0aW9uIGRvTWFwRml4ZWQoKSB7XG4gIC8vIHZpc3VhbCB3aWxsIGJlIGNvbnZlcnQgdG8gYXJyYXkuXG4gIHJldHVybiB0aGlzLm9wdGlvbi52aXN1YWxbMF07XG59XG4vKipcbiAqIENyZWF0ZSBtYXBwZWQgdG8gbnVtZXJpYyB2aXN1YWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZU5vcm1hbGl6ZWRUb051bWVyaWNWaXN1YWwoc291cmNlRXh0ZW50KSB7XG4gIHJldHVybiB7XG4gICAgbGluZWFyOiBmdW5jdGlvbiAobm9ybWFsaXplZCkge1xuICAgICAgcmV0dXJuIGxpbmVhck1hcChub3JtYWxpemVkLCBzb3VyY2VFeHRlbnQsIHRoaXMub3B0aW9uLnZpc3VhbCwgdHJ1ZSk7XG4gICAgfSxcbiAgICBjYXRlZ29yeTogZG9NYXBDYXRlZ29yeSxcbiAgICBwaWVjZXdpc2U6IGZ1bmN0aW9uIChub3JtYWxpemVkLCB2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGdldFNwZWNpZmllZFZpc3VhbC5jYWxsKHRoaXMsIHZhbHVlKTtcblxuICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IGxpbmVhck1hcChub3JtYWxpemVkLCBzb3VyY2VFeHRlbnQsIHRoaXMub3B0aW9uLnZpc3VhbCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBmaXhlZDogZG9NYXBGaXhlZFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTcGVjaWZpZWRWaXN1YWwodmFsdWUpIHtcbiAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgdmFyIHBpZWNlTGlzdCA9IHRoaXNPcHRpb24ucGllY2VMaXN0O1xuXG4gIGlmICh0aGlzT3B0aW9uLmhhc1NwZWNpYWxWaXN1YWwpIHtcbiAgICB2YXIgcGllY2VJbmRleCA9IFZpc3VhbE1hcHBpbmcuZmluZFBpZWNlSW5kZXgodmFsdWUsIHBpZWNlTGlzdCk7XG4gICAgdmFyIHBpZWNlID0gcGllY2VMaXN0W3BpZWNlSW5kZXhdO1xuXG4gICAgaWYgKHBpZWNlICYmIHBpZWNlLnZpc3VhbCkge1xuICAgICAgcmV0dXJuIHBpZWNlLnZpc3VhbFt0aGlzLnR5cGVdO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRWaXN1YWxUb09wdGlvbih0aGlzT3B0aW9uLCB2aXN1YWxBcnIpIHtcbiAgdGhpc09wdGlvbi52aXN1YWwgPSB2aXN1YWxBcnI7XG5cbiAgaWYgKHRoaXNPcHRpb24udHlwZSA9PT0gJ2NvbG9yJykge1xuICAgIHRoaXNPcHRpb24ucGFyc2VkVmlzdWFsID0genJVdGlsLm1hcCh2aXN1YWxBcnIsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4genJDb2xvci5wYXJzZShpdGVtKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2aXN1YWxBcnI7XG59XG4vKipcbiAqIE5vcm1hbGl6ZXJzIGJ5IG1hcHBpbmcgbWV0aG9kcy5cbiAqL1xuXG5cbnZhciBub3JtYWxpemVycyA9IHtcbiAgbGluZWFyOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gbGluZWFyTWFwKHZhbHVlLCB0aGlzLm9wdGlvbi5kYXRhRXh0ZW50LCBbMCwgMV0sIHRydWUpO1xuICB9LFxuICBwaWVjZXdpc2U6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBwaWVjZUxpc3QgPSB0aGlzLm9wdGlvbi5waWVjZUxpc3Q7XG4gICAgdmFyIHBpZWNlSW5kZXggPSBWaXN1YWxNYXBwaW5nLmZpbmRQaWVjZUluZGV4KHZhbHVlLCBwaWVjZUxpc3QsIHRydWUpO1xuXG4gICAgaWYgKHBpZWNlSW5kZXggIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGxpbmVhck1hcChwaWVjZUluZGV4LCBbMCwgcGllY2VMaXN0Lmxlbmd0aCAtIDFdLCBbMCwgMV0sIHRydWUpO1xuICAgIH1cbiAgfSxcbiAgY2F0ZWdvcnk6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMub3B0aW9uLmNhdGVnb3JpZXMgPyB0aGlzLm9wdGlvbi5jYXRlZ29yeU1hcFt2YWx1ZV0gOiB2YWx1ZTsgLy8gb3JkaW5hbCB2YWx1ZVxuXG4gICAgcmV0dXJuIGluZGV4ID09IG51bGwgPyBDQVRFR09SWV9ERUZBVUxUX1ZJU1VBTF9JTkRFWCA6IGluZGV4O1xuICB9LFxuICBmaXhlZDogenJVdGlsLm5vb3Bcbn07XG5cbmZ1bmN0aW9uIGxpdHRsZVRoYW4oY2xvc2UsIGEsIGIpIHtcbiAgcmV0dXJuIGNsb3NlID8gYSA8PSBiIDogYSA8IGI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpc3VhbE1hcHBpbmc7IiwiaW1wb3J0IEdyb3VwIGZyb20gJy4uL2dyYXBoaWMvR3JvdXAnO1xuaW1wb3J0IFpSSW1hZ2UgZnJvbSAnLi4vZ3JhcGhpYy9JbWFnZSc7XG5pbXBvcnQgQ2lyY2xlIGZyb20gJy4uL2dyYXBoaWMvc2hhcGUvQ2lyY2xlJztcbmltcG9ydCBSZWN0IGZyb20gJy4uL2dyYXBoaWMvc2hhcGUvUmVjdCc7XG5pbXBvcnQgRWxsaXBzZSBmcm9tICcuLi9ncmFwaGljL3NoYXBlL0VsbGlwc2UnO1xuaW1wb3J0IExpbmUgZnJvbSAnLi4vZ3JhcGhpYy9zaGFwZS9MaW5lJztcbmltcG9ydCBQYXRoIGZyb20gJy4uL2dyYXBoaWMvUGF0aCc7XG5pbXBvcnQgUG9seWdvbiBmcm9tICcuLi9ncmFwaGljL3NoYXBlL1BvbHlnb24nO1xuaW1wb3J0IFBvbHlsaW5lIGZyb20gJy4uL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUnO1xuaW1wb3J0ICogYXMgbWF0cml4IGZyb20gJy4uL2NvcmUvbWF0cml4JztcbmltcG9ydCB7IGNyZWF0ZUZyb21TdHJpbmcgfSBmcm9tICcuL3BhdGgnO1xuaW1wb3J0IHsgZXh0ZW5kLCBkZWZhdWx0cywgdHJpbSwgZWFjaCwgbWFwIH0gZnJvbSAnLi4vY29yZS91dGlsJztcbmltcG9ydCBMaW5lYXJHcmFkaWVudCBmcm9tICcuLi9ncmFwaGljL0xpbmVhckdyYWRpZW50JztcbmltcG9ydCBUU3BhbiBmcm9tICcuLi9ncmFwaGljL1RTcGFuJztcbmltcG9ydCB7IHBhcnNlWE1MIH0gZnJvbSAnLi9wYXJzZVhNTCc7XG52YXIgRElMSU1JVEVSX1JFRyA9IC9bXFxzLF0rLztcbnZhciBub2RlUGFyc2VycztcbnZhciBTVkdQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNWR1BhcnNlcigpIHtcbiAgICAgICAgdGhpcy5fZGVmcyA9IHt9O1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNEZWZpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNUZXh0ID0gZmFsc2U7XG4gICAgfVxuICAgIFNWR1BhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoeG1sLCBvcHQpIHtcbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgc3ZnID0gcGFyc2VYTUwoeG1sKTtcbiAgICAgICAgaWYgKCFzdmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBzdmcnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm9vdCA9IG5ldyBHcm91cCgpO1xuICAgICAgICB0aGlzLl9yb290ID0gcm9vdDtcbiAgICAgICAgdmFyIHZpZXdCb3ggPSBzdmcuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykgfHwgJyc7XG4gICAgICAgIHZhciB3aWR0aCA9IHBhcnNlRmxvYXQoKHN2Zy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgb3B0LndpZHRoKSk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBwYXJzZUZsb2F0KChzdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCBvcHQuaGVpZ2h0KSk7XG4gICAgICAgIGlzTmFOKHdpZHRoKSAmJiAod2lkdGggPSBudWxsKTtcbiAgICAgICAgaXNOYU4oaGVpZ2h0KSAmJiAoaGVpZ2h0ID0gbnVsbCk7XG4gICAgICAgIHBhcnNlQXR0cmlidXRlcyhzdmcsIHJvb3QsIG51bGwsIHRydWUpO1xuICAgICAgICB2YXIgY2hpbGQgPSBzdmcuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZU5vZGUoY2hpbGQsIHJvb3QpO1xuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmlld0JveFJlY3Q7XG4gICAgICAgIHZhciB2aWV3Qm94VHJhbnNmb3JtO1xuICAgICAgICBpZiAodmlld0JveCkge1xuICAgICAgICAgICAgdmFyIHZpZXdCb3hBcnIgPSB0cmltKHZpZXdCb3gpLnNwbGl0KERJTElNSVRFUl9SRUcpO1xuICAgICAgICAgICAgaWYgKHZpZXdCb3hBcnIubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICAgICAgICB2aWV3Qm94UmVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogcGFyc2VGbG9hdCgodmlld0JveEFyclswXSB8fCAwKSksXG4gICAgICAgICAgICAgICAgICAgIHk6IHBhcnNlRmxvYXQoKHZpZXdCb3hBcnJbMV0gfHwgMCkpLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcGFyc2VGbG9hdCh2aWV3Qm94QXJyWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUZsb2F0KHZpZXdCb3hBcnJbM10pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmlld0JveFJlY3QgJiYgd2lkdGggIT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmlld0JveFRyYW5zZm9ybSA9IG1ha2VWaWV3Qm94VHJhbnNmb3JtKHZpZXdCb3hSZWN0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGlmICghb3B0Lmlnbm9yZVZpZXdCb3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxSb290ID0gcm9vdDtcbiAgICAgICAgICAgICAgICByb290ID0gbmV3IEdyb3VwKCk7XG4gICAgICAgICAgICAgICAgcm9vdC5hZGQoZWxSb290KTtcbiAgICAgICAgICAgICAgICBlbFJvb3Quc2NhbGVYID0gZWxSb290LnNjYWxlWSA9IHZpZXdCb3hUcmFuc2Zvcm0uc2NhbGU7XG4gICAgICAgICAgICAgICAgZWxSb290LnggPSB2aWV3Qm94VHJhbnNmb3JtLng7XG4gICAgICAgICAgICAgICAgZWxSb290LnkgPSB2aWV3Qm94VHJhbnNmb3JtLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHQuaWdub3JlUm9vdENsaXAgJiYgd2lkdGggIT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcm9vdC5zZXRDbGlwUGF0aChuZXcgUmVjdCh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHsgeDogMCwgeTogMCwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIHZpZXdCb3hSZWN0OiB2aWV3Qm94UmVjdCxcbiAgICAgICAgICAgIHZpZXdCb3hUcmFuc2Zvcm06IHZpZXdCb3hUcmFuc2Zvcm1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFNWR1BhcnNlci5wcm90b3R5cGUuX3BhcnNlTm9kZSA9IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgICAgICB2YXIgbm9kZU5hbWUgPSB4bWxOb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ2RlZnMnKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RlZmluZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZU5hbWUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgdGhpcy5faXNUZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWw7XG4gICAgICAgIGlmICh0aGlzLl9pc0RlZmluZSkge1xuICAgICAgICAgICAgdmFyIHBhcnNlciA9IGRlZmluZVBhcnNlcnNbbm9kZU5hbWVdO1xuICAgICAgICAgICAgaWYgKHBhcnNlcikge1xuICAgICAgICAgICAgICAgIHZhciBkZWYgPSBwYXJzZXIuY2FsbCh0aGlzLCB4bWxOb2RlKTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVmc1tpZF0gPSBkZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhcnNlciA9IG5vZGVQYXJzZXJzW25vZGVOYW1lXTtcbiAgICAgICAgICAgIGlmIChwYXJzZXIpIHtcbiAgICAgICAgICAgICAgICBlbCA9IHBhcnNlci5jYWxsKHRoaXMsIHhtbE5vZGUsIHBhcmVudEdyb3VwKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRHcm91cC5hZGQoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0geG1sTm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTm9kZShjaGlsZCwgZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDMgJiYgdGhpcy5faXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlVGV4dChjaGlsZCwgZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ2RlZnMnKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RlZmluZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGVOYW1lID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzVGV4dCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTVkdQYXJzZXIucHJvdG90eXBlLl9wYXJzZVRleHQgPSBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICAgICAgaWYgKHhtbE5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdkeCcpIHx8IDA7XG4gICAgICAgICAgICB2YXIgZHkgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgnZHknKSB8fCAwO1xuICAgICAgICAgICAgdGhpcy5fdGV4dFggKz0gcGFyc2VGbG9hdChkeCk7XG4gICAgICAgICAgICB0aGlzLl90ZXh0WSArPSBwYXJzZUZsb2F0KGR5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dCA9IG5ldyBUU3Bhbih7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHRleHQ6IHhtbE5vZGUudGV4dENvbnRlbnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB4OiB0aGlzLl90ZXh0WCB8fCAwLFxuICAgICAgICAgICAgeTogdGhpcy5fdGV4dFkgfHwgMFxuICAgICAgICB9KTtcbiAgICAgICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCB0ZXh0KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIHRleHQsIHRoaXMuX2RlZnMpO1xuICAgICAgICB2YXIgdGV4dFN0eWxlID0gdGV4dC5zdHlsZTtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gdGV4dFN0eWxlLmZvbnRTaXplO1xuICAgICAgICBpZiAoZm9udFNpemUgJiYgZm9udFNpemUgPCA5KSB7XG4gICAgICAgICAgICB0ZXh0U3R5bGUuZm9udFNpemUgPSA5O1xuICAgICAgICAgICAgdGV4dC5zY2FsZVggKj0gZm9udFNpemUgLyA5O1xuICAgICAgICAgICAgdGV4dC5zY2FsZVkgKj0gZm9udFNpemUgLyA5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb250ID0gKHRleHRTdHlsZS5mb250U2l6ZSB8fCB0ZXh0U3R5bGUuZm9udEZhbWlseSkgJiYgW1xuICAgICAgICAgICAgdGV4dFN0eWxlLmZvbnRTdHlsZSxcbiAgICAgICAgICAgIHRleHRTdHlsZS5mb250V2VpZ2h0LFxuICAgICAgICAgICAgKHRleHRTdHlsZS5mb250U2l6ZSB8fCAxMikgKyAncHgnLFxuICAgICAgICAgICAgdGV4dFN0eWxlLmZvbnRGYW1pbHkgfHwgJ3NhbnMtc2VyaWYnXG4gICAgICAgIF0uam9pbignICcpO1xuICAgICAgICB0ZXh0U3R5bGUuZm9udCA9IGZvbnQ7XG4gICAgICAgIHZhciByZWN0ID0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgdGhpcy5fdGV4dFggKz0gcmVjdC53aWR0aDtcbiAgICAgICAgcGFyZW50R3JvdXAuYWRkKHRleHQpO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIFNWR1BhcnNlci5pbnRlcm5hbEZpZWxkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbm9kZVBhcnNlcnMgPSB7XG4gICAgICAgICAgICAnZyc6IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gICAgICAgICAgICAgICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBnKTtcbiAgICAgICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgZywgdGhpcy5fZGVmcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3JlY3QnOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBSZWN0KCk7XG4gICAgICAgICAgICAgICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCByZWN0KTtcbiAgICAgICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgcmVjdCwgdGhpcy5fZGVmcyk7XG4gICAgICAgICAgICAgICAgcmVjdC5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgICAgIHg6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3gnKSB8fCAnMCcpLFxuICAgICAgICAgICAgICAgICAgICB5OiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd5JykgfHwgJzAnKSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgJzAnKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAnMCcpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2NpcmNsZSc6IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlKCk7XG4gICAgICAgICAgICAgICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBjaXJjbGUpO1xuICAgICAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlcyh4bWxOb2RlLCBjaXJjbGUsIHRoaXMuX2RlZnMpO1xuICAgICAgICAgICAgICAgIGNpcmNsZS5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgICAgIGN4OiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdjeCcpIHx8ICcwJyksXG4gICAgICAgICAgICAgICAgICAgIGN5OiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdjeScpIHx8ICcwJyksXG4gICAgICAgICAgICAgICAgICAgIHI6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3InKSB8fCAnMCcpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbGluZSc6IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gbmV3IExpbmUoKTtcbiAgICAgICAgICAgICAgICBpbmhlcml0U3R5bGUocGFyZW50R3JvdXAsIGxpbmUpO1xuICAgICAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlcyh4bWxOb2RlLCBsaW5lLCB0aGlzLl9kZWZzKTtcbiAgICAgICAgICAgICAgICBsaW5lLnNldFNoYXBlKHtcbiAgICAgICAgICAgICAgICAgICAgeDE6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3gxJykgfHwgJzAnKSxcbiAgICAgICAgICAgICAgICAgICAgeTE6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3kxJykgfHwgJzAnKSxcbiAgICAgICAgICAgICAgICAgICAgeDI6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3gyJykgfHwgJzAnKSxcbiAgICAgICAgICAgICAgICAgICAgeTI6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3kyJykgfHwgJzAnKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdlbGxpcHNlJzogZnVuY3Rpb24gKHhtbE5vZGUsIHBhcmVudEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsbGlwc2UgPSBuZXcgRWxsaXBzZSgpO1xuICAgICAgICAgICAgICAgIGluaGVyaXRTdHlsZShwYXJlbnRHcm91cCwgZWxsaXBzZSk7XG4gICAgICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIGVsbGlwc2UsIHRoaXMuX2RlZnMpO1xuICAgICAgICAgICAgICAgIGVsbGlwc2Uuc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgICAgICBjeDogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgnY3gnKSB8fCAnMCcpLFxuICAgICAgICAgICAgICAgICAgICBjeTogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgnY3knKSB8fCAnMCcpLFxuICAgICAgICAgICAgICAgICAgICByeDogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgncngnKSB8fCAnMCcpLFxuICAgICAgICAgICAgICAgICAgICByeTogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgncnknKSB8fCAnMCcpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsbGlwc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3BvbHlnb24nOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzU3RyID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpO1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHNBcnI7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50c1N0cikge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNBcnIgPSBwYXJzZVBvaW50cyhwb2ludHNTdHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBQb2x5Z29uKHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzQXJyIHx8IFtdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbmhlcml0U3R5bGUocGFyZW50R3JvdXAsIHBvbHlnb24pO1xuICAgICAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlcyh4bWxOb2RlLCBwb2x5Z29uLCB0aGlzLl9kZWZzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9seWdvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncG9seWxpbmUnOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IG5ldyBQYXRoKCk7XG4gICAgICAgICAgICAgICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBwYXRoKTtcbiAgICAgICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgcGF0aCwgdGhpcy5fZGVmcyk7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50c1N0ciA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdwb2ludHMnKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzQXJyO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludHNTdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzQXJyID0gcGFyc2VQb2ludHMocG9pbnRzU3RyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHBvbHlsaW5lID0gbmV3IFBvbHlsaW5lKHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzQXJyIHx8IFtdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9seWxpbmU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ltYWdlJzogZnVuY3Rpb24gKHhtbE5vZGUsIHBhcmVudEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBaUkltYWdlKCk7XG4gICAgICAgICAgICAgICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBpbWcpO1xuICAgICAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlcyh4bWxOb2RlLCBpbWcsIHRoaXMuX2RlZnMpO1xuICAgICAgICAgICAgICAgIGltZy5zZXRTdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiB4bWxOb2RlLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpLFxuICAgICAgICAgICAgICAgICAgICB4OiAreG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3gnKSxcbiAgICAgICAgICAgICAgICAgICAgeTogK3htbE5vZGUuZ2V0QXR0cmlidXRlKCd5JyksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAreG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogK3htbE5vZGUuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbWc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3RleHQnOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd4JykgfHwgJzAnO1xuICAgICAgICAgICAgICAgIHZhciB5ID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3knKSB8fCAnMCc7XG4gICAgICAgICAgICAgICAgdmFyIGR4ID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ2R4JykgfHwgJzAnO1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdkeScpIHx8ICcwJztcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0WCA9IHBhcnNlRmxvYXQoeCkgKyBwYXJzZUZsb2F0KGR4KTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0WSA9IHBhcnNlRmxvYXQoeSkgKyBwYXJzZUZsb2F0KGR5KTtcbiAgICAgICAgICAgICAgICB2YXIgZyA9IG5ldyBHcm91cCgpO1xuICAgICAgICAgICAgICAgIGluaGVyaXRTdHlsZShwYXJlbnRHcm91cCwgZyk7XG4gICAgICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIGcsIHRoaXMuX2RlZnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd0c3Bhbic6IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0WCA9IHBhcnNlRmxvYXQoeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFkgPSBwYXJzZUZsb2F0KHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZHggPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgnZHgnKSB8fCAwO1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdkeScpIHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIGcgPSBuZXcgR3JvdXAoKTtcbiAgICAgICAgICAgICAgICBpbmhlcml0U3R5bGUocGFyZW50R3JvdXAsIGcpO1xuICAgICAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlcyh4bWxOb2RlLCBnLCB0aGlzLl9kZWZzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0WCArPSBkeDtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0WSArPSBkeTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncGF0aCc6IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBkID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ2QnKSB8fCAnJztcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IGNyZWF0ZUZyb21TdHJpbmcoZCk7XG4gICAgICAgICAgICAgICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBwYXRoKTtcbiAgICAgICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgcGF0aCwgdGhpcy5fZGVmcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICByZXR1cm4gU1ZHUGFyc2VyO1xufSgpKTtcbnZhciBkZWZpbmVQYXJzZXJzID0ge1xuICAgICdsaW5lYXJncmFkaWVudCc6IGZ1bmN0aW9uICh4bWxOb2RlKSB7XG4gICAgICAgIHZhciB4MSA9IHBhcnNlSW50KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd4MScpIHx8ICcwJywgMTApO1xuICAgICAgICB2YXIgeTEgPSBwYXJzZUludCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgneTEnKSB8fCAnMCcsIDEwKTtcbiAgICAgICAgdmFyIHgyID0gcGFyc2VJbnQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3gyJykgfHwgJzEwJywgMTApO1xuICAgICAgICB2YXIgeTIgPSBwYXJzZUludCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgneTInKSB8fCAnMCcsIDEwKTtcbiAgICAgICAgdmFyIGdyYWRpZW50ID0gbmV3IExpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgX3BhcnNlR3JhZGllbnRDb2xvclN0b3BzKHhtbE5vZGUsIGdyYWRpZW50KTtcbiAgICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH1cbn07XG5mdW5jdGlvbiBfcGFyc2VHcmFkaWVudENvbG9yU3RvcHMoeG1sTm9kZSwgZ3JhZGllbnQpIHtcbiAgICB2YXIgc3RvcCA9IHhtbE5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoc3RvcCkge1xuICAgICAgICBpZiAoc3RvcC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldFN0ciA9IHN0b3AuZ2V0QXR0cmlidXRlKCdvZmZzZXQnKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0U3RyLmluZGV4T2YoJyUnKSA+IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwYXJzZUludChvZmZzZXRTdHIsIDEwKSAvIDEwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9mZnNldFN0cikge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHBhcnNlRmxvYXQob2Zmc2V0U3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RvcENvbG9yID0gc3RvcC5nZXRBdHRyaWJ1dGUoJ3N0b3AtY29sb3InKSB8fCAnIzAwMDAwMCc7XG4gICAgICAgICAgICBncmFkaWVudC5jb2xvclN0b3BzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgIGNvbG9yOiBzdG9wQ29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0b3AgPSBzdG9wLm5leHRTaWJsaW5nO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluaGVyaXRTdHlsZShwYXJlbnQsIGNoaWxkKSB7XG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuX19pbmhlcml0ZWRTdHlsZSkge1xuICAgICAgICBpZiAoIWNoaWxkLl9faW5oZXJpdGVkU3R5bGUpIHtcbiAgICAgICAgICAgIGNoaWxkLl9faW5oZXJpdGVkU3R5bGUgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0cyhjaGlsZC5fX2luaGVyaXRlZFN0eWxlLCBwYXJlbnQuX19pbmhlcml0ZWRTdHlsZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VQb2ludHMocG9pbnRzU3RyaW5nKSB7XG4gICAgdmFyIGxpc3QgPSB0cmltKHBvaW50c1N0cmluZykuc3BsaXQoRElMSU1JVEVSX1JFRyk7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIgeCA9IHBhcnNlRmxvYXQobGlzdFtpXSk7XG4gICAgICAgIHZhciB5ID0gcGFyc2VGbG9hdChsaXN0W2kgKyAxXSk7XG4gICAgICAgIHBvaW50cy5wdXNoKFt4LCB5XSk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG59XG52YXIgYXR0cmlidXRlc01hcCA9IHtcbiAgICAnZmlsbCc6ICdmaWxsJyxcbiAgICAnc3Ryb2tlJzogJ3N0cm9rZScsXG4gICAgJ3N0cm9rZS13aWR0aCc6ICdsaW5lV2lkdGgnLFxuICAgICdvcGFjaXR5JzogJ29wYWNpdHknLFxuICAgICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICAgICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdsaW5lRGFzaCcsXG4gICAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ2xpbmVEYXNoT2Zmc2V0JyxcbiAgICAnc3Ryb2tlLWxpbmVjYXAnOiAnbGluZUNhcCcsXG4gICAgJ3N0cm9rZS1saW5lam9pbic6ICdsaW5lSm9pbicsXG4gICAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ21pdGVyTGltaXQnLFxuICAgICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICAgICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgICAndGV4dC1hbGlnbic6ICd0ZXh0QWxpZ24nLFxuICAgICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAndGV4dEJhc2VsaW5lJ1xufTtcbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyh4bWxOb2RlLCBlbCwgZGVmcywgb25seUlubGluZVN0eWxlKSB7XG4gICAgdmFyIGRpc3AgPSBlbDtcbiAgICB2YXIgenJTdHlsZSA9IGRpc3AuX19pbmhlcml0ZWRTdHlsZSB8fCB7fTtcbiAgICBpZiAoeG1sTm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBwYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSh4bWxOb2RlLCBlbCk7XG4gICAgICAgIGV4dGVuZCh6clN0eWxlLCBwYXJzZVN0eWxlQXR0cmlidXRlKHhtbE5vZGUpKTtcbiAgICAgICAgaWYgKCFvbmx5SW5saW5lU3R5bGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHN2Z0F0dHJOYW1lIGluIGF0dHJpYnV0ZXNNYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlc01hcC5oYXNPd25Qcm9wZXJ0eShzdmdBdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKHN2Z0F0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6clN0eWxlW2F0dHJpYnV0ZXNNYXBbc3ZnQXR0ck5hbWVdXSA9IGF0dHJWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwLnN0eWxlID0gZGlzcC5zdHlsZSB8fCB7fTtcbiAgICB6clN0eWxlLmZpbGwgIT0gbnVsbCAmJiAoZGlzcC5zdHlsZS5maWxsID0gZ2V0UGFpbnQoenJTdHlsZS5maWxsLCBkZWZzKSk7XG4gICAgenJTdHlsZS5zdHJva2UgIT0gbnVsbCAmJiAoZGlzcC5zdHlsZS5zdHJva2UgPSBnZXRQYWludCh6clN0eWxlLnN0cm9rZSwgZGVmcykpO1xuICAgIGVhY2goW1xuICAgICAgICAnbGluZVdpZHRoJywgJ29wYWNpdHknLCAnZmlsbE9wYWNpdHknLCAnc3Ryb2tlT3BhY2l0eScsICdtaXRlckxpbWl0JywgJ2ZvbnRTaXplJ1xuICAgIF0sIGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICB6clN0eWxlW3Byb3BOYW1lXSAhPSBudWxsICYmIChkaXNwLnN0eWxlW3Byb3BOYW1lXSA9IHBhcnNlRmxvYXQoenJTdHlsZVtwcm9wTmFtZV0pKTtcbiAgICB9KTtcbiAgICBpZiAoIXpyU3R5bGUudGV4dEJhc2VsaW5lIHx8IHpyU3R5bGUudGV4dEJhc2VsaW5lID09PSAnYXV0bycpIHtcbiAgICAgICAgenJTdHlsZS50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gICAgfVxuICAgIGlmICh6clN0eWxlLnRleHRCYXNlbGluZSA9PT0gJ2FscGhhYmV0aWMnKSB7XG4gICAgICAgIHpyU3R5bGUudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgfVxuICAgIGlmICh6clN0eWxlLnRleHRBbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB6clN0eWxlLnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICB9XG4gICAgaWYgKHpyU3R5bGUudGV4dEFsaWduID09PSAnZW5kJykge1xuICAgICAgICB6clN0eWxlLnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgfVxuICAgIGVhY2goWydsaW5lRGFzaE9mZnNldCcsICdsaW5lQ2FwJywgJ2xpbmVKb2luJyxcbiAgICAgICAgJ2ZvbnRXZWlnaHQnLCAnZm9udEZhbWlseScsICdmb250U3R5bGUnLCAndGV4dEFsaWduJywgJ3RleHRCYXNlbGluZSdcbiAgICBdLCBmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgenJTdHlsZVtwcm9wTmFtZV0gIT0gbnVsbCAmJiAoZGlzcC5zdHlsZVtwcm9wTmFtZV0gPSB6clN0eWxlW3Byb3BOYW1lXSk7XG4gICAgfSk7XG4gICAgaWYgKHpyU3R5bGUubGluZURhc2gpIHtcbiAgICAgICAgZGlzcC5zdHlsZS5saW5lRGFzaCA9IG1hcCh0cmltKHpyU3R5bGUubGluZURhc2gpLnNwbGl0KERJTElNSVRFUl9SRUcpLCBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzcC5fX2luaGVyaXRlZFN0eWxlID0genJTdHlsZTtcbn1cbnZhciB1cmxSZWdleCA9IC91cmxcXChcXHMqIyguKj8pXFwpLztcbmZ1bmN0aW9uIGdldFBhaW50KHN0ciwgZGVmcykge1xuICAgIHZhciB1cmxNYXRjaCA9IGRlZnMgJiYgc3RyICYmIHN0ci5tYXRjaCh1cmxSZWdleCk7XG4gICAgaWYgKHVybE1hdGNoKSB7XG4gICAgICAgIHZhciB1cmwgPSB0cmltKHVybE1hdGNoWzFdKTtcbiAgICAgICAgdmFyIGRlZiA9IGRlZnNbdXJsXTtcbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbnZhciB0cmFuc2Zvcm1SZWdleCA9IC8odHJhbnNsYXRlfHNjYWxlfHJvdGF0ZXxza2V3WHxza2V3WXxtYXRyaXgpXFwoKFtcXC1cXHMwLTlcXC5lLF0qKVxcKS9nO1xuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUoeG1sTm9kZSwgbm9kZSkge1xuICAgIHZhciB0cmFuc2Zvcm0gPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm0ucmVwbGFjZSgvLC9nLCAnICcpO1xuICAgICAgICB2YXIgdHJhbnNmb3JtT3BzXzEgPSBbXTtcbiAgICAgICAgdmFyIG0gPSBudWxsO1xuICAgICAgICB0cmFuc2Zvcm0ucmVwbGFjZSh0cmFuc2Zvcm1SZWdleCwgZnVuY3Rpb24gKHN0ciwgdHlwZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybU9wc18xLnB1c2godHlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRyYW5zZm9ybU9wc18xLmxlbmd0aCAtIDE7IGkgPiAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybU9wc18xW2ldO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0cmFuc2Zvcm1PcHNfMVtpIC0gMV07XG4gICAgICAgICAgICB2YXIgdmFsdWVBcnIgPSB2b2lkIDA7XG4gICAgICAgICAgICBtID0gbSB8fCBtYXRyaXguY3JlYXRlKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0cmFuc2xhdGUnOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUFyciA9IHRyaW0odmFsdWUpLnNwbGl0KERJTElNSVRFUl9SRUcpO1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFtwYXJzZUZsb2F0KHZhbHVlQXJyWzBdKSwgcGFyc2VGbG9hdCh2YWx1ZUFyclsxXSB8fCAnMCcpXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NjYWxlJzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVBcnIgPSB0cmltKHZhbHVlKS5zcGxpdChESUxJTUlURVJfUkVHKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNjYWxlKG0sIG0sIFtwYXJzZUZsb2F0KHZhbHVlQXJyWzBdKSwgcGFyc2VGbG9hdCh2YWx1ZUFyclsxXSB8fCB2YWx1ZUFyclswXSldKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVBcnIgPSB0cmltKHZhbHVlKS5zcGxpdChESUxJTUlURVJfUkVHKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnJvdGF0ZShtLCBtLCBwYXJzZUZsb2F0KHZhbHVlQXJyWzBdKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NrZXcnOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUFyciA9IHRyaW0odmFsdWUpLnNwbGl0KERJTElNSVRFUl9SRUcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1NrZXcgdHJhbnNmb3JtIGlzIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21hdHJpeCc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlQXJyID0gdHJpbSh2YWx1ZSkuc3BsaXQoRElMSU1JVEVSX1JFRyk7XG4gICAgICAgICAgICAgICAgICAgIG1bMF0gPSBwYXJzZUZsb2F0KHZhbHVlQXJyWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgbVsxXSA9IHBhcnNlRmxvYXQodmFsdWVBcnJbMV0pO1xuICAgICAgICAgICAgICAgICAgICBtWzJdID0gcGFyc2VGbG9hdCh2YWx1ZUFyclsyXSk7XG4gICAgICAgICAgICAgICAgICAgIG1bM10gPSBwYXJzZUZsb2F0KHZhbHVlQXJyWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgbVs0XSA9IHBhcnNlRmxvYXQodmFsdWVBcnJbNF0pO1xuICAgICAgICAgICAgICAgICAgICBtWzVdID0gcGFyc2VGbG9hdCh2YWx1ZUFycls1XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUuc2V0TG9jYWxUcmFuc2Zvcm0obSk7XG4gICAgfVxufVxudmFyIHN0eWxlUmVnZXggPSAvKFteXFxzOjtdKylcXHMqOlxccyooW146O10rKS9nO1xuZnVuY3Rpb24gcGFyc2VTdHlsZUF0dHJpYnV0ZSh4bWxOb2RlKSB7XG4gICAgdmFyIHN0eWxlID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmFyIHN0eWxlTGlzdCA9IHt9O1xuICAgIHN0eWxlUmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgc3R5bGVSZWdSZXN1bHQ7XG4gICAgd2hpbGUgKChzdHlsZVJlZ1Jlc3VsdCA9IHN0eWxlUmVnZXguZXhlYyhzdHlsZSkpICE9IG51bGwpIHtcbiAgICAgICAgc3R5bGVMaXN0W3N0eWxlUmVnUmVzdWx0WzFdXSA9IHN0eWxlUmVnUmVzdWx0WzJdO1xuICAgIH1cbiAgICBmb3IgKHZhciBzdmdBdHRyTmFtZSBpbiBhdHRyaWJ1dGVzTWFwKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzTWFwLmhhc093blByb3BlcnR5KHN2Z0F0dHJOYW1lKSAmJiBzdHlsZUxpc3Rbc3ZnQXR0ck5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdFthdHRyaWJ1dGVzTWFwW3N2Z0F0dHJOYW1lXV0gPSBzdHlsZUxpc3Rbc3ZnQXR0ck5hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVZpZXdCb3hUcmFuc2Zvcm0odmlld0JveFJlY3QsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgc2NhbGVYID0gd2lkdGggLyB2aWV3Qm94UmVjdC53aWR0aDtcbiAgICB2YXIgc2NhbGVZID0gaGVpZ2h0IC8gdmlld0JveFJlY3QuaGVpZ2h0O1xuICAgIHZhciBzY2FsZSA9IE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgIHg6IC0odmlld0JveFJlY3QueCArIHZpZXdCb3hSZWN0LndpZHRoIC8gMikgKiBzY2FsZSArIHdpZHRoIC8gMixcbiAgICAgICAgeTogLSh2aWV3Qm94UmVjdC55ICsgdmlld0JveFJlY3QuaGVpZ2h0IC8gMikgKiBzY2FsZSArIGhlaWdodCAvIDJcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU1ZHKHhtbCwgb3B0KSB7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBTVkdQYXJzZXIoKTtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlKHhtbCwgb3B0KTtcbn1cbmV4cG9ydCB7IHBhcnNlWE1MIH07XG4iXSwic291cmNlUm9vdCI6IiJ9